[
    {
        "title": "Unique Paths",
        "question_content": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\nGiven the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\nThe test cases are generated so that the answer will be less than or equal to 2 * 109.\n&nbsp;\nExample 1:\n\nInput: m = 3, n = 7\nOutput: 28\n\nExample 2:\n\nInput: m = 3, n = 2\nOutput: 3\nExplanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Down -> Down\n2. Down -> Down -> Right\n3. Down -> Right -> Down\n\n&nbsp;\nConstraints:\n\n\t1 <= m, n <= 100",
        "solutions": [
            {
                "id": 22954,
                "title": "c-dp",
                "content": "Since the robot can only move right and down, when it arrives at a point, it either arrives from left or above. If we use `dp[i][j]` for the number of unique paths to arrive at the point `(i, j)`, then the state equation is `dp[i][j] = dp[i][j - 1] + dp[i - 1][j]`. Moreover, we have the base cases `dp[0][j] = dp[i][0] = 1` for all valid `i` and `j`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 1));\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n            }\\n        }\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```\\n\\nThe above solution runs in `O(m * n)` time and costs `O(m * n)` space. However, you may have noticed that each time when we update `dp[i][j]`, we only need `dp[i - 1][j]` (at the previous row) and `dp[i][j - 1]` (at the current row). So we can reduce the memory usage to just two rows (`O(n)`).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> pre(n, 1), cur(n, 1);\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                cur[j] = pre[j] + cur[j - 1];\\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[n - 1];\\n    }\\n};\\n```\\n\\nFurther inspecting the above code, `pre[j]` is just the `cur[j]` before the update. So we can further reduce the memory usage to one row.\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> cur(n, 1);\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                cur[j] += cur[j - 1];\\n            }\\n        }\\n        return cur[n - 1];\\n    }\\n};\\n```\\n\\nNow, you may wonder whether we can further reduce the memory usage to just `O(1)` space since the above code seems to use only two variables (`cur[j]` and `cur[j - 1]`). However, since the whole row `cur` needs to be updated for `m - 1` times (the outer loop) based on old values, all of its values need to be saved and thus `O(1)`-space is impossible. However, if you are having a DP problem without the outer loop and just the inner one, then it will be possible.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 1));\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n            }\\n        }\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> pre(n, 1), cur(n, 1);\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                cur[j] = pre[j] + cur[j - 1];\\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[n - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> cur(n, 1);\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                cur[j] += cur[j - 1];\\n            }\\n        }\\n        return cur[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581998,
                "title": "c-python-5-simple-solutions-w-explanation-optimization-from-brute-force-to-dp-to-math",
                "content": "We are given a `m x n` grid where we start at cell `(0, 0)` (top-left) and are required to move to the cell `(m-1, n-1)` (bottom-right). We can only move to the right or to the bottom. We need to return total unique paths from start to end using these moves.\\n\\n---\\n\\n\\u274C ***Solution - I (Brute-Force) [TLE]***\\n\\nLet\\'s start with brute-force solution. For a path to be unique, at atleast 1 of move must differ at some cell within that path. \\n* At each cell we can either move down or move right. \\n* Choosing either of these moves could lead us to an unique path\\n* So we consider both of these moves. \\n* If the series of moves leads to a cell outside the grid\\'s boundary, we can return 0 denoting no valid path was found.\\n* If the series of moves leads us to the target cell `(m-1, n-1)`, we return 1 denoting we found a valid unique path from start to end.\\n\\n<p align=middle>\\n<img src=\"https://assets.leetcode.com/users/images/d974e3c6-3aca-4652-9811-d5505d963526_1637119284.4824865.png\" />\\n</p>\\n\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n, int i = 0, int j = 0) {\\n        if(i >= m || j >= n) return 0;                                    // reached out of bounds - invalid\\n        if(i == m-1 && j == n-1) return 1;                                // reached the destination - valid solution\\n        return uniquePaths(m, n, i+1, j) + uniquePaths(m, n, i, j+1);     // try both down and right\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def uniquePaths(self, m, n, i=0, j=0):\\n        if i >= m or j >= n:      return 0\\n        if i == m-1 and j == n-1: return 1\\n        return self.uniquePaths(m, n, i+1, j) + self.uniquePaths(m, n, i, j+1)\\n```\\n\\n\\n***Time Complexity :*** **<code>O(2<sup>m+n</sup>)</code>**, where `m` and `n` are the given input dimensions of the grid\\n***Space Complexity :*** **<code>O(m+n)</code>**, required by implicit recursive stack\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Dynamic Programming - Memoization)***\\n\\nThe above solution had a lot of redundant calculations. There are many cells which we reach multiple times and calculate the answer for it over and over again. However, the number of unique paths from a given cell `(i,j)` to the end cell is always fixed. So, we dont need to calculate and repeat the same process for a given cell multiple times. We can just store (or memoize) the result calculated for cell `(i, j)` and use that result in the future whenever required.\\n\\nThus, here we use a 2d array `dp`, where `dp[i][j]` denote the number of unique paths from cell `(i, j)` to the end cell `(m-1, n-1)`. Once we get an answer for cell `(i, j)`, we store the result in `dp[i][j]` and reuse it instead of recalculating it.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int dp[101][101]{};\\n    int uniquePaths(int m, int n, int i = 0, int j = 0) {\\n        if(i >= m || j >= n) return 0;\\n        if(i == m-1 && j == n-1) return 1;\\n        if(dp[i][j]) return dp[i][j];\\n        return dp[i][j] = uniquePaths(m, n, i+1, j) + uniquePaths(m, n, i, j+1);\\n    }\\n};\\n```\\n\\nA more generalized solution should be as follows -\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n));\\n        return dfs(dp, 0, 0);\\n    }\\n    int dfs(vector<vector<int>>& dp, int i, int j) {\\n        if(i >= size(dp)   || j >= size(dp[0]))   return 0;     // out of bounds - invalid\\n        if(i == size(dp)-1 && j == size(dp[0])-1) return 1;     // reached end - valid path\\n        if(dp[i][j]) return dp[i][j];                           // directly return if already calculated\\n        return dp[i][j] = dfs(dp, i+1, j) + dfs(dp, i, j+1);    // store the result in dp[i][j] and then return\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        @cache\\n        def dfs(i, j):\\n            if i >= m or j >= n:      return 0\\n            if i == m-1 and j == n-1: return 1\\n            return dfs(i+1, j) + dfs(i, j+1)\\n        return dfs(0, 0)\\n```\\n\\n\\n***Time Complexity :*** **<code>O(m*n)</code>**, the answer to each of cell is calculated only once and memoized. There are `m*n` cells in total and thus this process takes `O(m*n)` time.\\n***Space Complexity :*** **<code>O(m*n)</code>**, required to maintain `dp`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Dynamic Programming - Tabulation)***\\n\\nWe can also convert the above appraoch to an iterative version. Here, we will solve it in bottom-up manner by iteratively calculating the number of unique paths to reach cell `(i, j)` starting from `(0, 0)` where `0 <= i <= m-1` and `0 <= j <= n-1`. We will again use dynamic programming here using a `dp` matrix where `dp[i][j]` will denote the number of unique paths from cell `(0, 0)` the cell `(i, j)`. (Note this differs from memoization appraoch where `dp[i][j]` denoted number of unique paths from cell `(i, j)` to the cell `(m-1,n-1)`)\\n\\nIn this case, we first establish some base conditions first. \\n* We start at cell `(0, 0)`, so `dp[0][0] = 1`. \\n* Since we can only move right or down, there is only one way to reach a cell  `(i, 0)` or `(0, j)`. Thus, we also initialize `dp[i][0] = 1` and `dp[0][j]=1`.\\n* For every other cell `(i, j)` (where `1 <= i  <= m-1` and `1 <= j <= n-1`), we can reach here either from the top cell `(i-1, j)` or the left cell `(i, j-1)`. So the result for number of unique paths to arrive at `(i, j)` is the summation of both, i.e, `dp[i][j] = dp[i-1][j] + dp[i][j-1]`.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 1));\\n        for(int i = 1; i < m; i++)\\n            for(int j = 1; j < n; j++)\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];   // sum of unique paths ending at adjacent top and left cells\\n        return dp[m-1][n-1];         // return unique paths ending at cell (m-1, n-1)\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        dp = [[1]*n for i in range(m)]\\n        for i, j in product(range(1, m), range(1, n)):\\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n        return dp[-1][-1]\\n```\\n\\n***Time Complexity :*** **<code>O(m*n)</code>**, we are computing `dp` values for each of the `m*n` cells from the previous cells value. Thus, the total number of iterations performed is requires a time of `O(m*n)`.\\n***Space Complexity :*** **<code>O(m*n)</code>**, required to maintain the `dp` matrix\\n\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - IV (Space Optimized Dynamic Programming)***\\n\\nIn the above solution, we can observe that to compute the `dp` matrix, we are only ever using the cells from previous row and the current row. So, we don\\'t really need to maintain the entire `m x n` matrix of `dp`. We can optimize the space usage by only keeping the current and previous rows.\\n\\nA common way in `dp` problems to optimize space from 2d dp is just to convert the `dp` matrix from `m x n` grid to `2 x n` grid denoting the values for current and previous row. We can just overwrite the previous row and use the current row as the previous row for next iteration. We can simply alternate between these rows using the `& (AND)` operator as can be seen below -\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(2, vector<int>(n,1));\\n        for(int i = 1; i < m; i++)\\n            for(int j = 1; j < n; j++)\\n                dp[i & 1][j] = dp[(i-1) & 1][j] + dp[i & 1][j-1];   // <- &  used to alternate between rows\\n        return dp[(m-1) & 1][n-1];\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        dp = [[1]*n for i in range(2)]\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                dp[i&1][j] = dp[(i-1)&1][j] + dp[i&1][j-1]\\n        return dp[(m-1)&1][-1]\\n```\\n\\nOr still better yet, in this case, you can use a single vector as well. We are only accessing same column from previous row which can be given by `dp[j]` and previous column of current row which can be given by `dp[j-1]`. So the above code can be further simplfied to (Credits - [@zayne-siew](https://leetcode.com/zayne-siew)) -\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> dp(n, 1);\\n        for(int i = 1; i < m; i++)\\n            for(int j = 1; j < n; j++)\\n                dp[j] += dp[j-1];   \\n        return dp[n-1];\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        dp = [1]*n\\n        for _, j in product(range(1, m), range(1, n)):\\n            dp[j] += dp[j-1]\\n        return dp[-1]\\n```\\n\\n***Time Complexity :*** **<code>O(m*n)</code>**, for computing dp values for each of the `m*n` cells.\\n***Space Complexity :*** **<code>O(n)</code>**, required to maintain `dp`. We are only keeping two rows of length `n` giving space complexity of `O(n)`.\\nThere\\'s a small change that can allow us to optimize the space complexity down to `O(min(m, n))`. \\n*Comment below if you can figure it out :)*\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - V (Math)***\\n\\nThis problem can be modelled as a math combinatorics problem. \\n\\n<p align=middle>\\n<img src=\"https://assets.leetcode.com/users/images/2a074864-a70f-462f-a351-531fa191b157_1637118583.158331.png\" width=560 />\\n</p>\\n\\n* We start at `(0, 0)` cell and move to `(m-1, n-1)` cell. \\n* We need to make **`m-1` down-moves** and **`n-1` right-moves** to reach the destination cell. \\n* Thus, we need to perform a **total number of `m+n-2` moves**.\\n* At each cell along the path, we can choose either the right-move or down-move and we need to find the number of unique combinations of these choices (which eventually leads to unique paths).\\n* This is nothing but calculating the **number of different ways to choose `m-1` down-moves and `n-1` right-moves from a total of `m+n-2` moves**. Mathematically, this can be represented as -\\n\\n\\n\\n\\n<p align=middle>\\n<img src=\"https://assets.leetcode.com/users/images/8b8a877c-f29f-46a9-b541-149ae4ee3468_1637114902.8508475.png\" width=700 />\\n</p>\\n\\nWe could cancel out the `(n-1)!` as well  in the above evaluation. We will do one of those based on min(m,n) to give best time complexity in the solution below.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        long ans = 1;\\n        for(int i = m+n-2, j = 1; i >= max(m, n); i--, j++) \\n            ans = (ans * i) / j;\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        return factorial(m+n-2) // factorial(m-1) // factorial(n-1)\\n```\\n\\n\\n***Time Complexity :*** **<code>O(min(m,n))</code>** for C++, and **<code>O(m+n)</code>** for Python. We could do it in `O(min(m,n))` for python as well using technique used in C++.\\n***Space Complexity :*** **<code>O(1)</code>**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n, int i = 0, int j = 0) {\\n        if(i >= m || j >= n) return 0;                                    // reached out of bounds - invalid\\n        if(i == m-1 && j == n-1) return 1;                                // reached the destination - valid solution\\n        return uniquePaths(m, n, i+1, j) + uniquePaths(m, n, i, j+1);     // try both down and right\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def uniquePaths(self, m, n, i=0, j=0):\\n        if i >= m or j >= n:      return 0\\n        if i == m-1 and j == n-1: return 1\\n        return self.uniquePaths(m, n, i+1, j) + self.uniquePaths(m, n, i, j+1)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int dp[101][101]{};\\n    int uniquePaths(int m, int n, int i = 0, int j = 0) {\\n        if(i >= m || j >= n) return 0;\\n        if(i == m-1 && j == n-1) return 1;\\n        if(dp[i][j]) return dp[i][j];\\n        return dp[i][j] = uniquePaths(m, n, i+1, j) + uniquePaths(m, n, i, j+1);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n));\\n        return dfs(dp, 0, 0);\\n    }\\n    int dfs(vector<vector<int>>& dp, int i, int j) {\\n        if(i >= size(dp)   || j >= size(dp[0]))   return 0;     // out of bounds - invalid\\n        if(i == size(dp)-1 && j == size(dp[0])-1) return 1;     // reached end - valid path\\n        if(dp[i][j]) return dp[i][j];                           // directly return if already calculated\\n        return dp[i][j] = dfs(dp, i+1, j) + dfs(dp, i, j+1);    // store the result in dp[i][j] and then return\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        @cache\\n        def dfs(i, j):\\n            if i >= m or j >= n:      return 0\\n            if i == m-1 and j == n-1: return 1\\n            return dfs(i+1, j) + dfs(i, j+1)\\n        return dfs(0, 0)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 1));\\n        for(int i = 1; i < m; i++)\\n            for(int j = 1; j < n; j++)\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];   // sum of unique paths ending at adjacent top and left cells\\n        return dp[m-1][n-1];         // return unique paths ending at cell (m-1, n-1)\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        dp = [[1]*n for i in range(m)]\\n        for i, j in product(range(1, m), range(1, n)):\\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n        return dp[-1][-1]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(2, vector<int>(n,1));\\n        for(int i = 1; i < m; i++)\\n            for(int j = 1; j < n; j++)\\n                dp[i & 1][j] = dp[(i-1) & 1][j] + dp[i & 1][j-1];   // <- &  used to alternate between rows\\n        return dp[(m-1) & 1][n-1];\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        dp = [[1]*n for i in range(2)]\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                dp[i&1][j] = dp[(i-1)&1][j] + dp[i&1][j-1]\\n        return dp[(m-1)&1][-1]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> dp(n, 1);\\n        for(int i = 1; i < m; i++)\\n            for(int j = 1; j < n; j++)\\n                dp[j] += dp[j-1];   \\n        return dp[n-1];\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        dp = [1]*n\\n        for _, j in product(range(1, m), range(1, n)):\\n            dp[j] += dp[j-1]\\n        return dp[-1]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        long ans = 1;\\n        for(int i = m+n-2, j = 1; i >= max(m, n); i--, j++) \\n            ans = (ans * i) / j;\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        return factorial(m+n-2) // factorial(m-1) // factorial(n-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22958,
                "title": "math-solution-o-1-space",
                "content": "This is a combinatorial problem and can be solved without DP. For mxn grid, robot has to move exactly m-1 steps down and n-1 steps right and these can be done in any order.\\n\\nFor the eg., given in question, 3x7 matrix, robot needs to take 2+6 = 8 steps with 2 down and 6 right in any order. That is nothing but a permutation problem. Denote down as 'D' and right as 'R', following is one of the path :-\\n\\nD R R R D R R R\\n\\nWe have to tell the total number of permutations of the above given word. So, decrease both m & n by 1 and apply following formula:-\\n\\nTotal permutations = (m+n)! / (m! * n!)\\n\\nFollowing is my code doing the same :-\\n\\n    public class Solution {\\n        public int uniquePaths(int m, int n) {\\n            if(m == 1 || n == 1)\\n                return 1;\\n            m--;\\n            n--;\\n            if(m < n) {              // Swap, so that m is the bigger number\\n                m = m + n;\\n                n = m - n;\\n                m = m - n;\\n            }\\n            long res = 1;\\n            int j = 1;\\n            for(int i = m+1; i <= m+n; i++, j++){       // Instead of taking factorial, keep on multiply & divide\\n                res *= i;\\n                res /= j;\\n            }\\n                \\n            return (int)res;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Combinatorics"
                ],
                "code": "class Solution {\\n        public int uniquePaths(int m, int n) {\\n            if(m == 1 || n == 1)\\n                return 1;\\n            m--;\\n            n--;\\n            if(m < n) {              // Swap, so that m is the bigger number\\n                m = m + n;\\n                n = m - n;\\n                m = m - n;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 182143,
                "title": "recursive-memoization-and-dynamic-programming-solutions",
                "content": "Recursive (Time limit exceed for bigger values) \\n```\\nclass Solution {\\n  public int uniquePaths(int m, int n) {\\n    return uniquePathsHelper(m - 1, n - 1);\\n  }\\n  \\n  private int uniquePathsHelper(int m, int n) {\\n    if (m < 0 || n < 0) {\\n      return 0;\\n    } else if (m == 0 || n == 0) {\\n      return 1;\\n    } else {\\n      return uniquePathsHelper(m - 1, n) + uniquePathsHelper(m, n - 1);\\n    }\\n  }\\n}\\n```\\n\\nMemoization (Runtime 0 ms, Time complexity m x n, Space complexity: m x n):\\n```\\nclass Solution {\\n  public int uniquePaths(int m, int n) {\\n    return uniquePathsHelper(m - 1, n - 1, new int[n][m]);\\n  }\\n  \\n  private int uniquePathsHelper(int m, int n, int[][] memo) {\\n    if (m < 0 || n < 0) {\\n      return 0;\\n    } else if (m == 0 || n == 0) {\\n      return 1;\\n    } else if (memo[n][m] > 0) {\\n      return memo[n][m];\\n    } else {\\n      memo[n][m] = uniquePathsHelper(m - 1, n, memo) + uniquePathsHelper(m, n - 1, memo);\\n      return memo[n][m];\\n    }\\n  }\\n} \\n```\\n\\nDynamic programming (Runtime 1 ms, Time complexity m x n, Space complexity: m x n)\\n``` \\nclass Solution {\\n  public int uniquePaths(int m, int n) {\\n    int[][] grid = new int[n][m];\\n    \\n    for (int i = 0; i < n; i++) {\\n      for (int j = 0; j < m; j++) {\\n        if (i == 0) grid[0][j] = 1;\\n        if (j == 0) grid[i][j] = 1;\\n        if (i != 0 && j != 0) {\\n          int up = grid[i - 1][j];\\n          int left = grid[i][j - 1];\\n          grid[i][j] = up + left;\\n        }\\n      }\\n    }\\n    return grid[n - 1][m - 1];\\n  }\\n} \\n```\\n\\nUpdate: Apologies for not checking the comments and for not updating the solution(s). I performed a small refactor for the third one (seems cleaner to me now). As per Recursive time complexity we have O(2 ^ (m + n)) - we know that the formula we use to determine the time complexity for recursivity is branches ^ depth. In our case we have 2 possible branches (going up and going left), while for the depth, is the maximum possible distance taken to get 0,0 which is m + n. Given this, we can also mention the space complexity taken on the stack O(m + n);\\n\\nAlso: https://stackoverflow.com/questions/6184869/what-is-the-difference-between-memoization-and-dynamic-programming\\n\\nThank you for the comments and useful hints!\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public int uniquePaths(int m, int n) {\\n    return uniquePathsHelper(m - 1, n - 1);\\n  }\\n  \\n  private int uniquePathsHelper(int m, int n) {\\n    if (m < 0 || n < 0) {\\n      return 0;\\n    } else if (m == 0 || n == 0) {\\n      return 1;\\n    } else {\\n      return uniquePathsHelper(m - 1, n) + uniquePathsHelper(m, n - 1);\\n    }\\n  }\\n}\\n```\n```\\nclass Solution {\\n  public int uniquePaths(int m, int n) {\\n    return uniquePathsHelper(m - 1, n - 1, new int[n][m]);\\n  }\\n  \\n  private int uniquePathsHelper(int m, int n, int[][] memo) {\\n    if (m < 0 || n < 0) {\\n      return 0;\\n    } else if (m == 0 || n == 0) {\\n      return 1;\\n    } else if (memo[n][m] > 0) {\\n      return memo[n][m];\\n    } else {\\n      memo[n][m] = uniquePathsHelper(m - 1, n, memo) + uniquePathsHelper(m, n - 1, memo);\\n      return memo[n][m];\\n    }\\n  }\\n} \\n```\n``` \\nclass Solution {\\n  public int uniquePaths(int m, int n) {\\n    int[][] grid = new int[n][m];\\n    \\n    for (int i = 0; i < n; i++) {\\n      for (int j = 0; j < m; j++) {\\n        if (i == 0) grid[0][j] = 1;\\n        if (j == 0) grid[i][j] = 1;\\n        if (i != 0 && j != 0) {\\n          int up = grid[i - 1][j];\\n          int left = grid[i][j - 1];\\n          grid[i][j] = up + left;\\n        }\\n      }\\n    }\\n    return grid[n - 1][m - 1];\\n  }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 22981,
                "title": "my-ac-solution-using-formula",
                "content": "Binomial coefficient:\\n \\n\\n    class Solution {\\n        public:\\n            int uniquePaths(int m, int n) {\\n                int N = n + m - 2;// how much steps we need to do\\n                int k = m - 1; // number of steps that need to go down\\n                double res = 1;\\n                // here we calculate the total possible path number \\n                // Combination(N, k) = n! / (k!(n - k)!)\\n                // reduce the numerator and denominator and get\\n                // C = ( (n - k + 1) * (n - k + 2) * ... * n ) / k!\\n                for (int i = 1; i <= k; i++)\\n                    res = res * (N - k + i) / i;\\n                return (int)res;\\n            }\\n        };\\n\\nFirst of all you should understand that we need to do n + m - 2 movements : m - 1 down, n - 1 right, because we start from cell (1, 1).\\n\\nSecondly, the path it is the sequence of movements( go down / go right), \\ntherefore we can say that two paths are different \\nwhen there is  i-th (1 .. m + n - 2)  movement in path1 differ  i-th movement in path2.\\n\\nSo, how we can build paths.\\nLet's choose (n - 1) movements(number of steps to the right) from (m + n - 2), \\nand rest (m - 1) is (number of steps down).\\n\\nI think now it is obvious that count of different paths are all combinations (n - 1) movements from (m + n-2).",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int uniquePaths(int m, int n) {\\n                int N = n + m - 2;// how much steps we need to do\\n                int k = m - 1; // number of steps that need to go down\\n                double res = 1;\\n                // here we calculate the total possible path number \\n                // Combination(N, k) = n! / (k!(n - k)!)\\n                // reduce the numerator and denominator and get\\n                // C = ( (n - k + 1) * (n - k + 2) * ... * n ) / k!\\n                for (int i = 1; i <= k; i++)\\n                    res = res * (N - k + i) / i;\\n                return (int)res;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 22953,
                "title": "java-dp-solution-with-complexity-o-n-m",
                "content": "   \\n\\n     public class Solution {\\n        public int uniquePaths(int m, int n) {\\n            Integer[][] map = new Integer[m][n];\\n            for(int i = 0; i<m;i++){\\n                map[i][0] = 1;\\n            }\\n            for(int j= 0;j<n;j++){\\n                map[0][j]=1;\\n            }\\n            for(int i = 1;i<m;i++){\\n                for(int j = 1;j<n;j++){\\n                    map[i][j] = map[i-1][j]+map[i][j-1];\\n                }\\n            }\\n            return map[m-1][n-1];\\n        }\\n    }\\n\\n\\nThe assumptions are \\n\\n 1. When (n==0||m==0) the function always returns 1 since the robot\\n    can't go left or up.\\n 2. For all other cells. The result = uniquePaths(m-1,n)+uniquePaths(m,n-1)\\n\\nTherefore I populated the edges with 1 first and use DP to get the full 2-D array.\\n\\nPlease give any suggestions on improving the code.",
                "solutionTags": [],
                "code": "class Solution {\\n        public int uniquePaths(int m, int n) {\\n            Integer[][] map = new Integer[m][n];\\n            for(int i = 0; i<m;i++){\\n                map[i][0] = 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1582051,
                "title": "c-easy-intuitive-solution-combinatorics-tc-o-min-m-n-sc-o-1-beats-100",
                "content": "Hello everyone, I hope you all are doing great.\\n***Note: Please do upvote if you find this post helpful!***\\n\\nThis is a combinatorics problem that can be easily solved without DP or recursion.\\n\\n**Observation:** If you observe it care fully, our robot has to move `n-1` steps right and `m-1` steps down in any order to reach the right bottom of the grid. You will understand this more with the following example.\\n\\n**Example:** We had `3x7` grid, robot needs to take `(3-1) = 2` steps down overall and `7-1 = 6` steps right overall to reach the bottom right of the grid. This is a total of 8 steps. And the ordering doesn\\'t matter like: `D D R R R R R R` or `D R D R R R R R` or `R R R R R R D D` will all do the job, and all of this is noting but the permutation of total steps. So this is nothing but number of ways of choose `D` in the `8` blanks or number of ways of choosing `R` in the 8 blanks which is nothing but `8C6` or `8C2` ` = 28` (both will do the job) [Someone please tell me how to type nCr the way it looks on this discussion post \\uD83D\\uDE02]\\n\\n**Approach:** So, we only need to choose number of ways of picking **right** from the total steps or number of ways of choosing **down** from the total steps. Which is nothing but `(total) C (right)` or `(total) C (down)`.\\n\\nCode for the implementation of my approach:\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int N = n+m-2; // total steps = n-1 + m-1\\n        int r = min(n,m) - 1; // will iterate on the minimum for efficiency = (total) C (min(right, down))\\n        \\n        double res = 1;\\n        \\n\\t\\t// compute nCr\\n        for(int i=1; i<=r; ++i, N--){\\n            \\n            res = res * (N) / i;\\n        }\\n        \\n        return (int)res;\\n    }\\n};\\n```\\n\\n**Time Complexity:** ***O(min(n, m))***\\n**Space Complexity:** ***O(1)***\\n\\n***Note: Please do upvote if you find this post helpful!***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int N = n+m-2; // total steps = n-1 + m-1\\n        int r = min(n,m) - 1; // will iterate on the minimum for efficiency = (total) C (min(right, down))\\n        \\n        double res = 1;\\n        \\n\\t\\t// compute nCr\\n        for(int i=1; i<=r; ++i, N--){\\n            \\n            res = res * (N) / i;\\n        }\\n        \\n        return (int)res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254228,
                "title": "python-3-solutions-bottom-up-dp-math-picture-explained-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Bottom up DP**\\n- Let `dp[r][c]` is number of paths to move from `[0, 0]` to `[r, c]`.\\n- Then `dp[m-1][n-1]` is our result.\\n- There are maximum 2 ways to cell `(r, c)`, that is:\\n\\t- From upper cell, `dp[r][c] += dp[r-1][c]`\\n\\t- From left cell, `dp[r][c] += dp[r][c-1]`\\n```python\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[0] * n for _ in range(m)]\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0 or c == 0:\\n                    dp[r][c] = 1\\n                else:\\n                    dp[r][c] = dp[r-1][c] + dp[r][c-1]\\n        return dp[m-1][n-1]\\n```\\n**Complexity**\\n- Time: `O(M*N)`, where `M <= 100` is number of rows, `N <= 100` is number of columns.\\n- Space: `O(M*N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Bottom up DP (Space Optimized)**\\n- Since we only access 2 states: current state `dp` and previous state `dpPrev`, we can reduce the space complexity to `O(M)`.\\n```python\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp, dpPrev = [0] * n, [0] * n\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0 or c == 0:\\n                    dp[c] = 1\\n                else:\\n                    dp[c] = dpPrev[c] + dp[c-1]\\n            dp, dpPrev = dpPrev, dp\\n        return dpPrev[n-1]\\n```\\n**Complexity**\\n- Time: `O(M*N)`, where `M <= 100` is number of rows, `N <= 100` is number of columns.\\n- Space: `O(M)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Math Solution**\\n- There are total `m+n-2` moves to go from **Top-Left** to **Bottom-Right**. \\n- In `m+n-2` moves, there are `m-1` **down moves** and `n-1` **right moves**.\\n- You can imagine there are `m+n-2` moves as: `X X X ... X X X`\\n\\t- `X` can be one of two values: down `D` or right `R`.\\n\\t- So, basically, it means we need to calculate how many ways we could choose `m-1` **down moves** from `m+n-2` moves, or `n-1` **right moves** from `m+n-2` moves.\\n- So total ways = `C(m+n-2, m-1)` = `C(m+n-2, n-1)` = `(m+n-2)! / (m-1)! / (n-1)!`.\\n\\n![image](https://assets.leetcode.com/users/images/625a19e1-383a-41a9-8628-0850e390cf91_1632765391.8825638.png)\\n\\n\\n```python\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        return factorial(m+n-2) // factorial(n-1) // factorial(m-1)\\n```\\nOr\\n```python\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        ans = 1\\n        j = 1\\n        for i in range(m, m+n-2 + 1):\\n            ans *= i\\n            ans //= j\\n            j += 1\\n            \\n        return ans\\n```\\n**Complexity**\\n- Time: `O(M + N)`, where `M <= 100` is number of rows, `N <= 100` is number of columns.\\n- Space: `O(1)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[0] * n for _ in range(m)]\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0 or c == 0:\\n                    dp[r][c] = 1\\n                else:\\n                    dp[r][c] = dp[r-1][c] + dp[r][c-1]\\n        return dp[m-1][n-1]\\n```\n```python\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp, dpPrev = [0] * n, [0] * n\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0 or c == 0:\\n                    dp[c] = 1\\n                else:\\n                    dp[c] = dpPrev[c] + dp[c-1]\\n            dp, dpPrev = dpPrev, dp\\n        return dpPrev[n-1]\\n```\n```python\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        return factorial(m+n-2) // factorial(n-1) // factorial(m-1)\\n```\n```python\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        ans = 1\\n        j = 1\\n        for i in range(m, m+n-2 + 1):\\n            ans *= i\\n            ans //= j\\n            j += 1\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22980,
                "title": "clean-and-simple-dp-java",
                "content": "    public class Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] grid = new int[m][n];\\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                if(i==0||j==0)\\n                    grid[i][j] = 1;\\n                else\\n                    grid[i][j] = grid[i][j-1] + grid[i-1][j];\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] grid = new int[m][n];\\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                if(i==0||j==0)\\n                    grid[i][j] = 1;\\n                else\\n                    grid[i][j] = grid[i][j-1] + grid[i-1][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 23234,
                "title": "accpeted-simple-python-dp-solution",
                "content": "    class Solution:\\n        # @return an integer\\n        def uniquePaths(self, m, n):\\n            aux = [[1 for x in range(n)] for x in range(m)]\\n            for i in range(1, m):\\n                for j in range(1, n):\\n                    aux[i][j] = aux[i][j-1]+aux[i-1][j]\\n            return aux[-1][-1]",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @return an integer\\n        def uniquePaths(self, m, n):\\n            aux = [[1 for x in range(n)] for x in range(m)]\\n            for i in range(1, m):\\n                for j in range(1, n):\\n                    aux[i][j] = aux[i][j-1]+aux[i-1][j]\\n            return aux[-1][-1]",
                "codeTag": "Java"
            },
            {
                "id": 405983,
                "title": "easy-understand-java-solutions-with-explanations-dp-top-down-bottom-up-linear-space",
                "content": "## Problem\\n\\n> A robot is located at the top-left corner of a `m x n` grid (marked \\'Start\\' in the diagram below).\\n\\n> The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked \\'Finish\\' in the diagram below).\\n\\n> How many possible unique paths are there?\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/bu9wv.jpg)\\n\\n**Note:** `m` and `n` will be at most 100.\\n\\n**Example:** \\n\\n```java\\nInput: m = 1, n = 1\\nOutput: 1\\n\\nInput: m = 3, n = 2\\nOutput: 3\\n\\nInput: m = 7, n = 3\\nOutput: 28\\n```\\n\\n\\n## Analysis\\n\\n### Recursion\\n\\nCheck out the comments.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/ljcsc.png)\\n\\n```java\\n// Define: opt(i, j) the number of ways to the point (i, j)\\n// (0, 0) is the starting point, (m - 1, n - 1) is the finish point\\n// Recurrence: opt(i, j) = opt(i - 1, j) + opt(i, j - 1)\\n// Init: opt(0, 0) = 1, opt(0, j) = opt(i, 0) = 1\\npublic int uniquePaths(int m, int n) {\\n  if (m == 0 || n == 0) {\\n    throw new IllegalArgumentException(\"m or n can\\'t be 0\");\\n  }\\n  return numPaths(m - 1, n - 1);\\n}\\n\\nprivate int numPaths(int i, int j) {\\n  if (i == 0 || j == 0) { // includes the row 0 and col 0\\n    return 1;\\n  }\\n  return numPaths(i - 1, j) + numPaths(i, j - 1);\\n}\\n```\\n\\n**Time:** `O(2^{M + N})`\\n**Space:** `O(M + N)`\\n\\nRecurrence Tree for complexity analysis:\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/8pax9.jpg)\\n\\n\\n\\n### DP (Top-down with Memoization)\\n\\nUse an 2D array `mem` to do memoization.\\n\\n```java\\npublic int uniquePaths(int m, int n) {\\n  if (m == 0 || n == 0) {\\n    throw new IllegalArgumentException(\"m or n can\\'t be 0\");\\n  }\\n  int[][] mem = new int[m][n];\\n  for (int i = 0; i < m; ++i) { // init\\n    for (int j = 0; j < n; ++j) {\\n      mem[i][j] = -1;\\n    }\\n  }\\n  return numPaths(m - 1, n - 1, mem);\\n}\\n\\nprivate int numPaths(int i, int j, int[][] mem) {\\n  if (i == 0 || j == 0) {\\n    return 1;\\n  }\\n  if (mem[i - 1][j] == -1) mem[i - 1][j] = numPaths(i - 1, j, mem);\\n  if (mem[i][j - 1] == -1) mem[i][j - 1] = numPaths(i, j - 1, mem);\\n  return mem[i - 1][j] + mem[i][j - 1];\\n}\\n```\\n\\n**Time:** `O(MN)` where `MN` is the number of subproblems.\\n**Space:** `O(MN)`\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/fbu40.jpg)\\n\\n### DP (Bottom-up)\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/bckom.png)\\n\\n```java\\npublic int uniquePaths(int m, int n) {\\n  if (m == 0 || n == 0) {\\n    throw new IllegalArgumentException(\"m or n can\\'t be 0\");\\n  }\\n  int[][] dp = new int[m][n];\\n  // init\\n  for (int i = 0; i < m; ++i) dp[i][0] = 1;\\n  for (int i = 0; i < n; ++i) dp[0][i] = 1;\\n  // dp\\n  for (int i = 1; i < m; ++i) {\\n    for (int j = 1; j < n; ++j) {\\n      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n    }\\n  }\\n  return dp[m - 1][n - 1];\\n}\\n```\\n\\n**Time:** `O(MN)`\\n**Space:** `O(MN)`\\n\\n\\n\\n\\n### DP (Bottom-up, Linear Space)\\n\\nReduce the $O(MN)$ space complexity to $O(N)$ (a row) or $O(M)$ (a column). In terms of a row, we would update `dp[j]` by its old value plus `dp[j - 1]`.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/2usv6.png)\\n\\n\\n```java\\npublic int uniquePaths(int m, int n) {\\n  if (m == 0 || n == 0) {\\n    throw new IllegalArgumentException(\"m or n can\\'t be 0\");\\n  }\\n  int[] dp = new int[n]; // row\\n  // init\\n  for (int i = 0; i < n; ++i) dp[i] = 1;\\n  // dp\\n  for (int i = 1; i < m; ++i) {\\n    for (int j = 1; j < n; ++j) {\\n      dp[j] = dp[j] + dp[j - 1];\\n    }\\n  }\\n  return dp[n - 1];\\n}\\n```\\n\\n**Time:** `O(MN)`\\n**Space:** `O(N)` or `O(M)`",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nInput: m = 1, n = 1\\nOutput: 1\\n\\nInput: m = 3, n = 2\\nOutput: 3\\n\\nInput: m = 7, n = 3\\nOutput: 28\\n```\n```java\\n// Define: opt(i, j) the number of ways to the point (i, j)\\n// (0, 0) is the starting point, (m - 1, n - 1) is the finish point\\n// Recurrence: opt(i, j) = opt(i - 1, j) + opt(i, j - 1)\\n// Init: opt(0, 0) = 1, opt(0, j) = opt(i, 0) = 1\\npublic int uniquePaths(int m, int n) {\\n  if (m == 0 || n == 0) {\\n    throw new IllegalArgumentException(\"m or n can\\'t be 0\");\\n  }\\n  return numPaths(m - 1, n - 1);\\n}\\n\\nprivate int numPaths(int i, int j) {\\n  if (i == 0 || j == 0) { // includes the row 0 and col 0\\n    return 1;\\n  }\\n  return numPaths(i - 1, j) + numPaths(i, j - 1);\\n}\\n```\n```java\\npublic int uniquePaths(int m, int n) {\\n  if (m == 0 || n == 0) {\\n    throw new IllegalArgumentException(\"m or n can\\'t be 0\");\\n  }\\n  int[][] mem = new int[m][n];\\n  for (int i = 0; i < m; ++i) { // init\\n    for (int j = 0; j < n; ++j) {\\n      mem[i][j] = -1;\\n    }\\n  }\\n  return numPaths(m - 1, n - 1, mem);\\n}\\n\\nprivate int numPaths(int i, int j, int[][] mem) {\\n  if (i == 0 || j == 0) {\\n    return 1;\\n  }\\n  if (mem[i - 1][j] == -1) mem[i - 1][j] = numPaths(i - 1, j, mem);\\n  if (mem[i][j - 1] == -1) mem[i][j - 1] = numPaths(i, j - 1, mem);\\n  return mem[i - 1][j] + mem[i][j - 1];\\n}\\n```\n```java\\npublic int uniquePaths(int m, int n) {\\n  if (m == 0 || n == 0) {\\n    throw new IllegalArgumentException(\"m or n can\\'t be 0\");\\n  }\\n  int[][] dp = new int[m][n];\\n  // init\\n  for (int i = 0; i < m; ++i) dp[i][0] = 1;\\n  for (int i = 0; i < n; ++i) dp[0][i] = 1;\\n  // dp\\n  for (int i = 1; i < m; ++i) {\\n    for (int j = 1; j < n; ++j) {\\n      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n    }\\n  }\\n  return dp[m - 1][n - 1];\\n}\\n```\n```java\\npublic int uniquePaths(int m, int n) {\\n  if (m == 0 || n == 0) {\\n    throw new IllegalArgumentException(\"m or n can\\'t be 0\");\\n  }\\n  int[] dp = new int[n]; // row\\n  // init\\n  for (int i = 0; i < n; ++i) dp[i] = 1;\\n  // dp\\n  for (int i = 1; i < m; ++i) {\\n    for (int j = 1; j < n; ++j) {\\n      dp[j] = dp[j] + dp[j - 1];\\n    }\\n  }\\n  return dp[n - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1374942,
                "title": "c-solution-using-3-different-appraoches",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\n//Recursive Appraoch\\n//This will give a TLE\\n  int solve(int i,int j,int m,int n)\\n    {\\n        if(i>=m||j>=n)\\n            return 0;\\n        if(i==m-1&&j==n-1)\\n            return 1;\\n        return solve(i+1,j,m,n)+solve(i,j+1,m,n);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return solve(0,0,m,n);\\n    }\\n\\n//DP(recursive+memoization)\\n    int solve(int i,int j,int m,int n,vector<vector<int>> &dp)\\n    {\\n        if(i>=m||j>=n)\\n            return 0;\\n        if(i==m-1&&j==n-1)\\n            return 1;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        return dp[i][j]=solve(i+1,j,m,n,dp)+solve(i,j+1,m,n,dp);\\n    }\\n    int uniquePaths(int m, int n) {\\n      vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return solve(0,0,m,n,dp);\\n    }\\n//TC:O(m*n)\\n//SC:O(m*n)\\n\\n//DP(Bottom-Up Appraoch)\\n  int uniquePaths(int m, int n) {\\n     int dp[m][n];\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0||j==0)\\n                    dp[i][j]=1;\\n                else\\n                    dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n//TC:O(m*n)\\n//SC:O(m*n)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n//Recursive Appraoch\\n//This will give a TLE\\n  int solve(int i,int j,int m,int n)\\n    {\\n        if(i>=m||j>=n)\\n            return 0;\\n        if(i==m-1&&j==n-1)\\n            return 1;\\n        return solve(i+1,j,m,n)+solve(i,j+1,m,n);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return solve(0,0,m,n);\\n    }\\n\\n//DP(recursive+memoization)\\n    int solve(int i,int j,int m,int n,vector<vector<int>> &dp)\\n    {\\n        if(i>=m||j>=n)\\n            return 0;\\n        if(i==m-1&&j==n-1)\\n            return 1;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        return dp[i][j]=solve(i+1,j,m,n,dp)+solve(i,j+1,m,n,dp);\\n    }\\n    int uniquePaths(int m, int n) {\\n      vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return solve(0,0,m,n,dp);\\n    }\\n//TC:O(m*n)\\n//SC:O(m*n)\\n\\n//DP(Bottom-Up Appraoch)\\n  int uniquePaths(int m, int n) {\\n     int dp[m][n];\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0||j==0)\\n                    dp[i][j]=1;\\n                else\\n                    dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n//TC:O(m*n)\\n//SC:O(m*n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 22975,
                "title": "python-easy-to-understand-solutions-math-dp-o-m-n-and-o-n-space",
                "content": "        \\n    # math C(m+n-2,n-1)\\n    def uniquePaths1(self, m, n):\\n        if not m or not n:\\n            return 0\\n        return math.factorial(m+n-2)/(math.factorial(n-1) * math.factorial(m-1))\\n     \\n    # O(m*n) space   \\n    def uniquePaths2(self, m, n):\\n        if not m or not n:\\n            return 0\\n        dp = [[1 for _ in xrange(n)] for _ in xrange(m)]\\n        for i in xrange(1, m):\\n            for j in xrange(1, n):\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n        return dp[-1][-1]\\n    \\n    # O(n) space \\n    def uniquePaths(self, m, n):\\n        if not m or not n:\\n            return 0\\n        cur = [1] * n\\n        for i in xrange(1, m):\\n            for j in xrange(1, n):\\n                cur[j] += cur[j-1]\\n        return cur[-1]",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "        \\n    # math C(m+n-2,n-1)\\n    def uniquePaths1(self, m, n):\\n        if not m or not n:\\n            return 0\\n        return math.factorial(m+n-2)/(math.factorial(n-1) * math.factorial(m-1))\\n     \\n    # O(m*n) space   \\n    def uniquePaths2(self, m, n):\\n        if not m or not n:\\n            return 0\\n        dp = [[1 for _ in xrange(n)] for _ in xrange(m)]\\n        for i in xrange(1, m):\\n            for j in xrange(1, n):\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n        return dp[-1][-1]\\n    \\n    # O(n) space \\n    def uniquePaths(self, m, n):\\n        if not m or not n:\\n            return 0\\n        cur = [1] * n\\n        for i in xrange(1, m):\\n            for j in xrange(1, n):\\n                cur[j] += cur[j-1]\\n        return cur[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 3994523,
                "title": "98-83-easy-dp-math",
                "content": "# Interview Guide - Unique Paths in a Grid\\n\\n## Problem Understanding\\n\\nThe problem describes a robot situated on a $$ m \\\\times n $$ grid, starting at the top-left corner (i.e., $$ \\\\text{grid}[0][0] $$). The robot can move either to the right or downwards at any given time, and the objective is to reach the bottom-right corner of the grid. The challenge is to find the number of unique paths the robot can take to reach this goal.\\n\\n### Key Points to Consider\\n\\n1. **Grid Dimensions**:  \\n   The grid dimensions are $$ m $$ (rows) and $$ n $$ (columns), with $$ 1 \\\\leq m, n \\\\leq 100 $$.\\n  \\n2. **Movement Constraints**:  \\n   The robot can only move either down or to the right at any given point. It cannot move diagonally or backwards.\\n\\n3. **Dynamic Programming and Combinatorial Mathematics**:  \\n   The problem can be solved using either a Dynamic Programming approach or using Combinatorial Mathematics.\\n\\n---\\n\\n## Live Coding & More - 3 Solutions\\nhttps://youtu.be/-0OSF4u0cjQ?si=zup18xLotShahabI\\n\\n## Solution #1: Dynamic Programming\\n\\n### Intuition and Logic Behind the Solution\\n\\nThe idea behind this approach is to use a 2D Dynamic Programming (DP) array to store the number of unique paths to each cell. A cell $$ (i, j) $$ can be reached either from $$ (i-1, j) $$ or $$ (i, j-1) $$, and thus the number of unique paths to $$ (i, j) $$ is the sum of the number of unique paths to these two cells.\\n\\n### Step-by-step Explanation\\n\\n1. **Initialization**: \\n    - Create a $$ m \\\\times n $$ DP array, initializing the first row and first column to 1 because there\\'s only one way to reach those cells from the starting point.\\n\\n2. **Main Algorithm**:  \\n    - Iterate over the DP array starting from cell $$ (1, 1) $$.\\n    - For each cell $$ (i, j) $$, set $$ \\\\text{dp}[i][j] = \\\\text{dp}[i-1][j] + \\\\text{dp}[i][j-1] $$.\\n\\n### Complexity Analysis\\n\\n- **Time Complexity**: $$ O(m \\\\times n) $$ \\u2014 We iterate through each cell once.\\n- **Space Complexity**: $$ O(m \\\\times n) $$ \\u2014 For the DP array.\\n\\n---\\n\\n## Solution #2: Memory-Optimized Dynamic Programming\\n\\n### Intuition and Logic Behind the Solution\\n\\nThe original DP solution used a $$ m \\\\times n $$ array to store the number of unique paths to each cell. However, since we only need information from the previous row and the current row to compute the number of unique paths for a given cell, we can optimize the solution to use only two rows at a time. This reduces the space complexity from $$ O(m \\\\times n) $$ to $$ O(n) $$.\\n\\n### Transitioning from $$ O(m \\\\times n) $$ to $$ O(n) $$\\n\\nIn the original $$ O(m \\\\times n) $$ approach, we used a 2D array `dp` where $$ \\\\text{dp}[i][j] $$ represented the number of unique paths to reach cell $$ (i, j) $$. To optimize this to $$ O(n) $$, we can maintain only two 1D arrays: `prev_row` and `curr_row`, each of length $$ n $$.\\n\\n- `prev_row[j]` will represent $$ \\\\text{dp}[i-1][j] $$, the number of unique paths to reach the cell in the previous row and $$ j $$-th column.\\n- `curr_row[j]` will represent $$ \\\\text{dp}[i][j] $$, the number of unique paths to reach the cell in the current row and $$ j $$-th column.\\n\\n### Step-by-step Explanation\\n\\n1. **Initialization**:  \\n   - Initialize two 1D arrays `curr_row` and `prev_row` with $$ n $$ elements, setting all elements to 1.\\n\\n2. **Main Algorithm**:  \\n   - Iterate over the rows starting from 1 (the second row).\\n   - For each cell $$ (i, j) $$, set  `curr_row[j] = curr_row[j-1] + prev_row[j]` .\\n   - Swap `curr_row` and `prev_row` for the next iteration.\\n\\n### Complexity Analysis\\n\\n- **Time Complexity**: $$ O(m \\\\times n) $$ \\u2014 We still iterate through each cell once.\\n- **Space Complexity**: $$ O(n) $$ \\u2014 For the two 1D arrays.\\n\\n---\\n\\n## Solution #3: Combinatorial Mathematics\\n\\n### Intuition\\n\\nThe number of unique paths can be seen as the number of ways to choose $$ m-1 $$ downs and $$ n-1 $$ rights, regardless of the order. In combinatorial terms, this is equivalent to $$ \\\\binom{m+n-2}{m-1} $$.\\n\\n### Algorithm\\n\\n1. **Use the Combinatorial Formula**:  \\n   $$ \\\\binom{m+n-2}{m-1} $$ or $$ \\\\binom{m+n-2}{n-1} $$ to calculate the number of unique paths.\\n\\n2. **Python\\'s Math Library**:  \\n   Python provides a built-in function $$ \\\\text{math.comb(n, k)} $$ to calculate $$ \\\\binom{n}{k} $$ efficiently.\\n\\n### Complexity Analysis\\n\\n- **Time Complexity**: $$ O(m) $$ or $$ O(n) $$ \\u2014 For calculating the combination.\\n- **Space Complexity**: $$ O(1) $$ \\u2014 Constant space.\\n\\n---\\n\\n# Performance\\n### Dynamic Programming\\n\\n| Language  | Time (ms) | Memory (MB) |\\n|-----------|-----------|-------------|\\n| Rust      | 0 ms      | 2.2 MB      |\\n| C++       | 0 ms      | 6.5 MB      |\\n| Java      | 0 ms      | 39.9 MB     |\\n| Go        | 1 ms      | 2.1 MB      |\\n| PHP       | 10 ms     | 19.3 MB     |\\n| C#        | 23 ms     | 26.6 MB     |\\n| Python3 (1D)   | 26 ms     | 16.3 MB     |\\n| Python3 (2D)  | 28 ms     | 16.3 MB     |\\n| JavaScript| 52 ms     | 41.6 MB     |\\n\\n![dp.png](https://assets.leetcode.com/users/images/5add1caa-9acf-421d-9e0b-2cd8b6497b8f_1693701064.4193008.png)\\n\\n\\n## Combinatorial Mathematics\\n\\n| Language  | Time (ms) | Memory (MB) |\\n|-----------|-----------|-------------|\\n| Rust      | 0 ms      | 2.2 MB      |\\n| C++       | 0 ms      | 5.9 MB      |\\n| PHP       | 0 ms      | 18.9 MB     |\\n| Java      | 0 ms      | 39.8 MB     |\\n| Go        | 1 ms      | 1.9 MB      |\\n| C#        | 22 ms     | 26.5 MB     |\\n| Python3   | 27 ms     | 16.4 MB     |\\n| JavaScript| 55 ms     | 41.3 MB     |\\n\\n![mt.png](https://assets.leetcode.com/users/images/4949037f-4f74-43a6-ae38-afc9f1455847_1693701121.4660912.png)\\n\\n# Code Math\\n``` Python []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        return math.comb(m+n-2, m-1)\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn unique_paths(m: i32, n: i32) -> i32 {\\n        let mut ans: i64 = 1;\\n        for i in 1..=m as i64 - 1 {\\n            ans = ans * (n as i64 - 1 + i) / i;\\n        }\\n        ans as i32\\n    }\\n}\\n```\\n``` Go []\\nfunc uniquePaths(m int, n int) int {\\n    ans := 1\\n    for i := 1; i <= m - 1; i++ {\\n        ans = ans * (n - 1 + i) / i\\n    }\\n    return ans\\n}\\n```\\n``` C++ []\\n#include <cmath>\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        long long ans = 1;\\n        for (int i = 1; i <= m - 1; ++i) {\\n            ans = ans * (n - 1 + i) / i;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public int uniquePaths(int m, int n) {\\n        long ans = 1;\\n        for (int i = 1; i <= m - 1; i++) {\\n            ans = ans * (n - 1 + i) / i;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public int UniquePaths(int m, int n) {\\n        long ans = 1;\\n        for (int i = 1; i <= m - 1; i++) {\\n            ans = ans * (n - 1 + i) / i;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\\n``` PHP []\\nclass Solution {\\n    function uniquePaths($m, $n) {\\n        $ans = 1;\\n        for ($i = 1; $i <= $m - 1; ++$i) {\\n            $ans = $ans * ($n - 1 + $i) / $i;\\n        }\\n        return (int)$ans;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @return {number}\\n */\\nvar uniquePaths = function(m, n) {\\n    let ans = 1;\\n    for (let i = 1; i <= m - 1; i++) {\\n        ans = ans * (n - 1 + i) / i;\\n    }\\n    return ans;\\n};\\n```\\n# Code DP - 2D\\n``` Python []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[1 if i == 0 or j == 0 else 0 for j in range(n)] for i in range(m)]\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n                \\n        return dp[-1][-1]\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        \\n        for (int i = 0; i < m; ++i) {\\n            dp[i][0] = 1;\\n        }\\n        for (int j = 0; j < n; ++j) {\\n            dp[0][j] = 1;\\n        }\\n        \\n        for (int i = 1; i < m; ++i) {\\n            for (int j = 1; j < n; ++j) {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        \\n        for (int i = 0; i < m; i++) {\\n            dp[i][0] = 1;\\n        }\\n        for (int j = 0; j < n; j++) {\\n            dp[0][j] = 1;\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn unique_paths(m: i32, n: i32) -> i32 {\\n        let mut dp: Vec<Vec<i32>> = vec![vec![1; n as usize]; m as usize];\\n        \\n        for i in 1..m as usize {\\n            for j in 1..n as usize {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        \\n        dp[(m-1) as usize][(n-1) as usize]\\n    }\\n}\\n```\\n``` Go []\\nfunc uniquePaths(m int, n int) int {\\n    dp := make([][]int, m)\\n    for i := range dp {\\n        dp[i] = make([]int, n)\\n    }\\n    \\n    for i := 0; i < m; i++ {\\n        dp[i][0] = 1\\n    }\\n    for j := 0; j < n; j++ {\\n        dp[0][j] = 1\\n    }\\n    \\n    for i := 1; i < m; i++ {\\n        for j := 1; j < n; j++ {\\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n        }\\n    }\\n    \\n    return dp[m-1][n-1]\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public int UniquePaths(int m, int n) {\\n        int[,] dp = new int[m, n];\\n        \\n        for (int i = 0; i < m; i++) {\\n            dp[i, 0] = 1;\\n        }\\n        for (int j = 0; j < n; j++) {\\n            dp[0, j] = 1;\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i, j] = dp[i-1, j] + dp[i, j-1];\\n            }\\n        }\\n        \\n        return dp[m-1, n-1];\\n    }\\n}\\n```\\n``` PHP []\\nclass Solution {\\n    function uniquePaths($m, $n) {\\n        $dp = array_fill(0, $m, array_fill(0, $n, 0));\\n        \\n        for ($i = 0; $i < $m; ++$i) {\\n            $dp[$i][0] = 1;\\n        }\\n        for ($j = 0; $j < $n; ++$j) {\\n            $dp[0][$j] = 1;\\n        }\\n        \\n        for ($i = 1; $i < $m; ++$i) {\\n            for ($j = 1; $j < $n; ++$j) {\\n                $dp[$i][$j] = $dp[$i-1][$j] + $dp[$i][$j-1];\\n            }\\n        }\\n        \\n        return $dp[$m-1][$n-1];\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @return {number}\\n */\\nvar uniquePaths = function(m, n) {\\n    const dp = Array.from({ length: m }, () => Array(n).fill(0));\\n    \\n    for (let i = 0; i < m; ++i) {\\n        dp[i][0] = 1;\\n    }\\n    for (let j = 0; j < n; ++j) {\\n        dp[0][j] = 1;\\n    }\\n    \\n    for (let i = 1; i < m; ++i) {\\n        for (let j = 1; j < n; ++j) {\\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n        }\\n    }\\n    \\n    return dp[m-1][n-1];\\n};\\n```\\n# Code DP - 1D\\n``` Python []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        curr_row = [1] * n\\n        prev_row = [1] * n\\n\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                curr_row[j] = curr_row[j - 1] + prev_row[j]    \\n            curr_row, prev_row = prev_row, curr_row\\n        \\n        return prev_row[-1]\\n```\\n\\n## Final Thoughts\\n\\nBoth solutions are valid for the given problem constraints. The Dynamic Programming approach is more general and can be extended to more complex scenarios, such as when some cells are blocked. On the other hand, the Combinatorial Mathematics approach is more efficient for this specific problem.\\n\\nTackling this problem offers a deep dive into Dynamic Programming and Combinatorial Mathematics. Whether you use a dynamic table or mathematical combinations, each approach is a lesson in computational thinking. This isn\\'t just a problem; it\\'s a tool for honing your optimization and math skills. So dive in and advance your algorithm mastery. \\uD83D\\uDE80\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB\\uD83C\\uDF1F",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "PHP",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        return math.comb(m+n-2, m-1)\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn unique_paths(m: i32, n: i32) -> i32 {\\n        let mut ans: i64 = 1;\\n        for i in 1..=m as i64 - 1 {\\n            ans = ans * (n as i64 - 1 + i) / i;\\n        }\\n        ans as i32\\n    }\\n}\\n```\n``` Go []\\nfunc uniquePaths(m int, n int) int {\\n    ans := 1\\n    for i := 1; i <= m - 1; i++ {\\n        ans = ans * (n - 1 + i) / i\\n    }\\n    return ans\\n}\\n```\n``` C++ []\\n#include <cmath>\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        long long ans = 1;\\n        for (int i = 1; i <= m - 1; ++i) {\\n            ans = ans * (n - 1 + i) / i;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public int uniquePaths(int m, int n) {\\n        long ans = 1;\\n        for (int i = 1; i <= m - 1; i++) {\\n            ans = ans * (n - 1 + i) / i;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public int UniquePaths(int m, int n) {\\n        long ans = 1;\\n        for (int i = 1; i <= m - 1; i++) {\\n            ans = ans * (n - 1 + i) / i;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\n``` PHP []\\nclass Solution {\\n    function uniquePaths($m, $n) {\\n        $ans = 1;\\n        for ($i = 1; $i <= $m - 1; ++$i) {\\n            $ans = $ans * ($n - 1 + $i) / $i;\\n        }\\n        return (int)$ans;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @return {number}\\n */\\nvar uniquePaths = function(m, n) {\\n    let ans = 1;\\n    for (let i = 1; i <= m - 1; i++) {\\n        ans = ans * (n - 1 + i) / i;\\n    }\\n    return ans;\\n};\\n```\n``` Python []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[1 if i == 0 or j == 0 else 0 for j in range(n)] for i in range(m)]\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n                \\n        return dp[-1][-1]\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        \\n        for (int i = 0; i < m; ++i) {\\n            dp[i][0] = 1;\\n        }\\n        for (int j = 0; j < n; ++j) {\\n            dp[0][j] = 1;\\n        }\\n        \\n        for (int i = 1; i < m; ++i) {\\n            for (int j = 1; j < n; ++j) {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        \\n        for (int i = 0; i < m; i++) {\\n            dp[i][0] = 1;\\n        }\\n        for (int j = 0; j < n; j++) {\\n            dp[0][j] = 1;\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn unique_paths(m: i32, n: i32) -> i32 {\\n        let mut dp: Vec<Vec<i32>> = vec![vec![1; n as usize]; m as usize];\\n        \\n        for i in 1..m as usize {\\n            for j in 1..n as usize {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        \\n        dp[(m-1) as usize][(n-1) as usize]\\n    }\\n}\\n```\n``` Go []\\nfunc uniquePaths(m int, n int) int {\\n    dp := make([][]int, m)\\n    for i := range dp {\\n        dp[i] = make([]int, n)\\n    }\\n    \\n    for i := 0; i < m; i++ {\\n        dp[i][0] = 1\\n    }\\n    for j := 0; j < n; j++ {\\n        dp[0][j] = 1\\n    }\\n    \\n    for i := 1; i < m; i++ {\\n        for j := 1; j < n; j++ {\\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n        }\\n    }\\n    \\n    return dp[m-1][n-1]\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public int UniquePaths(int m, int n) {\\n        int[,] dp = new int[m, n];\\n        \\n        for (int i = 0; i < m; i++) {\\n            dp[i, 0] = 1;\\n        }\\n        for (int j = 0; j < n; j++) {\\n            dp[0, j] = 1;\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i, j] = dp[i-1, j] + dp[i, j-1];\\n            }\\n        }\\n        \\n        return dp[m-1, n-1];\\n    }\\n}\\n```\n``` PHP []\\nclass Solution {\\n    function uniquePaths($m, $n) {\\n        $dp = array_fill(0, $m, array_fill(0, $n, 0));\\n        \\n        for ($i = 0; $i < $m; ++$i) {\\n            $dp[$i][0] = 1;\\n        }\\n        for ($j = 0; $j < $n; ++$j) {\\n            $dp[0][$j] = 1;\\n        }\\n        \\n        for ($i = 1; $i < $m; ++$i) {\\n            for ($j = 1; $j < $n; ++$j) {\\n                $dp[$i][$j] = $dp[$i-1][$j] + $dp[$i][$j-1];\\n            }\\n        }\\n        \\n        return $dp[$m-1][$n-1];\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @return {number}\\n */\\nvar uniquePaths = function(m, n) {\\n    const dp = Array.from({ length: m }, () => Array(n).fill(0));\\n    \\n    for (let i = 0; i < m; ++i) {\\n        dp[i][0] = 1;\\n    }\\n    for (let j = 0; j < n; ++j) {\\n        dp[0][j] = 1;\\n    }\\n    \\n    for (let i = 1; i < m; ++i) {\\n        for (let j = 1; j < n; ++j) {\\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n        }\\n    }\\n    \\n    return dp[m-1][n-1];\\n};\\n```\n``` Python []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        curr_row = [1] * n\\n        prev_row = [1] * n\\n\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                curr_row[j] = curr_row[j - 1] + prev_row[j]    \\n            curr_row, prev_row = prev_row, curr_row\\n        \\n        return prev_row[-1]\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1175465,
                "title": "java-3-approaches-dp-recursion-memoization",
                "content": "# Recursive approach:\\nThis approach will lead to TLE as we are calculating the same subproblems again and again. \\n\\nFor e.g. when m = 3 and n = 3, then we evaluate the function call with (m, n) as (2, 2) twice.\\n\\n![image](https://assets.leetcode.com/users/images/beaf8366-60b5-4a6a-9515-e1e850743950_1619423613.0065389.png)\\n\\n\\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n\\t\\t// base case\\n        if(m == 1 || n == 1) return 1;\\n        \\n\\t\\t// move up\\n        int upMove = uniquePaths(m-1, n);\\n\\t\\t// move left\\n        int leftMove = uniquePaths(m, n-1);\\n        \\n        return upMove + leftMove;\\n    }\\n}\\n```\\n\\nTime Complexity : `O(2^(m * n))`\\nSpace Complexity : `O(m + n)`\\n\\n# Memoization approach:\\n\\nHere, we store the value for number of unique paths calculated for cell(i, j), so that if we encounter same subproblem in further recursive calls, we can directly use the calculated value instead of re-calculating for that cell. \\n\\n```\\nclass Solution {\\n    private Map<String, Integer> map = new HashMap<String, Integer>();\\n    public int uniquePaths(int m, int n) {\\n        // base case       \\n        if(m == 1 || n == 1) return 1;\\n        \\n        // check if we have already calculated unique paths for cell(m, n)\\n        String cell = new String(m + \",\" + n);\\n        // if yes, then get its value from our memoization table\\n        if(map.containsKey(cell)) \\n            return map.get(cell);\\n        \\n        // else, explore the up move\\n        int upMove = uniquePaths(m-1, n);\\n        // explore the left move\\n        int leftMove = uniquePaths(m, n-1);\\n        \\n        // put the value obtained for unique paths from cell(m, n)\\n        map.put(cell, upMove + leftMove);\\n        \\n        return upMove + leftMove;\\n    }    \\n}\\n```\\n\\nTime Complexity : `O(m * n)`\\nSpace Complexity : `O(m * n)`\\n\\n# DP approach:\\n\\nUsing DP, we find the number of unique paths from a given cell is equal to as the sum of the values of its previous possible states.\\n<code>dp[i,j] = dp[i-1,j] + dp[i,j-1]</code> gives us the idea. To reach the position (i, j), the path should either be coming from (i-1, j) or (i, j-1).\\n\\nNow, we can tabulate number of paths in two methods:\\n1. We start from top-left corner i.e. (0, 0) and finding paths in forward approach by using the formula <code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code>. The base case here is when <code>i == 0 || j == 0</code>, <code>dp[i][j] = 1</code>. Here, <code>dp[i][j]</code> represents the number of paths from cell (0, 0) to cell (i, j). \\n\\n![image](https://assets.leetcode.com/users/images/94a2048d-9abe-41fb-be2d-d011a810ba59_1619336032.060753.png)\\n\\n2. We will start from the bottom-left corner (m, n) and find finding paths using backward approach using the formula <code>dp[i][j] = dp[i+1][j] + dp[i][j+1]</code>, where m = no. of rows and n = no. of columns. The base case here is when <code>i == m-1 || j == n-1</code>, <code>dp[i][j] = 1</code>. Here, <code>dp[i][j]</code> \\xA0represents the number of paths from cell (m, n) to cell (i, j).\\n\\n![image](https://assets.leetcode.com/users/images/b1a2dc40-e197-4f3a-acda-8ae59e242038_1619336059.7530973.png)\\n\\n\\n**Method 1:**\\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n ; j++){\\n                if(i == 0 || j == 0)\\n                    dp[i][j] = 1;\\n                else\\n                    dp[i][j] = dp[i][j-1] + dp[i-1][j];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\\n\\n**Method 2:**\\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        \\n        for(int i = m - 1; i >= 0; i--){\\n            for(int j = n - 1; j >= 0; j--){\\n                if(i == m - 1 || j == n - 1)\\n                    dp[i][j] = 1;\\n                else\\n                    dp[i][j] = dp[i][j+1] + dp[i+1][j];\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```\\nTime Complexity : `O(m * n)`\\nSpace Complexity : `O(m * n)`\\n\\n**Please UPVOTE if you like the solution :)**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n\\t\\t// base case\\n        if(m == 1 || n == 1) return 1;\\n        \\n\\t\\t// move up\\n        int upMove = uniquePaths(m-1, n);\\n\\t\\t// move left\\n        int leftMove = uniquePaths(m, n-1);\\n        \\n        return upMove + leftMove;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private Map<String, Integer> map = new HashMap<String, Integer>();\\n    public int uniquePaths(int m, int n) {\\n        // base case       \\n        if(m == 1 || n == 1) return 1;\\n        \\n        // check if we have already calculated unique paths for cell(m, n)\\n        String cell = new String(m + \",\" + n);\\n        // if yes, then get its value from our memoization table\\n        if(map.containsKey(cell)) \\n            return map.get(cell);\\n        \\n        // else, explore the up move\\n        int upMove = uniquePaths(m-1, n);\\n        // explore the left move\\n        int leftMove = uniquePaths(m, n-1);\\n        \\n        // put the value obtained for unique paths from cell(m, n)\\n        map.put(cell, upMove + leftMove);\\n        \\n        return upMove + leftMove;\\n    }    \\n}\\n```\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n ; j++){\\n                if(i == 0 || j == 0)\\n                    dp[i][j] = 1;\\n                else\\n                    dp[i][j] = dp[i][j-1] + dp[i-1][j];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        \\n        for(int i = m - 1; i >= 0; i--){\\n            for(int j = n - 1; j >= 0; j--){\\n                if(i == m - 1 || j == n - 1)\\n                    dp[i][j] = 1;\\n                else\\n                    dp[i][j] = dp[i][j+1] + dp[i+1][j];\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994830,
                "title": "step-by-step-beginner-friendly-dp-3-approaches-full-explanation-dp",
                "content": "# Question Understanding-\\n\\n**Given are only two valid moves :**\\n- **Move right**\\n- **Move down**\\nHence, it is clear number of paths from cell (i,j) = sum of paths from cell( i+1,j) and cell(i,j+1)\\n\\n**It becomes a DP problem.**\\nBut implementing DP directly **will lead to TLE**.\\n**So memoization is useful -> Storing a result** so that we donot need to calculate it again.\\n\\ndp[i][j] = d[i+1][j] + dp[i][j+1]\\n\\n# BASE CASES\\n\\n**If we are in last row**, i == m-1, we only have the choice to move RIGHT, Hence number of moves will be 1.\\n**If we are in last column**, j == n-1, we only have the choice to move DOWN, Hence number of moves will be 1.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Step-by-Step Solution:\\n\\n---\\n\\n\\n---\\n# **Bottom-Up Dynamic Programming:**\\n\\n**Step 1: Initialize the DP Table**\\n- Create a 2D DP (dynamic programming) table of **size m x n** to store the number of unique paths for each cell.\\n- **Initialize the rightmost column and bottom row of the DP table to 1** because there\\'s only one way to reach each cell in those rows/columns (by moving all the way right or all the way down).\\n\\n**Step 2: Fill in the DP Table**\\n\\n- **Start from the second-to-last** row and second-to-last column (i.e., i = m - 2 and j = n - 2).\\n- **For each cell (i, j) in the grid:**\\n    - Calculate the **number of unique paths to reach (i, j)** as the sum of the unique paths from the cell below (i+1, j) and **the cell to the right (i, j+1)**. Use this formula: **dp[i][j] = dp[i+1][j] + dp[i][j+1].**\\n    - **Continue filling** in the DP table row by row and column by column until you reach the top-left corner (dp[0][0]).\\n\\n**Step 3: Return the Result**\\n\\n- Return the value stored in the top-left corner of the DP table (dp[0][0]), which represents the number of unique paths from the top-left corner to the bottom-right corner.\\n<!-- Describe your approach to solving the problem. -->\\n\\n---\\n\\n\\n---\\n\\n\\n# **Top-Down Dynamic Programming:**\\n\\n**Step 1: Initialize the Memoization Table**\\n\\n- **Create a memoization table** (an auxiliary 2D array) of size m x n to store computed results. Initialize all entries to -1 to indicate that no results have been computed yet.\\n\\n**Step 2: Recursive Function**\\n- **Implement a recursive function**, say **uniquePathsRecursive(x, y, m, n, memo)**, which calculates the number of unique paths to reach cell (x, y) from the top-left corner.\\n- **In this function:**\\n    - **Check if (x, y) is the destination cell** (m - 1, n - 1). If yes, return 1 since there is one way to reach the destination.\\n    - **Check if the result for (x, y) is already computed** in the memoization table (memo[x][y] != -1). **If yes, return the stored result.**    \\n\\n    - **Otherwise, calculate the number of unique paths** by recursively moving right and down (if valid) and adding the results. **Use the following logic:**\\n            \\u27A1**If (x, y) can move right** (i.e., x < m - 1), calculate rightPaths = uniquePathsRecursive(x + 1, y, m, n, memo).\\n            \\u27A1 **If (x, y) can move down** (i.e., y < n - 1), calculate downPaths = uniquePathsRecursive(x, y + 1, m, n, memo).\\n            \\u27A1 **The total unique paths to (x, y) are rightPaths + downPaths.**\\n            \\u27A1** Store the result** in the memoization table (memo[x][y]) and return it. \\n\\n**Step 3: Invoke the Recursive Function**\\n\\n- Call the recursive function with the initial arguments (0, 0, m, n, memo) to find the number of unique paths.\\n\\n**Step 4: Return the Result**\\n\\n- The result obtained from the recursive function call represents the number of unique paths from the top-left corner to the bottom-right corner.\\n # Complexity\\n\\n---\\n\\n\\n**Bottom-Up Dynamic Programming:**\\n**Time Complexity (TC):** The bottom-up approach fills in the DP table iteratively, visiting each cell once. There are m rows and n columns in the grid, so the TC is **O(m * n)**.\\n**Space Complexity (SC):** The space complexity is determined by the DP table, which is of size m x n. Therefore, **the SC is O(m * n)** to store the DP table.\\n\\n---\\n\\n\\n**Top-Down Dynamic Programming (with Memoization):**\\n**Time Complexity (TC):** O(m * n).\\n**Space Complexity (SC):** O(m + n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n---\\n\\n\\n\\n# \\uD83D\\uDE0A\\uD83D\\uDE0ASMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated\\uD83D\\uDE0A\\uD83D\\uDE0A\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n---\\n\\n\\n# Bottom up Approach Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        \\n        // Initialize the rightmost column and bottom row to 1 because there is only one way to reach each cell in those rows/columns.\\n        for (int i = 0; i < m; i++) {\\n            dp[i][n-1] = 1;\\n        }\\n        for (int j = 0; j < n; j++) {\\n            dp[m-1][j] = 1;\\n        }\\n        \\n        // Fill in the dp table bottom-up\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = n - 2; j >= 0; j--) {\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n};\\n\\n```\\n```python3 []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        # Create a 2D DP table filled with zeros\\n        dp = [[0] * n for _ in range(m)]\\n        \\n        # Initialize the rightmost column and bottom row to 1\\n        for i in range(m):\\n            dp[i][n-1] = 1\\n        for j in range(n):\\n            dp[m-1][j] = 1\\n        \\n        # Fill in the DP table bottom-up\\n        for i in range(m - 2, -1, -1):\\n            for j in range(n - 2, -1, -1):\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1]\\n        \\n        # Return the result stored in the top-left corner\\n        return dp[0][0]\\n\\n```\\n```Java []\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        // Create a 2D DP array filled with zeros\\n        int[][] dp = new int[m][n];\\n        \\n        // Initialize the rightmost column and bottom row to 1\\n        for (int i = 0; i < m; i++) {\\n            dp[i][n-1] = 1;\\n        }\\n        for (int j = 0; j < n; j++) {\\n            dp[m-1][j] = 1;\\n        }\\n        \\n        // Fill in the DP array bottom-up\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = n - 2; j >= 0; j--) {\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n        \\n        // Return the result stored in the top-left corner\\n        return dp[0][0];\\n    }\\n}\\n\\n```\\n```Javascript []\\nvar uniquePaths = function(m, n) {\\n    // Create a 2D DP array filled with zeros\\n    let dp = new Array(m).fill().map(() => new Array(n).fill(0));\\n    \\n    // Initialize the rightmost column and bottom row to 1\\n    for (let i = 0; i < m; i++) {\\n        dp[i][n-1] = 1;\\n    }\\n    for (let j = 0; j < n; j++) {\\n        dp[m-1][j] = 1;\\n    }\\n    \\n    // Fill in the DP array bottom-up\\n    for (let i = m - 2; i >= 0; i--) {\\n        for (let j = n - 2; j >= 0; j--) {\\n            dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n        }\\n    }\\n    \\n    // Return the result stored in the top-left corner\\n    return dp[0][0];\\n};\\n\\n```\\n# Top-Down Approach Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        // Create a memoization table to store computed results\\n        vector<vector<int>> memo(m, vector<int>(n, -1));\\n        \\n        // Call the recursive function to compute unique paths\\n        return uniquePathsRecursive(0, 0, m, n, memo);\\n    }\\n    \\n    int uniquePathsRecursive(int x, int y, int m, int n, vector<vector<int>>& memo) {\\n        // If we reach the destination (bottom-right corner), return 1\\n        if (x == m - 1 && y == n - 1) {\\n            return 1;\\n        }\\n        \\n        // If we have already computed the result for this cell, return it from the memo table\\n        if (memo[x][y] != -1) {\\n            return memo[x][y];\\n        }\\n        \\n        // Calculate the number of unique paths by moving right and down\\n        int rightPaths = 0;\\n        int downPaths = 0;\\n        \\n        // Check if it\\'s valid to move right\\n        if (x < m - 1) {\\n            rightPaths = uniquePathsRecursive(x + 1, y, m, n, memo);\\n        }\\n        \\n        // Check if it\\'s valid to move down\\n        if (y < n - 1) {\\n            downPaths = uniquePathsRecursive(x, y + 1, m, n, memo);\\n        }\\n        \\n        // Store the result in the memo table and return it\\n        memo[x][y] = rightPaths + downPaths;\\n        return memo[x][y];\\n    }\\n};\\n\\n```\\n```python3 []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        # Create a memoization table to store computed results\\n        memo = [[-1 for _ in range(n)] for _ in range(m)]\\n        \\n        # Call the recursive function to compute unique paths\\n        return self.uniquePathsRecursive(0, 0, m, n, memo)\\n    \\n    def uniquePathsRecursive(self, x: int, y: int, m: int, n: int, memo: List[List[int]]) -> int:\\n        # If we reach the destination (bottom-right corner), return 1\\n        if x == m - 1 and y == n - 1:\\n            return 1\\n        \\n        # If we have already computed the result for this cell, return it from the memo table\\n        if memo[x][y] != -1:\\n            return memo[x][y]\\n        \\n        # Calculate the number of unique paths by moving right and down\\n        rightPaths = 0\\n        downPaths = 0\\n        \\n        # Check if it\\'s valid to move right\\n        if x < m - 1:\\n            rightPaths = self.uniquePathsRecursive(x + 1, y, m, n, memo)\\n        \\n        # Check if it\\'s valid to move down\\n        if y < n - 1:\\n            downPaths = self.uniquePathsRecursive(x, y + 1, m, n, memo)\\n        \\n        # Store the result in the memo table and return it\\n        memo[x][y] = rightPaths + downPaths\\n        return memo[x][y]\\n\\n```\\n```Java []\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        // Create a memoization table to store computed results\\n        int[][] memo = new int[m][n];\\n        \\n        // Initialize the memoization table with -1 to indicate uncomputed results\\n        for (int i = 0; i < m; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n        \\n        // Call the recursive function to compute unique paths\\n        return uniquePathsRecursive(0, 0, m, n, memo);\\n    }\\n    \\n    public int uniquePathsRecursive(int x, int y, int m, int n, int[][] memo) {\\n        // If we reach the destination (bottom-right corner), return 1\\n        if (x == m - 1 && y == n - 1) {\\n            return 1;\\n        }\\n        \\n        // If we have already computed the result for this cell, return it from the memo table\\n        if (memo[x][y] != -1) {\\n            return memo[x][y];\\n        }\\n        \\n        // Calculate the number of unique paths by moving right and down\\n        int rightPaths = 0;\\n        int downPaths = 0;\\n        \\n        // Check if it\\'s valid to move right\\n        if (x < m - 1) {\\n            rightPaths = uniquePathsRecursive(x + 1, y, m, n, memo);\\n        }\\n        \\n        // Check if it\\'s valid to move down\\n        if (y < n - 1) {\\n            downPaths = uniquePathsRecursive(x, y + 1, m, n, memo);\\n        }\\n        \\n        // Store the result in the memo table and return it\\n        memo[x][y] = rightPaths + downPaths;\\n        return memo[x][y];\\n    }\\n}\\n\\n```\\n```Javascript []\\nvar uniquePaths = function(m, n) {\\n    // Create a memoization table to store computed results\\n    let memo = new Array(m).fill(null).map(() => new Array(n).fill(-1));\\n    \\n    // Call the recursive function to compute unique paths\\n    return uniquePathsRecursive(0, 0, m, n, memo);\\n};\\n\\nvar uniquePathsRecursive = function(x, y, m, n, memo) {\\n    // If we reach the destination (bottom-right corner), return 1\\n    if (x === m - 1 && y === n - 1) {\\n        return 1;\\n    }\\n    \\n    // If we have already computed the result for this cell, return it from the memo table\\n    if (memo[x][y] !== -1) {\\n        return memo[x][y];\\n    }\\n    \\n    // Calculate the number of unique paths by moving right and down\\n    let rightPaths = 0;\\n    let downPaths = 0;\\n    \\n    // Check if it\\'s valid to move right\\n    if (x < m - 1) {\\n        rightPaths = uniquePathsRecursive(x + 1, y, m, n, memo);\\n    }\\n    \\n    // Check if it\\'s valid to move down\\n    if (y < n - 1) {\\n        downPaths = uniquePathsRecursive(x, y + 1, m, n, memo);\\n    }\\n    \\n    // Store the result in the memo table and return it\\n    memo[x][y] = rightPaths + downPaths;\\n    return memo[x][y];\\n};\\n\\n```\\n# \\uD83D\\uDE0A\\uD83D\\uDE0ASMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated\\uD83D\\uDE0A\\uD83D\\uDE0A![UPVOTE.png](https://assets.leetcode.com/users/images/0c91ddd3-d9da-49c8-8add-2898aa10de7a_1693712670.8764517.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        \\n        // Initialize the rightmost column and bottom row to 1 because there is only one way to reach each cell in those rows/columns.\\n        for (int i = 0; i < m; i++) {\\n            dp[i][n-1] = 1;\\n        }\\n        for (int j = 0; j < n; j++) {\\n            dp[m-1][j] = 1;\\n        }\\n        \\n        // Fill in the dp table bottom-up\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = n - 2; j >= 0; j--) {\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n};\\n\\n```\n```python3 []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        # Create a 2D DP table filled with zeros\\n        dp = [[0] * n for _ in range(m)]\\n        \\n        # Initialize the rightmost column and bottom row to 1\\n        for i in range(m):\\n            dp[i][n-1] = 1\\n        for j in range(n):\\n            dp[m-1][j] = 1\\n        \\n        # Fill in the DP table bottom-up\\n        for i in range(m - 2, -1, -1):\\n            for j in range(n - 2, -1, -1):\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1]\\n        \\n        # Return the result stored in the top-left corner\\n        return dp[0][0]\\n\\n```\n```Java []\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        // Create a 2D DP array filled with zeros\\n        int[][] dp = new int[m][n];\\n        \\n        // Initialize the rightmost column and bottom row to 1\\n        for (int i = 0; i < m; i++) {\\n            dp[i][n-1] = 1;\\n        }\\n        for (int j = 0; j < n; j++) {\\n            dp[m-1][j] = 1;\\n        }\\n        \\n        // Fill in the DP array bottom-up\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = n - 2; j >= 0; j--) {\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n        \\n        // Return the result stored in the top-left corner\\n        return dp[0][0];\\n    }\\n}\\n\\n```\n```Javascript []\\nvar uniquePaths = function(m, n) {\\n    // Create a 2D DP array filled with zeros\\n    let dp = new Array(m).fill().map(() => new Array(n).fill(0));\\n    \\n    // Initialize the rightmost column and bottom row to 1\\n    for (let i = 0; i < m; i++) {\\n        dp[i][n-1] = 1;\\n    }\\n    for (let j = 0; j < n; j++) {\\n        dp[m-1][j] = 1;\\n    }\\n    \\n    // Fill in the DP array bottom-up\\n    for (let i = m - 2; i >= 0; i--) {\\n        for (let j = n - 2; j >= 0; j--) {\\n            dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n        }\\n    }\\n    \\n    // Return the result stored in the top-left corner\\n    return dp[0][0];\\n};\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        // Create a memoization table to store computed results\\n        vector<vector<int>> memo(m, vector<int>(n, -1));\\n        \\n        // Call the recursive function to compute unique paths\\n        return uniquePathsRecursive(0, 0, m, n, memo);\\n    }\\n    \\n    int uniquePathsRecursive(int x, int y, int m, int n, vector<vector<int>>& memo) {\\n        // If we reach the destination (bottom-right corner), return 1\\n        if (x == m - 1 && y == n - 1) {\\n            return 1;\\n        }\\n        \\n        // If we have already computed the result for this cell, return it from the memo table\\n        if (memo[x][y] != -1) {\\n            return memo[x][y];\\n        }\\n        \\n        // Calculate the number of unique paths by moving right and down\\n        int rightPaths = 0;\\n        int downPaths = 0;\\n        \\n        // Check if it\\'s valid to move right\\n        if (x < m - 1) {\\n            rightPaths = uniquePathsRecursive(x + 1, y, m, n, memo);\\n        }\\n        \\n        // Check if it\\'s valid to move down\\n        if (y < n - 1) {\\n            downPaths = uniquePathsRecursive(x, y + 1, m, n, memo);\\n        }\\n        \\n        // Store the result in the memo table and return it\\n        memo[x][y] = rightPaths + downPaths;\\n        return memo[x][y];\\n    }\\n};\\n\\n```\n```python3 []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        # Create a memoization table to store computed results\\n        memo = [[-1 for _ in range(n)] for _ in range(m)]\\n        \\n        # Call the recursive function to compute unique paths\\n        return self.uniquePathsRecursive(0, 0, m, n, memo)\\n    \\n    def uniquePathsRecursive(self, x: int, y: int, m: int, n: int, memo: List[List[int]]) -> int:\\n        # If we reach the destination (bottom-right corner), return 1\\n        if x == m - 1 and y == n - 1:\\n            return 1\\n        \\n        # If we have already computed the result for this cell, return it from the memo table\\n        if memo[x][y] != -1:\\n            return memo[x][y]\\n        \\n        # Calculate the number of unique paths by moving right and down\\n        rightPaths = 0\\n        downPaths = 0\\n        \\n        # Check if it\\'s valid to move right\\n        if x < m - 1:\\n            rightPaths = self.uniquePathsRecursive(x + 1, y, m, n, memo)\\n        \\n        # Check if it\\'s valid to move down\\n        if y < n - 1:\\n            downPaths = self.uniquePathsRecursive(x, y + 1, m, n, memo)\\n        \\n        # Store the result in the memo table and return it\\n        memo[x][y] = rightPaths + downPaths\\n        return memo[x][y]\\n\\n```\n```Java []\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        // Create a memoization table to store computed results\\n        int[][] memo = new int[m][n];\\n        \\n        // Initialize the memoization table with -1 to indicate uncomputed results\\n        for (int i = 0; i < m; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n        \\n        // Call the recursive function to compute unique paths\\n        return uniquePathsRecursive(0, 0, m, n, memo);\\n    }\\n    \\n    public int uniquePathsRecursive(int x, int y, int m, int n, int[][] memo) {\\n        // If we reach the destination (bottom-right corner), return 1\\n        if (x == m - 1 && y == n - 1) {\\n            return 1;\\n        }\\n        \\n        // If we have already computed the result for this cell, return it from the memo table\\n        if (memo[x][y] != -1) {\\n            return memo[x][y];\\n        }\\n        \\n        // Calculate the number of unique paths by moving right and down\\n        int rightPaths = 0;\\n        int downPaths = 0;\\n        \\n        // Check if it\\'s valid to move right\\n        if (x < m - 1) {\\n            rightPaths = uniquePathsRecursive(x + 1, y, m, n, memo);\\n        }\\n        \\n        // Check if it\\'s valid to move down\\n        if (y < n - 1) {\\n            downPaths = uniquePathsRecursive(x, y + 1, m, n, memo);\\n        }\\n        \\n        // Store the result in the memo table and return it\\n        memo[x][y] = rightPaths + downPaths;\\n        return memo[x][y];\\n    }\\n}\\n\\n```\n```Javascript []\\nvar uniquePaths = function(m, n) {\\n    // Create a memoization table to store computed results\\n    let memo = new Array(m).fill(null).map(() => new Array(n).fill(-1));\\n    \\n    // Call the recursive function to compute unique paths\\n    return uniquePathsRecursive(0, 0, m, n, memo);\\n};\\n\\nvar uniquePathsRecursive = function(x, y, m, n, memo) {\\n    // If we reach the destination (bottom-right corner), return 1\\n    if (x === m - 1 && y === n - 1) {\\n        return 1;\\n    }\\n    \\n    // If we have already computed the result for this cell, return it from the memo table\\n    if (memo[x][y] !== -1) {\\n        return memo[x][y];\\n    }\\n    \\n    // Calculate the number of unique paths by moving right and down\\n    let rightPaths = 0;\\n    let downPaths = 0;\\n    \\n    // Check if it\\'s valid to move right\\n    if (x < m - 1) {\\n        rightPaths = uniquePathsRecursive(x + 1, y, m, n, memo);\\n    }\\n    \\n    // Check if it\\'s valid to move down\\n    if (y < n - 1) {\\n        downPaths = uniquePathsRecursive(x, y + 1, m, n, memo);\\n    }\\n    \\n    // Store the result in the memo table and return it\\n    memo[x][y] = rightPaths + downPaths;\\n    return memo[x][y];\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711190,
                "title": "python-2-solutions-dp-and-oneliner-math-explained",
                "content": "### 1. Dynamic programming solution\\nOne way to solve this problem is to use **dynamic programming**: define by `dp[i][j]` number of ways to reach point `(i,j)`. How can we reach it, there are two options:\\n1. We can reach it from above `(i, j-1)`.\\n2. We can reach it from the left: `(i-1, j)`.\\n\\nThat is all! We just evaluate `dp[i][j] = dp[i-1][j] + dp[i][j-1]`\\n**Complexity**: time comlexity is `O(mn)`, space complexity is `O(mn)`, which can be improved to `O(min(m,n))`.\\n\\n```\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        dp = [[1] * n for _ in range(m)]\\n        for i,j in product(range(1,m),range(1,n)):\\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]            \\n        return dp[-1][-1]\\n```\\n\\n### 2. Math solution\\n\\nNote, that we need to make overall `n + m - 2` steps, and exactly `m - 1` of them need to be right moves and `n - 1` down steps. By definition this is numbef of combinations to choose `n - 1` elements from `n + m - 2`.\\n\\n**Complexity**: time complexity is `O(m+n)`, space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        return factorial(m+n-2)//factorial(m-1)//factorial(n-1)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        dp = [[1] * n for _ in range(m)]\\n        for i,j in product(range(1,m),range(1,n)):\\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]            \\n        return dp[-1][-1]\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        return factorial(m+n-2)//factorial(m-1)//factorial(n-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23230,
                "title": "java-dp-with-o-n-space",
                "content": "We only need to store the previous row/column to perform the calculation for the next one. So an 1-d array would suffice. You could also choose to iterate through m or n depending on which direction you choose to go (by row or by column). Note that the first element of the array will always be 1.\\n\\n    public class Solution {\\n        public int uniquePaths(int m, int n) {\\n            int[] arr = new int[m];\\n            for (int i = 0; i < m; i++) {\\n                arr[i] = 1;\\n            }\\n            for (int i = 1; i < n; i++) {\\n                for (int j = 1; j < m; j++) {\\n                    arr[j] = arr[j] + arr[j-1];\\n                }\\n            }\\n            return arr[m-1];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int uniquePaths(int m, int n) {\\n            int[] arr = new int[m];\\n            for (int i = 0; i < m; i++) {\\n                arr[i] = 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2362096,
                "title": "c-explained",
                "content": "**UPVOTE IF HELPFuuL**\\nGiven are only two valid moves :\\n* Move right\\n* Move down\\n*Hence,* it is clear number of paths from ```cell (i,j)``` = sum of paths from ```cell( i+1,j) and cell(i,j+1)``` \\n\\nIt becomes a DP problem.\\nBut implementing **DP** directly will lead to **TLE**\\nSo memoization is useful -> Storing a result so that we donot need to calculate it again.\\n\\n```dp[i][j] = d[i+1][j] + dp[i][j+1]```\\n\\n**BASE CASES**\\n* If we are in last row, ```i == m-1```, we only have the choice to move **RIGHT**, Hence number of moves will be **1**.\\n* If we are in last column, ```j == n-1```, we only have the choice to move **DOWN**, Hence number of moves will be **1**.\\n\\n**UPVOTE IF HELPFuuL**\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, vector<vector<int>> &dp, int& m, int& n) {\\n        if(i == m-1 || j == n-1) return 1;\\n        if(dp[i][j] != 0)return dp[i][j];\\n        \\n        dp[i][j] = solve(i+1, j, dp, m, n) + solve(i, j+1, dp, m, n);\\n        return dp[i][j];\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m , vector<int>(n , 0));\\n        return solve(0, 0, dp, m, n);\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/df8b4e17-aa90-43e4-aba4-112caf0795a7_1659315381.4456522.jpeg)\\n",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```cell (i,j)```\n```cell( i+1,j) and cell(i,j+1)```\n```dp[i][j] = d[i+1][j] + dp[i][j+1]```\n```i == m-1```\n```j == n-1```\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, vector<vector<int>> &dp, int& m, int& n) {\\n        if(i == m-1 || j == n-1) return 1;\\n        if(dp[i][j] != 0)return dp[i][j];\\n        \\n        dp[i][j] = solve(i+1, j, dp, m, n) + solve(i, j+1, dp, m, n);\\n        return dp[i][j];\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m , vector<int>(n , 0));\\n        return solve(0, 0, dp, m, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2363008,
                "title": "python-detailed-explanation-easy-understand-dp-math",
                "content": "**Appreciate if you could upvote this solution**\\n\\n**Method 1: `DP`**\\n\\nImagine that we store the grid in a 2D matrix\\nIf we want to go to dp[i][j], we can only either come from the left side or the top side.\\n![image](https://assets.leetcode.com/users/images/df065f88-f410-4313-b187-0ef8e434faed_1659331435.2545106.png)\\nThus, the total combinations for reaching `dp[i][j]`\\n= `dp[i-1][j] (*from the left*) + dp[i][j-1] (*from the top*)` **for i != 0 and j != 0**\\n\\nFor initializing the `dp` matrix, we need to set 1 to the first row and first column because there is only one way to reach `dp[0][j]` and `dp[i][0]`\\n\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        # Initialize the first row and column to 1\\n        # Since the combination for \\n        # dp[i][0] = dp[i-1][0]\\n        # dp[0][j] = dp[0][j-1]\\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n\\n        # df_table = [[1]*n] + [[1] + [0]*(n-1) ] * (m-1)\\n\\t\\t# Since dp[i][j] only depends on the calculated cells before,\\n\\t\\t# we can simply initialize the value of all cells to 1.\\n        dp = [[1]*n] * m\\n\\n        for r in range(1, m):\\n            for c in range(1, n):\\n                dp[r][c] = dp[r - 1][c] + dp[r][c - 1]\\n\\n        return dp[-1][-1]\\n```\\n\\n<br/>\\n\\n**Advanced solution**:\\nSince some of the paths are just reversed, we can ignore the calculated for those reversed paths to optimize the execution time.\\n\\n```\\nclass Solution:\\n    dp = dict()\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        if m > n:\\n            r = m\\n            c = n\\n        else:\\n            r = n\\n            c = m\\n            \\n        if r == 1 or c == 1:\\n            return 1\\n\\n        if (r, c) not in self.dp:\\n            self.dp[(r, c)] = self.uniquePaths(r - 1, c) + self.uniquePaths(r, c - 1)\\n\\n        return self.dp[(r,c)]\\n```\\nTime complexity: `O(n * m)`\\nSpace complexity:  `O(n)`\\n<br/>\\n<br/>\\n \\n**Method 2: `math`**\\n\\nFor a grid with `m` rows and `n` columns, there are `m + n - 2` steps to the destination.\\nFor example, if `m = 3` and `n = 7`\\n\\n![image](https://assets.leetcode.com/users/images/11c9d780-ba87-418a-8d2a-b4cc479c56e0_1659333082.6938484.png)\\ne.g. the `-2`  in this path means ignoring the starting cell and the overlapped corner.\\n\\nIn these  `m + n - 2` steps, we can have `n - 1` times to choose to turn right *(or `m - 1` times to choose to turn down)*.\\nThus, the total combinations is  `(m+n-2) C (n-1)` / `C(m+n-2, n-1)`\\n\\n```\\nimport math\\n\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        return math.comb(n + m - 2, n - 1)\\n```\\n\\n**Time complexity**: `O(n * m)`\\n**Space complexity**:  `O(1)`\\n<br/>\\n",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        # Initialize the first row and column to 1\\n        # Since the combination for \\n        # dp[i][0] = dp[i-1][0]\\n        # dp[0][j] = dp[0][j-1]\\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n\\n        # df_table = [[1]*n] + [[1] + [0]*(n-1) ] * (m-1)\\n\\t\\t# Since dp[i][j] only depends on the calculated cells before,\\n\\t\\t# we can simply initialize the value of all cells to 1.\\n        dp = [[1]*n] * m\\n\\n        for r in range(1, m):\\n            for c in range(1, n):\\n                dp[r][c] = dp[r - 1][c] + dp[r][c - 1]\\n\\n        return dp[-1][-1]\\n```\n```\\nclass Solution:\\n    dp = dict()\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        if m > n:\\n            r = m\\n            c = n\\n        else:\\n            r = n\\n            c = m\\n            \\n        if r == 1 or c == 1:\\n            return 1\\n\\n        if (r, c) not in self.dp:\\n            self.dp[(r, c)] = self.uniquePaths(r - 1, c) + self.uniquePaths(r, c - 1)\\n\\n        return self.dp[(r,c)]\\n```\n```\\nimport math\\n\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        return math.comb(n + m - 2, n - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23003,
                "title": "1-line-math-solution-python",
                "content": "    class Solution(object):\\n        def uniquePaths(self, m, n):\\n            \"\"\"\\n            :type m: int\\n            :type n: int\\n            :rtype: int\\n            \"\"\"\\n            return math.factorial(m+n-2)/math.factorial(m-1)/math.factorial(n-1)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def uniquePaths(self, m, n):\\n            \"\"\"\\n            :type m: int\\n            :type n: int\\n            :rtype: int\\n            \"\"\"\\n            return math.factorial(m+n-2)/math.factorial(m-1)/math.factorial(n-1)",
                "codeTag": "Java"
            },
            {
                "id": 22988,
                "title": "simple-c-version-using-math",
                "content": "    class Solution {\\n    public:\\n        int uniquePaths(int m, int n) {\\n            if(m <=0 || n <= 0) return 0;\\n            long long res = 1;\\n            for(int i = n; i < m+n-1 ; i++){\\n                res = res * i / (i- n + 1);\\n            }\\n            return (int)res;\\n        }\\n    };\\n\\nThe total step number should be m+n-2. This means that we have to move down for m-1 steps and move right n-1 steps to reach the definition. Then different choice number would be:\\n\\n\\n----------\\nUniqueStepNum = choose (m-1) from (m+n-2) = choose (n-1) from (m+n-2)\\n\\n----------\\n = (m+n-2)! / [(m-1)! * (n-1)!] \\n\\n----------\\n = ( (m+n-2) / (m-1) ) * ( (m+n-3) / (m-2) ) * ... * (n / 1)",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int uniquePaths(int m, int n) {\\n            if(m <=0 || n <= 0) return 0;\\n            long long res = 1;\\n            for(int i = n; i < m+n-1 ; i++){\\n                res = res * i / (i- n + 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 474165,
                "title": "python-js-java-go-c-by-o-mn-dp-with-explanation",
                "content": "3 sol. based on dynamic programming, math analysis, and recursion.\\n\\n\\n[My tutorial with DP problem solving framework to unique paths [English]](https://medium.com/@cutesciuridae/dive-into-dp-take-unique-path-for-example-28c817ba4fe8?source=your_stories_page-------------------------------------)\\n\\n[My tutorial with DP problem solving framework to unique paths [Chinese]](https://medium.com/@cutesciuridae/dynamic-programming-%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA-%E4%BB%A5unique-path%E7%82%BA%E4%BE%8B-2387bfab5722?source=your_stories_page-------------------------------------)\\n\\n[Tutorial video in Chinese \\u4E2D\\u6587\\u89E3\\u984C\\u5F71\\u7247](https://youtu.be/ZdGN8JZ23cU)\\n\\n[\\u4E2D\\u6587\\u89E3\\u984C\\u6587\\u7AE0 + DP\\u601D\\u8003\\u6846\\u67B6](https://vocus.cc/article/65102de8fd89780001c2bfd9)\\n\\n---\\n\\nDiagram:\\n\\n![image](https://assets.leetcode.com/users/images/2cf56e11-729e-426b-be98-2ef81469d933_1613721428.3846037.png)\\n\\n\\n---\\n\\nmethod_#1: Dynamic Programming\\n\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        rows, cols = m, n\\n        \\n        path_dp = [ [ 1 for j in range(cols)] for i in range(rows) ]\\n        \\n        \\n        # Dynamic Programming relation:\\n        \\n        # Base case:\\n        # DP(0, j) = 1 , only reachable from one step left\\n        # DP(i, 0) = 1 , only reachable from one step up\\n        \\n        # General case:\\n        # DP(i,j) = number of path reach to (i, j)\\n        #         = number of path reach to one step left + number of path reach to one step up\\n        #         = number of path reach to (i, j-1) + number of path to (i-1, j)\\n        #         = DP(i, j-1) + DP(i-1, j)\\n        \\n        \\n        \\n        for i in range(1, rows):\\n            for j in range(1, cols):\\n                \\n                path_dp[i][j] = path_dp[i][j-1] + path_dp[i-1][j]\\n        \\n        \\n        # Destination coordination = (rows-1, cols-1)\\n        return path_dp[rows-1][cols-1]\\n```\\n\\n---\\nC++\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n\\t\\n        vector< vector<int> > path(m, vector<int>(n, 1) );\\n        \\n        for(int y = 1 ; y < m ; y++){\\n            for(int x = 1 ; x < n ; x++){\\n                \\n                // just follow the DP recurrence formula\\n                path[y][x] = path[y][x-1] + path[y-1][x];\\n            }\\n        }\\n        return path[m-1][n-1];\\n    }\\n};\\n```\\n\\t\\n</details>\\n\\n\\n---\\n\\nJava:\\n\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        \\n        int [][]path = new int[m][n];\\n        \\n        // Base case:\\n        \\n        // left-most column\\n        for(int y = 0 ; y < m ; y++){\\n            path[y][0] = 1;\\n        }\\n        \\n        // top-most row\\n        for(int x = 0 ; x < n ; x++){\\n            path[0][x] = 1;\\n        }\\n        \\n        // General cases\\n        for(int y = 1 ; y < m ; y++){\\n            for(int x = 1 ; x < n ; x++){\\n                \\n                // just follow the DP recurrence formula\\n                path[y][x] = path[y][x-1] + path[y-1][x];\\n\\n            }\\n        }\\n        return path[m-1][n-1];        \\n    }\\n}\\n```\\n\\n</details>\\n\\n---\\n\\nGo\\n\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\n```\\nfunc uniquePaths(m int, n int) int {\\n    \\n    // Create 2D array with size m x n\\n    path := make( [][]int, m )\\n    rows := make( []int, m * n)\\n    for y := 0 ; y < m ; y++{\\n        path[y] = rows[ y*n : (y+1)*n]\\n    }\\n    \\n    for y := 0 ; y < m ; y++{\\n        for x := 0 ; x < n ; x++{\\n            \\n            if (y == 0) || (x == 0){\\n                path[y][x] = 1\\n            }else{\\n                // just follow the DP recurrence formula\\n                path[y][x] = path[y-1][x] + path[y][x-1]\\n            }\\n            \\n        }\\n    }\\n    \\n    return path[m-1][n-1]\\n}\\n```\\n\\t\\n</details>\\n\\n---\\n\\nJavascript\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\n```\\nvar uniquePaths = function(m, n) {\\n    let perRow = Array(n).fill(1);\\n    \\n    // pathCount is 2D array of size m * n\\n    let pathCount = Array.from( Array(m).fill( perRow ) );\\n    \\n    for(let y = 1 ; y < m ; y++){\\n        for(let x = 1 ; x < n ; x++){\\n            \\n            // path count = number of path reach to one step left + number of path reach to one step up\\n            pathCount[y][x] = pathCount[y][x-1] + pathCount[y-1][x] \\n        }\\n    }\\n    \\n    return pathCount[m-1][n-1]\\n\\n};\\n```\\n\\t\\n</details>\\n\\n\\n---------------------------------------\\n\\nmethod_#2: Math analysis\\n\\n```\\nfrom math import factorial\\n\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        rows, cols = m, n\\n        \\n        # from start to destination, we need (m-1) \\u2193 moves and (n-1) \\u2192 moves\\n        # Thus, the number of unique paths is the number of permutations of (m-1) \\u2193 and (n-1) \\u2192\\n        #\\n        # Number of unique paths = ( m-1 + n-1 ) ! / (m-1)! * (n-1)!\\n        \\n        \\n        return factorial( m+n-2 ) // ( factorial( m-1 ) * factorial( n-1 ) )    \\n```\\n\\n---\\n\\nJavascript:\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\n```\\nvar uniquePaths = function(m, n) {\\n    \\n    \\n    // from start to destination, we need (m-1) \\u2193 moves and (n-1) \\u2192 moves\\n    // Thus, the number of unique paths is the number of permutations of (m-1) \\u2193 and (n-1) \\u2192\\n    //\\n    // Number of unique paths = ( m-1 + n-1 ) ! / (m-1)! * (n-1)!\\n    \\n    let pathCount = factorial( m-1 + n-1 ) / ( factorial( m-1 )*factorial( n-1 ) );\\n    \\n    return pathCount\\n\\n};\\n\\n\\nvar factorial = function( k ){\\n    \\n    if( k == 0 || k == 1 ){\\n        return 1;\\n    }else{\\n        return k * factorial(k-1);\\n    }\\n    \\n};\\n```\\n\\t\\n</details>\\n\\n---\\n\\nC++\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\n```\\nunsigned long int combination( int n, int k )\\n{\\n    if (k > n){     return 0;} \\n    if (k * 2 > n){ k = n-k; } \\n    if (k == 0){    return 1;} \\n\\n    unsigned long int result = n;\\n    for( int i = 2; i <= k; ++i ) {\\n        result *= (n-i+1);\\n        result /= i;\\n    }\\n    return result;\\n}\\n\\nclass Solution {\\npublic:\\n    unsigned int uniquePaths(int m, int n) {\\n        return combination( m-1+n-1, m-1);        \\n    }\\n};\\n```\\n\\t\\n</details>\\n\\n\\n---\\n\\nmethod_#3 Recursion + Memoization\\n\\n```\\n\\n\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        # -----------------------------------\\n        \\n        # key: (m, n) size of grid\\n        # value: total path count from source to destinaion\\n        memo = {}\\n        \\n        def path_count(m, n):\\n            \\n            if (m, n) in memo:\\n                \\n                # look-up in memo\\n                return memo[(m, n)]\\n            \\n            if m == 0 or n == 0:\\n                \\n                # base case\\n                memo[(m, n)] = 0\\n                return 0\\n            \\n            elif m == 1 and n == 1:\\n                \\n                # base case\\n                memo[(m, n)] = 1\\n                return 1\\n\\n            # general case\\n            memo[(m, n)] = path_count(m-1, n) + path_count(m, n-1)\\n            return memo[(m, n)]\\n    \\n        # -----------------------------------\\n        return path_count(m, n)\\n    \\n    \\n\\n\\n```\\n\\n---\\n\\nC++\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        \\n        tuple<int, int> curMatrixSize = tuple<int, int>{m, n};\\n        \\n        if( pathCount.count( curMatrixSize ) ){\\n            return pathCount[ curMatrixSize ];\\n        }\\n        \\n        if( m == 0 || n == 0 ){\\n            // base case\\n            pathCount[ curMatrixSize ] = 0;    \\n            return 0;\\n            \\n        }else if( m == 1 && n == 1){\\n            \\n            // base case\\n            pathCount[ curMatrixSize ] = 1;    \\n            return 1;\\n        }\\n        \\n        // general cases:\\n        pathCount[ curMatrixSize ] = uniquePaths(m-1, n) + uniquePaths(m, n-1);\\n        return pathCount[ curMatrixSize ];\\n        \\n\\n    }\\n\\nprivate:\\n    \\n    // key: tuple of (matrix height, matrix width)\\n    // value: path count of matrix from start to destination\\n    map< tuple<int, int>, int> pathCount;\\n\\n};\\n\\n```\\n\\t\\n</details>\\n\\n---\\n\\nJavascript:\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\n```\\nvar makeKey = function(m, n){\\n    return String(m) + \",\" + String(n);\\n}\\n\\nvar uniquePaths = function(m, n) {\\n    \\n    // key: tuple of (matrix height, matrix width)\\n    // value: path count of matrix from start to destination\\n    pathCount = { };\\n    \\n    var dp = function(m, n){\\n        \\n        let matrixSize = makeKey(m, n);\\n        \\n        if( matrixSize in pathCount ){\\n            return pathCount[matrixSize];\\n        }\\n        \\n        if( m == 0 && n == 0 ){\\n            // base case\\n            pathCount[matrixSize] = 0;\\n            return 0;\\n        }\\n        else if( m == 1 || n == 1){\\n            // base case\\n            pathCount[matrixSize] = 1;\\n            return 1;\\n            \\n        }else{\\n            // general case\\n            pathCount[matrixSize] = dp(m-1, n) + dp(m, n-1);\\n            return pathCount[matrixSize];\\n        }\\n        \\n    }\\n    \\n    \\n    return dp(m, n);\\n\\n};\\n\\n\\n```\\n\\t\\n</details>\\n\\n---\\n\\nRelated Leetcode challenge:\\n\\n[Leetcode #62 Unique Paths](https://leetcode.com/problems/unique-paths)\\n\\n[Leetcode #63 Unique Paths II](https://leetcode.com/problems/unique-paths-ii)\\n\\n[Leetcode #980 Unique Paths III](https://leetcode.com/problems/unique-paths-iii)\\n\\n---",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Math",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        rows, cols = m, n\\n        \\n        path_dp = [ [ 1 for j in range(cols)] for i in range(rows) ]\\n        \\n        \\n        # Dynamic Programming relation:\\n        \\n        # Base case:\\n        # DP(0, j) = 1 , only reachable from one step left\\n        # DP(i, 0) = 1 , only reachable from one step up\\n        \\n        # General case:\\n        # DP(i,j) = number of path reach to (i, j)\\n        #         = number of path reach to one step left + number of path reach to one step up\\n        #         = number of path reach to (i, j-1) + number of path to (i-1, j)\\n        #         = DP(i, j-1) + DP(i-1, j)\\n        \\n        \\n        \\n        for i in range(1, rows):\\n            for j in range(1, cols):\\n                \\n                path_dp[i][j] = path_dp[i][j-1] + path_dp[i-1][j]\\n        \\n        \\n        # Destination coordination = (rows-1, cols-1)\\n        return path_dp[rows-1][cols-1]\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n\\t\\n        vector< vector<int> > path(m, vector<int>(n, 1) );\\n        \\n        for(int y = 1 ; y < m ; y++){\\n            for(int x = 1 ; x < n ; x++){\\n                \\n                // just follow the DP recurrence formula\\n                path[y][x] = path[y][x-1] + path[y-1][x];\\n            }\\n        }\\n        return path[m-1][n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        \\n        int [][]path = new int[m][n];\\n        \\n        // Base case:\\n        \\n        // left-most column\\n        for(int y = 0 ; y < m ; y++){\\n            path[y][0] = 1;\\n        }\\n        \\n        // top-most row\\n        for(int x = 0 ; x < n ; x++){\\n            path[0][x] = 1;\\n        }\\n        \\n        // General cases\\n        for(int y = 1 ; y < m ; y++){\\n            for(int x = 1 ; x < n ; x++){\\n                \\n                // just follow the DP recurrence formula\\n                path[y][x] = path[y][x-1] + path[y-1][x];\\n\\n            }\\n        }\\n        return path[m-1][n-1];        \\n    }\\n}\\n```\n```\\nfunc uniquePaths(m int, n int) int {\\n    \\n    // Create 2D array with size m x n\\n    path := make( [][]int, m )\\n    rows := make( []int, m * n)\\n    for y := 0 ; y < m ; y++{\\n        path[y] = rows[ y*n : (y+1)*n]\\n    }\\n    \\n    for y := 0 ; y < m ; y++{\\n        for x := 0 ; x < n ; x++{\\n            \\n            if (y == 0) || (x == 0){\\n                path[y][x] = 1\\n            }else{\\n                // just follow the DP recurrence formula\\n                path[y][x] = path[y-1][x] + path[y][x-1]\\n            }\\n            \\n        }\\n    }\\n    \\n    return path[m-1][n-1]\\n}\\n```\n```\\nvar uniquePaths = function(m, n) {\\n    let perRow = Array(n).fill(1);\\n    \\n    // pathCount is 2D array of size m * n\\n    let pathCount = Array.from( Array(m).fill( perRow ) );\\n    \\n    for(let y = 1 ; y < m ; y++){\\n        for(let x = 1 ; x < n ; x++){\\n            \\n            // path count = number of path reach to one step left + number of path reach to one step up\\n            pathCount[y][x] = pathCount[y][x-1] + pathCount[y-1][x] \\n        }\\n    }\\n    \\n    return pathCount[m-1][n-1]\\n\\n};\\n```\n```\\nfrom math import factorial\\n\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        rows, cols = m, n\\n        \\n        # from start to destination, we need (m-1) \\u2193 moves and (n-1) \\u2192 moves\\n        # Thus, the number of unique paths is the number of permutations of (m-1) \\u2193 and (n-1) \\u2192\\n        #\\n        # Number of unique paths = ( m-1 + n-1 ) ! / (m-1)! * (n-1)!\\n        \\n        \\n        return factorial( m+n-2 ) // ( factorial( m-1 ) * factorial( n-1 ) )    \\n```\n```\\nvar uniquePaths = function(m, n) {\\n    \\n    \\n    // from start to destination, we need (m-1) \\u2193 moves and (n-1) \\u2192 moves\\n    // Thus, the number of unique paths is the number of permutations of (m-1) \\u2193 and (n-1) \\u2192\\n    //\\n    // Number of unique paths = ( m-1 + n-1 ) ! / (m-1)! * (n-1)!\\n    \\n    let pathCount = factorial( m-1 + n-1 ) / ( factorial( m-1 )*factorial( n-1 ) );\\n    \\n    return pathCount\\n\\n};\\n\\n\\nvar factorial = function( k ){\\n    \\n    if( k == 0 || k == 1 ){\\n        return 1;\\n    }else{\\n        return k * factorial(k-1);\\n    }\\n    \\n};\\n```\n```\\nunsigned long int combination( int n, int k )\\n{\\n    if (k > n){     return 0;} \\n    if (k * 2 > n){ k = n-k; } \\n    if (k == 0){    return 1;} \\n\\n    unsigned long int result = n;\\n    for( int i = 2; i <= k; ++i ) {\\n        result *= (n-i+1);\\n        result /= i;\\n    }\\n    return result;\\n}\\n\\nclass Solution {\\npublic:\\n    unsigned int uniquePaths(int m, int n) {\\n        return combination( m-1+n-1, m-1);        \\n    }\\n};\\n```\n```\\n\\n\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        # -----------------------------------\\n        \\n        # key: (m, n) size of grid\\n        # value: total path count from source to destinaion\\n        memo = {}\\n        \\n        def path_count(m, n):\\n            \\n            if (m, n) in memo:\\n                \\n                # look-up in memo\\n                return memo[(m, n)]\\n            \\n            if m == 0 or n == 0:\\n                \\n                # base case\\n                memo[(m, n)] = 0\\n                return 0\\n            \\n            elif m == 1 and n == 1:\\n                \\n                # base case\\n                memo[(m, n)] = 1\\n                return 1\\n\\n            # general case\\n            memo[(m, n)] = path_count(m-1, n) + path_count(m, n-1)\\n            return memo[(m, n)]\\n    \\n        # -----------------------------------\\n        return path_count(m, n)\\n    \\n    \\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        \\n        tuple<int, int> curMatrixSize = tuple<int, int>{m, n};\\n        \\n        if( pathCount.count( curMatrixSize ) ){\\n            return pathCount[ curMatrixSize ];\\n        }\\n        \\n        if( m == 0 || n == 0 ){\\n            // base case\\n            pathCount[ curMatrixSize ] = 0;    \\n            return 0;\\n            \\n        }else if( m == 1 && n == 1){\\n            \\n            // base case\\n            pathCount[ curMatrixSize ] = 1;    \\n            return 1;\\n        }\\n        \\n        // general cases:\\n        pathCount[ curMatrixSize ] = uniquePaths(m-1, n) + uniquePaths(m, n-1);\\n        return pathCount[ curMatrixSize ];\\n        \\n\\n    }\\n\\nprivate:\\n    \\n    // key: tuple of (matrix height, matrix width)\\n    // value: path count of matrix from start to destination\\n    map< tuple<int, int>, int> pathCount;\\n\\n};\\n\\n```\n```\\nvar makeKey = function(m, n){\\n    return String(m) + \",\" + String(n);\\n}\\n\\nvar uniquePaths = function(m, n) {\\n    \\n    // key: tuple of (matrix height, matrix width)\\n    // value: path count of matrix from start to destination\\n    pathCount = { };\\n    \\n    var dp = function(m, n){\\n        \\n        let matrixSize = makeKey(m, n);\\n        \\n        if( matrixSize in pathCount ){\\n            return pathCount[matrixSize];\\n        }\\n        \\n        if( m == 0 && n == 0 ){\\n            // base case\\n            pathCount[matrixSize] = 0;\\n            return 0;\\n        }\\n        else if( m == 1 || n == 1){\\n            // base case\\n            pathCount[matrixSize] = 1;\\n            return 1;\\n            \\n        }else{\\n            // general case\\n            pathCount[matrixSize] = dp(m-1, n) + dp(m, n-1);\\n            return pathCount[matrixSize];\\n        }\\n        \\n    }\\n    \\n    \\n    return dp(m, n);\\n\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23090,
                "title": "java-solution-0ms-4lines",
                "content": "If you mark the south move as '1' and the east move as '0'. This problem shall be equal to :\\nGiven (m+n-2) bits. you can fill in '1' for (m-1) times and '0' for (n-1) times, what is the number of different numbers?\\n the result is clear that the formula shall be C(m-1)(m+n-2), where m-1 is the superscript behind C and m+n-2 is the subscript behind C.\\nTo avoid overflow, I write the program in this manner.\\n\\npublic class Solution {\\n\\n    public int uniquePaths(int m, int n) {\\n\\n         long result = 1;\\n         for(int i=0;i<Math.min(m-1,n-1);i++)\\n             result = result*(m+n-2-i)/(i+1); \\n         return (int)result;\\n\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int uniquePaths(int m, int n) {\\n\\n         long result = 1;\\n         for(int i=0;i<Math.min(m-1,n-1);i++)\\n             result = result*(m+n-2-i)/(i+1); \\n         return (int)result;\\n\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1635338,
                "title": "clean-recursive-dp-solution-javascript",
                "content": "Essentially we have 2 base cases where we know that:\\n* a 1x1 grid only has 1 path possible\\n* if we theoretically get a grid where m or n is 0, then the grid is invalid and there are 0 possible paths.\\n\\nWith memoization, we can pass down a hash that keeps track of values we have already calculated. If we have already previously saved the value, then we can simply add another base case where it simply returns the value saved in our memoization hash.\\n\\nIf we imagine uniquePaths as a tree of paths, we can either move down or right. Each decision effectively shrinks the grid size by either 1 row when we go down or 1 column when we go right. When drawn out, we can clearly see duplicate nodes that would return the same values, so we can simply save the first solution and refer back to it whenever we encounter it again.\\nTime: O(m * n)\\nSpace: O(m + n)\\n\\n![image](https://assets.leetcode.com/users/images/b0245695-e526-4247-8098-e2cc55efba8e_1639893241.4448733.png)\\n![image](https://assets.leetcode.com/users/images/064dbc78-fe2d-4817-9024-aa36fa826d39_1639892319.575502.png)\\n\\n```\\n const uniquePaths = function(m, n, memo = {}) {\\n     const key = m + \\',\\' + n;\\n     if (key in memo) return memo[key];\\n     if (m === 1 || n === 1) return 1\\n     if (m === 0 || n === 0) return 0;\\n     \\n     memo[key] = uniquePaths(m-1, n, memo) + uniquePaths(m, n-1, memo);\\n     return memo[key];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n const uniquePaths = function(m, n, memo = {}) {\\n     const key = m + \\',\\' + n;\\n     if (key in memo) return memo[key];\\n     if (m === 1 || n === 1) return 1\\n     if (m === 0 || n === 0) return 0;\\n     \\n     memo[key] = uniquePaths(m-1, n, memo) + uniquePaths(m, n-1, memo);\\n     return memo[key];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 184248,
                "title": "8-lines-java-dp-solution-0ms-beats-100-explained-with-graph",
                "content": "The idea is to use a 2D array to keep track of the total possible ways to enter specific block.\nSince we can only go \"DOWN\" and \"RIGHT\", therefore each block could be entered from both \"ABOVE\" and \"LEFT\", therefore adding up their total ways would give the total ways for current block. The idea is illustrated as following:\n![image](https://assets.leetcode.com/users/yfgu0618/image_1540157891.png)\n\nIn order to save the hassles in the future, it's easier that we initialize the array to something like following:\n![image](https://assets.leetcode.com/users/yfgu0618/image_1540158218.png)\nwhich is why `dp[1][0]=1`\n\nFollowing is the code\n```java\n  public static int uniquePaths(int m, int n) {\n    int[][] dp = new int[n + 1][m + 1];\n    dp[1][0] = 1;\n    for (int i = 1; i <= n; i++) {\n      for (int j = 1; j <= m; j++) {\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n      }\n    }\n    return dp[n][m];\n  }\n```",
                "solutionTags": [],
                "code": "```java\n  public static int uniquePaths(int m, int n) {\n    int[][] dp = new int[n + 1][m + 1];\n    dp[1][0] = 1;\n    for (int i = 1; i <= n; i++) {\n      for (int j = 1; j <= m; j++) {\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n      }\n    }\n    return dp[n][m];\n  }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1171708,
                "title": "100-faster-time-98-faster-space-easy-understanding",
                "content": "![image](https://assets.leetcode.com/users/images/9a4cc031-73e9-46e3-86b1-61e63ec9d7c6_1619115060.195593.jpeg)\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int dp[m][n];\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(i == 0 || j == 0)\\n                    dp[i][j] = 1;\\n        for(int i = 1; i < m; i++)\\n            for(int j = 1; j < n; j++)\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n        return dp[m-1][n-1];    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int dp[m][n];\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(i == 0 || j == 0)\\n                    dp[i][j] = 1;\\n        for(int i = 1; i < m; i++)\\n            for(int j = 1; j < n; j++)\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n        return dp[m-1][n-1];    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 511059,
                "title": "javascript-from-naive-recursive-to-dp-bottom-up",
                "content": "(this is my reasoning. It might not be the most optimal. But arrived at this before looking at the solution)\\n\\nProblem can be decomposed into the following sub-problems:\\n * can I go right?\\n * can I go down?\\n\\nand the following base cases to get a response to those questions:\\n\\n* have I gone outside bounds?\\n\\t* return 0. This is not a valid path. \\n\\n* have I reached destination?\\n\\t* return 1. This is a valid path.\\n\\nThen I can add up the numbe of valid paths (see code below)\\n \\n* Here\\'s my progression:\\n  *  Brute force recursive\\n  *  Optimize by memoizing\\n  *  Turn around and make it dp bottom up tabular\\n  *  Further optimize space\\n\\n* Brute force recursive\\n```javascript\\nconst uniquePaths = (m, n) => {\\n    return helper(m, n, 1, 1);\\n};\\n\\nconst helper = (m, n, row, col) => {\\n    if(row === m && col === n) return 1;\\n    if(row > m || col > n) return 0;\\n    \\n    const pathsRight = helper(m, n, row, col + 1);\\n    const pathsDown = helper(m, n, row + 1, col);\\n    \\n    return pathsRight + pathsDown;\\n};\\n```\\n\\n\\n* Memoized\\n```javascript\\nconst uniquePaths = (m, n) => {\\n    const memo = new Array(m + 1).fill(0);\\n    for(let i = 0; i < memo.length; i++) {\\n        memo[i] = new Array(n + 1).fill(-1);\\n    }\\n    return helper(m, n, 1, 1, memo);\\n};\\n\\nconst helper = (m, n, row, col, memo) => {\\n    if(row === m && col === n) return 1;\\n    if(row > m || col > n) return 0;\\n    \\n    if(memo[row][col] === -1) {\\n    \\n        const pathsRight = helper(m, n, row, col + 1, memo);\\n        const pathsDown = helper(m, n, row + 1, col, memo);\\n\\n        memo[row][col] = pathsRight + pathsDown;\\n    }\\n    \\n    return memo[row][col];\\n};\\n```\\n\\n* DP Bottom up tabular\\n```javascript\\nconst uniquePaths = (m, n) => {\\n    const dp = new Array(m + 1).fill(0);\\n    for(let i = 0; i < dp.length; i++) {\\n        dp[i] = new Array(n + 1).fill(1);\\n    }\\n    \\n    dp[m][n] = 1;\\n    for(let row = m - 1; row > 0; row--){\\n        for(let col = n - 1; col > 0; col--){\\n            dp[row][col] = dp[row + 1][col] + dp[row][col + 1];\\n        }\\n    }\\n    \\n    return dp[1][1];\\n};\\n```\\n\\n* DP space optimized (there might be even further space optimization!!)\\n```javascript\\nconst uniquePaths = (m, n) => {\\n    const dp = new Array(n + 1).fill(1);\\n    \\n    for(let row = m - 1; row > 0; row--){\\n        for(let col = n - 1; col > 0; col--){\\n            dp[col] = dp[col] + dp[col + 1];\\n        }\\n    }\\n    return dp[1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Memoization"
                ],
                "code": "```javascript\\nconst uniquePaths = (m, n) => {\\n    return helper(m, n, 1, 1);\\n};\\n\\nconst helper = (m, n, row, col) => {\\n    if(row === m && col === n) return 1;\\n    if(row > m || col > n) return 0;\\n    \\n    const pathsRight = helper(m, n, row, col + 1);\\n    const pathsDown = helper(m, n, row + 1, col);\\n    \\n    return pathsRight + pathsDown;\\n};\\n```\n```javascript\\nconst uniquePaths = (m, n) => {\\n    const memo = new Array(m + 1).fill(0);\\n    for(let i = 0; i < memo.length; i++) {\\n        memo[i] = new Array(n + 1).fill(-1);\\n    }\\n    return helper(m, n, 1, 1, memo);\\n};\\n\\nconst helper = (m, n, row, col, memo) => {\\n    if(row === m && col === n) return 1;\\n    if(row > m || col > n) return 0;\\n    \\n    if(memo[row][col] === -1) {\\n    \\n        const pathsRight = helper(m, n, row, col + 1, memo);\\n        const pathsDown = helper(m, n, row + 1, col, memo);\\n\\n        memo[row][col] = pathsRight + pathsDown;\\n    }\\n    \\n    return memo[row][col];\\n};\\n```\n```javascript\\nconst uniquePaths = (m, n) => {\\n    const dp = new Array(m + 1).fill(0);\\n    for(let i = 0; i < dp.length; i++) {\\n        dp[i] = new Array(n + 1).fill(1);\\n    }\\n    \\n    dp[m][n] = 1;\\n    for(let row = m - 1; row > 0; row--){\\n        for(let col = n - 1; col > 0; col--){\\n            dp[row][col] = dp[row + 1][col] + dp[row][col + 1];\\n        }\\n    }\\n    \\n    return dp[1][1];\\n};\\n```\n```javascript\\nconst uniquePaths = (m, n) => {\\n    const dp = new Array(n + 1).fill(1);\\n    \\n    for(let row = m - 1; row > 0; row--){\\n        for(let col = n - 1; col > 0; col--){\\n            dp[col] = dp[col] + dp[col + 1];\\n        }\\n    }\\n    return dp[1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 23122,
                "title": "sharing-my-0ms-java-solution-with-detailed-exploration",
                "content": "public class UniquePaths {\\n\\n\\t public int uniquePathsSample(int m, int n) {\\n\\t\\tint[] dp = new int[m];\\n\\t\\tdp[0] = 1;\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tfor (int j = 1; j < m; j++)\\n\\t\\t\\t\\tdp[j] = dp[j - 1] + dp[j];\\n\\t\\treturn dp[m - 1];\\n\\t}\\n\\n}\\n\\nFirst, image you have a m*n matrix, and you start from the left-top corner, to the right-bottom corner. And at the beginning, the matrix[0][0] would be 1, means you only have one way to reach the position where you are. And then if you want to move to the end of the first row, which is matrix[0][n-1], you only have one way to be there, too, you just need to move along the first row, to the rightmost position. Thus, you may set all values in the first row to 1.\\n\\nAnd then you move down, if you want to reach the bottom of the leftmost column. Similarly, you only have one way to be there, too, thus you can also set all values in the leftmost column to be 1.\\n\\nLet's go further, if you want to reach the right end of second row, how many different paths you can choose? Let's say, if you want to get matrix[1][1], you can either move right firstly, then move down, or you can move down firstly, then move right. So you will have two paths to reach the position(1,1), then matrix[1][1] will equal 2. So how can we get this number in general?\\n\\nObviously, we could know matrix[i][j] = matrix[i-1][j] + matrix[i][j-1], because if we can get the position (i-1,j) or (i, j-1), then we only have one way to reach the destination -- move down or move right -- thus we use this formula matrix[i][j] = matrix[i-1][j] + matrix[i][j-1] to fill up all of the values in the matrix.\\n\\nFurther more, do we really need o(m*n) space to help us finishing this task? Not really, through filling the matrix, we may see the filling task could be fulfilled layer by layer. Another saying, we could use only 1-dimension array to present each row of the matrix. And we fill the array again and again till n times (0,1,2...n-1). And finally we will get the result we want.",
                "solutionTags": [],
                "code": "public class UniquePaths {\\n\\n\\t public int uniquePathsSample(int m, int n) {\\n\\t\\tint[] dp = new int[m];\\n\\t\\tdp[0] = 1;\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tfor (int j = 1; j < m; j++)\\n\\t\\t\\t\\tdp[j] = dp[j - 1] + dp[j];\\n\\t\\treturn dp[m - 1];\\n\\t}\\n\\n}\\n\\nFirst, image you have a m*n matrix, and you start from the left-top corner, to the right-bottom corner. And at the beginning, the matrix[0][0] would be 1, means you only have one way to reach the position where you are. And then if you want to move to the end of the first row, which is matrix[0][n-1], you only have one way to be there, too, you just need to move along the first row, to the rightmost position. Thus, you may set all values in the first row to 1.\\n\\nAnd then you move down, if you want to reach the bottom of the leftmost column. Similarly, you only have one way to be there, too, thus you can also set all values in the leftmost column to be 1.\\n\\nLet's go further, if you want to reach the right end of second row, how many different paths you can choose? Let's say, if you want to get matrix[1][1], you can either move right firstly, then move down, or you can move down firstly, then move right. So you will have two paths to reach the position(1,1), then matrix[1][1] will equal 2. So how can we get this number in general?\\n\\nObviously, we could know matrix[i][j] = matrix[i-1][j] + matrix[i][j-1], because if we can get the position (i-1,j) or (i, j-1), then we only have one way to reach the destination -- move down or move right -- thus we use this formula matrix[i][j] = matrix[i-1][j] + matrix[i][j-1] to fill up all of the values in the matrix.\\n\\nFurther more, do we really need o(m*n) space to help us finishing this task? Not really, through filling the matrix, we may see the filling task could be fulfilled layer by layer. Another saying, we could use only 1-dimension array to present each row of the matrix. And we fill the array again and again till n times (0,1,2...n-1). And finally we will get the result we want.",
                "codeTag": "Java"
            },
            {
                "id": 1582017,
                "title": "python-simple-one-liner-math-solution-with-explanation",
                "content": "### Explanation\\n\\nFor any given ```M x N``` grid, each unique path (no matter which one it is) requires you to move right from the starting point ```N - 1``` times and move down from the starting point ```M - 1``` times. Hence, regardless of the order you choose to move right or down, you need to make a total of ```(M - 1) + (N - 1) = M + N - 2``` moves.\\n\\nThen, out of the ```M + N - 2``` moves, we need to select ```M - 1``` moves to move right and the remaining ```N - 1``` moves to move down. This essentially is why this problem boils down to combinatorics, because we need to calculate how many different ways we can select ```M - 1``` moves from ```M + N - 2``` moves (or equivalently, ```N - 1``` moves from ```M + N - 2``` moves).\\n\\nFor more information I suggest reading [this Stack Exchange post](https://math.stackexchange.com/questions/2486807/number-of-unique-paths-in-m-times-n-matrix-combination-or-permutation). There are tons of other resources that explain this problem in greater detail too.\\n\\n---\\n\\n### Code\\n\\n```python\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        return math.comb(m+n-2, m-1)  # or math.comb(m+n-2, n-1)\\n```\\n\\n---\\n\\n### Final Result\\n\\n![image](https://assets.leetcode.com/users/images/7e02c6e5-c597-43d0-9171-887a45d10f25_1634915058.3338945.png)\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```M x N```\n```N - 1```\n```M - 1```\n```(M - 1) + (N - 1) = M + N - 2```\n```M + N - 2```\n```M - 1```\n```N - 1```\n```M - 1```\n```M + N - 2```\n```N - 1```\n```M + N - 2```\n```python\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        return math.comb(m+n-2, m-1)  # or math.comb(m+n-2, n-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362027,
                "title": "3-approaches-dp-recursion-math",
                "content": "[Leetcode](https://leetcode.com/) [62. Unique Paths](https://leetcode.com/problems/unique-paths).\\n\\nHere shows **3** Approaches to slove this problem: Dynamic Programming, Recursion, Math.\\n\\n\\n# Dynamic Programming\\n\\nThe equation is: $f(i, j) = f(i\\u22121, j) + f(i, j\\u22121)$.\\n\\n```java\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n\\n        for (int i = 0; i < n; i++) {\\n            dp[0][i] = 1;\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            dp[i][0] = 1;\\n        }\\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = Math.max(dp[i][j - 1] + 1, dp[i][j - 1] + dp[i - 1][j]);\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(mn)$\\n- **Space Complexity**: $O(mn)$\\n\\n# Recursion\\n\\nThe DFS is top-down dynamic programming with **memoization**. If we do ordinary DFS without proper memoization, it will have a TLE error.\\n\\n```java\\n    public int uniquePaths(int m, int n) {\\n        return dfs(new HashMap<Pair, Integer>(), 0, 0, m, n);\\n    }\\n\\n    private static int dfs(Map<Pair, Integer> cache, int r, int c, int rows, int cols) {\\n        Pair p = new Pair(r, c);\\n\\n        if (cache.containsKey(p)) {\\n            return cache.get(p);\\n        }\\n\\n        if (r == rows - 1 || c == cols - 1) {\\n            return 1;\\n        }\\n        \\n        cache.put(p, dfs(cache, r + 1, c, rows, cols) + dfs(cache, r, c + 1, rows, cols));\\n        return cache.get(p);\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(mn)$\\n- **Space Complexity**: $O(mn)$\\n\\n# Combination Math\\n\\nIn the process from the top left to the bottom right, we need to move $m+n-2$ steps, of which there are $m-1$ moves down and $n-1$ times to the right. \\n\\nTherefore, the total number of paths is equal to the number of options for selecting $m-1$ downward moves from $m+n-2$ moves, that is, the number of combinations:\\n\\n$$\\n{\\\\Large C}_{m+n-2}^{m-1} = \\\\binom{m+n-2}{m-1} = \\\\frac{(m+n-2)(m+n-3)\\\\cdots n}{(m-1)!} = \\\\frac{(m+n-2)!}{(m-1)!(n-1)!}\\n$$\\n\\nWe can use $\\\\frac{(m+n-2)(m+n-3)\\\\cdots n}{(m-1)!}$ to calcuate the number.\\n\\u200B\\n```java\\n    public static int uniquePaths_math(int m, int n) {\\n        long ans = 1;\\n        \\n        for (int x = n, y = 1; y < m; ++x, ++y) {\\n            ans = ans * x / y;\\n        }\\n\\n        return (int) ans;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(m)$\\n- **Space Complexity**: $O(1)$\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```java\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n\\n        for (int i = 0; i < n; i++) {\\n            dp[0][i] = 1;\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            dp[i][0] = 1;\\n        }\\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = Math.max(dp[i][j - 1] + 1, dp[i][j - 1] + dp[i - 1][j]);\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n```\n```java\\n    public int uniquePaths(int m, int n) {\\n        return dfs(new HashMap<Pair, Integer>(), 0, 0, m, n);\\n    }\\n\\n    private static int dfs(Map<Pair, Integer> cache, int r, int c, int rows, int cols) {\\n        Pair p = new Pair(r, c);\\n\\n        if (cache.containsKey(p)) {\\n            return cache.get(p);\\n        }\\n\\n        if (r == rows - 1 || c == cols - 1) {\\n            return 1;\\n        }\\n        \\n        cache.put(p, dfs(cache, r + 1, c, rows, cols) + dfs(cache, r, c + 1, rows, cols));\\n        return cache.get(p);\\n    }\\n```\n```java\\n    public static int uniquePaths_math(int m, int n) {\\n        long ans = 1;\\n        \\n        for (int x = n, y = 1; y < m; ++x, ++y) {\\n            ans = ans * x / y;\\n        }\\n\\n        return (int) ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1513886,
                "title": "java-tc-o-m-n-sc-o-min-m-n-space-optimized-dynamic-programming-solution",
                "content": "**Space optimized Dynamic Programming solution**\\n\\n```java\\n/**\\n * Space optimized Dynamic Programming solution\\n *\\n * dp[i][j] = Number of ways to reach this cell [i][j].\\n * dp[i][j] = dp[i][j-1] + dp[i-1][j].\\n *\\n * This can be solved by using one array representing the row.\\n *\\n * Let M = number of rows and N = number of columns. Thus the row size will be\\n * N. Try to minimize N by swapping M and N if M < N;\\n *\\n * Time Complexity: O(M * N).\\n *\\n * Space Complexity = O(min(M, N)). Only one row is used for dp.\\n */\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        if (m <= 0 || n <= 0) {\\n            return 0;\\n        }\\n        if (m == 1 || n == 1) {\\n            return 1;\\n        }\\n        if (m < n) {\\n            uniquePaths(n, m);\\n        }\\n\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, 1);\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[j] += dp[j - 1];\\n            }\\n        }\\n\\n        return dp[n - 1];\\n    }\\n}\\n```\\n\\n---\\n**Math Solution using Combinatorics**\\n\\n```java\\n/**\\n * Find the total permutations of the directions to be travelled. For example\\n * D,D,D,D,R,R,R,R -> Find permutations of this list\\n *\\n * This is a combinatorial problem and can be solved without DP. For mxn grid,\\n * robot has to move exactly m-1 steps down and n-1 steps right and these can be\\n * done in any order.\\n *\\n * For the eg., given in question, 3x7 matrix, robot needs to take 2+6 = 8 steps\\n * with 2 down and 6 right in any order. That is nothing but a permutation\\n * problem. Denote down as \\'D\\' and right as \\'R\\', following is one of the path :-\\n *\\n * D R R R D R R R\\n *\\n * We have to tell the total number of permutations of the above given word. So,\\n * decrease both m & n by 1 and apply following formula:-\\n *\\n * Total permutations = (m+n)! / (m! * n!)\\n *\\n * Time Complexity: O(min(M,N)). Assuming Multiplication and Division takes\\n * O(1).\\n *\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        if (m <= 0 || n <= 0) {\\n            return 0;\\n        }\\n        if (m == 1 || n == 1) {\\n            return 1;\\n        }\\n        if (m < n) {\\n            uniquePaths(n, m);\\n        }\\n\\n        m--;\\n        n--;\\n        long paths = 1;\\n        for (int i = 1; i <= n; i++) {\\n            paths *= (m + i);\\n            paths /= i;\\n        }\\n\\n        return (int) paths;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Unique Path question on LeetCode:\\n- [63. Unique Paths II](https://leetcode.com/problems/unique-paths-ii/discuss/1513891/Java-or-TC:-O(R*C)-or-SC:-O(min(RC))-or-Space-optimized-Dynamic-Programming-solution)\\n- [64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/discuss/1513899/Java-or-TC:-O(R*C)-or-SC:-O(min(RC))-or-Space-optimized-Dynamic-Programming-solution)\\n- [980. Unique Paths III](https://leetcode.com/problems/unique-paths-iii/discuss/1513906/Java-or-TC:-O(3(R*C))-or-SC:-O(R*C)-or-DFS-solution-with-Backtracking)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Dynamic Programming",
                    "Matrix",
                    "Combinatorics"
                ],
                "code": "```java\\n/**\\n * Space optimized Dynamic Programming solution\\n *\\n * dp[i][j] = Number of ways to reach this cell [i][j].\\n * dp[i][j] = dp[i][j-1] + dp[i-1][j].\\n *\\n * This can be solved by using one array representing the row.\\n *\\n * Let M = number of rows and N = number of columns. Thus the row size will be\\n * N. Try to minimize N by swapping M and N if M < N;\\n *\\n * Time Complexity: O(M * N).\\n *\\n * Space Complexity = O(min(M, N)). Only one row is used for dp.\\n */\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        if (m <= 0 || n <= 0) {\\n            return 0;\\n        }\\n        if (m == 1 || n == 1) {\\n            return 1;\\n        }\\n        if (m < n) {\\n            uniquePaths(n, m);\\n        }\\n\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, 1);\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[j] += dp[j - 1];\\n            }\\n        }\\n\\n        return dp[n - 1];\\n    }\\n}\\n```\n```java\\n/**\\n * Find the total permutations of the directions to be travelled. For example\\n * D,D,D,D,R,R,R,R -> Find permutations of this list\\n *\\n * This is a combinatorial problem and can be solved without DP. For mxn grid,\\n * robot has to move exactly m-1 steps down and n-1 steps right and these can be\\n * done in any order.\\n *\\n * For the eg., given in question, 3x7 matrix, robot needs to take 2+6 = 8 steps\\n * with 2 down and 6 right in any order. That is nothing but a permutation\\n * problem. Denote down as \\'D\\' and right as \\'R\\', following is one of the path :-\\n *\\n * D R R R D R R R\\n *\\n * We have to tell the total number of permutations of the above given word. So,\\n * decrease both m & n by 1 and apply following formula:-\\n *\\n * Total permutations = (m+n)! / (m! * n!)\\n *\\n * Time Complexity: O(min(M,N)). Assuming Multiplication and Division takes\\n * O(1).\\n *\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        if (m <= 0 || n <= 0) {\\n            return 0;\\n        }\\n        if (m == 1 || n == 1) {\\n            return 1;\\n        }\\n        if (m < n) {\\n            uniquePaths(n, m);\\n        }\\n\\n        m--;\\n        n--;\\n        long paths = 1;\\n        for (int i = 1; i <= n; i++) {\\n            paths *= (m + i);\\n            paths /= i;\\n        }\\n\\n        return (int) paths;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996056,
                "title": "dp-easy-to-understand-solution-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nExplore all options i.e down + right\\n\\n`for detailed explanation you can refer to my youtube channel` \\n\\n[ Video in Hindi click here](https://youtube.com/@LetsCodeTogether72/videos)\\n\\nor link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The `uniquePaths` function initializes a 2D array `dp` of size 101x101 to store intermediate results. It also sets all values in `dp` to -1 as an indicator that they need to be computed.\\n\\n2. The `solve` function is a recursive helper function that calculates the number of unique paths from a given position `(i, j)` to the bottom-right corner `(m-1, n-1)`.\\n\\n3. In the `solve` function, it first checks if we have reached either the last row (`i == m-1`) or the last column (`j == n-1`). If either of these conditions is met, there is only one way to reach the destination, so it returns 1.\\n\\n4. If the value of `dp[i][j]` is not -1, it means we have already computed the number of unique paths from this position, so it returns the stored value.\\n\\n5. If none of the above conditions are met, it calculates the number of unique paths recursively by summing the paths from moving down (`solve(m, n, i+1, j)`) and moving right (`solve(m, n, i, j+1)`). It then stores this value in `dp[i][j]` to avoid redundant calculations and returns it.\\n\\n6. Finally, in the `uniquePaths` function, it calls the `solve` function with initial arguments `(0, 0)` to start the recursive calculation from the top-left corner and returns the result.\\n\\n\\n# Complexity\\n- Time complexity:$$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(int m,int n,int i,int j){\\n        if(i==m-1||j==n-1){\\n            return 1;\\n        }\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        return dp[i][j]=solve(m,n,i+1,j)+solve(m,n,i,j+1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(m,n,0,0);\\n    }\\n};\\n```\\n```java []\\npublic class Solution {\\n    int[][] dp;\\n\\n    public int uniquePaths(int m, int n) {\\n        dp = new int[m][n];\\n\\n        // Initialize dp grid with -1 values\\n        for (int i = 0; i < m; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n\\n        return solve(m, n, 0, 0);\\n    }\\n\\n    private int solve(int m, int n, int i, int j) {\\n        if (i == m - 1 || j == n - 1) {\\n            return 1;\\n        }\\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        return dp[i][j] = solve(m, n, i + 1, j) + solve(m, n, i, j + 1);\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[-1] * n for _ in range(m)]\\n\\n        def solve(i, j):\\n            if i == m - 1 or j == n - 1:\\n                return 1\\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            dp[i][j] = solve(i + 1, j) + solve(i, j + 1)\\n            return dp[i][j]\\n\\n        return solve(0, 0)\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(int m,int n,int i,int j){\\n        if(i==m-1||j==n-1){\\n            return 1;\\n        }\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        return dp[i][j]=solve(m,n,i+1,j)+solve(m,n,i,j+1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(m,n,0,0);\\n    }\\n};\\n```\n```java []\\npublic class Solution {\\n    int[][] dp;\\n\\n    public int uniquePaths(int m, int n) {\\n        dp = new int[m][n];\\n\\n        // Initialize dp grid with -1 values\\n        for (int i = 0; i < m; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n\\n        return solve(m, n, 0, 0);\\n    }\\n\\n    private int solve(int m, int n, int i, int j) {\\n        if (i == m - 1 || j == n - 1) {\\n            return 1;\\n        }\\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        return dp[i][j] = solve(m, n, i + 1, j) + solve(m, n, i, j + 1);\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[-1] * n for _ in range(m)]\\n\\n        def solve(i, j):\\n            if i == m - 1 or j == n - 1:\\n                return 1\\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            dp[i][j] = solve(i + 1, j) + solve(i, j + 1)\\n            return dp[i][j]\\n\\n        return solve(0, 0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582266,
                "title": "0-ms-c-easy-to-understand-with-explanation-tabulation-memoization-dp",
                "content": "**Thanks in advance for reading.**\\nPls upvote if this helps and feel free to suggest changes.\\n.\\n.\\nWe have to find the total number of unique paths.\\n\\n# Basic Idea\\nLet we are currently at (i,j) i.e. i-th row and j-th column, Then we can either move right or down.\\nLet the number of unique paths from (i,j+1) i.e. right cell to destination be x \\nand number of unique paths from (i+1,j) i.e. bottom cell to destination be y.\\n\\nThen, number of unique paths from (i,j) i.e. current cell to destination will be x+y.\\n\\n**Note**\\nif right cell (i,j+1) doesn\\'t exist, then treat x as 0.\\nif bottom cell (i+1,j) doesn\\'t exist, then we treat y as 0.\\n\\nSo we can easily do it with plain recursion, but\\n# Point to observe\\nconsider the cell (5,6) , recursion function will be called for this cell more than once. for example, this cell acts as bottom cell for (4,6). So whenever function call for (4,6) is made, recursive call for (5,6) too.\\nHowever answer will always be the same for same input. Same happens when function call for (5,5) is made since (5,6) acts as right cell for it.\\n\\nSo inorder to avoid computing the same thing again and again. We store the result of compuatation in a array (concept of dynamic prograaming). So if a function call is made for some input for which the computation is already done. We just return the value that we stored after getting the result when the computation was performed.\\n\\nThe above said logic can be implemented in the following two ways.\\n\\n**1) Memoization(top-down) code follows**\\ni.e. using recursive implementation\\n```\\nclass Solution\\n{\\n  public:\\n  int uniquePaths(int m, int n)\\n  {\\n    vector<vector<int>> dp(m+1,vector<int>(n+1,-1)) ;\\n    int x = 1 , y =1 ; // we start from (1,1)\\n      dp[m][n] = 1 ; // no. of unique paths from destination to itself is 1\\n    \\n      return solve(x,y,m,n,dp) ;\\n  }\\n  \\n  int solve(int x, int y, int m, int n, vector<vector<int>>& dp)\\n  {\\n    if(x<1 || x>m || y<1 || y>n) // if the current cell doesn\\'t exist return 0\\n        return 0 ;\\n      \\n      if(dp[x][y] != -1) // if answer for this cell is already calculated, return the stored value\\n         return dp[x][y] ;\\n     \\n    dp[x][y] = solve(x,y+1,m,n,dp) + solve(x+1,y,m,n,dp) ; // sum of paths from right cell and bottom cell\\n    \\n      return dp[x][y] ;\\n  }\\n} ;\\n\\n```\\n\\nTime Complexity : O(m*n)\\nSpace Complexity : O(m*n)\\n\\n.\\n.\\n.\\n\\n**2) Tabulation(bottom-up) code follows**\\ni.e using iterative implementation\\n```\\n\\nclass Solution \\n{\\npublic:\\n    int uniquePaths(int m, int n)\\n    {\\n        vector<vector<int>> dp(m+1, vector<int>(n+1,1)) ;\\n        \\n        for (int i = 2; i <= m; i++) \\n        {\\n            for (int j = 2; j <= n; j++) \\n            {\\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n\\n```\\n\\nTime Complexity : O(m*n)\\nSpace Complexity : O(m*n)\\n\\nupvote if this is helpful",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n  public:\\n  int uniquePaths(int m, int n)\\n  {\\n    vector<vector<int>> dp(m+1,vector<int>(n+1,-1)) ;\\n    int x = 1 , y =1 ; // we start from (1,1)\\n      dp[m][n] = 1 ; // no. of unique paths from destination to itself is 1\\n    \\n      return solve(x,y,m,n,dp) ;\\n  }\\n  \\n  int solve(int x, int y, int m, int n, vector<vector<int>>& dp)\\n  {\\n    if(x<1 || x>m || y<1 || y>n) // if the current cell doesn\\'t exist return 0\\n        return 0 ;\\n      \\n      if(dp[x][y] != -1) // if answer for this cell is already calculated, return the stored value\\n         return dp[x][y] ;\\n     \\n    dp[x][y] = solve(x,y+1,m,n,dp) + solve(x+1,y,m,n,dp) ; // sum of paths from right cell and bottom cell\\n    \\n      return dp[x][y] ;\\n  }\\n} ;\\n\\n```\n```\\n\\nclass Solution \\n{\\npublic:\\n    int uniquePaths(int m, int n)\\n    {\\n        vector<vector<int>> dp(m+1, vector<int>(n+1,1)) ;\\n        \\n        for (int i = 2; i <= m; i++) \\n        {\\n            for (int j = 2; j <= n; j++) \\n            {\\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994595,
                "title": "video-ex-amazon-explains-a-solution-with-python-javascript-java-and-c",
                "content": "# Intuition\\nThe main idea to solve the unique paths question is to use dynamic programming to calculate the number of unique paths from the top-left corner of a grid to the bottom-right corner. \\n\\nThis approach efficiently solves the problem by breaking it down into smaller subproblems and avoiding redundant calculations. It\\'s a classic example of dynamic programming used for finding solutions to grid-related problems.\\n\\n---\\n\\n# Solution Video\\n\\n### Please subscribe to my channel from here. I have 253 videos as of September 3rd, 2023.\\n\\nhttps://youtu.be/6NorAYw7NMU\\n\\n### In the video, the steps of approach below are visualized using diagrams and drawings. I\\'m sure you understand the solution easily!\\n\\n### \\u2B50\\uFE0F Don\\'t forget to subscribe to my channel!\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be differnt a bit.\\n\\n1. **Initialization of the AboveRow list**\\n   - Main Point: Initialize the aboveRow list with `n` elements, all set to 1.\\n   - Detailed Explanation: This list represents the number of unique paths for each column in the top row of the grid. It\\'s initialized with 1 because there\\'s only one way to reach each cell in the top row, which is by moving horizontally.\\n\\n2. **Iteration through Rows**\\n   - Main Point: Loop `m - 1` times, where `m` is the number of rows in the grid.\\n   - Detailed Explanation: This loop iterates over each row below the top row. The `-1` is used because the top row was already initialized, and there\\'s no need to recompute it.\\n\\n3. **Creating a New Row**\\n   - Main Point: Inside the loop, create a new list called currentRow with `n` elements, all set to 1.\\n   - Detailed Explanation: For each row below the top row, we create a new list to store the number of unique paths for each column in that row. All values are initialized to 1 because there are no previous paths to consider yet.\\n\\n4. **Nested Loop for Columns**\\n   - Main Point: Iterate over each column in the currentRow from index 1 to `n - 1`.\\n   - Detailed Explanation: This nested loop starts from index 1 because the cell at index 0 already has one unique path, and we want to calculate the number of unique paths for the remaining cells in the current row.\\n\\n5. **Updating Cell Values**\\n   - Main Point: In the nested loop, update the currentRow list at index `i` by adding the value at index `i-1` of the currentRow and the value at index `i` of the aboveRow.\\n   - Detailed Explanation: This step implements the dynamic programming logic. The number of unique paths to reach a cell in the current row is the sum of the number of paths to reach the cell immediately to the left (in the same row) and the number of paths to reach the cell above it (from the aboveRow).\\n\\n6. **Updating aboveRow**\\n   - Main Point: After the nested loop completes, update the aboveRow to be equal to the currentRow.\\n   - Detailed Explanation: We update the aboveRow to be the same as the currentRow because it becomes the reference for the next row calculation.\\n\\n7. **Returning the Result**\\n   - Main Point: Once the outer loop finishes, return the last element of the aboveRow list, which represents the number of unique paths to reach the bottom-right cell of the grid.\\n   - Detailed Explanation: The final result is stored in the last element of the aboveRow list because it represents the number of unique paths to reach the last column in the last row, which is the destination cell.\\n\\nThis algorithm efficiently calculates the number of unique paths to traverse an `m x n` grid from the top-left corner to the bottom-right corner using dynamic programming.\\n\\n# Complexity\\n- Time complexity: O(m * n)\\n\\n- Space complexity: O(n)\\nn is the number of columns in the grid\\n\\n```python []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n\\n        aboveRow = [1] * n\\n\\n        for _ in range(m - 1):\\n            currentRow = [1] * n\\n            for i in range(1, n):\\n                currentRow[i] = currentRow[i-1] + aboveRow[i]\\n            aboveRow = currentRow\\n        \\n        return aboveRow[-1]\\n```\\n```javascript []\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @return {number}\\n */\\nvar uniquePaths = function(m, n) {\\n    let aboveRow = Array(n).fill(1);\\n\\n    for (let row = 1; row < m; row++) {\\n        let currentRow = Array(n).fill(1);\\n        for (let col = 1; col < n; col++) {\\n            currentRow[col] = currentRow[col - 1] + aboveRow[col];\\n        }\\n        aboveRow = currentRow;\\n    }\\n\\n    return aboveRow[n - 1];    \\n};\\n```\\n```java []\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[] aboveRow = new int[n];\\n        Arrays.fill(aboveRow, 1);\\n\\n        for (int row = 1; row < m; row++) {\\n            int[] currentRow = new int[n];\\n            Arrays.fill(currentRow, 1);\\n            for (int col = 1; col < n; col++) {\\n                currentRow[col] = currentRow[col - 1] + aboveRow[col];\\n            }\\n            aboveRow = currentRow;\\n        }\\n\\n        return aboveRow[n - 1];        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        std::vector<int> aboveRow(n, 1);\\n\\n        for (int row = 1; row < m; row++) {\\n            std::vector<int> currentRow(n, 1);\\n            for (int col = 1; col < n; col++) {\\n                currentRow[col] = currentRow[col - 1] + aboveRow[col];\\n            }\\n            aboveRow = currentRow;\\n        }\\n\\n        return aboveRow[n - 1];        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n\\n        aboveRow = [1] * n\\n\\n        for _ in range(m - 1):\\n            currentRow = [1] * n\\n            for i in range(1, n):\\n                currentRow[i] = currentRow[i-1] + aboveRow[i]\\n            aboveRow = currentRow\\n        \\n        return aboveRow[-1]\\n```\n```javascript []\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @return {number}\\n */\\nvar uniquePaths = function(m, n) {\\n    let aboveRow = Array(n).fill(1);\\n\\n    for (let row = 1; row < m; row++) {\\n        let currentRow = Array(n).fill(1);\\n        for (let col = 1; col < n; col++) {\\n            currentRow[col] = currentRow[col - 1] + aboveRow[col];\\n        }\\n        aboveRow = currentRow;\\n    }\\n\\n    return aboveRow[n - 1];    \\n};\\n```\n```java []\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[] aboveRow = new int[n];\\n        Arrays.fill(aboveRow, 1);\\n\\n        for (int row = 1; row < m; row++) {\\n            int[] currentRow = new int[n];\\n            Arrays.fill(currentRow, 1);\\n            for (int col = 1; col < n; col++) {\\n                currentRow[col] = currentRow[col - 1] + aboveRow[col];\\n            }\\n            aboveRow = currentRow;\\n        }\\n\\n        return aboveRow[n - 1];        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        std::vector<int> aboveRow(n, 1);\\n\\n        for (int row = 1; row < m; row++) {\\n            std::vector<int> currentRow(n, 1);\\n            for (int col = 1; col < n; col++) {\\n                currentRow[col] = currentRow[col - 1] + aboveRow[col];\\n            }\\n            aboveRow = currentRow;\\n        }\\n\\n        return aboveRow[n - 1];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362451,
                "title": "c-easy-math-combinatorics-o-1-spaces",
                "content": "#### **Upvote if you like it**\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int k=m+n-2;\\n      long  ans=1;\\n        for(int i=1;i<=n-1;++i){\\n            \\n            \\n           ans=ans*(k-(n-1)+i)/i;\\n        }\\n        return (int)ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int k=m+n-2;\\n      long  ans=1;\\n        for(int i=1;i<=n-1;++i){\\n            \\n            \\n           ans=ans*(k-(n-1)+i)/i;\\n        }\\n        return (int)ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116646,
                "title": "very-simple-javascript-solution-in-100th-percentile-56ms",
                "content": "Given that the pure math solution using factorials can be numerically unstable, I opted for the DP approach that uses O(n) space for a single row vector that I update iteratively.\n\nFor context, here's an example for how to fill out a 3x6 grid in the more traditional DP regime:\n```\n0 | 1  | 1  | 1  | 1  | 1\n1 | 2  | 3  | 4  | 5  | 6\n1 | 3  | 6  | 10 | 15 | 21\n```\nNotice that for every i and j, matrix[i][j] is the total number of ways of getting to (i, j). The first row and first column of this matrix are trivial cases because we can only move down and to the right, so they will always be vectors of 1s with matrix[0][0] = 0 as a degenerate base case.\n```\n0 | 1  | 1  | 1  | 1  | 1\n1 | 0  | 0  | 0  | 0  | 0\n1 | 0  | 0  | 0  | 0  | 0\n```\nFrom the initialization above, we can work row by row, assigning matrix[i][j] = matrix[i][j-1] + matrix[i-1][j], getting a grid that looks like the first one above. The solution is the bottom-right value of this matrix.\n\nThe insight with my implementation is that we don't need to allocate the full mxn matrix. One row will suffice. Initialize the first row the same way you did before and simply mutate the values of that first row with the new values of the second row. You can iterate this process until you have calcluated the final row of the matrix. This works because we will only ever need row k to calculate the values of row k+1;\n\n```javascript\n/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar uniquePaths = function(m, n) {\n    let currentRow = new Array(n);\n    // Assigning a 1 to matrix[0][0] is simply a shortcut that skips some later computation\n    // as matrix[i][0] will never change in this iterative process\n    for (let i = 0; i < n; i++) {\n        currentRow[i] = 1;\n    }\n    for (let row = 1; row < m; row++) {\n        for (let i = 1; i < n; i++) {\n            currentRow[i] += currentRow[i - 1];\n        }\n    }\n    return currentRow[n - 1];\n};\n```",
                "solutionTags": [],
                "code": "```\n0 | 1  | 1  | 1  | 1  | 1\n1 | 2  | 3  | 4  | 5  | 6\n1 | 3  | 6  | 10 | 15 | 21\n```\n```\n0 | 1  | 1  | 1  | 1  | 1\n1 | 0  | 0  | 0  | 0  | 0\n1 | 0  | 0  | 0  | 0  | 0\n```\n```javascript\n/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar uniquePaths = function(m, n) {\n    let currentRow = new Array(n);\n    // Assigning a 1 to matrix[0][0] is simply a shortcut that skips some later computation\n    // as matrix[i][0] will never change in this iterative process\n    for (let i = 0; i < n; i++) {\n        currentRow[i] = 1;\n    }\n    for (let row = 1; row < m; row++) {\n        for (let i = 1; i < n; i++) {\n            currentRow[i] += currentRow[i - 1];\n        }\n    }\n    return currentRow[n - 1];\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2362303,
                "title": "java-easy-solution-using-dp-100-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution \\n{\\n    public int uniquePaths(int m, int n)\\n    {\\n        int dp[][]=new int[m][n];\\n        \\n        for(int i=0;i<m;i++)\\n            dp[i][0]=1;\\n        \\n        for(int i=0;i<n;i++)\\n            dp[0][i]=1;\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int uniquePaths(int m, int n)\\n    {\\n        int dp[][]=new int[m][n];\\n        \\n        for(int i=0;i<m;i++)\\n            dp[i][0]=1;\\n        \\n        for(int i=0;i<n;i++)\\n            dp[0][i]=1;\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774807,
                "title": "fastest-100-faster-and-simplest-java-solution-using-dynamic-programming",
                "content": "```\\nclass Solution {\\n       public int uniquePaths(int m, int n) {//in this question m is considered as columns and n as rows(usually we take first element written as rows but it is reversed here )\\n        int[][] matrix = new int[n][m]; // create a matrix in which value of every element represents the total possible ways to reach there.\\n       \\n        for (int i = 0; i < m; i++) {\\n            matrix[0][i] = 1;//as there is only one way to reach every element having index (0,i).i.e->(0,1)->(0,2)->(0,3)->--so on till (0,m) and it is by moving right from (0,0)\\n\\n        }\\n        for (int i = 0; i < n; i++) {\\n            matrix[i][0] = 1;// as there is only one way to reach every index (i,0) by going down(1,0) and down(2,0) and down(3,0)...\\n        }\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 1; j < m; j++) {\\n                matrix[i][j] = matrix[i - 1][j] + matrix[i][j - 1]; //for every other element number of ways to reach there is sum of number of ways to reach its top and number of ways to reach to its left(since we can move only right and down)\\n            }\\n        }\\n        return matrix[n - 1][m - 1];  //finally return the number of ways to reach last element.\\n    }\\n}\\n//PLEASE UPVOTE IF IT WAS HELPFUL!! \\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n       public int uniquePaths(int m, int n) {//in this question m is considered as columns and n as rows(usually we take first element written as rows but it is reversed here )\\n        int[][] matrix = new int[n][m]; // create a matrix in which value of every element represents the total possible ways to reach there.\\n       \\n        for (int i = 0; i < m; i++) {\\n            matrix[0][i] = 1;//as there is only one way to reach every element having index (0,i).i.e->(0,1)->(0,2)->(0,3)->--so on till (0,m) and it is by moving right from (0,0)\\n\\n        }\\n        for (int i = 0; i < n; i++) {\\n            matrix[i][0] = 1;// as there is only one way to reach every index (i,0) by going down(1,0) and down(2,0) and down(3,0)...\\n        }\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 1; j < m; j++) {\\n                matrix[i][j] = matrix[i - 1][j] + matrix[i][j - 1]; //for every other element number of ways to reach there is sum of number of ways to reach its top and number of ways to reach to its left(since we can move only right and down)\\n            }\\n        }\\n        return matrix[n - 1][m - 1];  //finally return the number of ways to reach last element.\\n    }\\n}\\n//PLEASE UPVOTE IF IT WAS HELPFUL!! \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581956,
                "title": "c-simple-and-short-dp-solution-brief-explanation-0ms-faster-than-100",
                "content": "**Idea:**\\nTo each cell `grid[i][j]` we have to ways: either coming from the top - `grid[i-1][j]` or coming from the left - `grid[i][j-1]`.\\ndp[i][j] holds the number of paths to get to grid[i][j].\\nSo we just add the sum of the two ways - `dp[i-1][j] + dp[i][j-1]`.\\n\\nBase cases are 1, there is one way to get to the cells on first row and col.\\n\\n**Time Complexity:** O(mn)\\n**Space Complexity:** O(mn)\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(n, vector<int>(m, 1));\\n\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++)\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n        \\n        return dp[n-1][m-1];\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(n, vector<int>(m, 1));\\n\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++)\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n        \\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691177,
                "title": "4-approaches-learn-for-interview-beats-100",
                "content": "Recursive solution (The very first step you should come up with)\\n\\n```\\nclass Solution {\\n    int solve(int[][] grid, int x, int y){\\n        if(x>=grid.length || y >=grid[0].length) return 0;\\n        if(x == grid.length-1 && y == grid[0].length-1) return 1;\\n        return solve(grid,x+1,y) + solve(grid,x,y+1); \\n    }\\n    public int uniquePaths(int m, int n) {\\n        int grid[][] = new int[m][n];\\n        return solve(grid,0,0);\\n    }\\n}\\n```\\n\\nMethod 1 : Top Down DP ( Recursion + memoization)\\n```\\nclass Solution {\\n    int[][] memo;\\n    \\n    int solve(int[][] grid, int x, int y){\\n        if(x>=grid.length || y >=grid[0].length) return 0;\\n        if(memo[x][y] != -1) return memo[x][y];\\n        if(x == grid.length-1 && y == grid[0].length-1) return 1;\\n        return memo[x][y] = solve(grid,x+1,y) + solve(grid,x,y+1); \\n    }\\n    public int uniquePaths(int m, int n) {\\n        int grid[][] = new int[m][n];\\n        memo = new int[m][n];\\n        for(int[]rows:memo) Arrays.fill(rows,-1);\\n        return solve(grid,0,0);\\n    }\\n}\\n```\\n\\nMethod 2 : Bottom up DP ( Building solution from (Destination) RIGHT-MOST BOTTOM corner)\\n\\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int grid[][] = new int[m][n];\\n        int[][]dp = new int[m+1][n+1];\\n        for(int x=m;x>=0;x--){\\n            for(int y=n;y>=0;y--){\\n                if(x == m || y == n) dp[x][y] = 0;\\n                else if(x == m-1 && y == n-1) dp[x][y] = 1;\\n                else dp[x][y] =  dp[x+1][y] + dp[x][y+1]; \\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```\\n\\nMethod 3 : Bottom-up ( Building solution from (source) LEFT-MOST TOP corner)\\n\\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int grid[][] = new int[m][n];\\n        int[][]dp = new int[m][n];\\n  \\n        for(int x=0;x<m;x++){\\n            for(int y=0;y<n;y++){\\n                if(x == 0 || y == 0) dp[x][y] = 1;\\n                else dp[x][y] =  dp[x-1][y] + dp[x][y-1]; \\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int solve(int[][] grid, int x, int y){\\n        if(x>=grid.length || y >=grid[0].length) return 0;\\n        if(x == grid.length-1 && y == grid[0].length-1) return 1;\\n        return solve(grid,x+1,y) + solve(grid,x,y+1); \\n    }\\n    public int uniquePaths(int m, int n) {\\n        int grid[][] = new int[m][n];\\n        return solve(grid,0,0);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[][] memo;\\n    \\n    int solve(int[][] grid, int x, int y){\\n        if(x>=grid.length || y >=grid[0].length) return 0;\\n        if(memo[x][y] != -1) return memo[x][y];\\n        if(x == grid.length-1 && y == grid[0].length-1) return 1;\\n        return memo[x][y] = solve(grid,x+1,y) + solve(grid,x,y+1); \\n    }\\n    public int uniquePaths(int m, int n) {\\n        int grid[][] = new int[m][n];\\n        memo = new int[m][n];\\n        for(int[]rows:memo) Arrays.fill(rows,-1);\\n        return solve(grid,0,0);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int grid[][] = new int[m][n];\\n        int[][]dp = new int[m+1][n+1];\\n        for(int x=m;x>=0;x--){\\n            for(int y=n;y>=0;y--){\\n                if(x == m || y == n) dp[x][y] = 0;\\n                else if(x == m-1 && y == n-1) dp[x][y] = 1;\\n                else dp[x][y] =  dp[x+1][y] + dp[x][y+1]; \\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int grid[][] = new int[m][n];\\n        int[][]dp = new int[m][n];\\n  \\n        for(int x=0;x<m;x++){\\n            for(int y=0;y<n;y++){\\n                if(x == 0 || y == 0) dp[x][y] = 1;\\n                else dp[x][y] =  dp[x-1][y] + dp[x][y-1]; \\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362191,
                "title": "python3-1-line-combinatorics-w-explanation-t-m-88-79",
                "content": "Some points to consider:\\n\\n*  Because the robot may only move to the right or down, the count of paths to any cell in row 0 or column 0 is exactly 1. For all other cells, the count of paths is equal to the the count of the cell to the left plus the count of the cell above.\\n\\n![image](https://assets.leetcode.com/users/images/4a75d47a-c14c-4efb-9913-33ac40c1017f_1659319303.142981.png)\\n\\n*  In the figure above, m = 3 and n = 5, and the answer to the problem is 15. One could iterate the relation above by row and column as shown  and determine the answer.\\n\\n![image](https://assets.leetcode.com/users/images/2379d57d-21e3-47ad-8e2f-9cbed8c7ee2a_1659318546.287716.png)\\n\\n\\n* However, the arrangement of integers on the grid are familiar-- Pascal\\'s Triangle. For Pascal\\'s Triangle, rows and columns are 0-indexed. The answer is at the intersection of left-column 2 (which is 3-1) and right-column 4 (which is 5-1. The row is 4+2 = 6 (which is 5+3 -2). From combinatorics, integer in the 6th row in column 2 is 6!/(2!4!) = 15\\n\\n```\\nclass Solution: \\n        def uniquePaths(self, m: int, n: int) -> int:\\n            return factorial(m+n-2)//factorial(m-1)//factorial(n-1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Combinatorics"
                ],
                "code": "Some points to consider:\\n\\n*  Because the robot may only move to the right or down, the count of paths to any cell in row 0 or column 0 is exactly 1. For all other cells, the count of paths is equal to the the count of the cell to the left plus the count of the cell above.\\n\\n![image](https://assets.leetcode.com/users/images/4a75d47a-c14c-4efb-9913-33ac40c1017f_1659319303.142981.png)\\n\\n*  In the figure above, m = 3 and n = 5, and the answer to the problem is 15. One could iterate the relation above by row and column as shown  and determine the answer.\\n\\n![image](https://assets.leetcode.com/users/images/2379d57d-21e3-47ad-8e2f-9cbed8c7ee2a_1659318546.287716.png)\\n\\n\\n* However, the arrangement of integers on the grid are familiar-- Pascal\\'s Triangle. For Pascal\\'s Triangle, rows and columns are 0-indexed. The answer is at the intersection of left-column 2 (which is 3-1) and right-column 4 (which is 5-1. The row is 4+2 = 6 (which is 5+3 -2). From combinatorics, integer in the 6th row in column 2 is 6!/(2!4!) = 15\\n\\n```\\nclass Solution: \\n        def uniquePaths(self, m: int, n: int) -> int:\\n            return factorial(m+n-2)//factorial(m-1)//factorial(n-1)",
                "codeTag": "Java"
            },
            {
                "id": 1912575,
                "title": "100-fastest-swift-solution-time-o-n-m-space-o-min-n-m",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n * m), where n is the number of rows, and m is the number of columns.\\n    //   - space: O(min(n, m)), where n is the number of rows, and m is the number of columns.\\n    \\n    func uniquePaths(_ m: Int, _ n: Int) -> Int {\\n        var matrix: [[Int]] = Array(repeating: Array(repeating: 0, count: m), count: n)\\n        \\n        for i in 0..<n {\\n            for j in 0..<m {\\n                if i == 0 || j == 0 {\\n                    matrix[i][j] = 1\\n                } else {\\n                    matrix[i][j] = matrix[i - 1][j] + matrix[i][j - 1]\\n                }\\n            }\\n        }\\n        \\n        return matrix[n - 1][m - 1]\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n * m), where n is the number of rows, and m is the number of columns.\\n    //   - space: O(min(n, m)), where n is the number of rows, and m is the number of columns.\\n    \\n    func uniquePaths(_ m: Int, _ n: Int) -> Int {\\n        var matrix: [[Int]] = Array(repeating: Array(repeating: 0, count: m), count: n)\\n        \\n        for i in 0..<n {\\n            for j in 0..<m {\\n                if i == 0 || j == 0 {\\n                    matrix[i][j] = 1\\n                } else {\\n                    matrix[i][j] = matrix[i - 1][j] + matrix[i][j - 1]\\n                }\\n            }\\n        }\\n        \\n        return matrix[n - 1][m - 1]\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241181,
                "title": "java-solutions",
                "content": "**Solution 1:**\\n\\n- The robot can only move either down or right. Hence any cell in the first row can only be reached from the cell left to it. Similarly, any cell in the first column can only be reached from the cell above it.\\n- For any other cell in the grid, we can reach it either from the cell to left of it or the cell above it.\\n---\\n- Thus, we have the following state equations: suppose the number of paths to arrive at a point `(i, j)` is denoted as `path[i][j]`, then we can find that \\n `path[i][j] = path[i - 1][j] + path[i][j - 1]`.\\n- The boundary conditions of the above equation occur at the leftmost-column and the topmost-row . These conditions can be handled by initialization. So we initialize first-row and first column with `1`. i,e. `path[0][j] = 1` and `path[i][0] = 1` for all valid `i`, `j`.\\n---\\n- Initially, we fill the first row and first column with `1` and then we fill the complete table.\\nFor example- when `n = 4` and `m = 6`, table will look like this:\\n\\n| 1 | 1 | 1 | 1 | 1 | 1 |\\n| -- | -- | -- | -- | -- | -- |\\n| **1** | 2 | 3 | 4 | 5 | 6 | \\n| **1** | 3 | 6 | 10 | 15 | 21 |\\n| **1** | 4 | 10 | 20 | 35 | **56** |\\n\\nTime complexity: `O(n * m)`\\nSpace Complexity: `O(n * m)`\\n\\n```\\nclass Solution\\n{\\n    public int uniquePaths(int m, int n)\\n    {\\n        int[][] path = new int[n][m];\\n        \\n        for(int i = 0; i < n; i++) path[i][0] = 1;\\n        for(int j = 0; j < m; j++) path[0][j] = 1;\\n\\n        for(int i = 1; i < n; i++)\\n        {\\n            for(int j = 1; j < m; j++)\\n            {\\n                path[i][j] = path[i - 1][j] + path[i][j - 1];\\t\\t// current cell = top cell + left cell\\n            }\\n        }\\n        return path[n - 1][m - 1];\\n    }\\n}\\n```\\n**OR**\\n```\\nclass Solution\\n{\\n    public int uniquePaths(int m, int n)\\n    {\\n        int[][] path = new int[n][m];\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(i == 0 || j == 0)\\n                    path[i][j] = 1;\\n                else\\n                    path[i][j] = path[i - 1][j] + path[i][j - 1];\\t// current cell = top cell + left cell\\n            }\\n        }\\n        return path[n - 1][m - 1];\\n    }\\n}\\n```\\n\\n**Solution 2:**\\n\\n- The `Solution1` runs in `O(n * m)` time and costs `O(n * m)` space. Each time when we update `path[i][j]`, we only need `path[i - 1][j]` (at the same column) and `path[i][j - 1]` (at the left column). \\n- So as per this observation, it is enough to maintain two columns the current column and the left column, instead of maintaining the full `n * m` matrix. This will reduce the space complexity to `O(m)`, where `m` is the column size.\\n\\nTime complexity: `O(n * m)`\\nSpace Complexity: `O(m)`\\n\\n```\\nclass Solution\\n{\\n    public int uniquePaths(int m, int n)\\n\\t{\\n        int[] pre = new int[m];\\n        int[] cur = new int[m];\\n\\n        for(int i = 0; i < m; i++)\\n\\t\\t{\\n            pre[i] = 1;\\n            cur[i] = 1;            \\n        }\\n\\n        for(int i = 1; i < n; i++)\\n\\t\\t{\\n            for(int j = 1; j < m; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcur[j] = cur[j - 1] + pre[j];\\t\\t\\t\\t\\t\\t// current cell = top cell + left cell\\n\\t\\t\\t}\\n            pre = cur;\\n        }\\n        return cur[m - 1];\\n    }\\n}\\n```\\n\\n**Solution 3:**\\n\\n- Further inspecting the `Solution2`, we can see that that keeping two columns or arrays is used to recover pre[i] from the left column, which is just cur[i] before its update. So there is even no need to use two arrays and one is just enough. This will further reduce the required space from `2 * m` to `m`\\n\\nTime complexity: `O(n * m)`\\nSpace Complexity: `O(m)`\\n\\n```\\nclass Solution\\n{\\n    public int uniquePaths(int m, int n)\\n\\t{\\n        int[] cur = new int[m];\\n        Arrays.fill(cur, 1);\\n\\n        for(int i = 1; i < n; i++)\\n\\t\\t{\\n            for(int j = 1; j < m; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcur[j] += cur[j - 1];\\t\\t\\t\\t\\t\\t// current cell = top cell + left cell  \\tcur[j] = cur[j] + cur[j - 1]\\n\\t\\t\\t}\\n        }\\n        return cur[m - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public int uniquePaths(int m, int n)\\n    {\\n        int[][] path = new int[n][m];\\n        \\n        for(int i = 0; i < n; i++) path[i][0] = 1;\\n        for(int j = 0; j < m; j++) path[0][j] = 1;\\n\\n        for(int i = 1; i < n; i++)\\n        {\\n            for(int j = 1; j < m; j++)\\n            {\\n                path[i][j] = path[i - 1][j] + path[i][j - 1];\\t\\t// current cell = top cell + left cell\\n            }\\n        }\\n        return path[n - 1][m - 1];\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int uniquePaths(int m, int n)\\n    {\\n        int[][] path = new int[n][m];\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(i == 0 || j == 0)\\n                    path[i][j] = 1;\\n                else\\n                    path[i][j] = path[i - 1][j] + path[i][j - 1];\\t// current cell = top cell + left cell\\n            }\\n        }\\n        return path[n - 1][m - 1];\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int uniquePaths(int m, int n)\\n\\t{\\n        int[] pre = new int[m];\\n        int[] cur = new int[m];\\n\\n        for(int i = 0; i < m; i++)\\n\\t\\t{\\n            pre[i] = 1;\\n            cur[i] = 1;            \\n        }\\n\\n        for(int i = 1; i < n; i++)\\n\\t\\t{\\n            for(int j = 1; j < m; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcur[j] = cur[j - 1] + pre[j];\\t\\t\\t\\t\\t\\t// current cell = top cell + left cell\\n\\t\\t\\t}\\n            pre = cur;\\n        }\\n        return cur[m - 1];\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int uniquePaths(int m, int n)\\n\\t{\\n        int[] cur = new int[m];\\n        Arrays.fill(cur, 1);\\n\\n        for(int i = 1; i < n; i++)\\n\\t\\t{\\n            for(int j = 1; j < m; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcur[j] += cur[j - 1];\\t\\t\\t\\t\\t\\t// current cell = top cell + left cell  \\tcur[j] = cur[j] + cur[j - 1]\\n\\t\\t\\t}\\n        }\\n        return cur[m - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23240,
                "title": "dynamic-programming-in-o-m-n-solution-in-c",
                "content": "    class Solution {\\n    public:\\n        int uniquePaths(int m, int n) {\\n            int P[101][101];\\n            P[1][1]=1;\\n            for (int i=2; i<=n; i++)\\n            {\\n                P[1][i]=1;\\n            }\\n            for (int i=2; i<=m; i++)\\n            {\\n                P[i][1]=1;\\n            }\\n            for (int i=2; i<=m; i++)\\n            {\\n                for (int j=2; j<=n; j++)\\n                {\\n                    P[i][j]=P[i-1][j]+P[i][j-1];\\n                }\\n            }\\n            return P[m][n];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int uniquePaths(int m, int n) {\\n            int P[101][101];\\n            P[1][1]=1;\\n            for (int i=2; i<=n; i++)\\n            {\\n                P[1][i]=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1484498,
                "title": "3-solutions-c-brute-better-best-recursion-dp-combinatorics",
                "content": "**Recursion Based Solution:(Brute Solution)**\\nExplanation with code:\\n```\\nclass Solution {\\npublic:\\n    int solve(int x,int y,int m,int n)\\n    {\\n        if(x==m-1 and y==n-1)// we reached at target so return 1 (consider 0 based indexing)\\n        {\\n            return 1;\\n        }\\n        \\n        if(x>=m || y>=n)//we are not able to reach to the target so return 0;\\n        {\\n            return 0;\\n        }\\n        \\n        return solve(x+1,y,m,n)+solve(x,y+1,m,n);//at last we return total of x+1 step and y+1 step\\n    }\\n    int uniquePaths(int m, int n) {\\n        int x=0,y=0;\\n        return solve(x,y,m,n);\\n    }\\n};\\n```\\nGives **TLE** :(\\n\\nLet\\'s try to solve by DP :)\\n\\n\\n\\n**DP based solution(Better solution):**\\nSince the robot can only move right and down, when it arrives at a point, it either arrives from left or above. If we use dp[i][j] for the number of unique paths to arrive at the point (i, j), then the state equation is dp[i][j] = dp[i][j - 1] + dp[i - 1][j]. Moreover, we have the base cases dp[0][j] = dp[i][0] = 1 for all valid i and j respectively.\\n\\nExplanation with code:\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> matrix(m,vector<int>(n,1));//0 based \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0||j==0)//Base case\\n                {\\n                    matrix[i][j]=1;\\n                }\\n                else matrix[i][j] = matrix[i-1][j] + matrix[i][j-1];//get the ans from (i-1,j) and (i,j-1) state\\n            }\\n        }\\n        \\n        return matrix[m-1][n-1];//return the ans\\n    }\\n};\\n```\\n\\n**Best Solution:**\\nFor mxn grid, robot has to move exactly m-1 steps down and n-1 steps right and these can be done in any order.\\nTherefore total ways are : m-1 + n-1 = m+n-2\\nIf you placed or choose the m-1 steps from total ways then n-1 automatically found // either can be calculated..\\n\\nso the final ans is m+n-2 choose m-1.i.e.**( (m+n-2 )C (m-1))**\\n\\nCode with explanation:\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int total_ways = m+n-2;//skip current row and col\\n        int r = m-1;//if i placed m-1 then definitely n-1 automatically arranged\\n        \\n        double ans=1;//take double because we have to divide something in the following iterations\\n        for(int i=1;i<=r;i++)\\n        {\\n            ans = ans *(total_ways-r+i)/i; // it will compute total ways choose m-1 \\n        }\\n        \\n        return (int)ans;\\n        \\n    }\\n};\\n```\\n\\n**Enjoy Coding :)** and Like the post if u liked....\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int x,int y,int m,int n)\\n    {\\n        if(x==m-1 and y==n-1)// we reached at target so return 1 (consider 0 based indexing)\\n        {\\n            return 1;\\n        }\\n        \\n        if(x>=m || y>=n)//we are not able to reach to the target so return 0;\\n        {\\n            return 0;\\n        }\\n        \\n        return solve(x+1,y,m,n)+solve(x,y+1,m,n);//at last we return total of x+1 step and y+1 step\\n    }\\n    int uniquePaths(int m, int n) {\\n        int x=0,y=0;\\n        return solve(x,y,m,n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> matrix(m,vector<int>(n,1));//0 based \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0||j==0)//Base case\\n                {\\n                    matrix[i][j]=1;\\n                }\\n                else matrix[i][j] = matrix[i-1][j] + matrix[i][j-1];//get the ans from (i-1,j) and (i,j-1) state\\n            }\\n        }\\n        \\n        return matrix[m-1][n-1];//return the ans\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int total_ways = m+n-2;//skip current row and col\\n        int r = m-1;//if i placed m-1 then definitely n-1 automatically arranged\\n        \\n        double ans=1;//take double because we have to divide something in the following iterations\\n        for(int i=1;i<=r;i++)\\n        {\\n            ans = ans *(total_ways-r+i)/i; // it will compute total ways choose m-1 \\n        }\\n        \\n        return (int)ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934807,
                "title": "recursion-memo-dp-two-js-solutions",
                "content": "```\\n/*\\n[Recursion & Memo]\\nThe number of possible paths from grid[row][col] to the bottom-right \\n= the number of possible paths from grid[row][col+1] + the number of possible paths from grid[row+1][col]\\n\\n1. We will use DFS to traverse every possible path starting at (0,0). The function dfs() will be called\\nrecursively until the bottom-right (where row = height-1, col = width-1) is reached. \\n- Once the bottom-right is reached, 1 is returned because it means there is a path.\\n- If invalid row or col index is given, 0 will be returned. \\n- If given row and col have already been visited, the result will be returned from this memoization table.\\n- If given row and col are valid, not bottom-right, unvisited position, we will call dfs one to the right and one to the bottom, add these results, record it to our memoization table and return it.\\n\\nWe will use a m x n 2-d array for a memoization table.\\n*/\\nvar uniquePaths = function(m, n) {\\n    let memo = new Array(m).fill(0).map(() => new Array(n));\\n    return dfs(0, 0, m, n, memo);\\n    // T.C: O(M * N), M = # of rows, N = # of columns\\n    // S.C: O(M * N)\\n};\\n\\n// Returns the number of possible paths from given (row,col) to the bottom-right\\nfunction dfs(row, col, height, width, memo) {\\n    // invalid index\\n    if (row < 0 || row >= height || col < 0 || col >= width) {\\n        return 0;\\n    }\\n    // the right-bottom is reached\\n    if (row === height-1 && col === width-1) {\\n        return 1;\\n    }\\n    if (memo[row][col] !== undefined) {\\n        return memo[row][col];\\n    }\\n    let res = dfs(row, col+1, height, width, memo) + dfs(row+1, col, height, width, memo);\\n    memo[row][col] = res;\\n    return res;\\n}\\n```\\n\\n```\\n/*\\n[DP]\\nThe number of paths from (row,col) to the bottom-right \\n= the number of paths from (row, col+1) + the number of paths from (row+1, col).\\n\\nHence, we will create a m x n dp table; dp[row][col] is the number of paths from given row and column to the bottom-right.\\nWe know that every entry in row=m-1 and every entry in col=n-1 will have a value of 1 because we can only move right or down. So, all these will be our base cases.\\n\\nSo we will traverse the grid backwards and fill our dp table.\\n\\nThe answer will be dp[0][0] since we want to figure out the number of paths from (0,0) to the bottom-right.\\n*/\\nvar uniquePaths = function(m, n) {\\n    let dp = new Array(m).fill(0).map(() => new Array(n));\\n    for (let row = m-1; row >= 0; row--) {\\n        for (let col = n-1; col >= 0; col--) {\\n            if (row === m-1 || col === n-1) {\\n                dp[row][col] = 1;\\n            } else {\\n                dp[row][col] = dp[row][col+1] + dp[row+1][col];\\n            }\\n        }\\n    }\\n    return dp[0][0];\\n    // T.C: O(M*N)\\n    // S.C: O(M*N)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\n[Recursion & Memo]\\nThe number of possible paths from grid[row][col] to the bottom-right \\n= the number of possible paths from grid[row][col+1] + the number of possible paths from grid[row+1][col]\\n\\n1. We will use DFS to traverse every possible path starting at (0,0). The function dfs() will be called\\nrecursively until the bottom-right (where row = height-1, col = width-1) is reached. \\n- Once the bottom-right is reached, 1 is returned because it means there is a path.\\n- If invalid row or col index is given, 0 will be returned. \\n- If given row and col have already been visited, the result will be returned from this memoization table.\\n- If given row and col are valid, not bottom-right, unvisited position, we will call dfs one to the right and one to the bottom, add these results, record it to our memoization table and return it.\\n\\nWe will use a m x n 2-d array for a memoization table.\\n*/\\nvar uniquePaths = function(m, n) {\\n    let memo = new Array(m).fill(0).map(() => new Array(n));\\n    return dfs(0, 0, m, n, memo);\\n    // T.C: O(M * N), M = # of rows, N = # of columns\\n    // S.C: O(M * N)\\n};\\n\\n// Returns the number of possible paths from given (row,col) to the bottom-right\\nfunction dfs(row, col, height, width, memo) {\\n    // invalid index\\n    if (row < 0 || row >= height || col < 0 || col >= width) {\\n        return 0;\\n    }\\n    // the right-bottom is reached\\n    if (row === height-1 && col === width-1) {\\n        return 1;\\n    }\\n    if (memo[row][col] !== undefined) {\\n        return memo[row][col];\\n    }\\n    let res = dfs(row, col+1, height, width, memo) + dfs(row+1, col, height, width, memo);\\n    memo[row][col] = res;\\n    return res;\\n}\\n```\n```\\n/*\\n[DP]\\nThe number of paths from (row,col) to the bottom-right \\n= the number of paths from (row, col+1) + the number of paths from (row+1, col).\\n\\nHence, we will create a m x n dp table; dp[row][col] is the number of paths from given row and column to the bottom-right.\\nWe know that every entry in row=m-1 and every entry in col=n-1 will have a value of 1 because we can only move right or down. So, all these will be our base cases.\\n\\nSo we will traverse the grid backwards and fill our dp table.\\n\\nThe answer will be dp[0][0] since we want to figure out the number of paths from (0,0) to the bottom-right.\\n*/\\nvar uniquePaths = function(m, n) {\\n    let dp = new Array(m).fill(0).map(() => new Array(n));\\n    for (let row = m-1; row >= 0; row--) {\\n        for (let col = n-1; col >= 0; col--) {\\n            if (row === m-1 || col === n-1) {\\n                dp[row][col] = 1;\\n            } else {\\n                dp[row][col] = dp[row][col+1] + dp[row+1][col];\\n            }\\n        }\\n    }\\n    return dp[0][0];\\n    // T.C: O(M*N)\\n    // S.C: O(M*N)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3994633,
                "title": "c-dp-combinatorics",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**DP Approach :**\\n* We can reach [i, j] from [i-1, j] or [i, j-1]\\n* count of unique paths to [i,j] = count of unique paths to [i-1,j] + count of unique paths to [i,j-1]  \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int uniquePaths(int m, int n) {\\n        int dp[m][n];\\n        for(int i=0, j=0;j<n;j++) dp[i][j]=1;\\n        for(int j=0, i=0;i<m;i++) dp[i][j]=1;\\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++) dp[i][j]=dp[i-1][j] + dp[i][j-1];\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\\n\\n**Combinatorics Approach:**\\n\\n* Considering [i,j+1] movement H sticks and [i+1,j] as V sticks, so H = m-1 and V = n-1\\n* Count of unique paths = number of ways we can make arrangments with these sticks\\n\\n![image](https://assets.leetcode.com/users/images/352ef86f-d8a2-4ca5-8f3c-02e13feb3a86_1693706929.8266468.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int ncr(int n, int r){\\n        long long int ans=1;\\n        for(int i=0;i<r;i++){\\n            ans *= (n-i);\\n            ans /= (i+1);\\n        }\\n        return (int) ans;\\n    }\\n    \\n    int uniquePaths(int m, int n) {     \\n        return ncr(m+n-2,min(n-1,m-1));\\n    }\\n};\\n```\\n\\n**Do upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int uniquePaths(int m, int n) {\\n        int dp[m][n];\\n        for(int i=0, j=0;j<n;j++) dp[i][j]=1;\\n        for(int j=0, i=0;i<m;i++) dp[i][j]=1;\\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++) dp[i][j]=dp[i-1][j] + dp[i][j-1];\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int ncr(int n, int r){\\n        long long int ans=1;\\n        for(int i=0;i<r;i++){\\n            ans *= (n-i);\\n            ans /= (i+1);\\n        }\\n        return (int) ans;\\n    }\\n    \\n    int uniquePaths(int m, int n) {     \\n        return ncr(m+n-2,min(n-1,m-1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640546,
                "title": "easiest-c-solution-using-memoization-0-ms-beats-100-of-the-solutions",
                "content": "1. Let\\'s first consider the possible base cases. \\nWhat happens if we move **out** of the grid ? There is no possible solution in such case.\\n2. If we reach the final cell, then we have a possible answer.\\n3. We can either move **down** or **right** in this problem, hence consider either of them.\\n4. Since, this is a **counting** problem and we need to count the **total ways**, we add the respective down and right results to the answer.\\n5. Memoize using the 2D DP array of size n x m filled with -1.\\n\\n```\\nint solve(int i, int j, int &n, int &m, vector<vector<int>>&dp)\\n    {\\n        if (i < 0 or j < 0 or i >= n or j >= m)\\n            return 0;\\n        \\n        if (i == n - 1 and j == m - 1)\\n            return 1;\\n        \\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int down = solve(i + 1, j, n, m, dp);\\n        int right = solve(i, j + 1, n, m, dp);\\n        \\n        return dp[i][j] = down + right;\\n    }\\n    \\n    int uniquePaths(int n, int m) {\\n        vector<vector<int>>dp(n, vector<int>(m, -1));\\n        return solve(0, 0, n, m, dp);\\n    }\\n```\\n\\n![image](https://assets.leetcode.com/users/images/9fc26cf5-daa2-4f8c-8e8b-25b88d621814_1686815441.0917704.png)",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nint solve(int i, int j, int &n, int &m, vector<vector<int>>&dp)\\n    {\\n        if (i < 0 or j < 0 or i >= n or j >= m)\\n            return 0;\\n        \\n        if (i == n - 1 and j == m - 1)\\n            return 1;\\n        \\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int down = solve(i + 1, j, n, m, dp);\\n        int right = solve(i, j + 1, n, m, dp);\\n        \\n        return dp[i][j] = down + right;\\n    }\\n    \\n    int uniquePaths(int n, int m) {\\n        vector<vector<int>>dp(n, vector<int>(m, -1));\\n        return solve(0, 0, n, m, dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2274218,
                "title": "c-0-ms-with-images-explanation",
                "content": "Hello there!\\n\\nHere I present the **combinatorial solution** because personally I think it is easier to think mathematically than to solve using DP (Dynamic Programming).\\n\\nFor those who are not familiar with the notion of combination, check this out: https://artofproblemsolving.com/wiki/index.php?title=Combination\\n\\n\\nIt is a really famous combinatorial problem for math competitions. The notion of N choose R is written in this form: $${n\\\\choose r}$$ \\n\\nOther people use these notations, which I do not use frequently:\\n$C(n,r)$\\n$_n C_r$\\n$C_n^r$\\nSo what does this mean, $N$ choose $R$? It basically means that you are putting $N$ indistinguishable (identical) balls into $R$ distinguishable (different) boxes. The formula for this would be:\\n$${n\\\\choose r} = \\\\frac{n!}{r!(n-r)!}$$\\nBecause you can put the balls in any way, you have $n!$ possibilities. But because there are repeats (the boxes are different), we should divide by $r!(n-r)!$ and you get this formula.\\n************************************************************************************************************************************\\nLet\\'s get in our problem. \\n\\nHere is the diagram provided:\\n![image](https://assets.leetcode.com/users/images/7b2d2c8b-ec9e-411b-aae7-524ec0dd07a7_1657661820.7252288.png)\\nFirst, I let you choose any path you want. How many steps must the bot go to reach the star?\\n![image](https://assets.leetcode.com/users/images/bef35c8f-85f0-482d-9dfa-0dcae9924c60_1657661383.641953.png)\\nClearly, you see that it requires $8$ steps to arrive there. But the bot walks two steps down and six steps right. It could have chosen to walk right first, then walk down to reach the star. So all the possible ways to walk to the end would be all the choices of where to place his downward steps in the grid! The bot could have chosen to walk like this:\\n![image](https://assets.leetcode.com/users/images/ae3636dd-fc2e-4481-b1c1-5fda55cea885_1657662070.0830517.png)\\nOr like this:\\n![image](https://assets.leetcode.com/users/images/05d62218-8a0f-482d-8d58-9d0677754a54_1657662094.6793065.png)\\nYou can see that he decides when to go down. When you get all the possibilities of where to go down, it is the final answer.\\n\\nYou should see that all the possibilities is simply the number of ways to choose 2 down steps from 8 walkings. You could also have thought of the number of ways to choose 6 right steps from 8 walkings. They yield to the same answer. You know why? It is because of the formula:\\n${8 \\\\choose 2}=\\\\frac{8!}{2!(8-2)!}=\\\\frac{8!}{2!6!}$\\n$${8 \\\\choose 6}=\\\\frac{8!}{6!(8-6)!}=\\\\frac{8!}{2!6!}$$\\n$${8 \\\\choose 2}={8\\\\choose 6}$$\\nSo the 1-1 correspondance would be that the number of ways to walk the grid would be the number of ways to choose $R$ down/right steps from $N$ steps.\\n******************************************************************************\\nBut wait, how do we translate this into code language? How do we define the number of steps and the number of down steps?\\n\\nLet\\'s work on our example. We have $m = 3$ and $n = 7$. We said earlier that we have 8 steps to walk. We get that by calculating $(m - 1) + (n - 1) = m + n - 2 = 3 + 7 - 2 = 8$.\\n\\nNext, how do we get the number of down/right steps? We either have $m - 1 = 2$ or $n - 1 = 6$. \\n\\nFinally, how do we implement our combinatorial formula? For those using Python, it is easier because $factorial$ which does all the work. (By the way, $n$ $factorial$ means $n!$)\\n\\nFor $C++$ (which is what I use), we need to create $for$ loops to compute it. Recall the formula:\\n$${n\\\\choose r} = \\\\frac{n!}{r!(n-r)!}$$\\nThis technically equals:\\n$${n\\\\choose r} = \\\\frac{n!}{r!(n-r)!}=\\\\frac{1\\\\times2\\\\times3\\\\times...\\\\times n}{(1\\\\times2\\\\times...\\\\times r)(1\\\\times2\\\\times...\\\\times n - r)}=\\\\frac{(n-r+1)(n-r+2)...n}{1\\\\times2\\\\times...\\\\times r}$$\\nSo we only need to loop-multiply from $m$ (or $n$) to $m + n - 2$ and then loop-divide from $1$ to ($m$ (or $n$) - 1).\\nDo not forget that we need the smallest divider and the biggest multiplier. You can choose between $smallest$ divider and $biggest$ multiplier OR $biggest$ divider and $smallest$ multiplier. They yield the same result.\\n\\nFor those who do not understand what I meant, look at the example: if $m = 3$ and $n = 7$, we would have either $7 \\\\times 8 / 1 \\\\times 2$ or $3 \\\\times 4 \\\\times 5 \\\\times 6 \\\\times 7 \\\\times 8 / 1 \\\\times 2 \\\\times 3 \\\\times 4 \\\\times 5 \\\\times 6$. In the second expression, the $3$, $4$, $5$ and $6$\\'s all cancel to yield the first expression. So it overcomplicates everything for nothing. I prefer using the smallest divider and the biggest multiplier for this problem.\\n\\nNow it\\'s time for what everyone wants to see: the solution code. It gave me $0\\\\text{ ms}$ runtime (yey!). Please note that I used ```double``` for the answer because the answers can be REALLY large. Even ```long long``` does not satisfy the problem.\\n``` C++ []\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        double ans = 1;\\n        // Implementing {m + n - 2 choose m (or n) - 1}\\n        for (int i = max(m, n); i <= m + n - 2; i++) ans *= i;\\n        for (int j = 1; j <= min(m, n) - 1; j++) ans /= j;\\n        return ans;\\n    }\\n};\\n```\\n**PLEASE UPVOTE IF YOU FIND IT HELPFUL!!!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```double```\n```long long```\n``` C++ []\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        double ans = 1;\\n        // Implementing {m + n - 2 choose m (or n) - 1}\\n        for (int i = max(m, n); i <= m + n - 2; i++) ans *= i;\\n        for (int j = 1; j <= min(m, n) - 1; j++) ans /= j;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22965,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The **ART** of dynamic programming:](https://leetcode.com/discuss/general-discussion/712010/the-art-of-dynamic-programming-an-intuitive-approach-from-apprentice-to-master/)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\n---\\n\\n**Top-Down:**\\n\\nThe number of ways to each cell `i`,`j` is the number of ways to reach the cell below (ie. `i + 1`,`j`) plus the number of ways to reach the cell to the right (ie. `i`,`j + 1`).  Thus the recurrence relation is:\\n\\n* `go(i, j)` = `go(i + 1, j) + go(i, j + 1)`\\n\\nThe base case occurs when we reach the bottom-right cell `M - 1`, `N - 1`, ie. we return `1` to count each unique each path.\\n\\n**Bottom-Up:**\\n\\nThe number of ways to each cell `i`,`j` is the sum of the number of ways to reach the cell above (ie. `i - 1`,`j`) and the number of ways to reach cell to-the-left (ie. `i`,`j - 1`).  Thus the recurrence relation is:\\n\\n* `dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`\\n\\nThe base case occurs where we start at `0`,`0`, ie. there exists `1` way to reach the beginning: `dp[0][0] = 1`.\\n\\n---\\n\\n**Kotlin Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun uniquePaths(M: Int, N: Int): Int {\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == M || j == N)\\n                return 0;\\n            if (i == M - 1 && j == N - 1)\\n                return 1\\n            var D = go(i + 1, j)\\n            var R = go(i, j + 1)\\n            return D + R\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun uniquePaths(M: Int, N: Int): Int {\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == M || j == N)\\n                return 0;\\n            if (i == M - 1 && j == N - 1)\\n                return 1\\n            var k = \"$i,$j\"\\n            if (!m.contains(k)) {\\n                var D = go(i + 1, j)\\n                var R = go(i, j + 1)\\n                m[k] = D + R\\n            }\\n            return m[k]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun uniquePaths(M: Int, N: Int): Int {\\n        var dp = Array(M) { IntArray(N) { 0 } }\\n        for (i in 0 until M) dp[i][0] = 1\\n        for (j in 0 until N) dp[0][j] = 1\\n        for (i in 1 until M) {\\n            for (j in 1 until N) {\\n                var U = dp[i - 1][j]\\n                var L = dp[i][j - 1]\\n                dp[i][j] = U + L\\n            }\\n        }\\n        return dp[M - 1][N - 1]\\n    }\\n}\\n```\\n\\n4. Bottom-up memory optimiziation 2N (previous and current rows of DP matrix)\\n```\\nclass Solution {\\n    fun uniquePaths(M: Int, N: Int): Int {\\n        var pre = IntArray(N) { 1 }\\n        for (i in 1 until M) {\\n            var cur = pre.copyOf()\\n            for (j in 1 until N)\\n                cur[j] += cur[j - 1]\\n            pre = cur.also{ cur = pre }\\n        }\\n        return pre[N - 1]\\n    }\\n}\\n```\\n\\n5. Bottom-up memory optimiziation N (current row of DP matrix)\\n```\\nclass Solution {\\n    fun uniquePaths(M: Int, N: Int): Int {\\n        var cur = IntArray(N) { 1 }\\n        for (i in 1 until M)\\n            for (j in 1 until N)\\n                cur[j] += cur[j - 1]\\n        return cur[N - 1]\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet uniquePaths = (M, N) => {\\n    let go = (i = 0, j = 0) => {\\n        if (i == M || j == N)\\n            return 0;\\n        if (i == M - 1 && j == N - 1)\\n            return 1;\\n        let D = go(i + 1, j),\\n            R = go(i, j + 1);\\n        return D + R;\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet uniquePaths = (M, N, m = new Map()) => {\\n    let go = (i = 0, j = 0) => {\\n        if (i == M || j == N)\\n            return 0;\\n        if (i == M - 1 && j == N - 1)\\n            return 1;\\n        let k = `${i},${j}`;\\n        if (!m.has(k)) {\\n            let D = go(i + 1, j),\\n                R = go(i, j + 1);\\n            m.set(k, D + R);\\n        }\\n        return m.get(k);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet uniquePaths = (M, N) => {\\n    let dp = [...Array(M)].map(_ => Array(N).fill(0));\\n    for (let i = 0; i < M; dp[i++][0] = 1);\\n    for (let j = 0; j < N; dp[0][j++] = 1);\\n    for (let i = 1; i < M; ++i) {\\n        for (let j = 1; j < N; ++j) {\\n            let U = dp[i - 1][j],\\n                L = dp[i][j - 1];\\n            dp[i][j] = U + L;\\n        }\\n    }\\n    return dp[M - 1][N - 1];\\n};\\n```\\n\\n4. Bottom-up memory optimiziation 2N (previous and current rows of DP matrix)\\n```\\nlet uniquePaths = (M, N) => {\\n    let pre = Array(N).fill(1);\\n    for (let i = 1; i < M; ++i) {\\n        let cur = [...pre];\\n        for (let j = 1; j < N; ++j)\\n            cur[j] += cur[j - 1];\\n        [pre, cur] = [cur, pre];\\n    }\\n    return pre[N - 1];\\n};\\n```\\n\\n5. Bottom-up memory optimiziation N (current row of DP matrix)\\n```\\nlet uniquePaths = (M, N) => {\\n    let cur = Array(N).fill(1);\\n    for (let i = 1; i < M; ++i)\\n        for (let j = 1; j < N; ++j)\\n            cur[j] += cur[j - 1];\\n    return cur[N - 1];\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def uniquePaths(self, M: int, N: int) -> int:\\n        def go(i = 0, j = 0):\\n            if i == M or j == N:\\n                return 0\\n            if i == M - 1 and j == N - 1:\\n                return 1\\n            D = go(i + 1, j)\\n            R = go(i, j + 1)\\n            return D + R\\n        return go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def uniquePaths(self, M: int, N: int) -> int:\\n        @cache\\n        def go(i = 0, j = 0):\\n            if i == M or j == N:\\n                return 0\\n            if i == M - 1 and j == N - 1:\\n                return 1\\n            D = go(i + 1, j)\\n            R = go(i, j + 1)\\n            return D + R\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def uniquePaths(self, M: int, N: int) -> int:\\n        dp = [[0] * N for _ in range(M)]\\n        for i in range(M): dp[i][0] = 1\\n        for j in range(N): dp[0][j] = 1\\n        for i in range(1, M):\\n            for j in range(1, N):\\n                U = dp[i - 1][j]\\n                L = dp[i][j - 1]\\n                dp[i][j] = U + L\\n        return dp[M - 1][N - 1]\\n```\\n\\n4. Bottom-up memory optimiziation 2N (previous and current rows of DP matrix)\\n```\\nclass Solution:\\n    def uniquePaths(self, M: int, N: int) -> int:\\n        pre = [1] * N\\n        for i in range(1, M):\\n            cur = pre.copy()\\n            for j in range(1, N):\\n                cur[j] += cur[j - 1]\\n            pre, cur = cur, pre\\n        return pre[N - 1]\\n```\\n\\n5. Bottom-up memory optimiziation N (current row of DP matrix)\\n```\\nclass Solution:\\n    def uniquePaths(self, M: int, N: int) -> int:\\n        cur = [1] * N\\n        for i in range(1, M):\\n            for j in range(1, N):\\n                cur[j] += cur[j - 1]\\n        return cur[N - 1]\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    int uniquePaths(int M, int N) {\\n        fun go = [&](auto i, auto j) {\\n            if (i == M || j == N)\\n                return 0;\\n            if (i == M - 1 && j == N - 1)\\n                return 1;\\n            auto D = go(i + 1, j),\\n                 R = go(i, j + 1);\\n            return D + R;\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int uniquePaths(int M, int N) {\\n        auto key = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j, Map m = {}) {\\n            if (i == M || j == N)\\n                return 0;\\n            if (i == M - 1 && j == N - 1)\\n                return 1;\\n            auto k = key(i, j);\\n            if (m.find(k) == m.end()) {\\n                auto D = go(i + 1, j),\\n                     R = go(i, j + 1);\\n                m[k] = D + R;\\n            }\\n            return m[k];\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int uniquePaths(int M, int N) {\\n        VVI dp(M, VI(N));\\n        for (auto i{ 0 }; i < M; dp[i++][0] = 1);\\n        for (auto j{ 0 }; j < N; dp[0][j++] = 1);\\n        for (auto i{ 1 }; i < M; ++i) {\\n            for (auto j{ 1 }; j < N; ++j) {\\n                auto U = dp[i - 1][j],\\n                     L = dp[i][j - 1];\\n                dp[i][j] = U + L;\\n            }\\n        }\\n        return dp[M - 1][N - 1];\\n    }\\n};\\n```\\n\\n4. Bottom-up memory optimiziation 2N (previous and current rows of DP matrix)\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int uniquePaths(int M, int N) {\\n        VI pre(N, 1);\\n        for (auto i{ 1 }; i < M; ++i) {\\n            auto cur{ pre };\\n            for (auto j{ 1 }; j < N; ++j)\\n                cur[j] += cur[j - 1];\\n            swap(pre, cur);\\n        }\\n        return pre[N - 1];\\n    }\\n};\\n```\\n\\n5. Bottom-up memory optimiziation N (current row of DP matrix)\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int uniquePaths(int M, int N) {\\n        VI cur(N, 1);\\n        for (auto i{ 1 }; i < M; ++i)\\n            for (auto j{ 1 }; j < N; ++j)\\n                cur[j] += cur[j - 1];\\n        return cur[N - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun uniquePaths(M: Int, N: Int): Int {\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == M || j == N)\\n                return 0;\\n            if (i == M - 1 && j == N - 1)\\n                return 1\\n            var D = go(i + 1, j)\\n            var R = go(i, j + 1)\\n            return D + R\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun uniquePaths(M: Int, N: Int): Int {\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == M || j == N)\\n                return 0;\\n            if (i == M - 1 && j == N - 1)\\n                return 1\\n            var k = \"$i,$j\"\\n            if (!m.contains(k)) {\\n                var D = go(i + 1, j)\\n                var R = go(i, j + 1)\\n                m[k] = D + R\\n            }\\n            return m[k]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun uniquePaths(M: Int, N: Int): Int {\\n        var dp = Array(M) { IntArray(N) { 0 } }\\n        for (i in 0 until M) dp[i][0] = 1\\n        for (j in 0 until N) dp[0][j] = 1\\n        for (i in 1 until M) {\\n            for (j in 1 until N) {\\n                var U = dp[i - 1][j]\\n                var L = dp[i][j - 1]\\n                dp[i][j] = U + L\\n            }\\n        }\\n        return dp[M - 1][N - 1]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun uniquePaths(M: Int, N: Int): Int {\\n        var pre = IntArray(N) { 1 }\\n        for (i in 1 until M) {\\n            var cur = pre.copyOf()\\n            for (j in 1 until N)\\n                cur[j] += cur[j - 1]\\n            pre = cur.also{ cur = pre }\\n        }\\n        return pre[N - 1]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun uniquePaths(M: Int, N: Int): Int {\\n        var cur = IntArray(N) { 1 }\\n        for (i in 1 until M)\\n            for (j in 1 until N)\\n                cur[j] += cur[j - 1]\\n        return cur[N - 1]\\n    }\\n}\\n```\n```\\nlet uniquePaths = (M, N) => {\\n    let go = (i = 0, j = 0) => {\\n        if (i == M || j == N)\\n            return 0;\\n        if (i == M - 1 && j == N - 1)\\n            return 1;\\n        let D = go(i + 1, j),\\n            R = go(i, j + 1);\\n        return D + R;\\n    };\\n    return go();\\n};\\n```\n```\\nlet uniquePaths = (M, N, m = new Map()) => {\\n    let go = (i = 0, j = 0) => {\\n        if (i == M || j == N)\\n            return 0;\\n        if (i == M - 1 && j == N - 1)\\n            return 1;\\n        let k = `${i},${j}`;\\n        if (!m.has(k)) {\\n            let D = go(i + 1, j),\\n                R = go(i, j + 1);\\n            m.set(k, D + R);\\n        }\\n        return m.get(k);\\n    };\\n    return go();\\n};\\n```\n```\\nlet uniquePaths = (M, N) => {\\n    let dp = [...Array(M)].map(_ => Array(N).fill(0));\\n    for (let i = 0; i < M; dp[i++][0] = 1);\\n    for (let j = 0; j < N; dp[0][j++] = 1);\\n    for (let i = 1; i < M; ++i) {\\n        for (let j = 1; j < N; ++j) {\\n            let U = dp[i - 1][j],\\n                L = dp[i][j - 1];\\n            dp[i][j] = U + L;\\n        }\\n    }\\n    return dp[M - 1][N - 1];\\n};\\n```\n```\\nlet uniquePaths = (M, N) => {\\n    let pre = Array(N).fill(1);\\n    for (let i = 1; i < M; ++i) {\\n        let cur = [...pre];\\n        for (let j = 1; j < N; ++j)\\n            cur[j] += cur[j - 1];\\n        [pre, cur] = [cur, pre];\\n    }\\n    return pre[N - 1];\\n};\\n```\n```\\nlet uniquePaths = (M, N) => {\\n    let cur = Array(N).fill(1);\\n    for (let i = 1; i < M; ++i)\\n        for (let j = 1; j < N; ++j)\\n            cur[j] += cur[j - 1];\\n    return cur[N - 1];\\n};\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, M: int, N: int) -> int:\\n        def go(i = 0, j = 0):\\n            if i == M or j == N:\\n                return 0\\n            if i == M - 1 and j == N - 1:\\n                return 1\\n            D = go(i + 1, j)\\n            R = go(i, j + 1)\\n            return D + R\\n        return go()\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, M: int, N: int) -> int:\\n        @cache\\n        def go(i = 0, j = 0):\\n            if i == M or j == N:\\n                return 0\\n            if i == M - 1 and j == N - 1:\\n                return 1\\n            D = go(i + 1, j)\\n            R = go(i, j + 1)\\n            return D + R\\n        return go()\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, M: int, N: int) -> int:\\n        dp = [[0] * N for _ in range(M)]\\n        for i in range(M): dp[i][0] = 1\\n        for j in range(N): dp[0][j] = 1\\n        for i in range(1, M):\\n            for j in range(1, N):\\n                U = dp[i - 1][j]\\n                L = dp[i][j - 1]\\n                dp[i][j] = U + L\\n        return dp[M - 1][N - 1]\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, M: int, N: int) -> int:\\n        pre = [1] * N\\n        for i in range(1, M):\\n            cur = pre.copy()\\n            for j in range(1, N):\\n                cur[j] += cur[j - 1]\\n            pre, cur = cur, pre\\n        return pre[N - 1]\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, M: int, N: int) -> int:\\n        cur = [1] * N\\n        for i in range(1, M):\\n            for j in range(1, N):\\n                cur[j] += cur[j - 1]\\n        return cur[N - 1]\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    int uniquePaths(int M, int N) {\\n        fun go = [&](auto i, auto j) {\\n            if (i == M || j == N)\\n                return 0;\\n            if (i == M - 1 && j == N - 1)\\n                return 1;\\n            auto D = go(i + 1, j),\\n                 R = go(i, j + 1);\\n            return D + R;\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int uniquePaths(int M, int N) {\\n        auto key = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j, Map m = {}) {\\n            if (i == M || j == N)\\n                return 0;\\n            if (i == M - 1 && j == N - 1)\\n                return 1;\\n            auto k = key(i, j);\\n            if (m.find(k) == m.end()) {\\n                auto D = go(i + 1, j),\\n                     R = go(i, j + 1);\\n                m[k] = D + R;\\n            }\\n            return m[k];\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int uniquePaths(int M, int N) {\\n        VVI dp(M, VI(N));\\n        for (auto i{ 0 }; i < M; dp[i++][0] = 1);\\n        for (auto j{ 0 }; j < N; dp[0][j++] = 1);\\n        for (auto i{ 1 }; i < M; ++i) {\\n            for (auto j{ 1 }; j < N; ++j) {\\n                auto U = dp[i - 1][j],\\n                     L = dp[i][j - 1];\\n                dp[i][j] = U + L;\\n            }\\n        }\\n        return dp[M - 1][N - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int uniquePaths(int M, int N) {\\n        VI pre(N, 1);\\n        for (auto i{ 1 }; i < M; ++i) {\\n            auto cur{ pre };\\n            for (auto j{ 1 }; j < N; ++j)\\n                cur[j] += cur[j - 1];\\n            swap(pre, cur);\\n        }\\n        return pre[N - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int uniquePaths(int M, int N) {\\n        VI cur(N, 1);\\n        for (auto i{ 1 }; i < M; ++i)\\n            for (auto j{ 1 }; j < N; ++j)\\n                cur[j] += cur[j - 1];\\n        return cur[N - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23129,
                "title": "0ms-java-10-line-code",
                "content": "    public int uniquePaths(int m, int n) {\\n        int smaller = m>n ? n-1 : m-1;\\n        int totalsteps = m+n-2;\\n        long result = 1;\\n        for (int counter = 1; counter<=smaller; counter++){\\n            result *= totalsteps--;\\n            result /= counter;\\n        }\\n        return (int)result;\\n    }\\nBasically it is math: select m (or n) from [(m-1)+(n-1)]",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int uniquePaths(int m, int n) {\\n        int smaller = m>n ? n-1 : m-1;\\n        int totalsteps = m+n-2;\\n        long result = 1;\\n        for (int counter = 1; counter<=smaller; counter++){\\n            result *= totalsteps--;\\n            result /= counter;\\n        }\\n        return (int)result;\\n    }\\nBasically it is math: select m (or n) from [(m-1)+(n-1)]",
                "codeTag": "Unknown"
            },
            {
                "id": 3995933,
                "title": "c-100-tc-basic-math-optimised",
                "content": "### \\uD83D\\uDD25 Donn Forget to Upvote if you liked the Approach \\uD83D\\uDD25\\n\\n\\n# Intuition\\nIntution to the problem is we just have to reach at the bottom corner for that we only have to moves possible either to our right or to a step down from the current location. So basically our total no. of ways is going to be total no. of arrangements of \\'R\\' movement and \\'D\\' movement.\\n\\n# Approach\\nLet\\'s Say `m=5` and `n=3` so to reach at bottom right we\\'ll have to move right 4 times and down 2 times. therefore we have `R,R,R,R,D,D` movements with us.\\nNow we have to find the total no. of ways of reaching at bottom right corner for that we have 4 R\\'s and 2 D\\'s. We just have to apply the arrangements formula which will be `6!/(4!*2!)`.\\n\\n# Complexity\\n- Time complexity:\\n    O(N-max(R,N-R)).\\n    N= Rows+ Cols- 2.\\n    R= Rows-1.\\n    N-R= Cols-1.\\n\\n- Space complexity:\\n    O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int cal(int n, int r)\\n    {\\n        long long p=1, k=1;\\n        if (n-r<r)\\n            r=n-r;\\n        if(r!=0) {\\n            while(r) {\\n                p*=n;\\n                k*=r;\\n                long long m=__gcd(p,k);\\n                p/=m;\\n                k/=m;\\n                n--;\\n                r--;\\n            }\\n        }\\n        else\\n            p=1;\\n        return p;\\n    }\\n    int uniquePaths(int m, int n) {\\n        return cal(m+n-2,n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int cal(int n, int r)\\n    {\\n        long long p=1, k=1;\\n        if (n-r<r)\\n            r=n-r;\\n        if(r!=0) {\\n            while(r) {\\n                p*=n;\\n                k*=r;\\n                long long m=__gcd(p,k);\\n                p/=m;\\n                k/=m;\\n                n--;\\n                r--;\\n            }\\n        }\\n        else\\n            p=1;\\n        return p;\\n    }\\n    int uniquePaths(int m, int n) {\\n        return cal(m+n-2,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572377,
                "title": "unique-paths-4-approaches-recursion-memoization-tabulation-space-optimization",
                "content": "# **Recursive Approach**\\n\\nTime Complexity : 2^(n*m)\\nSpace Complexity: O((m-1)+(n-1))\\nThis will give a **TLE**\\n\\n```\\nint find(int i,int j,vector<vector<int>>& dp){\\n        if( i == 0 &&  j == 0 ) return 1;\\n        if ( i<0 || j<0) return 0;\\n        int up = find( i-1 , j );\\n        int left = find( i , j-1 );\\n        return up+left;\\n    }\\n    int uniquePaths(int m, int n) {\\n        return find ( m-1 ,n-1 );\\n    }\\n```\\n\\t\\n# \\tMemoization Approach\\nTime Complexity : O(n*m)\\nSpace Complexity: O((m-1)+(n-1))+O(n*m)\\n\\n```\\nint find(int i,int j,vector<vector<int>>& dp){\\n        if(i==0 && j==0)\\n            return 1;\\n        if(i<0 || j<0)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int up = find(i-1,j,dp);\\n        int left = find(i,j-1,dp);\\n        return dp[i][j] = up+left;\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m,vector<int> (n,-1));\\n        return find(m-1,n-1,dp);\\n    }\\n```\\n\\t\\n# \\tTabulation Method\\n\\nTime Complexity : O(n*m)\\nSpace Complexity: O(n*m)\\n\\n```\\nint uniquePaths(int m, int n) {\\n\\t// Write your code here.\\n    int dp [m] [n];   \\n\\tfor (int i=0; i<m; i++){\\n        for (int j=0 ;j<n ;j++){\\n            if ( i==0 || j==0 ) dp[i][j]=1;\\n            else{                    \\n                int l=0;\\n                if(i>0) l=dp [i-1] [j];\\n                int u=0;\\n                if(j>0) u=dp [i] [j-1];                       \\n                dp [i] [j] =l+u;\\n                }\\n            }\\n        }\\n        return dp [ m-1 ] [ n-1 ] ;\\n}\\n```\\n\\n# Space Optimization\\n\\n```\\nint uniquePaths(int m, int n) {\\n\\t// Write your code here.\\n    vector<int> prev(n,0);\\n    for(int i=0;i<m;i++){\\n        vector<int>curr(n,0);\\n        for(int j=0;j<n;j++){\\n            if(i==0||j==0) curr[j]=1;\\n            else{                    \\n                int l=0;\\n                if(i>0) l=prev[j];\\n                int u=0;\\n                if(j>0) u=curr[j-1];                       \\n                curr[j]=l+u;\\n                }\\n            }\\n        prev=curr;\\n        }\\n        return prev[n-1];\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint find(int i,int j,vector<vector<int>>& dp){\\n        if( i == 0 &&  j == 0 ) return 1;\\n        if ( i<0 || j<0) return 0;\\n        int up = find( i-1 , j );\\n        int left = find( i , j-1 );\\n        return up+left;\\n    }\\n    int uniquePaths(int m, int n) {\\n        return find ( m-1 ,n-1 );\\n    }\\n```\n```\\nint find(int i,int j,vector<vector<int>>& dp){\\n        if(i==0 && j==0)\\n            return 1;\\n        if(i<0 || j<0)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int up = find(i-1,j,dp);\\n        int left = find(i,j-1,dp);\\n        return dp[i][j] = up+left;\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m,vector<int> (n,-1));\\n        return find(m-1,n-1,dp);\\n    }\\n```\n```\\nint uniquePaths(int m, int n) {\\n\\t// Write your code here.\\n    int dp [m] [n];   \\n\\tfor (int i=0; i<m; i++){\\n        for (int j=0 ;j<n ;j++){\\n            if ( i==0 || j==0 ) dp[i][j]=1;\\n            else{                    \\n                int l=0;\\n                if(i>0) l=dp [i-1] [j];\\n                int u=0;\\n                if(j>0) u=dp [i] [j-1];                       \\n                dp [i] [j] =l+u;\\n                }\\n            }\\n        }\\n        return dp [ m-1 ] [ n-1 ] ;\\n}\\n```\n```\\nint uniquePaths(int m, int n) {\\n\\t// Write your code here.\\n    vector<int> prev(n,0);\\n    for(int i=0;i<m;i++){\\n        vector<int>curr(n,0);\\n        for(int j=0;j<n;j++){\\n            if(i==0||j==0) curr[j]=1;\\n            else{                    \\n                int l=0;\\n                if(i>0) l=prev[j];\\n                int u=0;\\n                if(j>0) u=curr[j-1];                       \\n                curr[j]=l+u;\\n                }\\n            }\\n        prev=curr;\\n        }\\n        return prev[n-1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2127822,
                "title": "5-approaches-o-m-time-o-1-space-c",
                "content": "Implementation\\n\\n**1st Approach\\nRecursive Approach\\nWill give TLE\\nTime Complexity : O(2!)\\nSpace Complexity : O(2!)**\\n\\n```\\nclass Solution {\\nprivate:\\n    int solve(int m, int n, int left, int up){\\n        if(left == -1 || up == -1) return 0;\\n        if(left == 0 && up == 0) return 1;\\n        \\n        int leftSide = solve(m, n, left-1, up);\\n        int upSide = solve(m, n, left, up-1);\\n        \\n        return leftSide + upSide;\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        return solve(m, n, m-1, n-1);\\n    }\\n};\\n```\\n\\n\\n**2nd Approach\\nMemoization Approach\\nime Complexity : O(M * N)\\nSpace Complexity : O((M * N) + (M * N)) => O(M * N), bcz of recursion stack trace**\\n\\n```\\nclass Solution {\\nprivate:\\n    int solve(int m, int n, int left, int up, vector<vector<int>> &memo){\\n        if(left == -1 || up == -1) return 0;\\n        if(left == 0 && up == 0) return 1;\\n        \\n        if(memo[left][up] != -1) return memo[left][up];\\n        \\n        int leftSide = solve(m, n, left-1, up, memo);\\n        int upSide = solve(m, n, left, up-1, memo);\\n        \\n        return memo[left][up] = leftSide + upSide;\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> memo(m, vector<int> (n, -1));\\n        return solve(m, n, m-1, n-1, memo);\\n    }\\n};\\n```\\n\\n\\n\\n**3rd Approach\\nDP Approach\\nTime Complexity : O(M * N)\\nSpace Complexity : O(M * N)**\\n\\n```\\nclass Solution {    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int> (n));\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i == 0 && j == 0){\\n                    dp[i][j] = 1;\\n                }\\n                else{                    \\n                    int leftSide = 0;\\n                    if(i-1 >= 0){\\n                        leftSide = dp[i-1][j];\\n                    }\\n                    \\n                    int upSide = 0;\\n                    if(j-1 >= 0){\\n                        upSide = dp[i][j-1];\\n                    }                        \\n                    \\n                    dp[i][j] = leftSide + upSide;\\n                }\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n};\\n```\\n\\n\\n**4th Approach\\nSpace Optimization in DP Approach\\nTime Complexity : O(M*N)\\nSpace Complexity : O(N)**\\n\\n```\\nclass Solution {    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> prev(n, 0);\\n        \\n        for(int i = 0; i < m; i++){\\n            \\n            vector<int> cur(n, 0);\\n            \\n            for(int j = 0; j < n; j++){\\n                if(i == 0 && j == 0){\\n                    cur[j] = 1;\\n                }\\n                else{                    \\n                    int leftSide = 0;\\n                    if(i-1 >= 0){\\n                        leftSide = prev[j];\\n                    }\\n                    \\n                    int upSide = 0;\\n                    if(j-1 >= 0){\\n                        upSide = cur[j-1];\\n                    }                        \\n                    \\n                    cur[j] = leftSide + upSide;\\n                }\\n            }\\n            prev = cur;\\n        }\\n        \\n        return prev[n-1];\\n    }\\n};\\n```\\n\\n\\n\\n**5th Approach\\nLinear Solution\\nTime Complexity : O(M)\\nSpace Complexity : O(1)**\\n```\\nclass Solution {    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        int formulaValue = m + n - 2;\\n        int run = m-1;\\n        \\n        // NcR formula\\n        \\n        double sum = 1;\\n        for(int i = 1; i <= run; i++){\\n            sum = sum * (formulaValue - run + i) / i;\\n        }\\n        \\n        return (int)sum;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Math",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int m, int n, int left, int up){\\n        if(left == -1 || up == -1) return 0;\\n        if(left == 0 && up == 0) return 1;\\n        \\n        int leftSide = solve(m, n, left-1, up);\\n        int upSide = solve(m, n, left, up-1);\\n        \\n        return leftSide + upSide;\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        return solve(m, n, m-1, n-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int m, int n, int left, int up, vector<vector<int>> &memo){\\n        if(left == -1 || up == -1) return 0;\\n        if(left == 0 && up == 0) return 1;\\n        \\n        if(memo[left][up] != -1) return memo[left][up];\\n        \\n        int leftSide = solve(m, n, left-1, up, memo);\\n        int upSide = solve(m, n, left, up-1, memo);\\n        \\n        return memo[left][up] = leftSide + upSide;\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> memo(m, vector<int> (n, -1));\\n        return solve(m, n, m-1, n-1, memo);\\n    }\\n};\\n```\n```\\nclass Solution {    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int> (n));\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i == 0 && j == 0){\\n                    dp[i][j] = 1;\\n                }\\n                else{                    \\n                    int leftSide = 0;\\n                    if(i-1 >= 0){\\n                        leftSide = dp[i-1][j];\\n                    }\\n                    \\n                    int upSide = 0;\\n                    if(j-1 >= 0){\\n                        upSide = dp[i][j-1];\\n                    }                        \\n                    \\n                    dp[i][j] = leftSide + upSide;\\n                }\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n};\\n```\n```\\nclass Solution {    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> prev(n, 0);\\n        \\n        for(int i = 0; i < m; i++){\\n            \\n            vector<int> cur(n, 0);\\n            \\n            for(int j = 0; j < n; j++){\\n                if(i == 0 && j == 0){\\n                    cur[j] = 1;\\n                }\\n                else{                    \\n                    int leftSide = 0;\\n                    if(i-1 >= 0){\\n                        leftSide = prev[j];\\n                    }\\n                    \\n                    int upSide = 0;\\n                    if(j-1 >= 0){\\n                        upSide = cur[j-1];\\n                    }                        \\n                    \\n                    cur[j] = leftSide + upSide;\\n                }\\n            }\\n            prev = cur;\\n        }\\n        \\n        return prev[n-1];\\n    }\\n};\\n```\n```\\nclass Solution {    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        int formulaValue = m + n - 2;\\n        int run = m-1;\\n        \\n        // NcR formula\\n        \\n        double sum = 1;\\n        for(int i = 1; i <= run; i++){\\n            sum = sum * (formulaValue - run + i) / i;\\n        }\\n        \\n        return (int)sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23204,
                "title": "44ms-python-dp-solution",
                "content": "    def uniquePaths(self, m, n):\\n            table = [[0 for x in range(n)] for x in range(m)]\\n            for i in range(m):\\n                table[i][0] = 1\\n            for i in range(n):\\n                table[0][i] = 1\\n            for i in range(1,m):\\n                for j in range(1,n):\\n                    table[i][j] = table[i-1][j] + table[i][j-1]\\n            return table[m-1][n-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    def uniquePaths(self, m, n):\\n            table = [[0 for x in range(n)] for x in range(m)]\\n            for i in range(m):\\n                table[i][0] = 1\\n            for i in range(n):\\n                table[0][i] = 1\\n            for i in range(1,m):\\n                for j in range(1,n):\\n                    table[i][j] = table[i-1][j] + table[i][j-1]\\n            return table[m-1][n-1]",
                "codeTag": "Python3"
            },
            {
                "id": 23239,
                "title": "one-line-in-python",
                "content": "It's true that this can be solved with dynamic programming. But you can see that every path has exactly m - 1 horizontal moves and n - 1 vertical moves. So, to get a particular path, you need to choose where to put your m - 1 horizontal moves (or your n - 1 vertical moves) amongst the m + n - 2 total moves. That gives (m+n-2 choose m-1) paths (or (m+n-2 choose n-1), which is the same).\\n\\n    class Solution:\\n        # @return an integer\\n        def uniquePaths(self, m, n):\\n            return math.factorial(m + n - 2) / (math.factorial(m - 1) * math.factorial(n - 1))",
                "solutionTags": [],
                "code": "It's true that this can be solved with dynamic programming. But you can see that every path has exactly m - 1 horizontal moves and n - 1 vertical moves. So, to get a particular path, you need to choose where to put your m - 1 horizontal moves (or your n - 1 vertical moves) amongst the m + n - 2 total moves. That gives (m+n-2 choose m-1) paths (or (m+n-2 choose n-1), which is the same).\\n\\n    class Solution:\\n        # @return an integer\\n        def uniquePaths(self, m, n):\\n            return math.factorial(m + n - 2) / (math.factorial(m - 1) * math.factorial(n - 1))",
                "codeTag": "Java"
            },
            {
                "id": 3346352,
                "title": "dp-o-mn-time-o-mn-space-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\nThe approach used in the code is dynamic programming. We create a m x n grid and calculate the number of unique paths from the top-left corner to each cell in the grid.\\n\\nWe initialize the first row and first column of the grid to 1, because there is only one way to reach any cell in the first row or first column - by moving only right or down respectively.\\n\\nFor all other cells, we can reach that cell from either the cell above it or the cell to its left. So the number of unique paths to that cell is the sum of the number of unique paths to the cell above it and the cell to its left.\\n\\nWe fill up the entire grid in this manner and return the number of unique paths to the bottom-right corner, which is the last cell in the grid.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Initialize a 2D grid of size m x n with all elements set to 0.\\n2. For each cell in the first row or first column, set its value to 1, since there is only one unique path to reach any cell in the first row or first column.\\n3. For each cell (i, j) in the grid where i > 0 and j > 0, set its value to the sum of the value of the cell above it (i-1, j) and the value of the cell to its left (i, j-1).\\n4. Once the entire grid has been filled, return the value of the bottom-right cell (m-1, n-1), which represents the total number of unique paths from the top-left corner to the bottom-right corner of the grid.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\n//using dynamic programming - O(mn) time and O(mn) space\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>grid(m, vector<int>(n));\\n        for (int row = 0; row < m; row++) {\\n            for (int col = 0; col < n; col++) {\\n                if (row == 0 || col == 0) {\\n                    grid[row][col] = 1;\\n                }\\n                else {\\n                    grid[row][col] = grid[row-1][col] + grid[row][col-1];\\n                }\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```\\n```C++ []\\n//using recursion - O(2^(m+n)) time and O(m+n) space\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        if (m == 1 || n == 1)\\n            return 1;\\n        return uniquePaths(m-1, n) + uniquePaths(m, n-1);\\n    }\\n};\\n```\\n```Java []\\n//using dynamic programming - O(mn) time and O(mn) space\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] grid = new int[m][n];\\n        for (int row = 0; row < m; row++) {\\n            for (int col = 0; col < n; col++) {\\n                if (row == 0 || col == 0) {\\n                    grid[row][col] = 1;\\n                }\\n                else {\\n                    grid[row][col] = grid[row-1][col] + grid[row][col-1];\\n                }\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        grid = [[0] * n for _ in range(m)]\\n        for row in range(m):\\n            for col in range(n):\\n                if row == 0 or col == 0:\\n                    grid[row][col] = 1\\n                else:\\n                    grid[row][col] = grid[row-1][col] + grid[row][col-1]\\n        return grid[m-1][n-1]\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity : **O(mn)** - DP\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : **O(mn)** - DP\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\n//using dynamic programming - O(mn) time and O(mn) space\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>grid(m, vector<int>(n));\\n        for (int row = 0; row < m; row++) {\\n            for (int col = 0; col < n; col++) {\\n                if (row == 0 || col == 0) {\\n                    grid[row][col] = 1;\\n                }\\n                else {\\n                    grid[row][col] = grid[row-1][col] + grid[row][col-1];\\n                }\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```\n```C++ []\\n//using recursion - O(2^(m+n)) time and O(m+n) space\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        if (m == 1 || n == 1)\\n            return 1;\\n        return uniquePaths(m-1, n) + uniquePaths(m, n-1);\\n    }\\n};\\n```\n```Java []\\n//using dynamic programming - O(mn) time and O(mn) space\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] grid = new int[m][n];\\n        for (int row = 0; row < m; row++) {\\n            for (int col = 0; col < n; col++) {\\n                if (row == 0 || col == 0) {\\n                    grid[row][col] = 1;\\n                }\\n                else {\\n                    grid[row][col] = grid[row-1][col] + grid[row][col-1];\\n                }\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        grid = [[0] * n for _ in range(m)]\\n        for row in range(m):\\n            for col in range(n):\\n                if row == 0 or col == 0:\\n                    grid[row][col] = 1\\n                else:\\n                    grid[row][col] = grid[row-1][col] + grid[row][col-1]\\n        return grid[m-1][n-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362716,
                "title": "convert-recursion-dp-easy-cpp-comments",
                "content": "UPVOTE IF HELPFUL\\n\\n**recursion**\\n```\\nclass Solution {\\npublic:\\n    int help(int i,int j,int m,int n)\\n    {\\n        if(i>=m || j>=n )return 0;   //if i>=m means outside so simple return 0;\\n        if(i==(m-1) && j==(n-1))return 1;    // if i==m-1 && j==n-1 means we reach the exact location or at the end so return 1;\\n       return  help(i+1,j,m,n)+help(i,j+1,m,n);   // move right abd down so i+1 mean down and j+1 move right.\\n    }\\n\\t\\n    int uniquePaths(int m, int n) {\\n        return help(0,0,m,n); //function call\\n        \\n    }\\n};\\n\\n```\\n\\n**DP**\\n\\n```\\nclass Solution {\\npublic:\\n    int help(int i,int j,int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(i>=m || j>=n )return 0;\\n        if(i==(m-1) && j==(n-1))return 1;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n       return dp[i][j]= help(i+1,j,m,n,dp)+help(i,j+1,m,n,dp);\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        return help(0,0,m,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int help(int i,int j,int m,int n)\\n    {\\n        if(i>=m || j>=n )return 0;   //if i>=m means outside so simple return 0;\\n        if(i==(m-1) && j==(n-1))return 1;    // if i==m-1 && j==n-1 means we reach the exact location or at the end so return 1;\\n       return  help(i+1,j,m,n)+help(i,j+1,m,n);   // move right abd down so i+1 mean down and j+1 move right.\\n    }\\n\\t\\n    int uniquePaths(int m, int n) {\\n        return help(0,0,m,n); //function call\\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int help(int i,int j,int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(i>=m || j>=n )return 0;\\n        if(i==(m-1) && j==(n-1))return 1;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n       return dp[i][j]= help(i+1,j,m,n,dp)+help(i,j+1,m,n,dp);\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        return help(0,0,m,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1855525,
                "title": "python-math-solution-3-lines",
                "content": "This problem can be used in a more Computer Science lens or a Mathematics lens. As a CS and Math double major I wanted to go with the math solution as it\\'s a lot easier to explain and code. This is a question about possile unique paths, which can be solved using DP or just basic combinatorics. In combinatorics, if you want to find the number of possible unique paths, in no particular order, without repitition, we use n choose k (nCk). Instead of hard coding the factorial and choose functions, we can simply use the math module which has the comb() method for nCk. By letting k be the smaller of the two dimensions, it improves the time.\\n\\nIt should be noted that in my explanation above, n isn\\'t the same n given in the problem, hence why I am using n to be a for nCk since the given *n* is one of the demensions of our board.\\n```\\nclass Solution:    \\n    def uniquePaths(self, m: int, n: int) -> int:\\n        a = (n - 1) + (m - 1)\\n        k = min(n, m) - 1\\n               \\n        return int(comb(a, k))\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:    \\n    def uniquePaths(self, m: int, n: int) -> int:\\n        a = (n - 1) + (m - 1)\\n        k = min(n, m) - 1\\n               \\n        return int(comb(a, k))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 411539,
                "title": "dp-solution-with-o-n-and-o-m-n-space-complexity",
                "content": "```python\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        # DP Solution\\n        if m == 1 or n == 1:\\n            return 1\\n        \\n        \\'\\'\\'\\n        # O(m*n) Space Complexity \\n        dp = [[1] * n for i in range(m)]\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]      \\n        return dp[m-1][n-1]\\n        \\'\\'\\'\\n        \\n        # O(n) Space Complexity \\n        dp = [1] * n\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[j] += dp[j-1]\\n        return dp[n-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        # DP Solution\\n        if m == 1 or n == 1:\\n            return 1\\n        \\n        \\'\\'\\'\\n        # O(m*n) Space Complexity \\n        dp = [[1] * n for i in range(m)]\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]      \\n        return dp[m-1][n-1]\\n        \\'\\'\\'\\n        \\n        # O(n) Space Complexity \\n        dp = [1] * n\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[j] += dp[j-1]\\n        return dp[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23147,
                "title": "c-dp-o-n-2-time-o-n-space",
                "content": "The state transition equation is: `memo[i][j] = memo[i][j-1] + memo[i-1][j]`\\n                \\nFor example: A 3x4 grid, you need to reach bottom-right corner from top-left corner. \\n               \\nWe use memo[3][4] to save number of paths.\\n\\n    x x x x\\n    x x x x \\n    x x x x \\n\\nNumber of paths of first row is 1 1 1 1, because you can only go down and left, you only have one way to go to destination in row 0. So I init the row 0 with 1. \\n\\nAnd the second row, we only have one way to go to grid[1][0], is start->down->down.so memo[1][0] = 1. \\n\\nAnd for memo[1][1], you can go from grid[1][0] and grid[0][1], so memo[1][1] = memo[1][0]+memo[0][1], and the others are the similar. \\n\\nso the number of paths of 3x4 grid is: \\n\\n    1 1 1  1 \\n    1 2 3  4 \\n    1 3 6 10, and return memo[2][3].\\n\\nAnd take a closer look at the question, you can just use O(n) space, because when you calculate m[i][j], you need to add up m[i][j-1] and m[i-1][j]. \\n\\nIn my solution, m[i][j-1] is m[i-1],has been calculated just before m[i]j, and m[i-1][j] is old m[i] saved in m[i]. \\n\\nYou add up old m[i] and new m[i-1], the answer saves in m[i]. \\n\\nMy English is not so good, I hope this can answer you question.   \\n\\n       int uniquePaths(int m, int n) {\\n            int *memo = new int[n];\\n            for(int i = 0; i < n; i++)\\n                memo[i] = 1;\\n            for(int i = 1 ; i < m; i++)\\n                for(int j = 1; j < n; j++)\\n                    memo[j] += memo[j-1];\\n            return memo[n-1];\\n        }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "The state transition equation is: `memo[i][j] = memo[i][j-1] + memo[i-1][j]`\\n                \\nFor example: A 3x4 grid, you need to reach bottom-right corner from top-left corner. \\n               \\nWe use memo[3][4] to save number of paths.\\n\\n    x x x x\\n    x x x x \\n    x x x x \\n\\nNumber of paths of first row is 1 1 1 1, because you can only go down and left, you only have one way to go to destination in row 0. So I init the row 0 with 1. \\n\\nAnd the second row, we only have one way to go to grid[1][0], is start->down->down.so memo[1][0] = 1. \\n\\nAnd for memo[1][1], you can go from grid[1][0] and grid[0][1], so memo[1][1] = memo[1][0]+memo[0][1], and the others are the similar. \\n\\nso the number of paths of 3x4 grid is: \\n\\n    1 1 1  1 \\n    1 2 3  4 \\n    1 3 6 10, and return memo[2][3].\\n\\nAnd take a closer look at the question, you can just use O(n) space, because when you calculate m[i][j], you need to add up m[i][j-1] and m[i-1][j]. \\n\\nIn my solution, m[i][j-1] is m[i-1],has been calculated just before m[i]j, and m[i-1][j] is old m[i] saved in m[i]. \\n\\nYou add up old m[i] and new m[i-1], the answer saves in m[i]. \\n\\nMy English is not so good, I hope this can answer you question.   \\n\\n       int uniquePaths(int m, int n) {\\n            int *memo = new int[n];\\n            for(int i = 0; i < n; i++)\\n                memo[i] = 1;\\n            for(int i = 1 ; i < m; i++)\\n                for(int j = 1; j < n; j++)\\n                    memo[j] += memo[j-1];\\n            return memo[n-1];\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 23214,
                "title": "trickily-solve-the-problem-with-math-code-is-simple",
                "content": "This problem can be trickily solved with math, the principle is simple:\\n      In total the robot should walk m + n - 2 steps, m - 1 steps to right and n - 1 steps to bottom, so all what we should do is to select which m - 1 steps to be right, therefore the problem is actually a combination problem, then we just need to calculate  (n + m - 2)! / ((m - 1)!  * (n - 1)!), here is the code:\\n\\n    class Solution {\\n    public:\\n    long long fab(int x, int y) {\\n        long long ret = 1;\\n        for (int i = x; i >= y && i > 0; --i) {\\n            ret *=i;\\n        }\\n        return ret;\\n    }\\n\\n    int uniquePaths(int m, int n) {\\n        if (0 == m || 0 == n) {\\n            return 0;\\n        }\\n\\n        int max = std::max(m, n) - 1;\\n        int min = std::min(m, n) - 1;\\n\\n        int ret = int(fab(max + min, max + 1) / fab(min, 1));\\n\\n        return ret;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    long long fab(int x, int y) {\\n        long long ret = 1;\\n        for (int i = x; i >= y && i > 0; --i) {\\n            ret *=i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3461624,
                "title": "c-and-c-the-fastest-solution-ever-explained",
                "content": "# Intuition:\\nThis formula is based on the fact that the robot must take exactly m-1 steps to the right and n-1 steps down to reach the bottom-right corner, for a total of m+n-2 steps. Therefore, the problem can be reduced to counting the number of ways to arrange m-1 right steps and n-1 down steps in a sequence of length m+n-2, which is equivalent to choosing (m-1) positions out of (m+n-2) to place the right steps, or equivalently (n-1) positions out of (m+n-2) to place the down steps.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![photo_2023-04-27_23-33-18.jpg](https://assets.leetcode.com/users/images/cfa6708a-a601-46f4-abdc-13985ae04393_1682620652.8100438.jpeg)\\n\\n```C++ []\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> dp(n, 1);\\n        for (int i = 1; i < m; ++i) {\\n            for (int j = 1; j < n; ++j) {\\n                dp[j] += dp[j - 1];\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```\\n\\n```C# []\\npublic class Solution {\\n    public int UniquePaths(int m, int n) {\\n        long result = 1;\\n        for (int i = 1; i < m; i++) {\\n            result *= n + i - 1;\\n            result /= i;\\n        }\\n        return (int)result;\\n    }\\n}\\n```\\n# JavaScript\\n```\\nvar uniquePaths = function(m, n) {\\n     let result = 1;\\n        for (let i = 1; i < m; i++) {\\n            result *= n + i - 1;\\n            result /= i;\\n        }\\n        return result;\\n};\\n```\\n\\n![photo_2023-04-27_23-33-24.jpg](https://assets.leetcode.com/users/images/0304e462-6b47-4b47-87a8-8e05711c61ec_1682620656.2920358.jpeg)\\n![Vote.png](https://assets.leetcode.com/users/images/3bf051dc-1393-4cb0-a60f-91341aa2cb2a_1682620641.9265544.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C#",
                    "Combinatorics"
                ],
                "code": "```C++ []\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> dp(n, 1);\\n        for (int i = 1; i < m; ++i) {\\n            for (int j = 1; j < n; ++j) {\\n                dp[j] += dp[j - 1];\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```\n```C# []\\npublic class Solution {\\n    public int UniquePaths(int m, int n) {\\n        long result = 1;\\n        for (int i = 1; i < m; i++) {\\n            result *= n + i - 1;\\n            result /= i;\\n        }\\n        return (int)result;\\n    }\\n}\\n```\n```\\nvar uniquePaths = function(m, n) {\\n     let result = 1;\\n        for (let i = 1; i < m; i++) {\\n            result *= n + i - 1;\\n            result /= i;\\n        }\\n        return result;\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2974621,
                "title": "c-easy-to-understand-recursion-memoization-tabulation-space-optimization",
                "content": "**1. Recursion** \\n\\n```\\n    int solveRec(int row,int col,int m,int n){\\n        if(row>=m || col>=n) return 0;\\n        if(row==m-1 && col==n-1){\\n            return 1;\\n        }\\n        else{\\n            int right=solveRec(row+1,col,m,n);\\n            int down=solveRec(row,col+1,m,n);\\n            return right+down;\\n        }\\n    }\\n\\tint uniquePaths(int m, int n) {\\n        return solveRec(0,0,m,n);\\n    }\\n```\\n\\n**2. Memoization**\\n\\n```\\nint solveMem(int row,int col,int m,int n,vector<vector<int>>&dp){\\n        if(row>=m || col>=n) return 0;\\n        if(dp[row][col]!=-1) return dp[row][col];\\n        if(row==m-1 && col==n-1){\\n            return 1;\\n        }\\n        else{\\n            int right=solveMem(row+1,col,m,n,dp);\\n            int down=solveMem(row,col+1,m,n,dp);\\n            int ans=right+down;\\n            return dp[row][col]=ans;\\n        }\\n    }\\n\\tint uniquePaths(int m, int n) {\\n         vector<vector<int>>dp(m,vector<int>(n,-1));\\n         return solveMem(0,0,m,n,dp);\\n    }\\n```\\n\\n**3. Tabulation** \\n\\n```\\n int solveTab(int m,int n){\\n        vector<vector<int>>dp(m,vector<int>(n,1));\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n\\tint uniquePaths(int m, int n) {\\n        return solveTab(m,n);\\n    }\\n\\n```\\n**4. Space Optimization**\\n\\n```\\nint solveSpaceOpt(int m,int n){\\n        vector<int> next(n,1);\\n        vector<int> curr(n,1);\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                curr[j]=next[j]+curr[j-1];\\n            }\\n            next=curr;\\n        }\\n        return next[n-1];\\n    }\\n\\tint uniquePaths(int m, int n) {\\n        return solveSpaceOpt(m,n);\\n    }\\n\\t\\n```\\n**Don\\'t forget to upvote this post if it has helped you!!!**",
                "solutionTags": [],
                "code": "```\\n    int solveRec(int row,int col,int m,int n){\\n        if(row>=m || col>=n) return 0;\\n        if(row==m-1 && col==n-1){\\n            return 1;\\n        }\\n        else{\\n            int right=solveRec(row+1,col,m,n);\\n            int down=solveRec(row,col+1,m,n);\\n            return right+down;\\n        }\\n    }\\n\\tint uniquePaths(int m, int n) {\\n        return solveRec(0,0,m,n);\\n    }\\n```\n```\\nint solveMem(int row,int col,int m,int n,vector<vector<int>>&dp){\\n        if(row>=m || col>=n) return 0;\\n        if(dp[row][col]!=-1) return dp[row][col];\\n        if(row==m-1 && col==n-1){\\n            return 1;\\n        }\\n        else{\\n            int right=solveMem(row+1,col,m,n,dp);\\n            int down=solveMem(row,col+1,m,n,dp);\\n            int ans=right+down;\\n            return dp[row][col]=ans;\\n        }\\n    }\\n\\tint uniquePaths(int m, int n) {\\n         vector<vector<int>>dp(m,vector<int>(n,-1));\\n         return solveMem(0,0,m,n,dp);\\n    }\\n```\n```\\n int solveTab(int m,int n){\\n        vector<vector<int>>dp(m,vector<int>(n,1));\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n\\tint uniquePaths(int m, int n) {\\n        return solveTab(m,n);\\n    }\\n\\n```\n```\\nint solveSpaceOpt(int m,int n){\\n        vector<int> next(n,1);\\n        vector<int> curr(n,1);\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                curr[j]=next[j]+curr[j-1];\\n            }\\n            next=curr;\\n        }\\n        return next[n-1];\\n    }\\n\\tint uniquePaths(int m, int n) {\\n        return solveSpaceOpt(m,n);\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 23154,
                "title": "6-lines-java-0ms-solution",
                "content": "    public int uniquePaths(int m, int n) {\\n        int[] dp = new int[m];\\n        dp[0] = 1;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 1; j < m; j++)\\n                dp[j] = dp[j-1] + dp[j];\\n        return dp[m-1];\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int uniquePaths(int m, int n) {\\n        int[] dp = new int[m];\\n        dp[0] = 1;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 1; j < m; j++)\\n                dp[j] = dp[j-1] + dp[j];\\n        return dp[m-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 23170,
                "title": "python-solution-using-dp-40ms",
                "content": "    class Solution(object):\\n        def uniquePaths(self, m, n):\\n            \"\"\"\\n            :type m: int\\n            :type n: int\\n            :rtype: int\\n            \"\"\"\\n            if m == 1 or n == 1:\\n                return 1\\n            \\n            #have a list of lists to represent the grid, initilized with 0's\\n            diffPaths = [[0]*n]*m\\n            \\n            #fill row 0 and column 0 with all 1's, only one way to get to all those squares\\n            for col in range(n):\\n                diffPaths[0][col] = 1\\n            \\n            for row in range(m):\\n                diffPaths[row][0] = 1\\n            \\n            #starting at grid[1][1], go through each gridspace and enter in the amount of unique paths to that square\\n            #unique paths for a certain square are found by adding the amount of unique paths from each of the squares to its top and its left\\n            for row in range(1, m):\\n                for col in range(1, n):\\n                    diffPaths[row][col] = diffPaths[row-1][col] + diffPaths[row][col-1]\\n            \\n            #bottom rightmost square will now contain the total amount of unique paths to there\\n            return diffPaths[m-1][n-1]",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def uniquePaths(self, m, n):\\n            \"\"\"\\n            :type m: int\\n            :type n: int\\n            :rtype: int\\n            \"\"\"\\n            if m == 1 or n == 1:\\n                return 1\\n            \\n            #have a list of lists to represent the grid, initilized with 0's\\n            diffPaths = [[0]*n]*m\\n            \\n            #fill row 0 and column 0 with all 1's, only one way to get to all those squares\\n            for col in range(n):\\n                diffPaths[0][col] = 1\\n            \\n            for row in range(m):\\n                diffPaths[row][0] = 1\\n            \\n            #starting at grid[1][1], go through each gridspace and enter in the amount of unique paths to that square\\n            #unique paths for a certain square are found by adding the amount of unique paths from each of the squares to its top and its left\\n            for row in range(1, m):\\n                for col in range(1, n):\\n                    diffPaths[row][col] = diffPaths[row-1][col] + diffPaths[row][col-1]\\n            \\n            #bottom rightmost square will now contain the total amount of unique paths to there\\n            return diffPaths[m-1][n-1]",
                "codeTag": "Java"
            },
            {
                "id": 23200,
                "title": "python-recursive-solution-with-cache",
                "content": "    class Solution:\\n        # @param {integer} m\\n        # @param {integer} n\\n        # @return {integer}\\n        def uniquePaths(self, m, n):\\n            cache = {}\\n            return self.findPath(m, n, cache)\\n    \\n        def findPath(self, m, n, cache):\\n            if (m, n) in cache:\\n                return cache[(m, n)]\\n            elif m == 1 or n == 1:\\n                return 1\\n    \\n            cache[(m, n)] = self.findPath(m - 1, n, cache) + self.findPath(m, n - 1, cache)\\n    \\n            return cache[(m, n)]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n        # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 23139,
                "title": "solve-unique-paths-with-linear-algorithm",
                "content": "1. The formula : C(n + m - 2, n - 1)  \\n    Overflow is the problem. Would you do it with this formula? Thanks.\\n\\n2. Using DP  Time Complexity is O(m * n)  Space Complexity is O(min(m, n))\\n\\n        class Solution {\\n        public:\\n            int uniquePaths(int m, int n) {\\n                // IMPORTANT: Please reset any member data you declared, as\\n                // the same Solution instance will be reused for each test case.\\n                if((m <= 0) || (n <= 0)) return 0;\\n                if((1 == m) || (1 == n)) return 1;\\n                int map[n + 1];\\n                memset(map, 0, sizeof(map));\\n                for(int i = 1; i <= n; i ++) map[i] = 1;\\n                for(int i = 2; i <= m; i ++) {\\n                    for(int j = 2; j <= n; j ++) {\\n                        map[j] += map[j - 1];\\n                    }\\n                }\\n                return map[n];\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int uniquePaths(int m, int n) {\\n                // IMPORTANT: Please reset any member data you declared, as\\n                // the same Solution instance will be reused for each test case.\\n                if((m <= 0) || (n <= 0)) return 0;\\n                if((1 == m) || (1 == n)) return 1;\\n                int map[n + 1];\\n                memset(map, 0, sizeof(map));\\n                for(int i = 1; i <= n; i ++) map[i] = 1;\\n                for(int i = 2; i <= m; i ++) {\\n                    for(int j = 2; j <= n; j ++) {\\n                        map[j] += map[j - 1];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3995244,
                "title": "c-dp-iterative",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        swap(n,m);\\n        vector<vector<int>>dp(n,vector<int>(m,1));\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/dacfbe5e-516f-4457-9ceb-54582996237d_1693716740.5145779.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        swap(n,m);\\n        vector<vector<int>>dp(n,vector<int>(m,1));\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2365888,
                "title": "python-simple-python-solution-using-two-approach",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n\\n# Approach 1 Using Recursion : -\\n\\n# Runtime: 49 ms, faster than 52.07% of Python3 online submissions for Unique Paths.\\n# Memory Usage: 14.1 MB, less than 14.98% of Python3 online submissions for Unique Paths.\\n\\tclass Solution:\\n\\t\\tdef uniquePaths(self, m: int, n: int) -> int:\\n\\n\\t\\t\\tresult = {}\\n\\n\\t\\t\\tdef All_Path(row, col):\\n\\n\\t\\t\\t\\tif row == 0 or col == 0:\\n\\t\\t\\t\\t\\treturn 1\\n\\n\\t\\t\\t\\telif (row , col ) not in result:\\n\\n\\t\\t\\t\\t\\tresult[(row , col)] = All_Path(row - 1, col) + All_Path(row, col - 1)\\n\\n\\t\\t\\t\\treturn result[(row , col )]\\n\\n\\t\\t\\treturn All_Path(m - 1, n - 1)\\n\\n# Approach 2 Using Dynamic Programming : -\\n# Runtime: 36 ms, faster than 71.76% of Python3 online submissions for Unique Paths.\\n# Memory Usage: 13.8 MB, less than 72.18% of Python3 online submissions for Unique Paths.\\n\\n\\tclass Solution:\\n\\t\\tdef uniquePaths(self, m: int, n: int) -> int:\\n\\n\\t\\t\\tdp = [[1 for _ in range(n)] for _ in range(m)]\\n\\n\\t\\t\\tfor i in range(1, m):\\n\\t\\t\\t\\tfor j in range(1, n):\\n\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j] + dp[i][j - 1]\\n\\n\\t\\t\\treturn dp[m-1][n-1]\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution:\\n\\t\\tdef uniquePaths(self, m: int, n: int) -> int:\\n\\n\\t\\t\\tresult = {}",
                "codeTag": "Java"
            },
            {
                "id": 1328799,
                "title": "c-brute-to-optimal-3-approaches",
                "content": "**1. RECURSION**\\n```\\nclass Solution {\\npublic:\\n    \\n    int paths(int m, int n, int i, int j){\\n        if((i>=m) || (j>=n)){ return 0; }\\n        if((i==m-1 && j==n-1)) return 1;\\n        else return (paths(m, n, i+1, j) + paths(m, n, i, j+1));\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n        return paths(m, n, 0, 0);\\n    }\\n};\\n```\\n\\n**2. DYNAMIC PROGRAMMING**\\n```\\nclass Solution {\\npublic:\\n    \\n    int paths(int m, int n, int i, int j, vector<vector<int>> &dp){\\n        if((i>=m) || (j>=n)){ return 0; }\\n        if((i==m-1 && j==n-1)) return 1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        else return  dp[i][j] = (paths(m, n, i+1, j, dp) + paths(m, n, i, j+1, dp));\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp (m+1, vector<int>(n+1, -1));\\n        return paths(m, n, 0, 0, dp);\\n    }\\n};\\n```\\n\\n**3. COMBINATION**\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int N = n+m-2;\\n        int r = m-1;\\n        double res = 1;\\n        \\n        for(int i=1; i<=r; i++){\\n            res = res * ( N - r + i) / i;\\n        }\\n        \\n        return (int)res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int paths(int m, int n, int i, int j){\\n        if((i>=m) || (j>=n)){ return 0; }\\n        if((i==m-1 && j==n-1)) return 1;\\n        else return (paths(m, n, i+1, j) + paths(m, n, i, j+1));\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n        return paths(m, n, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int paths(int m, int n, int i, int j, vector<vector<int>> &dp){\\n        if((i>=m) || (j>=n)){ return 0; }\\n        if((i==m-1 && j==n-1)) return 1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        else return  dp[i][j] = (paths(m, n, i+1, j, dp) + paths(m, n, i, j+1, dp));\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp (m+1, vector<int>(n+1, -1));\\n        return paths(m, n, 0, 0, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int N = n+m-2;\\n        int r = m-1;\\n        double res = 1;\\n        \\n        for(int i=1; i<=r; i++){\\n            res = res * ( N - r + i) / i;\\n        }\\n        \\n        return (int)res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301553,
                "title": "python-2d-intuitive-dp-solution-96-36",
                "content": "```\\ndef uniquePaths(self, m: int, n: int) -> int:\\n\\ttriangle = [[1] * n] # figure 1\\n\\tfor i in range(1, m):\\n\\t\\trow = list()\\n\\t\\trow.append(1) # figure 2\\n\\t\\tfor j in range(1, n):\\n\\t\\t\\trow.append(row[j-1] + triangle[i-1][j]) # figure 3\\n\\t\\ttriangle.append(row)\\n\\treturn triangle[m-1][n-1]```\\n```\\nOther posts talk about Pascal\\'s triangle and binomial coefficients, but they don\\'t exactly explain what makes the solution work.\\n\\nIn this solution, we construct a 2D array, ```triangle```, where ```triangle[row][col]]``` retrieves the number of unique steps to go to ```row, col``` with only 2 types of moves: right and down.\\n\\nWe build this 2D array by starting with our top row, an array filled with ones. Trivially, we can move to any spot in this array from the top-left corner with one move.\\n\\n![image](https://assets.leetcode.com/users/images/8c89c661-6a70-4a81-afe9-13817f5d00f8_1624831359.9246347.png)\\n\\nTo expand on the 2D array, we create new arrays to serve as additional rows below, with the first value as 0 because we can move down in one move (i.e. ```triangle[row][0] = 1```, or as shown in the code, ```row.append(1)```).\\n\\n![image](https://assets.leetcode.com/users/images/e1db0708-b47d-46b2-a691-f96566298ede_1624831580.4956439.png)\\n\\nThe final logical step that builds the remainder of the solution is for each tile ```row, col``` to be equal to the sum of the unique moves in the squares above and to the left. In the code, this represents itself as ```row.append(row[j-1] + triangle[i-1][j])```. This is dynamic programming because it builds on the previous solutions ```row[j-1] and triangle[i-1][j]```.\\n\\nThe image below shows a visualization of how the code finds the solution to the first example test case.\\n![image](https://assets.leetcode.com/users/images/ba04201d-8c41-4f5c-b338-194839ea16f4_1624832023.493262.png)\\n\\nIs this the most efficient solution? No, it uses ```O(m * n)``` space and time, but it\\'s very straight-forward and it serves as a good way to visualize this problem and other DP-type problems.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef uniquePaths(self, m: int, n: int) -> int:\\n\\ttriangle = [[1] * n] # figure 1\\n\\tfor i in range(1, m):\\n\\t\\trow = list()\\n\\t\\trow.append(1) # figure 2\\n\\t\\tfor j in range(1, n):\\n\\t\\t\\trow.append(row[j-1] + triangle[i-1][j]) # figure 3\\n\\t\\ttriangle.append(row)\\n\\treturn triangle[m-1][n-1]```\n```\\nOther posts talk about Pascal\\'s triangle and binomial coefficients, but they don\\'t exactly explain what makes the solution work.\\n\\nIn this solution, we construct a 2D array, ```\n```, where ```\n``` retrieves the number of unique steps to go to ```\n``` with only 2 types of moves: right and down.\\n\\nWe build this 2D array by starting with our top row, an array filled with ones. Trivially, we can move to any spot in this array from the top-left corner with one move.\\n\\n![image](https://assets.leetcode.com/users/images/8c89c661-6a70-4a81-afe9-13817f5d00f8_1624831359.9246347.png)\\n\\nTo expand on the 2D array, we create new arrays to serve as additional rows below, with the first value as 0 because we can move down in one move (i.e. ```\n```, or as shown in the code, ```\n```).\\n\\n![image](https://assets.leetcode.com/users/images/e1db0708-b47d-46b2-a691-f96566298ede_1624831580.4956439.png)\\n\\nThe final logical step that builds the remainder of the solution is for each tile ```\n``` to be equal to the sum of the unique moves in the squares above and to the left. In the code, this represents itself as ```\n```. This is dynamic programming because it builds on the previous solutions ```\n```.\\n\\nThe image below shows a visualization of how the code finds the solution to the first example test case.\\n![image](https://assets.leetcode.com/users/images/ba04201d-8c41-4f5c-b338-194839ea16f4_1624832023.493262.png)\\n\\nIs this the most efficient solution? No, it uses ```",
                "codeTag": "Python3"
            },
            {
                "id": 323514,
                "title": "two-python-solutions-with-explanation",
                "content": "Observe that for a `m` by `n` grid, robot will always make `(m-1)` moves to the right, and `(n-1)` moves down for a total of `(m+n-2)` moves. The number of possible paths the robot can take is then the binomial coefficient `B(m+n-2,m-1) = factorial(m+n-2)/(factorial(m-1)*factorial(n-1))`\\n\\n**Solution 1 **(definition of binomial coefficient):\\n```\\nfrom math import factorial as fact\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return fact(m+n-2)/(fact(m-1)*fact(n-1))\\n```\\n\\n**Solution 2 ** (Dynamic Programming)\\nThe recurrance relation between the number of moves at grid `(i,j)` and previous grids is `dp[i-1][j] + dp[i][j-1]` and a dp matrix is created to memoize the moves at each `(i,j)`.\\n\\n```\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        dp = [[1]*m for _ in range(n)]\\n        \\n        for i in range(1,n):\\n            for j in range(1,m):\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n                \\n        return dp[-1][-1]\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom math import factorial as fact\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return fact(m+n-2)/(fact(m-1)*fact(n-1))\\n```\n```\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        dp = [[1]*m for _ in range(n)]\\n        \\n        for i in range(1,n):\\n            for j in range(1,m):\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n                \\n        return dp[-1][-1]\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 267270,
                "title": "dp-javascript-solution",
                "content": "Use a Javascript syntactic suger to initialize list.\\nI don\\'t know if this initialization is efficient or not.\\n\\n``` javascript\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @return {number}\\n */\\nvar uniquePaths = function(m, n) {\\n    const res = [];\\n    for (let i = 0; i < n; i++) res.push([...new Array(m).fill(1)]); // initialize list\\n    for (let i = 1; i < n; i++) {\\n        for (let j = 1; j < m; j++) {\\n            res[i][j] = res[i-1][j] + res[i][j-1];\\n        }\\n    }\\n    return res[n-1][m-1];\\n};\\n```",
                "solutionTags": [],
                "code": "``` javascript\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @return {number}\\n */\\nvar uniquePaths = function(m, n) {\\n    const res = [];\\n    for (let i = 0; i < n; i++) res.push([...new Array(m).fill(1)]); // initialize list\\n    for (let i = 1; i < n; i++) {\\n        for (let j = 1; j < m; j++) {\\n            res[i][j] = res[i-1][j] + res[i][j-1];\\n        }\\n    }\\n    return res[n-1][m-1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996246,
                "title": "python-bottom-up-dynamic-programming",
                "content": "# Python | Bottom-Up Dynamic Programming \\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[0] * n for _ in range(m)]\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0 or c == 0:\\n                    dp[r][c] = 1\\n                else:\\n                    dp[r][c] = dp[r-1][c] + dp[r][c-1]\\n        return dp[m-1][n-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[0] * n for _ in range(m)]\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0 or c == 0:\\n                    dp[r][c] = 1\\n                else:\\n                    dp[r][c] = dp[r-1][c] + dp[r][c-1]\\n        return dp[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324014,
                "title": "java-solution-dynamic-programming-beats-100-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first intuition after seeing the problem was to use DFS to search all the possible paths and count them.\\nThis is the recursive bruteforce approach.\\nLater I realized that many repetitive subproblems are calculated and it was way beyond the limited time complexity.\\nSo I have applied Dynamic Programming to solve this.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLets consider an 2d `grid` of length `m x n` where each cell represents total number of unique paths that are possible.\\n\\nBy the problem description we can conclude that the unique paths from a particular cell will be the sum of unique paths of its `right` and `down` cells.\\nFor ex :-\\n```\\ngrid[r][c] = grid[r+1][c] + grid[r][c+1]\\n```\\n**So, we can use bottom-up approach of Dynamic Programming to solve this problem.**\\n\\nNow,\\nInitially the last target position `grid[m-1][n-1]` has value `1` as one path.\\nNow we traverse through the last `cell` until `grid[0][0]` and calculate paths of each cell.\\nIn the end, total paths from starting position `0,0` will be `dp[0][0]`.\\n# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs we traverse through the 2d array of `m x n`.\\n- Space complexity: O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAs we created an 2d array of `m x n`.\\n# Code\\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int grid[][] = new int[m][n];\\n        grid[m-1][n-1] = 1;\\n        for(int r = m-1; r >= 0; r--){\\n            for(int c = n-1; c >= 0; c--){\\n                if(r+1 < m){\\n                    grid[r][c] += grid[r+1][c];\\n                }\\n                if(c+1 < n){\\n                    grid[r][c] += grid[r][c+1];\\n                }\\n            }\\n        }\\n        return grid[0][0];\\n    }\\n}\\n```\\n*Hope You Understand the Approach !!*\\n\\n**Please Do Upvote :)**\\n\\n*Thank You !!*",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\ngrid[r][c] = grid[r+1][c] + grid[r][c+1]\\n```\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int grid[][] = new int[m][n];\\n        grid[m-1][n-1] = 1;\\n        for(int r = m-1; r >= 0; r--){\\n            for(int c = n-1; c >= 0; c--){\\n                if(r+1 < m){\\n                    grid[r][c] += grid[r+1][c];\\n                }\\n                if(c+1 < n){\\n                    grid[r][c] += grid[r][c+1];\\n                }\\n            }\\n        }\\n        return grid[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2361997,
                "title": "daily-leetcoding-challenge-august-day-1",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 2:** Math (Python3 only)\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1180400,
                "title": "c-simplest-5-line-dynamic-programming-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(n, vector<int>(m, 1));\\n\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++)\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n        \\n        return dp[n-1][m-1];\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(n, vector<int>(m, 1));\\n\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++)\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n        \\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896149,
                "title": "javascript-dp-solution",
                "content": "```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @return {number}\\n */\\nvar uniquePaths = function(m, n) {\\n    // big idea: the number of ways to reach a cell c[i][j]\\n    // is equal to the number of ways to reach the cell above c[i-1][j]\\n    // plus the number of ways to make the cell left c[i][j-i], because you\\n    // can only reach c[i][j] via either of those two cells\\n\\t\\n    if(m === 0 || n === 0) return 0;\\n    if(m === 1 || n === 1) return 1;\\n    \\n    // initialise DP with base cases\\n    const dp = Array(m ).fill(\\n        Array(n).fill(1)\\n    );\\n    \\n    for(let i = 1; i < m; i++) {\\n        for(let j = 1; j < n; j++) {\\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n        }\\n    }\\n    \\n    // return value for bottom right\\n    return dp[m-1][n-1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @return {number}\\n */\\nvar uniquePaths = function(m, n) {\\n    // big idea: the number of ways to reach a cell c[i][j]\\n    // is equal to the number of ways to reach the cell above c[i-1][j]\\n    // plus the number of ways to make the cell left c[i][j-i], because you\\n    // can only reach c[i][j] via either of those two cells\\n\\t\\n    if(m === 0 || n === 0) return 0;\\n    if(m === 1 || n === 1) return 1;\\n    \\n    // initialise DP with base cases\\n    const dp = Array(m ).fill(\\n        Array(n).fill(1)\\n    );\\n    \\n    for(let i = 1; i < m; i++) {\\n        for(let j = 1; j < n; j++) {\\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n        }\\n    }\\n    \\n    // return value for bottom right\\n    return dp[m-1][n-1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 871688,
                "title": "detail-explanation-using-combination-0-ms-and-100-faster",
                "content": "\\n\\n  ## Combination Program : Explanation has been given at end ##\\n   \\n    private int countUniquePathWithNCR ( int m, int n ) {      \\n    int N = m+n-2;       \\n    int r = m-1;        \\n    double ans = 1;   //Initialize it with 1 as we need to multiply the obtained result while\\n\\t//calculation    \\n\\t//Logic of loop. To understand it, take an specific example of 10c3.\\n\\t//Numerator will be 10*9*8*!7\\n\\t//Denominator !3 * !7\\n\\t//After solving you will have numeraor =10*9*8\\n\\t//and denominator =!3=3*2*1\\n\\t//Now, adjust them in a loop. the first factor in the numerator will be 8 and it can be calculated as follows 10-3+1 [Where N=10, r=3 and i=1]\\n\\t//Denominator = 1 [where i=1 ]\\n\\t//If the loop start with i=1 and goes to i=3, we will start getting the result as follows\\n\\t// 8/1, 9/2, 10/3\\n\\t//ans=ans*(N-r+i)/i  ; will give the final result.\\n\\t\\n    for ( int j=1; j<=r;  j++) {\\n        ans =  ans * ( N-r+j ) / j ;            \\n    }\\n    return ( int ) ans;  \\n}\\n\\n## Explanation ##\\n     The Recursive solution was taking more time in its execution, whereas Recursive with \\n\\t DP was a good way to solve it. But, it can also be solved by using permutation \\n\\t and combination approach.\\n\\n     If you start oberving the solution of the problem with a small matrix of size 2*3, you\\n\\t could notice that the no. of cells you visit in each unique path remains fixed . \\n\\t In case of 2*3 matrix ,the possible paths are as follows. \\n\\n    RRD, RDR, DRR \\n\\t\\n\\t**Remark**: Each R and D have different co-ordinates. Don\\'t get confused with similar \\n\\ttwo Rs. they are infact with differnt co-ordinates.\\n\\t\\n    We also notice here that we need 2 R-movements [steps] and 1- down \\n\\tmovement [step] in each path.\\n\\t\\n    Now, try to find out a relationship between total step-counts and the given matrix size.\\n\\t\\n\\tYou could notice that (m-1) + ( n-1) which is (3-1)+(2-1)  i.e.   3. Which is the no. of \\n\\ttotal step-counts.\\n\\t\\n\\tSecond thing that you can notice is the no. of right and down movements [steps] in \\n\\teach unique path which also remains constant. i.e.  Two R-movement [step] and one \\n\\tD-movement [step] are available in each path.\\n\\t\\n\\tNow, again try to find out a relationship between the no. of R-movement [step] \\n\\tand the no. of D-movement [step] with the given matrix size.\\n\\t\\n\\tYou could notice that if \"m\" denotes the right movement [step] direction, then \\n\\tthe total no. of right movement [step] is m-1 which is 3-1 i.e. 2. Which are R and  R.\\n\\t\\n\\tYou could also notice that if \"n\" denotes the down movement [step] direction, \\n\\tthen the total no. of down movement [step] is n-1 which is 2-1 i.e. 1. Which is D.\\n\\t\\n\\tSo, finally you have reached at a conclusion that there is a relationship between \\n\\tour two observations and matrix size\\n\\t\\n\\tFirst one is total steps counts = 3 [ (m-1)+(n-1) ]\\n\\t\\n\\tTotal Right movement count in each path = 2 [m-1]\\n\\tTotal Down movement count in each path = 1 [n-1]\\n\\t\\n    Now, we can think of having 3 places  to fill with 2 items[2 R] and one place with \\n\\tone item[1 D].\\n\\t\\n\\t# # #  [ \\'# \\' dentoees 3 places ]\\t\\n\\t3C2 * 1C1 \\n\\t\\n\\tOR\\n\\t\\n\\t Now, we can think of having 3 places  to fill with 1 item[1 D] and the rest two places with \\n\\ttwo items [2 R].\\n\\t\\n\\t# # #  [ \\'# \\' dentoees 3 places ]\\t\\t\\n\\t3C1 * 2C2\\n\\t\\t\\n\\tYou can approach either way to calculate the total possible combination which results \\n\\tas 3.  One more thing that you can notice here is that both 1C1 and 2C2 will give you 1 as\\n\\ta result. So, we can discard it and we can directly use either 3C2 or 3C1 .\\n\\t\\n\\tNow, translate the final result in NcR formula.\\n\\tLet N= (m-1) + (n-1)=m+n-2\\n\\tLet r= m-1 or n-1\\n\\tCalculate NcR in the program and it will be the total no. of nique paths.\\t\\n   \\n   \\n",
                "solutionTags": [
                    "Java",
                    "Combinatorics"
                ],
                "code": "\\n\\n  ## Combination Program : Explanation has been given at end ##\\n   \\n    private int countUniquePathWithNCR ( int m, int n ) {      \\n    int N = m+n-2;       \\n    int r = m-1;        \\n    double ans = 1;   //Initialize it with 1 as we need to multiply the obtained result while\\n\\t//calculation    \\n\\t//Logic of loop. To understand it, take an specific example of 10c3.\\n\\t//Numerator will be 10*9*8*!7\\n\\t//Denominator !3 * !7\\n\\t//After solving you will have numeraor =10*9*8\\n\\t//and denominator =!3=3*2*1\\n\\t//Now, adjust them in a loop. the first factor in the numerator will be 8 and it can be calculated as follows 10-3+1 [Where N=10, r=3 and i=1]\\n\\t//Denominator = 1 [where i=1 ]\\n\\t//If the loop start with i=1 and goes to i=3, we will start getting the result as follows\\n\\t// 8/1, 9/2, 10/3\\n\\t//ans=ans*(N-r+i)/i  ; will give the final result.\\n\\t\\n    for ( int j=1; j<=r;  j++) {\\n        ans =  ans * ( N-r+j ) / j ;            \\n    }\\n    return ( int ) ans;  \\n}\\n\\n## Explanation ##\\n     The Recursive solution was taking more time in its execution, whereas Recursive with \\n\\t DP was a good way to solve it. But, it can also be solved by using permutation \\n\\t and combination approach.\\n\\n     If you start oberving the solution of the problem with a small matrix of size 2*3, you\\n\\t could notice that the no. of cells you visit in each unique path remains fixed . \\n\\t In case of 2*3 matrix ,the possible paths are as follows. \\n\\n    RRD, RDR, DRR \\n\\t\\n\\t**Remark**: Each R and D have different co-ordinates. Don\\'t get confused with similar \\n\\ttwo Rs. they are infact with differnt co-ordinates.\\n\\t\\n    We also notice here that we need 2 R-movements [steps] and 1- down \\n\\tmovement [step] in each path.\\n\\t\\n    Now, try to find out a relationship between total step-counts and the given matrix size.\\n\\t\\n\\tYou could notice that (m-1) + ( n-1) which is (3-1)+(2-1)  i.e.   3. Which is the no. of \\n\\ttotal step-counts.\\n\\t\\n\\tSecond thing that you can notice is the no. of right and down movements [steps] in \\n\\teach unique path which also remains constant. i.e.  Two R-movement [step] and one \\n\\tD-movement [step] are available in each path.\\n\\t\\n\\tNow, again try to find out a relationship between the no. of R-movement [step] \\n\\tand the no. of D-movement [step] with the given matrix size.\\n\\t\\n\\tYou could notice that if \"m\" denotes the right movement [step] direction, then \\n\\tthe total no. of right movement [step] is m-1 which is 3-1 i.e. 2. Which are R and  R.\\n\\t\\n\\tYou could also notice that if \"n\" denotes the down movement [step] direction, \\n\\tthen the total no. of down movement [step] is n-1 which is 2-1 i.e. 1. Which is D.\\n\\t\\n\\tSo, finally you have reached at a conclusion that there is a relationship between \\n\\tour two observations and matrix size\\n\\t\\n\\tFirst one is total steps counts = 3 [ (m-1)+(n-1) ]\\n\\t\\n\\tTotal Right movement count in each path = 2 [m-1]\\n\\tTotal Down movement count in each path = 1 [n-1]\\n\\t\\n    Now, we can think of having 3 places  to fill with 2 items[2 R] and one place with \\n\\tone item[1 D].\\n\\t\\n\\t# # #  [ \\'# \\' dentoees 3 places ]\\t\\n\\t3C2 * 1C1 \\n\\t\\n\\tOR\\n\\t\\n\\t Now, we can think of having 3 places  to fill with 1 item[1 D] and the rest two places with \\n\\ttwo items [2 R].\\n\\t\\n\\t# # #  [ \\'# \\' dentoees 3 places ]\\t\\t\\n\\t3C1 * 2C2\\n\\t\\t\\n\\tYou can approach either way to calculate the total possible combination which results \\n\\tas 3.  One more thing that you can notice here is that both 1C1 and 2C2 will give you 1 as\\n\\ta result. So, we can discard it and we can directly use either 3C2 or 3C1 .\\n\\t\\n\\tNow, translate the final result in NcR formula.\\n\\tLet N= (m-1) + (n-1)=m+n-2\\n\\tLet r= m-1 or n-1\\n\\tCalculate NcR in the program and it will be the total no. of nique paths.\\t\\n   \\n   \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 23180,
                "title": "with-explanation-simplest-method-based-on-a-little-bit-math-knowledge-no-dp-or-any-programming-trick-needed",
                "content": "When the grid is m*n, Robot on top left need to move right m-1 times and down n-1 times to get to Finish Spot in total, since it doesn't know to go left or up. Nothing more, nothing less.  \\n\\nSo the problem now is \"how many possible combination of m-1 right moves and n-1 down moves\", obviously it is C(m+n-2, m-1), aka  \\\\frac{(m+n-2)!}{(m-1)!(n-1)!}, which is shown by the code below.\\n\\n    class Solution:\\n        def c(self,n,k):\\n            r = 1\\n            for i in range(n,n-k,-1):\\n                r *= i\\n            for i in range(1,k+1):\\n                r /= i\\n            return r\\n            \\n        def uniquePaths(self, m, n):\\n            return self.c(m+n-2,m-1)",
                "solutionTags": [],
                "code": "When the grid is m*n, Robot on top left need to move right m-1 times and down n-1 times to get to Finish Spot in total, since it doesn't know to go left or up. Nothing more, nothing less.  \\n\\nSo the problem now is \"how many possible combination of m-1 right moves and n-1 down moves\", obviously it is C(m+n-2, m-1), aka  \\\\frac{(m+n-2)!}{(m-1)!(n-1)!}, which is shown by the code below.\\n\\n    class Solution:\\n        def c(self,n,k):\\n            r = 1\\n            for i in range(n,n-k,-1):\\n                r *= i\\n            for i in range(1,k+1):\\n                r /= i\\n            return r\\n            \\n        def uniquePaths(self, m, n):\\n            return self.c(m+n-2,m-1)",
                "codeTag": "Java"
            },
            {
                "id": 3994790,
                "title": "putta-easy-solution-c-beats-100-recursive-memoization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int paths(int i,int j,int m,int n,vector< vector<int>>& dp){\\n        if (i >= m || j>= n){\\n            return 0;\\n        }\\n        if (i == m-1 && j == n-1)\\n            return 1;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = paths(i+1,j,m,n,dp)+paths(i,j+1,m,n,dp);\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector< vector<int>> dp(m,vector<int>(n,-1));\\n        return paths(0,0,m,n,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int paths(int i,int j,int m,int n,vector< vector<int>>& dp){\\n        if (i >= m || j>= n){\\n            return 0;\\n        }\\n        if (i == m-1 && j == n-1)\\n            return 1;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = paths(i+1,j,m,n,dp)+paths(i,j+1,m,n,dp);\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector< vector<int>> dp(m,vector<int>(n,-1));\\n        return paths(0,0,m,n,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994527,
                "title": "c-python-math-pascal-triangle-dp-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe codes calculate the number of unique paths in a grid from the top-left corner to the bottom-right corner. To do this, it uses the concept of combinations to determine the total number of ways to choose a certain number of downward steps (represented by \\'V\\') and rightward steps (represented by \\'>\\').\\n\\n[Please turn on English subtitles if necessary]\\n[https://youtu.be/sgRvG0rhWGI?si=N7nEiMEw70QCsnLx](https://youtu.be/sgRvG0rhWGI?si=N7nEiMEw70QCsnLx)\\n\\n\\nIn the grid, there are exactly (m + n - 2) steps to move in total. Out of these steps, (m - 1) are downward steps and (n - 1) are rightward steps. This can be converted into a combination problem where we need to find the combination number for permutations of (m - 1) downward steps and (n - 1) rightward steps.\\n\\nIn Python, the combination number can be directly calculated using the formula \\n$$C(N, K) = \\\\frac{(N)(N-1)\\\\cdots (N-K+1)}{K!},$$ \\nwhere $N=m + n - 2$ represents the total number of steps and $K=\\\\min(n-1, m-1)$ the mininum for the numbers for downward steps and rightward steps. This formula simplifies the computation.\\n\\nHowever, in C++, the direct computation of the combination number may exceed the limits of even the signed long long data type. Therefore, the code employs an iterative approach inspired by Pascal\\'s Triangle, which is a form of dynamic programming. By iteratively calculating the combinations, it avoids the need for large integer computations and efficiently determines the number of unique paths.\\n\\nBy understanding this concept and leveraging dynamic programming techniques, the code effectively solves the problem of finding the number of unique paths in the grid.\\n\\nSo use the idea in Leetcode 118. Pascal\\'s Triangle, which is in fact the iterative way for dynamic programming, then done!\\n[https://youtu.be/paoJGMYEEhA](https://youtu.be/paoJGMYEEhA)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Python 1 line just comb(m+n-2, m-1)\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:        \\n        return comb(m+n-2, m-1)\\n```\\n# Python Code\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        if n == 1: \\n            return 1\\n        N = n + m - 2\\n        K = min(n - 1, m - 1)\\n        C=1\\n        for i in range(N,N-K, -1):\\n            C*=i\\n        for i in range(1, K+1):\\n            C//=i       \\n        return C\\n```\\n# C++ solution uses recursion from Pascal\\'s Triangle with Memoziation\\n```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> C;\\n    long long comb(int i, int j){\\n        if (C[i][j]!=-1) return C[i][j];\\n        if (j==0 || j==i ) return C[i][j]=1LL;\\n        return C[i][j]=comb(i-1, j)+comb(i-1, j-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        int N = n + m - 2, K = min(n - 1, m - 1);\\n        C.assign(N+1, vector(K+1, -1LL));\\n        return comb(N, K);\\n    }\\n};\\n```\\n# DP solution using recursion dp(i,j)=dp(i-1, j)+dp(i, j-1) beats also 100% can compare with comb(i+j, j)=dp[i][j] in Pascal\\'s triangle\\n```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> dp;\\n    long long f(int i, int j){\\n        if (dp[i][j]!=-1) return dp[i][j];\\n        if (i==0 || j==0 ) return dp[i][j]=1LL;\\n        return dp[i][j]=f(i-1, j)+f(i, j-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        dp.assign(m+1, vector(n+1, -1LL));\\n        return f(m-1, n-1);\\n    }\\n};\\n```\\n# C++ code using Pascal\\'s triangle beats 100%\\nBoth of SC & iterations are optimized\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        if (n == 1) return 1;\\n        int N = n + m - 2, K = min(n - 1, m - 1);\\n        vector<int> prev, C_N;\\n        prev.assign(K + 1, 1); // C(0,0)=1\\n        for (int i = 1; i <= K; i++) {\\n            C_N.assign(i + 1, 1);\\n            for (int j = 1; j <= i / 2; j++) {\\n                C_N[j] = C_N[i - j] = prev[j] + prev[j - 1];\\n            }\\n            prev = C_N;\\n        }\\n        for (int i = K + 1; i <= N - K; i++) {\\n            C_N.assign(K + 1, 1);\\n            for (int j = 1; j <= K; j++)\\n                C_N[j] = prev[j - 1] + prev[j];\\n            prev = C_N;\\n        }\\n        for (int i = N - K + 1, j0 = 1; i <= N; i++, j0++) {\\n            C_N.assign(K + 1, 1);\\n            for (int j = j0; j <= K; j++)\\n                C_N[j] = prev[j - 1] + prev[j];\\n            prev = C_N;\\n        }\\n        return C_N[K];\\n    }\\n};\\n\\n```\\n# C++ code using C(N, K)=C(N-1, K-1)*N/K which is also applied for solving hard problem [2842. Count K-Subsequences of a String With Maximum Beauty](https://leetcode.com/problems/count-k-subsequences-of-a-string-with-maximum-beauty/solutions/3995805/c-math-beats-100/)\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        if (n == 1) return 1;\\n        int N = n + m - 2, K = min(n - 1, m - 1);\\n        unsigned long long C=1LL;\\n        for (unsigned i=1; i<=K; i++) \\n            C=C*(N-K+i)/i;            \\n        return C;\\n    }\\n};\\n\\n\\n```\\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:        \\n        return comb(m+n-2, m-1)\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        if n == 1: \\n            return 1\\n        N = n + m - 2\\n        K = min(n - 1, m - 1)\\n        C=1\\n        for i in range(N,N-K, -1):\\n            C*=i\\n        for i in range(1, K+1):\\n            C//=i       \\n        return C\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> C;\\n    long long comb(int i, int j){\\n        if (C[i][j]!=-1) return C[i][j];\\n        if (j==0 || j==i ) return C[i][j]=1LL;\\n        return C[i][j]=comb(i-1, j)+comb(i-1, j-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        int N = n + m - 2, K = min(n - 1, m - 1);\\n        C.assign(N+1, vector(K+1, -1LL));\\n        return comb(N, K);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> dp;\\n    long long f(int i, int j){\\n        if (dp[i][j]!=-1) return dp[i][j];\\n        if (i==0 || j==0 ) return dp[i][j]=1LL;\\n        return dp[i][j]=f(i-1, j)+f(i, j-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        dp.assign(m+1, vector(n+1, -1LL));\\n        return f(m-1, n-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        if (n == 1) return 1;\\n        int N = n + m - 2, K = min(n - 1, m - 1);\\n        vector<int> prev, C_N;\\n        prev.assign(K + 1, 1); // C(0,0)=1\\n        for (int i = 1; i <= K; i++) {\\n            C_N.assign(i + 1, 1);\\n            for (int j = 1; j <= i / 2; j++) {\\n                C_N[j] = C_N[i - j] = prev[j] + prev[j - 1];\\n            }\\n            prev = C_N;\\n        }\\n        for (int i = K + 1; i <= N - K; i++) {\\n            C_N.assign(K + 1, 1);\\n            for (int j = 1; j <= K; j++)\\n                C_N[j] = prev[j - 1] + prev[j];\\n            prev = C_N;\\n        }\\n        for (int i = N - K + 1, j0 = 1; i <= N; i++, j0++) {\\n            C_N.assign(K + 1, 1);\\n            for (int j = j0; j <= K; j++)\\n                C_N[j] = prev[j - 1] + prev[j];\\n            prev = C_N;\\n        }\\n        return C_N[K];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        if (n == 1) return 1;\\n        int N = n + m - 2, K = min(n - 1, m - 1);\\n        unsigned long long C=1LL;\\n        for (unsigned i=1; i<=K; i++) \\n            C=C*(N-K+i)/i;            \\n        return C;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999834,
                "title": "python-3-solutions-video-solution",
                "content": "I have explained this [here](https://youtu.be/Q6rwr41Hml8).\\n\\nIf you found this useful, please upvote, like the video & subscribe to the channel.\\n\\nCheers.\\n\\n# Time Compexity\\n\\n![image](https://assets.leetcode.com/users/images/1796bdb8-5c47-421b-9c85-f11c2eb7ca27_1672861197.1021965.png)\\n\\n\\n# Maths - Combinations\\nThis is the same as chosing **m-1** down moves from **m+n-2** total moves.\\n\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        return math.comb(m+n-2, m-1)\\n```\\n\\n# Memoization (Top-Down)\\n\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n                \\n        @cache\\n        def dfs(i,j):\\n            if i==m-1 or j==n-1:\\n                return 1\\n            return dfs(i+1, j) + dfs(i, j+1)\\n        return dfs(0, 0)\\n```\\n\\n# Dynamic Programming (Bottom-Up)\\n\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        lower = [1] * n\\n        \\n        for i in reversed(range(m-1)):\\n            upper = [0] * n\\n            upper[n-1] = 1\\n            for j in reversed(range(n-1)):\\n                upper[j] = upper[j+1] + lower[j]\\n            lower = upper\\n            \\n        return lower[0]\\t\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        return math.comb(m+n-2, m-1)\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n                \\n        @cache\\n        def dfs(i,j):\\n            if i==m-1 or j==n-1:\\n                return 1\\n            return dfs(i+1, j) + dfs(i, j+1)\\n        return dfs(0, 0)\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        lower = [1] * n\\n        \\n        for i in reversed(range(m-1)):\\n            upper = [0] * n\\n            upper[n-1] = 1\\n            for j in reversed(range(n-1)):\\n                upper[j] = upper[j+1] + lower[j]\\n            lower = upper\\n            \\n        return lower[0]\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362169,
                "title": "quick-math-approach-python-c-go-o-min-m-n-time",
                "content": "To get from the top left corner to the bottom right corner, the robot has to move, in some order, `m - 1` squares down and `n - 1` squares to the right. There is a **one-to-one correspondence** with the set of all possible paths and the set of *instructions* to follow these paths.\\n\\n>An easy way to give instructions is to tell the robot at ***each step*** if they need to move down or to the right, so the problem is equivalent to figuring out in how many ways we can **rearrange** the letters of the word `DDDDD...DDDRRRR...RR` that has exactly `m - 1` `D`s and `n - 1` `R`s. This can be done in exactly\\n>```\\n>\\tbinom((m - 1) + (n - 1), n - 1)\\n>```\\n>different ways, where\\n>```\\n>\\tbinom(n, k) = n! / (k! * (n - k)!)\\n>```\\n>counts the number of ways to choose `k` objects from a group of `n` in no particular order, since we need to **choose** which `n - 1` of the `(m - 1) + (n - 1)` spots in the word will be taken by `R`s, and the remaining will be taken by `D`s.\\n\\n&#8718;\\n\\n### ****Python3** Code**\\n\\n```python\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n\\t\\n\\t\\t# recursive definition of binom(n, k)\\n        def binom(n, k) -> int:\\n            if k == 0:\\n                return 1\\n            return (n - k + 1) * binom(n, k - 1) // k\\n        \\n        return binom(m + n - 2, min(m - 1, n - 1))\\n```\\n\\n### ****C++** Code**\\n```\\nclass Solution {\\n    long int binom(int n, int k){\\n        if (k == 0){\\n            return 1;\\n        }\\n        return (long int) floor((n - k + 1) * binom(n, k - 1) / k);\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        return binom(m + n - 2, min(m - 1, n - 1));\\n    }\\n};\\n```\\n\\n### ****Go** code**\\n```\\nfunc min(a int, b int) int {\\n    if a < b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n\\nfunc binom(n int, k int) int {\\n    if k == 0 {\\n        return 1\\n    }\\n    return (n - k + 1) * binom(n, k - 1) / k\\n}\\n\\nfunc uniquePaths(m int, n int) int {\\n    return binom(m + n - 2, min(m - 1, n - 1))\\n}\\n```\\n* **Note** `binom(n, k) == binom(n, n - k)` for all `0 <= k <= n`. The recursive definition we have above performs faster if we pick the smallest of `k` and `n - k`, so that is why we call `binom(m + n - 2, min(m - 1, n - 1))`.",
                "solutionTags": [
                    "Python",
                    "C",
                    "Go",
                    "Math"
                ],
                "code": "```\\n>\\tbinom((m - 1) + (n - 1), n - 1)\\n>```\n```\\n>\\tbinom(n, k) = n! / (k! * (n - k)!)\\n>```\n```python\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n\\t\\n\\t\\t# recursive definition of binom(n, k)\\n        def binom(n, k) -> int:\\n            if k == 0:\\n                return 1\\n            return (n - k + 1) * binom(n, k - 1) // k\\n        \\n        return binom(m + n - 2, min(m - 1, n - 1))\\n```\n```\\nclass Solution {\\n    long int binom(int n, int k){\\n        if (k == 0){\\n            return 1;\\n        }\\n        return (long int) floor((n - k + 1) * binom(n, k - 1) / k);\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        return binom(m + n - 2, min(m - 1, n - 1));\\n    }\\n};\\n```\n```\\nfunc min(a int, b int) int {\\n    if a < b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n\\nfunc binom(n int, k int) int {\\n    if k == 0 {\\n        return 1\\n    }\\n    return (n - k + 1) * binom(n, k - 1) / k\\n}\\n\\nfunc uniquePaths(m int, n int) int {\\n    return binom(m + n - 2, min(m - 1, n - 1))\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255608,
                "title": "c-simple-tc-o-n-m-using-calculate-ncr",
                "content": "int uniquePaths(int m, int n) {\\n      long path=1;\\n       \\n         \\n    for (int i = n; i < (m + n - 1); i++) {\\n        path *= i;\\n        path /= (i - n + 1);\\n    }\\n",
                "solutionTags": [],
                "code": "int uniquePaths(int m, int n) {\\n      long path=1;\\n       \\n         \\n    for (int i = n; i < (m + n - 1); i++) {\\n        path *= i;\\n        path /= (i - n + 1);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1674332,
                "title": "solution-swift-unique-paths-test-cases",
                "content": "```swift\\nclass Solution {\\n    func uniquePaths(_ m: Int, _ n: Int) -> Int {\\n        guard m > 0 else { return 0 }\\n        var dp = [Int](repeating: 1, count: n)\\n        for _ in 1..<m {\\n            for c in 1..<n {\\n                dp[c] += dp[c - 1]\\n            }\\n        }\\n        return dp.last ?? 0\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 4 tests, with 0 failures (0 unexpected) in 0.014 (0.016) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.uniquePaths(3, 7)\\n        XCTAssertEqual(value, 28)\\n    }\\n    \\n    /// From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\\n    /// 1. Right -> Down -> Down\\n    /// 2. Down -> Down -> Right\\n    /// 3. Down -> Right -> Down\\n    func test1() {\\n        let value = solution.uniquePaths(3, 2)\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    func test2() {\\n        let value = solution.uniquePaths(7, 3)\\n        XCTAssertEqual(value, 28)\\n    }\\n    \\n    func test3() {\\n        let value = solution.uniquePaths(3, 3)\\n        XCTAssertEqual(value, 6)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func uniquePaths(_ m: Int, _ n: Int) -> Int {\\n        guard m > 0 else { return 0 }\\n        var dp = [Int](repeating: 1, count: n)\\n        for _ in 1..<m {\\n            for c in 1..<n {\\n                dp[c] += dp[c - 1]\\n            }\\n        }\\n        return dp.last ?? 0\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.uniquePaths(3, 7)\\n        XCTAssertEqual(value, 28)\\n    }\\n    \\n    /// From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\\n    /// 1. Right -> Down -> Down\\n    /// 2. Down -> Down -> Right\\n    /// 3. Down -> Right -> Down\\n    func test1() {\\n        let value = solution.uniquePaths(3, 2)\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    func test2() {\\n        let value = solution.uniquePaths(7, 3)\\n        XCTAssertEqual(value, 28)\\n    }\\n    \\n    func test3() {\\n        let value = solution.uniquePaths(3, 3)\\n        XCTAssertEqual(value, 6)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223719,
                "title": "faster-than-100-using-basic-maths-in-c",
                "content": "So basically to reach the destination we have to move m-1 downs and n-1 rights, this means now our new task would be like there are m-1 objects of one kind and n-1 objects of another kind and we have to count the total number of arrangements possible.\\nUsing permutation and combinations\\nanswer = (m+n-2)! / ((m-1)! * (n-1)!)\\nThat\\'s it. Hit like if you like my approach :-)\\nAnd here is the simple code\\n```\\nclass Solution {\\npublic:\\n    \\n    int uniquePaths(int m, int n) {\\n        if(m <=0 || n <= 0) \\n            return 0;\\n        \\n        long long res = 1;\\n        for(int i = n; i < m+n-1 ; i++){\\n            res = res * i / (i- n + 1);\\n        }\\n        \\n        return (int)res;\\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int uniquePaths(int m, int n) {\\n        if(m <=0 || n <= 0) \\n            return 0;\\n        \\n        long long res = 1;\\n        for(int i = n; i < m+n-1 ; i++){\\n            res = res * i / (i- n + 1);\\n        }\\n        \\n        return (int)res;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124869,
                "title": "c-bruteforce-top-down-bottom-up-time-o-2-n-o-m-n-space-o-m-n",
                "content": "**Bruteforce**\\nTime Complexity: O (2^(m+n))\\nSpace Complexity: O(m + n) //I thinkk\\n```\\n    int uniquePaths(int m, int n) {\\n        int res=0;\\n        res+=dfs (m, n, 0, 0);\\n    return res;\\n    }\\n    \\n    int dfs (int m, int n, int i, int j) {\\n        if (i<0 || j<0 || i>=m || j>=n) return 0;\\n        if (i==m-1 && j==n-1) return 1;\\n        \\n        return dfs (m, n, i+1, j) + dfs (m, n, i, j+1);\\n    }\\n```\\n\\n**Memoisation (Top-down)**\\nTime Complexity: O(m * n)\\nSpace Complexity: O(m * n)\\n```\\n    int uniquePaths(int m, int n) {\\n        vector <vector<int>> dp(m+1, vector<int> (n+1,-1));\\n        return dfs (m, n, dp, 0, 0);\\n    }\\n    \\n    int dfs (int m, int n, vector <vector<int>> &dp, int i, int j) {\\n        if (i>m || j>n) return 0;\\n        if (i==m-1 && j==n-1) return 1;\\n        else if (dp[i][j]!=-1) return dp[i][j];        \\n        else return dp[i][j]=dfs (m, n, dp, i+1, j) + dfs (m, n, dp, i, j+1);\\n    }\\n```\\n\\n**Tabular (Bottom-up)**\\nTime Complexity: O(m * n)\\nSpace Complexity: O(m * n)\\n```\\n    int uniquePaths(int m, int n) {\\n        vector <vector<int>> dp(m, vector<int> (n,1));\\n        for (int i=1; i<m; i++) \\n            for (int j=1; j<n; j++) \\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n        \\n        return dp[m-1][n-1];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int uniquePaths(int m, int n) {\\n        int res=0;\\n        res+=dfs (m, n, 0, 0);\\n    return res;\\n    }\\n    \\n    int dfs (int m, int n, int i, int j) {\\n        if (i<0 || j<0 || i>=m || j>=n) return 0;\\n        if (i==m-1 && j==n-1) return 1;\\n        \\n        return dfs (m, n, i+1, j) + dfs (m, n, i, j+1);\\n    }\\n```\n```\\n    int uniquePaths(int m, int n) {\\n        vector <vector<int>> dp(m+1, vector<int> (n+1,-1));\\n        return dfs (m, n, dp, 0, 0);\\n    }\\n    \\n    int dfs (int m, int n, vector <vector<int>> &dp, int i, int j) {\\n        if (i>m || j>n) return 0;\\n        if (i==m-1 && j==n-1) return 1;\\n        else if (dp[i][j]!=-1) return dp[i][j];        \\n        else return dp[i][j]=dfs (m, n, dp, i+1, j) + dfs (m, n, dp, i, j+1);\\n    }\\n```\n```\\n    int uniquePaths(int m, int n) {\\n        vector <vector<int>> dp(m, vector<int> (n,1));\\n        for (int i=1; i<m; i++) \\n            for (int j=1; j<n; j++) \\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n        \\n        return dp[m-1][n-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1000238,
                "title": "only-1-line-of-c-with-clear-explanation-beats-100",
                "content": "First thing\\'s first, here\\'s the 1 line code ..\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        return round(exp(lgamma(m+n-1) - (lgamma(m) + lgamma(n))));\\n    }\\n};\\n```\\n\\nThis is **not at all a DP problem**. It\\'s a simple **math combiantional problem**.\\n\\nWhat is lgamma ?\\n=> It\\'s a math formula which calculates natural logarithm of the absolute value of the [gamma function](https://en.wikipedia.org/wiki/Gamma_function) of x. [Refer here for usage.](http://www.cplusplus.com/reference/cmath/lgamma/)\\n\\nWhy are we using lgamma ?\\n=> Because it helps us to calculate factorial. Given `\\u0413(n)` is gamma function of n, \\n\\t\\t**`\\u0413(n) = (n-1)!; for positive integers`**\\nAnd so, **`lgamma(n) = log(\\u0413(n))`**\\n\\nTo avoid re-writing what other great articles have already mentioned, all we need is to compute\\n`(n + m -2) ! / (n-1)! (m-1)!`\\n\\nLet\\'s take \\n```\\n=> y = (n + m - 2) ! /  (n-1)! (m-1)!\\n=> log y = log[(n + m - 2) ! / (n-1)! (m-1)!] .. (taking log both sides)\\n=> log y = log[(n + m - 2)!] - log[(n-1)! (m-1)!]\\n=> log y = log[(n + m - 2)!] - [log((n-1)!) + log((m-1)!)]\\n=> log y = lgamma(n + m - 1) - (lgamma(n) + lgamma(m))\\n=> y = e ^ [lgamma(n + m - 1) - (lgamma(n) + lgamma(m))]\\n```\\nAnd then we round off for precisions.\\n\\nI hope someone found this helpful and interesting :)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        return round(exp(lgamma(m+n-1) - (lgamma(m) + lgamma(n))));\\n    }\\n};\\n```\n```\\n=> y = (n + m - 2) ! /  (n-1)! (m-1)!\\n=> log y = log[(n + m - 2) ! / (n-1)! (m-1)!] .. (taking log both sides)\\n=> log y = log[(n + m - 2)!] - log[(n-1)! (m-1)!]\\n=> log y = log[(n + m - 2)!] - [log((n-1)!) + log((m-1)!)]\\n=> log y = lgamma(n + m - 1) - (lgamma(n) + lgamma(m))\\n=> y = e ^ [lgamma(n + m - 1) - (lgamma(n) + lgamma(m))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711370,
                "title": "c-optimized-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        if(n==1||m==1)\\n            return 1;\\n        vector<vector<int>> dp(2,vector<int>(m,1));\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                dp[i%2][j] = dp[(i-1)%2][j] + dp[i%2][j-1];\\n            }\\n        }\\n        return dp[(n-1)%2][m-1];\\n    }\\n};\\n```\\nIf you have any doubts,feel free to ask in comment section",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        if(n==1||m==1)\\n            return 1;\\n        vector<vector<int>> dp(2,vector<int>(m,1));\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                dp[i%2][j] = dp[(i-1)%2][j] + dp[i%2][j-1];\\n            }\\n        }\\n        return dp[(n-1)%2][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588648,
                "title": "c-100-both-in-memory-and-time-dp",
                "content": "**If understood please upvote\\nIf want help please comment**\\n```\\nint uniquePaths(int m, int n) {\\n        int dp[m][n];\\n        \\n        for(int i=0;i<m;i++)\\n            dp[i][0]=1;\\n        \\n        for(int i=0;i<n;i++)\\n            dp[0][i]=1;\\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++)\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n        }\\n        return dp[m-1][n-1];\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint uniquePaths(int m, int n) {\\n        int dp[m][n];\\n        \\n        for(int i=0;i<m;i++)\\n            dp[i][0]=1;\\n        \\n        for(int i=0;i<n;i++)\\n            dp[0][i]=1;\\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++)\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n        }\\n        return dp[m-1][n-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 405310,
                "title": "c-solution-with-explanation-dp",
                "content": "```\\npublic int UniquePaths(int m, int n)\\n        {\\n            // Matrix to store the value of possible ways to reach each cell\\n            int[][] dp = new int[m][];\\n\\n            // C# thing, as we cannot define int[][] dp = new int[m][n]; \\n            for (int i = 0; i < m; i++)\\n            {\\n                dp[i] = new int[n];\\n            }\\n\\n            //Base Conditions \\n            // all first column of every row as 1\\n            for(int i = 0; i < dp.Length; i++)\\n                dp[i][0] = 1;\\n            // all first row of every column as 1\\n            for(int i = 0; i< dp[0].Length; i++)\\n                  dp[0][i] = 1;\\n\\n            for (int i = 1; i < m; i++)\\n            {\\n                for (int j = 1; j < n; j++)\\n                {\\n                        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];   \\n                }\\n            }\\n\\n            return dp[m - 1][n - 1];\\n\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int UniquePaths(int m, int n)\\n        {\\n            // Matrix to store the value of possible ways to reach each cell\\n            int[][] dp = new int[m][];\\n\\n            // C# thing, as we cannot define int[][] dp = new int[m][n]; \\n            for (int i = 0; i < m; i++)\\n            {\\n                dp[i] = new int[n];\\n            }\\n\\n            //Base Conditions \\n            // all first column of every row as 1\\n            for(int i = 0; i < dp.Length; i++)\\n                dp[i][0] = 1;\\n            // all first row of every column as 1\\n            for(int i = 0; i< dp[0].Length; i++)\\n                  dp[0][i] = 1;\\n\\n            for (int i = 1; i < m; i++)\\n            {\\n                for (int j = 1; j < n; j++)\\n                {\\n                        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];   \\n                }\\n            }\\n\\n            return dp[m - 1][n - 1];\\n\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374561,
                "title": "100-5-solutions-step-by-step-optimisation-dp-thought-process",
                "content": "Presenting a approach driven code, so that it help you to learn how to approach this kind of problems.\\n\\n**Backtracking**\\n----------\\n\\n```\\n\\n/**\\n * We can solve this problem through backtracking.\\n * Backtracking\\n * 1. Our goal: To reach destination cell (m-1,n-1), once reach it counted as one path\\n * 2. Our constraints: a) We can not move outside of boundary b\\n * 3. Our choices: a) we can move either Down (i+1,j) or right (i, j+1) from any cell\\n * <p>\\n * Complexity:\\n * To reach a cell there are two way and we try all the source cell to reach this cell.\\n * Complexity: O((m*n)^2) /O (m*n)\\n * <p>\\n * TLE\\n */\\nclass UniquePathsIBacktracking {\\n\\n\\n    public int uniquePaths(int m, int n) {\\n\\n        if (m == 0 || n == 0)\\n            return 0;\\n\\n        /**\\n         * m==1 ; if only horizontal strip is there; source (0,0) destination (0,n-1) and we can move right only\\n         * n==1 ; if only vertical strip is there; source (0,0) destination (m-1,0) and we can move down only\\n         */\\n        if (m == 1 || n == 1)\\n            return 1;\\n\\n\\n        final boolean maze[][] = new boolean[m][n];\\n\\n        final int sx = 0, sy = 0;\\n        final int dx = m - 1, dy = n - 1;\\n\\n        return uniquePaths(maze, m, n, sx, sy, dx, dy);\\n\\n\\n    }\\n\\n    private int uniquePaths(boolean[][] maze, int m, int n, int sx, int sy, int dx, int dy) {\\n\\n        //1. Our goal: To reach destination cell (m-1,n-1), once reach it counted as one path\\n        if (sx == dx && sy == dy)\\n            return 1;\\n\\n        int path = 0;\\n        if (isSafe(sx, sy, m, n, maze)) {\\n            maze[sx][sy] = true;\\n\\n            path = uniquePaths(maze, m, n, sx + 1, sy, dx, dy)  //down\\n                    +\\n                    uniquePaths(maze, m, n, sx, sy + 1, dx, dy);//right\\n\\n            maze[sx][sy] = false;\\n        }\\n        return path;\\n    }\\n\\n    private boolean isSafe(int sx, int sy, int m, int n, boolean[][] maze) {\\n        if (sx >= m || sy >= n || sx < 0 || sy < 0 || maze[sx][sy])\\n            return false;\\n        return true;\\n    }\\n\\n\\n}\\n```\\n\\n**Cache: DP Top Down**\\n\\n```\\n\\n/**\\n * In above backtracking, we visit same cell[i][j] and try to reach destination[m-1][n-1].\\n * This happen again n again for different source cell [sx][sy] for this cell [i][j].\\n * <p>\\n * Since there are overlapping sub-problems, we can cache them; Hence DP\\n * <p>\\n * dp[i][j] = dp[i+1][j] + dp[i][j+1] ; [i,j] is in range of [m,n]\\n * *        = 0 [i,j] is Not in range of [m,n]\\n * base case:\\n * i==dx, j==dy => dp[i][j] = 1\\n * <p>\\n * dp[sx][sy] is output\\n * <p>\\n * <p>\\n * <p>\\n * Complexity : To reach a cell there are two way and we try them only once from the source cell to reach this cell.\\n * O(m*n) / O (m*n)\\n * <p>\\n * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths.\\n * Memory Usage: 33.2 MB, less than 5.10% of Java online submissions for Unique Paths.\\n */\\nclass UniquePathsIDPTopDown {\\n\\n\\n    public int uniquePaths(int m, int n) {\\n\\n        if (m == 0 || n == 0)\\n            return 0;\\n\\n        /**\\n         * m==1 ; if only horizontal strip is there; source (0,0) destination (0,n-1) and we can move right only\\n         * n==1 ; if only vertical strip is there; source (0,0) destination (m-1,0) and we can move down only\\n         */\\n        if (m == 1 || n == 1)\\n            return 1;\\n\\n\\n        final int maze[][] = new int[m][n];\\n        for (int i = 0; i < m; i++)\\n            Arrays.fill(maze[i], -1);\\n\\n        final int sx = 0, sy = 0;\\n        final int dx = m - 1, dy = n - 1;\\n\\n        return uniquePaths(maze, m, n, sx, sy, dx, dy);\\n\\n\\n    }\\n\\n    private int uniquePaths(int[][] maze, int m, int n, int sx, int sy, int dx, int dy) {\\n\\n        if (isSafe(sx, sy, m, n)) {\\n\\n            if (sx == dx && sy == dy)\\n                return maze[sx][sy] = 1;\\n\\n            if (maze[sx][sy] != -1)\\n                return maze[sx][sy];\\n\\n\\n            return maze[sx][sy] = uniquePaths(maze, m, n, sx + 1, sy, dx, dy)  //down\\n                    +\\n                    uniquePaths(maze, m, n, sx, sy + 1, dx, dy);//right\\n\\n        }\\n        return 0;\\n    }\\n\\n    private boolean isSafe(int sx, int sy, int m, int n) {\\n        if (sx >= m || sy >= n || sx < 0 || sy < 0)\\n            return false;\\n        return true;\\n    }\\n}\\n\\n```\\n\\n\\n**Cache: DP Bottom up**\\n\\n```\\n\\n/**\\n * * dp[i][j] = dp[i-1][j] + dp[i][j-1] ; [i,j] is in range of [m,n]\\n * * *        = 0 [i,j] is Not in range of [m,n]\\n * * base case:\\n * * i==0 or j==0 => dp[i][j] = 0\\n * * i==dx, j==dy => dp[i][j] = 1\\n * * <p>\\n * * dp[dx][dy] is output\\n * <p>\\n * * Complexity : To reach a cell there are two way and we try them only once from the source cell to reach this cell.\\n * * O(m*n) / O (m*n)\\n * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths.\\n * Memory Usage: 33.2 MB, less than 5.10% of Java online submissions for Unique Paths.\\n */\\nclass UniquePathsIDPBottomUp {\\n\\n\\n    public int uniquePaths(int m, int n) {\\n\\n        if (m == 0 || n == 0)\\n            return 0;\\n\\n\\n        final int dp[][] = new int[m + 1][n + 1];\\n\\n        for (int i = 0; i <= m; i++) {\\n\\n            for (int j = 0; j <= n; j++) {\\n\\n                if (i == 0 || j == 0)\\n                    dp[i][j] = 0;\\n\\n                /**\\n                 * m==1 ; if only horizontal strip is there; source (0,0) destination (0,n-1) and we can move right only\\n                 * n==1 ; if only vertical strip is there; source (0,0) destination (m-1,0) and we can move down only\\n                 */\\n                else if (i == 1 || j == 1)\\n                    dp[i][j] = 1;\\n\\n                else {\\n                    //would reach this cell by coming down from up dp[i - 1][j] or by coming right from left dp[i][j - 1]\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n\\n            }\\n        }\\n        return dp[m][n];\\n\\n\\n    }\\n\\n\\n}\\n```\\n\\n\\n**Cache: DP Bottom up Space optimize**\\n\\n```\\n\\n/**\\n * * dp[i][j] = dp[i-1][j] + dp[i][j-1] ; [i,j] is in range of [m,n]\\n * * *        = 0 [i,j] is Not in range of [m,n]\\n * * base case:\\n * * i==0 or j==0 => dp[i][j] = 0\\n * * i==dx, j==dy => dp[i][j] = 1\\n * * <p>\\n * * dp[dx][dy] is output\\n * <p>\\n * We can see we are using only two rows at a time. We can optimize the space\\n * dp[i-1][j] => dp[j] old\\n * dp[i][j-1] => dp[j-1] old\\n * <p>\\n * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths.\\n * Memory Usage: 32.9 MB, less than 5.10% of Java online submissions for Unique Paths.\\n */\\nclass UniquePathsIDPBottomUpSpaceOptimize {\\n\\n\\n    public int uniquePaths(int m, int n) {\\n\\n        if (m == 0 || n == 0)\\n            return 0;\\n\\n\\n        final int dp[] = new int[n + 1];\\n\\n        for (int i = 0; i <= m; i++) {\\n\\n            for (int j = 0; j <= n; j++) {\\n\\n                if (i == 0 || j == 0)\\n                    dp[j] = 0;\\n\\n                /**\\n                 * m==1 ; if only horizontal strip is there; source (0,0) destination (0,n-1) and we can move right only\\n                 * n==1 ; if only vertical strip is there; source (0,0) destination (m-1,0) and we can move down only\\n                 */\\n                else if (i == 1 || j == 1)\\n                    dp[j] = 1;\\n\\n                else {\\n                    //would reach this cell by coming down from up dp[i - 1][j] or by coming right from left dp[i][j - 1]\\n                    dp[j] = dp[j] + dp[j - 1];\\n                }\\n\\n            }\\n        }\\n        return dp[n];\\n\\n\\n    }\\n\\n\\n    public int uniquePathsReverse(int m, int n) {\\n        int[] res = new int[m + 1]; // for this problem we can reduce the m*n matrix to an array\\n\\n        Arrays.fill(res, 1);\\n\\n        for (int nIdx = n - 1; nIdx >= 1; nIdx--) {\\n            for (int mIdx = m - 1; mIdx >= 1; mIdx--) {\\n                res[mIdx] = res[mIdx] + res[mIdx + 1];\\n            }\\n        }\\n\\n        return res[1];\\n    }\\n\\n}\\n\\n```\\n\\n**Another approach: Binomial Coefficient**\\n\\n```\\n/**\\n * https://www.geeksforgeeks.org/binomial-coefficient-dp-9/\\n * Basically imagine that you have a binary array where:\\n * 1- move right\\n * 0- move down\\n * <p>\\n * You need m-1 moves right and n-1 moves down\\n * <p>\\n * That means that you need to calculate the number of\\n * binary arrays of length: (m-1 + n-1) = m+n-2 with m-1 ones (1) and n-1 zeros (0). This you can calculate from the\\n * binomial coefficient { (m+n-2) C (m-1) }  // or { (m+n-2) C (n-1) }\\n */\\nclass UniquePathsIBinomialCoefficient {\\n\\n\\n    public int uniquePaths(int m, int n) {\\n\\n        if (m == 0 || n == 0)\\n            return 0;\\n        /**\\n         * m==1 ; if only horizontal strip is there; source (0,0) destination (0,n-1) and we can move right only\\n         * n==1 ; if only vertical strip is there; source (0,0) destination (m-1,0) and we can move down only\\n         */\\n        if (m == 1 || n == 1)\\n            return 1;\\n\\n\\n        return binomialCoefficient(m + n - 2, m - 1);\\n\\n    }\\n\\n    //C(n, k) = C(n-1, k-1) + C(n-1, k)\\n    //   C(n, 0) = C(n, n) = 1\\n    private int binomialCoefficient(int n, int k) {\\n\\n        int c[] = new int[k + 1];\\n\\n        c[0] = 1;\\n\\n        for (int i = 1; i <= n; i++)\\n            for (int j = Math.min(k, i); j >= 1; j--)\\n                c[j] = c[j] + c[j - 1];\\n\\n        return c[k];\\n    }\\n\\n}\\n```\\nUnique Path II : https://leetcode.com/problems/unique-paths-ii/discuss/374664/Simple-or-Easy-to-understand-or-Though-Processor-Explanation-or-4-Solutions-or-UniquePath-I-extension",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\n\\n/**\\n * We can solve this problem through backtracking.\\n * Backtracking\\n * 1. Our goal: To reach destination cell (m-1,n-1), once reach it counted as one path\\n * 2. Our constraints: a) We can not move outside of boundary b\\n * 3. Our choices: a) we can move either Down (i+1,j) or right (i, j+1) from any cell\\n * <p>\\n * Complexity:\\n * To reach a cell there are two way and we try all the source cell to reach this cell.\\n * Complexity: O((m*n)^2) /O (m*n)\\n * <p>\\n * TLE\\n */\\nclass UniquePathsIBacktracking {\\n\\n\\n    public int uniquePaths(int m, int n) {\\n\\n        if (m == 0 || n == 0)\\n            return 0;\\n\\n        /**\\n         * m==1 ; if only horizontal strip is there; source (0,0) destination (0,n-1) and we can move right only\\n         * n==1 ; if only vertical strip is there; source (0,0) destination (m-1,0) and we can move down only\\n         */\\n        if (m == 1 || n == 1)\\n            return 1;\\n\\n\\n        final boolean maze[][] = new boolean[m][n];\\n\\n        final int sx = 0, sy = 0;\\n        final int dx = m - 1, dy = n - 1;\\n\\n        return uniquePaths(maze, m, n, sx, sy, dx, dy);\\n\\n\\n    }\\n\\n    private int uniquePaths(boolean[][] maze, int m, int n, int sx, int sy, int dx, int dy) {\\n\\n        //1. Our goal: To reach destination cell (m-1,n-1), once reach it counted as one path\\n        if (sx == dx && sy == dy)\\n            return 1;\\n\\n        int path = 0;\\n        if (isSafe(sx, sy, m, n, maze)) {\\n            maze[sx][sy] = true;\\n\\n            path = uniquePaths(maze, m, n, sx + 1, sy, dx, dy)  //down\\n                    +\\n                    uniquePaths(maze, m, n, sx, sy + 1, dx, dy);//right\\n\\n            maze[sx][sy] = false;\\n        }\\n        return path;\\n    }\\n\\n    private boolean isSafe(int sx, int sy, int m, int n, boolean[][] maze) {\\n        if (sx >= m || sy >= n || sx < 0 || sy < 0 || maze[sx][sy])\\n            return false;\\n        return true;\\n    }\\n\\n\\n}\\n```\n```\\n\\n/**\\n * In above backtracking, we visit same cell[i][j] and try to reach destination[m-1][n-1].\\n * This happen again n again for different source cell [sx][sy] for this cell [i][j].\\n * <p>\\n * Since there are overlapping sub-problems, we can cache them; Hence DP\\n * <p>\\n * dp[i][j] = dp[i+1][j] + dp[i][j+1] ; [i,j] is in range of [m,n]\\n * *        = 0 [i,j] is Not in range of [m,n]\\n * base case:\\n * i==dx, j==dy => dp[i][j] = 1\\n * <p>\\n * dp[sx][sy] is output\\n * <p>\\n * <p>\\n * <p>\\n * Complexity : To reach a cell there are two way and we try them only once from the source cell to reach this cell.\\n * O(m*n) / O (m*n)\\n * <p>\\n * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths.\\n * Memory Usage: 33.2 MB, less than 5.10% of Java online submissions for Unique Paths.\\n */\\nclass UniquePathsIDPTopDown {\\n\\n\\n    public int uniquePaths(int m, int n) {\\n\\n        if (m == 0 || n == 0)\\n            return 0;\\n\\n        /**\\n         * m==1 ; if only horizontal strip is there; source (0,0) destination (0,n-1) and we can move right only\\n         * n==1 ; if only vertical strip is there; source (0,0) destination (m-1,0) and we can move down only\\n         */\\n        if (m == 1 || n == 1)\\n            return 1;\\n\\n\\n        final int maze[][] = new int[m][n];\\n        for (int i = 0; i < m; i++)\\n            Arrays.fill(maze[i], -1);\\n\\n        final int sx = 0, sy = 0;\\n        final int dx = m - 1, dy = n - 1;\\n\\n        return uniquePaths(maze, m, n, sx, sy, dx, dy);\\n\\n\\n    }\\n\\n    private int uniquePaths(int[][] maze, int m, int n, int sx, int sy, int dx, int dy) {\\n\\n        if (isSafe(sx, sy, m, n)) {\\n\\n            if (sx == dx && sy == dy)\\n                return maze[sx][sy] = 1;\\n\\n            if (maze[sx][sy] != -1)\\n                return maze[sx][sy];\\n\\n\\n            return maze[sx][sy] = uniquePaths(maze, m, n, sx + 1, sy, dx, dy)  //down\\n                    +\\n                    uniquePaths(maze, m, n, sx, sy + 1, dx, dy);//right\\n\\n        }\\n        return 0;\\n    }\\n\\n    private boolean isSafe(int sx, int sy, int m, int n) {\\n        if (sx >= m || sy >= n || sx < 0 || sy < 0)\\n            return false;\\n        return true;\\n    }\\n}\\n\\n```\n```\\n\\n/**\\n * * dp[i][j] = dp[i-1][j] + dp[i][j-1] ; [i,j] is in range of [m,n]\\n * * *        = 0 [i,j] is Not in range of [m,n]\\n * * base case:\\n * * i==0 or j==0 => dp[i][j] = 0\\n * * i==dx, j==dy => dp[i][j] = 1\\n * * <p>\\n * * dp[dx][dy] is output\\n * <p>\\n * * Complexity : To reach a cell there are two way and we try them only once from the source cell to reach this cell.\\n * * O(m*n) / O (m*n)\\n * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths.\\n * Memory Usage: 33.2 MB, less than 5.10% of Java online submissions for Unique Paths.\\n */\\nclass UniquePathsIDPBottomUp {\\n\\n\\n    public int uniquePaths(int m, int n) {\\n\\n        if (m == 0 || n == 0)\\n            return 0;\\n\\n\\n        final int dp[][] = new int[m + 1][n + 1];\\n\\n        for (int i = 0; i <= m; i++) {\\n\\n            for (int j = 0; j <= n; j++) {\\n\\n                if (i == 0 || j == 0)\\n                    dp[i][j] = 0;\\n\\n                /**\\n                 * m==1 ; if only horizontal strip is there; source (0,0) destination (0,n-1) and we can move right only\\n                 * n==1 ; if only vertical strip is there; source (0,0) destination (m-1,0) and we can move down only\\n                 */\\n                else if (i == 1 || j == 1)\\n                    dp[i][j] = 1;\\n\\n                else {\\n                    //would reach this cell by coming down from up dp[i - 1][j] or by coming right from left dp[i][j - 1]\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n\\n            }\\n        }\\n        return dp[m][n];\\n\\n\\n    }\\n\\n\\n}\\n```\n```\\n\\n/**\\n * * dp[i][j] = dp[i-1][j] + dp[i][j-1] ; [i,j] is in range of [m,n]\\n * * *        = 0 [i,j] is Not in range of [m,n]\\n * * base case:\\n * * i==0 or j==0 => dp[i][j] = 0\\n * * i==dx, j==dy => dp[i][j] = 1\\n * * <p>\\n * * dp[dx][dy] is output\\n * <p>\\n * We can see we are using only two rows at a time. We can optimize the space\\n * dp[i-1][j] => dp[j] old\\n * dp[i][j-1] => dp[j-1] old\\n * <p>\\n * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths.\\n * Memory Usage: 32.9 MB, less than 5.10% of Java online submissions for Unique Paths.\\n */\\nclass UniquePathsIDPBottomUpSpaceOptimize {\\n\\n\\n    public int uniquePaths(int m, int n) {\\n\\n        if (m == 0 || n == 0)\\n            return 0;\\n\\n\\n        final int dp[] = new int[n + 1];\\n\\n        for (int i = 0; i <= m; i++) {\\n\\n            for (int j = 0; j <= n; j++) {\\n\\n                if (i == 0 || j == 0)\\n                    dp[j] = 0;\\n\\n                /**\\n                 * m==1 ; if only horizontal strip is there; source (0,0) destination (0,n-1) and we can move right only\\n                 * n==1 ; if only vertical strip is there; source (0,0) destination (m-1,0) and we can move down only\\n                 */\\n                else if (i == 1 || j == 1)\\n                    dp[j] = 1;\\n\\n                else {\\n                    //would reach this cell by coming down from up dp[i - 1][j] or by coming right from left dp[i][j - 1]\\n                    dp[j] = dp[j] + dp[j - 1];\\n                }\\n\\n            }\\n        }\\n        return dp[n];\\n\\n\\n    }\\n\\n\\n    public int uniquePathsReverse(int m, int n) {\\n        int[] res = new int[m + 1]; // for this problem we can reduce the m*n matrix to an array\\n\\n        Arrays.fill(res, 1);\\n\\n        for (int nIdx = n - 1; nIdx >= 1; nIdx--) {\\n            for (int mIdx = m - 1; mIdx >= 1; mIdx--) {\\n                res[mIdx] = res[mIdx] + res[mIdx + 1];\\n            }\\n        }\\n\\n        return res[1];\\n    }\\n\\n}\\n\\n```\n```\\n/**\\n * https://www.geeksforgeeks.org/binomial-coefficient-dp-9/\\n * Basically imagine that you have a binary array where:\\n * 1- move right\\n * 0- move down\\n * <p>\\n * You need m-1 moves right and n-1 moves down\\n * <p>\\n * That means that you need to calculate the number of\\n * binary arrays of length: (m-1 + n-1) = m+n-2 with m-1 ones (1) and n-1 zeros (0). This you can calculate from the\\n * binomial coefficient { (m+n-2) C (m-1) }  // or { (m+n-2) C (n-1) }\\n */\\nclass UniquePathsIBinomialCoefficient {\\n\\n\\n    public int uniquePaths(int m, int n) {\\n\\n        if (m == 0 || n == 0)\\n            return 0;\\n        /**\\n         * m==1 ; if only horizontal strip is there; source (0,0) destination (0,n-1) and we can move right only\\n         * n==1 ; if only vertical strip is there; source (0,0) destination (m-1,0) and we can move down only\\n         */\\n        if (m == 1 || n == 1)\\n            return 1;\\n\\n\\n        return binomialCoefficient(m + n - 2, m - 1);\\n\\n    }\\n\\n    //C(n, k) = C(n-1, k-1) + C(n-1, k)\\n    //   C(n, 0) = C(n, n) = 1\\n    private int binomialCoefficient(int n, int k) {\\n\\n        int c[] = new int[k + 1];\\n\\n        c[0] = 1;\\n\\n        for (int i = 1; i <= n; i++)\\n            for (int j = Math.min(k, i); j >= 1; j--)\\n                c[j] = c[j] + c[j - 1];\\n\\n        return c[k];\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197557,
                "title": "java-and-python-backtrack-and-dp-solutions-with-descriptions",
                "content": "Methods:\\n1) Using backtrack, we can literally traverse through all the possible paths. It sounds bruteforce and yeah it is brute force with asymptotic time being ```O(2^(m+n))```, because always gotta move m times bottom and n times right. But it works, just takes long time and it TLE on leetcode, it spits out same answer as the latter DP method given enough time.. I\\'ve included the code. Backtrack works by searching through all the possible state space tree, illustrated below.\\n![image](https://assets.leetcode.com/users/tedcoder/image_1543101243.png)\\n2) We can use dynamic programming to optimize this problem from method 1). If we think about what backtracking algorithm is doing, it is traversing through the same paths multiple times, so subproblems overlap and we can use DP.\\n\\t1) Subproblems: Smaller grid size of (i,j), there are O(m*n) subproblems\\n\\t2) Guess: # of paths just before the final move.\\n\\t3) Recurrence: Suppose ```DP[i,j]``` is the num paths for sub matrix of i x j where i <= m and j <= n. Then the recurrence relationship is given by ```DP[i,j] = DP[i-1,j] + DP[i,j-1]```. This is derived from illustrations such as below:\\n![image](https://assets.leetcode.com/users/tedcoder/image_1543101488.png)\\nWe simply add up paths just before the ending. The ending move is finished just above or to the left in this question, indicated by red diamonds.\\n\\t4) Using the recurrence, we can construct a bottom-up algorithm with base case ```DP[i,0] = 1 and DP[0,j] = 1```, which correspond to just thin singular paths. ```Time/subproblem = O(1)```, so ```total time is O(m*n) * O(1) = O(m*n)``` with ```space complexity of O(m*n)```.\\n\\t5) Solves original problem ? Yes, because ```DP[m-1,n-1]``` will give you the answer.\\n3) We can further optimize the DP solution by realizing that we dont need O(m*n) space, we just need like two rows of DP data at a time, since we are propagating diagonally (top left to bot right direction). So if we want, we can reduce space to O(n).\\n\\nHere are my code:\\nJava (backtrack, TLE solution):\\n```\\nclass Solution {\\n    private int paths = 0;\\n    public int uniquePaths(int m, int n) {\\n        backtrack(m,n,0,0);\\n        return paths;\\n    }\\n    \\n    public void backtrack(int m, int n, int i, int j){\\n        if(i >= m) return;\\n        if(j >= n) return;\\n        if(i == m-1 && j== n-1){\\n            paths++;\\n            return;\\n        }\\n        \\n        backtrack(m,n,i+1,j);\\n        backtrack(m,n,i,j+1);\\n    }\\n}\\n```\\n\\nPython (DP solution):\\n```\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        #construct a DP matrix\\n        DP = [0]*(m)\\n        for i in range(0,m):\\n            DP[i] = [0]*(n)\\n        # set base cases\\n        DP[0][0] = 1\\n        for i in range(1,m):\\n            DP[i][0] = 1\\n        for j in range(1,n):\\n            DP[0][j] = 1\\n        \\n        #bottom up approach\\n        for i in range(1, m):\\n            for j in range(1,n):\\n                DP[i][j] = DP[i-1][j] + DP[i][j-1]\\n                \\n        return DP[m-1][n-1]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```O(2^(m+n))```\n```DP[i,j]```\n```DP[i,j] = DP[i-1,j] + DP[i,j-1]```\n```DP[i,0] = 1 and DP[0,j] = 1```\n```Time/subproblem = O(1)```\n```total time is O(m*n) * O(1) = O(m*n)```\n```space complexity of O(m*n)```\n```DP[m-1,n-1]```\n```\\nclass Solution {\\n    private int paths = 0;\\n    public int uniquePaths(int m, int n) {\\n        backtrack(m,n,0,0);\\n        return paths;\\n    }\\n    \\n    public void backtrack(int m, int n, int i, int j){\\n        if(i >= m) return;\\n        if(j >= n) return;\\n        if(i == m-1 && j== n-1){\\n            paths++;\\n            return;\\n        }\\n        \\n        backtrack(m,n,i+1,j);\\n        backtrack(m,n,i,j+1);\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        #construct a DP matrix\\n        DP = [0]*(m)\\n        for i in range(0,m):\\n            DP[i] = [0]*(n)\\n        # set base cases\\n        DP[0][0] = 1\\n        for i in range(1,m):\\n            DP[i][0] = 1\\n        for j in range(1,n):\\n            DP[0][j] = 1\\n        \\n        #bottom up approach\\n        for i in range(1, m):\\n            for j in range(1,n):\\n                DP[i][j] = DP[i-1][j] + DP[i][j-1]\\n                \\n        return DP[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 130628,
                "title": "java-solution-beats-87-but-will-explanation-and-the-approach-to-this-problem",
                "content": "First thing first -- you should first try to solve it recursively. The reason is that the recursion clearly demonstrates what the problem is. The approach should be to come up with a recursive equation and then use that to solve it first. The optimization using DP should come later. \\nSo, to solve using recursion, the question is: how many ways one could reach to the last cell (with the finish)? It is the sum of number of ways you could reach to the cell above, and the cell to the left. Putting it into an equation, here it is :\\n`T(m)(n) = T(m-1)(n) + T(m)(n-1).`\\n\\nSo the recursive solution will be:\\n\\n```\\n    public int uniquePaths_rec(int m, int n) {\\n        if (m <=0 || n<=0) {\\n           return 0;\\n        } else if (m == 1 && n ==1) {\\n            return 1;\\n        }\\n        return uniquePaths(m-1,n) + uniquePaths(m,n-1);\\n    }\\n```\\nThe first condition takes care of index going out of scope and when you reach to the first cell, it completes one path. Rest is merely recursive call.\\n\\nHowever, the time complexity of this approach tends to be exponential since it will calculate every path again and again. The better way is to use Dynamic Programming keeping the same recursion in our mind. We could simulate it with a 2-D array that uses n * m size and our size lies at the arr [n-1 ][m-1] index. Also, remember that for all values of m, arr[0][m] will be 1 since there is only 1 way to go on the right side. Likewise, for all values of n, arr[n][0] will be 1 since there is only 1 way to go down. With that in the mind, here is the code:\\n\\n```\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[n][m];\\n        Arrays.fill(dp[0],1);\\n        for (int i = 0;i<n;i++) {\\n            dp[i][0] = 1;\\n        }\\n        \\n        for (int i=1;i<n ; i++) {\\n            for (int j=1;j<m;j++) {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }  \\n        \\n        return dp[n-1][m-1];        \\n    }\\n```\\n\\nSome examples of run:\\n\\n```\\nYour input\\nm=3,n=3\\n\\nInitialized DP array\\n[1, 1, 1]\\n[1, 0, 0]\\n[1, 0, 0]\\n\\nFinal DP array\\n[1, 1, 1]\\n[1, 2, 3]\\n[1, 3, 6]\\n\\nYour input\\nm=7,n=3\\n\\nInitialized DP array\\n[1, 1, 1, 1, 1, 1, 1]\\n[1, 0, 0, 0, 0, 0, 0]\\n[1, 0, 0, 0, 0, 0, 0]\\n\\nFinal DP array\\n[1, 1, 1, 1, 1, 1, 1]\\n[1, 2, 3, 4, 5, 6, 7]\\n[1, 3, 6, 10, 15, 21, 28]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    public int uniquePaths_rec(int m, int n) {\\n        if (m <=0 || n<=0) {\\n           return 0;\\n        } else if (m == 1 && n ==1) {\\n            return 1;\\n        }\\n        return uniquePaths(m-1,n) + uniquePaths(m,n-1);\\n    }\\n```\n```\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[n][m];\\n        Arrays.fill(dp[0],1);\\n        for (int i = 0;i<n;i++) {\\n            dp[i][0] = 1;\\n        }\\n        \\n        for (int i=1;i<n ; i++) {\\n            for (int j=1;j<m;j++) {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }  \\n        \\n        return dp[n-1][m-1];        \\n    }\\n```\n```\\nYour input\\nm=3,n=3\\n\\nInitialized DP array\\n[1, 1, 1]\\n[1, 0, 0]\\n[1, 0, 0]\\n\\nFinal DP array\\n[1, 1, 1]\\n[1, 2, 3]\\n[1, 3, 6]\\n\\nYour input\\nm=7,n=3\\n\\nInitialized DP array\\n[1, 1, 1, 1, 1, 1, 1]\\n[1, 0, 0, 0, 0, 0, 0]\\n[1, 0, 0, 0, 0, 0, 0]\\n\\nFinal DP array\\n[1, 1, 1, 1, 1, 1, 1]\\n[1, 2, 3, 4, 5, 6, 7]\\n[1, 3, 6, 10, 15, 21, 28]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996228,
                "title": "c-0ms-fastest-easy-to-understand",
                "content": "# C++ | 0ms | Fastest | Easy to Understand\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 1));\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n            }\\n        }\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 1));\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n            }\\n        }\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555153,
                "title": "easy-to-understand-o-m-n-c",
                "content": "# Intuition\\nThe count of distinct routes to navigate to a given cell will be equivalent to the summation of the paths leading to the cell immediately to the left of the current cell and the paths leading to the cell directly above the current cell. \\n\\n# Approach\\nThe number of unique paths when traversing only along a row or column is 1.\\n\\nA matrix of size m*n is initialized with all elements assigned the value 1. Each row and column is sequentially traversed, commencing from index 1. The count of unique paths at any given point is determined by summing the values of dp[i-1][j] and dp[i][j-1], denoting the number of paths leading to the cell directly to the left and above the current cell, respectively. Finally, the value in the last cell, representing the target position, is returned.\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n\\n- Space complexity: $$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n)\\n    {\\n        vector<vector<int> > dp(m,vector<int> (n,1));\\n\\n        for(int i = 1;i<m;i++)\\n        {\\n            for(int j = 1;j<n;j++)\\n            {  \\n                dp[i][j] = dp[i][j-1] + dp[i-1][j];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n)\\n    {\\n        vector<vector<int> > dp(m,vector<int> (n,1));\\n\\n        for(int i = 1;i<m;i++)\\n        {\\n            for(int j = 1;j<n;j++)\\n            {  \\n                dp[i][j] = dp[i][j-1] + dp[i-1][j];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386573,
                "title": "c-easy-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        swap(n,m);\\n        int t=0;\\n        vector<vector<int>>dp(n,vector<int>(m,1));\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        swap(n,m);\\n        int t=0;\\n        vector<vector<int>>dp(n,vector<int>(m,1));\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233752,
                "title": "fastest-solution-using-combinations-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter observing similarities of pattern in each example we can conclude that we are taking  m + n - 2 number of steps every time.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can conclude by our observation that total number of steps in  each observation is m + 1 or n - 1 so calculate combinations (m + n - 2)C (n - 1) or (m + n - 2)C(m - 1) steps. We can linearly iterate over the given matrix and can compute the value of above derived relation.\\n\\nFor more clarity : https://www.youtube.com/watch?v=t_f0nwwdg5o&list=PLgUwDviBIf0p4ozDR_kJJkONnb1wdx2Ma&index=4 \\nWatch strivers placement series lecture number 3\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(m - 1) or O(n - 1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    int uniquePaths(int m, int n) {\\n        int k = n + m - 2;\\n        int r = m - 1;\\n        double res = 1;\\n        for(int i = 1; i <= r; i++){\\n            res = res * (k - r + i) / i;\\n        }\\n        return (int)res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int uniquePaths(int m, int n) {\\n        int k = n + m - 2;\\n        int r = m - 1;\\n        double res = 1;\\n        for(int i = 1; i <= r; i++){\\n            res = res * (k - r + i) / i;\\n        }\\n        return (int)res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745303,
                "title": "100-faster-solution-2d-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n         vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        \\n        dp[0][0]=0;\\n        dp[0][1]=1;\\n        \\n        for(int i = 1 ; i <= m ; ++i)\\n            for(int j = 1 ; j <= n ; ++j)\\n                    dp[i][j] = dp[i-1][j]+dp[i][j-1];\\n        return dp[m][n];   \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n         vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        \\n        dp[0][0]=0;\\n        dp[0][1]=1;\\n        \\n        for(int i = 1 ; i <= m ; ++i)\\n            for(int j = 1 ; j <= n ; ++j)\\n                    dp[i][j] = dp[i-1][j]+dp[i][j-1];\\n        return dp[m][n];   \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345223,
                "title": "very-easy-0-ms-100-fully-explained-c-java-python-js-c-python3",
                "content": "# **C++ Solution (DP Approach):**\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        // create a 2D array to store results of sub-problems...\\n        int paths[m][n];\\n        // To reach any cell in first column is 1...\\n        for (int i = 0; i < m; i++)\\n            paths[i][0] = 1;\\n        // To reach any cell in first row is 1...\\n        for (int j = 0; j < n; j++)\\n            paths[0][j] = 1;\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++)\\n                paths[i][j] = paths[i - 1][j] + paths[i][j - 1];\\n        }\\n        return paths[m - 1][n - 1];   // Return the result...\\n    }\\n};\\n```\\n\\n# **Java Solution (DP Approach):**\\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        if(m==0 || n==0) return 0;\\n        if(m==1 || n==1) return 1;\\n        int way[][] = new int [m][n];\\n\\t    for(int i = 0; i<m; i++){\\n\\t\\t    for(int j = 0; j<n; j++){\\n\\t\\t\\t    if(i==0 || j==0)\\n                    way[i][j] = 1;\\n\\t\\t\\t    else\\n                    way[i][j] = way[i-1][j] + way[i][j-1];\\n\\t\\t    }\\n\\t    }\\n\\t    return way[m-1][n-1];\\n    }\\n}\\n```\\n\\n# **Python Solution (DP Approach):**\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        paths = [[1] * n for _ in range(m)]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                paths[i][j] = paths[i - 1][j] + paths[i][j - 1]\\n        return paths[-1][-1]\\n```\\n        \\n# **JavaScript Solution (Combinatorics approach):**\\n```\\nvar uniquePaths = function(m, n) {\\n    let way = 1;\\n    for(let i = n; i < m + n - 1; i++){\\n        way *= i;\\n        way /= (i - n + 1);\\n    }\\n    return way;\\n};\\n```\\n\\n# **C Language (DP Approach):**\\n```\\nint uniquePaths(int m, int n){\\n    // create a 2D array to store results of sub-problems...\\n    int paths[m][n];\\n    // To reach any cell in first column is 1...\\n    for (int i = 0; i < m; i++)\\n        paths[i][0] = 1;\\n    // To reach any cell in first row is 1...\\n    for (int j = 0; j < n; j++)\\n        paths[0][j] = 1;\\n    for (int i = 1; i < m; i++) {\\n        for (int j = 1; j < n; j++)\\n            paths[i][j] = paths[i - 1][j] + paths[i][j - 1];\\n    }\\n    return paths[m - 1][n - 1];   // Return the result...\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        total = m + n -2\\n        any = min(m, n) - 1\\n        paths = 1\\n        for i in range(any):\\n            paths = paths * total / (i+1)\\n            total -= 1\\n        return int(paths)\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        // create a 2D array to store results of sub-problems...\\n        int paths[m][n];\\n        // To reach any cell in first column is 1...\\n        for (int i = 0; i < m; i++)\\n            paths[i][0] = 1;\\n        // To reach any cell in first row is 1...\\n        for (int j = 0; j < n; j++)\\n            paths[0][j] = 1;\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++)\\n                paths[i][j] = paths[i - 1][j] + paths[i][j - 1];\\n        }\\n        return paths[m - 1][n - 1];   // Return the result...\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        if(m==0 || n==0) return 0;\\n        if(m==1 || n==1) return 1;\\n        int way[][] = new int [m][n];\\n\\t    for(int i = 0; i<m; i++){\\n\\t\\t    for(int j = 0; j<n; j++){\\n\\t\\t\\t    if(i==0 || j==0)\\n                    way[i][j] = 1;\\n\\t\\t\\t    else\\n                    way[i][j] = way[i-1][j] + way[i][j-1];\\n\\t\\t    }\\n\\t    }\\n\\t    return way[m-1][n-1];\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        paths = [[1] * n for _ in range(m)]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                paths[i][j] = paths[i - 1][j] + paths[i][j - 1]\\n        return paths[-1][-1]\\n```\n```\\nvar uniquePaths = function(m, n) {\\n    let way = 1;\\n    for(let i = n; i < m + n - 1; i++){\\n        way *= i;\\n        way /= (i - n + 1);\\n    }\\n    return way;\\n};\\n```\n```\\nint uniquePaths(int m, int n){\\n    // create a 2D array to store results of sub-problems...\\n    int paths[m][n];\\n    // To reach any cell in first column is 1...\\n    for (int i = 0; i < m; i++)\\n        paths[i][0] = 1;\\n    // To reach any cell in first row is 1...\\n    for (int j = 0; j < n; j++)\\n        paths[0][j] = 1;\\n    for (int i = 1; i < m; i++) {\\n        for (int j = 1; j < n; j++)\\n            paths[i][j] = paths[i - 1][j] + paths[i][j - 1];\\n    }\\n    return paths[m - 1][n - 1];   // Return the result...\\n}\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        total = m + n -2\\n        any = min(m, n) - 1\\n        paths = 1\\n        for i in range(any):\\n            paths = paths * total / (i+1)\\n            total -= 1\\n        return int(paths)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330657,
                "title": "python-1line-answer-ultra-simple-answer-faster-than-95",
                "content": "The Code and logic is given below\\n\\n```\\nimport math\\n\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        return math.comb(m-1+n-1,n-1)\\n```\\n\\nThink robot has to go from (0,0) to (m,n) ... which means it has to move (m-1) times down \\nand (n-1) time right\\nSo,\\ntotal move = (m-1)+(n-1)\\ndown move = (m-1) \\nright move = (n-1)\\n\\nNow the question narrow down to arrange (m-1) D ( D means down)  and (n-1) R (R means right)\\nso answer is => (m-1)C(n-1)\\n\\nExample if (0,0) to (3,2)\\nthen i know i need to arrange 2 D and 1 L\\nSo possible arrangements are:-\\nDDL\\nDLD\\nLDD\\ntotal 3 arrangement\\nSo answer is 3C2 multiple by 1C1 (posssible way of chossing 2 position for D out of 3 and chossing 1 position of L out of 1 position\\n\\nor 3C1 multiple by 2C2 (posssible way of chossing 1 position for L out of 3 and chossing 2 position of D out of 2 position)\\n\\n\\nPlease Vote Up if you find it usefull.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport math\\n\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        return math.comb(m-1+n-1,n-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195092,
                "title": "no-dp-100-faster-by-maths-4-line-code-o-n-time-complexity-o-1-auxiliary-space-explained",
                "content": "![image](https://assets.leetcode.com/users/images/4e7e809d-b461-4ac8-bf9d-67c22478e4fc_1656157107.7047405.jpeg)\\n\\nGeneral formula :- m-1+i/i\\nThink this like you have 5 cards(Here m+n) and you have to choose 2 cards(Here m or n) ,so total combinations are 5C2.\\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        double res = 1;\\n        \\n        for (int i = 1; i <= n-1; i++) {\\n            res = res * (m-1+i) / i;\\n        }\\n        return (int)res;\\n    }\\n}\\n```\\nTime Complexity: O(n)\\nAuxiliary Space: O(1)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        double res = 1;\\n        \\n        for (int i = 1; i <= n-1; i++) {\\n            res = res * (m-1+i) / i;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318140,
                "title": "c-tle-recursive-ac-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int path(int m, int n, int a, int b)\\n    {\\n        if (a < 0 || a > m || b < 0 || b > n) {\\n            return 0;\\n        }    \\n        if (a == m-1 && b == n-1) {\\n            return 1;\\n        }\\n        return path(m, n, a+1, b) + path(m, n, a, b+1);\\n    }\\n    \\n    int uniquePaths(int m, int n) \\n    {\\n        int totalPaths = path(m, n, 0, 0);\\n        return totalPaths;\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int path(int m, int n, int a, int b, vector<vector<int>> &dp)\\n    {\\n        if (a < 0 || a > m || b < 0 || b > n) {\\n            return 0;\\n        }\\n        if (dp[a][b] != -1) {\\n            return dp[a][b];\\n        }\\n        if (a == m-1 && b == n-1) {\\n            dp[a][b] = 1;\\n        }\\n        else {\\n            dp[a][b] = path(m, n, a+1, b, dp) + path(m, n, a, b+1, dp);\\n        } \\n        return dp[a][b];\\n    }\\n    \\n    int uniquePaths(int m, int n) \\n    {\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, -1));\\n        int totalPaths = path(m, n, 0, 0, dp);\\n        return totalPaths;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int path(int m, int n, int a, int b)\\n    {\\n        if (a < 0 || a > m || b < 0 || b > n) {\\n            return 0;\\n        }    \\n        if (a == m-1 && b == n-1) {\\n            return 1;\\n        }\\n        return path(m, n, a+1, b) + path(m, n, a, b+1);\\n    }\\n    \\n    int uniquePaths(int m, int n) \\n    {\\n        int totalPaths = path(m, n, 0, 0);\\n        return totalPaths;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int path(int m, int n, int a, int b, vector<vector<int>> &dp)\\n    {\\n        if (a < 0 || a > m || b < 0 || b > n) {\\n            return 0;\\n        }\\n        if (dp[a][b] != -1) {\\n            return dp[a][b];\\n        }\\n        if (a == m-1 && b == n-1) {\\n            dp[a][b] = 1;\\n        }\\n        else {\\n            dp[a][b] = path(m, n, a+1, b, dp) + path(m, n, a, b+1, dp);\\n        } \\n        return dp[a][b];\\n    }\\n    \\n    int uniquePaths(int m, int n) \\n    {\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, -1));\\n        int totalPaths = path(m, n, 0, 0, dp);\\n        return totalPaths;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 804052,
                "title": "python-easy-simple-dp-solution-time-o-m-n",
                "content": "```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[1] * n for i in range(m)]        # DP Matrix of size m*n intialized to 1\\n\\n        for r in range(1, m):\\n            for c in range(1, n):\\n                dp[r][c] = dp[r - 1][c] + dp[r][c - 1]\\n\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[1] * n for i in range(m)]        # DP Matrix of size m*n intialized to 1\\n\\n        for r in range(1, m):\\n            for c in range(1, n):\\n                dp[r][c] = dp[r - 1][c] + dp[r][c - 1]\\n\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395453,
                "title": "kotlin-solution-beats-100-mem-runtime",
                "content": "Here it\\'s\\n\\n```\\nclass Solution {\\n    \\n    fun uniquePaths(m: Int, n: Int): Int {\\n        \\n        var line = IntArray(n){1}\\n\\n        for(i in 1 until m){\\n            for(j in 1 until n){\\n                line[j] += line[j-1]\\n            }\\n        }\\n\\n        return line[n-1]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    fun uniquePaths(m: Int, n: Int): Int {\\n        \\n        var line = IntArray(n){1}\\n\\n        for(i in 1 until m){\\n            for(j in 1 until n){\\n                line[j] += line[j-1]\\n            }\\n        }\\n\\n        return line[n-1]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23159,
                "title": "java-different-solutions-math-dp-o-m-n-o-n-space",
                "content": "    import static java.lang.Math.toIntExact;\\n    public class Solution {\\n    // math \\n    public int uniquePaths1(int m, int n) {\\n        m--; n--;\\n        long ret=1;\\n        for (int i=1; i<=Math.min(m, n); i++) {\\n            ret = ret * (m+n+1-i)/i; //take care here \\n        }\\n        return toIntExact(ret);\\n    }   \\n    \\n    // O(n*m) space, dp\\n    public int uniquePaths2(int m, int n) {\\n        int dp[][] = new int[m][n];\\n        for (int i=0; i<m; i++)\\n            dp[i][0] = 1;\\n        for (int j=0; j<n; j++)\\n            dp[0][j] = 1;\\n        for (int i=1; i<m; i++) \\n            for (int j=1; j<n; j++) \\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n        return dp[m-1][n-1];\\n    }\\n    \\n    // O(n) space, dp\\n    public int uniquePaths(int m, int n) {\\n        int []dp = new int[n];\\n        for (int j=0; j<n; j++)\\n            dp[j] = 1;\\n        for (int i=1; i<m; i++) \\n            for (int j=1; j<n; j++)\\n                dp[j] += dp[j-1];\\n         return dp[n-1];       \\n    }\\n    }",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    // math \\n    public int uniquePaths1(int m, int n) {\\n        m--; n--;\\n        long ret=1;\\n        for (int i=1; i<=Math.min(m, n); i++) {\\n            ret = ret * (m+n+1-i)/i; //take care here \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3995388,
                "title": "4-different-approaches-dp",
                "content": "# 1. Recursive Approach-------->Top to Down\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        def solve(ind1,ind2):\\n            if ind1==0 and ind2==0:\\n                return 1\\n            if ind1<0  or ind2<0:\\n                return 0\\n            return solve(ind1-1,ind2)+solve(ind1,ind2-1)\\n        return solve(m-1,n-1)\\n ```\\n # 2. Memorization Approach\\n ```\\n class Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp=[[-1]*(n+1) for i in range(m)]\\n        def solve(ind1,ind2):\\n            if ind1==0 and ind2==0:\\n                return 1\\n            if ind1<0 or ind2<0:\\n                return 0\\n            if dp[ind1][ind2]!=-1:\\n                return dp[ind1][ind2]\\n            left=solve(ind1,ind2-1)\\n            up=solve(ind1-1,ind2)\\n            dp[ind1][ind2]=up+left\\n            return left+up\\n        return solve(m-1,n-1)\\n```\\n# 3. Tabulation------>Bottom to Up Approach\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp=[[0]*(n+1) for i in range(m+1)]\\n        for ind1 in range(1,m+1):\\n            for ind2 in range(1,n+1):\\n                if ind1==ind2==1:\\n                    dp[ind1][ind2]=1\\n                else:\\n                    left=up=0\\n                    if ind2-1>=0:\\n                        left=dp[ind1][ind2-1]\\n                    if ind1-1>=0:\\n                        up=dp[ind1-1][ind2]\\n                    dp[ind1][ind2]=up+left\\n        return dp[-1][-1]\\n```\\n# 4. Space Optimization\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        prev=[0]*(n+1)\\n        for ind1 in range(1,m+1):\\n            cur=[0]*(n+1)\\n            for ind2 in range(1,n+1):\\n                if ind1==ind2==1:\\n                    cur[ind2]=1\\n                else:\\n                    left=up=0\\n                    if ind2-1>=0:\\n                        left=cur[ind2-1]\\n                    if ind1-1>=0:\\n                        up=prev[ind2]\\n                    cur[ind2]=up+left\\n            prev=cur\\n        return cur[-1]\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        def solve(ind1,ind2):\\n            if ind1==0 and ind2==0:\\n                return 1\\n            if ind1<0  or ind2<0:\\n                return 0\\n            return solve(ind1-1,ind2)+solve(ind1,ind2-1)\\n        return solve(m-1,n-1)\\n ```\n```\\n class Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp=[[-1]*(n+1) for i in range(m)]\\n        def solve(ind1,ind2):\\n            if ind1==0 and ind2==0:\\n                return 1\\n            if ind1<0 or ind2<0:\\n                return 0\\n            if dp[ind1][ind2]!=-1:\\n                return dp[ind1][ind2]\\n            left=solve(ind1,ind2-1)\\n            up=solve(ind1-1,ind2)\\n            dp[ind1][ind2]=up+left\\n            return left+up\\n        return solve(m-1,n-1)\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp=[[0]*(n+1) for i in range(m+1)]\\n        for ind1 in range(1,m+1):\\n            for ind2 in range(1,n+1):\\n                if ind1==ind2==1:\\n                    dp[ind1][ind2]=1\\n                else:\\n                    left=up=0\\n                    if ind2-1>=0:\\n                        left=dp[ind1][ind2-1]\\n                    if ind1-1>=0:\\n                        up=dp[ind1-1][ind2]\\n                    dp[ind1][ind2]=up+left\\n        return dp[-1][-1]\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        prev=[0]*(n+1)\\n        for ind1 in range(1,m+1):\\n            cur=[0]*(n+1)\\n            for ind2 in range(1,n+1):\\n                if ind1==ind2==1:\\n                    cur[ind2]=1\\n                else:\\n                    left=up=0\\n                    if ind2-1>=0:\\n                        left=cur[ind2-1]\\n                    if ind1-1>=0:\\n                        up=prev[ind2]\\n                    cur[ind2]=up+left\\n            prev=cur\\n        return cur[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897175,
                "title": "beats-100-user-solution",
                "content": "# **PLS UPVOTE IF YOU LIKE MY SOLUTION AND COMMENT FOR ANY SUPPORT**\\n# SPACE OPTIMIZED SOLUTION\\n# Approach\\nInitialize two vectors, prevRow and currRow, both of size n. The initial values for these vectors are all set to 1. This is because there\\'s only one way to reach any cell in the first row or column.\\n\\nIterate through the rows from the second row (index 1) to the last row (index m - 1):\\n\\na. In each iteration of the outer loop, iterate through the columns from the second column (index 1) to the last column (index n - 1).\\n\\nb. For each cell, update the value in currRow[j] using the dynamic programming formula: currRow[j] = currRow[j - 1] + prevRow[j]. This calculates the number of unique paths to the current cell based on the values from the left cell (currRow[j - 1]) and the cell above (prevRow[j]).\\n\\nAfter updating all cells in currRow, swap the contents of currRow and prevRow. This is done so that in the next iteration, prevRow holds the values of the previous row, and you can update currRow with the new values.\\n\\nAfter completing the loop, the value at prevRow[n - 1] represents the number of unique paths to the last cell of the grid (bottom-right corner). Return this value as the final result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> prevRow(n, 1);\\n        vector<int> currRow(n, 1);\\n        \\n        for (int i = 1; i < m; ++i) {\\n            for (int j = 1; j < n; ++j) {\\n                currRow[j] = currRow[j - 1] + prevRow[j];\\n            }\\n            swap(currRow, prevRow); \\n        }\\n        return prevRow[n - 1];\\n    }\\n};\\n\\n```\\n# MEMOIZATION\\n# Approach\\nThe function path is a recursive function that calculates the number of unique paths from a given cell (i, j) to the destination cell (m-1, n-1) in the grid.\\n\\nThe base cases are handled first:\\n\\nIf the current cell (i, j) is the destination cell (m-1, n-1), there is only one way to reach the destination, so the function returns 1.\\nIf i is greater than or equal to m or j is greater than or equal to n, it means the current cell is out of bounds, so the function returns 0.\\nThe memoization check is done by looking at the value of dp[i][j]. If it\\'s not equal to -1, it means the result for this cell has already been computed, so the function directly returns dp[i][j].\\n\\nIf the result for the current cell (i, j) is not available in the dp array, the function calculates the number of unique paths by recursively calculating the number of paths moving down (i+1, j) and moving right (i, j+1). These values are stored in the down and right variables, respectively.\\n\\nThe result for the current cell (i, j) is then calculated as the sum of the paths moving down and moving right: dp[i][j] = down + right.\\n\\nFinally, the result dp[i][j] is returned.\\n\\nThe uniquePaths function initializes the dp array with -1 values. Then, it calls the path function with the starting cell (0, 0) and the dp array.\\n\\nThe path function calculates and returns the total number of unique paths from the starting cell to the destination cell.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint path(int m, int n, int i ,int j,vector<vector<int>>&dp)\\n{\\n    if(i==m-1 && j==n-1)return 1;\\n    if(i>=m || j>=n)return 0;\\n    if(dp[i][j]!=-1)\\n    return dp[i][j];\\n\\n    int down=path(m,n,i+1,j,dp);\\n    int right=path(m,n,i,j+1,dp);\\n    dp[i][j]=down+right;\\n    return dp[i][j];\\n\\n}\\n    int uniquePaths(int m, int n){\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        return path(m,n,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> prevRow(n, 1);\\n        vector<int> currRow(n, 1);\\n        \\n        for (int i = 1; i < m; ++i) {\\n            for (int j = 1; j < n; ++j) {\\n                currRow[j] = currRow[j - 1] + prevRow[j];\\n            }\\n            swap(currRow, prevRow); \\n        }\\n        return prevRow[n - 1];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\nint path(int m, int n, int i ,int j,vector<vector<int>>&dp)\\n{\\n    if(i==m-1 && j==n-1)return 1;\\n    if(i>=m || j>=n)return 0;\\n    if(dp[i][j]!=-1)\\n    return dp[i][j];\\n\\n    int down=path(m,n,i+1,j,dp);\\n    int right=path(m,n,i,j+1,dp);\\n    dp[i][j]=down+right;\\n    return dp[i][j];\\n\\n}\\n    int uniquePaths(int m, int n){\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        return path(m,n,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735932,
                "title": "simple-math-easy-to-understand",
                "content": "# Simple Math\\n```\\n    int combination(int n,int r){\\n        double ans=1,N=n;\\n        for(double i=1;i<=r;i++){\\n            ans*=(N-(i-1));\\n            ans/=i;\\n        }\\n        return ans;\\n    }\\n    int uniquePaths(int m, int n) {\\n        //Combinatrial solution \\n\\n        /*  \\n        Total_right_step_to_take = n-1    \\n        Total_down_step_to_take = m-1\\n        Total step = n-1+m-1 = m+n-2\\n        We want to choose m-1 down path from this total paths which is (m+n-2)C(m-1)\\n        which will also be equal to (m+n-2)C(n-1)\\n        Answer = (m+n-2)C(m-1) or (m+n-2)C(n-1)\\n        */\\n\\n        return combination(m+n-2,min(n-1,m-1));\\n    }\\n```\\n\\n# DP\\n```\\n    int dp[105][105];\\n    int uniquePaths(int n, int m) {\\n        memset(dp,-1,sizeof dp);\\n        for(int i=0;i<n;i++) dp[i][0]=1; \\n        for(int i=0;i<m;i++) dp[0][i]=1; \\n        for(int i=1;i<n;i++) {\\n            for(int j=1;j<m;j++) {\\n                //Think in reverse direction,\\n                //we can go from current cell to up or left,\\n                //So we only add dp[i-1][j] && dp[i][j-1] to current dp[i][j].\\n                dp[i][j]=(i-1>=0?dp[i-1][j]:0)+(j-1>=0?dp[i][j-1]:0);\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int combination(int n,int r){\\n        double ans=1,N=n;\\n        for(double i=1;i<=r;i++){\\n            ans*=(N-(i-1));\\n            ans/=i;\\n        }\\n        return ans;\\n    }\\n    int uniquePaths(int m, int n) {\\n        //Combinatrial solution \\n\\n        /*  \\n        Total_right_step_to_take = n-1    \\n        Total_down_step_to_take = m-1\\n        Total step = n-1+m-1 = m+n-2\\n        We want to choose m-1 down path from this total paths which is (m+n-2)C(m-1)\\n        which will also be equal to (m+n-2)C(n-1)\\n        Answer = (m+n-2)C(m-1) or (m+n-2)C(n-1)\\n        */\\n\\n        return combination(m+n-2,min(n-1,m-1));\\n    }\\n```\n```\\n    int dp[105][105];\\n    int uniquePaths(int n, int m) {\\n        memset(dp,-1,sizeof dp);\\n        for(int i=0;i<n;i++) dp[i][0]=1; \\n        for(int i=0;i<m;i++) dp[0][i]=1; \\n        for(int i=1;i<n;i++) {\\n            for(int j=1;j<m;j++) {\\n                //Think in reverse direction,\\n                //we can go from current cell to up or left,\\n                //So we only add dp[i-1][j] && dp[i][j-1] to current dp[i][j].\\n                dp[i][j]=(i-1>=0?dp[i-1][j]:0)+(j-1>=0?dp[i][j-1]:0);\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3602735,
                "title": "python-c-solutions-use-math-pascal-triangle-dp-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe codes calculate the number of unique paths in a grid from the top-left corner to the bottom-right corner. To do this, it uses the concept of combinations to determine the total number of ways to choose a certain number of downward steps (represented by \\'V\\') and rightward steps (represented by \\'>\\').\\n\\nIn the grid, there are exactly (m + n - 2) steps to move in total. Out of these steps, (m - 1) are downward steps and (n - 1) are rightward steps. This can be converted into a combination problem where we need to find the combination number for permutations of (m - 1) downward steps and (n - 1) rightward steps.\\n\\nIn Python, the combination number can be directly calculated using the formula \\n$$C(N, K) = \\\\frac{(N)(N-1)\\\\cdots (N-K+1)}{K!},$$ \\nwhere $N=m + n - 2$ represents the total number of steps and $K=\\\\min(n-1, m-1)$ the mininum for the numbers for downward steps and rightward steps. This formula simplifies the computation.\\n\\nHowever, in C++, the direct computation of the combination number may exceed the limits of even the signed long long data type. Therefore, the code employs an iterative approach inspired by Pascal\\'s Triangle, which is a form of dynamic programming. By iteratively calculating the combinations, it avoids the need for large integer computations and efficiently determines the number of unique paths.\\n\\nBy understanding this concept and leveraging dynamic programming techniques, the code effectively solves the problem of finding the number of unique paths in the grid.\\n\\nSo use the idea in Leetcode 118. Pascal\\'s Triangle, which is in fact the iterative way for dynamic programming, then done!\\n[https://youtu.be/paoJGMYEEhA](https://youtu.be/paoJGMYEEhA)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Python Code\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        if n == 1: \\n            return 1\\n        N = n + m - 2\\n        K = min(n - 1, m - 1)\\n        C=1\\n        for i in range(N,N-K, -1):\\n            C*=i\\n        for i in range(1, K+1):\\n            C//=i       \\n        return C\\n```\\n# C++ solution uses recursion with Memoziation\\n```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> C;\\n    long long comb(int i, int j){\\n        if (C[i][j]!=-1) return C[i][j];\\n        if (j==0 || j==i ) return C[i][j]=1LL;\\n        return C[i][j]=comb(i-1, j)+comb(i-1, j-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        int N = n + m - 2, K = min(n - 1, m - 1);\\n        C.assign(N+1, vector(K+1, -1LL));\\n        return comb(N, K);\\n    }\\n};\\n```\\n# C++ code using Pascal\\'s triangle beats 100%\\nBoth of SC & iterations are optimized\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        if (n == 1) return 1;\\n        int N = n + m - 2, K = min(n - 1, m - 1);\\n        vector<int> prev, C_N;\\n        prev.assign(K + 1, 1); // C(0,0)=1\\n        for (int i = 1; i <= K; i++) {\\n            C_N.assign(i + 1, 1);\\n            for (int j = 1; j <= i / 2; j++) {\\n                C_N[j] = C_N[i - j] = prev[j] + prev[j - 1];\\n            }\\n            prev = C_N;\\n        }\\n        for (int i = K + 1; i <= N - K; i++) {\\n            C_N.assign(K + 1, 1);\\n            for (int j = 1; j <= K; j++)\\n                C_N[j] = prev[j - 1] + prev[j];\\n            prev = C_N;\\n        }\\n        for (int i = N - K + 1, j0 = 1; i <= N; i++, j0++) {\\n            C_N.assign(K + 1, 1);\\n            for (int j = j0; j <= K; j++)\\n                C_N[j] = prev[j - 1] + prev[j];\\n            prev = C_N;\\n        }\\n        return C_N[K];\\n    }\\n};\\n\\n```\\n# C++ code using C(N, K)=C(N-1, K-1)*N/K\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        if (n == 1) return 1;\\n        int N = n + m - 2, K = min(n - 1, m - 1);\\n        unsigned long long C=1LL;\\n        for (unsigned i=1; i<=K; i++) \\n            C=C*(N-K+i)/i;            \\n        return C;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        if n == 1: \\n            return 1\\n        N = n + m - 2\\n        K = min(n - 1, m - 1)\\n        C=1\\n        for i in range(N,N-K, -1):\\n            C*=i\\n        for i in range(1, K+1):\\n            C//=i       \\n        return C\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> C;\\n    long long comb(int i, int j){\\n        if (C[i][j]!=-1) return C[i][j];\\n        if (j==0 || j==i ) return C[i][j]=1LL;\\n        return C[i][j]=comb(i-1, j)+comb(i-1, j-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        int N = n + m - 2, K = min(n - 1, m - 1);\\n        C.assign(N+1, vector(K+1, -1LL));\\n        return comb(N, K);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        if (n == 1) return 1;\\n        int N = n + m - 2, K = min(n - 1, m - 1);\\n        vector<int> prev, C_N;\\n        prev.assign(K + 1, 1); // C(0,0)=1\\n        for (int i = 1; i <= K; i++) {\\n            C_N.assign(i + 1, 1);\\n            for (int j = 1; j <= i / 2; j++) {\\n                C_N[j] = C_N[i - j] = prev[j] + prev[j - 1];\\n            }\\n            prev = C_N;\\n        }\\n        for (int i = K + 1; i <= N - K; i++) {\\n            C_N.assign(K + 1, 1);\\n            for (int j = 1; j <= K; j++)\\n                C_N[j] = prev[j - 1] + prev[j];\\n            prev = C_N;\\n        }\\n        for (int i = N - K + 1, j0 = 1; i <= N; i++, j0++) {\\n            C_N.assign(K + 1, 1);\\n            for (int j = j0; j <= K; j++)\\n                C_N[j] = prev[j - 1] + prev[j];\\n            prev = C_N;\\n        }\\n        return C_N[K];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        if (n == 1) return 1;\\n        int N = n + m - 2, K = min(n - 1, m - 1);\\n        unsigned long long C=1LL;\\n        for (unsigned i=1; i<=K; i++) \\n            C=C*(N-K+i)/i;            \\n        return C;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593119,
                "title": "c-easy-to-understand-0ms-o-m-n-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConsider a cell A. The number of paths from A will be the sum of paths from the cell below it and the cell to the right of it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach is a top-down DP approach.\\nWe are adding the number of paths of the right and below cells and doing it recurrsively. Along this we are storing the calculated paths in the DP array to use them in repetitive recurrsive calls.\\n\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(m*n) (memory used by DP array)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int rec(int m, int n,int a, int b, vector<vector<int>> &v)\\n    {\\n        if(v[m][n]!=-1)return v[m][n];\\n        //cheking if the value is previously stored in DP array\\n\\n        if(m==a || n==b)return 1;\\n        //base case\\n        //if the recurrsion reached the bottom or right edge then only one path is present to the final box\\n\\n        v[m][n] = rec(m+1,n,a,b, v)+rec(m, n+1,a,b,v);\\n        //adding and storing the number of paths of right and bottom cell\\n\\n        return v[m][n];\\n    }\\n\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> v(m, vector<int>(n, -1));\\n        return rec(0,0,m-1,n-1, v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int rec(int m, int n,int a, int b, vector<vector<int>> &v)\\n    {\\n        if(v[m][n]!=-1)return v[m][n];\\n        //cheking if the value is previously stored in DP array\\n\\n        if(m==a || n==b)return 1;\\n        //base case\\n        //if the recurrsion reached the bottom or right edge then only one path is present to the final box\\n\\n        v[m][n] = rec(m+1,n,a,b, v)+rec(m, n+1,a,b,v);\\n        //adding and storing the number of paths of right and bottom cell\\n\\n        return v[m][n];\\n    }\\n\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> v(m, vector<int>(n, -1));\\n        return rec(0,0,m-1,n-1, v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372964,
                "title": "easy-clear-solution-python3",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        memo=[[0 for _ in range(n+1)] for _ in range(m+1)]\\n        def db(x,y):\\n            if x==m and y==n:\\n                return 1\\n            elif x==m:\\n                if memo[x][y+1]==0:\\n                    memo[x][y+1]=db(x,y+1)\\n                return memo[x][y+1]\\n            elif y==n:\\n                if memo[x+1][y]==0:\\n                    memo[x+1][y]=db(x+1,y)\\n                return memo[x+1][y]\\n            else:\\n                if memo[x][y+1]==0:\\n                    memo[x][y+1]=db(x,y+1)\\n                if memo[x+1][y]==0:\\n                    memo[x+1][y]=db(x+1,y)\\n                return memo[x][y+1]+memo[x+1][y]\\n        return db(1,1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        memo=[[0 for _ in range(n+1)] for _ in range(m+1)]\\n        def db(x,y):\\n            if x==m and y==n:\\n                return 1\\n            elif x==m:\\n                if memo[x][y+1]==0:\\n                    memo[x][y+1]=db(x,y+1)\\n                return memo[x][y+1]\\n            elif y==n:\\n                if memo[x+1][y]==0:\\n                    memo[x+1][y]=db(x+1,y)\\n                return memo[x+1][y]\\n            else:\\n                if memo[x][y+1]==0:\\n                    memo[x][y+1]=db(x,y+1)\\n                if memo[x+1][y]==0:\\n                    memo[x+1][y]=db(x+1,y)\\n                return memo[x][y+1]+memo[x+1][y]\\n        return db(1,1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161220,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int dp[101][101]{};\\n    int uniquePaths(int m, int n, int i = 0, int j = 0) {\\n        if(i >= m || j >= n) return 0;\\n        if(i == m-1 && j == n-1) return 1;\\n        if(dp[i][j]) return dp[i][j];\\n        return dp[i][j] = uniquePaths(m, n, i+1, j) + uniquePaths(m, n, i, j+1);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [ [1]*n for i in range(m)]\\n\\n        for y in range(1,m):\\n            for x in range(1,n):\\n                dp[y][x] = dp[y-1][x] + dp[y][x-1]\\n\\n        return dp[m-1][n-1]\\n```\\n\\n```Java []\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] arr = new int[m][n];\\n        int total = traverse(0, 0, m, n, arr);\\n        return total;\\n    }\\n\\n    private int traverse(int i, int j, int m, int n, int[][] arr) {\\n        if (i == m  || j == n) {\\n            return 0;\\n        }\\n\\n        if (i == m - 1 && j == n - 1) {\\n            return 1;\\n        }\\n\\n        int bottom = i+1 < m && arr[i+1][j] != 0 ? arr[i+1][j]:traverse(i+1, j, m, n, arr);\\n        int right = j+1 < n && arr[i][j+1] != 0 ? arr[i][j]:traverse(i, j + 1, m, n, arr);\\n\\n        arr[i][j] = bottom + right;\\n        return arr[i][j];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int dp[101][101]{};\\n    int uniquePaths(int m, int n, int i = 0, int j = 0) {\\n        if(i >= m || j >= n) return 0;\\n        if(i == m-1 && j == n-1) return 1;\\n        if(dp[i][j]) return dp[i][j];\\n        return dp[i][j] = uniquePaths(m, n, i+1, j) + uniquePaths(m, n, i, j+1);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [ [1]*n for i in range(m)]\\n\\n        for y in range(1,m):\\n            for x in range(1,n):\\n                dp[y][x] = dp[y-1][x] + dp[y][x-1]\\n\\n        return dp[m-1][n-1]\\n```\n```Java []\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] arr = new int[m][n];\\n        int total = traverse(0, 0, m, n, arr);\\n        return total;\\n    }\\n\\n    private int traverse(int i, int j, int m, int n, int[][] arr) {\\n        if (i == m  || j == n) {\\n            return 0;\\n        }\\n\\n        if (i == m - 1 && j == n - 1) {\\n            return 1;\\n        }\\n\\n        int bottom = i+1 < m && arr[i+1][j] != 0 ? arr[i+1][j]:traverse(i+1, j, m, n, arr);\\n        int right = j+1 < n && arr[i][j+1] != 0 ? arr[i][j]:traverse(i, j + 1, m, n, arr);\\n\\n        arr[i][j] = bottom + right;\\n        return arr[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158157,
                "title": "java-2-solutions-with-clear-explanation-brute-force-dp",
                "content": "# Intuition\\nThe Unique Paths problem is a classic dynamic programming problem where you need to find the number of unique paths from the top-left corner of a grid to a bottom-right corner, while only allow to move right or down.\\n\\n# Approach\\nThe first approach that came into my mind was backtracking. Starting from the top-left corner of the grid (represented by `row` and `column`), we recursively explore all the possible paths to the bottom-right corner of the grid. However, this solution is quite inefficient.\\n\\n# Code\\n#### **1) Brute force solution (Recursive) [TLE] \\u274C**\\n\\nAt every cell, we make 2 decisions: go right / go left.\\n\\nif `row` is equal to `m-1` and `column` is equal to `n-1`, it means we have reached the bottom-right corner, and we can increment the `count` of unique paths by 1.\\n\\nif `row` is greater than or equal to `m` or `column` is greater than or equal to `n`, it means we have stepped outside the grid, and we return from the function.\\n\\nFinally we return the variable `count`.\\n\\n```\\nclass Solution {\\n    int count = 0;\\n    public int uniquePaths(int m, int n) {\\n        backtracking(0, 0, m, n);\\n        return count;\\n    }\\n\\n    public void backtracking(int row, int column, int m, int n)\\n    {\\n        if(row == m - 1 && column == n - 1) \\n        {\\n            count++;\\n            return;\\n        }\\n        if(row >= m || column >= n) return;\\n        backtracking(row, column + 1, m,n);\\n        backtracking(row + 1, column, m, n);\\n    }\\n}\\n```\\n\\n- Time complexity: $$O(2^m * 2^n)$$ where `m` and `n` are the dimensions of the grid. For each cells, the robot tries every possible path to go and this lead to an exponential number of possible paths to solve.\\n\\n- Space complexity: $$O(m*n)$$ in the worst case, the maximum number of function calls that can be made is `m * n`, one for each cell of the grid. \\n\\n#### **2) Dynamic programming solutions**\\n\\n##### Iterative - Tabulation - Bottom Up \\u2705\\n\\nStep 1 - Create a 2D-array with the same dimension as the grid. This `dp` array will store the number of unique paths to each cell in the grid. You can initialize the whole top row and side-left column to 1 because there is always one path and to reach any cell in the top row and the side-left column.\\n\\nYour array might looks like this:\\n[1\\t1\\t1\\t1]\\n[1\\t0\\t0\\t0]\\n[1\\t0\\t0\\t0]\\n[1\\t0\\t0\\t0]\\n\\nStep 2 - Fill the `dp` array: Now traverse through the `dp` array, you can skip any cell that has a value of 1. The value of each cell holds the number of unique paths to reach that cell. To find this value, you can add the value of the cell above it and the cell to its left. \\n\\n[1\\t1\\t1\\t1   ]\\n[1\\t2\\t3\\t4  ] \\n[1\\t3\\t9\\t13 ]\\n[1\\t4\\t13\\t26]\\n\\nStep 3 - Return the value of the last cell. After traversing through the array, the last cell will hold the number of unique paths to get to it. You can return `dp[m-1][n-1]` to get the solution. \\n\\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int [][] grid = new int [m][n];\\n        for(int k = 0; k < m; k++) grid[k][0] = 1;\\n        for(int k = 0; k < n; k++) grid[0][k] = 1;\\n\\n        for(int k = 0; k < m; k++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid[k][j] == 1) continue;\\n                else\\n                {\\n                    grid[k][j] = grid[k-1][j] + grid[k] [j-1]; \\n                }\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n```\\n\\n- Time complexity: $$O(m*n)$$ where m and n are the dimensions of the grid\\n\\n- Space complexity: $$O(m*n)$$ as you need to store the values of all cells in the `dp` array.\\n\\n# Application\\n\\n###### The Jump Game problem have several real-life applications, including the following: \\n\\n1. Robotics: find the number of unique paths it can take to reach its destionation in a grid-like enviroment (warehouses).\\n2. Game development: this algorithm can be used to find the number of unique paths that a player can take to reach a certain point.\\n3. Image processing: measure the  distance between two objects by counting the number of unique paths between two points in an image\\n4. Network Design: find the number of unique paths between two nodes in a network, for example, two find the number of different routes between 2 cities.\\n5. Supplychain management: unique paths that a product can take from the warehouse to the customer\\n6. Map navigation: find different routes between 2 cities.\\n\\n*Thank you for reading! If you found this solution helpful, please give me an upvote. Feel free to add suggestions.*\\n\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public int uniquePaths(int m, int n) {\\n        backtracking(0, 0, m, n);\\n        return count;\\n    }\\n\\n    public void backtracking(int row, int column, int m, int n)\\n    {\\n        if(row == m - 1 && column == n - 1) \\n        {\\n            count++;\\n            return;\\n        }\\n        if(row >= m || column >= n) return;\\n        backtracking(row, column + 1, m,n);\\n        backtracking(row + 1, column, m, n);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int [][] grid = new int [m][n];\\n        for(int k = 0; k < m; k++) grid[k][0] = 1;\\n        for(int k = 0; k < n; k++) grid[0][k] = 1;\\n\\n        for(int k = 0; k < m; k++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid[k][j] == 1) continue;\\n                else\\n                {\\n                    grid[k][j] = grid[k-1][j] + grid[k] [j-1]; \\n                }\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078158,
                "title": "100-runtime-recursion-memoization-tabulation-optimisation",
                "content": "## Intuition\\nThe question is a simple problem of recursion/backtracking that can be optimised through Dynamic Programming using memoization and tabulation, to reduce the time complexity exponentially.\\n> To put things into perspective, it takes about 0.0000006 seconds to finish 60 computations, but more than 360 YEARS for 2^60 computations, on most platforms.\\n\\nWe are given a matrix of M rows and N columns, where we have to reach the bottom-right corner (i.e the block with index [m-1][n-1]) from the top-left (i.e. the block with index [0][0]), moving only to the right or down from any given block.\\n\\nOur first intuition would be to start from the first block and explore all possibilities on each iterations till we reach the destination, then repeat for every other possible combination along the way. Let\\'s see how we do that while not aging beyond our generation.\\n\\n# Approach 1: Recursion/Backtracking [TLE]\\n<!-- Describe your approach to solving the problem. -->\\n1) The first approach that comes to mind is Recursion, starting from the base case, reaching the destination through a valid path then backtracking to find all possible solutions. \\nDoing so is a correct approach but not an optimised one, since we would be performing a huge amount of redundant computations while traversing all possibilities in the recursion tree.\\n## Complexity\\n- Time complexity:<code>**O(2<sup>m + n</sup>)**</code>\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: <code>**O(m*n) + O(m+n)**</code>, for the dp array and the implicit recursive stack respectively.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int find(int& m, int& n, int i, int j){\\n        if(i==m || j==n) return 0;  // Out of bounds\\n        if(i==m-1 && j==n-1) return 1;\\n        return find(m, n, i+1, j) + find(m, n, i, j+1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return find(m, n, 0, 0);\\n    }\\n};\\n```\\n<br>\\n\\n# Approach 2: Memoization - Top down\\nNow that we\\'ve got a glamorous TLE error, let\\'s try to optimise it by maintaining a `M*N` dp matrix that saves all computations for future reference. Every time we come across a cell whole value has already been found, we return that value without having to go down that road again.\\n> You\\'ll see, its much better! \\n\\n## Complexity\\n- Time complexity:<code>**O(m * n)**</code>\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: <code>**O(m*n) + O(m+n)**</code>, for the dp array and the implicit recursive stack respectively.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int find(vector<vector<int>>& dp, int& m, int& n, int i, int j){\\n        if(i==m || j==n) return 0;  // Out of bounds\\n        if(i==m-1 && j==n-1) return 1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        dp[i][j] = find(dp, m, n, i+1, j) + find(dp, m, n, i, j+1);\\n        return dp[i][j];\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return find(dp, m, n, 0, 0);\\n    }\\n};\\n```\\n<br>\\n\\n# Approach 3: Tabulation - Bottom up\\nOkay so we\\'ve solved it but the space complexity still bugs a bit, doesn\\'t it? I get why we need the `M*N` space for the array, but the additional space needs to leave. What if we come up with an iterative solution instead (it\\'s basically the same thing, just in a loop, and better), which works from the *bottom-up*... that ought to work?\\n> PS, it does.\\n\\n## Complexity\\n- Time complexity:<code>**O(m * n)**</code>\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: <code>**O(m*n)**</code>, for the dp array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 1));\\n        if(m==1 && n==1) return 1;\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                dp[i][j]=0;\\n                dp[i][j] += dp[i+1][j];\\n                dp[i][j] += dp[i][j+1];\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\\nNow we **could** stop with the madness, but we do notice that we\\'re not really using all of `M*N` space; instead, on every iteration, we\\'re just concerned with the current row, and the one succeeding it. So why not just do that? Let\\'s reduce the array to have 2 rows which we alternate through on every iteration and update the values in those cells instead of storing values in new ones. \\n> Why? Reduces the space complexity even more, which would be good when you\\'ve got longer testcases.\\n\\n## Complexity\\n- Time complexity:<code>**O(m * n)**</code>\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: <code>**O(2*n)**</code>, for the optimised dp array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(2, vector<int>(n, 1));\\n        int f=(m-2)&1;\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                dp[f][j] = dp[!f][j] + dp[f][j+1];\\n            }\\n            f=!f;\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\\n\\nOr still better yet, we can use a single vector as well. We are only accessing same column from previous row which can be given by dp[j] and previous column of current row which can be given by dp[j-1]. So the above code can be further simplfied to a space complexity of <code>**O(n)**</code>, thanks to [@zayne-siew](https://leetcode.com/zayne-siew/).",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int& m, int& n, int i, int j){\\n        if(i==m || j==n) return 0;  // Out of bounds\\n        if(i==m-1 && j==n-1) return 1;\\n        return find(m, n, i+1, j) + find(m, n, i, j+1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return find(m, n, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int find(vector<vector<int>>& dp, int& m, int& n, int i, int j){\\n        if(i==m || j==n) return 0;  // Out of bounds\\n        if(i==m-1 && j==n-1) return 1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        dp[i][j] = find(dp, m, n, i+1, j) + find(dp, m, n, i, j+1);\\n        return dp[i][j];\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return find(dp, m, n, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 1));\\n        if(m==1 && n==1) return 1;\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                dp[i][j]=0;\\n                dp[i][j] += dp[i+1][j];\\n                dp[i][j] += dp[i][j+1];\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(2, vector<int>(n, 1));\\n        int f=(m-2)&1;\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                dp[f][j] = dp[!f][j] + dp[f][j+1];\\n            }\\n            f=!f;\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974532,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Recursive DP\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nl, ml, dp[105][105];\\n\\n    bool valid(int x, int y) {\\n        if(x < nl and y < ml) return true;\\n        else return false;\\n    }\\n\\n    int solve(int i, int j) {\\n        if(!valid(i, j)) return 0;\\n        if(i >= nl-1 and j >= ml-1) return 1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans = solve(i+1, j) + solve(i, j+1);\\n        return dp[i][j] = ans;\\n    }\\n\\n    int uniquePaths(int m, int n) {\\n        nl = m, ml = n;\\n        memset(dp, -1, sizeof(dp));\\n        int ans = solve(0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nl, ml, dp[105][105];\\n\\n    bool valid(int x, int y) {\\n        if(x < nl and y < ml) return true;\\n        else return false;\\n    }\\n\\n    int solve(int i, int j) {\\n        if(!valid(i, j)) return 0;\\n        if(i >= nl-1 and j >= ml-1) return 1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans = solve(i+1, j) + solve(i, j+1);\\n        return dp[i][j] = ans;\\n    }\\n\\n    int uniquePaths(int m, int n) {\\n        nl = m, ml = n;\\n        memset(dp, -1, sizeof(dp));\\n        int ans = solve(0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815421,
                "title": "java-runtime-0ms-faster-than-100-recursion-memoization",
                "content": "```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return helper(m, n, new int[m + 1][n + 1]);\\n    }\\n\\n    private int helper(int m, int n, int[][] arr) {\\n        if (m < 1 || n < 1) return 0;\\n        if (m == 1 && n == 1) return 1;\\n\\n        if (arr[m][n] != 0) return arr[m][n];\\n        arr[m][n] = helper(m - 1, n, arr) + helper(m, n - 1, arr);\\n\\n        return arr[m][n];\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/a64975ed-3362-45cd-b513-c550863466b2_1668474983.0550408.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return helper(m, n, new int[m + 1][n + 1]);\\n    }\\n\\n    private int helper(int m, int n, int[][] arr) {\\n        if (m < 1 || n < 1) return 0;\\n        if (m == 1 && n == 1) return 1;\\n\\n        if (arr[m][n] != 0) return arr[m][n];\\n        arr[m][n] = helper(m - 1, n, arr) + helper(m, n - 1, arr);\\n\\n        return arr[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760831,
                "title": "recursion-memo-dp-clean-javascript-explain",
                "content": "Since we can only move to the right or down, the number of paths from any point is equal to the sum of the paths from the right cell and bottom cell. And there are zero possible paths outside the map.\\n\\n![image](https://assets.leetcode.com/users/images/66ab31aa-c2f7-4d60-b01d-cca55d67e47b_1667153620.739161.png)\\n\\nSo we can use recursion and memoization to prevent re-calculations.\\n``` javascript\\nfunction uniquePaths(m, n) {\\n    // generate map\\n    const cache = Array.from({length: m}, e => Array(n));\\n    cache[m-1][n-1] = 1;\\n    \\n    function cellCalc(x, y) {\\n        // if not in chache then calc\\n        if (!cache[x][y]) {\\n            cache[x][y] = \\n                // if out of map then + 0\\n                (x < m - 1 ? cellCalc(x + 1, y) : 0) + \\n                (y < n - 1 ? cellCalc(x, y + 1) : 0);\\n        }\\n        return cache[x][y];\\n    }\\n    \\n    return cellCalc(0, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Memoization"
                ],
                "code": "``` javascript\\nfunction uniquePaths(m, n) {\\n    // generate map\\n    const cache = Array.from({length: m}, e => Array(n));\\n    cache[m-1][n-1] = 1;\\n    \\n    function cellCalc(x, y) {\\n        // if not in chache then calc\\n        if (!cache[x][y]) {\\n            cache[x][y] = \\n                // if out of map then + 0\\n                (x < m - 1 ? cellCalc(x + 1, y) : 0) + \\n                (y < n - 1 ? cellCalc(x, y + 1) : 0);\\n        }\\n        return cache[x][y];\\n    }\\n    \\n    return cellCalc(0, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2740482,
                "title": "python-one-liner",
                "content": "We can consider this as a permutation/combination problem. If the matrix has `m` rows and `n` columns, any path we take will include `m-1` down steps and `n-1` right steps. The problem of finding number of unique paths is essentially number of ways to arrange these steps we take. Since all the down steps are identical and similarly all the right steps are identical it doesn matter the internal ordering of all the down steps (similarly true for the right steps). Essentialy we want to find number of unique ways to arrange `m-1` identical objects and `n-1` identical objects with each other, which becomes `(m-1+n-1)!/((m-1)!*(n-1)!)`.\\n```\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return math.factorial(m+n-2) / (math.factorial(m-1) * math.factorial(n-1))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return math.factorial(m+n-2) / (math.factorial(m-1) * math.factorial(n-1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693671,
                "title": "c-easy-fast-and-shortest-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(int i, int j, vector<vector<int>> &dp)\\n    {\\n        if(i==0 or j==0) return 1;\\n        return dp[i-1][j] + dp[i][j-1];\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(n, vector<int> (m,0));\\n        \\n        for(int i=0;i<n;i++)\\n        for(int j=0;j<m;j++)\\n        dp[i][j] = solve(i,j,dp);\\n        \\n        return dp[n-1][m-1];\\n    }\\n};\\n```\\n**UPVOTE**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(int i, int j, vector<vector<int>> &dp)\\n    {\\n        if(i==0 or j==0) return 1;\\n        return dp[i-1][j] + dp[i][j-1];\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(n, vector<int> (m,0));\\n        \\n        for(int i=0;i<n;i++)\\n        for(int j=0;j<m;j++)\\n        dp[i][j] = solve(i,j,dp);\\n        \\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2445553,
                "title": "dp-all-techniques-memoization-and-tabulation-and-tabulation-with-space-optimization",
                "content": "Memoization:\\n```\\nint f (int row, int col, vector<vector<int>> &dp) {\\n        if (row == 0 || col == 0 ) return 1;\\n        if (dp[row][col] != 1) return dp[row][col];\\n        return dp[row][col] = f(row-1, col,dp) + f(row, col-1,dp);\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp (m, vector<int> (n,1));\\n        return f(m-1, n-1,dp);\\n    }\\n```\\nTime Complexity: O(NxM)\\nSpace Complexity: O(NxM) + O(N+M)\\n(O(NxM) for dp grid and  O(N+M) for extra stack space)\\nThe extra stack space can be reduced by using Tabulation Method.\\n\\nTabulation:\\n```\\nint uniquePaths(int m, int n) {\\n        vector<vector<int>> dp (m, vector<int> (n,1));\\n        \\n        for (int j=1;j<n;j++) {\\n            for (int i=1;i<m;i++) {\\n                dp[i][j] = dp[i][j-1] + dp[i-1][j];\\n            }\\n            \\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n```\\nTime Complexity: O (NxM)\\nSpace Complexity: O (NxM)\\n\\nNow, the space used by the dp grid can also be optimized. We observe that we only need the values from dp grid from last column and current column. So, instead of the whole dp grid we can just store the values from last column and current column in two vectors.\\n\\nTabulation with Space Optimization: \\n```\\nint uniquePaths(int m, int n) {\\n        vector<int> last (m,1);\\n        \\n        for (int j=1;j<n;j++) {\\n            vector<int> curr (m,1);\\n            for (int i=1;i<m;i++) {\\n                curr[i] = last[i] + curr[i-1];\\n            }\\n            last = curr;\\n        }\\n        \\n        return last[m-1];\\n    }\\n```\\nTime Complexity: O(MxN)\\nSpace Complexity: O(M)",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint f (int row, int col, vector<vector<int>> &dp) {\\n        if (row == 0 || col == 0 ) return 1;\\n        if (dp[row][col] != 1) return dp[row][col];\\n        return dp[row][col] = f(row-1, col,dp) + f(row, col-1,dp);\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp (m, vector<int> (n,1));\\n        return f(m-1, n-1,dp);\\n    }\\n```\n```\\nint uniquePaths(int m, int n) {\\n        vector<vector<int>> dp (m, vector<int> (n,1));\\n        \\n        for (int j=1;j<n;j++) {\\n            for (int i=1;i<m;i++) {\\n                dp[i][j] = dp[i][j-1] + dp[i-1][j];\\n            }\\n            \\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n```\n```\\nint uniquePaths(int m, int n) {\\n        vector<int> last (m,1);\\n        \\n        for (int j=1;j<n;j++) {\\n            vector<int> curr (m,1);\\n            for (int i=1;i<m;i++) {\\n                curr[i] = last[i] + curr[i-1];\\n            }\\n            last = curr;\\n        }\\n        \\n        return last[m-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2363681,
                "title": "java-easy-dp-solution-o-n-m",
                "content": "```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int [][]matrix = new int[m][n];\\n        for (int i=0;i<m;i++){\\n            for (int j=0;j<n;j++){\\n                if (i==0 || j==0)matrix[i][j]=1;\\n                else matrix[i][j]=matrix[i-1][j]+matrix[i][j-1];\\n            }\\n        }\\n        return matrix[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int [][]matrix = new int[m][n];\\n        for (int i=0;i<m;i++){\\n            for (int j=0;j<n;j++){\\n                if (i==0 || j==0)matrix[i][j]=1;\\n                else matrix[i][j]=matrix[i-1][j]+matrix[i][j-1];\\n            }\\n        }\\n        return matrix[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2363489,
                "title": "java-4-liner-solution-without-dp",
                "content": "```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n      long ans = 1;\\n      \\nfor(int i = m + n - 2, j = 1; i >= Math.max(m, n); i --, j ++)\\nans = (ans * i) / j;\\n      \\nreturn (int)ans;  \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n      long ans = 1;\\n      \\nfor(int i = m + n - 2, j = 1; i >= Math.max(m, n); i --, j ++)\\nans = (ans * i) / j;\\n      \\nreturn (int)ans;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362994,
                "title": "dp-top-down-bottom-up-space-reduction-explained",
                "content": "If you found this helpful, please upvote <3\\n\\n<hr />\\n\\nThis is a dynamic programming problem, how do we identify?\\n\\nAt any position in the grid `r, c` (row, column) we can ask how many paths we have to reach the end of the grid.\\n\\nThis is a `subproblem statement`, which is independent of the previous problems.\\n\\nAlso there is an `optimal substructure`, possible **unique paths**.\\n\\n# Transition\\nWe stand at the starting cell 0,0.\\n\\nWe have 2 choices: go right or go down.\\n\\nWhenever we reach the end, `row == m-1 and col == n-1` we found a path to the end, we return 1.\\n\\n# Top down\\nUse memoization to lookup answers to already solved subproblems.\\n\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        @lru_cache(maxsize=None)\\n        def dp_memo(r, c):\\n\\t\\t\\t# base case - reached the end\\n            if r == m-1 and c == n-1:\\n                return 1\\n            \\n            ans = 0\\n            for nr, nc in [(r+1, c), (r, c+1)]:\\n\\t\\t\\t\\t# if inbound\\n                if 0 <= nr < m and 0 <= nc < n:\\n                    ans += dp_memo(nr, nc)\\n            return ans\\n            \\n        return dp_memo(0, 0)\\n```\\n\\n# Bottom up\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[0 for _ in range(n)] for _ in range(m)]\\n        \\n        # base case, bottom row and most right column\\n        for i in range(n):\\n            dp[-1][i] = 1\\n        \\n        for j in range(m):\\n            dp[j][-1] = 1\\n            \\n        # transition\\n        for r in range(m-2, -1, -1):\\n            for c in range(n-2, -1, -1):\\n                for nr, nc in [(r+1, c), (r, c+1)]:\\n                    dp[r][c] += dp[nr][nc]\\n        \\n        return dp[0][0]\\n```\\n\\n# Space reduction\\nWe can see that our dp transition is only based on the previous row, or the previous column.\\n\\nWe can reduce the `m*n` dp array into a 1D array.\\n\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        # base case, bottom row and most right column\\n        prev_row = [1] * n\\n            \\n        # transition\\n        for r in range(m-2, -1, -1):\\n            cur_row = [0] * n\\n            # base case, last column is 1\\n            cur_row[-1] = 1\\n            \\n            for c in range(n-2, -1, -1):\\n                cur_row[c] += prev_row[c] + cur_row[c+1]\\n        \\n            prev_row = cur_row\\n            \\n        return prev_row[0]\\n```\\n\\n\\n<hr />\\n\\nHave a fantastic day",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        @lru_cache(maxsize=None)\\n        def dp_memo(r, c):\\n\\t\\t\\t# base case - reached the end\\n            if r == m-1 and c == n-1:\\n                return 1\\n            \\n            ans = 0\\n            for nr, nc in [(r+1, c), (r, c+1)]:\\n\\t\\t\\t\\t# if inbound\\n                if 0 <= nr < m and 0 <= nc < n:\\n                    ans += dp_memo(nr, nc)\\n            return ans\\n            \\n        return dp_memo(0, 0)\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[0 for _ in range(n)] for _ in range(m)]\\n        \\n        # base case, bottom row and most right column\\n        for i in range(n):\\n            dp[-1][i] = 1\\n        \\n        for j in range(m):\\n            dp[j][-1] = 1\\n            \\n        # transition\\n        for r in range(m-2, -1, -1):\\n            for c in range(n-2, -1, -1):\\n                for nr, nc in [(r+1, c), (r, c+1)]:\\n                    dp[r][c] += dp[nr][nc]\\n        \\n        return dp[0][0]\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        # base case, bottom row and most right column\\n        prev_row = [1] * n\\n            \\n        # transition\\n        for r in range(m-2, -1, -1):\\n            cur_row = [0] * n\\n            # base case, last column is 1\\n            cur_row[-1] = 1\\n            \\n            for c in range(n-2, -1, -1):\\n                cur_row[c] += prev_row[c] + cur_row[c+1]\\n        \\n            prev_row = cur_row\\n            \\n        return prev_row[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362815,
                "title": "easy-solution-using-combinatorics",
                "content": "This is a combinatorial problem and can be solved without DP. For mxn grid, robot has to move exactly m-1 steps down and n-1 steps right and these can be done in any order.\\n\\nFor the eg., given in question, 3x7 matrix, robot needs to take 2+6 = 8 steps with 2 down and 6 right in any order. That is nothing but a permutation problem. Denote down as \\'D\\' and right as \\'R\\', following is one of the path :-\\n\\nD R R R D R R R\\n\\nWe have to tell the total number of permutations of the above given word. So, decrease both m & n by 1 and apply following formula:-\\n\\nTotal permutations = (m+n)! / (m! * n!)\\n\\nFollowing is my code doing the same :-\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int N=m+n-2;\\n        int R=min(m-1,n-1);\\n        \\n        double ans=1;\\n        \\n        for(int i=1;i<=R;++i)\\n            ans = ans*(N--)/i;\\n        \\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int N=m+n-2;\\n        int R=min(m-1,n-1);\\n        \\n        double ans=1;\\n        \\n        for(int i=1;i<=R;++i)\\n            ans = ans*(N--)/i;\\n        \\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298605,
                "title": "python-4-approaches-entire-dp",
                "content": "**Recursion -> TLE\\nTime Complexity: O(2^M*N)\\nSpace Complexity: O(Path Length)\\nwhere, Path Length = (M+1)+(N+1)**\\n\\n```\\ndef f(i,j):\\n    \\n    if(i == 0 and j == 0):\\n        return 1\\n    \\n    if(i < 0 or j < 0):\\n        return 0\\n    \\n    up = f(i-1,j)\\n    left = f(i,j-1)\\n    \\n    return up+left\\n\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        return f(m-1,n-1)\\n```\\n\\n**Memoization**\\n**Time Complexity: O(M*N)**\\n**Space Complexity: O((N-1)+(M-1)) + O(M*N)**\\n\\n```\\ndef f(i,j,dp):\\n    \\n    if(i == 0 and j == 0):\\n        return 1\\n    \\n    if(i < 0 or j < 0):\\n        return 0\\n    \\n    if(dp[i][j] != -1):\\n        return dp[i][j]\\n    \\n    up = f(i-1,j,dp)\\n    left = f(i,j-1,dp)\\n    \\n    dp[i][j] = up + left\\n    \\n    return dp[i][j]\\n\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        dp = [[-1] * n for x in range(m)]\\n        \\n        return f(m-1,n-1,dp)\\n```\\n\\n**Tabulation**\\n**Time Complexity: O(M*N)**\\n**Space Complexity: O(M*N)**\\n\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        dp = [[-1] * n for x in range(m)]\\n        \\n        for i in range(0,m):\\n            for j in range(0,n):\\n                \\n                if(i==0 and j==0):\\n                    dp[i][j] =1\\n                    \\n                else:\\n                    up,left = 0,0\\n                    if(i>0):\\n                        \\n                        up = dp[i-1][j]\\n                    if(j>0):\\n                        \\n                        left = dp[i][j-1]\\n                        \\n                    dp[i][j] = up+left\\n                    \\n        return dp[m-1][n-1]\\n```\\n\\n**Tabulation with SPACE OPTIMIZED**\\n**Time Complexity: O(M*N)**\\n**Space Complexity: O(N)**\\n\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        prev = [0] * n\\n        for i in range(0,m):\\n            curr = [0] * n\\n            for j in range(0,n):\\n                \\n                if(i==0 and j==0):\\n                    curr[j] = 1\\n                    \\n                else:\\n                    up,left = 0,0\\n                    \\n                    if(i>0):\\n                        up = prev[j]\\n                    if(j>0):\\n                        \\n                        left = curr[j-1]\\n                    curr[j] = up+left\\n                    \\n            prev = [x for x in curr]        \\n                    \\n        return prev[n-1]\\n```\\n\\n**Please upvote if you find it useful !!!**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ndef f(i,j):\\n    \\n    if(i == 0 and j == 0):\\n        return 1\\n    \\n    if(i < 0 or j < 0):\\n        return 0\\n    \\n    up = f(i-1,j)\\n    left = f(i,j-1)\\n    \\n    return up+left\\n\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        return f(m-1,n-1)\\n```\n```\\ndef f(i,j,dp):\\n    \\n    if(i == 0 and j == 0):\\n        return 1\\n    \\n    if(i < 0 or j < 0):\\n        return 0\\n    \\n    if(dp[i][j] != -1):\\n        return dp[i][j]\\n    \\n    up = f(i-1,j,dp)\\n    left = f(i,j-1,dp)\\n    \\n    dp[i][j] = up + left\\n    \\n    return dp[i][j]\\n\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        dp = [[-1] * n for x in range(m)]\\n        \\n        return f(m-1,n-1,dp)\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        dp = [[-1] * n for x in range(m)]\\n        \\n        for i in range(0,m):\\n            for j in range(0,n):\\n                \\n                if(i==0 and j==0):\\n                    dp[i][j] =1\\n                    \\n                else:\\n                    up,left = 0,0\\n                    if(i>0):\\n                        \\n                        up = dp[i-1][j]\\n                    if(j>0):\\n                        \\n                        left = dp[i][j-1]\\n                        \\n                    dp[i][j] = up+left\\n                    \\n        return dp[m-1][n-1]\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        prev = [0] * n\\n        for i in range(0,m):\\n            curr = [0] * n\\n            for j in range(0,n):\\n                \\n                if(i==0 and j==0):\\n                    curr[j] = 1\\n                    \\n                else:\\n                    up,left = 0,0\\n                    \\n                    if(i>0):\\n                        up = prev[j]\\n                    if(j>0):\\n                        \\n                        left = curr[j-1]\\n                    curr[j] = up+left\\n                    \\n            prev = [x for x in curr]        \\n                    \\n        return prev[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252966,
                "title": "easy-c-sol-naive-efficient-approaches-time-o-n",
                "content": "```\\n// Brute-Force Solution :: Using Recursion :: Time : O(2^(max(m,n))) :: Aux_Space : O(2^(max(m,n))) [Stack Space]\\n\\nclass Solution {\\npublic:\\n\\n    int countPaths(int i,int j,int m,int n){\\n\\n        if(i == (n-1) && j == (m-1))\\n            return 1;\\n\\n        if(i >= n || j>=m)\\n            return 0;\\n        else\\n            return countPaths(i+1,j,m,n) + countPaths(i,j+1,m,n);\\n\\n\\n    }\\n\\n    int uniquePaths(int m, int n) {\\n\\n        int i=0,j=0;\\n\\n        return countPaths(i,j,m,n);\\n\\n    }\\n};\\n\\n// Better Solution :: Using Dynamic Programming :: Time : O(M*N) :: Aux_Space : O(M*N)\\n\\nclass Solution {\\npublic:\\n\\n    int countPaths(int i,int j,int m,int n, vector<vector<int>> &dp){\\n\\n        if(i >= n || j>=m)\\n            return 0;\\n\\n        if(i == (n-1) && j == (m-1))\\n            return 1;\\n\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n\\n        return dp[i][j] = countPaths(i+1,j,m,n,dp) + countPaths(i,j+1,m,n,dp);\\n    }\\n\\n    int uniquePaths(int m, int n) {\\n\\n        int i=0,j=0;\\n\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n\\n        return countPaths(i,j,m,n,dp);\\n\\n    }\\n};\\n\\n// Efficient Solution :: Using Combinations :: Time : O(M-1) || O(N-1) :: Aux_Space : O(1)\\n\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n\\n        int N = m+n-2;\\n\\n        int r = m-1;\\n        double res = 1;\\n\\n        for(int i=1;i<=r;i++){\\n            res = res * (N-r+i)/i;\\n        }\\n        return (int)res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int countPaths(int i,int j,int m,int n){\\n\\n        if(i == (n-1) && j == (m-1))\\n            return 1;\\n\\n        if(i >= n || j>=m)\\n            return 0;\\n        else\\n            return countPaths(i+1,j,m,n) + countPaths(i,j+1,m,n);\\n\\n\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2225531,
                "title": "recursive-memo-hashmap-2d-dp-tabulation",
                "content": "RECURSION\\n```\\nclass Solution {   \\n    public int uniquePaths(int m, int n) {\\n       return solve(m-1,n-1);\\n    }\\n    private int solve(int si, int sj){\\n        if(si == 0 && sj == 0) return 1;\\n        if(si < 0 || sj < 0) return 0;\\n        int op1 = solve(si-1, sj);\\n        int op2 = solve(si, sj-1);\\n        return op1+op2;\\n    }\\n}\\n```\\nMEMO => HASHMAP\\n```\\nclass Solution {   \\n    public int uniquePaths(int m, int n) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        return solve(m-1,n-1, map);\\n    }\\n    private int solve(int si, int sj, HashMap<String, Integer> map){\\n        if(si == 0 && sj == 0) return 1;\\n        if(si < 0 || sj < 0) return 0;\\n        String key = si+\"$\"+sj;\\n        if(map.containsKey(key)) return map.get(key);\\n        int op1 = solve(si-1, sj, map);\\n        int op2 = solve(si, sj-1, map);\\n        map.put(key, op1+op2);\\n        return op1+op2;\\n    }\\n}\\n```\\nMEMO => 2D DP ARRAY\\n```\\nclass Solution {   \\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        return solve(m-1,n-1, dp);\\n    }\\n    private int solve(int si, int sj, int[][] dp){\\n        if(si == 0 && sj == 0) return 1;\\n        if(si < 0 || sj < 0) return 0;\\n        if(dp[si][sj] != 0) return dp[si][sj];\\n        int op1 = solve(si-1, sj, dp);\\n        int op2 = solve(si, sj-1, dp);\\n        dp[si][sj] = op1 + op2;\\n        return op1+op2;\\n    }\\n}\\n```\\nTABULATION\\n```\\nclass Solution {   \\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i == 0 || j==0) dp[i][j] = 1;\\n                else{\\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {   \\n    public int uniquePaths(int m, int n) {\\n       return solve(m-1,n-1);\\n    }\\n    private int solve(int si, int sj){\\n        if(si == 0 && sj == 0) return 1;\\n        if(si < 0 || sj < 0) return 0;\\n        int op1 = solve(si-1, sj);\\n        int op2 = solve(si, sj-1);\\n        return op1+op2;\\n    }\\n}\\n```\n```\\nclass Solution {   \\n    public int uniquePaths(int m, int n) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        return solve(m-1,n-1, map);\\n    }\\n    private int solve(int si, int sj, HashMap<String, Integer> map){\\n        if(si == 0 && sj == 0) return 1;\\n        if(si < 0 || sj < 0) return 0;\\n        String key = si+\"$\"+sj;\\n        if(map.containsKey(key)) return map.get(key);\\n        int op1 = solve(si-1, sj, map);\\n        int op2 = solve(si, sj-1, map);\\n        map.put(key, op1+op2);\\n        return op1+op2;\\n    }\\n}\\n```\n```\\nclass Solution {   \\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        return solve(m-1,n-1, dp);\\n    }\\n    private int solve(int si, int sj, int[][] dp){\\n        if(si == 0 && sj == 0) return 1;\\n        if(si < 0 || sj < 0) return 0;\\n        if(dp[si][sj] != 0) return dp[si][sj];\\n        int op1 = solve(si-1, sj, dp);\\n        int op2 = solve(si, sj-1, dp);\\n        dp[si][sj] = op1 + op2;\\n        return op1+op2;\\n    }\\n}\\n```\n```\\nclass Solution {   \\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i == 0 || j==0) dp[i][j] = 1;\\n                else{\\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212649,
                "title": "simple-c-clean-code-dp-and-recursion-memorization-easy-understanding",
                "content": "**We will try to build dp grid of given m*n size and try to fill it accordingly.**\\n**We can see in question that we can either move down or right only.\\nSo to reach any cell of first row or first column we only one way to reach there.\\nNow for other cells say cell[1][1]  we can reach there in cell[0][1]+cell[1][0] ways.\\nso at last the value at cell[m-1][n-1] will be our ans.\\nFor clear understanding take a look at image below.**\\n![image](https://assets.leetcode.com/users/images/2586eea7-5f90-480f-b94b-351830c404eb_1656486252.4715111.png)\\nhere if we are at any cell in first row or column we can reach there in one way only.\\nand we have updated dp matrix according to approch explained above.\\n\\n**DP CODE**\\n```\\nclass Solution {\\npublic:\\n\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m,vector<int>(n,1));\\n        {\\n            for(int  i = 1;i < m;i++)\\n            {\\n                for(int j = 1;j < n;j++)\\n                {\\n                    dp[i][j] = dp[i][j-1] + dp[i-1][j];\\n                }\\n            }\\n            return dp[m-1][n-1];\\n        }\\n    }\\n};\\n```\\n\\n\\n**Recursion + Memoization**\\n```\\nclass Solution {\\npublic:\\n    \\n    int giveMePathCount(int row, int col,int m, int  n, vector<vector<int>> &dp)\\n    {\\n        if(row >= m  || col >= n){\\n            return 0;\\n        }\\n        if(row == m - 1 && col == n - 1)\\n        {\\n            return 1;\\n        }\\n        \\n        if(dp[row][col] != -1)return dp[row][col];\\n        \\n        return dp[row][col] = giveMePathCount(row + 1, col, m, n, dp) + giveMePathCount(row, col + 1, m, n, dp);\\n    }\\n    \\n    int uniquePaths(int m, int n) \\n    {\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return giveMePathCount(0, 0, m, n, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m,vector<int>(n,1));\\n        {\\n            for(int  i = 1;i < m;i++)\\n            {\\n                for(int j = 1;j < n;j++)\\n                {\\n                    dp[i][j] = dp[i][j-1] + dp[i-1][j];\\n                }\\n            }\\n            return dp[m-1][n-1];\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int giveMePathCount(int row, int col,int m, int  n, vector<vector<int>> &dp)\\n    {\\n        if(row >= m  || col >= n){\\n            return 0;\\n        }\\n        if(row == m - 1 && col == n - 1)\\n        {\\n            return 1;\\n        }\\n        \\n        if(dp[row][col] != -1)return dp[row][col];\\n        \\n        return dp[row][col] = giveMePathCount(row + 1, col, m, n, dp) + giveMePathCount(row, col + 1, m, n, dp);\\n    }\\n    \\n    int uniquePaths(int m, int n) \\n    {\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return giveMePathCount(0, 0, m, n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126442,
                "title": "faster-than-100-c-java-both",
                "content": "*Brut-Forces ( It\\'s give TLE )*\\n```\\nclass Solution {\\npublic:\\n    int f(int i, int j){\\n        if(i==0 and j==0)   return 1;\\n        if(i<0 or j<0)    return 0;\\n        return f(i-1, j) + f(i, j-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return f(m-1, n-1);\\n    }\\n};\\n//*If you find helpful please upvote\\n```\\n\\n*Steps to memoize a recursive solution: O(N*M)*\\n```\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>> &dp){\\n        if(i==0 and j==0)   return 1;\\n        if(i<0 or j<0)    return 0;\\n        if(dp[i][j]!=-1)    return dp[i][j];\\n        \\n        return dp[i][j] = f(i-1, j, dp) + f(i, j-1, dp);\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return f(m-1, n-1, dp);\\n    }\\n\\t//*If you find helpful please upvote\\n};\\n```\\n\\n*Steps to convert Recursive Solution to Tabulation one.*\\n```\\nint uniquePaths(int m, int n) {\\n        int dp[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(i==0 and j==0) dp[i][j]=1;\\n                else{\\n                    int up=0, down=0;\\n                    if(i>0) up = dp[i-1][j];\\n                    if(j>0) down = dp[i][j-1];\\n                    dp[i][j]= up + down;\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n\\t\\t//*If you find helpful please upvote\\n    }\\n```\\n\\n*Space Optimization*\\n```\\nint countWays(int m, int n){\\n    vector<int> prev(n,0);\\n    for(int i=0; i<m; i++){\\n        vector<int> temp(n,0);\\n        for(int j=0; j<n; j++){\\n            if(i==0 && j==0){\\n                temp[j]=1;\\n                continue;\\n            }\\n            \\n            int up=0;\\n            int left =0;\\n            \\n            if(i>0)\\n                up = prev[j];\\n            if(j>0)\\n                left = temp[j-1];\\n                \\n            temp[j] = up + left;\\n        }\\n        prev = temp;\\n    }\\n    \\n    return prev[n-1];\\n    //*If you find helpful please upvote\\n}\\n```\\n\\nJava Code\\n```\\nstatic int countWaysUtil(int i, int j, int[][] dp) {\\n  if(i==0 && j == 0)\\n    return 1;\\n  if(i<0 || j<0)\\n    return 0;\\n  if(dp[i][j]!=-1) return dp[i][j];\\n    \\n  int up = countWaysUtil(i-1,j,dp);\\n  int left = countWaysUtil(i,j-1,dp);\\n  \\n  return dp[i][j] = up+left;\\n  \\n}\\n\\nstatic int countWays(int m, int n){\\n    int dp[][]=new int[m][n];\\n    for (int[] row : dp)\\n        Arrays.fill(row, -1);\\n    return countWaysUtil(m-1,n-1,dp);\\n    \\n\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i, int j){\\n        if(i==0 and j==0)   return 1;\\n        if(i<0 or j<0)    return 0;\\n        return f(i-1, j) + f(i, j-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return f(m-1, n-1);\\n    }\\n};\\n//*If you find helpful please upvote\\n```\n```\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>> &dp){\\n        if(i==0 and j==0)   return 1;\\n        if(i<0 or j<0)    return 0;\\n        if(dp[i][j]!=-1)    return dp[i][j];\\n        \\n        return dp[i][j] = f(i-1, j, dp) + f(i, j-1, dp);\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return f(m-1, n-1, dp);\\n    }\\n\\t//*If you find helpful please upvote\\n};\\n```\n```\\nint uniquePaths(int m, int n) {\\n        int dp[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(i==0 and j==0) dp[i][j]=1;\\n                else{\\n                    int up=0, down=0;\\n                    if(i>0) up = dp[i-1][j];\\n                    if(j>0) down = dp[i][j-1];\\n                    dp[i][j]= up + down;\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n\\t\\t//*If you find helpful please upvote\\n    }\\n```\n```\\nint countWays(int m, int n){\\n    vector<int> prev(n,0);\\n    for(int i=0; i<m; i++){\\n        vector<int> temp(n,0);\\n        for(int j=0; j<n; j++){\\n            if(i==0 && j==0){\\n                temp[j]=1;\\n                continue;\\n            }\\n            \\n            int up=0;\\n            int left =0;\\n            \\n            if(i>0)\\n                up = prev[j];\\n            if(j>0)\\n                left = temp[j-1];\\n                \\n            temp[j] = up + left;\\n        }\\n        prev = temp;\\n    }\\n    \\n    return prev[n-1];\\n    //*If you find helpful please upvote\\n}\\n```\n```\\nstatic int countWaysUtil(int i, int j, int[][] dp) {\\n  if(i==0 && j == 0)\\n    return 1;\\n  if(i<0 || j<0)\\n    return 0;\\n  if(dp[i][j]!=-1) return dp[i][j];\\n    \\n  int up = countWaysUtil(i-1,j,dp);\\n  int left = countWaysUtil(i,j-1,dp);\\n  \\n  return dp[i][j] = up+left;\\n  \\n}\\n\\nstatic int countWays(int m, int n){\\n    int dp[][]=new int[m][n];\\n    for (int[] row : dp)\\n        Arrays.fill(row, -1);\\n    return countWaysUtil(m-1,n-1,dp);\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466475,
                "title": "recursion-memoization-tabulation-c",
                "content": "**Plain Recursion**\\n```\\n// Given function\\nint uniquePaths(int m, int n)\\n{\\n\\t/* base condition */\\n    if (m == 1 or n == 1)\\n        return 1;\\n\\t\\n\\t/* recursive call*/\\n    return uniquePaths(m - 1, n) + uniquePaths(m, n - 1);\\n}\\n\\n// Driver code\\nint main()\\n{\\n\\t// Given numbers\\n    int m = 13, n = 11;\\n    cout << uniquePaths(m, n);  // 646646\\n}\\n```\\n\\n**Memoization**\\n\\n```\\n// Global memo array\\nint memo[100][100];\\n\\n// Given function\\nint uniquePaths(int m, int n)\\n{\\n    /* base condition */\\n    if (m == 1 or n == 1)\\n        return 1;\\n\\n    /* check in memo array */\\n    if (memo[m][n])\\n        return memo[m][n];\\n\\n    /* recursive call*/\\n    return uniquePaths(m - 1, n) + uniquePaths(m, n - 1);\\n}\\n\\n// Driver code\\nint main()\\n{\\n    // initialize memo arry\\n    memset(memo, 0, sizeof(memo));\\n\\n    // Given numbers\\n    int m = 13, n = 11;\\n    cout << uniquePaths(m, n);  // 646646\\n}\\n```\\n\\n**Tabulation**\\n\\n```\\n// Global dp array\\nint dp[100][100];\\n\\n// Given function\\nint uniquePaths(int m, int n)\\n{\\n    /* initialize first row and first column */\\n    for (int i = 0; i < m; i++)\\n        for (int j = 0; j < n; j++)\\n            if (i == 0 or j == 0)\\n                dp[i][j] = 1;\\n\\n    /* logic: */\\n    for (int i = 1; i < m; i++)\\n        for (int j = 1; j < n; j++)\\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n\\n    /* result */\\n    return dp[m - 1][n - 1];\\n}\\n\\n// Driver code\\nint main()\\n{\\n    // Given numers\\n    int m = 13, n = 11;\\n    cout << uniquePaths(m, n);  // 646646\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Given function\\nint uniquePaths(int m, int n)\\n{\\n\\t/* base condition */\\n    if (m == 1 or n == 1)\\n        return 1;\\n\\t\\n\\t/* recursive call*/\\n    return uniquePaths(m - 1, n) + uniquePaths(m, n - 1);\\n}\\n\\n// Driver code\\nint main()\\n{\\n\\t// Given numbers\\n    int m = 13, n = 11;\\n    cout << uniquePaths(m, n);  // 646646\\n}\\n```\n```\\n// Global memo array\\nint memo[100][100];\\n\\n// Given function\\nint uniquePaths(int m, int n)\\n{\\n    /* base condition */\\n    if (m == 1 or n == 1)\\n        return 1;\\n\\n    /* check in memo array */\\n    if (memo[m][n])\\n        return memo[m][n];\\n\\n    /* recursive call*/\\n    return uniquePaths(m - 1, n) + uniquePaths(m, n - 1);\\n}\\n\\n// Driver code\\nint main()\\n{\\n    // initialize memo arry\\n    memset(memo, 0, sizeof(memo));\\n\\n    // Given numbers\\n    int m = 13, n = 11;\\n    cout << uniquePaths(m, n);  // 646646\\n}\\n```\n```\\n// Global dp array\\nint dp[100][100];\\n\\n// Given function\\nint uniquePaths(int m, int n)\\n{\\n    /* initialize first row and first column */\\n    for (int i = 0; i < m; i++)\\n        for (int j = 0; j < n; j++)\\n            if (i == 0 or j == 0)\\n                dp[i][j] = 1;\\n\\n    /* logic: */\\n    for (int i = 1; i < m; i++)\\n        for (int j = 1; j < n; j++)\\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n\\n    /* result */\\n    return dp[m - 1][n - 1];\\n}\\n\\n// Driver code\\nint main()\\n{\\n    // Given numers\\n    int m = 13, n = 11;\\n    cout << uniquePaths(m, n);  // 646646\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1454615,
                "title": "from-recursive-to-dp-intuition-and-explanation",
                "content": "First, i will write down the most basic approach that might come to mind - checking all the combinations at first. At every point, we need to decide whether we go down or left, so let `i` be the x co-ordinate and `j` be the y co-ordinate. \\nSince we can move only right i.e `i` can increase or we can move down i.e. `j` can increase. \\nSo, at every point in the grid, we just have 2 choices - either to go `i+1` or to go `j+1`.\\n\\nRemember how I used the word \"or\". Since, we need to count the number of ways so the word \"or\" means `+` in numerical computations. \\nWhen do we stop? when either `i`reaches to last column or `j` reaches to last row. Hence, we have a base condition too and a logic.\\nThe recursive code:\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(int m, int n, int i, int j){\\n        if(i>=n || j>=m) return 0;\\n        if(i==n-1 && j==m-1) return 1;\\n        return solve(m,n,i+1,j) + solve(m,n,i,j+1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return solve(m,n,0,0);\\n    }\\n};\\n```\\n\\nThis will ofcourse give TLE. So, to convert to dp, a good rule of thumb would be `look before you leap` i.e. check if you have the ans in table, if yes, then return and if not, then go ahead compute a new answer and save it before returning.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(int m, int n, int i, int j){\\n        if(i>=n || j>=m) return 0;\\n        if(i==n-1 && j==m-1) return 1;\\n//         look before you leap\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        // save and return\\n        return dp[i][j]=solve(m,n,i+1,j) + solve(m,n,i,j+1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(m,n,0,0);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int m, int n, int i, int j){\\n        if(i>=n || j>=m) return 0;\\n        if(i==n-1 && j==m-1) return 1;\\n        return solve(m,n,i+1,j) + solve(m,n,i,j+1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return solve(m,n,0,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(int m, int n, int i, int j){\\n        if(i>=n || j>=m) return 0;\\n        if(i==n-1 && j==m-1) return 1;\\n//         look before you leap\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        // save and return\\n        return dp[i][j]=solve(m,n,i+1,j) + solve(m,n,i,j+1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(m,n,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112519,
                "title": "c-dp-100-faster-unique-paths",
                "content": "```int uniquePaths(int m, int n) {\\n        int dp[n][m];\\n        for(int  i = 0 ; i < m ; i++){\\n            dp[n-1][i] = 1;\\n        }\\n        for(int  i = 0 ; i < n ; i++){\\n            dp[i][m-1] = 1;\\n        }\\n        for(int  i = n-2 ; i>=0 ; i--){\\n            for(int  j = m-2 ; j>=0 ; j--){\\n                /*Total number of ways to reach (i,j) grid equal to\\n                Total no of ways to reach (i+1,j)+(i,j+1) grid*/\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n        return dp[0][0];\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```int uniquePaths(int m, int n) {\\n        int dp[n][m];\\n        for(int  i = 0 ; i < m ; i++){\\n            dp[n-1][i] = 1;\\n        }\\n        for(int  i = 0 ; i < n ; i++){\\n            dp[i][m-1] = 1;\\n        }\\n        for(int  i = n-2 ; i>=0 ; i--){\\n            for(int  j = m-2 ; j>=0 ; j--){\\n                /*Total number of ways to reach (i,j) grid equal to\\n                Total no of ways to reach (i+1,j)+(i,j+1) grid*/\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n        return dp[0][0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 983132,
                "title": "java-solution",
                "content": "java\\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        \\n        for(int i=0;i<n;i++)\\n            dp[0][i]=1;\\n        for(int i=0;i<m;i++)\\n            dp[i][0]=1;\\n        \\n        for(int i=1;i<m;i++) {\\n            for(int j=1;j<n;j++) {\\n                \\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        \\n        for(int i=0;i<n;i++)\\n            dp[0][i]=1;\\n        for(int i=0;i<m;i++)\\n            dp[i][0]=1;\\n        \\n        for(int i=1;i<m;i++) {\\n            for(int j=1;j<n;j++) {\\n                \\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711761,
                "title": "java-runtime-o-m-n-space-o-1-combinatorics-solution",
                "content": "This solution uses the combinatorics theorems to quickly calculate the number of unique paths. \\n\\nIn this problem, you\\'re limited to choosing a *right* move, or a *down* move - both of which take you in the right direction. There will be (n-1) *right moves* and (m-1) *down moves* in any path from start to finish. Let a *right move* be represented by the character `X` and a *down move* be represented by the character `O`. \\n\\n*Let m=3, n=4*.  The problem becomes *\"how many unique permutations of the String `\\'OOXXX\\'` exist?\"*\\n\\nThis is a well-studied and well-known problem in combinatorics and you may have studied this if you\\'ve taken a combinatorics class before. Here\\'s the theorem used to solve this problem. \\n![image](https://assets.leetcode.com/users/images/ffbeecd8-9f61-41c1-bbb3-f517c11d2c87_1593443864.6758277.png)\\n\\nNow for my code, there are cleaner ways to implement, and faster ways to implement, but this code is concise and clear. It is not difficult to follow what\\'s going on once you know the theorem being used.\\n```java\\nimport java.math.BigInteger;\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        //numerator = total moves! = ((m-1) + (n - 1))! = (m+n-2)! (as a BigInteger because factorials get out of hand quickly)\\n\\t\\t//BigInteger String constructor is easy to use. So we\\'ll convert the number to a String and pass to BigInteger constructor, which is sent to factorial function\\n        BigInteger numerator = bigFact(new BigInteger(String.valueOf(m + n - 2)));\\n\\t\\t\\n\\t\\t//we only have 2 classes of indistinguishable objects (down moves and right moves)\\n\\t\\t//denom1 is the first factorial of the denominator\\n        BigInteger denom1 = bigFact(new BigInteger(String.valueOf(m-1)));\\n\\t\\t\\n\\t\\t//denom2 is the second factorial of the denominator\\n        BigInteger denom2 = bigFact(new BigInteger(String.valueOf(n-1)));\\n\\t\\t\\n\\t\\t//denom is both denominator terms multiplied together\\n        BigInteger denom = denom1.multiply(denom2);\\n\\t\\t\\n\\t\\t//result is the numerator divided by the denominator (obviously)\\n        BigInteger result = numerator.divide(denom);\\n        return result.intValueExact();\\n    }\\n    \\n\\t//BigInteger Factorial function\\n    public static BigInteger bigFact(BigInteger number){\\n        BigInteger result = BigInteger.ONE;\\n        while(number.compareTo(BigInteger.ONE) > 0){\\n            result = result.multiply(number);\\n            number = number.subtract(BigInteger.ONE);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nimport java.math.BigInteger;\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        //numerator = total moves! = ((m-1) + (n - 1))! = (m+n-2)! (as a BigInteger because factorials get out of hand quickly)\\n\\t\\t//BigInteger String constructor is easy to use. So we\\'ll convert the number to a String and pass to BigInteger constructor, which is sent to factorial function\\n        BigInteger numerator = bigFact(new BigInteger(String.valueOf(m + n - 2)));\\n\\t\\t\\n\\t\\t//we only have 2 classes of indistinguishable objects (down moves and right moves)\\n\\t\\t//denom1 is the first factorial of the denominator\\n        BigInteger denom1 = bigFact(new BigInteger(String.valueOf(m-1)));\\n\\t\\t\\n\\t\\t//denom2 is the second factorial of the denominator\\n        BigInteger denom2 = bigFact(new BigInteger(String.valueOf(n-1)));\\n\\t\\t\\n\\t\\t//denom is both denominator terms multiplied together\\n        BigInteger denom = denom1.multiply(denom2);\\n\\t\\t\\n\\t\\t//result is the numerator divided by the denominator (obviously)\\n        BigInteger result = numerator.divide(denom);\\n        return result.intValueExact();\\n    }\\n    \\n\\t//BigInteger Factorial function\\n    public static BigInteger bigFact(BigInteger number){\\n        BigInteger result = BigInteger.ONE;\\n        while(number.compareTo(BigInteger.ONE) > 0){\\n            result = result.multiply(number);\\n            number = number.subtract(BigInteger.ONE);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362375,
                "title": "3-solutions-in-go-best-beats-100-time-space-dp",
                "content": "The **basic recursive approach** (time limit exceeded):\\n```\\nfunc uniquePathsRecurs(m int, n int) int {\\n    var explore func(i, j int) int\\n    explore = func(i, j int) int {\\n        if i == m && j == n {\\n            return 1\\n        }\\n        \\n        var iPaths, jPaths int\\n        if i < m {\\n            iPaths = explore(i+1, j) // move right\\n        }\\n        if j < n {\\n            jPaths = explore(i, j+1) // move down\\n        }\\n        return iPaths+jPaths\\n    }\\n    return explore(1, 1)\\n}\\n```\\n\\nThen, with **memoization**:\\n```\\nfunc uniquePathsMemo(m int, n int) int {\\n    paths := make([][]int, n)\\n    for i := 0; i < len(paths); i++ {\\n        paths[i] = make([]int, m)\\n    }\\n    paths[n-1][m-1] = 1\\n    \\n    var explore func(i, j int) int\\n    explore = func(i, j int) int {\\n        if paths[j][i] != 0 {\\n            return paths[j][i]\\n        }\\n        \\n        var iPaths, jPaths int\\n        if i < m-1 {\\n            iPaths = explore(i+1, j) // move right\\n        }\\n        if j < n-1 {\\n            jPaths = explore(i, j+1) // move down\\n        }\\n        paths[j][i] = iPaths+jPaths\\n        return iPaths+jPaths\\n    }\\n    return explore(0, 0)\\n}\\n```\\n\\nThen, with **Dynamic Programming** (bottom up processing):\\nTime: `O(m*n)`\\nSpace: `O(m*n)`\\n```\\nfunc uniquePathsDP(m int, n int) int {\\n   paths := make([][]int, n)\\n    for i := 0; i < len(paths); i++ {\\n        paths[i] = make([]int, m)\\n    }\\n    for i := 0; i < m; i++ {\\n        paths[0][i] = 1\\n    }\\n    for j := 1; j < n; j++ {\\n        paths[j][0] = 1\\n    }\\n    \\n    for i := 1; i < m; i++ {\\n        for j := 1; j < n; j++ {\\n            paths[j][i] = paths[j][i-1] + paths[j-1][i]\\n        }\\n    }\\n    \\n    return paths[n-1][m-1]\\n}\\n```\\n\\nAnd a **bonus**, moving `O(m*n)` space of the above to `O(n)`. This is based on the intuition that we only need to look at the current and previous rows when computing each cell.\\nTime: `O(m*n)`\\nSpace: `O(n)`\\n```\\nfunc uniquePaths(m int, n int) int {\\n    cur := make([]int, m)\\n    prev := make([]int, m)\\n    for i := 0; i < m; i++ {\\n        cur[i] = 1\\n        prev[i] = 1\\n    }\\n    \\n    for j := 1; j < n; j++ {\\n        for i := 1; i < m; i++ {\\n            cur[i] = cur[i-1] + prev[i]            \\n        }\\n        cur, prev = prev, cur\\n    }\\n    return prev[m-1]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc uniquePathsRecurs(m int, n int) int {\\n    var explore func(i, j int) int\\n    explore = func(i, j int) int {\\n        if i == m && j == n {\\n            return 1\\n        }\\n        \\n        var iPaths, jPaths int\\n        if i < m {\\n            iPaths = explore(i+1, j) // move right\\n        }\\n        if j < n {\\n            jPaths = explore(i, j+1) // move down\\n        }\\n        return iPaths+jPaths\\n    }\\n    return explore(1, 1)\\n}\\n```\n```\\nfunc uniquePathsMemo(m int, n int) int {\\n    paths := make([][]int, n)\\n    for i := 0; i < len(paths); i++ {\\n        paths[i] = make([]int, m)\\n    }\\n    paths[n-1][m-1] = 1\\n    \\n    var explore func(i, j int) int\\n    explore = func(i, j int) int {\\n        if paths[j][i] != 0 {\\n            return paths[j][i]\\n        }\\n        \\n        var iPaths, jPaths int\\n        if i < m-1 {\\n            iPaths = explore(i+1, j) // move right\\n        }\\n        if j < n-1 {\\n            jPaths = explore(i, j+1) // move down\\n        }\\n        paths[j][i] = iPaths+jPaths\\n        return iPaths+jPaths\\n    }\\n    return explore(0, 0)\\n}\\n```\n```\\nfunc uniquePathsDP(m int, n int) int {\\n   paths := make([][]int, n)\\n    for i := 0; i < len(paths); i++ {\\n        paths[i] = make([]int, m)\\n    }\\n    for i := 0; i < m; i++ {\\n        paths[0][i] = 1\\n    }\\n    for j := 1; j < n; j++ {\\n        paths[j][0] = 1\\n    }\\n    \\n    for i := 1; i < m; i++ {\\n        for j := 1; j < n; j++ {\\n            paths[j][i] = paths[j][i-1] + paths[j-1][i]\\n        }\\n    }\\n    \\n    return paths[n-1][m-1]\\n}\\n```\n```\\nfunc uniquePaths(m int, n int) int {\\n    cur := make([]int, m)\\n    prev := make([]int, m)\\n    for i := 0; i < m; i++ {\\n        cur[i] = 1\\n        prev[i] = 1\\n    }\\n    \\n    for j := 1; j < n; j++ {\\n        for i := 1; i < m; i++ {\\n            cur[i] = cur[i-1] + prev[i]            \\n        }\\n        cur, prev = prev, cur\\n    }\\n    return prev[m-1]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 329894,
                "title": "c-top-down-memoized-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int paths(int i, int j, int m, int n, vector<vector<int>>& dp)\\n    {\\n        if (i >= m || j >= n)\\n            return 0;\\n        if (i == m - 1 || j == n - 1)\\n            return 1;\\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n        dp[i][j] = paths(i + 1, j, m, n, dp) + paths(i, j + 1, m, n, dp);\\n        return dp[i][j];\\n    }\\n    int uniquePaths(int m, int n) {\\n       vector<vector<int>> dp(m, vector<int>(n, -1));\\n       return paths(0, 0, m, n, dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int paths(int i, int j, int m, int n, vector<vector<int>>& dp)\\n    {\\n        if (i >= m || j >= n)\\n            return 0;\\n        if (i == m - 1 || j == n - 1)\\n            return 1;\\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n        dp[i][j] = paths(i + 1, j, m, n, dp) + paths(i, j + 1, m, n, dp);\\n        return dp[i][j];\\n    }\\n    int uniquePaths(int m, int n) {\\n       vector<vector<int>> dp(m, vector<int>(n, -1));\\n       return paths(0, 0, m, n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 326002,
                "title": "go-100",
                "content": "```\\nfunc uniquePaths(m int, n int) int {\\n    \\n    result := make([][]int, m)\\n    for i:=0; i<m; i++{\\n        result[i] = make([]int,n)\\n    }\\n    \\n    for i:=0; i<m;i++{\\n        result[i][0] = 1\\n    }\\n    \\n    for j:=1; j<n; j++{\\n        result[0][j] = 1\\n    }\\n    \\n    \\n    for i:=1;i<m; i++{\\n        for j:=1; j<n; j++{\\n            result[i][j] = result[i-1][j] + result[i][j-1]\\n        }\\n    }\\n    return result[m-1][n-1]\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc uniquePaths(m int, n int) int {\\n    \\n    result := make([][]int, m)\\n    for i:=0; i<m; i++{\\n        result[i] = make([]int,n)\\n    }\\n    \\n    for i:=0; i<m;i++{\\n        result[i][0] = 1\\n    }\\n    \\n    for j:=1; j<n; j++{\\n        result[0][j] = 1\\n    }\\n    \\n    \\n    for i:=1;i<m; i++{\\n        for j:=1; j<n; j++{\\n            result[i][j] = result[i-1][j] + result[i][j-1]\\n        }\\n    }\\n    return result[m-1][n-1]\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 298244,
                "title": "python-simple-1-line-solution-based-on-permutation",
                "content": "We can handle this poblem by using permutations. suppose we have 7x3 grid. So, we have to move right 6 times and down 2 times. Now, the problem is reduced to how we can arrange 6 right moves and 2 down move. This will be (6+2)! / (6! * 2!) = 8! / (6! * 2!) = 28.\\nso the formula we get is (m-1 + n-1)! / ((m-1)! * (n-1)!)\\n```\\nimport math\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        return int(math.factorial(m+n-2)/(math.factorial(m-1)*math.factorial(n-1)))\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        return int(math.factorial(m+n-2)/(math.factorial(m-1)*math.factorial(n-1)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257504,
                "title": "python-concise-dp-solution-with-accumulate-4-lines",
                "content": "Firstly, we can maintain a 2d matrix to store the ans.\\n\\u9996\\u5148\\u6211\\u4EEC\\u53EF\\u4EE5\\u7528\\u4E00\\u4E2A\\u4E8C\\u7EF4\\u6570\\u7EC4\\u6765\\u4FDD\\u5B58\\u6BCF\\u4E2A\\u5355\\u5143\\u683C\\u7684\\u8D70\\u6CD5\\u3002\\n```python\\ndef uniquePaths(self, m: int, n: int) -> int:\\n    g = [[0] * m for _ in range(n)]\\n    for i in range(n):\\n        for j in range(m):\\n            if i==0 or j==0:\\n                g[i][j] = 1\\n            else:\\n                g[i][j] = g[i-1][j] + g[i][j-1]\\n        \\n    return g[-1][-1]\\n```\\nbut, 2d-matrix is unnecessary. We only need the last row to caculate current row.\\n\\u4E8C\\u7EF4\\u6570\\u7EC4\\u662F\\u6CA1\\u6709\\u5FC5\\u8981\\u7684\\uFF0C\\u5B9E\\u9645\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u6839\\u636E\\u4E0A\\u4E00\\u884C\\u6765\\u8BA1\\u7B97\\u5F53\\u524D\\u884C\\u3002\\ni.e.  m = 7, n = 3\\nthe matix is \\n```\\n[1,  1,  1,   1,   1,   1,   1]\\n[1,  2,  3,   4,   5,   6,   7]\\n[1,  3,  6,  10,  15,  21,  28]\\n```\\nThat is what the `accumulate` does.\\n`accumulate`\\u505A\\u7684\\u4E8B\\u60C5\\u5C31\\u662F\\u628A\\u5DE6\\u8FB9\\u7684\\u503C\\u548C\\u5F53\\u524D\\u503C\\u7D2F\\u8BA1\\u3002\\n```python\\ndef uniquePaths(self, m: int, n: int) -> int:\\n    row = [1] * m\\n    for _ in range(n-1):\\n        row = itertools.accumulate(row)\\n    return list(row)[-1]\\n```\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\ndef uniquePaths(self, m: int, n: int) -> int:\\n    g = [[0] * m for _ in range(n)]\\n    for i in range(n):\\n        for j in range(m):\\n            if i==0 or j==0:\\n                g[i][j] = 1\\n            else:\\n                g[i][j] = g[i-1][j] + g[i][j-1]\\n        \\n    return g[-1][-1]\\n```\n```\\n[1,  1,  1,   1,   1,   1,   1]\\n[1,  2,  3,   4,   5,   6,   7]\\n[1,  3,  6,  10,  15,  21,  28]\\n```\n```python\\ndef uniquePaths(self, m: int, n: int) -> int:\\n    row = [1] * m\\n    for _ in range(n-1):\\n        row = itertools.accumulate(row)\\n    return list(row)[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 162333,
                "title": "python-solution",
                "content": "Dynamic programming: O(mn) time O(mn) space\\n```\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        table = [[0]*n for _ in range(m)]\\n        for i in range(n):\\n            table[0][i] = 1\\n        for j in range(m):\\n            table[j][0] = 1\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                table[i][j] = table[i-1][j] + table[i][j-1]\\n        return table[m-1][n-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        table = [[0]*n for _ in range(m)]\\n        for i in range(n):\\n            table[0][i] = 1\\n        for j in range(m):\\n            table[j][0] = 1\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                table[i][j] = table[i-1][j] + table[i][j-1]\\n        return table[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23040,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Unique Paths** https://leetcode.com/problems/unique-paths/\\n\\n**Dynamic Programming using Memoization**\\n* path[i,j] = Number of paths from [i,j] to destination\\n* path[m-1,n-1] = 1\\n* return path[0,0]\\n```\\nclass Solution(object):\\n    def helper(self, i, j, m, n, paths):\\n        if 0<=i<m and 0<=j<n:\\n            if paths[i][j] != -1:\\n                return paths[i][j]\\n            paths[i][j] = self.helper(i, j+1, m, n, paths) + self.helper(i+1, j, m, n, paths)\\n            return paths[i][j]\\n        return 0\\n    \\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if m == 0 or n == 0:\\n            return 0\\n        paths = [[-1]*n for _ in range(m)]\\n        paths[m-1][n-1] = 1\\n        return self.helper(0, 0, m, n, paths)\\n```\\n\\n**Dynamic Programming without Recursion**\\n* path[i,j] = Number of paths from [0,0] to [i,j].\\n* path[0,j] = 1 and path[i,0] = 1\\n* path[i,j] = path[i,j-1] + path[i-1,j]\\n* return path[m-1, n-1]\\n* We can start from row 1 and column 1 after initializing the path matrix to 1.\\n* Time and Space complexity: O(MN)\\n```\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if m == 0 or n == 0:\\n            return 0\\n        paths = [[1]*n for _ in range(m)]\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                paths[i][j] = paths[i-1][j] + paths[i][j-1]\\n        return paths[-1][-1]\\n```\\n\\n**Dynamic Programming without Recursion * Optimization**\\n* Optimization: Instead of 2D matrix, a single array can do the job and reduce space complexity to O(N)\\n```\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if m == 0 or n == 0:\\n            return 0\\n        dp = [1]*n\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                dp[j] = dp[j-1] + dp[j]\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def helper(self, i, j, m, n, paths):\\n        if 0<=i<m and 0<=j<n:\\n            if paths[i][j] != -1:\\n                return paths[i][j]\\n            paths[i][j] = self.helper(i, j+1, m, n, paths) + self.helper(i+1, j, m, n, paths)\\n            return paths[i][j]\\n        return 0\\n    \\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if m == 0 or n == 0:\\n            return 0\\n        paths = [[-1]*n for _ in range(m)]\\n        paths[m-1][n-1] = 1\\n        return self.helper(0, 0, m, n, paths)\\n```\n```\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if m == 0 or n == 0:\\n            return 0\\n        paths = [[1]*n for _ in range(m)]\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                paths[i][j] = paths[i-1][j] + paths[i][j-1]\\n        return paths[-1][-1]\\n```\n```\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if m == 0 or n == 0:\\n            return 0\\n        dp = [1]*n\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                dp[j] = dp[j-1] + dp[j]\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23106,
                "title": "similar-to-pascal-triangle-o-1-space-and-o-min-m-n-solution-with-image-explanation",
                "content": "![enter image description here][1]\\n\\n\\n  [1]: http://uiinventory.netne.net/LC_62.png\\n\\n    import java.math.BigInteger;\\n    \\n    public class Solution {\\n        \\n        private int comb(int n, int k) {\\n            long r = 1;\\n            for(int d = 1; d <= k; ++d) r = r * n-- / d;\\n            return (int)r;\\n        }\\n        \\n        public int uniquePaths(int m, int n) {\\n            return comb(m + n - 2, Math.min(n - 1, m - 1));\\n        }\\n    }",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n        \\n        private int comb(int n, int k) {\\n            long r = 1;\\n            for(int d = 1; d <= k; ++d) r = r * n-- / d;\\n            return (int)r;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3997007,
                "title": "clean-and-understandable-java-sol-optimised",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: Tabulation\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(m X n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m X n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int uniquePaths(int m, int n) {\\n     int[][] dp = new int[m][n];\\n     for(int i=0; i<m ;i++){\\n      for(int j=0; j<n; j++){\\n          \\n          //base condition\\n          if(i==0 && j==0){\\n              dp[i][j]=1;\\n              continue;\\n          }\\n          \\n          int up=0;\\n          int left = 0;\\n          \\n          if(i>0) \\n            up = dp[i-1][j];\\n          if(j>0)\\n            left = dp[i][j-1];\\n            \\n          dp[i][j] = up+left;\\n      }\\n  }\\n  \\n  return dp[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int uniquePaths(int m, int n) {\\n     int[][] dp = new int[m][n];\\n     for(int i=0; i<m ;i++){\\n      for(int j=0; j<n; j++){\\n          \\n          //base condition\\n          if(i==0 && j==0){\\n              dp[i][j]=1;\\n              continue;\\n          }\\n          \\n          int up=0;\\n          int left = 0;\\n          \\n          if(i>0) \\n            up = dp[i-1][j];\\n          if(j>0)\\n            left = dp[i][j-1];\\n            \\n          dp[i][j] = up+left;\\n      }\\n  }\\n  \\n  return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995616,
                "title": "easiest-python-solution-for-beginners-using-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The problem can be approached as a dynamic programming problem.\\n- We can calculate the number of unique paths for each cell in the grid          by summing the paths coming from the cell above it and the cell to its left.\\n        \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Define a helper function `check(i, j)` to check if a cell is within the grid.\\n- Use memoization with the `@lru_cache` decorator to optimize the recursive approach.\\n- Implement a recursive function `helper(i, j)` to calculate the number of unique paths.\\n- Start from the top-left corner (0, 0) and recursively explore all possible paths.\\n- Memoize the results to avoid redundant calculations.\\n        \\n# Complexity\\n- Time complexity:$$O(m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(m * n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        # Helper function to check if a cell is within the grid\\n        def check(i, j):\\n            if i < 0 or j < 0 or i >= m or j >= n:\\n                return False\\n            return True\\n        \\n        # Recursive function with memoization\\n        @lru_cache(maxsize=None)\\n        def helper(i, j):\\n            if not check(i, j):\\n                return 0\\n            else:\\n                if j == n - 1 and i == m - 1:\\n                    return 1\\n                else:\\n                    # Move right (i, j+1) and move down (i+1, j)\\n                    return helper(i + 1, j) + helper(i, j + 1)\\n\\n        # Start from the top-left corner\\n        return helper(0, 0)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        # Helper function to check if a cell is within the grid\\n        def check(i, j):\\n            if i < 0 or j < 0 or i >= m or j >= n:\\n                return False\\n            return True\\n        \\n        # Recursive function with memoization\\n        @lru_cache(maxsize=None)\\n        def helper(i, j):\\n            if not check(i, j):\\n                return 0\\n            else:\\n                if j == n - 1 and i == m - 1:\\n                    return 1\\n                else:\\n                    # Move right (i, j+1) and move down (i+1, j)\\n                    return helper(i + 1, j) + helper(i, j + 1)\\n\\n        # Start from the top-left corner\\n        return helper(0, 0)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730915,
                "title": "4-different-codes-recursion-memoisation-tabulation-space-optimisation",
                "content": "# Intuition\\nSince we can only move right or down, If we only have one row or one column then only one way is possible. Now this can be used as the base case and i can work my way up from the goal\\n\\n# Recursive Approach\\n**Will give TLE**\\nStart from the goal coordinates and either go left or move up, till you either reach the first row or first column and we already know only one way is possible to get there so return from there.\\nAt any given coordinate our answer will be the sum of the moves required to reach the coordinate just above it and just to its left.\\n# Complexity\\n- Time complexity: O(2**N)\\n\\n- Space complexity: Please help with the space complexity if possible\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int m, int n) {\\n        if (m < 0 || n < 0) {\\n            return 0;\\n        }\\n        if (n == 0 || m == 0) {\\n            return 1;\\n        }\\n        return solve(m-1, n) + solve(m, n-1);\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        return solve(m-1, n-1);\\n    }\\n};\\n```\\n# Memoisation\\nAs evident from the recursive solution two variables are changing i.e. the row coordinate and the column coordinate.\\nThis makes it a problem of 2D dp.\\nMemoisation required 3 main steps :\\n1. Create a vector of appropriate dimensions\\n2. Store the answer in the vector\\n3. Check if answer to current subproblem is already present and return it.\\n# Complexity\\n- Time complexity: O(N*N)\\n\\n- Space complexity: O(N*N)\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int m, int n, vector<vector<int>>& dp) {\\n        if (m < 0 || n < 0) {\\n            return 0;\\n        }\\n        if (n == 0 || m == 0) {\\n            return 1;\\n        }\\n        <!-- check if answer already present -->\\n        if (dp[m][n] != 0) {\\n            return dp[m][n];\\n        }\\n        <!-- store calculated answer -->\\n        dp[m][n] = solve(m-1, n, dp) + solve(m, n-1, dp);\\n        return dp[m][n];\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        <!-- make vector where each coordinate represents ways to reach it-->\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        return solve(m-1, n-1, dp);\\n    }\\n};\\n```\\n# Tabulation\\nInstead of using recursive calls use for loop to traverse the matrix and fill values. Use the base case properly i.e. the value in the first column and row should be 1.\\n# Complexity\\n- Time complexity: O(N*N)\\n\\n- Space complexity: O(N*N)\\n# Code \\n```\\nclass Solution {\\nprivate:\\n    int solve(int m, int n) {\\n        vector<vector<int>> dp(m+1, vector<int>(n+1,1));\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        return dp[m][n];\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        return solve(m-1, n-1);\\n    }\\n};\\n```\\n# Space optimisation\\nOn careful observation we can see that only two 1D vectors are required to store the answer as current answer depends on the answer of the previous row and previous column(but same row). In the previous row everywhere you see dp[i] swap it with CurrRow and everywhere you see dp[i-1] swap with previous row. At the end of the iteration swap with previous and current row vectors to prepare for the next iteration \\n# Complexity\\n- Time complexity: O(N*N)\\n\\n- Space complexity: O(N)\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int m, int n) {\\n        // vector<vector<int>> dp(m+1, vector<int>(n+1,1));\\n        vector<int> prevRow(n+1,1);\\n        for (int i = 1; i <= m; i++) {\\n            vector<int> currRow(n+1);\\n            currRow[0] = 1;\\n            for (int j = 1; j <= n; j++) {\\n                currRow[j] = prevRow[j] + currRow[j-1];\\n            }\\n            prevRow = currRow;\\n        }\\n        return prevRow[n];\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        return solve(m-1, n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int m, int n) {\\n        if (m < 0 || n < 0) {\\n            return 0;\\n        }\\n        if (n == 0 || m == 0) {\\n            return 1;\\n        }\\n        return solve(m-1, n) + solve(m, n-1);\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        return solve(m-1, n-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int m, int n, vector<vector<int>>& dp) {\\n        if (m < 0 || n < 0) {\\n            return 0;\\n        }\\n        if (n == 0 || m == 0) {\\n            return 1;\\n        }\\n        <!-- check if answer already present -->\\n        if (dp[m][n] != 0) {\\n            return dp[m][n];\\n        }\\n        <!-- store calculated answer -->\\n        dp[m][n] = solve(m-1, n, dp) + solve(m, n-1, dp);\\n        return dp[m][n];\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        <!-- make vector where each coordinate represents ways to reach it-->\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        return solve(m-1, n-1, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int m, int n) {\\n        vector<vector<int>> dp(m+1, vector<int>(n+1,1));\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        return dp[m][n];\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        return solve(m-1, n-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int m, int n) {\\n        // vector<vector<int>> dp(m+1, vector<int>(n+1,1));\\n        vector<int> prevRow(n+1,1);\\n        for (int i = 1; i <= m; i++) {\\n            vector<int> currRow(n+1);\\n            currRow[0] = 1;\\n            for (int j = 1; j <= n; j++) {\\n                currRow[j] = prevRow[j] + currRow[j-1];\\n            }\\n            prevRow = currRow;\\n        }\\n        return prevRow[n];\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        return solve(m-1, n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680395,
                "title": "c-solution-dp-100-beat-with-3-approach",
                "content": "\\n\\n# Approach\\nIf the recusrion code is correct but the time limit is exceeded due to an overlapping problem, we can use the top down and bottom up approaches in the DP question. First, try the top down approach, and then try the bottom up approach.\\n\\n    any DP questions to be answered follow this flow. \\n\\n# recusrive soltution (time limit exceeded)\\n```\\n class Solution {\\n public:\\n     int uniquePaths(int m, int n) {\\n         vector<int>dp()\\n         return helper(m, n);\\n     }\\n\\n private:\\n     int helper(int m, int n) {\\n         if (m == 1 && n == 1)\\n             return 1;\\n         if (m < 1 || n < 1)\\n             return 0;\\n\\n         int count = 0;\\n         count += helper(m - 1, n);\\n         count += helper(m, n - 1);\\n\\n         return count;\\n     }\\n };\\n\\n\\n```\\n# top-down approach \\n```\\nclass Solution {\\n public:\\n     int uniquePaths(int m, int n) {\\n         vector<vector<int>> dp(m + 1, vector<int>(n + 1, -1));\\n         return helper(m, n, dp);\\n     }\\n\\n private:\\n     int helper(int m, int n, vector<vector<int>>& dp) {\\n         if (m == 1 && n == 1) return 1;\\n         if (m < 1 || n < 1) return 0;\\n         if (dp[m][n] != -1) return dp[m][n];\\n\\n         int count = 0;\\n         count += helper(m - 1, n, dp);\\n         count += helper(m, n - 1, dp);\\n\\n         return dp[m][n] = count;\\n     }\\n };\\n```\\n# bottom-up approach \\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j == 0) continue;\\n                int count = 0;\\n                if (j - 1 >= 0) count += dp[i][j - 1];\\n                if (i - 1 >= 0) count += dp[i - 1][j];\\n                dp[i][j] = count;\\n            }\\n        }\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n class Solution {\\n public:\\n     int uniquePaths(int m, int n) {\\n         vector<int>dp()\\n         return helper(m, n);\\n     }\\n\\n private:\\n     int helper(int m, int n) {\\n         if (m == 1 && n == 1)\\n             return 1;\\n         if (m < 1 || n < 1)\\n             return 0;\\n\\n         int count = 0;\\n         count += helper(m - 1, n);\\n         count += helper(m, n - 1);\\n\\n         return count;\\n     }\\n };\\n\\n\\n```\n```\\nclass Solution {\\n public:\\n     int uniquePaths(int m, int n) {\\n         vector<vector<int>> dp(m + 1, vector<int>(n + 1, -1));\\n         return helper(m, n, dp);\\n     }\\n\\n private:\\n     int helper(int m, int n, vector<vector<int>>& dp) {\\n         if (m == 1 && n == 1) return 1;\\n         if (m < 1 || n < 1) return 0;\\n         if (dp[m][n] != -1) return dp[m][n];\\n\\n         int count = 0;\\n         count += helper(m - 1, n, dp);\\n         count += helper(m, n - 1, dp);\\n\\n         return dp[m][n] = count;\\n     }\\n };\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j == 0) continue;\\n                int count = 0;\\n                if (j - 1 >= 0) count += dp[i][j - 1];\\n                if (i - 1 >= 0) count += dp[i - 1][j];\\n                dp[i][j] = count;\\n            }\\n        }\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569630,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 2041560,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1771537,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1572401,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1569205,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1574527,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1565160,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1575649,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1567179,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1566319,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1569630,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 2041560,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1771537,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1572401,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1569205,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1574527,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1565160,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1575649,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1567179,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1566319,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1576421,
                "content": [
                    {
                        "username": "mkbari5",
                        "content": "![image](https://assets.leetcode.com/users/images/10b1134d-5697-4789-92ca-2ab39090da32_1645349752.5808718.png)\\n"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "The answer is 1 because there is only one way to reach the destination which is just staying there. The answer will be 0 if and only if there is no way to reach destination."
                    },
                    {
                        "username": "lakshyakumartiwari",
                        "content": "// 100% beat solution using combination\\n/** we can also solve it by creating sieve of array but it is less efficient as of space complexity while is doing competitive programming it is preffered to pre compute factorial and power using fermit theorem (numbe^mod-2) for handling division modulo\\n**/\\nclass Solution {\\npublic:\\n   int uniquePaths(int m, int n) {\\n\\t\\tint N = n+m-2,R = min(n-1,m-1);\\n\\t\\tdouble result = 1;\\n\\t\\tfor(int i = 0; i < min(n-1,m-1); i++)\\n\\t\\t\\t\\tresult = result * N-- / R--;\\n\\t\\treturn round(result);\\n   }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you know that there is a Solutions section here? :)"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Any Dp with grid Question Exists:\\n\\n<a href=\"https://imgur.com/naclXcE\"><img src=\"https://i.imgur.com/naclXcE.jpg\" title=\"source: imgur.com\" width=\"350px\"/></a>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "psionl0",
                        "content": "By my calculation, using Pascal's triangle to calculate ``combin(n,r)`` has an ``O(n * k)`` run time and a space penalty of ``O(k)`` where ``k = min(r, n-r)``. Using multiplication we can get the time complexity down to ``O(k)``."
                    },
                    {
                        "username": "aneeshakella17",
                        "content": "Hello, \\nI was wondering why BFS doesn\\'t work here?"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@slnarasim92](/slnarasim92) If there are too many paths to report without taking MOD 1e9+7 remainders, then there are too many to count one by one in a search.  "
                    },
                    {
                        "username": "slnarasim92",
                        "content": "getting time limit exceeded for backtracking based approach as well"
                    },
                    {
                        "username": "pranjal_28",
                        "content": "This questions gave me nostalgia and all JEE aspirants will relate to it....we used to do this question in Permutations and Combinations in class 12th during our JEE preperation"
                    },
                    {
                        "username": "psionl0",
                        "content": "If I remember correctly, ``63. Unique Paths II`` was a daily problem on August 12, 2023 (a Saturday). This one is definitely not your usual type of Sunday problem."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "why can\\'t they just make row n and col m.\\nI got 2 typos and I spend my 20 mins finding why its showing runtime error.\\n\\n"
                    },
                    {
                        "username": "Joald",
                        "content": "We need to make m - 1 steps right and n - 1 steps down.\\nWe are asked for how many ways we can do that - that is, in how many different ways we can produce a sequence of that many of each step.\\nFor m = 4, n = 3, one such sequence is > \\\\\\\\/ > > \\\\\\\\/\\nSince we always have to make the same amount of steps (m + n - 2), we can treat steps as \"slots\", and one kind of arrow as \"chosen\" and the other as \"not chosen\". This means that all we need to calculate is how many ways we can choose a certain amount of arrows out of the pool of m + n - 2 arrows. \\nThe rest is left as an exercise for the reader."
                    },
                    {
                        "username": "purple329",
                        "content": "For the last test case, I got an wrong answer.\\n\\ninput:\\n1\\n1\\nOutput:\\n0\\nExpected:\\n1"
                    },
                    {
                        "username": "Joald",
                        "content": "There is exactly one path from each square to itself - the empty path."
                    }
                ]
            },
            {
                "id": 1760609,
                "content": [
                    {
                        "username": "mkbari5",
                        "content": "![image](https://assets.leetcode.com/users/images/10b1134d-5697-4789-92ca-2ab39090da32_1645349752.5808718.png)\\n"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "The answer is 1 because there is only one way to reach the destination which is just staying there. The answer will be 0 if and only if there is no way to reach destination."
                    },
                    {
                        "username": "lakshyakumartiwari",
                        "content": "// 100% beat solution using combination\\n/** we can also solve it by creating sieve of array but it is less efficient as of space complexity while is doing competitive programming it is preffered to pre compute factorial and power using fermit theorem (numbe^mod-2) for handling division modulo\\n**/\\nclass Solution {\\npublic:\\n   int uniquePaths(int m, int n) {\\n\\t\\tint N = n+m-2,R = min(n-1,m-1);\\n\\t\\tdouble result = 1;\\n\\t\\tfor(int i = 0; i < min(n-1,m-1); i++)\\n\\t\\t\\t\\tresult = result * N-- / R--;\\n\\t\\treturn round(result);\\n   }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you know that there is a Solutions section here? :)"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Any Dp with grid Question Exists:\\n\\n<a href=\"https://imgur.com/naclXcE\"><img src=\"https://i.imgur.com/naclXcE.jpg\" title=\"source: imgur.com\" width=\"350px\"/></a>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "psionl0",
                        "content": "By my calculation, using Pascal's triangle to calculate ``combin(n,r)`` has an ``O(n * k)`` run time and a space penalty of ``O(k)`` where ``k = min(r, n-r)``. Using multiplication we can get the time complexity down to ``O(k)``."
                    },
                    {
                        "username": "aneeshakella17",
                        "content": "Hello, \\nI was wondering why BFS doesn\\'t work here?"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@slnarasim92](/slnarasim92) If there are too many paths to report without taking MOD 1e9+7 remainders, then there are too many to count one by one in a search.  "
                    },
                    {
                        "username": "slnarasim92",
                        "content": "getting time limit exceeded for backtracking based approach as well"
                    },
                    {
                        "username": "pranjal_28",
                        "content": "This questions gave me nostalgia and all JEE aspirants will relate to it....we used to do this question in Permutations and Combinations in class 12th during our JEE preperation"
                    },
                    {
                        "username": "psionl0",
                        "content": "If I remember correctly, ``63. Unique Paths II`` was a daily problem on August 12, 2023 (a Saturday). This one is definitely not your usual type of Sunday problem."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "why can\\'t they just make row n and col m.\\nI got 2 typos and I spend my 20 mins finding why its showing runtime error.\\n\\n"
                    },
                    {
                        "username": "Joald",
                        "content": "We need to make m - 1 steps right and n - 1 steps down.\\nWe are asked for how many ways we can do that - that is, in how many different ways we can produce a sequence of that many of each step.\\nFor m = 4, n = 3, one such sequence is > \\\\\\\\/ > > \\\\\\\\/\\nSince we always have to make the same amount of steps (m + n - 2), we can treat steps as \"slots\", and one kind of arrow as \"chosen\" and the other as \"not chosen\". This means that all we need to calculate is how many ways we can choose a certain amount of arrows out of the pool of m + n - 2 arrows. \\nThe rest is left as an exercise for the reader."
                    },
                    {
                        "username": "purple329",
                        "content": "For the last test case, I got an wrong answer.\\n\\ninput:\\n1\\n1\\nOutput:\\n0\\nExpected:\\n1"
                    },
                    {
                        "username": "Joald",
                        "content": "There is exactly one path from each square to itself - the empty path."
                    }
                ]
            },
            {
                "id": 2041941,
                "content": [
                    {
                        "username": "mkbari5",
                        "content": "![image](https://assets.leetcode.com/users/images/10b1134d-5697-4789-92ca-2ab39090da32_1645349752.5808718.png)\\n"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "The answer is 1 because there is only one way to reach the destination which is just staying there. The answer will be 0 if and only if there is no way to reach destination."
                    },
                    {
                        "username": "lakshyakumartiwari",
                        "content": "// 100% beat solution using combination\\n/** we can also solve it by creating sieve of array but it is less efficient as of space complexity while is doing competitive programming it is preffered to pre compute factorial and power using fermit theorem (numbe^mod-2) for handling division modulo\\n**/\\nclass Solution {\\npublic:\\n   int uniquePaths(int m, int n) {\\n\\t\\tint N = n+m-2,R = min(n-1,m-1);\\n\\t\\tdouble result = 1;\\n\\t\\tfor(int i = 0; i < min(n-1,m-1); i++)\\n\\t\\t\\t\\tresult = result * N-- / R--;\\n\\t\\treturn round(result);\\n   }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you know that there is a Solutions section here? :)"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Any Dp with grid Question Exists:\\n\\n<a href=\"https://imgur.com/naclXcE\"><img src=\"https://i.imgur.com/naclXcE.jpg\" title=\"source: imgur.com\" width=\"350px\"/></a>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "psionl0",
                        "content": "By my calculation, using Pascal's triangle to calculate ``combin(n,r)`` has an ``O(n * k)`` run time and a space penalty of ``O(k)`` where ``k = min(r, n-r)``. Using multiplication we can get the time complexity down to ``O(k)``."
                    },
                    {
                        "username": "aneeshakella17",
                        "content": "Hello, \\nI was wondering why BFS doesn\\'t work here?"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@slnarasim92](/slnarasim92) If there are too many paths to report without taking MOD 1e9+7 remainders, then there are too many to count one by one in a search.  "
                    },
                    {
                        "username": "slnarasim92",
                        "content": "getting time limit exceeded for backtracking based approach as well"
                    },
                    {
                        "username": "pranjal_28",
                        "content": "This questions gave me nostalgia and all JEE aspirants will relate to it....we used to do this question in Permutations and Combinations in class 12th during our JEE preperation"
                    },
                    {
                        "username": "psionl0",
                        "content": "If I remember correctly, ``63. Unique Paths II`` was a daily problem on August 12, 2023 (a Saturday). This one is definitely not your usual type of Sunday problem."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "why can\\'t they just make row n and col m.\\nI got 2 typos and I spend my 20 mins finding why its showing runtime error.\\n\\n"
                    },
                    {
                        "username": "Joald",
                        "content": "We need to make m - 1 steps right and n - 1 steps down.\\nWe are asked for how many ways we can do that - that is, in how many different ways we can produce a sequence of that many of each step.\\nFor m = 4, n = 3, one such sequence is > \\\\\\\\/ > > \\\\\\\\/\\nSince we always have to make the same amount of steps (m + n - 2), we can treat steps as \"slots\", and one kind of arrow as \"chosen\" and the other as \"not chosen\". This means that all we need to calculate is how many ways we can choose a certain amount of arrows out of the pool of m + n - 2 arrows. \\nThe rest is left as an exercise for the reader."
                    },
                    {
                        "username": "purple329",
                        "content": "For the last test case, I got an wrong answer.\\n\\ninput:\\n1\\n1\\nOutput:\\n0\\nExpected:\\n1"
                    },
                    {
                        "username": "Joald",
                        "content": "There is exactly one path from each square to itself - the empty path."
                    }
                ]
            },
            {
                "id": 1917677,
                "content": [
                    {
                        "username": "mkbari5",
                        "content": "![image](https://assets.leetcode.com/users/images/10b1134d-5697-4789-92ca-2ab39090da32_1645349752.5808718.png)\\n"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "The answer is 1 because there is only one way to reach the destination which is just staying there. The answer will be 0 if and only if there is no way to reach destination."
                    },
                    {
                        "username": "lakshyakumartiwari",
                        "content": "// 100% beat solution using combination\\n/** we can also solve it by creating sieve of array but it is less efficient as of space complexity while is doing competitive programming it is preffered to pre compute factorial and power using fermit theorem (numbe^mod-2) for handling division modulo\\n**/\\nclass Solution {\\npublic:\\n   int uniquePaths(int m, int n) {\\n\\t\\tint N = n+m-2,R = min(n-1,m-1);\\n\\t\\tdouble result = 1;\\n\\t\\tfor(int i = 0; i < min(n-1,m-1); i++)\\n\\t\\t\\t\\tresult = result * N-- / R--;\\n\\t\\treturn round(result);\\n   }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you know that there is a Solutions section here? :)"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Any Dp with grid Question Exists:\\n\\n<a href=\"https://imgur.com/naclXcE\"><img src=\"https://i.imgur.com/naclXcE.jpg\" title=\"source: imgur.com\" width=\"350px\"/></a>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "psionl0",
                        "content": "By my calculation, using Pascal's triangle to calculate ``combin(n,r)`` has an ``O(n * k)`` run time and a space penalty of ``O(k)`` where ``k = min(r, n-r)``. Using multiplication we can get the time complexity down to ``O(k)``."
                    },
                    {
                        "username": "aneeshakella17",
                        "content": "Hello, \\nI was wondering why BFS doesn\\'t work here?"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@slnarasim92](/slnarasim92) If there are too many paths to report without taking MOD 1e9+7 remainders, then there are too many to count one by one in a search.  "
                    },
                    {
                        "username": "slnarasim92",
                        "content": "getting time limit exceeded for backtracking based approach as well"
                    },
                    {
                        "username": "pranjal_28",
                        "content": "This questions gave me nostalgia and all JEE aspirants will relate to it....we used to do this question in Permutations and Combinations in class 12th during our JEE preperation"
                    },
                    {
                        "username": "psionl0",
                        "content": "If I remember correctly, ``63. Unique Paths II`` was a daily problem on August 12, 2023 (a Saturday). This one is definitely not your usual type of Sunday problem."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "why can\\'t they just make row n and col m.\\nI got 2 typos and I spend my 20 mins finding why its showing runtime error.\\n\\n"
                    },
                    {
                        "username": "Joald",
                        "content": "We need to make m - 1 steps right and n - 1 steps down.\\nWe are asked for how many ways we can do that - that is, in how many different ways we can produce a sequence of that many of each step.\\nFor m = 4, n = 3, one such sequence is > \\\\\\\\/ > > \\\\\\\\/\\nSince we always have to make the same amount of steps (m + n - 2), we can treat steps as \"slots\", and one kind of arrow as \"chosen\" and the other as \"not chosen\". This means that all we need to calculate is how many ways we can choose a certain amount of arrows out of the pool of m + n - 2 arrows. \\nThe rest is left as an exercise for the reader."
                    },
                    {
                        "username": "purple329",
                        "content": "For the last test case, I got an wrong answer.\\n\\ninput:\\n1\\n1\\nOutput:\\n0\\nExpected:\\n1"
                    },
                    {
                        "username": "Joald",
                        "content": "There is exactly one path from each square to itself - the empty path."
                    }
                ]
            },
            {
                "id": 1572008,
                "content": [
                    {
                        "username": "mkbari5",
                        "content": "![image](https://assets.leetcode.com/users/images/10b1134d-5697-4789-92ca-2ab39090da32_1645349752.5808718.png)\\n"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "The answer is 1 because there is only one way to reach the destination which is just staying there. The answer will be 0 if and only if there is no way to reach destination."
                    },
                    {
                        "username": "lakshyakumartiwari",
                        "content": "// 100% beat solution using combination\\n/** we can also solve it by creating sieve of array but it is less efficient as of space complexity while is doing competitive programming it is preffered to pre compute factorial and power using fermit theorem (numbe^mod-2) for handling division modulo\\n**/\\nclass Solution {\\npublic:\\n   int uniquePaths(int m, int n) {\\n\\t\\tint N = n+m-2,R = min(n-1,m-1);\\n\\t\\tdouble result = 1;\\n\\t\\tfor(int i = 0; i < min(n-1,m-1); i++)\\n\\t\\t\\t\\tresult = result * N-- / R--;\\n\\t\\treturn round(result);\\n   }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you know that there is a Solutions section here? :)"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Any Dp with grid Question Exists:\\n\\n<a href=\"https://imgur.com/naclXcE\"><img src=\"https://i.imgur.com/naclXcE.jpg\" title=\"source: imgur.com\" width=\"350px\"/></a>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "psionl0",
                        "content": "By my calculation, using Pascal's triangle to calculate ``combin(n,r)`` has an ``O(n * k)`` run time and a space penalty of ``O(k)`` where ``k = min(r, n-r)``. Using multiplication we can get the time complexity down to ``O(k)``."
                    },
                    {
                        "username": "aneeshakella17",
                        "content": "Hello, \\nI was wondering why BFS doesn\\'t work here?"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@slnarasim92](/slnarasim92) If there are too many paths to report without taking MOD 1e9+7 remainders, then there are too many to count one by one in a search.  "
                    },
                    {
                        "username": "slnarasim92",
                        "content": "getting time limit exceeded for backtracking based approach as well"
                    },
                    {
                        "username": "pranjal_28",
                        "content": "This questions gave me nostalgia and all JEE aspirants will relate to it....we used to do this question in Permutations and Combinations in class 12th during our JEE preperation"
                    },
                    {
                        "username": "psionl0",
                        "content": "If I remember correctly, ``63. Unique Paths II`` was a daily problem on August 12, 2023 (a Saturday). This one is definitely not your usual type of Sunday problem."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "why can\\'t they just make row n and col m.\\nI got 2 typos and I spend my 20 mins finding why its showing runtime error.\\n\\n"
                    },
                    {
                        "username": "Joald",
                        "content": "We need to make m - 1 steps right and n - 1 steps down.\\nWe are asked for how many ways we can do that - that is, in how many different ways we can produce a sequence of that many of each step.\\nFor m = 4, n = 3, one such sequence is > \\\\\\\\/ > > \\\\\\\\/\\nSince we always have to make the same amount of steps (m + n - 2), we can treat steps as \"slots\", and one kind of arrow as \"chosen\" and the other as \"not chosen\". This means that all we need to calculate is how many ways we can choose a certain amount of arrows out of the pool of m + n - 2 arrows. \\nThe rest is left as an exercise for the reader."
                    },
                    {
                        "username": "purple329",
                        "content": "For the last test case, I got an wrong answer.\\n\\ninput:\\n1\\n1\\nOutput:\\n0\\nExpected:\\n1"
                    },
                    {
                        "username": "Joald",
                        "content": "There is exactly one path from each square to itself - the empty path."
                    }
                ]
            },
            {
                "id": 2069326,
                "content": [
                    {
                        "username": "mkbari5",
                        "content": "![image](https://assets.leetcode.com/users/images/10b1134d-5697-4789-92ca-2ab39090da32_1645349752.5808718.png)\\n"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "The answer is 1 because there is only one way to reach the destination which is just staying there. The answer will be 0 if and only if there is no way to reach destination."
                    },
                    {
                        "username": "lakshyakumartiwari",
                        "content": "// 100% beat solution using combination\\n/** we can also solve it by creating sieve of array but it is less efficient as of space complexity while is doing competitive programming it is preffered to pre compute factorial and power using fermit theorem (numbe^mod-2) for handling division modulo\\n**/\\nclass Solution {\\npublic:\\n   int uniquePaths(int m, int n) {\\n\\t\\tint N = n+m-2,R = min(n-1,m-1);\\n\\t\\tdouble result = 1;\\n\\t\\tfor(int i = 0; i < min(n-1,m-1); i++)\\n\\t\\t\\t\\tresult = result * N-- / R--;\\n\\t\\treturn round(result);\\n   }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you know that there is a Solutions section here? :)"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Any Dp with grid Question Exists:\\n\\n<a href=\"https://imgur.com/naclXcE\"><img src=\"https://i.imgur.com/naclXcE.jpg\" title=\"source: imgur.com\" width=\"350px\"/></a>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "psionl0",
                        "content": "By my calculation, using Pascal's triangle to calculate ``combin(n,r)`` has an ``O(n * k)`` run time and a space penalty of ``O(k)`` where ``k = min(r, n-r)``. Using multiplication we can get the time complexity down to ``O(k)``."
                    },
                    {
                        "username": "aneeshakella17",
                        "content": "Hello, \\nI was wondering why BFS doesn\\'t work here?"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@slnarasim92](/slnarasim92) If there are too many paths to report without taking MOD 1e9+7 remainders, then there are too many to count one by one in a search.  "
                    },
                    {
                        "username": "slnarasim92",
                        "content": "getting time limit exceeded for backtracking based approach as well"
                    },
                    {
                        "username": "pranjal_28",
                        "content": "This questions gave me nostalgia and all JEE aspirants will relate to it....we used to do this question in Permutations and Combinations in class 12th during our JEE preperation"
                    },
                    {
                        "username": "psionl0",
                        "content": "If I remember correctly, ``63. Unique Paths II`` was a daily problem on August 12, 2023 (a Saturday). This one is definitely not your usual type of Sunday problem."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "why can\\'t they just make row n and col m.\\nI got 2 typos and I spend my 20 mins finding why its showing runtime error.\\n\\n"
                    },
                    {
                        "username": "Joald",
                        "content": "We need to make m - 1 steps right and n - 1 steps down.\\nWe are asked for how many ways we can do that - that is, in how many different ways we can produce a sequence of that many of each step.\\nFor m = 4, n = 3, one such sequence is > \\\\\\\\/ > > \\\\\\\\/\\nSince we always have to make the same amount of steps (m + n - 2), we can treat steps as \"slots\", and one kind of arrow as \"chosen\" and the other as \"not chosen\". This means that all we need to calculate is how many ways we can choose a certain amount of arrows out of the pool of m + n - 2 arrows. \\nThe rest is left as an exercise for the reader."
                    },
                    {
                        "username": "purple329",
                        "content": "For the last test case, I got an wrong answer.\\n\\ninput:\\n1\\n1\\nOutput:\\n0\\nExpected:\\n1"
                    },
                    {
                        "username": "Joald",
                        "content": "There is exactly one path from each square to itself - the empty path."
                    }
                ]
            },
            {
                "id": 2041658,
                "content": [
                    {
                        "username": "mkbari5",
                        "content": "![image](https://assets.leetcode.com/users/images/10b1134d-5697-4789-92ca-2ab39090da32_1645349752.5808718.png)\\n"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "The answer is 1 because there is only one way to reach the destination which is just staying there. The answer will be 0 if and only if there is no way to reach destination."
                    },
                    {
                        "username": "lakshyakumartiwari",
                        "content": "// 100% beat solution using combination\\n/** we can also solve it by creating sieve of array but it is less efficient as of space complexity while is doing competitive programming it is preffered to pre compute factorial and power using fermit theorem (numbe^mod-2) for handling division modulo\\n**/\\nclass Solution {\\npublic:\\n   int uniquePaths(int m, int n) {\\n\\t\\tint N = n+m-2,R = min(n-1,m-1);\\n\\t\\tdouble result = 1;\\n\\t\\tfor(int i = 0; i < min(n-1,m-1); i++)\\n\\t\\t\\t\\tresult = result * N-- / R--;\\n\\t\\treturn round(result);\\n   }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you know that there is a Solutions section here? :)"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Any Dp with grid Question Exists:\\n\\n<a href=\"https://imgur.com/naclXcE\"><img src=\"https://i.imgur.com/naclXcE.jpg\" title=\"source: imgur.com\" width=\"350px\"/></a>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "psionl0",
                        "content": "By my calculation, using Pascal's triangle to calculate ``combin(n,r)`` has an ``O(n * k)`` run time and a space penalty of ``O(k)`` where ``k = min(r, n-r)``. Using multiplication we can get the time complexity down to ``O(k)``."
                    },
                    {
                        "username": "aneeshakella17",
                        "content": "Hello, \\nI was wondering why BFS doesn\\'t work here?"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@slnarasim92](/slnarasim92) If there are too many paths to report without taking MOD 1e9+7 remainders, then there are too many to count one by one in a search.  "
                    },
                    {
                        "username": "slnarasim92",
                        "content": "getting time limit exceeded for backtracking based approach as well"
                    },
                    {
                        "username": "pranjal_28",
                        "content": "This questions gave me nostalgia and all JEE aspirants will relate to it....we used to do this question in Permutations and Combinations in class 12th during our JEE preperation"
                    },
                    {
                        "username": "psionl0",
                        "content": "If I remember correctly, ``63. Unique Paths II`` was a daily problem on August 12, 2023 (a Saturday). This one is definitely not your usual type of Sunday problem."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "why can\\'t they just make row n and col m.\\nI got 2 typos and I spend my 20 mins finding why its showing runtime error.\\n\\n"
                    },
                    {
                        "username": "Joald",
                        "content": "We need to make m - 1 steps right and n - 1 steps down.\\nWe are asked for how many ways we can do that - that is, in how many different ways we can produce a sequence of that many of each step.\\nFor m = 4, n = 3, one such sequence is > \\\\\\\\/ > > \\\\\\\\/\\nSince we always have to make the same amount of steps (m + n - 2), we can treat steps as \"slots\", and one kind of arrow as \"chosen\" and the other as \"not chosen\". This means that all we need to calculate is how many ways we can choose a certain amount of arrows out of the pool of m + n - 2 arrows. \\nThe rest is left as an exercise for the reader."
                    },
                    {
                        "username": "purple329",
                        "content": "For the last test case, I got an wrong answer.\\n\\ninput:\\n1\\n1\\nOutput:\\n0\\nExpected:\\n1"
                    },
                    {
                        "username": "Joald",
                        "content": "There is exactly one path from each square to itself - the empty path."
                    }
                ]
            },
            {
                "id": 1926934,
                "content": [
                    {
                        "username": "mkbari5",
                        "content": "![image](https://assets.leetcode.com/users/images/10b1134d-5697-4789-92ca-2ab39090da32_1645349752.5808718.png)\\n"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "The answer is 1 because there is only one way to reach the destination which is just staying there. The answer will be 0 if and only if there is no way to reach destination."
                    },
                    {
                        "username": "lakshyakumartiwari",
                        "content": "// 100% beat solution using combination\\n/** we can also solve it by creating sieve of array but it is less efficient as of space complexity while is doing competitive programming it is preffered to pre compute factorial and power using fermit theorem (numbe^mod-2) for handling division modulo\\n**/\\nclass Solution {\\npublic:\\n   int uniquePaths(int m, int n) {\\n\\t\\tint N = n+m-2,R = min(n-1,m-1);\\n\\t\\tdouble result = 1;\\n\\t\\tfor(int i = 0; i < min(n-1,m-1); i++)\\n\\t\\t\\t\\tresult = result * N-- / R--;\\n\\t\\treturn round(result);\\n   }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you know that there is a Solutions section here? :)"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Any Dp with grid Question Exists:\\n\\n<a href=\"https://imgur.com/naclXcE\"><img src=\"https://i.imgur.com/naclXcE.jpg\" title=\"source: imgur.com\" width=\"350px\"/></a>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "psionl0",
                        "content": "By my calculation, using Pascal's triangle to calculate ``combin(n,r)`` has an ``O(n * k)`` run time and a space penalty of ``O(k)`` where ``k = min(r, n-r)``. Using multiplication we can get the time complexity down to ``O(k)``."
                    },
                    {
                        "username": "aneeshakella17",
                        "content": "Hello, \\nI was wondering why BFS doesn\\'t work here?"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@slnarasim92](/slnarasim92) If there are too many paths to report without taking MOD 1e9+7 remainders, then there are too many to count one by one in a search.  "
                    },
                    {
                        "username": "slnarasim92",
                        "content": "getting time limit exceeded for backtracking based approach as well"
                    },
                    {
                        "username": "pranjal_28",
                        "content": "This questions gave me nostalgia and all JEE aspirants will relate to it....we used to do this question in Permutations and Combinations in class 12th during our JEE preperation"
                    },
                    {
                        "username": "psionl0",
                        "content": "If I remember correctly, ``63. Unique Paths II`` was a daily problem on August 12, 2023 (a Saturday). This one is definitely not your usual type of Sunday problem."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "why can\\'t they just make row n and col m.\\nI got 2 typos and I spend my 20 mins finding why its showing runtime error.\\n\\n"
                    },
                    {
                        "username": "Joald",
                        "content": "We need to make m - 1 steps right and n - 1 steps down.\\nWe are asked for how many ways we can do that - that is, in how many different ways we can produce a sequence of that many of each step.\\nFor m = 4, n = 3, one such sequence is > \\\\\\\\/ > > \\\\\\\\/\\nSince we always have to make the same amount of steps (m + n - 2), we can treat steps as \"slots\", and one kind of arrow as \"chosen\" and the other as \"not chosen\". This means that all we need to calculate is how many ways we can choose a certain amount of arrows out of the pool of m + n - 2 arrows. \\nThe rest is left as an exercise for the reader."
                    },
                    {
                        "username": "purple329",
                        "content": "For the last test case, I got an wrong answer.\\n\\ninput:\\n1\\n1\\nOutput:\\n0\\nExpected:\\n1"
                    },
                    {
                        "username": "Joald",
                        "content": "There is exactly one path from each square to itself - the empty path."
                    }
                ]
            },
            {
                "id": 1711267,
                "content": [
                    {
                        "username": "mkbari5",
                        "content": "![image](https://assets.leetcode.com/users/images/10b1134d-5697-4789-92ca-2ab39090da32_1645349752.5808718.png)\\n"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "The answer is 1 because there is only one way to reach the destination which is just staying there. The answer will be 0 if and only if there is no way to reach destination."
                    },
                    {
                        "username": "lakshyakumartiwari",
                        "content": "// 100% beat solution using combination\\n/** we can also solve it by creating sieve of array but it is less efficient as of space complexity while is doing competitive programming it is preffered to pre compute factorial and power using fermit theorem (numbe^mod-2) for handling division modulo\\n**/\\nclass Solution {\\npublic:\\n   int uniquePaths(int m, int n) {\\n\\t\\tint N = n+m-2,R = min(n-1,m-1);\\n\\t\\tdouble result = 1;\\n\\t\\tfor(int i = 0; i < min(n-1,m-1); i++)\\n\\t\\t\\t\\tresult = result * N-- / R--;\\n\\t\\treturn round(result);\\n   }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you know that there is a Solutions section here? :)"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Any Dp with grid Question Exists:\\n\\n<a href=\"https://imgur.com/naclXcE\"><img src=\"https://i.imgur.com/naclXcE.jpg\" title=\"source: imgur.com\" width=\"350px\"/></a>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "psionl0",
                        "content": "By my calculation, using Pascal's triangle to calculate ``combin(n,r)`` has an ``O(n * k)`` run time and a space penalty of ``O(k)`` where ``k = min(r, n-r)``. Using multiplication we can get the time complexity down to ``O(k)``."
                    },
                    {
                        "username": "aneeshakella17",
                        "content": "Hello, \\nI was wondering why BFS doesn\\'t work here?"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@slnarasim92](/slnarasim92) If there are too many paths to report without taking MOD 1e9+7 remainders, then there are too many to count one by one in a search.  "
                    },
                    {
                        "username": "slnarasim92",
                        "content": "getting time limit exceeded for backtracking based approach as well"
                    },
                    {
                        "username": "pranjal_28",
                        "content": "This questions gave me nostalgia and all JEE aspirants will relate to it....we used to do this question in Permutations and Combinations in class 12th during our JEE preperation"
                    },
                    {
                        "username": "psionl0",
                        "content": "If I remember correctly, ``63. Unique Paths II`` was a daily problem on August 12, 2023 (a Saturday). This one is definitely not your usual type of Sunday problem."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "why can\\'t they just make row n and col m.\\nI got 2 typos and I spend my 20 mins finding why its showing runtime error.\\n\\n"
                    },
                    {
                        "username": "Joald",
                        "content": "We need to make m - 1 steps right and n - 1 steps down.\\nWe are asked for how many ways we can do that - that is, in how many different ways we can produce a sequence of that many of each step.\\nFor m = 4, n = 3, one such sequence is > \\\\\\\\/ > > \\\\\\\\/\\nSince we always have to make the same amount of steps (m + n - 2), we can treat steps as \"slots\", and one kind of arrow as \"chosen\" and the other as \"not chosen\". This means that all we need to calculate is how many ways we can choose a certain amount of arrows out of the pool of m + n - 2 arrows. \\nThe rest is left as an exercise for the reader."
                    },
                    {
                        "username": "purple329",
                        "content": "For the last test case, I got an wrong answer.\\n\\ninput:\\n1\\n1\\nOutput:\\n0\\nExpected:\\n1"
                    },
                    {
                        "username": "Joald",
                        "content": "There is exactly one path from each square to itself - the empty path."
                    }
                ]
            },
            {
                "id": 1576019,
                "content": [
                    {
                        "username": "mkbari5",
                        "content": "![image](https://assets.leetcode.com/users/images/10b1134d-5697-4789-92ca-2ab39090da32_1645349752.5808718.png)\\n"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "The answer is 1 because there is only one way to reach the destination which is just staying there. The answer will be 0 if and only if there is no way to reach destination."
                    },
                    {
                        "username": "lakshyakumartiwari",
                        "content": "// 100% beat solution using combination\\n/** we can also solve it by creating sieve of array but it is less efficient as of space complexity while is doing competitive programming it is preffered to pre compute factorial and power using fermit theorem (numbe^mod-2) for handling division modulo\\n**/\\nclass Solution {\\npublic:\\n   int uniquePaths(int m, int n) {\\n\\t\\tint N = n+m-2,R = min(n-1,m-1);\\n\\t\\tdouble result = 1;\\n\\t\\tfor(int i = 0; i < min(n-1,m-1); i++)\\n\\t\\t\\t\\tresult = result * N-- / R--;\\n\\t\\treturn round(result);\\n   }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you know that there is a Solutions section here? :)"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Any Dp with grid Question Exists:\\n\\n<a href=\"https://imgur.com/naclXcE\"><img src=\"https://i.imgur.com/naclXcE.jpg\" title=\"source: imgur.com\" width=\"350px\"/></a>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "psionl0",
                        "content": "By my calculation, using Pascal's triangle to calculate ``combin(n,r)`` has an ``O(n * k)`` run time and a space penalty of ``O(k)`` where ``k = min(r, n-r)``. Using multiplication we can get the time complexity down to ``O(k)``."
                    },
                    {
                        "username": "aneeshakella17",
                        "content": "Hello, \\nI was wondering why BFS doesn\\'t work here?"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@slnarasim92](/slnarasim92) If there are too many paths to report without taking MOD 1e9+7 remainders, then there are too many to count one by one in a search.  "
                    },
                    {
                        "username": "slnarasim92",
                        "content": "getting time limit exceeded for backtracking based approach as well"
                    },
                    {
                        "username": "pranjal_28",
                        "content": "This questions gave me nostalgia and all JEE aspirants will relate to it....we used to do this question in Permutations and Combinations in class 12th during our JEE preperation"
                    },
                    {
                        "username": "psionl0",
                        "content": "If I remember correctly, ``63. Unique Paths II`` was a daily problem on August 12, 2023 (a Saturday). This one is definitely not your usual type of Sunday problem."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "why can\\'t they just make row n and col m.\\nI got 2 typos and I spend my 20 mins finding why its showing runtime error.\\n\\n"
                    },
                    {
                        "username": "Joald",
                        "content": "We need to make m - 1 steps right and n - 1 steps down.\\nWe are asked for how many ways we can do that - that is, in how many different ways we can produce a sequence of that many of each step.\\nFor m = 4, n = 3, one such sequence is > \\\\\\\\/ > > \\\\\\\\/\\nSince we always have to make the same amount of steps (m + n - 2), we can treat steps as \"slots\", and one kind of arrow as \"chosen\" and the other as \"not chosen\". This means that all we need to calculate is how many ways we can choose a certain amount of arrows out of the pool of m + n - 2 arrows. \\nThe rest is left as an exercise for the reader."
                    },
                    {
                        "username": "purple329",
                        "content": "For the last test case, I got an wrong answer.\\n\\ninput:\\n1\\n1\\nOutput:\\n0\\nExpected:\\n1"
                    },
                    {
                        "username": "Joald",
                        "content": "There is exactly one path from each square to itself - the empty path."
                    }
                ]
            },
            {
                "id": 1574458,
                "content": [
                    {
                        "username": "ml4",
                        "content": "answer: (m+n-2)! / [(m-1)! * (n-1)!]"
                    },
                    {
                        "username": "vashishthaakshay18",
                        "content": "This question can be solved by two method one through dp and another through maths \\nMaths approach ->\\n1. In path we need to fix no. of down moves and fix no. of right moves so we can say that in a string of length (m-1) + (n-1) we need to find total different string possible so so we can easily see ans is (n!)/(m1!)(m2!)..... ans so \\n2. we just need to compute (n+m-2)!/(n-1)!*(m-1)!\\n\\nDp approach we can easily see that we just need find the no of possible ways to reach (i,j) index so that will be equal to dp[i][k] which is equal to the sum of its upper row or left column value i.e. dp[i][j] = dp[i-1][j] + dp[i][j-1]"
                    },
                    {
                        "username": "kavyakumar",
                        "content": "Input: m = 3, n = 2\\nOutput: 3\\nExplanation:\\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\\n1. Right -> Right -> Down\\n2. Right -> Down -> Right\\n3. Down -> Right -> Right\\n\\nOne more path is also available\\ndown->right->up->right->down"
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "Yes it is possible. However, according to problem statement, we can move either down or right. So, in the problem context 4th path is not available."
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\\ttotal steps to be taken = m-1 (right)+n-1(down);\\n\\tto select m-1 right steps from m+n-2 total steps then n-1 down steps from remaining n-1 down steps \\n\\t\\ttherefore ans should be **m+n-2 C m-1******\\n"
                    },
                    {
                        "username": "seaskies",
                        "content": "The note says m and n will be at most 100, then how does the platform deal with the answer bigger than 2^31-1 as the follow picture?\\nCan anyone help me out, with great appreciation!\\n![image](https://assets.leetcode.com/users/seaskies/image_1556768250.png)\\n"
                    },
                    {
                        "username": "demmr",
                        "content": "The return type of the function is int and it will fail for values of m and n going more than 40 lets say. I took dp matrix to be long type and then it is able to accomodate the values as m and n can go upto 100. But the code is accepted when I\\'m just taking dp matrix to be int type.\\n\\nIn running the test cases, I can see that Integer overflow is happening for m,n >40, but the testcases get pass. \\n\\nCan someone please let me know if I want to get it accepted for int return type for m,n = 100, then how can we proceed and is it possible using dp matrix?"
                    },
                    {
                        "username": "kruglikov",
                        "content": "This problem is essentially asking  N+M - 2 choose N-1. It\\'s a simple math problem as long as you figure out how to avoid overflowing the int type (asuume n = N+M-2 and k = min(N, M) - 1 just perform n!/max(n-k, k)! as a single step so in the the 100,2 test case it redeuces to 100 instead of calculating 100!/99! which will overflow the int type."
                    },
                    {
                        "username": "sykKo",
                        "content": "\\u7B54\\u6848\\u662F (m + n - 2)! / ((m - 1)! * (n - 1)!)\\n\\u6211\\u77E5\\u9053\\u8FD9\\u9898\\u5E94\\u8BE5\\u7528dynamic programming\\u505A\\uFF0C\\u4F46\\u662F\\u4E8B\\u5B9E\\u4E0A\\u8FD9\\u9053\\u9898\\u6211\\u4EEC\\u5728\\u5B66\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u65F6\\u5019\\u5176\\u5B9E\\u5E94\\u8BE5\\u90FD\\u505A\\u5230\\u8FC7\\uFF0C\\u5F53\\u65F6\\u53EF\\u6CA1\\u6CD5\\u7F16\\u7A0B\\u505A\\uFF0C\\u66F4\\u4F55\\u51B5\\u9898\\u76EE\\u91CC\\u7684m\\u548Cn\\u90FD\\u4E0D\\u4E00\\u5B9A\\u662F\\u5177\\u4F53\\u6570\\u5B57\\u3002\\n\\u590D\\u4E60\\u4E86\\u4E00\\u4E0B\\u4EE5\\u540E\\uFF08\\u662F\\u7684\\uFF0C\\u6211TM\\u73B0\\u5728\\u5DF2\\u7ECF\\u4E0D\\u4F1A\\u505A\\u8FD9\\u9053\\u9898\\u4E86\\uFF09\\uFF0C\\u89E3\\u7B54\\u8FC7\\u7A0B\\u5982\\u4E0B\\uFF1A\\n\\u9996\\u5148\\uFF0C\\u5C06\\u9898\\u76EE\\u8F6C\\u53D8\\u4E3A\\u628A(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u63D2\\u5165\\u5230(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u91CC\\u3002\\n\\u800C\\u8FD9\\u53C8\\u53EF\\u4EE5\\u8F6C\\u53D8\\u4E3A\\u6C42(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u548C(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u603B\\u5171\\u6709\\u591A\\u5C11\\u79CD\\u4E0D\\u540C\\u7684\\u6392\\u5217\\u65B9\\u6CD5\\uFF0C\\u90A3\\u7B54\\u6848\\u5C31\\u662F(m + n - 2)! / ((m - 1)! * (n - 1)!)\\u4E86\\u3002\\n\\nEnglish translation:\\nanswer is (m + n - 2)! / ((m - 1)! * (n - 1)!)\\nI know this problem is supposed to be solved with dynamic programming, but the truth is that we Chinese have all probably met this question when learning permutations and combinations in school. We could program then, let alone m and n might even not be actual numbers.\\nAfter reviewing a bit (yeah, I cannot solve this on my own now, years after graduating), I\\'ve solved this problem with following steps:\\n1. The problem actually equals to insert m - 1 \"right\"s into n - 1 \"downs\"\\n2. and that equals to find out in how many ways m - 1 \"1\"s and n - 1 \"0\"s can form a string\\n3. the answer here it is."
                    },
                    {
                        "username": "quantic",
                        "content": "If you try with 60 60 the Accepted solution will return -234078496 so i thing the answer should be returned MOD some prime number or the limits (m,n<= 100 ) changed."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "Fibonacci style easy DP problem"
                    }
                ]
            },
            {
                "id": 1573974,
                "content": [
                    {
                        "username": "ml4",
                        "content": "answer: (m+n-2)! / [(m-1)! * (n-1)!]"
                    },
                    {
                        "username": "vashishthaakshay18",
                        "content": "This question can be solved by two method one through dp and another through maths \\nMaths approach ->\\n1. In path we need to fix no. of down moves and fix no. of right moves so we can say that in a string of length (m-1) + (n-1) we need to find total different string possible so so we can easily see ans is (n!)/(m1!)(m2!)..... ans so \\n2. we just need to compute (n+m-2)!/(n-1)!*(m-1)!\\n\\nDp approach we can easily see that we just need find the no of possible ways to reach (i,j) index so that will be equal to dp[i][k] which is equal to the sum of its upper row or left column value i.e. dp[i][j] = dp[i-1][j] + dp[i][j-1]"
                    },
                    {
                        "username": "kavyakumar",
                        "content": "Input: m = 3, n = 2\\nOutput: 3\\nExplanation:\\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\\n1. Right -> Right -> Down\\n2. Right -> Down -> Right\\n3. Down -> Right -> Right\\n\\nOne more path is also available\\ndown->right->up->right->down"
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "Yes it is possible. However, according to problem statement, we can move either down or right. So, in the problem context 4th path is not available."
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\\ttotal steps to be taken = m-1 (right)+n-1(down);\\n\\tto select m-1 right steps from m+n-2 total steps then n-1 down steps from remaining n-1 down steps \\n\\t\\ttherefore ans should be **m+n-2 C m-1******\\n"
                    },
                    {
                        "username": "seaskies",
                        "content": "The note says m and n will be at most 100, then how does the platform deal with the answer bigger than 2^31-1 as the follow picture?\\nCan anyone help me out, with great appreciation!\\n![image](https://assets.leetcode.com/users/seaskies/image_1556768250.png)\\n"
                    },
                    {
                        "username": "demmr",
                        "content": "The return type of the function is int and it will fail for values of m and n going more than 40 lets say. I took dp matrix to be long type and then it is able to accomodate the values as m and n can go upto 100. But the code is accepted when I\\'m just taking dp matrix to be int type.\\n\\nIn running the test cases, I can see that Integer overflow is happening for m,n >40, but the testcases get pass. \\n\\nCan someone please let me know if I want to get it accepted for int return type for m,n = 100, then how can we proceed and is it possible using dp matrix?"
                    },
                    {
                        "username": "kruglikov",
                        "content": "This problem is essentially asking  N+M - 2 choose N-1. It\\'s a simple math problem as long as you figure out how to avoid overflowing the int type (asuume n = N+M-2 and k = min(N, M) - 1 just perform n!/max(n-k, k)! as a single step so in the the 100,2 test case it redeuces to 100 instead of calculating 100!/99! which will overflow the int type."
                    },
                    {
                        "username": "sykKo",
                        "content": "\\u7B54\\u6848\\u662F (m + n - 2)! / ((m - 1)! * (n - 1)!)\\n\\u6211\\u77E5\\u9053\\u8FD9\\u9898\\u5E94\\u8BE5\\u7528dynamic programming\\u505A\\uFF0C\\u4F46\\u662F\\u4E8B\\u5B9E\\u4E0A\\u8FD9\\u9053\\u9898\\u6211\\u4EEC\\u5728\\u5B66\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u65F6\\u5019\\u5176\\u5B9E\\u5E94\\u8BE5\\u90FD\\u505A\\u5230\\u8FC7\\uFF0C\\u5F53\\u65F6\\u53EF\\u6CA1\\u6CD5\\u7F16\\u7A0B\\u505A\\uFF0C\\u66F4\\u4F55\\u51B5\\u9898\\u76EE\\u91CC\\u7684m\\u548Cn\\u90FD\\u4E0D\\u4E00\\u5B9A\\u662F\\u5177\\u4F53\\u6570\\u5B57\\u3002\\n\\u590D\\u4E60\\u4E86\\u4E00\\u4E0B\\u4EE5\\u540E\\uFF08\\u662F\\u7684\\uFF0C\\u6211TM\\u73B0\\u5728\\u5DF2\\u7ECF\\u4E0D\\u4F1A\\u505A\\u8FD9\\u9053\\u9898\\u4E86\\uFF09\\uFF0C\\u89E3\\u7B54\\u8FC7\\u7A0B\\u5982\\u4E0B\\uFF1A\\n\\u9996\\u5148\\uFF0C\\u5C06\\u9898\\u76EE\\u8F6C\\u53D8\\u4E3A\\u628A(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u63D2\\u5165\\u5230(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u91CC\\u3002\\n\\u800C\\u8FD9\\u53C8\\u53EF\\u4EE5\\u8F6C\\u53D8\\u4E3A\\u6C42(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u548C(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u603B\\u5171\\u6709\\u591A\\u5C11\\u79CD\\u4E0D\\u540C\\u7684\\u6392\\u5217\\u65B9\\u6CD5\\uFF0C\\u90A3\\u7B54\\u6848\\u5C31\\u662F(m + n - 2)! / ((m - 1)! * (n - 1)!)\\u4E86\\u3002\\n\\nEnglish translation:\\nanswer is (m + n - 2)! / ((m - 1)! * (n - 1)!)\\nI know this problem is supposed to be solved with dynamic programming, but the truth is that we Chinese have all probably met this question when learning permutations and combinations in school. We could program then, let alone m and n might even not be actual numbers.\\nAfter reviewing a bit (yeah, I cannot solve this on my own now, years after graduating), I\\'ve solved this problem with following steps:\\n1. The problem actually equals to insert m - 1 \"right\"s into n - 1 \"downs\"\\n2. and that equals to find out in how many ways m - 1 \"1\"s and n - 1 \"0\"s can form a string\\n3. the answer here it is."
                    },
                    {
                        "username": "quantic",
                        "content": "If you try with 60 60 the Accepted solution will return -234078496 so i thing the answer should be returned MOD some prime number or the limits (m,n<= 100 ) changed."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "Fibonacci style easy DP problem"
                    }
                ]
            },
            {
                "id": 1573799,
                "content": [
                    {
                        "username": "ml4",
                        "content": "answer: (m+n-2)! / [(m-1)! * (n-1)!]"
                    },
                    {
                        "username": "vashishthaakshay18",
                        "content": "This question can be solved by two method one through dp and another through maths \\nMaths approach ->\\n1. In path we need to fix no. of down moves and fix no. of right moves so we can say that in a string of length (m-1) + (n-1) we need to find total different string possible so so we can easily see ans is (n!)/(m1!)(m2!)..... ans so \\n2. we just need to compute (n+m-2)!/(n-1)!*(m-1)!\\n\\nDp approach we can easily see that we just need find the no of possible ways to reach (i,j) index so that will be equal to dp[i][k] which is equal to the sum of its upper row or left column value i.e. dp[i][j] = dp[i-1][j] + dp[i][j-1]"
                    },
                    {
                        "username": "kavyakumar",
                        "content": "Input: m = 3, n = 2\\nOutput: 3\\nExplanation:\\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\\n1. Right -> Right -> Down\\n2. Right -> Down -> Right\\n3. Down -> Right -> Right\\n\\nOne more path is also available\\ndown->right->up->right->down"
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "Yes it is possible. However, according to problem statement, we can move either down or right. So, in the problem context 4th path is not available."
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\\ttotal steps to be taken = m-1 (right)+n-1(down);\\n\\tto select m-1 right steps from m+n-2 total steps then n-1 down steps from remaining n-1 down steps \\n\\t\\ttherefore ans should be **m+n-2 C m-1******\\n"
                    },
                    {
                        "username": "seaskies",
                        "content": "The note says m and n will be at most 100, then how does the platform deal with the answer bigger than 2^31-1 as the follow picture?\\nCan anyone help me out, with great appreciation!\\n![image](https://assets.leetcode.com/users/seaskies/image_1556768250.png)\\n"
                    },
                    {
                        "username": "demmr",
                        "content": "The return type of the function is int and it will fail for values of m and n going more than 40 lets say. I took dp matrix to be long type and then it is able to accomodate the values as m and n can go upto 100. But the code is accepted when I\\'m just taking dp matrix to be int type.\\n\\nIn running the test cases, I can see that Integer overflow is happening for m,n >40, but the testcases get pass. \\n\\nCan someone please let me know if I want to get it accepted for int return type for m,n = 100, then how can we proceed and is it possible using dp matrix?"
                    },
                    {
                        "username": "kruglikov",
                        "content": "This problem is essentially asking  N+M - 2 choose N-1. It\\'s a simple math problem as long as you figure out how to avoid overflowing the int type (asuume n = N+M-2 and k = min(N, M) - 1 just perform n!/max(n-k, k)! as a single step so in the the 100,2 test case it redeuces to 100 instead of calculating 100!/99! which will overflow the int type."
                    },
                    {
                        "username": "sykKo",
                        "content": "\\u7B54\\u6848\\u662F (m + n - 2)! / ((m - 1)! * (n - 1)!)\\n\\u6211\\u77E5\\u9053\\u8FD9\\u9898\\u5E94\\u8BE5\\u7528dynamic programming\\u505A\\uFF0C\\u4F46\\u662F\\u4E8B\\u5B9E\\u4E0A\\u8FD9\\u9053\\u9898\\u6211\\u4EEC\\u5728\\u5B66\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u65F6\\u5019\\u5176\\u5B9E\\u5E94\\u8BE5\\u90FD\\u505A\\u5230\\u8FC7\\uFF0C\\u5F53\\u65F6\\u53EF\\u6CA1\\u6CD5\\u7F16\\u7A0B\\u505A\\uFF0C\\u66F4\\u4F55\\u51B5\\u9898\\u76EE\\u91CC\\u7684m\\u548Cn\\u90FD\\u4E0D\\u4E00\\u5B9A\\u662F\\u5177\\u4F53\\u6570\\u5B57\\u3002\\n\\u590D\\u4E60\\u4E86\\u4E00\\u4E0B\\u4EE5\\u540E\\uFF08\\u662F\\u7684\\uFF0C\\u6211TM\\u73B0\\u5728\\u5DF2\\u7ECF\\u4E0D\\u4F1A\\u505A\\u8FD9\\u9053\\u9898\\u4E86\\uFF09\\uFF0C\\u89E3\\u7B54\\u8FC7\\u7A0B\\u5982\\u4E0B\\uFF1A\\n\\u9996\\u5148\\uFF0C\\u5C06\\u9898\\u76EE\\u8F6C\\u53D8\\u4E3A\\u628A(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u63D2\\u5165\\u5230(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u91CC\\u3002\\n\\u800C\\u8FD9\\u53C8\\u53EF\\u4EE5\\u8F6C\\u53D8\\u4E3A\\u6C42(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u548C(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u603B\\u5171\\u6709\\u591A\\u5C11\\u79CD\\u4E0D\\u540C\\u7684\\u6392\\u5217\\u65B9\\u6CD5\\uFF0C\\u90A3\\u7B54\\u6848\\u5C31\\u662F(m + n - 2)! / ((m - 1)! * (n - 1)!)\\u4E86\\u3002\\n\\nEnglish translation:\\nanswer is (m + n - 2)! / ((m - 1)! * (n - 1)!)\\nI know this problem is supposed to be solved with dynamic programming, but the truth is that we Chinese have all probably met this question when learning permutations and combinations in school. We could program then, let alone m and n might even not be actual numbers.\\nAfter reviewing a bit (yeah, I cannot solve this on my own now, years after graduating), I\\'ve solved this problem with following steps:\\n1. The problem actually equals to insert m - 1 \"right\"s into n - 1 \"downs\"\\n2. and that equals to find out in how many ways m - 1 \"1\"s and n - 1 \"0\"s can form a string\\n3. the answer here it is."
                    },
                    {
                        "username": "quantic",
                        "content": "If you try with 60 60 the Accepted solution will return -234078496 so i thing the answer should be returned MOD some prime number or the limits (m,n<= 100 ) changed."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "Fibonacci style easy DP problem"
                    }
                ]
            },
            {
                "id": 1573453,
                "content": [
                    {
                        "username": "ml4",
                        "content": "answer: (m+n-2)! / [(m-1)! * (n-1)!]"
                    },
                    {
                        "username": "vashishthaakshay18",
                        "content": "This question can be solved by two method one through dp and another through maths \\nMaths approach ->\\n1. In path we need to fix no. of down moves and fix no. of right moves so we can say that in a string of length (m-1) + (n-1) we need to find total different string possible so so we can easily see ans is (n!)/(m1!)(m2!)..... ans so \\n2. we just need to compute (n+m-2)!/(n-1)!*(m-1)!\\n\\nDp approach we can easily see that we just need find the no of possible ways to reach (i,j) index so that will be equal to dp[i][k] which is equal to the sum of its upper row or left column value i.e. dp[i][j] = dp[i-1][j] + dp[i][j-1]"
                    },
                    {
                        "username": "kavyakumar",
                        "content": "Input: m = 3, n = 2\\nOutput: 3\\nExplanation:\\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\\n1. Right -> Right -> Down\\n2. Right -> Down -> Right\\n3. Down -> Right -> Right\\n\\nOne more path is also available\\ndown->right->up->right->down"
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "Yes it is possible. However, according to problem statement, we can move either down or right. So, in the problem context 4th path is not available."
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\\ttotal steps to be taken = m-1 (right)+n-1(down);\\n\\tto select m-1 right steps from m+n-2 total steps then n-1 down steps from remaining n-1 down steps \\n\\t\\ttherefore ans should be **m+n-2 C m-1******\\n"
                    },
                    {
                        "username": "seaskies",
                        "content": "The note says m and n will be at most 100, then how does the platform deal with the answer bigger than 2^31-1 as the follow picture?\\nCan anyone help me out, with great appreciation!\\n![image](https://assets.leetcode.com/users/seaskies/image_1556768250.png)\\n"
                    },
                    {
                        "username": "demmr",
                        "content": "The return type of the function is int and it will fail for values of m and n going more than 40 lets say. I took dp matrix to be long type and then it is able to accomodate the values as m and n can go upto 100. But the code is accepted when I\\'m just taking dp matrix to be int type.\\n\\nIn running the test cases, I can see that Integer overflow is happening for m,n >40, but the testcases get pass. \\n\\nCan someone please let me know if I want to get it accepted for int return type for m,n = 100, then how can we proceed and is it possible using dp matrix?"
                    },
                    {
                        "username": "kruglikov",
                        "content": "This problem is essentially asking  N+M - 2 choose N-1. It\\'s a simple math problem as long as you figure out how to avoid overflowing the int type (asuume n = N+M-2 and k = min(N, M) - 1 just perform n!/max(n-k, k)! as a single step so in the the 100,2 test case it redeuces to 100 instead of calculating 100!/99! which will overflow the int type."
                    },
                    {
                        "username": "sykKo",
                        "content": "\\u7B54\\u6848\\u662F (m + n - 2)! / ((m - 1)! * (n - 1)!)\\n\\u6211\\u77E5\\u9053\\u8FD9\\u9898\\u5E94\\u8BE5\\u7528dynamic programming\\u505A\\uFF0C\\u4F46\\u662F\\u4E8B\\u5B9E\\u4E0A\\u8FD9\\u9053\\u9898\\u6211\\u4EEC\\u5728\\u5B66\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u65F6\\u5019\\u5176\\u5B9E\\u5E94\\u8BE5\\u90FD\\u505A\\u5230\\u8FC7\\uFF0C\\u5F53\\u65F6\\u53EF\\u6CA1\\u6CD5\\u7F16\\u7A0B\\u505A\\uFF0C\\u66F4\\u4F55\\u51B5\\u9898\\u76EE\\u91CC\\u7684m\\u548Cn\\u90FD\\u4E0D\\u4E00\\u5B9A\\u662F\\u5177\\u4F53\\u6570\\u5B57\\u3002\\n\\u590D\\u4E60\\u4E86\\u4E00\\u4E0B\\u4EE5\\u540E\\uFF08\\u662F\\u7684\\uFF0C\\u6211TM\\u73B0\\u5728\\u5DF2\\u7ECF\\u4E0D\\u4F1A\\u505A\\u8FD9\\u9053\\u9898\\u4E86\\uFF09\\uFF0C\\u89E3\\u7B54\\u8FC7\\u7A0B\\u5982\\u4E0B\\uFF1A\\n\\u9996\\u5148\\uFF0C\\u5C06\\u9898\\u76EE\\u8F6C\\u53D8\\u4E3A\\u628A(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u63D2\\u5165\\u5230(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u91CC\\u3002\\n\\u800C\\u8FD9\\u53C8\\u53EF\\u4EE5\\u8F6C\\u53D8\\u4E3A\\u6C42(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u548C(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u603B\\u5171\\u6709\\u591A\\u5C11\\u79CD\\u4E0D\\u540C\\u7684\\u6392\\u5217\\u65B9\\u6CD5\\uFF0C\\u90A3\\u7B54\\u6848\\u5C31\\u662F(m + n - 2)! / ((m - 1)! * (n - 1)!)\\u4E86\\u3002\\n\\nEnglish translation:\\nanswer is (m + n - 2)! / ((m - 1)! * (n - 1)!)\\nI know this problem is supposed to be solved with dynamic programming, but the truth is that we Chinese have all probably met this question when learning permutations and combinations in school. We could program then, let alone m and n might even not be actual numbers.\\nAfter reviewing a bit (yeah, I cannot solve this on my own now, years after graduating), I\\'ve solved this problem with following steps:\\n1. The problem actually equals to insert m - 1 \"right\"s into n - 1 \"downs\"\\n2. and that equals to find out in how many ways m - 1 \"1\"s and n - 1 \"0\"s can form a string\\n3. the answer here it is."
                    },
                    {
                        "username": "quantic",
                        "content": "If you try with 60 60 the Accepted solution will return -234078496 so i thing the answer should be returned MOD some prime number or the limits (m,n<= 100 ) changed."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "Fibonacci style easy DP problem"
                    }
                ]
            },
            {
                "id": 1572654,
                "content": [
                    {
                        "username": "ml4",
                        "content": "answer: (m+n-2)! / [(m-1)! * (n-1)!]"
                    },
                    {
                        "username": "vashishthaakshay18",
                        "content": "This question can be solved by two method one through dp and another through maths \\nMaths approach ->\\n1. In path we need to fix no. of down moves and fix no. of right moves so we can say that in a string of length (m-1) + (n-1) we need to find total different string possible so so we can easily see ans is (n!)/(m1!)(m2!)..... ans so \\n2. we just need to compute (n+m-2)!/(n-1)!*(m-1)!\\n\\nDp approach we can easily see that we just need find the no of possible ways to reach (i,j) index so that will be equal to dp[i][k] which is equal to the sum of its upper row or left column value i.e. dp[i][j] = dp[i-1][j] + dp[i][j-1]"
                    },
                    {
                        "username": "kavyakumar",
                        "content": "Input: m = 3, n = 2\\nOutput: 3\\nExplanation:\\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\\n1. Right -> Right -> Down\\n2. Right -> Down -> Right\\n3. Down -> Right -> Right\\n\\nOne more path is also available\\ndown->right->up->right->down"
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "Yes it is possible. However, according to problem statement, we can move either down or right. So, in the problem context 4th path is not available."
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\\ttotal steps to be taken = m-1 (right)+n-1(down);\\n\\tto select m-1 right steps from m+n-2 total steps then n-1 down steps from remaining n-1 down steps \\n\\t\\ttherefore ans should be **m+n-2 C m-1******\\n"
                    },
                    {
                        "username": "seaskies",
                        "content": "The note says m and n will be at most 100, then how does the platform deal with the answer bigger than 2^31-1 as the follow picture?\\nCan anyone help me out, with great appreciation!\\n![image](https://assets.leetcode.com/users/seaskies/image_1556768250.png)\\n"
                    },
                    {
                        "username": "demmr",
                        "content": "The return type of the function is int and it will fail for values of m and n going more than 40 lets say. I took dp matrix to be long type and then it is able to accomodate the values as m and n can go upto 100. But the code is accepted when I\\'m just taking dp matrix to be int type.\\n\\nIn running the test cases, I can see that Integer overflow is happening for m,n >40, but the testcases get pass. \\n\\nCan someone please let me know if I want to get it accepted for int return type for m,n = 100, then how can we proceed and is it possible using dp matrix?"
                    },
                    {
                        "username": "kruglikov",
                        "content": "This problem is essentially asking  N+M - 2 choose N-1. It\\'s a simple math problem as long as you figure out how to avoid overflowing the int type (asuume n = N+M-2 and k = min(N, M) - 1 just perform n!/max(n-k, k)! as a single step so in the the 100,2 test case it redeuces to 100 instead of calculating 100!/99! which will overflow the int type."
                    },
                    {
                        "username": "sykKo",
                        "content": "\\u7B54\\u6848\\u662F (m + n - 2)! / ((m - 1)! * (n - 1)!)\\n\\u6211\\u77E5\\u9053\\u8FD9\\u9898\\u5E94\\u8BE5\\u7528dynamic programming\\u505A\\uFF0C\\u4F46\\u662F\\u4E8B\\u5B9E\\u4E0A\\u8FD9\\u9053\\u9898\\u6211\\u4EEC\\u5728\\u5B66\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u65F6\\u5019\\u5176\\u5B9E\\u5E94\\u8BE5\\u90FD\\u505A\\u5230\\u8FC7\\uFF0C\\u5F53\\u65F6\\u53EF\\u6CA1\\u6CD5\\u7F16\\u7A0B\\u505A\\uFF0C\\u66F4\\u4F55\\u51B5\\u9898\\u76EE\\u91CC\\u7684m\\u548Cn\\u90FD\\u4E0D\\u4E00\\u5B9A\\u662F\\u5177\\u4F53\\u6570\\u5B57\\u3002\\n\\u590D\\u4E60\\u4E86\\u4E00\\u4E0B\\u4EE5\\u540E\\uFF08\\u662F\\u7684\\uFF0C\\u6211TM\\u73B0\\u5728\\u5DF2\\u7ECF\\u4E0D\\u4F1A\\u505A\\u8FD9\\u9053\\u9898\\u4E86\\uFF09\\uFF0C\\u89E3\\u7B54\\u8FC7\\u7A0B\\u5982\\u4E0B\\uFF1A\\n\\u9996\\u5148\\uFF0C\\u5C06\\u9898\\u76EE\\u8F6C\\u53D8\\u4E3A\\u628A(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u63D2\\u5165\\u5230(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u91CC\\u3002\\n\\u800C\\u8FD9\\u53C8\\u53EF\\u4EE5\\u8F6C\\u53D8\\u4E3A\\u6C42(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u548C(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u603B\\u5171\\u6709\\u591A\\u5C11\\u79CD\\u4E0D\\u540C\\u7684\\u6392\\u5217\\u65B9\\u6CD5\\uFF0C\\u90A3\\u7B54\\u6848\\u5C31\\u662F(m + n - 2)! / ((m - 1)! * (n - 1)!)\\u4E86\\u3002\\n\\nEnglish translation:\\nanswer is (m + n - 2)! / ((m - 1)! * (n - 1)!)\\nI know this problem is supposed to be solved with dynamic programming, but the truth is that we Chinese have all probably met this question when learning permutations and combinations in school. We could program then, let alone m and n might even not be actual numbers.\\nAfter reviewing a bit (yeah, I cannot solve this on my own now, years after graduating), I\\'ve solved this problem with following steps:\\n1. The problem actually equals to insert m - 1 \"right\"s into n - 1 \"downs\"\\n2. and that equals to find out in how many ways m - 1 \"1\"s and n - 1 \"0\"s can form a string\\n3. the answer here it is."
                    },
                    {
                        "username": "quantic",
                        "content": "If you try with 60 60 the Accepted solution will return -234078496 so i thing the answer should be returned MOD some prime number or the limits (m,n<= 100 ) changed."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "Fibonacci style easy DP problem"
                    }
                ]
            },
            {
                "id": 1572497,
                "content": [
                    {
                        "username": "ml4",
                        "content": "answer: (m+n-2)! / [(m-1)! * (n-1)!]"
                    },
                    {
                        "username": "vashishthaakshay18",
                        "content": "This question can be solved by two method one through dp and another through maths \\nMaths approach ->\\n1. In path we need to fix no. of down moves and fix no. of right moves so we can say that in a string of length (m-1) + (n-1) we need to find total different string possible so so we can easily see ans is (n!)/(m1!)(m2!)..... ans so \\n2. we just need to compute (n+m-2)!/(n-1)!*(m-1)!\\n\\nDp approach we can easily see that we just need find the no of possible ways to reach (i,j) index so that will be equal to dp[i][k] which is equal to the sum of its upper row or left column value i.e. dp[i][j] = dp[i-1][j] + dp[i][j-1]"
                    },
                    {
                        "username": "kavyakumar",
                        "content": "Input: m = 3, n = 2\\nOutput: 3\\nExplanation:\\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\\n1. Right -> Right -> Down\\n2. Right -> Down -> Right\\n3. Down -> Right -> Right\\n\\nOne more path is also available\\ndown->right->up->right->down"
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "Yes it is possible. However, according to problem statement, we can move either down or right. So, in the problem context 4th path is not available."
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\\ttotal steps to be taken = m-1 (right)+n-1(down);\\n\\tto select m-1 right steps from m+n-2 total steps then n-1 down steps from remaining n-1 down steps \\n\\t\\ttherefore ans should be **m+n-2 C m-1******\\n"
                    },
                    {
                        "username": "seaskies",
                        "content": "The note says m and n will be at most 100, then how does the platform deal with the answer bigger than 2^31-1 as the follow picture?\\nCan anyone help me out, with great appreciation!\\n![image](https://assets.leetcode.com/users/seaskies/image_1556768250.png)\\n"
                    },
                    {
                        "username": "demmr",
                        "content": "The return type of the function is int and it will fail for values of m and n going more than 40 lets say. I took dp matrix to be long type and then it is able to accomodate the values as m and n can go upto 100. But the code is accepted when I\\'m just taking dp matrix to be int type.\\n\\nIn running the test cases, I can see that Integer overflow is happening for m,n >40, but the testcases get pass. \\n\\nCan someone please let me know if I want to get it accepted for int return type for m,n = 100, then how can we proceed and is it possible using dp matrix?"
                    },
                    {
                        "username": "kruglikov",
                        "content": "This problem is essentially asking  N+M - 2 choose N-1. It\\'s a simple math problem as long as you figure out how to avoid overflowing the int type (asuume n = N+M-2 and k = min(N, M) - 1 just perform n!/max(n-k, k)! as a single step so in the the 100,2 test case it redeuces to 100 instead of calculating 100!/99! which will overflow the int type."
                    },
                    {
                        "username": "sykKo",
                        "content": "\\u7B54\\u6848\\u662F (m + n - 2)! / ((m - 1)! * (n - 1)!)\\n\\u6211\\u77E5\\u9053\\u8FD9\\u9898\\u5E94\\u8BE5\\u7528dynamic programming\\u505A\\uFF0C\\u4F46\\u662F\\u4E8B\\u5B9E\\u4E0A\\u8FD9\\u9053\\u9898\\u6211\\u4EEC\\u5728\\u5B66\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u65F6\\u5019\\u5176\\u5B9E\\u5E94\\u8BE5\\u90FD\\u505A\\u5230\\u8FC7\\uFF0C\\u5F53\\u65F6\\u53EF\\u6CA1\\u6CD5\\u7F16\\u7A0B\\u505A\\uFF0C\\u66F4\\u4F55\\u51B5\\u9898\\u76EE\\u91CC\\u7684m\\u548Cn\\u90FD\\u4E0D\\u4E00\\u5B9A\\u662F\\u5177\\u4F53\\u6570\\u5B57\\u3002\\n\\u590D\\u4E60\\u4E86\\u4E00\\u4E0B\\u4EE5\\u540E\\uFF08\\u662F\\u7684\\uFF0C\\u6211TM\\u73B0\\u5728\\u5DF2\\u7ECF\\u4E0D\\u4F1A\\u505A\\u8FD9\\u9053\\u9898\\u4E86\\uFF09\\uFF0C\\u89E3\\u7B54\\u8FC7\\u7A0B\\u5982\\u4E0B\\uFF1A\\n\\u9996\\u5148\\uFF0C\\u5C06\\u9898\\u76EE\\u8F6C\\u53D8\\u4E3A\\u628A(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u63D2\\u5165\\u5230(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u91CC\\u3002\\n\\u800C\\u8FD9\\u53C8\\u53EF\\u4EE5\\u8F6C\\u53D8\\u4E3A\\u6C42(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u548C(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u603B\\u5171\\u6709\\u591A\\u5C11\\u79CD\\u4E0D\\u540C\\u7684\\u6392\\u5217\\u65B9\\u6CD5\\uFF0C\\u90A3\\u7B54\\u6848\\u5C31\\u662F(m + n - 2)! / ((m - 1)! * (n - 1)!)\\u4E86\\u3002\\n\\nEnglish translation:\\nanswer is (m + n - 2)! / ((m - 1)! * (n - 1)!)\\nI know this problem is supposed to be solved with dynamic programming, but the truth is that we Chinese have all probably met this question when learning permutations and combinations in school. We could program then, let alone m and n might even not be actual numbers.\\nAfter reviewing a bit (yeah, I cannot solve this on my own now, years after graduating), I\\'ve solved this problem with following steps:\\n1. The problem actually equals to insert m - 1 \"right\"s into n - 1 \"downs\"\\n2. and that equals to find out in how many ways m - 1 \"1\"s and n - 1 \"0\"s can form a string\\n3. the answer here it is."
                    },
                    {
                        "username": "quantic",
                        "content": "If you try with 60 60 the Accepted solution will return -234078496 so i thing the answer should be returned MOD some prime number or the limits (m,n<= 100 ) changed."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "Fibonacci style easy DP problem"
                    }
                ]
            },
            {
                "id": 1571986,
                "content": [
                    {
                        "username": "ml4",
                        "content": "answer: (m+n-2)! / [(m-1)! * (n-1)!]"
                    },
                    {
                        "username": "vashishthaakshay18",
                        "content": "This question can be solved by two method one through dp and another through maths \\nMaths approach ->\\n1. In path we need to fix no. of down moves and fix no. of right moves so we can say that in a string of length (m-1) + (n-1) we need to find total different string possible so so we can easily see ans is (n!)/(m1!)(m2!)..... ans so \\n2. we just need to compute (n+m-2)!/(n-1)!*(m-1)!\\n\\nDp approach we can easily see that we just need find the no of possible ways to reach (i,j) index so that will be equal to dp[i][k] which is equal to the sum of its upper row or left column value i.e. dp[i][j] = dp[i-1][j] + dp[i][j-1]"
                    },
                    {
                        "username": "kavyakumar",
                        "content": "Input: m = 3, n = 2\\nOutput: 3\\nExplanation:\\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\\n1. Right -> Right -> Down\\n2. Right -> Down -> Right\\n3. Down -> Right -> Right\\n\\nOne more path is also available\\ndown->right->up->right->down"
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "Yes it is possible. However, according to problem statement, we can move either down or right. So, in the problem context 4th path is not available."
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\\ttotal steps to be taken = m-1 (right)+n-1(down);\\n\\tto select m-1 right steps from m+n-2 total steps then n-1 down steps from remaining n-1 down steps \\n\\t\\ttherefore ans should be **m+n-2 C m-1******\\n"
                    },
                    {
                        "username": "seaskies",
                        "content": "The note says m and n will be at most 100, then how does the platform deal with the answer bigger than 2^31-1 as the follow picture?\\nCan anyone help me out, with great appreciation!\\n![image](https://assets.leetcode.com/users/seaskies/image_1556768250.png)\\n"
                    },
                    {
                        "username": "demmr",
                        "content": "The return type of the function is int and it will fail for values of m and n going more than 40 lets say. I took dp matrix to be long type and then it is able to accomodate the values as m and n can go upto 100. But the code is accepted when I\\'m just taking dp matrix to be int type.\\n\\nIn running the test cases, I can see that Integer overflow is happening for m,n >40, but the testcases get pass. \\n\\nCan someone please let me know if I want to get it accepted for int return type for m,n = 100, then how can we proceed and is it possible using dp matrix?"
                    },
                    {
                        "username": "kruglikov",
                        "content": "This problem is essentially asking  N+M - 2 choose N-1. It\\'s a simple math problem as long as you figure out how to avoid overflowing the int type (asuume n = N+M-2 and k = min(N, M) - 1 just perform n!/max(n-k, k)! as a single step so in the the 100,2 test case it redeuces to 100 instead of calculating 100!/99! which will overflow the int type."
                    },
                    {
                        "username": "sykKo",
                        "content": "\\u7B54\\u6848\\u662F (m + n - 2)! / ((m - 1)! * (n - 1)!)\\n\\u6211\\u77E5\\u9053\\u8FD9\\u9898\\u5E94\\u8BE5\\u7528dynamic programming\\u505A\\uFF0C\\u4F46\\u662F\\u4E8B\\u5B9E\\u4E0A\\u8FD9\\u9053\\u9898\\u6211\\u4EEC\\u5728\\u5B66\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u65F6\\u5019\\u5176\\u5B9E\\u5E94\\u8BE5\\u90FD\\u505A\\u5230\\u8FC7\\uFF0C\\u5F53\\u65F6\\u53EF\\u6CA1\\u6CD5\\u7F16\\u7A0B\\u505A\\uFF0C\\u66F4\\u4F55\\u51B5\\u9898\\u76EE\\u91CC\\u7684m\\u548Cn\\u90FD\\u4E0D\\u4E00\\u5B9A\\u662F\\u5177\\u4F53\\u6570\\u5B57\\u3002\\n\\u590D\\u4E60\\u4E86\\u4E00\\u4E0B\\u4EE5\\u540E\\uFF08\\u662F\\u7684\\uFF0C\\u6211TM\\u73B0\\u5728\\u5DF2\\u7ECF\\u4E0D\\u4F1A\\u505A\\u8FD9\\u9053\\u9898\\u4E86\\uFF09\\uFF0C\\u89E3\\u7B54\\u8FC7\\u7A0B\\u5982\\u4E0B\\uFF1A\\n\\u9996\\u5148\\uFF0C\\u5C06\\u9898\\u76EE\\u8F6C\\u53D8\\u4E3A\\u628A(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u63D2\\u5165\\u5230(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u91CC\\u3002\\n\\u800C\\u8FD9\\u53C8\\u53EF\\u4EE5\\u8F6C\\u53D8\\u4E3A\\u6C42(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u548C(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u603B\\u5171\\u6709\\u591A\\u5C11\\u79CD\\u4E0D\\u540C\\u7684\\u6392\\u5217\\u65B9\\u6CD5\\uFF0C\\u90A3\\u7B54\\u6848\\u5C31\\u662F(m + n - 2)! / ((m - 1)! * (n - 1)!)\\u4E86\\u3002\\n\\nEnglish translation:\\nanswer is (m + n - 2)! / ((m - 1)! * (n - 1)!)\\nI know this problem is supposed to be solved with dynamic programming, but the truth is that we Chinese have all probably met this question when learning permutations and combinations in school. We could program then, let alone m and n might even not be actual numbers.\\nAfter reviewing a bit (yeah, I cannot solve this on my own now, years after graduating), I\\'ve solved this problem with following steps:\\n1. The problem actually equals to insert m - 1 \"right\"s into n - 1 \"downs\"\\n2. and that equals to find out in how many ways m - 1 \"1\"s and n - 1 \"0\"s can form a string\\n3. the answer here it is."
                    },
                    {
                        "username": "quantic",
                        "content": "If you try with 60 60 the Accepted solution will return -234078496 so i thing the answer should be returned MOD some prime number or the limits (m,n<= 100 ) changed."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "Fibonacci style easy DP problem"
                    }
                ]
            },
            {
                "id": 1572600,
                "content": [
                    {
                        "username": "ml4",
                        "content": "answer: (m+n-2)! / [(m-1)! * (n-1)!]"
                    },
                    {
                        "username": "vashishthaakshay18",
                        "content": "This question can be solved by two method one through dp and another through maths \\nMaths approach ->\\n1. In path we need to fix no. of down moves and fix no. of right moves so we can say that in a string of length (m-1) + (n-1) we need to find total different string possible so so we can easily see ans is (n!)/(m1!)(m2!)..... ans so \\n2. we just need to compute (n+m-2)!/(n-1)!*(m-1)!\\n\\nDp approach we can easily see that we just need find the no of possible ways to reach (i,j) index so that will be equal to dp[i][k] which is equal to the sum of its upper row or left column value i.e. dp[i][j] = dp[i-1][j] + dp[i][j-1]"
                    },
                    {
                        "username": "kavyakumar",
                        "content": "Input: m = 3, n = 2\\nOutput: 3\\nExplanation:\\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\\n1. Right -> Right -> Down\\n2. Right -> Down -> Right\\n3. Down -> Right -> Right\\n\\nOne more path is also available\\ndown->right->up->right->down"
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "Yes it is possible. However, according to problem statement, we can move either down or right. So, in the problem context 4th path is not available."
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\\ttotal steps to be taken = m-1 (right)+n-1(down);\\n\\tto select m-1 right steps from m+n-2 total steps then n-1 down steps from remaining n-1 down steps \\n\\t\\ttherefore ans should be **m+n-2 C m-1******\\n"
                    },
                    {
                        "username": "seaskies",
                        "content": "The note says m and n will be at most 100, then how does the platform deal with the answer bigger than 2^31-1 as the follow picture?\\nCan anyone help me out, with great appreciation!\\n![image](https://assets.leetcode.com/users/seaskies/image_1556768250.png)\\n"
                    },
                    {
                        "username": "demmr",
                        "content": "The return type of the function is int and it will fail for values of m and n going more than 40 lets say. I took dp matrix to be long type and then it is able to accomodate the values as m and n can go upto 100. But the code is accepted when I\\'m just taking dp matrix to be int type.\\n\\nIn running the test cases, I can see that Integer overflow is happening for m,n >40, but the testcases get pass. \\n\\nCan someone please let me know if I want to get it accepted for int return type for m,n = 100, then how can we proceed and is it possible using dp matrix?"
                    },
                    {
                        "username": "kruglikov",
                        "content": "This problem is essentially asking  N+M - 2 choose N-1. It\\'s a simple math problem as long as you figure out how to avoid overflowing the int type (asuume n = N+M-2 and k = min(N, M) - 1 just perform n!/max(n-k, k)! as a single step so in the the 100,2 test case it redeuces to 100 instead of calculating 100!/99! which will overflow the int type."
                    },
                    {
                        "username": "sykKo",
                        "content": "\\u7B54\\u6848\\u662F (m + n - 2)! / ((m - 1)! * (n - 1)!)\\n\\u6211\\u77E5\\u9053\\u8FD9\\u9898\\u5E94\\u8BE5\\u7528dynamic programming\\u505A\\uFF0C\\u4F46\\u662F\\u4E8B\\u5B9E\\u4E0A\\u8FD9\\u9053\\u9898\\u6211\\u4EEC\\u5728\\u5B66\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u65F6\\u5019\\u5176\\u5B9E\\u5E94\\u8BE5\\u90FD\\u505A\\u5230\\u8FC7\\uFF0C\\u5F53\\u65F6\\u53EF\\u6CA1\\u6CD5\\u7F16\\u7A0B\\u505A\\uFF0C\\u66F4\\u4F55\\u51B5\\u9898\\u76EE\\u91CC\\u7684m\\u548Cn\\u90FD\\u4E0D\\u4E00\\u5B9A\\u662F\\u5177\\u4F53\\u6570\\u5B57\\u3002\\n\\u590D\\u4E60\\u4E86\\u4E00\\u4E0B\\u4EE5\\u540E\\uFF08\\u662F\\u7684\\uFF0C\\u6211TM\\u73B0\\u5728\\u5DF2\\u7ECF\\u4E0D\\u4F1A\\u505A\\u8FD9\\u9053\\u9898\\u4E86\\uFF09\\uFF0C\\u89E3\\u7B54\\u8FC7\\u7A0B\\u5982\\u4E0B\\uFF1A\\n\\u9996\\u5148\\uFF0C\\u5C06\\u9898\\u76EE\\u8F6C\\u53D8\\u4E3A\\u628A(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u63D2\\u5165\\u5230(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u91CC\\u3002\\n\\u800C\\u8FD9\\u53C8\\u53EF\\u4EE5\\u8F6C\\u53D8\\u4E3A\\u6C42(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u548C(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u603B\\u5171\\u6709\\u591A\\u5C11\\u79CD\\u4E0D\\u540C\\u7684\\u6392\\u5217\\u65B9\\u6CD5\\uFF0C\\u90A3\\u7B54\\u6848\\u5C31\\u662F(m + n - 2)! / ((m - 1)! * (n - 1)!)\\u4E86\\u3002\\n\\nEnglish translation:\\nanswer is (m + n - 2)! / ((m - 1)! * (n - 1)!)\\nI know this problem is supposed to be solved with dynamic programming, but the truth is that we Chinese have all probably met this question when learning permutations and combinations in school. We could program then, let alone m and n might even not be actual numbers.\\nAfter reviewing a bit (yeah, I cannot solve this on my own now, years after graduating), I\\'ve solved this problem with following steps:\\n1. The problem actually equals to insert m - 1 \"right\"s into n - 1 \"downs\"\\n2. and that equals to find out in how many ways m - 1 \"1\"s and n - 1 \"0\"s can form a string\\n3. the answer here it is."
                    },
                    {
                        "username": "quantic",
                        "content": "If you try with 60 60 the Accepted solution will return -234078496 so i thing the answer should be returned MOD some prime number or the limits (m,n<= 100 ) changed."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "Fibonacci style easy DP problem"
                    }
                ]
            },
            {
                "id": 1571146,
                "content": [
                    {
                        "username": "ml4",
                        "content": "answer: (m+n-2)! / [(m-1)! * (n-1)!]"
                    },
                    {
                        "username": "vashishthaakshay18",
                        "content": "This question can be solved by two method one through dp and another through maths \\nMaths approach ->\\n1. In path we need to fix no. of down moves and fix no. of right moves so we can say that in a string of length (m-1) + (n-1) we need to find total different string possible so so we can easily see ans is (n!)/(m1!)(m2!)..... ans so \\n2. we just need to compute (n+m-2)!/(n-1)!*(m-1)!\\n\\nDp approach we can easily see that we just need find the no of possible ways to reach (i,j) index so that will be equal to dp[i][k] which is equal to the sum of its upper row or left column value i.e. dp[i][j] = dp[i-1][j] + dp[i][j-1]"
                    },
                    {
                        "username": "kavyakumar",
                        "content": "Input: m = 3, n = 2\\nOutput: 3\\nExplanation:\\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\\n1. Right -> Right -> Down\\n2. Right -> Down -> Right\\n3. Down -> Right -> Right\\n\\nOne more path is also available\\ndown->right->up->right->down"
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "Yes it is possible. However, according to problem statement, we can move either down or right. So, in the problem context 4th path is not available."
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\\ttotal steps to be taken = m-1 (right)+n-1(down);\\n\\tto select m-1 right steps from m+n-2 total steps then n-1 down steps from remaining n-1 down steps \\n\\t\\ttherefore ans should be **m+n-2 C m-1******\\n"
                    },
                    {
                        "username": "seaskies",
                        "content": "The note says m and n will be at most 100, then how does the platform deal with the answer bigger than 2^31-1 as the follow picture?\\nCan anyone help me out, with great appreciation!\\n![image](https://assets.leetcode.com/users/seaskies/image_1556768250.png)\\n"
                    },
                    {
                        "username": "demmr",
                        "content": "The return type of the function is int and it will fail for values of m and n going more than 40 lets say. I took dp matrix to be long type and then it is able to accomodate the values as m and n can go upto 100. But the code is accepted when I\\'m just taking dp matrix to be int type.\\n\\nIn running the test cases, I can see that Integer overflow is happening for m,n >40, but the testcases get pass. \\n\\nCan someone please let me know if I want to get it accepted for int return type for m,n = 100, then how can we proceed and is it possible using dp matrix?"
                    },
                    {
                        "username": "kruglikov",
                        "content": "This problem is essentially asking  N+M - 2 choose N-1. It\\'s a simple math problem as long as you figure out how to avoid overflowing the int type (asuume n = N+M-2 and k = min(N, M) - 1 just perform n!/max(n-k, k)! as a single step so in the the 100,2 test case it redeuces to 100 instead of calculating 100!/99! which will overflow the int type."
                    },
                    {
                        "username": "sykKo",
                        "content": "\\u7B54\\u6848\\u662F (m + n - 2)! / ((m - 1)! * (n - 1)!)\\n\\u6211\\u77E5\\u9053\\u8FD9\\u9898\\u5E94\\u8BE5\\u7528dynamic programming\\u505A\\uFF0C\\u4F46\\u662F\\u4E8B\\u5B9E\\u4E0A\\u8FD9\\u9053\\u9898\\u6211\\u4EEC\\u5728\\u5B66\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u65F6\\u5019\\u5176\\u5B9E\\u5E94\\u8BE5\\u90FD\\u505A\\u5230\\u8FC7\\uFF0C\\u5F53\\u65F6\\u53EF\\u6CA1\\u6CD5\\u7F16\\u7A0B\\u505A\\uFF0C\\u66F4\\u4F55\\u51B5\\u9898\\u76EE\\u91CC\\u7684m\\u548Cn\\u90FD\\u4E0D\\u4E00\\u5B9A\\u662F\\u5177\\u4F53\\u6570\\u5B57\\u3002\\n\\u590D\\u4E60\\u4E86\\u4E00\\u4E0B\\u4EE5\\u540E\\uFF08\\u662F\\u7684\\uFF0C\\u6211TM\\u73B0\\u5728\\u5DF2\\u7ECF\\u4E0D\\u4F1A\\u505A\\u8FD9\\u9053\\u9898\\u4E86\\uFF09\\uFF0C\\u89E3\\u7B54\\u8FC7\\u7A0B\\u5982\\u4E0B\\uFF1A\\n\\u9996\\u5148\\uFF0C\\u5C06\\u9898\\u76EE\\u8F6C\\u53D8\\u4E3A\\u628A(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u63D2\\u5165\\u5230(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u91CC\\u3002\\n\\u800C\\u8FD9\\u53C8\\u53EF\\u4EE5\\u8F6C\\u53D8\\u4E3A\\u6C42(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u548C(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u603B\\u5171\\u6709\\u591A\\u5C11\\u79CD\\u4E0D\\u540C\\u7684\\u6392\\u5217\\u65B9\\u6CD5\\uFF0C\\u90A3\\u7B54\\u6848\\u5C31\\u662F(m + n - 2)! / ((m - 1)! * (n - 1)!)\\u4E86\\u3002\\n\\nEnglish translation:\\nanswer is (m + n - 2)! / ((m - 1)! * (n - 1)!)\\nI know this problem is supposed to be solved with dynamic programming, but the truth is that we Chinese have all probably met this question when learning permutations and combinations in school. We could program then, let alone m and n might even not be actual numbers.\\nAfter reviewing a bit (yeah, I cannot solve this on my own now, years after graduating), I\\'ve solved this problem with following steps:\\n1. The problem actually equals to insert m - 1 \"right\"s into n - 1 \"downs\"\\n2. and that equals to find out in how many ways m - 1 \"1\"s and n - 1 \"0\"s can form a string\\n3. the answer here it is."
                    },
                    {
                        "username": "quantic",
                        "content": "If you try with 60 60 the Accepted solution will return -234078496 so i thing the answer should be returned MOD some prime number or the limits (m,n<= 100 ) changed."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "Fibonacci style easy DP problem"
                    }
                ]
            },
            {
                "id": 2053141,
                "content": [
                    {
                        "username": "ml4",
                        "content": "answer: (m+n-2)! / [(m-1)! * (n-1)!]"
                    },
                    {
                        "username": "vashishthaakshay18",
                        "content": "This question can be solved by two method one through dp and another through maths \\nMaths approach ->\\n1. In path we need to fix no. of down moves and fix no. of right moves so we can say that in a string of length (m-1) + (n-1) we need to find total different string possible so so we can easily see ans is (n!)/(m1!)(m2!)..... ans so \\n2. we just need to compute (n+m-2)!/(n-1)!*(m-1)!\\n\\nDp approach we can easily see that we just need find the no of possible ways to reach (i,j) index so that will be equal to dp[i][k] which is equal to the sum of its upper row or left column value i.e. dp[i][j] = dp[i-1][j] + dp[i][j-1]"
                    },
                    {
                        "username": "kavyakumar",
                        "content": "Input: m = 3, n = 2\\nOutput: 3\\nExplanation:\\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\\n1. Right -> Right -> Down\\n2. Right -> Down -> Right\\n3. Down -> Right -> Right\\n\\nOne more path is also available\\ndown->right->up->right->down"
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "Yes it is possible. However, according to problem statement, we can move either down or right. So, in the problem context 4th path is not available."
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\\ttotal steps to be taken = m-1 (right)+n-1(down);\\n\\tto select m-1 right steps from m+n-2 total steps then n-1 down steps from remaining n-1 down steps \\n\\t\\ttherefore ans should be **m+n-2 C m-1******\\n"
                    },
                    {
                        "username": "seaskies",
                        "content": "The note says m and n will be at most 100, then how does the platform deal with the answer bigger than 2^31-1 as the follow picture?\\nCan anyone help me out, with great appreciation!\\n![image](https://assets.leetcode.com/users/seaskies/image_1556768250.png)\\n"
                    },
                    {
                        "username": "demmr",
                        "content": "The return type of the function is int and it will fail for values of m and n going more than 40 lets say. I took dp matrix to be long type and then it is able to accomodate the values as m and n can go upto 100. But the code is accepted when I\\'m just taking dp matrix to be int type.\\n\\nIn running the test cases, I can see that Integer overflow is happening for m,n >40, but the testcases get pass. \\n\\nCan someone please let me know if I want to get it accepted for int return type for m,n = 100, then how can we proceed and is it possible using dp matrix?"
                    },
                    {
                        "username": "kruglikov",
                        "content": "This problem is essentially asking  N+M - 2 choose N-1. It\\'s a simple math problem as long as you figure out how to avoid overflowing the int type (asuume n = N+M-2 and k = min(N, M) - 1 just perform n!/max(n-k, k)! as a single step so in the the 100,2 test case it redeuces to 100 instead of calculating 100!/99! which will overflow the int type."
                    },
                    {
                        "username": "sykKo",
                        "content": "\\u7B54\\u6848\\u662F (m + n - 2)! / ((m - 1)! * (n - 1)!)\\n\\u6211\\u77E5\\u9053\\u8FD9\\u9898\\u5E94\\u8BE5\\u7528dynamic programming\\u505A\\uFF0C\\u4F46\\u662F\\u4E8B\\u5B9E\\u4E0A\\u8FD9\\u9053\\u9898\\u6211\\u4EEC\\u5728\\u5B66\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u65F6\\u5019\\u5176\\u5B9E\\u5E94\\u8BE5\\u90FD\\u505A\\u5230\\u8FC7\\uFF0C\\u5F53\\u65F6\\u53EF\\u6CA1\\u6CD5\\u7F16\\u7A0B\\u505A\\uFF0C\\u66F4\\u4F55\\u51B5\\u9898\\u76EE\\u91CC\\u7684m\\u548Cn\\u90FD\\u4E0D\\u4E00\\u5B9A\\u662F\\u5177\\u4F53\\u6570\\u5B57\\u3002\\n\\u590D\\u4E60\\u4E86\\u4E00\\u4E0B\\u4EE5\\u540E\\uFF08\\u662F\\u7684\\uFF0C\\u6211TM\\u73B0\\u5728\\u5DF2\\u7ECF\\u4E0D\\u4F1A\\u505A\\u8FD9\\u9053\\u9898\\u4E86\\uFF09\\uFF0C\\u89E3\\u7B54\\u8FC7\\u7A0B\\u5982\\u4E0B\\uFF1A\\n\\u9996\\u5148\\uFF0C\\u5C06\\u9898\\u76EE\\u8F6C\\u53D8\\u4E3A\\u628A(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u63D2\\u5165\\u5230(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u91CC\\u3002\\n\\u800C\\u8FD9\\u53C8\\u53EF\\u4EE5\\u8F6C\\u53D8\\u4E3A\\u6C42(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u548C(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u603B\\u5171\\u6709\\u591A\\u5C11\\u79CD\\u4E0D\\u540C\\u7684\\u6392\\u5217\\u65B9\\u6CD5\\uFF0C\\u90A3\\u7B54\\u6848\\u5C31\\u662F(m + n - 2)! / ((m - 1)! * (n - 1)!)\\u4E86\\u3002\\n\\nEnglish translation:\\nanswer is (m + n - 2)! / ((m - 1)! * (n - 1)!)\\nI know this problem is supposed to be solved with dynamic programming, but the truth is that we Chinese have all probably met this question when learning permutations and combinations in school. We could program then, let alone m and n might even not be actual numbers.\\nAfter reviewing a bit (yeah, I cannot solve this on my own now, years after graduating), I\\'ve solved this problem with following steps:\\n1. The problem actually equals to insert m - 1 \"right\"s into n - 1 \"downs\"\\n2. and that equals to find out in how many ways m - 1 \"1\"s and n - 1 \"0\"s can form a string\\n3. the answer here it is."
                    },
                    {
                        "username": "quantic",
                        "content": "If you try with 60 60 the Accepted solution will return -234078496 so i thing the answer should be returned MOD some prime number or the limits (m,n<= 100 ) changed."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "Fibonacci style easy DP problem"
                    }
                ]
            },
            {
                "id": 2048390,
                "content": [
                    {
                        "username": "1234567812345678",
                        "content": "Well, combinatorial solution is the most immediate one. However, this will require us to use long long type because of the integer overflow. Integer overflow is quite annoying especially when we are solving the computational problem like this. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "You can solve it in O(n) space with bottom-up dp."
                    },
                    {
                        "username": "shresthaaa",
                        "content": "What is wrong in this\\nclass Solution {\\npublic:\\n    int fun(int m, int n , vector<vector<int>> &v ,int r,int d )\\n    {\\n        if(r>= n || d >= m)\\n        return 0;\\n\\n       else if(v[r][d])\\n        return v[r][d]; \\n\\n        else\\n        v[r][d] = fun( m, n , v , r++, d ) + fun( m, n, v , r, d++ );\\n\\n        return v[r][d];\\n\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        int r = 0, d =0 ;\\n        return fun(m, n, v , r, d );\\n        \\n    }\\n};"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "dfs , island count , with only 2 dir?"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Whoa whoa whoa... No Backtracking??? WHYYYY  ;_;"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Why doesn\\'t this work?\\n\\n`import java.lang.*;\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return (factorial(Math.max(m,n))/factorial(Math.min(m,n)))/ factorial(Math.abs(m - n));\\n    }\\n    public int factorial(int m) {\\n        int prod = 1;\\n        for(int i = 1; i <= m; i++) {\\n            prod *= i;\\n        }\\n        return prod;\\n    }\\n}`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that there is Dynamic Programming mentioned among the related topics. This problem has nothing to do with the Dynamic Programming whatsoever, just picking an appropriate number from Pascal triangle via $$O(min(m, n))$$ multiplications and divisions."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "[@sergei99](/sergei99) Thats a good point. I guess the problem should include a note at the bottom specifying the improved time complexity as a goal once the O(mn) solution is found, like in lots of other problems."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@PierreLessard](/PierreLessard) Well, Unique Paths II is definitely a kind of such harder problem, and DP is appropriate there. But subproblems don't have to demand the same algorithms as their main problems to solve them. Somebody was complaining here that Google said them goodbye at an interview because they used DP where it was not the most efficient way."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "Its labeled dynamic programing because its a subproblem of harder unique path dynamic programming problems. If you open with the pascal triangle solution youll still need to know the dp solution since its required to solve those more complicated problems that interviewers often lead with afterwards. Also, including this as dp is good considering it is a pretty intuitive starter dp problem with how hard dp problems are to first learn."
                    },
                    {
                        "username": "lentehora",
                        "content": "Would you guys say that this is one of the easiest use cases of dynamic programming? "
                    },
                    {
                        "username": "aviralj02",
                        "content": "I\\'m so happy to solve this in first go as usually dp problems make me busy for sometime \\uD83D\\uDE00"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "For the test case : \\n`m =\\n19`\\n`n =\\n13`\\n\\nOutput:\\n`86493225`\\n\\nWhen I run it properly executes with not much time, but gives TLE when submitted. I used the Recursive approach. Any help/suggestion on this?"
                    }
                ]
            },
            {
                "id": 2043136,
                "content": [
                    {
                        "username": "1234567812345678",
                        "content": "Well, combinatorial solution is the most immediate one. However, this will require us to use long long type because of the integer overflow. Integer overflow is quite annoying especially when we are solving the computational problem like this. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "You can solve it in O(n) space with bottom-up dp."
                    },
                    {
                        "username": "shresthaaa",
                        "content": "What is wrong in this\\nclass Solution {\\npublic:\\n    int fun(int m, int n , vector<vector<int>> &v ,int r,int d )\\n    {\\n        if(r>= n || d >= m)\\n        return 0;\\n\\n       else if(v[r][d])\\n        return v[r][d]; \\n\\n        else\\n        v[r][d] = fun( m, n , v , r++, d ) + fun( m, n, v , r, d++ );\\n\\n        return v[r][d];\\n\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        int r = 0, d =0 ;\\n        return fun(m, n, v , r, d );\\n        \\n    }\\n};"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "dfs , island count , with only 2 dir?"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Whoa whoa whoa... No Backtracking??? WHYYYY  ;_;"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Why doesn\\'t this work?\\n\\n`import java.lang.*;\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return (factorial(Math.max(m,n))/factorial(Math.min(m,n)))/ factorial(Math.abs(m - n));\\n    }\\n    public int factorial(int m) {\\n        int prod = 1;\\n        for(int i = 1; i <= m; i++) {\\n            prod *= i;\\n        }\\n        return prod;\\n    }\\n}`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that there is Dynamic Programming mentioned among the related topics. This problem has nothing to do with the Dynamic Programming whatsoever, just picking an appropriate number from Pascal triangle via $$O(min(m, n))$$ multiplications and divisions."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "[@sergei99](/sergei99) Thats a good point. I guess the problem should include a note at the bottom specifying the improved time complexity as a goal once the O(mn) solution is found, like in lots of other problems."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@PierreLessard](/PierreLessard) Well, Unique Paths II is definitely a kind of such harder problem, and DP is appropriate there. But subproblems don't have to demand the same algorithms as their main problems to solve them. Somebody was complaining here that Google said them goodbye at an interview because they used DP where it was not the most efficient way."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "Its labeled dynamic programing because its a subproblem of harder unique path dynamic programming problems. If you open with the pascal triangle solution youll still need to know the dp solution since its required to solve those more complicated problems that interviewers often lead with afterwards. Also, including this as dp is good considering it is a pretty intuitive starter dp problem with how hard dp problems are to first learn."
                    },
                    {
                        "username": "lentehora",
                        "content": "Would you guys say that this is one of the easiest use cases of dynamic programming? "
                    },
                    {
                        "username": "aviralj02",
                        "content": "I\\'m so happy to solve this in first go as usually dp problems make me busy for sometime \\uD83D\\uDE00"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "For the test case : \\n`m =\\n19`\\n`n =\\n13`\\n\\nOutput:\\n`86493225`\\n\\nWhen I run it properly executes with not much time, but gives TLE when submitted. I used the Recursive approach. Any help/suggestion on this?"
                    }
                ]
            },
            {
                "id": 2043047,
                "content": [
                    {
                        "username": "1234567812345678",
                        "content": "Well, combinatorial solution is the most immediate one. However, this will require us to use long long type because of the integer overflow. Integer overflow is quite annoying especially when we are solving the computational problem like this. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "You can solve it in O(n) space with bottom-up dp."
                    },
                    {
                        "username": "shresthaaa",
                        "content": "What is wrong in this\\nclass Solution {\\npublic:\\n    int fun(int m, int n , vector<vector<int>> &v ,int r,int d )\\n    {\\n        if(r>= n || d >= m)\\n        return 0;\\n\\n       else if(v[r][d])\\n        return v[r][d]; \\n\\n        else\\n        v[r][d] = fun( m, n , v , r++, d ) + fun( m, n, v , r, d++ );\\n\\n        return v[r][d];\\n\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        int r = 0, d =0 ;\\n        return fun(m, n, v , r, d );\\n        \\n    }\\n};"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "dfs , island count , with only 2 dir?"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Whoa whoa whoa... No Backtracking??? WHYYYY  ;_;"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Why doesn\\'t this work?\\n\\n`import java.lang.*;\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return (factorial(Math.max(m,n))/factorial(Math.min(m,n)))/ factorial(Math.abs(m - n));\\n    }\\n    public int factorial(int m) {\\n        int prod = 1;\\n        for(int i = 1; i <= m; i++) {\\n            prod *= i;\\n        }\\n        return prod;\\n    }\\n}`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that there is Dynamic Programming mentioned among the related topics. This problem has nothing to do with the Dynamic Programming whatsoever, just picking an appropriate number from Pascal triangle via $$O(min(m, n))$$ multiplications and divisions."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "[@sergei99](/sergei99) Thats a good point. I guess the problem should include a note at the bottom specifying the improved time complexity as a goal once the O(mn) solution is found, like in lots of other problems."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@PierreLessard](/PierreLessard) Well, Unique Paths II is definitely a kind of such harder problem, and DP is appropriate there. But subproblems don't have to demand the same algorithms as their main problems to solve them. Somebody was complaining here that Google said them goodbye at an interview because they used DP where it was not the most efficient way."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "Its labeled dynamic programing because its a subproblem of harder unique path dynamic programming problems. If you open with the pascal triangle solution youll still need to know the dp solution since its required to solve those more complicated problems that interviewers often lead with afterwards. Also, including this as dp is good considering it is a pretty intuitive starter dp problem with how hard dp problems are to first learn."
                    },
                    {
                        "username": "lentehora",
                        "content": "Would you guys say that this is one of the easiest use cases of dynamic programming? "
                    },
                    {
                        "username": "aviralj02",
                        "content": "I\\'m so happy to solve this in first go as usually dp problems make me busy for sometime \\uD83D\\uDE00"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "For the test case : \\n`m =\\n19`\\n`n =\\n13`\\n\\nOutput:\\n`86493225`\\n\\nWhen I run it properly executes with not much time, but gives TLE when submitted. I used the Recursive approach. Any help/suggestion on this?"
                    }
                ]
            },
            {
                "id": 2043036,
                "content": [
                    {
                        "username": "1234567812345678",
                        "content": "Well, combinatorial solution is the most immediate one. However, this will require us to use long long type because of the integer overflow. Integer overflow is quite annoying especially when we are solving the computational problem like this. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "You can solve it in O(n) space with bottom-up dp."
                    },
                    {
                        "username": "shresthaaa",
                        "content": "What is wrong in this\\nclass Solution {\\npublic:\\n    int fun(int m, int n , vector<vector<int>> &v ,int r,int d )\\n    {\\n        if(r>= n || d >= m)\\n        return 0;\\n\\n       else if(v[r][d])\\n        return v[r][d]; \\n\\n        else\\n        v[r][d] = fun( m, n , v , r++, d ) + fun( m, n, v , r, d++ );\\n\\n        return v[r][d];\\n\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        int r = 0, d =0 ;\\n        return fun(m, n, v , r, d );\\n        \\n    }\\n};"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "dfs , island count , with only 2 dir?"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Whoa whoa whoa... No Backtracking??? WHYYYY  ;_;"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Why doesn\\'t this work?\\n\\n`import java.lang.*;\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return (factorial(Math.max(m,n))/factorial(Math.min(m,n)))/ factorial(Math.abs(m - n));\\n    }\\n    public int factorial(int m) {\\n        int prod = 1;\\n        for(int i = 1; i <= m; i++) {\\n            prod *= i;\\n        }\\n        return prod;\\n    }\\n}`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that there is Dynamic Programming mentioned among the related topics. This problem has nothing to do with the Dynamic Programming whatsoever, just picking an appropriate number from Pascal triangle via $$O(min(m, n))$$ multiplications and divisions."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "[@sergei99](/sergei99) Thats a good point. I guess the problem should include a note at the bottom specifying the improved time complexity as a goal once the O(mn) solution is found, like in lots of other problems."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@PierreLessard](/PierreLessard) Well, Unique Paths II is definitely a kind of such harder problem, and DP is appropriate there. But subproblems don't have to demand the same algorithms as their main problems to solve them. Somebody was complaining here that Google said them goodbye at an interview because they used DP where it was not the most efficient way."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "Its labeled dynamic programing because its a subproblem of harder unique path dynamic programming problems. If you open with the pascal triangle solution youll still need to know the dp solution since its required to solve those more complicated problems that interviewers often lead with afterwards. Also, including this as dp is good considering it is a pretty intuitive starter dp problem with how hard dp problems are to first learn."
                    },
                    {
                        "username": "lentehora",
                        "content": "Would you guys say that this is one of the easiest use cases of dynamic programming? "
                    },
                    {
                        "username": "aviralj02",
                        "content": "I\\'m so happy to solve this in first go as usually dp problems make me busy for sometime \\uD83D\\uDE00"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "For the test case : \\n`m =\\n19`\\n`n =\\n13`\\n\\nOutput:\\n`86493225`\\n\\nWhen I run it properly executes with not much time, but gives TLE when submitted. I used the Recursive approach. Any help/suggestion on this?"
                    }
                ]
            },
            {
                "id": 2043006,
                "content": [
                    {
                        "username": "1234567812345678",
                        "content": "Well, combinatorial solution is the most immediate one. However, this will require us to use long long type because of the integer overflow. Integer overflow is quite annoying especially when we are solving the computational problem like this. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "You can solve it in O(n) space with bottom-up dp."
                    },
                    {
                        "username": "shresthaaa",
                        "content": "What is wrong in this\\nclass Solution {\\npublic:\\n    int fun(int m, int n , vector<vector<int>> &v ,int r,int d )\\n    {\\n        if(r>= n || d >= m)\\n        return 0;\\n\\n       else if(v[r][d])\\n        return v[r][d]; \\n\\n        else\\n        v[r][d] = fun( m, n , v , r++, d ) + fun( m, n, v , r, d++ );\\n\\n        return v[r][d];\\n\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        int r = 0, d =0 ;\\n        return fun(m, n, v , r, d );\\n        \\n    }\\n};"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "dfs , island count , with only 2 dir?"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Whoa whoa whoa... No Backtracking??? WHYYYY  ;_;"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Why doesn\\'t this work?\\n\\n`import java.lang.*;\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return (factorial(Math.max(m,n))/factorial(Math.min(m,n)))/ factorial(Math.abs(m - n));\\n    }\\n    public int factorial(int m) {\\n        int prod = 1;\\n        for(int i = 1; i <= m; i++) {\\n            prod *= i;\\n        }\\n        return prod;\\n    }\\n}`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that there is Dynamic Programming mentioned among the related topics. This problem has nothing to do with the Dynamic Programming whatsoever, just picking an appropriate number from Pascal triangle via $$O(min(m, n))$$ multiplications and divisions."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "[@sergei99](/sergei99) Thats a good point. I guess the problem should include a note at the bottom specifying the improved time complexity as a goal once the O(mn) solution is found, like in lots of other problems."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@PierreLessard](/PierreLessard) Well, Unique Paths II is definitely a kind of such harder problem, and DP is appropriate there. But subproblems don't have to demand the same algorithms as their main problems to solve them. Somebody was complaining here that Google said them goodbye at an interview because they used DP where it was not the most efficient way."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "Its labeled dynamic programing because its a subproblem of harder unique path dynamic programming problems. If you open with the pascal triangle solution youll still need to know the dp solution since its required to solve those more complicated problems that interviewers often lead with afterwards. Also, including this as dp is good considering it is a pretty intuitive starter dp problem with how hard dp problems are to first learn."
                    },
                    {
                        "username": "lentehora",
                        "content": "Would you guys say that this is one of the easiest use cases of dynamic programming? "
                    },
                    {
                        "username": "aviralj02",
                        "content": "I\\'m so happy to solve this in first go as usually dp problems make me busy for sometime \\uD83D\\uDE00"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "For the test case : \\n`m =\\n19`\\n`n =\\n13`\\n\\nOutput:\\n`86493225`\\n\\nWhen I run it properly executes with not much time, but gives TLE when submitted. I used the Recursive approach. Any help/suggestion on this?"
                    }
                ]
            },
            {
                "id": 2042827,
                "content": [
                    {
                        "username": "1234567812345678",
                        "content": "Well, combinatorial solution is the most immediate one. However, this will require us to use long long type because of the integer overflow. Integer overflow is quite annoying especially when we are solving the computational problem like this. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "You can solve it in O(n) space with bottom-up dp."
                    },
                    {
                        "username": "shresthaaa",
                        "content": "What is wrong in this\\nclass Solution {\\npublic:\\n    int fun(int m, int n , vector<vector<int>> &v ,int r,int d )\\n    {\\n        if(r>= n || d >= m)\\n        return 0;\\n\\n       else if(v[r][d])\\n        return v[r][d]; \\n\\n        else\\n        v[r][d] = fun( m, n , v , r++, d ) + fun( m, n, v , r, d++ );\\n\\n        return v[r][d];\\n\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        int r = 0, d =0 ;\\n        return fun(m, n, v , r, d );\\n        \\n    }\\n};"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "dfs , island count , with only 2 dir?"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Whoa whoa whoa... No Backtracking??? WHYYYY  ;_;"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Why doesn\\'t this work?\\n\\n`import java.lang.*;\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return (factorial(Math.max(m,n))/factorial(Math.min(m,n)))/ factorial(Math.abs(m - n));\\n    }\\n    public int factorial(int m) {\\n        int prod = 1;\\n        for(int i = 1; i <= m; i++) {\\n            prod *= i;\\n        }\\n        return prod;\\n    }\\n}`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that there is Dynamic Programming mentioned among the related topics. This problem has nothing to do with the Dynamic Programming whatsoever, just picking an appropriate number from Pascal triangle via $$O(min(m, n))$$ multiplications and divisions."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "[@sergei99](/sergei99) Thats a good point. I guess the problem should include a note at the bottom specifying the improved time complexity as a goal once the O(mn) solution is found, like in lots of other problems."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@PierreLessard](/PierreLessard) Well, Unique Paths II is definitely a kind of such harder problem, and DP is appropriate there. But subproblems don't have to demand the same algorithms as their main problems to solve them. Somebody was complaining here that Google said them goodbye at an interview because they used DP where it was not the most efficient way."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "Its labeled dynamic programing because its a subproblem of harder unique path dynamic programming problems. If you open with the pascal triangle solution youll still need to know the dp solution since its required to solve those more complicated problems that interviewers often lead with afterwards. Also, including this as dp is good considering it is a pretty intuitive starter dp problem with how hard dp problems are to first learn."
                    },
                    {
                        "username": "lentehora",
                        "content": "Would you guys say that this is one of the easiest use cases of dynamic programming? "
                    },
                    {
                        "username": "aviralj02",
                        "content": "I\\'m so happy to solve this in first go as usually dp problems make me busy for sometime \\uD83D\\uDE00"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "For the test case : \\n`m =\\n19`\\n`n =\\n13`\\n\\nOutput:\\n`86493225`\\n\\nWhen I run it properly executes with not much time, but gives TLE when submitted. I used the Recursive approach. Any help/suggestion on this?"
                    }
                ]
            },
            {
                "id": 2042687,
                "content": [
                    {
                        "username": "1234567812345678",
                        "content": "Well, combinatorial solution is the most immediate one. However, this will require us to use long long type because of the integer overflow. Integer overflow is quite annoying especially when we are solving the computational problem like this. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "You can solve it in O(n) space with bottom-up dp."
                    },
                    {
                        "username": "shresthaaa",
                        "content": "What is wrong in this\\nclass Solution {\\npublic:\\n    int fun(int m, int n , vector<vector<int>> &v ,int r,int d )\\n    {\\n        if(r>= n || d >= m)\\n        return 0;\\n\\n       else if(v[r][d])\\n        return v[r][d]; \\n\\n        else\\n        v[r][d] = fun( m, n , v , r++, d ) + fun( m, n, v , r, d++ );\\n\\n        return v[r][d];\\n\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        int r = 0, d =0 ;\\n        return fun(m, n, v , r, d );\\n        \\n    }\\n};"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "dfs , island count , with only 2 dir?"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Whoa whoa whoa... No Backtracking??? WHYYYY  ;_;"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Why doesn\\'t this work?\\n\\n`import java.lang.*;\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return (factorial(Math.max(m,n))/factorial(Math.min(m,n)))/ factorial(Math.abs(m - n));\\n    }\\n    public int factorial(int m) {\\n        int prod = 1;\\n        for(int i = 1; i <= m; i++) {\\n            prod *= i;\\n        }\\n        return prod;\\n    }\\n}`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that there is Dynamic Programming mentioned among the related topics. This problem has nothing to do with the Dynamic Programming whatsoever, just picking an appropriate number from Pascal triangle via $$O(min(m, n))$$ multiplications and divisions."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "[@sergei99](/sergei99) Thats a good point. I guess the problem should include a note at the bottom specifying the improved time complexity as a goal once the O(mn) solution is found, like in lots of other problems."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@PierreLessard](/PierreLessard) Well, Unique Paths II is definitely a kind of such harder problem, and DP is appropriate there. But subproblems don't have to demand the same algorithms as their main problems to solve them. Somebody was complaining here that Google said them goodbye at an interview because they used DP where it was not the most efficient way."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "Its labeled dynamic programing because its a subproblem of harder unique path dynamic programming problems. If you open with the pascal triangle solution youll still need to know the dp solution since its required to solve those more complicated problems that interviewers often lead with afterwards. Also, including this as dp is good considering it is a pretty intuitive starter dp problem with how hard dp problems are to first learn."
                    },
                    {
                        "username": "lentehora",
                        "content": "Would you guys say that this is one of the easiest use cases of dynamic programming? "
                    },
                    {
                        "username": "aviralj02",
                        "content": "I\\'m so happy to solve this in first go as usually dp problems make me busy for sometime \\uD83D\\uDE00"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "For the test case : \\n`m =\\n19`\\n`n =\\n13`\\n\\nOutput:\\n`86493225`\\n\\nWhen I run it properly executes with not much time, but gives TLE when submitted. I used the Recursive approach. Any help/suggestion on this?"
                    }
                ]
            },
            {
                "id": 2042530,
                "content": [
                    {
                        "username": "1234567812345678",
                        "content": "Well, combinatorial solution is the most immediate one. However, this will require us to use long long type because of the integer overflow. Integer overflow is quite annoying especially when we are solving the computational problem like this. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "You can solve it in O(n) space with bottom-up dp."
                    },
                    {
                        "username": "shresthaaa",
                        "content": "What is wrong in this\\nclass Solution {\\npublic:\\n    int fun(int m, int n , vector<vector<int>> &v ,int r,int d )\\n    {\\n        if(r>= n || d >= m)\\n        return 0;\\n\\n       else if(v[r][d])\\n        return v[r][d]; \\n\\n        else\\n        v[r][d] = fun( m, n , v , r++, d ) + fun( m, n, v , r, d++ );\\n\\n        return v[r][d];\\n\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        int r = 0, d =0 ;\\n        return fun(m, n, v , r, d );\\n        \\n    }\\n};"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "dfs , island count , with only 2 dir?"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Whoa whoa whoa... No Backtracking??? WHYYYY  ;_;"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Why doesn\\'t this work?\\n\\n`import java.lang.*;\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return (factorial(Math.max(m,n))/factorial(Math.min(m,n)))/ factorial(Math.abs(m - n));\\n    }\\n    public int factorial(int m) {\\n        int prod = 1;\\n        for(int i = 1; i <= m; i++) {\\n            prod *= i;\\n        }\\n        return prod;\\n    }\\n}`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that there is Dynamic Programming mentioned among the related topics. This problem has nothing to do with the Dynamic Programming whatsoever, just picking an appropriate number from Pascal triangle via $$O(min(m, n))$$ multiplications and divisions."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "[@sergei99](/sergei99) Thats a good point. I guess the problem should include a note at the bottom specifying the improved time complexity as a goal once the O(mn) solution is found, like in lots of other problems."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@PierreLessard](/PierreLessard) Well, Unique Paths II is definitely a kind of such harder problem, and DP is appropriate there. But subproblems don't have to demand the same algorithms as their main problems to solve them. Somebody was complaining here that Google said them goodbye at an interview because they used DP where it was not the most efficient way."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "Its labeled dynamic programing because its a subproblem of harder unique path dynamic programming problems. If you open with the pascal triangle solution youll still need to know the dp solution since its required to solve those more complicated problems that interviewers often lead with afterwards. Also, including this as dp is good considering it is a pretty intuitive starter dp problem with how hard dp problems are to first learn."
                    },
                    {
                        "username": "lentehora",
                        "content": "Would you guys say that this is one of the easiest use cases of dynamic programming? "
                    },
                    {
                        "username": "aviralj02",
                        "content": "I\\'m so happy to solve this in first go as usually dp problems make me busy for sometime \\uD83D\\uDE00"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "For the test case : \\n`m =\\n19`\\n`n =\\n13`\\n\\nOutput:\\n`86493225`\\n\\nWhen I run it properly executes with not much time, but gives TLE when submitted. I used the Recursive approach. Any help/suggestion on this?"
                    }
                ]
            },
            {
                "id": 2042504,
                "content": [
                    {
                        "username": "1234567812345678",
                        "content": "Well, combinatorial solution is the most immediate one. However, this will require us to use long long type because of the integer overflow. Integer overflow is quite annoying especially when we are solving the computational problem like this. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "You can solve it in O(n) space with bottom-up dp."
                    },
                    {
                        "username": "shresthaaa",
                        "content": "What is wrong in this\\nclass Solution {\\npublic:\\n    int fun(int m, int n , vector<vector<int>> &v ,int r,int d )\\n    {\\n        if(r>= n || d >= m)\\n        return 0;\\n\\n       else if(v[r][d])\\n        return v[r][d]; \\n\\n        else\\n        v[r][d] = fun( m, n , v , r++, d ) + fun( m, n, v , r, d++ );\\n\\n        return v[r][d];\\n\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        int r = 0, d =0 ;\\n        return fun(m, n, v , r, d );\\n        \\n    }\\n};"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "dfs , island count , with only 2 dir?"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Whoa whoa whoa... No Backtracking??? WHYYYY  ;_;"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Why doesn\\'t this work?\\n\\n`import java.lang.*;\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return (factorial(Math.max(m,n))/factorial(Math.min(m,n)))/ factorial(Math.abs(m - n));\\n    }\\n    public int factorial(int m) {\\n        int prod = 1;\\n        for(int i = 1; i <= m; i++) {\\n            prod *= i;\\n        }\\n        return prod;\\n    }\\n}`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that there is Dynamic Programming mentioned among the related topics. This problem has nothing to do with the Dynamic Programming whatsoever, just picking an appropriate number from Pascal triangle via $$O(min(m, n))$$ multiplications and divisions."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "[@sergei99](/sergei99) Thats a good point. I guess the problem should include a note at the bottom specifying the improved time complexity as a goal once the O(mn) solution is found, like in lots of other problems."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@PierreLessard](/PierreLessard) Well, Unique Paths II is definitely a kind of such harder problem, and DP is appropriate there. But subproblems don't have to demand the same algorithms as their main problems to solve them. Somebody was complaining here that Google said them goodbye at an interview because they used DP where it was not the most efficient way."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "Its labeled dynamic programing because its a subproblem of harder unique path dynamic programming problems. If you open with the pascal triangle solution youll still need to know the dp solution since its required to solve those more complicated problems that interviewers often lead with afterwards. Also, including this as dp is good considering it is a pretty intuitive starter dp problem with how hard dp problems are to first learn."
                    },
                    {
                        "username": "lentehora",
                        "content": "Would you guys say that this is one of the easiest use cases of dynamic programming? "
                    },
                    {
                        "username": "aviralj02",
                        "content": "I\\'m so happy to solve this in first go as usually dp problems make me busy for sometime \\uD83D\\uDE00"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "For the test case : \\n`m =\\n19`\\n`n =\\n13`\\n\\nOutput:\\n`86493225`\\n\\nWhen I run it properly executes with not much time, but gives TLE when submitted. I used the Recursive approach. Any help/suggestion on this?"
                    }
                ]
            },
            {
                "id": 2042478,
                "content": [
                    {
                        "username": "1234567812345678",
                        "content": "Well, combinatorial solution is the most immediate one. However, this will require us to use long long type because of the integer overflow. Integer overflow is quite annoying especially when we are solving the computational problem like this. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "You can solve it in O(n) space with bottom-up dp."
                    },
                    {
                        "username": "shresthaaa",
                        "content": "What is wrong in this\\nclass Solution {\\npublic:\\n    int fun(int m, int n , vector<vector<int>> &v ,int r,int d )\\n    {\\n        if(r>= n || d >= m)\\n        return 0;\\n\\n       else if(v[r][d])\\n        return v[r][d]; \\n\\n        else\\n        v[r][d] = fun( m, n , v , r++, d ) + fun( m, n, v , r, d++ );\\n\\n        return v[r][d];\\n\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        int r = 0, d =0 ;\\n        return fun(m, n, v , r, d );\\n        \\n    }\\n};"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "dfs , island count , with only 2 dir?"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Whoa whoa whoa... No Backtracking??? WHYYYY  ;_;"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Why doesn\\'t this work?\\n\\n`import java.lang.*;\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return (factorial(Math.max(m,n))/factorial(Math.min(m,n)))/ factorial(Math.abs(m - n));\\n    }\\n    public int factorial(int m) {\\n        int prod = 1;\\n        for(int i = 1; i <= m; i++) {\\n            prod *= i;\\n        }\\n        return prod;\\n    }\\n}`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that there is Dynamic Programming mentioned among the related topics. This problem has nothing to do with the Dynamic Programming whatsoever, just picking an appropriate number from Pascal triangle via $$O(min(m, n))$$ multiplications and divisions."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "[@sergei99](/sergei99) Thats a good point. I guess the problem should include a note at the bottom specifying the improved time complexity as a goal once the O(mn) solution is found, like in lots of other problems."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@PierreLessard](/PierreLessard) Well, Unique Paths II is definitely a kind of such harder problem, and DP is appropriate there. But subproblems don't have to demand the same algorithms as their main problems to solve them. Somebody was complaining here that Google said them goodbye at an interview because they used DP where it was not the most efficient way."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "Its labeled dynamic programing because its a subproblem of harder unique path dynamic programming problems. If you open with the pascal triangle solution youll still need to know the dp solution since its required to solve those more complicated problems that interviewers often lead with afterwards. Also, including this as dp is good considering it is a pretty intuitive starter dp problem with how hard dp problems are to first learn."
                    },
                    {
                        "username": "lentehora",
                        "content": "Would you guys say that this is one of the easiest use cases of dynamic programming? "
                    },
                    {
                        "username": "aviralj02",
                        "content": "I\\'m so happy to solve this in first go as usually dp problems make me busy for sometime \\uD83D\\uDE00"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "For the test case : \\n`m =\\n19`\\n`n =\\n13`\\n\\nOutput:\\n`86493225`\\n\\nWhen I run it properly executes with not much time, but gives TLE when submitted. I used the Recursive approach. Any help/suggestion on this?"
                    }
                ]
            },
            {
                "id": 2042468,
                "content": [
                    {
                        "username": "kiart-tantasi",
                        "content": "It is a good dp but I do not like that only dp or limited solutions would pass the time limit.\\n\\nI like solving these questions in some other ways. (even they are slower)"
                    },
                    {
                        "username": "layyy",
                        "content": "directly calculating the factorials will give overflow, so apply some math to the answer"
                    },
                    {
                        "username": "nikalinov",
                        "content": "Now I am become Leetcode, the destroyer of weekends"
                    },
                    {
                        "username": "GD18",
                        "content": "standard dfs, dont overthink"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "This [question](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/) is asked a lot of times in interviews!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[I\\'ve explained  with images too here](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Is this the first weekend without a Hard?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "Would a recursive solution be accepted in an interview? My solution beats 50% on time (2ms) and 69% on memory but I see most people talking about other approaches and I wouldn't actually know how to solve it any other way...\n\nhttps://leetcode.com/problems/unique-paths/solutions/3995427/pure-c-recursive-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it depends on which firm is interviewing you but recursion + memoization is a perfectly acceptable way to solve dp problems. With practice, you can convert from recursion directly into a bottom up solution if you want to avoid recursion.\\nThis is the technique I used to solve ``63. Unique Paths II``. The commented out section was the original recursive approach.\\nhttps://leetcode.com/submissions/detail/1039268411/"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "already done, just pressed submit"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Well explained solutions and code is in JAVA**\\nhttps://leetcode.com/problems/unique-paths/solutions/2363431/using-maths-0ms-java-solution/\\nhttps://leetcode.com/problems/unique-paths/solutions/2675825/2-easy-explained-java-solution/"
                    }
                ]
            },
            {
                "id": 2042464,
                "content": [
                    {
                        "username": "kiart-tantasi",
                        "content": "It is a good dp but I do not like that only dp or limited solutions would pass the time limit.\\n\\nI like solving these questions in some other ways. (even they are slower)"
                    },
                    {
                        "username": "layyy",
                        "content": "directly calculating the factorials will give overflow, so apply some math to the answer"
                    },
                    {
                        "username": "nikalinov",
                        "content": "Now I am become Leetcode, the destroyer of weekends"
                    },
                    {
                        "username": "GD18",
                        "content": "standard dfs, dont overthink"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "This [question](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/) is asked a lot of times in interviews!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[I\\'ve explained  with images too here](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Is this the first weekend without a Hard?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "Would a recursive solution be accepted in an interview? My solution beats 50% on time (2ms) and 69% on memory but I see most people talking about other approaches and I wouldn't actually know how to solve it any other way...\n\nhttps://leetcode.com/problems/unique-paths/solutions/3995427/pure-c-recursive-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it depends on which firm is interviewing you but recursion + memoization is a perfectly acceptable way to solve dp problems. With practice, you can convert from recursion directly into a bottom up solution if you want to avoid recursion.\\nThis is the technique I used to solve ``63. Unique Paths II``. The commented out section was the original recursive approach.\\nhttps://leetcode.com/submissions/detail/1039268411/"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "already done, just pressed submit"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Well explained solutions and code is in JAVA**\\nhttps://leetcode.com/problems/unique-paths/solutions/2363431/using-maths-0ms-java-solution/\\nhttps://leetcode.com/problems/unique-paths/solutions/2675825/2-easy-explained-java-solution/"
                    }
                ]
            },
            {
                "id": 2042365,
                "content": [
                    {
                        "username": "kiart-tantasi",
                        "content": "It is a good dp but I do not like that only dp or limited solutions would pass the time limit.\\n\\nI like solving these questions in some other ways. (even they are slower)"
                    },
                    {
                        "username": "layyy",
                        "content": "directly calculating the factorials will give overflow, so apply some math to the answer"
                    },
                    {
                        "username": "nikalinov",
                        "content": "Now I am become Leetcode, the destroyer of weekends"
                    },
                    {
                        "username": "GD18",
                        "content": "standard dfs, dont overthink"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "This [question](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/) is asked a lot of times in interviews!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[I\\'ve explained  with images too here](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Is this the first weekend without a Hard?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "Would a recursive solution be accepted in an interview? My solution beats 50% on time (2ms) and 69% on memory but I see most people talking about other approaches and I wouldn't actually know how to solve it any other way...\n\nhttps://leetcode.com/problems/unique-paths/solutions/3995427/pure-c-recursive-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it depends on which firm is interviewing you but recursion + memoization is a perfectly acceptable way to solve dp problems. With practice, you can convert from recursion directly into a bottom up solution if you want to avoid recursion.\\nThis is the technique I used to solve ``63. Unique Paths II``. The commented out section was the original recursive approach.\\nhttps://leetcode.com/submissions/detail/1039268411/"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "already done, just pressed submit"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Well explained solutions and code is in JAVA**\\nhttps://leetcode.com/problems/unique-paths/solutions/2363431/using-maths-0ms-java-solution/\\nhttps://leetcode.com/problems/unique-paths/solutions/2675825/2-easy-explained-java-solution/"
                    }
                ]
            },
            {
                "id": 2042144,
                "content": [
                    {
                        "username": "kiart-tantasi",
                        "content": "It is a good dp but I do not like that only dp or limited solutions would pass the time limit.\\n\\nI like solving these questions in some other ways. (even they are slower)"
                    },
                    {
                        "username": "layyy",
                        "content": "directly calculating the factorials will give overflow, so apply some math to the answer"
                    },
                    {
                        "username": "nikalinov",
                        "content": "Now I am become Leetcode, the destroyer of weekends"
                    },
                    {
                        "username": "GD18",
                        "content": "standard dfs, dont overthink"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "This [question](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/) is asked a lot of times in interviews!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[I\\'ve explained  with images too here](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Is this the first weekend without a Hard?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "Would a recursive solution be accepted in an interview? My solution beats 50% on time (2ms) and 69% on memory but I see most people talking about other approaches and I wouldn't actually know how to solve it any other way...\n\nhttps://leetcode.com/problems/unique-paths/solutions/3995427/pure-c-recursive-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it depends on which firm is interviewing you but recursion + memoization is a perfectly acceptable way to solve dp problems. With practice, you can convert from recursion directly into a bottom up solution if you want to avoid recursion.\\nThis is the technique I used to solve ``63. Unique Paths II``. The commented out section was the original recursive approach.\\nhttps://leetcode.com/submissions/detail/1039268411/"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "already done, just pressed submit"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Well explained solutions and code is in JAVA**\\nhttps://leetcode.com/problems/unique-paths/solutions/2363431/using-maths-0ms-java-solution/\\nhttps://leetcode.com/problems/unique-paths/solutions/2675825/2-easy-explained-java-solution/"
                    }
                ]
            },
            {
                "id": 2042087,
                "content": [
                    {
                        "username": "kiart-tantasi",
                        "content": "It is a good dp but I do not like that only dp or limited solutions would pass the time limit.\\n\\nI like solving these questions in some other ways. (even they are slower)"
                    },
                    {
                        "username": "layyy",
                        "content": "directly calculating the factorials will give overflow, so apply some math to the answer"
                    },
                    {
                        "username": "nikalinov",
                        "content": "Now I am become Leetcode, the destroyer of weekends"
                    },
                    {
                        "username": "GD18",
                        "content": "standard dfs, dont overthink"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "This [question](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/) is asked a lot of times in interviews!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[I\\'ve explained  with images too here](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Is this the first weekend without a Hard?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "Would a recursive solution be accepted in an interview? My solution beats 50% on time (2ms) and 69% on memory but I see most people talking about other approaches and I wouldn't actually know how to solve it any other way...\n\nhttps://leetcode.com/problems/unique-paths/solutions/3995427/pure-c-recursive-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it depends on which firm is interviewing you but recursion + memoization is a perfectly acceptable way to solve dp problems. With practice, you can convert from recursion directly into a bottom up solution if you want to avoid recursion.\\nThis is the technique I used to solve ``63. Unique Paths II``. The commented out section was the original recursive approach.\\nhttps://leetcode.com/submissions/detail/1039268411/"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "already done, just pressed submit"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Well explained solutions and code is in JAVA**\\nhttps://leetcode.com/problems/unique-paths/solutions/2363431/using-maths-0ms-java-solution/\\nhttps://leetcode.com/problems/unique-paths/solutions/2675825/2-easy-explained-java-solution/"
                    }
                ]
            },
            {
                "id": 2042085,
                "content": [
                    {
                        "username": "kiart-tantasi",
                        "content": "It is a good dp but I do not like that only dp or limited solutions would pass the time limit.\\n\\nI like solving these questions in some other ways. (even they are slower)"
                    },
                    {
                        "username": "layyy",
                        "content": "directly calculating the factorials will give overflow, so apply some math to the answer"
                    },
                    {
                        "username": "nikalinov",
                        "content": "Now I am become Leetcode, the destroyer of weekends"
                    },
                    {
                        "username": "GD18",
                        "content": "standard dfs, dont overthink"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "This [question](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/) is asked a lot of times in interviews!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[I\\'ve explained  with images too here](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Is this the first weekend without a Hard?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "Would a recursive solution be accepted in an interview? My solution beats 50% on time (2ms) and 69% on memory but I see most people talking about other approaches and I wouldn't actually know how to solve it any other way...\n\nhttps://leetcode.com/problems/unique-paths/solutions/3995427/pure-c-recursive-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it depends on which firm is interviewing you but recursion + memoization is a perfectly acceptable way to solve dp problems. With practice, you can convert from recursion directly into a bottom up solution if you want to avoid recursion.\\nThis is the technique I used to solve ``63. Unique Paths II``. The commented out section was the original recursive approach.\\nhttps://leetcode.com/submissions/detail/1039268411/"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "already done, just pressed submit"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Well explained solutions and code is in JAVA**\\nhttps://leetcode.com/problems/unique-paths/solutions/2363431/using-maths-0ms-java-solution/\\nhttps://leetcode.com/problems/unique-paths/solutions/2675825/2-easy-explained-java-solution/"
                    }
                ]
            },
            {
                "id": 2042035,
                "content": [
                    {
                        "username": "kiart-tantasi",
                        "content": "It is a good dp but I do not like that only dp or limited solutions would pass the time limit.\\n\\nI like solving these questions in some other ways. (even they are slower)"
                    },
                    {
                        "username": "layyy",
                        "content": "directly calculating the factorials will give overflow, so apply some math to the answer"
                    },
                    {
                        "username": "nikalinov",
                        "content": "Now I am become Leetcode, the destroyer of weekends"
                    },
                    {
                        "username": "GD18",
                        "content": "standard dfs, dont overthink"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "This [question](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/) is asked a lot of times in interviews!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[I\\'ve explained  with images too here](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Is this the first weekend without a Hard?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "Would a recursive solution be accepted in an interview? My solution beats 50% on time (2ms) and 69% on memory but I see most people talking about other approaches and I wouldn't actually know how to solve it any other way...\n\nhttps://leetcode.com/problems/unique-paths/solutions/3995427/pure-c-recursive-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it depends on which firm is interviewing you but recursion + memoization is a perfectly acceptable way to solve dp problems. With practice, you can convert from recursion directly into a bottom up solution if you want to avoid recursion.\\nThis is the technique I used to solve ``63. Unique Paths II``. The commented out section was the original recursive approach.\\nhttps://leetcode.com/submissions/detail/1039268411/"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "already done, just pressed submit"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Well explained solutions and code is in JAVA**\\nhttps://leetcode.com/problems/unique-paths/solutions/2363431/using-maths-0ms-java-solution/\\nhttps://leetcode.com/problems/unique-paths/solutions/2675825/2-easy-explained-java-solution/"
                    }
                ]
            },
            {
                "id": 2042034,
                "content": [
                    {
                        "username": "kiart-tantasi",
                        "content": "It is a good dp but I do not like that only dp or limited solutions would pass the time limit.\\n\\nI like solving these questions in some other ways. (even they are slower)"
                    },
                    {
                        "username": "layyy",
                        "content": "directly calculating the factorials will give overflow, so apply some math to the answer"
                    },
                    {
                        "username": "nikalinov",
                        "content": "Now I am become Leetcode, the destroyer of weekends"
                    },
                    {
                        "username": "GD18",
                        "content": "standard dfs, dont overthink"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "This [question](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/) is asked a lot of times in interviews!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[I\\'ve explained  with images too here](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Is this the first weekend without a Hard?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "Would a recursive solution be accepted in an interview? My solution beats 50% on time (2ms) and 69% on memory but I see most people talking about other approaches and I wouldn't actually know how to solve it any other way...\n\nhttps://leetcode.com/problems/unique-paths/solutions/3995427/pure-c-recursive-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it depends on which firm is interviewing you but recursion + memoization is a perfectly acceptable way to solve dp problems. With practice, you can convert from recursion directly into a bottom up solution if you want to avoid recursion.\\nThis is the technique I used to solve ``63. Unique Paths II``. The commented out section was the original recursive approach.\\nhttps://leetcode.com/submissions/detail/1039268411/"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "already done, just pressed submit"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Well explained solutions and code is in JAVA**\\nhttps://leetcode.com/problems/unique-paths/solutions/2363431/using-maths-0ms-java-solution/\\nhttps://leetcode.com/problems/unique-paths/solutions/2675825/2-easy-explained-java-solution/"
                    }
                ]
            },
            {
                "id": 2041953,
                "content": [
                    {
                        "username": "kiart-tantasi",
                        "content": "It is a good dp but I do not like that only dp or limited solutions would pass the time limit.\\n\\nI like solving these questions in some other ways. (even they are slower)"
                    },
                    {
                        "username": "layyy",
                        "content": "directly calculating the factorials will give overflow, so apply some math to the answer"
                    },
                    {
                        "username": "nikalinov",
                        "content": "Now I am become Leetcode, the destroyer of weekends"
                    },
                    {
                        "username": "GD18",
                        "content": "standard dfs, dont overthink"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "This [question](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/) is asked a lot of times in interviews!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[I\\'ve explained  with images too here](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Is this the first weekend without a Hard?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "Would a recursive solution be accepted in an interview? My solution beats 50% on time (2ms) and 69% on memory but I see most people talking about other approaches and I wouldn't actually know how to solve it any other way...\n\nhttps://leetcode.com/problems/unique-paths/solutions/3995427/pure-c-recursive-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it depends on which firm is interviewing you but recursion + memoization is a perfectly acceptable way to solve dp problems. With practice, you can convert from recursion directly into a bottom up solution if you want to avoid recursion.\\nThis is the technique I used to solve ``63. Unique Paths II``. The commented out section was the original recursive approach.\\nhttps://leetcode.com/submissions/detail/1039268411/"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "already done, just pressed submit"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Well explained solutions and code is in JAVA**\\nhttps://leetcode.com/problems/unique-paths/solutions/2363431/using-maths-0ms-java-solution/\\nhttps://leetcode.com/problems/unique-paths/solutions/2675825/2-easy-explained-java-solution/"
                    }
                ]
            },
            {
                "id": 2041804,
                "content": [
                    {
                        "username": "kiart-tantasi",
                        "content": "It is a good dp but I do not like that only dp or limited solutions would pass the time limit.\\n\\nI like solving these questions in some other ways. (even they are slower)"
                    },
                    {
                        "username": "layyy",
                        "content": "directly calculating the factorials will give overflow, so apply some math to the answer"
                    },
                    {
                        "username": "nikalinov",
                        "content": "Now I am become Leetcode, the destroyer of weekends"
                    },
                    {
                        "username": "GD18",
                        "content": "standard dfs, dont overthink"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "This [question](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/) is asked a lot of times in interviews!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[I\\'ve explained  with images too here](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Is this the first weekend without a Hard?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "Would a recursive solution be accepted in an interview? My solution beats 50% on time (2ms) and 69% on memory but I see most people talking about other approaches and I wouldn't actually know how to solve it any other way...\n\nhttps://leetcode.com/problems/unique-paths/solutions/3995427/pure-c-recursive-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it depends on which firm is interviewing you but recursion + memoization is a perfectly acceptable way to solve dp problems. With practice, you can convert from recursion directly into a bottom up solution if you want to avoid recursion.\\nThis is the technique I used to solve ``63. Unique Paths II``. The commented out section was the original recursive approach.\\nhttps://leetcode.com/submissions/detail/1039268411/"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "already done, just pressed submit"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Well explained solutions and code is in JAVA**\\nhttps://leetcode.com/problems/unique-paths/solutions/2363431/using-maths-0ms-java-solution/\\nhttps://leetcode.com/problems/unique-paths/solutions/2675825/2-easy-explained-java-solution/"
                    }
                ]
            },
            {
                "id": 2041779,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "If you wish to use the combinations formula instead of a dp matrix then a recursive formula that can be used is\n```\ncombin(r, r) = 1\ncombin(n, r) = combin(n-1, r) * n / (n - r)\n```\nNote that you will need to use a ``long long`` integer for your intermediate products otherwise they will overflow."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*after an annoying contest, I would say, this question good*"
                    },
                    {
                        "username": "jaggz01",
                        "content": "The combinations formula is = Combination (m,n) = m!/(n! * (m-n)!). Use this formula to generate the answer."
                    },
                    {
                        "username": "psionl0",
                        "content": "That formula will never work if m=100 or n=100. Use iteration or recursion to get the combinations."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This might be the most familiar dp problem to me now."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you have practised some dp, imo this should be marked as Easy"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "And Here I complete my 101 days of POTD streak."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "DP is easier than Math :("
                    },
                    {
                        "username": "rajat_171",
                        "content": "No DP is like : cooking the whole dish by yourself.\\nWith DP is like : Just order that dish."
                    },
                    {
                        "username": "jukov",
                        "content": "Looks like all solutions lay on pascal triangle"
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "The math solution of (m+n-2)! / (m-1)! * (n-1)! does not scale well.\\nThe int will overflow as little as m+n-2 = 18\\n\\nOf couse you can calc factorial in long and then cast the result into int. \\nTry uniquePath(10, 10) in your programming language with ints"
                    }
                ]
            },
            {
                "id": 2041775,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "If you wish to use the combinations formula instead of a dp matrix then a recursive formula that can be used is\n```\ncombin(r, r) = 1\ncombin(n, r) = combin(n-1, r) * n / (n - r)\n```\nNote that you will need to use a ``long long`` integer for your intermediate products otherwise they will overflow."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*after an annoying contest, I would say, this question good*"
                    },
                    {
                        "username": "jaggz01",
                        "content": "The combinations formula is = Combination (m,n) = m!/(n! * (m-n)!). Use this formula to generate the answer."
                    },
                    {
                        "username": "psionl0",
                        "content": "That formula will never work if m=100 or n=100. Use iteration or recursion to get the combinations."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This might be the most familiar dp problem to me now."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you have practised some dp, imo this should be marked as Easy"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "And Here I complete my 101 days of POTD streak."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "DP is easier than Math :("
                    },
                    {
                        "username": "rajat_171",
                        "content": "No DP is like : cooking the whole dish by yourself.\\nWith DP is like : Just order that dish."
                    },
                    {
                        "username": "jukov",
                        "content": "Looks like all solutions lay on pascal triangle"
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "The math solution of (m+n-2)! / (m-1)! * (n-1)! does not scale well.\\nThe int will overflow as little as m+n-2 = 18\\n\\nOf couse you can calc factorial in long and then cast the result into int. \\nTry uniquePath(10, 10) in your programming language with ints"
                    }
                ]
            },
            {
                "id": 2041684,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "If you wish to use the combinations formula instead of a dp matrix then a recursive formula that can be used is\n```\ncombin(r, r) = 1\ncombin(n, r) = combin(n-1, r) * n / (n - r)\n```\nNote that you will need to use a ``long long`` integer for your intermediate products otherwise they will overflow."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*after an annoying contest, I would say, this question good*"
                    },
                    {
                        "username": "jaggz01",
                        "content": "The combinations formula is = Combination (m,n) = m!/(n! * (m-n)!). Use this formula to generate the answer."
                    },
                    {
                        "username": "psionl0",
                        "content": "That formula will never work if m=100 or n=100. Use iteration or recursion to get the combinations."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This might be the most familiar dp problem to me now."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you have practised some dp, imo this should be marked as Easy"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "And Here I complete my 101 days of POTD streak."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "DP is easier than Math :("
                    },
                    {
                        "username": "rajat_171",
                        "content": "No DP is like : cooking the whole dish by yourself.\\nWith DP is like : Just order that dish."
                    },
                    {
                        "username": "jukov",
                        "content": "Looks like all solutions lay on pascal triangle"
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "The math solution of (m+n-2)! / (m-1)! * (n-1)! does not scale well.\\nThe int will overflow as little as m+n-2 = 18\\n\\nOf couse you can calc factorial in long and then cast the result into int. \\nTry uniquePath(10, 10) in your programming language with ints"
                    }
                ]
            },
            {
                "id": 2041677,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "If you wish to use the combinations formula instead of a dp matrix then a recursive formula that can be used is\n```\ncombin(r, r) = 1\ncombin(n, r) = combin(n-1, r) * n / (n - r)\n```\nNote that you will need to use a ``long long`` integer for your intermediate products otherwise they will overflow."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*after an annoying contest, I would say, this question good*"
                    },
                    {
                        "username": "jaggz01",
                        "content": "The combinations formula is = Combination (m,n) = m!/(n! * (m-n)!). Use this formula to generate the answer."
                    },
                    {
                        "username": "psionl0",
                        "content": "That formula will never work if m=100 or n=100. Use iteration or recursion to get the combinations."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This might be the most familiar dp problem to me now."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you have practised some dp, imo this should be marked as Easy"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "And Here I complete my 101 days of POTD streak."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "DP is easier than Math :("
                    },
                    {
                        "username": "rajat_171",
                        "content": "No DP is like : cooking the whole dish by yourself.\\nWith DP is like : Just order that dish."
                    },
                    {
                        "username": "jukov",
                        "content": "Looks like all solutions lay on pascal triangle"
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "The math solution of (m+n-2)! / (m-1)! * (n-1)! does not scale well.\\nThe int will overflow as little as m+n-2 = 18\\n\\nOf couse you can calc factorial in long and then cast the result into int. \\nTry uniquePath(10, 10) in your programming language with ints"
                    }
                ]
            },
            {
                "id": 2041669,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "If you wish to use the combinations formula instead of a dp matrix then a recursive formula that can be used is\n```\ncombin(r, r) = 1\ncombin(n, r) = combin(n-1, r) * n / (n - r)\n```\nNote that you will need to use a ``long long`` integer for your intermediate products otherwise they will overflow."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*after an annoying contest, I would say, this question good*"
                    },
                    {
                        "username": "jaggz01",
                        "content": "The combinations formula is = Combination (m,n) = m!/(n! * (m-n)!). Use this formula to generate the answer."
                    },
                    {
                        "username": "psionl0",
                        "content": "That formula will never work if m=100 or n=100. Use iteration or recursion to get the combinations."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This might be the most familiar dp problem to me now."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you have practised some dp, imo this should be marked as Easy"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "And Here I complete my 101 days of POTD streak."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "DP is easier than Math :("
                    },
                    {
                        "username": "rajat_171",
                        "content": "No DP is like : cooking the whole dish by yourself.\\nWith DP is like : Just order that dish."
                    },
                    {
                        "username": "jukov",
                        "content": "Looks like all solutions lay on pascal triangle"
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "The math solution of (m+n-2)! / (m-1)! * (n-1)! does not scale well.\\nThe int will overflow as little as m+n-2 = 18\\n\\nOf couse you can calc factorial in long and then cast the result into int. \\nTry uniquePath(10, 10) in your programming language with ints"
                    }
                ]
            },
            {
                "id": 2041666,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "If you wish to use the combinations formula instead of a dp matrix then a recursive formula that can be used is\n```\ncombin(r, r) = 1\ncombin(n, r) = combin(n-1, r) * n / (n - r)\n```\nNote that you will need to use a ``long long`` integer for your intermediate products otherwise they will overflow."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*after an annoying contest, I would say, this question good*"
                    },
                    {
                        "username": "jaggz01",
                        "content": "The combinations formula is = Combination (m,n) = m!/(n! * (m-n)!). Use this formula to generate the answer."
                    },
                    {
                        "username": "psionl0",
                        "content": "That formula will never work if m=100 or n=100. Use iteration or recursion to get the combinations."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This might be the most familiar dp problem to me now."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you have practised some dp, imo this should be marked as Easy"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "And Here I complete my 101 days of POTD streak."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "DP is easier than Math :("
                    },
                    {
                        "username": "rajat_171",
                        "content": "No DP is like : cooking the whole dish by yourself.\\nWith DP is like : Just order that dish."
                    },
                    {
                        "username": "jukov",
                        "content": "Looks like all solutions lay on pascal triangle"
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "The math solution of (m+n-2)! / (m-1)! * (n-1)! does not scale well.\\nThe int will overflow as little as m+n-2 = 18\\n\\nOf couse you can calc factorial in long and then cast the result into int. \\nTry uniquePath(10, 10) in your programming language with ints"
                    }
                ]
            },
            {
                "id": 2041593,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "If you wish to use the combinations formula instead of a dp matrix then a recursive formula that can be used is\n```\ncombin(r, r) = 1\ncombin(n, r) = combin(n-1, r) * n / (n - r)\n```\nNote that you will need to use a ``long long`` integer for your intermediate products otherwise they will overflow."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*after an annoying contest, I would say, this question good*"
                    },
                    {
                        "username": "jaggz01",
                        "content": "The combinations formula is = Combination (m,n) = m!/(n! * (m-n)!). Use this formula to generate the answer."
                    },
                    {
                        "username": "psionl0",
                        "content": "That formula will never work if m=100 or n=100. Use iteration or recursion to get the combinations."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This might be the most familiar dp problem to me now."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you have practised some dp, imo this should be marked as Easy"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "And Here I complete my 101 days of POTD streak."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "DP is easier than Math :("
                    },
                    {
                        "username": "rajat_171",
                        "content": "No DP is like : cooking the whole dish by yourself.\\nWith DP is like : Just order that dish."
                    },
                    {
                        "username": "jukov",
                        "content": "Looks like all solutions lay on pascal triangle"
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "The math solution of (m+n-2)! / (m-1)! * (n-1)! does not scale well.\\nThe int will overflow as little as m+n-2 = 18\\n\\nOf couse you can calc factorial in long and then cast the result into int. \\nTry uniquePath(10, 10) in your programming language with ints"
                    }
                ]
            },
            {
                "id": 2017853,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "If you wish to use the combinations formula instead of a dp matrix then a recursive formula that can be used is\n```\ncombin(r, r) = 1\ncombin(n, r) = combin(n-1, r) * n / (n - r)\n```\nNote that you will need to use a ``long long`` integer for your intermediate products otherwise they will overflow."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*after an annoying contest, I would say, this question good*"
                    },
                    {
                        "username": "jaggz01",
                        "content": "The combinations formula is = Combination (m,n) = m!/(n! * (m-n)!). Use this formula to generate the answer."
                    },
                    {
                        "username": "psionl0",
                        "content": "That formula will never work if m=100 or n=100. Use iteration or recursion to get the combinations."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This might be the most familiar dp problem to me now."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you have practised some dp, imo this should be marked as Easy"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "And Here I complete my 101 days of POTD streak."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "DP is easier than Math :("
                    },
                    {
                        "username": "rajat_171",
                        "content": "No DP is like : cooking the whole dish by yourself.\\nWith DP is like : Just order that dish."
                    },
                    {
                        "username": "jukov",
                        "content": "Looks like all solutions lay on pascal triangle"
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "The math solution of (m+n-2)! / (m-1)! * (n-1)! does not scale well.\\nThe int will overflow as little as m+n-2 = 18\\n\\nOf couse you can calc factorial in long and then cast the result into int. \\nTry uniquePath(10, 10) in your programming language with ints"
                    }
                ]
            },
            {
                "id": 2010589,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "If you wish to use the combinations formula instead of a dp matrix then a recursive formula that can be used is\n```\ncombin(r, r) = 1\ncombin(n, r) = combin(n-1, r) * n / (n - r)\n```\nNote that you will need to use a ``long long`` integer for your intermediate products otherwise they will overflow."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*after an annoying contest, I would say, this question good*"
                    },
                    {
                        "username": "jaggz01",
                        "content": "The combinations formula is = Combination (m,n) = m!/(n! * (m-n)!). Use this formula to generate the answer."
                    },
                    {
                        "username": "psionl0",
                        "content": "That formula will never work if m=100 or n=100. Use iteration or recursion to get the combinations."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This might be the most familiar dp problem to me now."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you have practised some dp, imo this should be marked as Easy"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "And Here I complete my 101 days of POTD streak."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "DP is easier than Math :("
                    },
                    {
                        "username": "rajat_171",
                        "content": "No DP is like : cooking the whole dish by yourself.\\nWith DP is like : Just order that dish."
                    },
                    {
                        "username": "jukov",
                        "content": "Looks like all solutions lay on pascal triangle"
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "The math solution of (m+n-2)! / (m-1)! * (n-1)! does not scale well.\\nThe int will overflow as little as m+n-2 = 18\\n\\nOf couse you can calc factorial in long and then cast the result into int. \\nTry uniquePath(10, 10) in your programming language with ints"
                    }
                ]
            },
            {
                "id": 1983522,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "If you wish to use the combinations formula instead of a dp matrix then a recursive formula that can be used is\n```\ncombin(r, r) = 1\ncombin(n, r) = combin(n-1, r) * n / (n - r)\n```\nNote that you will need to use a ``long long`` integer for your intermediate products otherwise they will overflow."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*after an annoying contest, I would say, this question good*"
                    },
                    {
                        "username": "jaggz01",
                        "content": "The combinations formula is = Combination (m,n) = m!/(n! * (m-n)!). Use this formula to generate the answer."
                    },
                    {
                        "username": "psionl0",
                        "content": "That formula will never work if m=100 or n=100. Use iteration or recursion to get the combinations."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This might be the most familiar dp problem to me now."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you have practised some dp, imo this should be marked as Easy"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "And Here I complete my 101 days of POTD streak."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "DP is easier than Math :("
                    },
                    {
                        "username": "rajat_171",
                        "content": "No DP is like : cooking the whole dish by yourself.\\nWith DP is like : Just order that dish."
                    },
                    {
                        "username": "jukov",
                        "content": "Looks like all solutions lay on pascal triangle"
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "The math solution of (m+n-2)! / (m-1)! * (n-1)! does not scale well.\\nThe int will overflow as little as m+n-2 = 18\\n\\nOf couse you can calc factorial in long and then cast the result into int. \\nTry uniquePath(10, 10) in your programming language with ints"
                    }
                ]
            },
            {
                "id": 1979658,
                "content": [
                    {
                        "username": "ahmad_masood",
                        "content": "Hint:\\n\"Total steps to get to the goal how many can you have to pick them to be right\".. If you know combination and permutation concepts then it will be simple using the above statement. Let\\'s suppose i have 7 rows and 3 columns. how many time do i have to move right so to reach my goal? use combination to solve this statement and then implement in the code\\n"
                    },
                    {
                        "username": "zzz6519003",
                        "content": "what if we omit \"The robot can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alwaysaditi](/alwaysaditi) Not if the question asked for (all) <i>minimum</i> paths. A \"visited\" matrix should  take care of previously visited cells. ``980. Unique Paths III`` is similar in nature to this."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Then there could be some paths of infinite length and there would be infinite such paths!"
                    },
                    {
                        "username": "YungIrving",
                        "content": "Can some look at my code. Trying a dfs + memo approach and I just can\\'t visualize how it bubbles up so my answer is wrong. Thanks!\\n\\n    `def uniquePaths(self, m: int, n: int) -> int:\\n        dirs = [(1, 0), (0, 1)]\\n        memo = defaultdict(int)\\n        memo[(m - 1, n - 1)] = 1\\n\\n        def dfs(r, c):\\n            if (r, c) in memo:\\n                return memo[(r, c)]\\n            else:\\n                for i, j in dirs:\\n                    x = r + i\\n                    y = c + j\\n\\n                    if self.valid(m, n, x, y):\\n                        memo[(r, c)] += dfs(x, y)\\n                        return memo[(r, c)]\\n\\n        \\n        dfs(0, 0)\\n        return memo[(0, 0)]\\n\\n    def valid(self, m, n, r, c) -> bool:\\n        return r in range(m) and c in range(n)\\n`"
                    },
                    {
                        "username": "startupveteran",
                        "content": "During live interview, are we permitted to skip DP and head straight to math-based solutions (combinations/permutations)?\n\n----------------SPOILER BELOW------------------:\n.\n.\n.\n.\n..\n.\n.\n.\n.\n.\n..\n.\n.\n.\n.\n..\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n\n        vertical_moves = m-1\n        horizontal_moves = n-1\n        \n        total_moves = vertical_moves + horizontal_moves\n        \n        top = 1\n        bottom = 1\n        for each in range(vertical_moves):\n            top *= total_moves\n            total_moves -= 1\n            bottom *= (1+each)\n        return int(top/bottom)\n"
                    },
                    {
                        "username": "Shivainspace",
                        "content": "i get the output for my code when i put in my compiler. but here am getting a type error, pls help."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = 1;\\n                    continue;\\n                }\\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];\\n\\nthis code works but the code below doesn\\'t what is that I am missing??\\n\\ndp[0][0] = 1;\\n        for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                \\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "In the for loop there will be i<m , j<n. Less than or equal to(<=) is wrong there. Also return value will be dp[m-1][n-1]. Your current code is providing answer for m+1, n+1."
                    },
                    {
                        "username": "ashishlawaniyaa",
                        "content": "fun fact:- robot is not smiling :)"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "why i am getting tle on using dfs"
                    },
                    {
                        "username": "amirdon",
                        "content": "I don\\'t understand why the base-case is `m == 1 || n == 1`. Shouldn\\'t it be `m == 1 && n == 1`?\\n"
                    },
                    {
                        "username": "raginibhayana99",
                        "content": "\"class Solution {\\n    vector<vector<int>>dp;\\n    \\n    int solve(int m, int n){\\n        if(m==0 and n==0) return 1;\\n        if(m<0 or n <0) return 0;\\n\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\n        return dp[m][n] = uniquePaths(m-1, n)+ uniquePaths(m, n-1);\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        dp = vector<vector<int>>(m, vector<int>(n, -1));\\n        return solve(m-1, n-1);\\n        return 0;\\n    }\\n}; \"i am getting this error: terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  cannot create std::vector larger than max_size(). Please help. Thank you so much in advance. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If only one of `m` or `n` is `0` then the `return` statement calls `uniquePaths()` with a negative argument, and when `uniquePaths()` creates a `std::vector` this `-1` gets implicitly converted to a large integer because the parameter of `std::vector` is `std::size_t`, an unsigned integer type.\nAlso, are you sure that `solve()` should call `uniquePaths()` and not `solve()`?"
                    }
                ]
            },
            {
                "id": 1971750,
                "content": [
                    {
                        "username": "ahmad_masood",
                        "content": "Hint:\\n\"Total steps to get to the goal how many can you have to pick them to be right\".. If you know combination and permutation concepts then it will be simple using the above statement. Let\\'s suppose i have 7 rows and 3 columns. how many time do i have to move right so to reach my goal? use combination to solve this statement and then implement in the code\\n"
                    },
                    {
                        "username": "zzz6519003",
                        "content": "what if we omit \"The robot can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alwaysaditi](/alwaysaditi) Not if the question asked for (all) <i>minimum</i> paths. A \"visited\" matrix should  take care of previously visited cells. ``980. Unique Paths III`` is similar in nature to this."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Then there could be some paths of infinite length and there would be infinite such paths!"
                    },
                    {
                        "username": "YungIrving",
                        "content": "Can some look at my code. Trying a dfs + memo approach and I just can\\'t visualize how it bubbles up so my answer is wrong. Thanks!\\n\\n    `def uniquePaths(self, m: int, n: int) -> int:\\n        dirs = [(1, 0), (0, 1)]\\n        memo = defaultdict(int)\\n        memo[(m - 1, n - 1)] = 1\\n\\n        def dfs(r, c):\\n            if (r, c) in memo:\\n                return memo[(r, c)]\\n            else:\\n                for i, j in dirs:\\n                    x = r + i\\n                    y = c + j\\n\\n                    if self.valid(m, n, x, y):\\n                        memo[(r, c)] += dfs(x, y)\\n                        return memo[(r, c)]\\n\\n        \\n        dfs(0, 0)\\n        return memo[(0, 0)]\\n\\n    def valid(self, m, n, r, c) -> bool:\\n        return r in range(m) and c in range(n)\\n`"
                    },
                    {
                        "username": "startupveteran",
                        "content": "During live interview, are we permitted to skip DP and head straight to math-based solutions (combinations/permutations)?\n\n----------------SPOILER BELOW------------------:\n.\n.\n.\n.\n..\n.\n.\n.\n.\n.\n..\n.\n.\n.\n.\n..\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n\n        vertical_moves = m-1\n        horizontal_moves = n-1\n        \n        total_moves = vertical_moves + horizontal_moves\n        \n        top = 1\n        bottom = 1\n        for each in range(vertical_moves):\n            top *= total_moves\n            total_moves -= 1\n            bottom *= (1+each)\n        return int(top/bottom)\n"
                    },
                    {
                        "username": "Shivainspace",
                        "content": "i get the output for my code when i put in my compiler. but here am getting a type error, pls help."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = 1;\\n                    continue;\\n                }\\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];\\n\\nthis code works but the code below doesn\\'t what is that I am missing??\\n\\ndp[0][0] = 1;\\n        for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                \\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "In the for loop there will be i<m , j<n. Less than or equal to(<=) is wrong there. Also return value will be dp[m-1][n-1]. Your current code is providing answer for m+1, n+1."
                    },
                    {
                        "username": "ashishlawaniyaa",
                        "content": "fun fact:- robot is not smiling :)"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "why i am getting tle on using dfs"
                    },
                    {
                        "username": "amirdon",
                        "content": "I don\\'t understand why the base-case is `m == 1 || n == 1`. Shouldn\\'t it be `m == 1 && n == 1`?\\n"
                    },
                    {
                        "username": "raginibhayana99",
                        "content": "\"class Solution {\\n    vector<vector<int>>dp;\\n    \\n    int solve(int m, int n){\\n        if(m==0 and n==0) return 1;\\n        if(m<0 or n <0) return 0;\\n\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\n        return dp[m][n] = uniquePaths(m-1, n)+ uniquePaths(m, n-1);\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        dp = vector<vector<int>>(m, vector<int>(n, -1));\\n        return solve(m-1, n-1);\\n        return 0;\\n    }\\n}; \"i am getting this error: terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  cannot create std::vector larger than max_size(). Please help. Thank you so much in advance. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If only one of `m` or `n` is `0` then the `return` statement calls `uniquePaths()` with a negative argument, and when `uniquePaths()` creates a `std::vector` this `-1` gets implicitly converted to a large integer because the parameter of `std::vector` is `std::size_t`, an unsigned integer type.\nAlso, are you sure that `solve()` should call `uniquePaths()` and not `solve()`?"
                    }
                ]
            },
            {
                "id": 1954069,
                "content": [
                    {
                        "username": "ahmad_masood",
                        "content": "Hint:\\n\"Total steps to get to the goal how many can you have to pick them to be right\".. If you know combination and permutation concepts then it will be simple using the above statement. Let\\'s suppose i have 7 rows and 3 columns. how many time do i have to move right so to reach my goal? use combination to solve this statement and then implement in the code\\n"
                    },
                    {
                        "username": "zzz6519003",
                        "content": "what if we omit \"The robot can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alwaysaditi](/alwaysaditi) Not if the question asked for (all) <i>minimum</i> paths. A \"visited\" matrix should  take care of previously visited cells. ``980. Unique Paths III`` is similar in nature to this."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Then there could be some paths of infinite length and there would be infinite such paths!"
                    },
                    {
                        "username": "YungIrving",
                        "content": "Can some look at my code. Trying a dfs + memo approach and I just can\\'t visualize how it bubbles up so my answer is wrong. Thanks!\\n\\n    `def uniquePaths(self, m: int, n: int) -> int:\\n        dirs = [(1, 0), (0, 1)]\\n        memo = defaultdict(int)\\n        memo[(m - 1, n - 1)] = 1\\n\\n        def dfs(r, c):\\n            if (r, c) in memo:\\n                return memo[(r, c)]\\n            else:\\n                for i, j in dirs:\\n                    x = r + i\\n                    y = c + j\\n\\n                    if self.valid(m, n, x, y):\\n                        memo[(r, c)] += dfs(x, y)\\n                        return memo[(r, c)]\\n\\n        \\n        dfs(0, 0)\\n        return memo[(0, 0)]\\n\\n    def valid(self, m, n, r, c) -> bool:\\n        return r in range(m) and c in range(n)\\n`"
                    },
                    {
                        "username": "startupveteran",
                        "content": "During live interview, are we permitted to skip DP and head straight to math-based solutions (combinations/permutations)?\n\n----------------SPOILER BELOW------------------:\n.\n.\n.\n.\n..\n.\n.\n.\n.\n.\n..\n.\n.\n.\n.\n..\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n\n        vertical_moves = m-1\n        horizontal_moves = n-1\n        \n        total_moves = vertical_moves + horizontal_moves\n        \n        top = 1\n        bottom = 1\n        for each in range(vertical_moves):\n            top *= total_moves\n            total_moves -= 1\n            bottom *= (1+each)\n        return int(top/bottom)\n"
                    },
                    {
                        "username": "Shivainspace",
                        "content": "i get the output for my code when i put in my compiler. but here am getting a type error, pls help."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = 1;\\n                    continue;\\n                }\\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];\\n\\nthis code works but the code below doesn\\'t what is that I am missing??\\n\\ndp[0][0] = 1;\\n        for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                \\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "In the for loop there will be i<m , j<n. Less than or equal to(<=) is wrong there. Also return value will be dp[m-1][n-1]. Your current code is providing answer for m+1, n+1."
                    },
                    {
                        "username": "ashishlawaniyaa",
                        "content": "fun fact:- robot is not smiling :)"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "why i am getting tle on using dfs"
                    },
                    {
                        "username": "amirdon",
                        "content": "I don\\'t understand why the base-case is `m == 1 || n == 1`. Shouldn\\'t it be `m == 1 && n == 1`?\\n"
                    },
                    {
                        "username": "raginibhayana99",
                        "content": "\"class Solution {\\n    vector<vector<int>>dp;\\n    \\n    int solve(int m, int n){\\n        if(m==0 and n==0) return 1;\\n        if(m<0 or n <0) return 0;\\n\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\n        return dp[m][n] = uniquePaths(m-1, n)+ uniquePaths(m, n-1);\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        dp = vector<vector<int>>(m, vector<int>(n, -1));\\n        return solve(m-1, n-1);\\n        return 0;\\n    }\\n}; \"i am getting this error: terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  cannot create std::vector larger than max_size(). Please help. Thank you so much in advance. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If only one of `m` or `n` is `0` then the `return` statement calls `uniquePaths()` with a negative argument, and when `uniquePaths()` creates a `std::vector` this `-1` gets implicitly converted to a large integer because the parameter of `std::vector` is `std::size_t`, an unsigned integer type.\nAlso, are you sure that `solve()` should call `uniquePaths()` and not `solve()`?"
                    }
                ]
            },
            {
                "id": 1945891,
                "content": [
                    {
                        "username": "ahmad_masood",
                        "content": "Hint:\\n\"Total steps to get to the goal how many can you have to pick them to be right\".. If you know combination and permutation concepts then it will be simple using the above statement. Let\\'s suppose i have 7 rows and 3 columns. how many time do i have to move right so to reach my goal? use combination to solve this statement and then implement in the code\\n"
                    },
                    {
                        "username": "zzz6519003",
                        "content": "what if we omit \"The robot can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alwaysaditi](/alwaysaditi) Not if the question asked for (all) <i>minimum</i> paths. A \"visited\" matrix should  take care of previously visited cells. ``980. Unique Paths III`` is similar in nature to this."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Then there could be some paths of infinite length and there would be infinite such paths!"
                    },
                    {
                        "username": "YungIrving",
                        "content": "Can some look at my code. Trying a dfs + memo approach and I just can\\'t visualize how it bubbles up so my answer is wrong. Thanks!\\n\\n    `def uniquePaths(self, m: int, n: int) -> int:\\n        dirs = [(1, 0), (0, 1)]\\n        memo = defaultdict(int)\\n        memo[(m - 1, n - 1)] = 1\\n\\n        def dfs(r, c):\\n            if (r, c) in memo:\\n                return memo[(r, c)]\\n            else:\\n                for i, j in dirs:\\n                    x = r + i\\n                    y = c + j\\n\\n                    if self.valid(m, n, x, y):\\n                        memo[(r, c)] += dfs(x, y)\\n                        return memo[(r, c)]\\n\\n        \\n        dfs(0, 0)\\n        return memo[(0, 0)]\\n\\n    def valid(self, m, n, r, c) -> bool:\\n        return r in range(m) and c in range(n)\\n`"
                    },
                    {
                        "username": "startupveteran",
                        "content": "During live interview, are we permitted to skip DP and head straight to math-based solutions (combinations/permutations)?\n\n----------------SPOILER BELOW------------------:\n.\n.\n.\n.\n..\n.\n.\n.\n.\n.\n..\n.\n.\n.\n.\n..\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n\n        vertical_moves = m-1\n        horizontal_moves = n-1\n        \n        total_moves = vertical_moves + horizontal_moves\n        \n        top = 1\n        bottom = 1\n        for each in range(vertical_moves):\n            top *= total_moves\n            total_moves -= 1\n            bottom *= (1+each)\n        return int(top/bottom)\n"
                    },
                    {
                        "username": "Shivainspace",
                        "content": "i get the output for my code when i put in my compiler. but here am getting a type error, pls help."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = 1;\\n                    continue;\\n                }\\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];\\n\\nthis code works but the code below doesn\\'t what is that I am missing??\\n\\ndp[0][0] = 1;\\n        for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                \\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "In the for loop there will be i<m , j<n. Less than or equal to(<=) is wrong there. Also return value will be dp[m-1][n-1]. Your current code is providing answer for m+1, n+1."
                    },
                    {
                        "username": "ashishlawaniyaa",
                        "content": "fun fact:- robot is not smiling :)"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "why i am getting tle on using dfs"
                    },
                    {
                        "username": "amirdon",
                        "content": "I don\\'t understand why the base-case is `m == 1 || n == 1`. Shouldn\\'t it be `m == 1 && n == 1`?\\n"
                    },
                    {
                        "username": "raginibhayana99",
                        "content": "\"class Solution {\\n    vector<vector<int>>dp;\\n    \\n    int solve(int m, int n){\\n        if(m==0 and n==0) return 1;\\n        if(m<0 or n <0) return 0;\\n\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\n        return dp[m][n] = uniquePaths(m-1, n)+ uniquePaths(m, n-1);\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        dp = vector<vector<int>>(m, vector<int>(n, -1));\\n        return solve(m-1, n-1);\\n        return 0;\\n    }\\n}; \"i am getting this error: terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  cannot create std::vector larger than max_size(). Please help. Thank you so much in advance. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If only one of `m` or `n` is `0` then the `return` statement calls `uniquePaths()` with a negative argument, and when `uniquePaths()` creates a `std::vector` this `-1` gets implicitly converted to a large integer because the parameter of `std::vector` is `std::size_t`, an unsigned integer type.\nAlso, are you sure that `solve()` should call `uniquePaths()` and not `solve()`?"
                    }
                ]
            },
            {
                "id": 1940881,
                "content": [
                    {
                        "username": "ahmad_masood",
                        "content": "Hint:\\n\"Total steps to get to the goal how many can you have to pick them to be right\".. If you know combination and permutation concepts then it will be simple using the above statement. Let\\'s suppose i have 7 rows and 3 columns. how many time do i have to move right so to reach my goal? use combination to solve this statement and then implement in the code\\n"
                    },
                    {
                        "username": "zzz6519003",
                        "content": "what if we omit \"The robot can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alwaysaditi](/alwaysaditi) Not if the question asked for (all) <i>minimum</i> paths. A \"visited\" matrix should  take care of previously visited cells. ``980. Unique Paths III`` is similar in nature to this."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Then there could be some paths of infinite length and there would be infinite such paths!"
                    },
                    {
                        "username": "YungIrving",
                        "content": "Can some look at my code. Trying a dfs + memo approach and I just can\\'t visualize how it bubbles up so my answer is wrong. Thanks!\\n\\n    `def uniquePaths(self, m: int, n: int) -> int:\\n        dirs = [(1, 0), (0, 1)]\\n        memo = defaultdict(int)\\n        memo[(m - 1, n - 1)] = 1\\n\\n        def dfs(r, c):\\n            if (r, c) in memo:\\n                return memo[(r, c)]\\n            else:\\n                for i, j in dirs:\\n                    x = r + i\\n                    y = c + j\\n\\n                    if self.valid(m, n, x, y):\\n                        memo[(r, c)] += dfs(x, y)\\n                        return memo[(r, c)]\\n\\n        \\n        dfs(0, 0)\\n        return memo[(0, 0)]\\n\\n    def valid(self, m, n, r, c) -> bool:\\n        return r in range(m) and c in range(n)\\n`"
                    },
                    {
                        "username": "startupveteran",
                        "content": "During live interview, are we permitted to skip DP and head straight to math-based solutions (combinations/permutations)?\n\n----------------SPOILER BELOW------------------:\n.\n.\n.\n.\n..\n.\n.\n.\n.\n.\n..\n.\n.\n.\n.\n..\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n\n        vertical_moves = m-1\n        horizontal_moves = n-1\n        \n        total_moves = vertical_moves + horizontal_moves\n        \n        top = 1\n        bottom = 1\n        for each in range(vertical_moves):\n            top *= total_moves\n            total_moves -= 1\n            bottom *= (1+each)\n        return int(top/bottom)\n"
                    },
                    {
                        "username": "Shivainspace",
                        "content": "i get the output for my code when i put in my compiler. but here am getting a type error, pls help."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = 1;\\n                    continue;\\n                }\\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];\\n\\nthis code works but the code below doesn\\'t what is that I am missing??\\n\\ndp[0][0] = 1;\\n        for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                \\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "In the for loop there will be i<m , j<n. Less than or equal to(<=) is wrong there. Also return value will be dp[m-1][n-1]. Your current code is providing answer for m+1, n+1."
                    },
                    {
                        "username": "ashishlawaniyaa",
                        "content": "fun fact:- robot is not smiling :)"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "why i am getting tle on using dfs"
                    },
                    {
                        "username": "amirdon",
                        "content": "I don\\'t understand why the base-case is `m == 1 || n == 1`. Shouldn\\'t it be `m == 1 && n == 1`?\\n"
                    },
                    {
                        "username": "raginibhayana99",
                        "content": "\"class Solution {\\n    vector<vector<int>>dp;\\n    \\n    int solve(int m, int n){\\n        if(m==0 and n==0) return 1;\\n        if(m<0 or n <0) return 0;\\n\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\n        return dp[m][n] = uniquePaths(m-1, n)+ uniquePaths(m, n-1);\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        dp = vector<vector<int>>(m, vector<int>(n, -1));\\n        return solve(m-1, n-1);\\n        return 0;\\n    }\\n}; \"i am getting this error: terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  cannot create std::vector larger than max_size(). Please help. Thank you so much in advance. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If only one of `m` or `n` is `0` then the `return` statement calls `uniquePaths()` with a negative argument, and when `uniquePaths()` creates a `std::vector` this `-1` gets implicitly converted to a large integer because the parameter of `std::vector` is `std::size_t`, an unsigned integer type.\nAlso, are you sure that `solve()` should call `uniquePaths()` and not `solve()`?"
                    }
                ]
            },
            {
                "id": 1925582,
                "content": [
                    {
                        "username": "ahmad_masood",
                        "content": "Hint:\\n\"Total steps to get to the goal how many can you have to pick them to be right\".. If you know combination and permutation concepts then it will be simple using the above statement. Let\\'s suppose i have 7 rows and 3 columns. how many time do i have to move right so to reach my goal? use combination to solve this statement and then implement in the code\\n"
                    },
                    {
                        "username": "zzz6519003",
                        "content": "what if we omit \"The robot can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alwaysaditi](/alwaysaditi) Not if the question asked for (all) <i>minimum</i> paths. A \"visited\" matrix should  take care of previously visited cells. ``980. Unique Paths III`` is similar in nature to this."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Then there could be some paths of infinite length and there would be infinite such paths!"
                    },
                    {
                        "username": "YungIrving",
                        "content": "Can some look at my code. Trying a dfs + memo approach and I just can\\'t visualize how it bubbles up so my answer is wrong. Thanks!\\n\\n    `def uniquePaths(self, m: int, n: int) -> int:\\n        dirs = [(1, 0), (0, 1)]\\n        memo = defaultdict(int)\\n        memo[(m - 1, n - 1)] = 1\\n\\n        def dfs(r, c):\\n            if (r, c) in memo:\\n                return memo[(r, c)]\\n            else:\\n                for i, j in dirs:\\n                    x = r + i\\n                    y = c + j\\n\\n                    if self.valid(m, n, x, y):\\n                        memo[(r, c)] += dfs(x, y)\\n                        return memo[(r, c)]\\n\\n        \\n        dfs(0, 0)\\n        return memo[(0, 0)]\\n\\n    def valid(self, m, n, r, c) -> bool:\\n        return r in range(m) and c in range(n)\\n`"
                    },
                    {
                        "username": "startupveteran",
                        "content": "During live interview, are we permitted to skip DP and head straight to math-based solutions (combinations/permutations)?\n\n----------------SPOILER BELOW------------------:\n.\n.\n.\n.\n..\n.\n.\n.\n.\n.\n..\n.\n.\n.\n.\n..\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n\n        vertical_moves = m-1\n        horizontal_moves = n-1\n        \n        total_moves = vertical_moves + horizontal_moves\n        \n        top = 1\n        bottom = 1\n        for each in range(vertical_moves):\n            top *= total_moves\n            total_moves -= 1\n            bottom *= (1+each)\n        return int(top/bottom)\n"
                    },
                    {
                        "username": "Shivainspace",
                        "content": "i get the output for my code when i put in my compiler. but here am getting a type error, pls help."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = 1;\\n                    continue;\\n                }\\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];\\n\\nthis code works but the code below doesn\\'t what is that I am missing??\\n\\ndp[0][0] = 1;\\n        for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                \\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "In the for loop there will be i<m , j<n. Less than or equal to(<=) is wrong there. Also return value will be dp[m-1][n-1]. Your current code is providing answer for m+1, n+1."
                    },
                    {
                        "username": "ashishlawaniyaa",
                        "content": "fun fact:- robot is not smiling :)"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "why i am getting tle on using dfs"
                    },
                    {
                        "username": "amirdon",
                        "content": "I don\\'t understand why the base-case is `m == 1 || n == 1`. Shouldn\\'t it be `m == 1 && n == 1`?\\n"
                    },
                    {
                        "username": "raginibhayana99",
                        "content": "\"class Solution {\\n    vector<vector<int>>dp;\\n    \\n    int solve(int m, int n){\\n        if(m==0 and n==0) return 1;\\n        if(m<0 or n <0) return 0;\\n\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\n        return dp[m][n] = uniquePaths(m-1, n)+ uniquePaths(m, n-1);\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        dp = vector<vector<int>>(m, vector<int>(n, -1));\\n        return solve(m-1, n-1);\\n        return 0;\\n    }\\n}; \"i am getting this error: terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  cannot create std::vector larger than max_size(). Please help. Thank you so much in advance. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If only one of `m` or `n` is `0` then the `return` statement calls `uniquePaths()` with a negative argument, and when `uniquePaths()` creates a `std::vector` this `-1` gets implicitly converted to a large integer because the parameter of `std::vector` is `std::size_t`, an unsigned integer type.\nAlso, are you sure that `solve()` should call `uniquePaths()` and not `solve()`?"
                    }
                ]
            },
            {
                "id": 1911579,
                "content": [
                    {
                        "username": "ahmad_masood",
                        "content": "Hint:\\n\"Total steps to get to the goal how many can you have to pick them to be right\".. If you know combination and permutation concepts then it will be simple using the above statement. Let\\'s suppose i have 7 rows and 3 columns. how many time do i have to move right so to reach my goal? use combination to solve this statement and then implement in the code\\n"
                    },
                    {
                        "username": "zzz6519003",
                        "content": "what if we omit \"The robot can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alwaysaditi](/alwaysaditi) Not if the question asked for (all) <i>minimum</i> paths. A \"visited\" matrix should  take care of previously visited cells. ``980. Unique Paths III`` is similar in nature to this."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Then there could be some paths of infinite length and there would be infinite such paths!"
                    },
                    {
                        "username": "YungIrving",
                        "content": "Can some look at my code. Trying a dfs + memo approach and I just can\\'t visualize how it bubbles up so my answer is wrong. Thanks!\\n\\n    `def uniquePaths(self, m: int, n: int) -> int:\\n        dirs = [(1, 0), (0, 1)]\\n        memo = defaultdict(int)\\n        memo[(m - 1, n - 1)] = 1\\n\\n        def dfs(r, c):\\n            if (r, c) in memo:\\n                return memo[(r, c)]\\n            else:\\n                for i, j in dirs:\\n                    x = r + i\\n                    y = c + j\\n\\n                    if self.valid(m, n, x, y):\\n                        memo[(r, c)] += dfs(x, y)\\n                        return memo[(r, c)]\\n\\n        \\n        dfs(0, 0)\\n        return memo[(0, 0)]\\n\\n    def valid(self, m, n, r, c) -> bool:\\n        return r in range(m) and c in range(n)\\n`"
                    },
                    {
                        "username": "startupveteran",
                        "content": "During live interview, are we permitted to skip DP and head straight to math-based solutions (combinations/permutations)?\n\n----------------SPOILER BELOW------------------:\n.\n.\n.\n.\n..\n.\n.\n.\n.\n.\n..\n.\n.\n.\n.\n..\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n\n        vertical_moves = m-1\n        horizontal_moves = n-1\n        \n        total_moves = vertical_moves + horizontal_moves\n        \n        top = 1\n        bottom = 1\n        for each in range(vertical_moves):\n            top *= total_moves\n            total_moves -= 1\n            bottom *= (1+each)\n        return int(top/bottom)\n"
                    },
                    {
                        "username": "Shivainspace",
                        "content": "i get the output for my code when i put in my compiler. but here am getting a type error, pls help."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = 1;\\n                    continue;\\n                }\\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];\\n\\nthis code works but the code below doesn\\'t what is that I am missing??\\n\\ndp[0][0] = 1;\\n        for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                \\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "In the for loop there will be i<m , j<n. Less than or equal to(<=) is wrong there. Also return value will be dp[m-1][n-1]. Your current code is providing answer for m+1, n+1."
                    },
                    {
                        "username": "ashishlawaniyaa",
                        "content": "fun fact:- robot is not smiling :)"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "why i am getting tle on using dfs"
                    },
                    {
                        "username": "amirdon",
                        "content": "I don\\'t understand why the base-case is `m == 1 || n == 1`. Shouldn\\'t it be `m == 1 && n == 1`?\\n"
                    },
                    {
                        "username": "raginibhayana99",
                        "content": "\"class Solution {\\n    vector<vector<int>>dp;\\n    \\n    int solve(int m, int n){\\n        if(m==0 and n==0) return 1;\\n        if(m<0 or n <0) return 0;\\n\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\n        return dp[m][n] = uniquePaths(m-1, n)+ uniquePaths(m, n-1);\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        dp = vector<vector<int>>(m, vector<int>(n, -1));\\n        return solve(m-1, n-1);\\n        return 0;\\n    }\\n}; \"i am getting this error: terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  cannot create std::vector larger than max_size(). Please help. Thank you so much in advance. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If only one of `m` or `n` is `0` then the `return` statement calls `uniquePaths()` with a negative argument, and when `uniquePaths()` creates a `std::vector` this `-1` gets implicitly converted to a large integer because the parameter of `std::vector` is `std::size_t`, an unsigned integer type.\nAlso, are you sure that `solve()` should call `uniquePaths()` and not `solve()`?"
                    }
                ]
            },
            {
                "id": 1905332,
                "content": [
                    {
                        "username": "ahmad_masood",
                        "content": "Hint:\\n\"Total steps to get to the goal how many can you have to pick them to be right\".. If you know combination and permutation concepts then it will be simple using the above statement. Let\\'s suppose i have 7 rows and 3 columns. how many time do i have to move right so to reach my goal? use combination to solve this statement and then implement in the code\\n"
                    },
                    {
                        "username": "zzz6519003",
                        "content": "what if we omit \"The robot can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alwaysaditi](/alwaysaditi) Not if the question asked for (all) <i>minimum</i> paths. A \"visited\" matrix should  take care of previously visited cells. ``980. Unique Paths III`` is similar in nature to this."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Then there could be some paths of infinite length and there would be infinite such paths!"
                    },
                    {
                        "username": "YungIrving",
                        "content": "Can some look at my code. Trying a dfs + memo approach and I just can\\'t visualize how it bubbles up so my answer is wrong. Thanks!\\n\\n    `def uniquePaths(self, m: int, n: int) -> int:\\n        dirs = [(1, 0), (0, 1)]\\n        memo = defaultdict(int)\\n        memo[(m - 1, n - 1)] = 1\\n\\n        def dfs(r, c):\\n            if (r, c) in memo:\\n                return memo[(r, c)]\\n            else:\\n                for i, j in dirs:\\n                    x = r + i\\n                    y = c + j\\n\\n                    if self.valid(m, n, x, y):\\n                        memo[(r, c)] += dfs(x, y)\\n                        return memo[(r, c)]\\n\\n        \\n        dfs(0, 0)\\n        return memo[(0, 0)]\\n\\n    def valid(self, m, n, r, c) -> bool:\\n        return r in range(m) and c in range(n)\\n`"
                    },
                    {
                        "username": "startupveteran",
                        "content": "During live interview, are we permitted to skip DP and head straight to math-based solutions (combinations/permutations)?\n\n----------------SPOILER BELOW------------------:\n.\n.\n.\n.\n..\n.\n.\n.\n.\n.\n..\n.\n.\n.\n.\n..\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n\n        vertical_moves = m-1\n        horizontal_moves = n-1\n        \n        total_moves = vertical_moves + horizontal_moves\n        \n        top = 1\n        bottom = 1\n        for each in range(vertical_moves):\n            top *= total_moves\n            total_moves -= 1\n            bottom *= (1+each)\n        return int(top/bottom)\n"
                    },
                    {
                        "username": "Shivainspace",
                        "content": "i get the output for my code when i put in my compiler. but here am getting a type error, pls help."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = 1;\\n                    continue;\\n                }\\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];\\n\\nthis code works but the code below doesn\\'t what is that I am missing??\\n\\ndp[0][0] = 1;\\n        for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                \\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "In the for loop there will be i<m , j<n. Less than or equal to(<=) is wrong there. Also return value will be dp[m-1][n-1]. Your current code is providing answer for m+1, n+1."
                    },
                    {
                        "username": "ashishlawaniyaa",
                        "content": "fun fact:- robot is not smiling :)"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "why i am getting tle on using dfs"
                    },
                    {
                        "username": "amirdon",
                        "content": "I don\\'t understand why the base-case is `m == 1 || n == 1`. Shouldn\\'t it be `m == 1 && n == 1`?\\n"
                    },
                    {
                        "username": "raginibhayana99",
                        "content": "\"class Solution {\\n    vector<vector<int>>dp;\\n    \\n    int solve(int m, int n){\\n        if(m==0 and n==0) return 1;\\n        if(m<0 or n <0) return 0;\\n\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\n        return dp[m][n] = uniquePaths(m-1, n)+ uniquePaths(m, n-1);\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        dp = vector<vector<int>>(m, vector<int>(n, -1));\\n        return solve(m-1, n-1);\\n        return 0;\\n    }\\n}; \"i am getting this error: terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  cannot create std::vector larger than max_size(). Please help. Thank you so much in advance. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If only one of `m` or `n` is `0` then the `return` statement calls `uniquePaths()` with a negative argument, and when `uniquePaths()` creates a `std::vector` this `-1` gets implicitly converted to a large integer because the parameter of `std::vector` is `std::size_t`, an unsigned integer type.\nAlso, are you sure that `solve()` should call `uniquePaths()` and not `solve()`?"
                    }
                ]
            },
            {
                "id": 1902501,
                "content": [
                    {
                        "username": "ahmad_masood",
                        "content": "Hint:\\n\"Total steps to get to the goal how many can you have to pick them to be right\".. If you know combination and permutation concepts then it will be simple using the above statement. Let\\'s suppose i have 7 rows and 3 columns. how many time do i have to move right so to reach my goal? use combination to solve this statement and then implement in the code\\n"
                    },
                    {
                        "username": "zzz6519003",
                        "content": "what if we omit \"The robot can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alwaysaditi](/alwaysaditi) Not if the question asked for (all) <i>minimum</i> paths. A \"visited\" matrix should  take care of previously visited cells. ``980. Unique Paths III`` is similar in nature to this."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Then there could be some paths of infinite length and there would be infinite such paths!"
                    },
                    {
                        "username": "YungIrving",
                        "content": "Can some look at my code. Trying a dfs + memo approach and I just can\\'t visualize how it bubbles up so my answer is wrong. Thanks!\\n\\n    `def uniquePaths(self, m: int, n: int) -> int:\\n        dirs = [(1, 0), (0, 1)]\\n        memo = defaultdict(int)\\n        memo[(m - 1, n - 1)] = 1\\n\\n        def dfs(r, c):\\n            if (r, c) in memo:\\n                return memo[(r, c)]\\n            else:\\n                for i, j in dirs:\\n                    x = r + i\\n                    y = c + j\\n\\n                    if self.valid(m, n, x, y):\\n                        memo[(r, c)] += dfs(x, y)\\n                        return memo[(r, c)]\\n\\n        \\n        dfs(0, 0)\\n        return memo[(0, 0)]\\n\\n    def valid(self, m, n, r, c) -> bool:\\n        return r in range(m) and c in range(n)\\n`"
                    },
                    {
                        "username": "startupveteran",
                        "content": "During live interview, are we permitted to skip DP and head straight to math-based solutions (combinations/permutations)?\n\n----------------SPOILER BELOW------------------:\n.\n.\n.\n.\n..\n.\n.\n.\n.\n.\n..\n.\n.\n.\n.\n..\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n\n        vertical_moves = m-1\n        horizontal_moves = n-1\n        \n        total_moves = vertical_moves + horizontal_moves\n        \n        top = 1\n        bottom = 1\n        for each in range(vertical_moves):\n            top *= total_moves\n            total_moves -= 1\n            bottom *= (1+each)\n        return int(top/bottom)\n"
                    },
                    {
                        "username": "Shivainspace",
                        "content": "i get the output for my code when i put in my compiler. but here am getting a type error, pls help."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = 1;\\n                    continue;\\n                }\\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];\\n\\nthis code works but the code below doesn\\'t what is that I am missing??\\n\\ndp[0][0] = 1;\\n        for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                \\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "In the for loop there will be i<m , j<n. Less than or equal to(<=) is wrong there. Also return value will be dp[m-1][n-1]. Your current code is providing answer for m+1, n+1."
                    },
                    {
                        "username": "ashishlawaniyaa",
                        "content": "fun fact:- robot is not smiling :)"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "why i am getting tle on using dfs"
                    },
                    {
                        "username": "amirdon",
                        "content": "I don\\'t understand why the base-case is `m == 1 || n == 1`. Shouldn\\'t it be `m == 1 && n == 1`?\\n"
                    },
                    {
                        "username": "raginibhayana99",
                        "content": "\"class Solution {\\n    vector<vector<int>>dp;\\n    \\n    int solve(int m, int n){\\n        if(m==0 and n==0) return 1;\\n        if(m<0 or n <0) return 0;\\n\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\n        return dp[m][n] = uniquePaths(m-1, n)+ uniquePaths(m, n-1);\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        dp = vector<vector<int>>(m, vector<int>(n, -1));\\n        return solve(m-1, n-1);\\n        return 0;\\n    }\\n}; \"i am getting this error: terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  cannot create std::vector larger than max_size(). Please help. Thank you so much in advance. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If only one of `m` or `n` is `0` then the `return` statement calls `uniquePaths()` with a negative argument, and when `uniquePaths()` creates a `std::vector` this `-1` gets implicitly converted to a large integer because the parameter of `std::vector` is `std::size_t`, an unsigned integer type.\nAlso, are you sure that `solve()` should call `uniquePaths()` and not `solve()`?"
                    }
                ]
            },
            {
                "id": 1870221,
                "content": [
                    {
                        "username": "ahmad_masood",
                        "content": "Hint:\\n\"Total steps to get to the goal how many can you have to pick them to be right\".. If you know combination and permutation concepts then it will be simple using the above statement. Let\\'s suppose i have 7 rows and 3 columns. how many time do i have to move right so to reach my goal? use combination to solve this statement and then implement in the code\\n"
                    },
                    {
                        "username": "zzz6519003",
                        "content": "what if we omit \"The robot can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alwaysaditi](/alwaysaditi) Not if the question asked for (all) <i>minimum</i> paths. A \"visited\" matrix should  take care of previously visited cells. ``980. Unique Paths III`` is similar in nature to this."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Then there could be some paths of infinite length and there would be infinite such paths!"
                    },
                    {
                        "username": "YungIrving",
                        "content": "Can some look at my code. Trying a dfs + memo approach and I just can\\'t visualize how it bubbles up so my answer is wrong. Thanks!\\n\\n    `def uniquePaths(self, m: int, n: int) -> int:\\n        dirs = [(1, 0), (0, 1)]\\n        memo = defaultdict(int)\\n        memo[(m - 1, n - 1)] = 1\\n\\n        def dfs(r, c):\\n            if (r, c) in memo:\\n                return memo[(r, c)]\\n            else:\\n                for i, j in dirs:\\n                    x = r + i\\n                    y = c + j\\n\\n                    if self.valid(m, n, x, y):\\n                        memo[(r, c)] += dfs(x, y)\\n                        return memo[(r, c)]\\n\\n        \\n        dfs(0, 0)\\n        return memo[(0, 0)]\\n\\n    def valid(self, m, n, r, c) -> bool:\\n        return r in range(m) and c in range(n)\\n`"
                    },
                    {
                        "username": "startupveteran",
                        "content": "During live interview, are we permitted to skip DP and head straight to math-based solutions (combinations/permutations)?\n\n----------------SPOILER BELOW------------------:\n.\n.\n.\n.\n..\n.\n.\n.\n.\n.\n..\n.\n.\n.\n.\n..\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n\n        vertical_moves = m-1\n        horizontal_moves = n-1\n        \n        total_moves = vertical_moves + horizontal_moves\n        \n        top = 1\n        bottom = 1\n        for each in range(vertical_moves):\n            top *= total_moves\n            total_moves -= 1\n            bottom *= (1+each)\n        return int(top/bottom)\n"
                    },
                    {
                        "username": "Shivainspace",
                        "content": "i get the output for my code when i put in my compiler. but here am getting a type error, pls help."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = 1;\\n                    continue;\\n                }\\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];\\n\\nthis code works but the code below doesn\\'t what is that I am missing??\\n\\ndp[0][0] = 1;\\n        for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                \\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "In the for loop there will be i<m , j<n. Less than or equal to(<=) is wrong there. Also return value will be dp[m-1][n-1]. Your current code is providing answer for m+1, n+1."
                    },
                    {
                        "username": "ashishlawaniyaa",
                        "content": "fun fact:- robot is not smiling :)"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "why i am getting tle on using dfs"
                    },
                    {
                        "username": "amirdon",
                        "content": "I don\\'t understand why the base-case is `m == 1 || n == 1`. Shouldn\\'t it be `m == 1 && n == 1`?\\n"
                    },
                    {
                        "username": "raginibhayana99",
                        "content": "\"class Solution {\\n    vector<vector<int>>dp;\\n    \\n    int solve(int m, int n){\\n        if(m==0 and n==0) return 1;\\n        if(m<0 or n <0) return 0;\\n\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\n        return dp[m][n] = uniquePaths(m-1, n)+ uniquePaths(m, n-1);\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        dp = vector<vector<int>>(m, vector<int>(n, -1));\\n        return solve(m-1, n-1);\\n        return 0;\\n    }\\n}; \"i am getting this error: terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  cannot create std::vector larger than max_size(). Please help. Thank you so much in advance. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If only one of `m` or `n` is `0` then the `return` statement calls `uniquePaths()` with a negative argument, and when `uniquePaths()` creates a `std::vector` this `-1` gets implicitly converted to a large integer because the parameter of `std::vector` is `std::size_t`, an unsigned integer type.\nAlso, are you sure that `solve()` should call `uniquePaths()` and not `solve()`?"
                    }
                ]
            },
            {
                "id": 1856298,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "What is this Bruhh \n```class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        int N = n+m-2;\n        int r = m-1;\n        int ans = 1;\n        for(int i=1;i<=r;i++){\n            ans = ans*(N-r+i)/i;\n        }\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "singhapoorv7",
                        "content": "return 1 if (i==1 or j==1) else self.uniquePaths(i,j-1)+self.uniquePaths(i-1,j)"
                    },
                    {
                        "username": "Hello_There_",
                        "content": "Backtracking approach to check all the paths. But TLE\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        count=0\\n        def back(i,j):\\n            nonlocal count\\n            if i>=m or j>=n:\\n                return \\n            if i==m-1 and j==n-1:\\n                count+=1\\n                return count\\n            back(i,j+1)\\n            back(i+1,j)\\n            return count\\n        back(0,0)\\n        return count"
                    },
                    {
                        "username": "suchitnegi",
                        "content": "can anyone explain me what is the problem with this approach?\\n\\n\\nclass Solution {\\nunordered_set<vector<pair<int,int>>>  st;\\npublic:\\n    \\n    void help(vector<pair<int,int>> &vec,int i,int j,unordered_set<vector<pair<int,int>>> &st,int m,int n)\\n    {\\n        if(i>=m || j>=n)\\n        return;\\n        \\n        if(i==(m-1) && j == (n-1))\\n        {\\n            st.insert(vec);\\n            return;\\n        }\\n\\n        vec.push_back(make_pair(i,j));\\n        help(vec,i+1,j,st,m,n);\\n        vec.pop_back();\\n        help(vec,i,j+1,st,m,n);\\n\\n        // return;\\n       \\n\\n\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n       \\n        vector<pair<int,int>> vec;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n\\n        help(vec,i,j,st,m,n);\\n\\n\\n        int ans = st.size();\\n        return ans;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Should have been marked EASY"
                    },
                    {
                        "username": "harkeshbirman",
                        "content": " no of path required to move from (0,0) to (0,0) is 1"
                    },
                    {
                        "username": "c8763yee",
                        "content": "i don\\'t get it, why my O(1) space solution using more memory than dp solution"
                    },
                    {
                        "username": "pritha28",
                        "content": "What is the time complexity if we traverse all possible paths using dfs approach ?\n`\n     public int dfs(int m, int n, int row_idx, int col_idx){\n         if(row_idx >= m || col_idx >= n) return 0;\n         if(row_idx == m-1 && col_idx == n-1) return 1;\n         return dfs(m, n, row_idx+1, col_idx) + dfs(m, n, row_idx, col_idx+1);\n     }\n`"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "this is a back-tracking problem, right?"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "It should be. If solving it with back tracking and recursions didn\\'t hit TLE."
                    },
                    {
                        "username": "EserCengiz",
                        "content": "uniquePaths = (m+n-2)! / ((m-1)! * (n-1)!)"
                    }
                ]
            },
            {
                "id": 1849563,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "What is this Bruhh \n```class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        int N = n+m-2;\n        int r = m-1;\n        int ans = 1;\n        for(int i=1;i<=r;i++){\n            ans = ans*(N-r+i)/i;\n        }\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "singhapoorv7",
                        "content": "return 1 if (i==1 or j==1) else self.uniquePaths(i,j-1)+self.uniquePaths(i-1,j)"
                    },
                    {
                        "username": "Hello_There_",
                        "content": "Backtracking approach to check all the paths. But TLE\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        count=0\\n        def back(i,j):\\n            nonlocal count\\n            if i>=m or j>=n:\\n                return \\n            if i==m-1 and j==n-1:\\n                count+=1\\n                return count\\n            back(i,j+1)\\n            back(i+1,j)\\n            return count\\n        back(0,0)\\n        return count"
                    },
                    {
                        "username": "suchitnegi",
                        "content": "can anyone explain me what is the problem with this approach?\\n\\n\\nclass Solution {\\nunordered_set<vector<pair<int,int>>>  st;\\npublic:\\n    \\n    void help(vector<pair<int,int>> &vec,int i,int j,unordered_set<vector<pair<int,int>>> &st,int m,int n)\\n    {\\n        if(i>=m || j>=n)\\n        return;\\n        \\n        if(i==(m-1) && j == (n-1))\\n        {\\n            st.insert(vec);\\n            return;\\n        }\\n\\n        vec.push_back(make_pair(i,j));\\n        help(vec,i+1,j,st,m,n);\\n        vec.pop_back();\\n        help(vec,i,j+1,st,m,n);\\n\\n        // return;\\n       \\n\\n\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n       \\n        vector<pair<int,int>> vec;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n\\n        help(vec,i,j,st,m,n);\\n\\n\\n        int ans = st.size();\\n        return ans;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Should have been marked EASY"
                    },
                    {
                        "username": "harkeshbirman",
                        "content": " no of path required to move from (0,0) to (0,0) is 1"
                    },
                    {
                        "username": "c8763yee",
                        "content": "i don\\'t get it, why my O(1) space solution using more memory than dp solution"
                    },
                    {
                        "username": "pritha28",
                        "content": "What is the time complexity if we traverse all possible paths using dfs approach ?\n`\n     public int dfs(int m, int n, int row_idx, int col_idx){\n         if(row_idx >= m || col_idx >= n) return 0;\n         if(row_idx == m-1 && col_idx == n-1) return 1;\n         return dfs(m, n, row_idx+1, col_idx) + dfs(m, n, row_idx, col_idx+1);\n     }\n`"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "this is a back-tracking problem, right?"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "It should be. If solving it with back tracking and recursions didn\\'t hit TLE."
                    },
                    {
                        "username": "EserCengiz",
                        "content": "uniquePaths = (m+n-2)! / ((m-1)! * (n-1)!)"
                    }
                ]
            },
            {
                "id": 1848748,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "What is this Bruhh \n```class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        int N = n+m-2;\n        int r = m-1;\n        int ans = 1;\n        for(int i=1;i<=r;i++){\n            ans = ans*(N-r+i)/i;\n        }\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "singhapoorv7",
                        "content": "return 1 if (i==1 or j==1) else self.uniquePaths(i,j-1)+self.uniquePaths(i-1,j)"
                    },
                    {
                        "username": "Hello_There_",
                        "content": "Backtracking approach to check all the paths. But TLE\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        count=0\\n        def back(i,j):\\n            nonlocal count\\n            if i>=m or j>=n:\\n                return \\n            if i==m-1 and j==n-1:\\n                count+=1\\n                return count\\n            back(i,j+1)\\n            back(i+1,j)\\n            return count\\n        back(0,0)\\n        return count"
                    },
                    {
                        "username": "suchitnegi",
                        "content": "can anyone explain me what is the problem with this approach?\\n\\n\\nclass Solution {\\nunordered_set<vector<pair<int,int>>>  st;\\npublic:\\n    \\n    void help(vector<pair<int,int>> &vec,int i,int j,unordered_set<vector<pair<int,int>>> &st,int m,int n)\\n    {\\n        if(i>=m || j>=n)\\n        return;\\n        \\n        if(i==(m-1) && j == (n-1))\\n        {\\n            st.insert(vec);\\n            return;\\n        }\\n\\n        vec.push_back(make_pair(i,j));\\n        help(vec,i+1,j,st,m,n);\\n        vec.pop_back();\\n        help(vec,i,j+1,st,m,n);\\n\\n        // return;\\n       \\n\\n\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n       \\n        vector<pair<int,int>> vec;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n\\n        help(vec,i,j,st,m,n);\\n\\n\\n        int ans = st.size();\\n        return ans;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Should have been marked EASY"
                    },
                    {
                        "username": "harkeshbirman",
                        "content": " no of path required to move from (0,0) to (0,0) is 1"
                    },
                    {
                        "username": "c8763yee",
                        "content": "i don\\'t get it, why my O(1) space solution using more memory than dp solution"
                    },
                    {
                        "username": "pritha28",
                        "content": "What is the time complexity if we traverse all possible paths using dfs approach ?\n`\n     public int dfs(int m, int n, int row_idx, int col_idx){\n         if(row_idx >= m || col_idx >= n) return 0;\n         if(row_idx == m-1 && col_idx == n-1) return 1;\n         return dfs(m, n, row_idx+1, col_idx) + dfs(m, n, row_idx, col_idx+1);\n     }\n`"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "this is a back-tracking problem, right?"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "It should be. If solving it with back tracking and recursions didn\\'t hit TLE."
                    },
                    {
                        "username": "EserCengiz",
                        "content": "uniquePaths = (m+n-2)! / ((m-1)! * (n-1)!)"
                    }
                ]
            },
            {
                "id": 1845088,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "What is this Bruhh \n```class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        int N = n+m-2;\n        int r = m-1;\n        int ans = 1;\n        for(int i=1;i<=r;i++){\n            ans = ans*(N-r+i)/i;\n        }\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "singhapoorv7",
                        "content": "return 1 if (i==1 or j==1) else self.uniquePaths(i,j-1)+self.uniquePaths(i-1,j)"
                    },
                    {
                        "username": "Hello_There_",
                        "content": "Backtracking approach to check all the paths. But TLE\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        count=0\\n        def back(i,j):\\n            nonlocal count\\n            if i>=m or j>=n:\\n                return \\n            if i==m-1 and j==n-1:\\n                count+=1\\n                return count\\n            back(i,j+1)\\n            back(i+1,j)\\n            return count\\n        back(0,0)\\n        return count"
                    },
                    {
                        "username": "suchitnegi",
                        "content": "can anyone explain me what is the problem with this approach?\\n\\n\\nclass Solution {\\nunordered_set<vector<pair<int,int>>>  st;\\npublic:\\n    \\n    void help(vector<pair<int,int>> &vec,int i,int j,unordered_set<vector<pair<int,int>>> &st,int m,int n)\\n    {\\n        if(i>=m || j>=n)\\n        return;\\n        \\n        if(i==(m-1) && j == (n-1))\\n        {\\n            st.insert(vec);\\n            return;\\n        }\\n\\n        vec.push_back(make_pair(i,j));\\n        help(vec,i+1,j,st,m,n);\\n        vec.pop_back();\\n        help(vec,i,j+1,st,m,n);\\n\\n        // return;\\n       \\n\\n\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n       \\n        vector<pair<int,int>> vec;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n\\n        help(vec,i,j,st,m,n);\\n\\n\\n        int ans = st.size();\\n        return ans;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Should have been marked EASY"
                    },
                    {
                        "username": "harkeshbirman",
                        "content": " no of path required to move from (0,0) to (0,0) is 1"
                    },
                    {
                        "username": "c8763yee",
                        "content": "i don\\'t get it, why my O(1) space solution using more memory than dp solution"
                    },
                    {
                        "username": "pritha28",
                        "content": "What is the time complexity if we traverse all possible paths using dfs approach ?\n`\n     public int dfs(int m, int n, int row_idx, int col_idx){\n         if(row_idx >= m || col_idx >= n) return 0;\n         if(row_idx == m-1 && col_idx == n-1) return 1;\n         return dfs(m, n, row_idx+1, col_idx) + dfs(m, n, row_idx, col_idx+1);\n     }\n`"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "this is a back-tracking problem, right?"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "It should be. If solving it with back tracking and recursions didn\\'t hit TLE."
                    },
                    {
                        "username": "EserCengiz",
                        "content": "uniquePaths = (m+n-2)! / ((m-1)! * (n-1)!)"
                    }
                ]
            },
            {
                "id": 1844958,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "What is this Bruhh \n```class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        int N = n+m-2;\n        int r = m-1;\n        int ans = 1;\n        for(int i=1;i<=r;i++){\n            ans = ans*(N-r+i)/i;\n        }\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "singhapoorv7",
                        "content": "return 1 if (i==1 or j==1) else self.uniquePaths(i,j-1)+self.uniquePaths(i-1,j)"
                    },
                    {
                        "username": "Hello_There_",
                        "content": "Backtracking approach to check all the paths. But TLE\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        count=0\\n        def back(i,j):\\n            nonlocal count\\n            if i>=m or j>=n:\\n                return \\n            if i==m-1 and j==n-1:\\n                count+=1\\n                return count\\n            back(i,j+1)\\n            back(i+1,j)\\n            return count\\n        back(0,0)\\n        return count"
                    },
                    {
                        "username": "suchitnegi",
                        "content": "can anyone explain me what is the problem with this approach?\\n\\n\\nclass Solution {\\nunordered_set<vector<pair<int,int>>>  st;\\npublic:\\n    \\n    void help(vector<pair<int,int>> &vec,int i,int j,unordered_set<vector<pair<int,int>>> &st,int m,int n)\\n    {\\n        if(i>=m || j>=n)\\n        return;\\n        \\n        if(i==(m-1) && j == (n-1))\\n        {\\n            st.insert(vec);\\n            return;\\n        }\\n\\n        vec.push_back(make_pair(i,j));\\n        help(vec,i+1,j,st,m,n);\\n        vec.pop_back();\\n        help(vec,i,j+1,st,m,n);\\n\\n        // return;\\n       \\n\\n\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n       \\n        vector<pair<int,int>> vec;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n\\n        help(vec,i,j,st,m,n);\\n\\n\\n        int ans = st.size();\\n        return ans;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Should have been marked EASY"
                    },
                    {
                        "username": "harkeshbirman",
                        "content": " no of path required to move from (0,0) to (0,0) is 1"
                    },
                    {
                        "username": "c8763yee",
                        "content": "i don\\'t get it, why my O(1) space solution using more memory than dp solution"
                    },
                    {
                        "username": "pritha28",
                        "content": "What is the time complexity if we traverse all possible paths using dfs approach ?\n`\n     public int dfs(int m, int n, int row_idx, int col_idx){\n         if(row_idx >= m || col_idx >= n) return 0;\n         if(row_idx == m-1 && col_idx == n-1) return 1;\n         return dfs(m, n, row_idx+1, col_idx) + dfs(m, n, row_idx, col_idx+1);\n     }\n`"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "this is a back-tracking problem, right?"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "It should be. If solving it with back tracking and recursions didn\\'t hit TLE."
                    },
                    {
                        "username": "EserCengiz",
                        "content": "uniquePaths = (m+n-2)! / ((m-1)! * (n-1)!)"
                    }
                ]
            },
            {
                "id": 1841877,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "What is this Bruhh \n```class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        int N = n+m-2;\n        int r = m-1;\n        int ans = 1;\n        for(int i=1;i<=r;i++){\n            ans = ans*(N-r+i)/i;\n        }\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "singhapoorv7",
                        "content": "return 1 if (i==1 or j==1) else self.uniquePaths(i,j-1)+self.uniquePaths(i-1,j)"
                    },
                    {
                        "username": "Hello_There_",
                        "content": "Backtracking approach to check all the paths. But TLE\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        count=0\\n        def back(i,j):\\n            nonlocal count\\n            if i>=m or j>=n:\\n                return \\n            if i==m-1 and j==n-1:\\n                count+=1\\n                return count\\n            back(i,j+1)\\n            back(i+1,j)\\n            return count\\n        back(0,0)\\n        return count"
                    },
                    {
                        "username": "suchitnegi",
                        "content": "can anyone explain me what is the problem with this approach?\\n\\n\\nclass Solution {\\nunordered_set<vector<pair<int,int>>>  st;\\npublic:\\n    \\n    void help(vector<pair<int,int>> &vec,int i,int j,unordered_set<vector<pair<int,int>>> &st,int m,int n)\\n    {\\n        if(i>=m || j>=n)\\n        return;\\n        \\n        if(i==(m-1) && j == (n-1))\\n        {\\n            st.insert(vec);\\n            return;\\n        }\\n\\n        vec.push_back(make_pair(i,j));\\n        help(vec,i+1,j,st,m,n);\\n        vec.pop_back();\\n        help(vec,i,j+1,st,m,n);\\n\\n        // return;\\n       \\n\\n\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n       \\n        vector<pair<int,int>> vec;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n\\n        help(vec,i,j,st,m,n);\\n\\n\\n        int ans = st.size();\\n        return ans;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Should have been marked EASY"
                    },
                    {
                        "username": "harkeshbirman",
                        "content": " no of path required to move from (0,0) to (0,0) is 1"
                    },
                    {
                        "username": "c8763yee",
                        "content": "i don\\'t get it, why my O(1) space solution using more memory than dp solution"
                    },
                    {
                        "username": "pritha28",
                        "content": "What is the time complexity if we traverse all possible paths using dfs approach ?\n`\n     public int dfs(int m, int n, int row_idx, int col_idx){\n         if(row_idx >= m || col_idx >= n) return 0;\n         if(row_idx == m-1 && col_idx == n-1) return 1;\n         return dfs(m, n, row_idx+1, col_idx) + dfs(m, n, row_idx, col_idx+1);\n     }\n`"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "this is a back-tracking problem, right?"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "It should be. If solving it with back tracking and recursions didn\\'t hit TLE."
                    },
                    {
                        "username": "EserCengiz",
                        "content": "uniquePaths = (m+n-2)! / ((m-1)! * (n-1)!)"
                    }
                ]
            },
            {
                "id": 1832847,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "What is this Bruhh \n```class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        int N = n+m-2;\n        int r = m-1;\n        int ans = 1;\n        for(int i=1;i<=r;i++){\n            ans = ans*(N-r+i)/i;\n        }\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "singhapoorv7",
                        "content": "return 1 if (i==1 or j==1) else self.uniquePaths(i,j-1)+self.uniquePaths(i-1,j)"
                    },
                    {
                        "username": "Hello_There_",
                        "content": "Backtracking approach to check all the paths. But TLE\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        count=0\\n        def back(i,j):\\n            nonlocal count\\n            if i>=m or j>=n:\\n                return \\n            if i==m-1 and j==n-1:\\n                count+=1\\n                return count\\n            back(i,j+1)\\n            back(i+1,j)\\n            return count\\n        back(0,0)\\n        return count"
                    },
                    {
                        "username": "suchitnegi",
                        "content": "can anyone explain me what is the problem with this approach?\\n\\n\\nclass Solution {\\nunordered_set<vector<pair<int,int>>>  st;\\npublic:\\n    \\n    void help(vector<pair<int,int>> &vec,int i,int j,unordered_set<vector<pair<int,int>>> &st,int m,int n)\\n    {\\n        if(i>=m || j>=n)\\n        return;\\n        \\n        if(i==(m-1) && j == (n-1))\\n        {\\n            st.insert(vec);\\n            return;\\n        }\\n\\n        vec.push_back(make_pair(i,j));\\n        help(vec,i+1,j,st,m,n);\\n        vec.pop_back();\\n        help(vec,i,j+1,st,m,n);\\n\\n        // return;\\n       \\n\\n\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n       \\n        vector<pair<int,int>> vec;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n\\n        help(vec,i,j,st,m,n);\\n\\n\\n        int ans = st.size();\\n        return ans;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Should have been marked EASY"
                    },
                    {
                        "username": "harkeshbirman",
                        "content": " no of path required to move from (0,0) to (0,0) is 1"
                    },
                    {
                        "username": "c8763yee",
                        "content": "i don\\'t get it, why my O(1) space solution using more memory than dp solution"
                    },
                    {
                        "username": "pritha28",
                        "content": "What is the time complexity if we traverse all possible paths using dfs approach ?\n`\n     public int dfs(int m, int n, int row_idx, int col_idx){\n         if(row_idx >= m || col_idx >= n) return 0;\n         if(row_idx == m-1 && col_idx == n-1) return 1;\n         return dfs(m, n, row_idx+1, col_idx) + dfs(m, n, row_idx, col_idx+1);\n     }\n`"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "this is a back-tracking problem, right?"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "It should be. If solving it with back tracking and recursions didn\\'t hit TLE."
                    },
                    {
                        "username": "EserCengiz",
                        "content": "uniquePaths = (m+n-2)! / ((m-1)! * (n-1)!)"
                    }
                ]
            },
            {
                "id": 1822880,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "What is this Bruhh \n```class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        int N = n+m-2;\n        int r = m-1;\n        int ans = 1;\n        for(int i=1;i<=r;i++){\n            ans = ans*(N-r+i)/i;\n        }\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "singhapoorv7",
                        "content": "return 1 if (i==1 or j==1) else self.uniquePaths(i,j-1)+self.uniquePaths(i-1,j)"
                    },
                    {
                        "username": "Hello_There_",
                        "content": "Backtracking approach to check all the paths. But TLE\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        count=0\\n        def back(i,j):\\n            nonlocal count\\n            if i>=m or j>=n:\\n                return \\n            if i==m-1 and j==n-1:\\n                count+=1\\n                return count\\n            back(i,j+1)\\n            back(i+1,j)\\n            return count\\n        back(0,0)\\n        return count"
                    },
                    {
                        "username": "suchitnegi",
                        "content": "can anyone explain me what is the problem with this approach?\\n\\n\\nclass Solution {\\nunordered_set<vector<pair<int,int>>>  st;\\npublic:\\n    \\n    void help(vector<pair<int,int>> &vec,int i,int j,unordered_set<vector<pair<int,int>>> &st,int m,int n)\\n    {\\n        if(i>=m || j>=n)\\n        return;\\n        \\n        if(i==(m-1) && j == (n-1))\\n        {\\n            st.insert(vec);\\n            return;\\n        }\\n\\n        vec.push_back(make_pair(i,j));\\n        help(vec,i+1,j,st,m,n);\\n        vec.pop_back();\\n        help(vec,i,j+1,st,m,n);\\n\\n        // return;\\n       \\n\\n\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n       \\n        vector<pair<int,int>> vec;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n\\n        help(vec,i,j,st,m,n);\\n\\n\\n        int ans = st.size();\\n        return ans;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Should have been marked EASY"
                    },
                    {
                        "username": "harkeshbirman",
                        "content": " no of path required to move from (0,0) to (0,0) is 1"
                    },
                    {
                        "username": "c8763yee",
                        "content": "i don\\'t get it, why my O(1) space solution using more memory than dp solution"
                    },
                    {
                        "username": "pritha28",
                        "content": "What is the time complexity if we traverse all possible paths using dfs approach ?\n`\n     public int dfs(int m, int n, int row_idx, int col_idx){\n         if(row_idx >= m || col_idx >= n) return 0;\n         if(row_idx == m-1 && col_idx == n-1) return 1;\n         return dfs(m, n, row_idx+1, col_idx) + dfs(m, n, row_idx, col_idx+1);\n     }\n`"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "this is a back-tracking problem, right?"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "It should be. If solving it with back tracking and recursions didn\\'t hit TLE."
                    },
                    {
                        "username": "EserCengiz",
                        "content": "uniquePaths = (m+n-2)! / ((m-1)! * (n-1)!)"
                    }
                ]
            },
            {
                "id": 1820592,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "What is this Bruhh \n```class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        int N = n+m-2;\n        int r = m-1;\n        int ans = 1;\n        for(int i=1;i<=r;i++){\n            ans = ans*(N-r+i)/i;\n        }\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "singhapoorv7",
                        "content": "return 1 if (i==1 or j==1) else self.uniquePaths(i,j-1)+self.uniquePaths(i-1,j)"
                    },
                    {
                        "username": "Hello_There_",
                        "content": "Backtracking approach to check all the paths. But TLE\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        count=0\\n        def back(i,j):\\n            nonlocal count\\n            if i>=m or j>=n:\\n                return \\n            if i==m-1 and j==n-1:\\n                count+=1\\n                return count\\n            back(i,j+1)\\n            back(i+1,j)\\n            return count\\n        back(0,0)\\n        return count"
                    },
                    {
                        "username": "suchitnegi",
                        "content": "can anyone explain me what is the problem with this approach?\\n\\n\\nclass Solution {\\nunordered_set<vector<pair<int,int>>>  st;\\npublic:\\n    \\n    void help(vector<pair<int,int>> &vec,int i,int j,unordered_set<vector<pair<int,int>>> &st,int m,int n)\\n    {\\n        if(i>=m || j>=n)\\n        return;\\n        \\n        if(i==(m-1) && j == (n-1))\\n        {\\n            st.insert(vec);\\n            return;\\n        }\\n\\n        vec.push_back(make_pair(i,j));\\n        help(vec,i+1,j,st,m,n);\\n        vec.pop_back();\\n        help(vec,i,j+1,st,m,n);\\n\\n        // return;\\n       \\n\\n\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n       \\n        vector<pair<int,int>> vec;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n\\n        help(vec,i,j,st,m,n);\\n\\n\\n        int ans = st.size();\\n        return ans;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Should have been marked EASY"
                    },
                    {
                        "username": "harkeshbirman",
                        "content": " no of path required to move from (0,0) to (0,0) is 1"
                    },
                    {
                        "username": "c8763yee",
                        "content": "i don\\'t get it, why my O(1) space solution using more memory than dp solution"
                    },
                    {
                        "username": "pritha28",
                        "content": "What is the time complexity if we traverse all possible paths using dfs approach ?\n`\n     public int dfs(int m, int n, int row_idx, int col_idx){\n         if(row_idx >= m || col_idx >= n) return 0;\n         if(row_idx == m-1 && col_idx == n-1) return 1;\n         return dfs(m, n, row_idx+1, col_idx) + dfs(m, n, row_idx, col_idx+1);\n     }\n`"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "this is a back-tracking problem, right?"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "It should be. If solving it with back tracking and recursions didn\\'t hit TLE."
                    },
                    {
                        "username": "EserCengiz",
                        "content": "uniquePaths = (m+n-2)! / ((m-1)! * (n-1)!)"
                    }
                ]
            },
            {
                "id": 1806039,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "What is this Bruhh \n```class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        int N = n+m-2;\n        int r = m-1;\n        int ans = 1;\n        for(int i=1;i<=r;i++){\n            ans = ans*(N-r+i)/i;\n        }\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "singhapoorv7",
                        "content": "return 1 if (i==1 or j==1) else self.uniquePaths(i,j-1)+self.uniquePaths(i-1,j)"
                    },
                    {
                        "username": "Hello_There_",
                        "content": "Backtracking approach to check all the paths. But TLE\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        count=0\\n        def back(i,j):\\n            nonlocal count\\n            if i>=m or j>=n:\\n                return \\n            if i==m-1 and j==n-1:\\n                count+=1\\n                return count\\n            back(i,j+1)\\n            back(i+1,j)\\n            return count\\n        back(0,0)\\n        return count"
                    },
                    {
                        "username": "suchitnegi",
                        "content": "can anyone explain me what is the problem with this approach?\\n\\n\\nclass Solution {\\nunordered_set<vector<pair<int,int>>>  st;\\npublic:\\n    \\n    void help(vector<pair<int,int>> &vec,int i,int j,unordered_set<vector<pair<int,int>>> &st,int m,int n)\\n    {\\n        if(i>=m || j>=n)\\n        return;\\n        \\n        if(i==(m-1) && j == (n-1))\\n        {\\n            st.insert(vec);\\n            return;\\n        }\\n\\n        vec.push_back(make_pair(i,j));\\n        help(vec,i+1,j,st,m,n);\\n        vec.pop_back();\\n        help(vec,i,j+1,st,m,n);\\n\\n        // return;\\n       \\n\\n\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n       \\n        vector<pair<int,int>> vec;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n\\n        help(vec,i,j,st,m,n);\\n\\n\\n        int ans = st.size();\\n        return ans;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Should have been marked EASY"
                    },
                    {
                        "username": "harkeshbirman",
                        "content": " no of path required to move from (0,0) to (0,0) is 1"
                    },
                    {
                        "username": "c8763yee",
                        "content": "i don\\'t get it, why my O(1) space solution using more memory than dp solution"
                    },
                    {
                        "username": "pritha28",
                        "content": "What is the time complexity if we traverse all possible paths using dfs approach ?\n`\n     public int dfs(int m, int n, int row_idx, int col_idx){\n         if(row_idx >= m || col_idx >= n) return 0;\n         if(row_idx == m-1 && col_idx == n-1) return 1;\n         return dfs(m, n, row_idx+1, col_idx) + dfs(m, n, row_idx, col_idx+1);\n     }\n`"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "this is a back-tracking problem, right?"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "It should be. If solving it with back tracking and recursions didn\\'t hit TLE."
                    },
                    {
                        "username": "EserCengiz",
                        "content": "uniquePaths = (m+n-2)! / ((m-1)! * (n-1)!)"
                    }
                ]
            },
            {
                "id": 1803957,
                "content": [
                    {
                        "username": "bikramleeemboo",
                        "content": "Can please suggest me how to decrease runtime for this following code. thanks in advance.\\n\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return recursive(m, n, 0, 0);\\n    }\\n\\n    private int recursive(int m, int n, int x, int y) {\\n        if(x == m -1 && y == n -1) {\\n            return 1;\\n        }\\n        if(x == m || y == n) return 0;\\n        return recursive(m, n, x + 1, y) + recursive(m, n, x, y + 1);\\n    }\\n}"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "Here, I use tablization in which finding out the unique paths  by making the rows and columns in the dp matrix or the same as the table given i.e,. m,n...Now implement  dp[i][j] = dp[i-1][j] + dp[i][j-1]; by this we get the unique paths "
                    },
                    {
                        "username": "amaan7",
                        "content": "Why i am getting TLE ?? can someone explain !!\\n\\n`class Solution {\\n    public int countPaths(int m ,int n, int i ,int j){\\n        if(i>=m || j >=n){\\n            return 0;\\n        }\\n        if(i==m-1 && j==n-1){\\n            return 1;\\n        }\\n        int downPaths = countPaths(m,n,i+1,j);\\n        int RightPaths = countPaths(m,n,i,j+1);\\n        return downPaths+RightPaths;\\n    }\\n    public int uniquePaths(int m, int n) {\\n        int ans = countPaths(m,n,0,0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First of all, please make sure the code which you are sending is enough for readability, we are programmers, not bloggers."
                    },
                    {
                        "username": "Code2Buzz",
                        "content": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(m,1));\n        for(int i=m-2;i>=0;i--){\n            for(int j=n-2;j>=0;j--){\n                dp[i][j]=dp[i+1][j]+dp[i][j+1];\n            }\n        }\n        return dp[0][0];\n    }\n};\n\nWhat is wrong in above code it's getting AddressSanitizer error ?."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the definition of `dp`. It creates a `std::vector<std::vector<int>>` with dimensions `m x m`.  \\nBut what if `n` is greater than `m`?"
                    },
                    {
                        "username": "user4956si",
                        "content": "I\\'ll try to explain as simply as possible.\\nLet\\'s say, you only have a 1x1 grid. In this case, it doesn\\'t make sense to get to the end so let\\'s assume the number of ways to get to the end would be 1.\\n\\nNow, if you have 2x1 grid, no of of ways of getting to end would be 1. similarly for 3x1 grid, answer would be 1. So, for mx1 grid, total number of ways to get to the end would be 1.\\n\\nSimilarly, total number of ways to get to the end of 1xn grid would also be 1.\\n\\nNow, calculating the number of ways to get to the end is simple. If you are at (m-1,n-2) position number of ways is 1. If you are at (m-2,n-1) number of ways is 1. And mind you, to reach (m-1,n-1) you must first either enter (m-1,n-2) or (m-2,n-1). \\n\\nSo total no of ways of reaching (m-1,n-1) = no of ways of reaching(m-2,n-1) + no of ways of reaching (m-1,n-2).\\n\\nNow we can solve this using dynamic programming technique."
                    },
                    {
                        "username": "ivsvinay2003",
                        "content": "class Solution {\\npublic:\\n    long long int solve(int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(m<0 || n<0){\\n            return 0;\\n        }\\n        if(m==0 && n!=0){\\n            return 1;\\n        }\\n        if(m!=0 && n==0){\\n            return 1;\\n        }\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        return dp[m][n]=1+solve(m-1,n,dp)+solve(m,n-1,dp);\\n    }\\n    long long int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,-1));\\n        long long ans=solve(m-1,n-1,dp);\\n        return (ans+1)/2;\\n    }\\nmay I know what\\'s the problem for this solution?\\n61/63 cases passed!!\\nremaining 2 are left"
                    },
                    {
                        "username": "roundup414",
                        "content": "// Why this code giving TLE \n\n\nclass Solution {\npublic:\n  int solve(int m,int n,vector<vector<int>> dp)\n    {\n        if(m==0 && n==0)\n            return 1;\n        if(m<0 || n<0)\n            return 0;\n        if(dp[m][n]!=-1) return dp[m][n];\n        int  sum=solve(m,n-1,dp)+solve(m-1,n,dp);\n        return dp[m][n]=sum;\n    }\n   int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(n,-1));\n        return solve(m-1,n-1,dp);\n    }\n};\n\n\n\n\n\n\n\n// Why this code doesn't \n\nclass Solution {\npublic:\n\n   int countWaysUtil(int i, int j, vector<vector<int> > &dp) {\n  if(i==0 && j == 0)\n    return 1;\n  if(i<0 || j<0)\n    return 0;\n  if(dp[i][j]!=-1) return dp[i][j];\n    \n  int up = countWaysUtil(i-1,j,dp);\n  int left = countWaysUtil(i,j-1,dp);\n  \n  return dp[i][j] = up+left;\n  \n}\n\nint uniquePaths(int m, int n){\n    vector<vector<int> > dp(m,vector<int>(n,-1));\n    return countWaysUtil(m-1,n-1,dp);\n    \n}\n};\n\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Biggest hint:\\n1. Draw the number of possible ways to reach the finish on a grid.\\n2. Look for the pattern\\n3. Put that pattern into code\\n4. Question how one is able to come to these conclusions during coding interviews"
                    },
                    {
                        "username": "sed4ted",
                        "content": "So for this problem i decided to use tgamma from cmath to implement combinatorics formula, but i think i ran into a problem of precition.\\nwhen i use standart tgamma i get some of the answers 1 short, when i use tgammal i get other testcases wrong is this rounding problem for different compilers or smth?"
                    },
                    {
                        "username": "prats02",
                        "content": "how do i optimize this or y isnt this giving me ans\\nclass Solution {\\npublic:\\n    int fact(int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return fact((n+m)-2)/(fact(n-1)*fact(m-1));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1800932,
                "content": [
                    {
                        "username": "bikramleeemboo",
                        "content": "Can please suggest me how to decrease runtime for this following code. thanks in advance.\\n\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return recursive(m, n, 0, 0);\\n    }\\n\\n    private int recursive(int m, int n, int x, int y) {\\n        if(x == m -1 && y == n -1) {\\n            return 1;\\n        }\\n        if(x == m || y == n) return 0;\\n        return recursive(m, n, x + 1, y) + recursive(m, n, x, y + 1);\\n    }\\n}"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "Here, I use tablization in which finding out the unique paths  by making the rows and columns in the dp matrix or the same as the table given i.e,. m,n...Now implement  dp[i][j] = dp[i-1][j] + dp[i][j-1]; by this we get the unique paths "
                    },
                    {
                        "username": "amaan7",
                        "content": "Why i am getting TLE ?? can someone explain !!\\n\\n`class Solution {\\n    public int countPaths(int m ,int n, int i ,int j){\\n        if(i>=m || j >=n){\\n            return 0;\\n        }\\n        if(i==m-1 && j==n-1){\\n            return 1;\\n        }\\n        int downPaths = countPaths(m,n,i+1,j);\\n        int RightPaths = countPaths(m,n,i,j+1);\\n        return downPaths+RightPaths;\\n    }\\n    public int uniquePaths(int m, int n) {\\n        int ans = countPaths(m,n,0,0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First of all, please make sure the code which you are sending is enough for readability, we are programmers, not bloggers."
                    },
                    {
                        "username": "Code2Buzz",
                        "content": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(m,1));\n        for(int i=m-2;i>=0;i--){\n            for(int j=n-2;j>=0;j--){\n                dp[i][j]=dp[i+1][j]+dp[i][j+1];\n            }\n        }\n        return dp[0][0];\n    }\n};\n\nWhat is wrong in above code it's getting AddressSanitizer error ?."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the definition of `dp`. It creates a `std::vector<std::vector<int>>` with dimensions `m x m`.  \\nBut what if `n` is greater than `m`?"
                    },
                    {
                        "username": "user4956si",
                        "content": "I\\'ll try to explain as simply as possible.\\nLet\\'s say, you only have a 1x1 grid. In this case, it doesn\\'t make sense to get to the end so let\\'s assume the number of ways to get to the end would be 1.\\n\\nNow, if you have 2x1 grid, no of of ways of getting to end would be 1. similarly for 3x1 grid, answer would be 1. So, for mx1 grid, total number of ways to get to the end would be 1.\\n\\nSimilarly, total number of ways to get to the end of 1xn grid would also be 1.\\n\\nNow, calculating the number of ways to get to the end is simple. If you are at (m-1,n-2) position number of ways is 1. If you are at (m-2,n-1) number of ways is 1. And mind you, to reach (m-1,n-1) you must first either enter (m-1,n-2) or (m-2,n-1). \\n\\nSo total no of ways of reaching (m-1,n-1) = no of ways of reaching(m-2,n-1) + no of ways of reaching (m-1,n-2).\\n\\nNow we can solve this using dynamic programming technique."
                    },
                    {
                        "username": "ivsvinay2003",
                        "content": "class Solution {\\npublic:\\n    long long int solve(int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(m<0 || n<0){\\n            return 0;\\n        }\\n        if(m==0 && n!=0){\\n            return 1;\\n        }\\n        if(m!=0 && n==0){\\n            return 1;\\n        }\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        return dp[m][n]=1+solve(m-1,n,dp)+solve(m,n-1,dp);\\n    }\\n    long long int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,-1));\\n        long long ans=solve(m-1,n-1,dp);\\n        return (ans+1)/2;\\n    }\\nmay I know what\\'s the problem for this solution?\\n61/63 cases passed!!\\nremaining 2 are left"
                    },
                    {
                        "username": "roundup414",
                        "content": "// Why this code giving TLE \n\n\nclass Solution {\npublic:\n  int solve(int m,int n,vector<vector<int>> dp)\n    {\n        if(m==0 && n==0)\n            return 1;\n        if(m<0 || n<0)\n            return 0;\n        if(dp[m][n]!=-1) return dp[m][n];\n        int  sum=solve(m,n-1,dp)+solve(m-1,n,dp);\n        return dp[m][n]=sum;\n    }\n   int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(n,-1));\n        return solve(m-1,n-1,dp);\n    }\n};\n\n\n\n\n\n\n\n// Why this code doesn't \n\nclass Solution {\npublic:\n\n   int countWaysUtil(int i, int j, vector<vector<int> > &dp) {\n  if(i==0 && j == 0)\n    return 1;\n  if(i<0 || j<0)\n    return 0;\n  if(dp[i][j]!=-1) return dp[i][j];\n    \n  int up = countWaysUtil(i-1,j,dp);\n  int left = countWaysUtil(i,j-1,dp);\n  \n  return dp[i][j] = up+left;\n  \n}\n\nint uniquePaths(int m, int n){\n    vector<vector<int> > dp(m,vector<int>(n,-1));\n    return countWaysUtil(m-1,n-1,dp);\n    \n}\n};\n\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Biggest hint:\\n1. Draw the number of possible ways to reach the finish on a grid.\\n2. Look for the pattern\\n3. Put that pattern into code\\n4. Question how one is able to come to these conclusions during coding interviews"
                    },
                    {
                        "username": "sed4ted",
                        "content": "So for this problem i decided to use tgamma from cmath to implement combinatorics formula, but i think i ran into a problem of precition.\\nwhen i use standart tgamma i get some of the answers 1 short, when i use tgammal i get other testcases wrong is this rounding problem for different compilers or smth?"
                    },
                    {
                        "username": "prats02",
                        "content": "how do i optimize this or y isnt this giving me ans\\nclass Solution {\\npublic:\\n    int fact(int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return fact((n+m)-2)/(fact(n-1)*fact(m-1));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1799419,
                "content": [
                    {
                        "username": "bikramleeemboo",
                        "content": "Can please suggest me how to decrease runtime for this following code. thanks in advance.\\n\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return recursive(m, n, 0, 0);\\n    }\\n\\n    private int recursive(int m, int n, int x, int y) {\\n        if(x == m -1 && y == n -1) {\\n            return 1;\\n        }\\n        if(x == m || y == n) return 0;\\n        return recursive(m, n, x + 1, y) + recursive(m, n, x, y + 1);\\n    }\\n}"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "Here, I use tablization in which finding out the unique paths  by making the rows and columns in the dp matrix or the same as the table given i.e,. m,n...Now implement  dp[i][j] = dp[i-1][j] + dp[i][j-1]; by this we get the unique paths "
                    },
                    {
                        "username": "amaan7",
                        "content": "Why i am getting TLE ?? can someone explain !!\\n\\n`class Solution {\\n    public int countPaths(int m ,int n, int i ,int j){\\n        if(i>=m || j >=n){\\n            return 0;\\n        }\\n        if(i==m-1 && j==n-1){\\n            return 1;\\n        }\\n        int downPaths = countPaths(m,n,i+1,j);\\n        int RightPaths = countPaths(m,n,i,j+1);\\n        return downPaths+RightPaths;\\n    }\\n    public int uniquePaths(int m, int n) {\\n        int ans = countPaths(m,n,0,0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First of all, please make sure the code which you are sending is enough for readability, we are programmers, not bloggers."
                    },
                    {
                        "username": "Code2Buzz",
                        "content": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(m,1));\n        for(int i=m-2;i>=0;i--){\n            for(int j=n-2;j>=0;j--){\n                dp[i][j]=dp[i+1][j]+dp[i][j+1];\n            }\n        }\n        return dp[0][0];\n    }\n};\n\nWhat is wrong in above code it's getting AddressSanitizer error ?."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the definition of `dp`. It creates a `std::vector<std::vector<int>>` with dimensions `m x m`.  \\nBut what if `n` is greater than `m`?"
                    },
                    {
                        "username": "user4956si",
                        "content": "I\\'ll try to explain as simply as possible.\\nLet\\'s say, you only have a 1x1 grid. In this case, it doesn\\'t make sense to get to the end so let\\'s assume the number of ways to get to the end would be 1.\\n\\nNow, if you have 2x1 grid, no of of ways of getting to end would be 1. similarly for 3x1 grid, answer would be 1. So, for mx1 grid, total number of ways to get to the end would be 1.\\n\\nSimilarly, total number of ways to get to the end of 1xn grid would also be 1.\\n\\nNow, calculating the number of ways to get to the end is simple. If you are at (m-1,n-2) position number of ways is 1. If you are at (m-2,n-1) number of ways is 1. And mind you, to reach (m-1,n-1) you must first either enter (m-1,n-2) or (m-2,n-1). \\n\\nSo total no of ways of reaching (m-1,n-1) = no of ways of reaching(m-2,n-1) + no of ways of reaching (m-1,n-2).\\n\\nNow we can solve this using dynamic programming technique."
                    },
                    {
                        "username": "ivsvinay2003",
                        "content": "class Solution {\\npublic:\\n    long long int solve(int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(m<0 || n<0){\\n            return 0;\\n        }\\n        if(m==0 && n!=0){\\n            return 1;\\n        }\\n        if(m!=0 && n==0){\\n            return 1;\\n        }\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        return dp[m][n]=1+solve(m-1,n,dp)+solve(m,n-1,dp);\\n    }\\n    long long int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,-1));\\n        long long ans=solve(m-1,n-1,dp);\\n        return (ans+1)/2;\\n    }\\nmay I know what\\'s the problem for this solution?\\n61/63 cases passed!!\\nremaining 2 are left"
                    },
                    {
                        "username": "roundup414",
                        "content": "// Why this code giving TLE \n\n\nclass Solution {\npublic:\n  int solve(int m,int n,vector<vector<int>> dp)\n    {\n        if(m==0 && n==0)\n            return 1;\n        if(m<0 || n<0)\n            return 0;\n        if(dp[m][n]!=-1) return dp[m][n];\n        int  sum=solve(m,n-1,dp)+solve(m-1,n,dp);\n        return dp[m][n]=sum;\n    }\n   int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(n,-1));\n        return solve(m-1,n-1,dp);\n    }\n};\n\n\n\n\n\n\n\n// Why this code doesn't \n\nclass Solution {\npublic:\n\n   int countWaysUtil(int i, int j, vector<vector<int> > &dp) {\n  if(i==0 && j == 0)\n    return 1;\n  if(i<0 || j<0)\n    return 0;\n  if(dp[i][j]!=-1) return dp[i][j];\n    \n  int up = countWaysUtil(i-1,j,dp);\n  int left = countWaysUtil(i,j-1,dp);\n  \n  return dp[i][j] = up+left;\n  \n}\n\nint uniquePaths(int m, int n){\n    vector<vector<int> > dp(m,vector<int>(n,-1));\n    return countWaysUtil(m-1,n-1,dp);\n    \n}\n};\n\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Biggest hint:\\n1. Draw the number of possible ways to reach the finish on a grid.\\n2. Look for the pattern\\n3. Put that pattern into code\\n4. Question how one is able to come to these conclusions during coding interviews"
                    },
                    {
                        "username": "sed4ted",
                        "content": "So for this problem i decided to use tgamma from cmath to implement combinatorics formula, but i think i ran into a problem of precition.\\nwhen i use standart tgamma i get some of the answers 1 short, when i use tgammal i get other testcases wrong is this rounding problem for different compilers or smth?"
                    },
                    {
                        "username": "prats02",
                        "content": "how do i optimize this or y isnt this giving me ans\\nclass Solution {\\npublic:\\n    int fact(int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return fact((n+m)-2)/(fact(n-1)*fact(m-1));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1786634,
                "content": [
                    {
                        "username": "bikramleeemboo",
                        "content": "Can please suggest me how to decrease runtime for this following code. thanks in advance.\\n\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return recursive(m, n, 0, 0);\\n    }\\n\\n    private int recursive(int m, int n, int x, int y) {\\n        if(x == m -1 && y == n -1) {\\n            return 1;\\n        }\\n        if(x == m || y == n) return 0;\\n        return recursive(m, n, x + 1, y) + recursive(m, n, x, y + 1);\\n    }\\n}"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "Here, I use tablization in which finding out the unique paths  by making the rows and columns in the dp matrix or the same as the table given i.e,. m,n...Now implement  dp[i][j] = dp[i-1][j] + dp[i][j-1]; by this we get the unique paths "
                    },
                    {
                        "username": "amaan7",
                        "content": "Why i am getting TLE ?? can someone explain !!\\n\\n`class Solution {\\n    public int countPaths(int m ,int n, int i ,int j){\\n        if(i>=m || j >=n){\\n            return 0;\\n        }\\n        if(i==m-1 && j==n-1){\\n            return 1;\\n        }\\n        int downPaths = countPaths(m,n,i+1,j);\\n        int RightPaths = countPaths(m,n,i,j+1);\\n        return downPaths+RightPaths;\\n    }\\n    public int uniquePaths(int m, int n) {\\n        int ans = countPaths(m,n,0,0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First of all, please make sure the code which you are sending is enough for readability, we are programmers, not bloggers."
                    },
                    {
                        "username": "Code2Buzz",
                        "content": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(m,1));\n        for(int i=m-2;i>=0;i--){\n            for(int j=n-2;j>=0;j--){\n                dp[i][j]=dp[i+1][j]+dp[i][j+1];\n            }\n        }\n        return dp[0][0];\n    }\n};\n\nWhat is wrong in above code it's getting AddressSanitizer error ?."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the definition of `dp`. It creates a `std::vector<std::vector<int>>` with dimensions `m x m`.  \\nBut what if `n` is greater than `m`?"
                    },
                    {
                        "username": "user4956si",
                        "content": "I\\'ll try to explain as simply as possible.\\nLet\\'s say, you only have a 1x1 grid. In this case, it doesn\\'t make sense to get to the end so let\\'s assume the number of ways to get to the end would be 1.\\n\\nNow, if you have 2x1 grid, no of of ways of getting to end would be 1. similarly for 3x1 grid, answer would be 1. So, for mx1 grid, total number of ways to get to the end would be 1.\\n\\nSimilarly, total number of ways to get to the end of 1xn grid would also be 1.\\n\\nNow, calculating the number of ways to get to the end is simple. If you are at (m-1,n-2) position number of ways is 1. If you are at (m-2,n-1) number of ways is 1. And mind you, to reach (m-1,n-1) you must first either enter (m-1,n-2) or (m-2,n-1). \\n\\nSo total no of ways of reaching (m-1,n-1) = no of ways of reaching(m-2,n-1) + no of ways of reaching (m-1,n-2).\\n\\nNow we can solve this using dynamic programming technique."
                    },
                    {
                        "username": "ivsvinay2003",
                        "content": "class Solution {\\npublic:\\n    long long int solve(int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(m<0 || n<0){\\n            return 0;\\n        }\\n        if(m==0 && n!=0){\\n            return 1;\\n        }\\n        if(m!=0 && n==0){\\n            return 1;\\n        }\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        return dp[m][n]=1+solve(m-1,n,dp)+solve(m,n-1,dp);\\n    }\\n    long long int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,-1));\\n        long long ans=solve(m-1,n-1,dp);\\n        return (ans+1)/2;\\n    }\\nmay I know what\\'s the problem for this solution?\\n61/63 cases passed!!\\nremaining 2 are left"
                    },
                    {
                        "username": "roundup414",
                        "content": "// Why this code giving TLE \n\n\nclass Solution {\npublic:\n  int solve(int m,int n,vector<vector<int>> dp)\n    {\n        if(m==0 && n==0)\n            return 1;\n        if(m<0 || n<0)\n            return 0;\n        if(dp[m][n]!=-1) return dp[m][n];\n        int  sum=solve(m,n-1,dp)+solve(m-1,n,dp);\n        return dp[m][n]=sum;\n    }\n   int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(n,-1));\n        return solve(m-1,n-1,dp);\n    }\n};\n\n\n\n\n\n\n\n// Why this code doesn't \n\nclass Solution {\npublic:\n\n   int countWaysUtil(int i, int j, vector<vector<int> > &dp) {\n  if(i==0 && j == 0)\n    return 1;\n  if(i<0 || j<0)\n    return 0;\n  if(dp[i][j]!=-1) return dp[i][j];\n    \n  int up = countWaysUtil(i-1,j,dp);\n  int left = countWaysUtil(i,j-1,dp);\n  \n  return dp[i][j] = up+left;\n  \n}\n\nint uniquePaths(int m, int n){\n    vector<vector<int> > dp(m,vector<int>(n,-1));\n    return countWaysUtil(m-1,n-1,dp);\n    \n}\n};\n\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Biggest hint:\\n1. Draw the number of possible ways to reach the finish on a grid.\\n2. Look for the pattern\\n3. Put that pattern into code\\n4. Question how one is able to come to these conclusions during coding interviews"
                    },
                    {
                        "username": "sed4ted",
                        "content": "So for this problem i decided to use tgamma from cmath to implement combinatorics formula, but i think i ran into a problem of precition.\\nwhen i use standart tgamma i get some of the answers 1 short, when i use tgammal i get other testcases wrong is this rounding problem for different compilers or smth?"
                    },
                    {
                        "username": "prats02",
                        "content": "how do i optimize this or y isnt this giving me ans\\nclass Solution {\\npublic:\\n    int fact(int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return fact((n+m)-2)/(fact(n-1)*fact(m-1));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1784104,
                "content": [
                    {
                        "username": "bikramleeemboo",
                        "content": "Can please suggest me how to decrease runtime for this following code. thanks in advance.\\n\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return recursive(m, n, 0, 0);\\n    }\\n\\n    private int recursive(int m, int n, int x, int y) {\\n        if(x == m -1 && y == n -1) {\\n            return 1;\\n        }\\n        if(x == m || y == n) return 0;\\n        return recursive(m, n, x + 1, y) + recursive(m, n, x, y + 1);\\n    }\\n}"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "Here, I use tablization in which finding out the unique paths  by making the rows and columns in the dp matrix or the same as the table given i.e,. m,n...Now implement  dp[i][j] = dp[i-1][j] + dp[i][j-1]; by this we get the unique paths "
                    },
                    {
                        "username": "amaan7",
                        "content": "Why i am getting TLE ?? can someone explain !!\\n\\n`class Solution {\\n    public int countPaths(int m ,int n, int i ,int j){\\n        if(i>=m || j >=n){\\n            return 0;\\n        }\\n        if(i==m-1 && j==n-1){\\n            return 1;\\n        }\\n        int downPaths = countPaths(m,n,i+1,j);\\n        int RightPaths = countPaths(m,n,i,j+1);\\n        return downPaths+RightPaths;\\n    }\\n    public int uniquePaths(int m, int n) {\\n        int ans = countPaths(m,n,0,0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First of all, please make sure the code which you are sending is enough for readability, we are programmers, not bloggers."
                    },
                    {
                        "username": "Code2Buzz",
                        "content": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(m,1));\n        for(int i=m-2;i>=0;i--){\n            for(int j=n-2;j>=0;j--){\n                dp[i][j]=dp[i+1][j]+dp[i][j+1];\n            }\n        }\n        return dp[0][0];\n    }\n};\n\nWhat is wrong in above code it's getting AddressSanitizer error ?."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the definition of `dp`. It creates a `std::vector<std::vector<int>>` with dimensions `m x m`.  \\nBut what if `n` is greater than `m`?"
                    },
                    {
                        "username": "user4956si",
                        "content": "I\\'ll try to explain as simply as possible.\\nLet\\'s say, you only have a 1x1 grid. In this case, it doesn\\'t make sense to get to the end so let\\'s assume the number of ways to get to the end would be 1.\\n\\nNow, if you have 2x1 grid, no of of ways of getting to end would be 1. similarly for 3x1 grid, answer would be 1. So, for mx1 grid, total number of ways to get to the end would be 1.\\n\\nSimilarly, total number of ways to get to the end of 1xn grid would also be 1.\\n\\nNow, calculating the number of ways to get to the end is simple. If you are at (m-1,n-2) position number of ways is 1. If you are at (m-2,n-1) number of ways is 1. And mind you, to reach (m-1,n-1) you must first either enter (m-1,n-2) or (m-2,n-1). \\n\\nSo total no of ways of reaching (m-1,n-1) = no of ways of reaching(m-2,n-1) + no of ways of reaching (m-1,n-2).\\n\\nNow we can solve this using dynamic programming technique."
                    },
                    {
                        "username": "ivsvinay2003",
                        "content": "class Solution {\\npublic:\\n    long long int solve(int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(m<0 || n<0){\\n            return 0;\\n        }\\n        if(m==0 && n!=0){\\n            return 1;\\n        }\\n        if(m!=0 && n==0){\\n            return 1;\\n        }\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        return dp[m][n]=1+solve(m-1,n,dp)+solve(m,n-1,dp);\\n    }\\n    long long int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,-1));\\n        long long ans=solve(m-1,n-1,dp);\\n        return (ans+1)/2;\\n    }\\nmay I know what\\'s the problem for this solution?\\n61/63 cases passed!!\\nremaining 2 are left"
                    },
                    {
                        "username": "roundup414",
                        "content": "// Why this code giving TLE \n\n\nclass Solution {\npublic:\n  int solve(int m,int n,vector<vector<int>> dp)\n    {\n        if(m==0 && n==0)\n            return 1;\n        if(m<0 || n<0)\n            return 0;\n        if(dp[m][n]!=-1) return dp[m][n];\n        int  sum=solve(m,n-1,dp)+solve(m-1,n,dp);\n        return dp[m][n]=sum;\n    }\n   int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(n,-1));\n        return solve(m-1,n-1,dp);\n    }\n};\n\n\n\n\n\n\n\n// Why this code doesn't \n\nclass Solution {\npublic:\n\n   int countWaysUtil(int i, int j, vector<vector<int> > &dp) {\n  if(i==0 && j == 0)\n    return 1;\n  if(i<0 || j<0)\n    return 0;\n  if(dp[i][j]!=-1) return dp[i][j];\n    \n  int up = countWaysUtil(i-1,j,dp);\n  int left = countWaysUtil(i,j-1,dp);\n  \n  return dp[i][j] = up+left;\n  \n}\n\nint uniquePaths(int m, int n){\n    vector<vector<int> > dp(m,vector<int>(n,-1));\n    return countWaysUtil(m-1,n-1,dp);\n    \n}\n};\n\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Biggest hint:\\n1. Draw the number of possible ways to reach the finish on a grid.\\n2. Look for the pattern\\n3. Put that pattern into code\\n4. Question how one is able to come to these conclusions during coding interviews"
                    },
                    {
                        "username": "sed4ted",
                        "content": "So for this problem i decided to use tgamma from cmath to implement combinatorics formula, but i think i ran into a problem of precition.\\nwhen i use standart tgamma i get some of the answers 1 short, when i use tgammal i get other testcases wrong is this rounding problem for different compilers or smth?"
                    },
                    {
                        "username": "prats02",
                        "content": "how do i optimize this or y isnt this giving me ans\\nclass Solution {\\npublic:\\n    int fact(int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return fact((n+m)-2)/(fact(n-1)*fact(m-1));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1774478,
                "content": [
                    {
                        "username": "bikramleeemboo",
                        "content": "Can please suggest me how to decrease runtime for this following code. thanks in advance.\\n\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return recursive(m, n, 0, 0);\\n    }\\n\\n    private int recursive(int m, int n, int x, int y) {\\n        if(x == m -1 && y == n -1) {\\n            return 1;\\n        }\\n        if(x == m || y == n) return 0;\\n        return recursive(m, n, x + 1, y) + recursive(m, n, x, y + 1);\\n    }\\n}"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "Here, I use tablization in which finding out the unique paths  by making the rows and columns in the dp matrix or the same as the table given i.e,. m,n...Now implement  dp[i][j] = dp[i-1][j] + dp[i][j-1]; by this we get the unique paths "
                    },
                    {
                        "username": "amaan7",
                        "content": "Why i am getting TLE ?? can someone explain !!\\n\\n`class Solution {\\n    public int countPaths(int m ,int n, int i ,int j){\\n        if(i>=m || j >=n){\\n            return 0;\\n        }\\n        if(i==m-1 && j==n-1){\\n            return 1;\\n        }\\n        int downPaths = countPaths(m,n,i+1,j);\\n        int RightPaths = countPaths(m,n,i,j+1);\\n        return downPaths+RightPaths;\\n    }\\n    public int uniquePaths(int m, int n) {\\n        int ans = countPaths(m,n,0,0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First of all, please make sure the code which you are sending is enough for readability, we are programmers, not bloggers."
                    },
                    {
                        "username": "Code2Buzz",
                        "content": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(m,1));\n        for(int i=m-2;i>=0;i--){\n            for(int j=n-2;j>=0;j--){\n                dp[i][j]=dp[i+1][j]+dp[i][j+1];\n            }\n        }\n        return dp[0][0];\n    }\n};\n\nWhat is wrong in above code it's getting AddressSanitizer error ?."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the definition of `dp`. It creates a `std::vector<std::vector<int>>` with dimensions `m x m`.  \\nBut what if `n` is greater than `m`?"
                    },
                    {
                        "username": "user4956si",
                        "content": "I\\'ll try to explain as simply as possible.\\nLet\\'s say, you only have a 1x1 grid. In this case, it doesn\\'t make sense to get to the end so let\\'s assume the number of ways to get to the end would be 1.\\n\\nNow, if you have 2x1 grid, no of of ways of getting to end would be 1. similarly for 3x1 grid, answer would be 1. So, for mx1 grid, total number of ways to get to the end would be 1.\\n\\nSimilarly, total number of ways to get to the end of 1xn grid would also be 1.\\n\\nNow, calculating the number of ways to get to the end is simple. If you are at (m-1,n-2) position number of ways is 1. If you are at (m-2,n-1) number of ways is 1. And mind you, to reach (m-1,n-1) you must first either enter (m-1,n-2) or (m-2,n-1). \\n\\nSo total no of ways of reaching (m-1,n-1) = no of ways of reaching(m-2,n-1) + no of ways of reaching (m-1,n-2).\\n\\nNow we can solve this using dynamic programming technique."
                    },
                    {
                        "username": "ivsvinay2003",
                        "content": "class Solution {\\npublic:\\n    long long int solve(int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(m<0 || n<0){\\n            return 0;\\n        }\\n        if(m==0 && n!=0){\\n            return 1;\\n        }\\n        if(m!=0 && n==0){\\n            return 1;\\n        }\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        return dp[m][n]=1+solve(m-1,n,dp)+solve(m,n-1,dp);\\n    }\\n    long long int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,-1));\\n        long long ans=solve(m-1,n-1,dp);\\n        return (ans+1)/2;\\n    }\\nmay I know what\\'s the problem for this solution?\\n61/63 cases passed!!\\nremaining 2 are left"
                    },
                    {
                        "username": "roundup414",
                        "content": "// Why this code giving TLE \n\n\nclass Solution {\npublic:\n  int solve(int m,int n,vector<vector<int>> dp)\n    {\n        if(m==0 && n==0)\n            return 1;\n        if(m<0 || n<0)\n            return 0;\n        if(dp[m][n]!=-1) return dp[m][n];\n        int  sum=solve(m,n-1,dp)+solve(m-1,n,dp);\n        return dp[m][n]=sum;\n    }\n   int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(n,-1));\n        return solve(m-1,n-1,dp);\n    }\n};\n\n\n\n\n\n\n\n// Why this code doesn't \n\nclass Solution {\npublic:\n\n   int countWaysUtil(int i, int j, vector<vector<int> > &dp) {\n  if(i==0 && j == 0)\n    return 1;\n  if(i<0 || j<0)\n    return 0;\n  if(dp[i][j]!=-1) return dp[i][j];\n    \n  int up = countWaysUtil(i-1,j,dp);\n  int left = countWaysUtil(i,j-1,dp);\n  \n  return dp[i][j] = up+left;\n  \n}\n\nint uniquePaths(int m, int n){\n    vector<vector<int> > dp(m,vector<int>(n,-1));\n    return countWaysUtil(m-1,n-1,dp);\n    \n}\n};\n\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Biggest hint:\\n1. Draw the number of possible ways to reach the finish on a grid.\\n2. Look for the pattern\\n3. Put that pattern into code\\n4. Question how one is able to come to these conclusions during coding interviews"
                    },
                    {
                        "username": "sed4ted",
                        "content": "So for this problem i decided to use tgamma from cmath to implement combinatorics formula, but i think i ran into a problem of precition.\\nwhen i use standart tgamma i get some of the answers 1 short, when i use tgammal i get other testcases wrong is this rounding problem for different compilers or smth?"
                    },
                    {
                        "username": "prats02",
                        "content": "how do i optimize this or y isnt this giving me ans\\nclass Solution {\\npublic:\\n    int fact(int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return fact((n+m)-2)/(fact(n-1)*fact(m-1));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1774153,
                "content": [
                    {
                        "username": "bikramleeemboo",
                        "content": "Can please suggest me how to decrease runtime for this following code. thanks in advance.\\n\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return recursive(m, n, 0, 0);\\n    }\\n\\n    private int recursive(int m, int n, int x, int y) {\\n        if(x == m -1 && y == n -1) {\\n            return 1;\\n        }\\n        if(x == m || y == n) return 0;\\n        return recursive(m, n, x + 1, y) + recursive(m, n, x, y + 1);\\n    }\\n}"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "Here, I use tablization in which finding out the unique paths  by making the rows and columns in the dp matrix or the same as the table given i.e,. m,n...Now implement  dp[i][j] = dp[i-1][j] + dp[i][j-1]; by this we get the unique paths "
                    },
                    {
                        "username": "amaan7",
                        "content": "Why i am getting TLE ?? can someone explain !!\\n\\n`class Solution {\\n    public int countPaths(int m ,int n, int i ,int j){\\n        if(i>=m || j >=n){\\n            return 0;\\n        }\\n        if(i==m-1 && j==n-1){\\n            return 1;\\n        }\\n        int downPaths = countPaths(m,n,i+1,j);\\n        int RightPaths = countPaths(m,n,i,j+1);\\n        return downPaths+RightPaths;\\n    }\\n    public int uniquePaths(int m, int n) {\\n        int ans = countPaths(m,n,0,0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First of all, please make sure the code which you are sending is enough for readability, we are programmers, not bloggers."
                    },
                    {
                        "username": "Code2Buzz",
                        "content": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(m,1));\n        for(int i=m-2;i>=0;i--){\n            for(int j=n-2;j>=0;j--){\n                dp[i][j]=dp[i+1][j]+dp[i][j+1];\n            }\n        }\n        return dp[0][0];\n    }\n};\n\nWhat is wrong in above code it's getting AddressSanitizer error ?."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the definition of `dp`. It creates a `std::vector<std::vector<int>>` with dimensions `m x m`.  \\nBut what if `n` is greater than `m`?"
                    },
                    {
                        "username": "user4956si",
                        "content": "I\\'ll try to explain as simply as possible.\\nLet\\'s say, you only have a 1x1 grid. In this case, it doesn\\'t make sense to get to the end so let\\'s assume the number of ways to get to the end would be 1.\\n\\nNow, if you have 2x1 grid, no of of ways of getting to end would be 1. similarly for 3x1 grid, answer would be 1. So, for mx1 grid, total number of ways to get to the end would be 1.\\n\\nSimilarly, total number of ways to get to the end of 1xn grid would also be 1.\\n\\nNow, calculating the number of ways to get to the end is simple. If you are at (m-1,n-2) position number of ways is 1. If you are at (m-2,n-1) number of ways is 1. And mind you, to reach (m-1,n-1) you must first either enter (m-1,n-2) or (m-2,n-1). \\n\\nSo total no of ways of reaching (m-1,n-1) = no of ways of reaching(m-2,n-1) + no of ways of reaching (m-1,n-2).\\n\\nNow we can solve this using dynamic programming technique."
                    },
                    {
                        "username": "ivsvinay2003",
                        "content": "class Solution {\\npublic:\\n    long long int solve(int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(m<0 || n<0){\\n            return 0;\\n        }\\n        if(m==0 && n!=0){\\n            return 1;\\n        }\\n        if(m!=0 && n==0){\\n            return 1;\\n        }\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        return dp[m][n]=1+solve(m-1,n,dp)+solve(m,n-1,dp);\\n    }\\n    long long int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,-1));\\n        long long ans=solve(m-1,n-1,dp);\\n        return (ans+1)/2;\\n    }\\nmay I know what\\'s the problem for this solution?\\n61/63 cases passed!!\\nremaining 2 are left"
                    },
                    {
                        "username": "roundup414",
                        "content": "// Why this code giving TLE \n\n\nclass Solution {\npublic:\n  int solve(int m,int n,vector<vector<int>> dp)\n    {\n        if(m==0 && n==0)\n            return 1;\n        if(m<0 || n<0)\n            return 0;\n        if(dp[m][n]!=-1) return dp[m][n];\n        int  sum=solve(m,n-1,dp)+solve(m-1,n,dp);\n        return dp[m][n]=sum;\n    }\n   int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(n,-1));\n        return solve(m-1,n-1,dp);\n    }\n};\n\n\n\n\n\n\n\n// Why this code doesn't \n\nclass Solution {\npublic:\n\n   int countWaysUtil(int i, int j, vector<vector<int> > &dp) {\n  if(i==0 && j == 0)\n    return 1;\n  if(i<0 || j<0)\n    return 0;\n  if(dp[i][j]!=-1) return dp[i][j];\n    \n  int up = countWaysUtil(i-1,j,dp);\n  int left = countWaysUtil(i,j-1,dp);\n  \n  return dp[i][j] = up+left;\n  \n}\n\nint uniquePaths(int m, int n){\n    vector<vector<int> > dp(m,vector<int>(n,-1));\n    return countWaysUtil(m-1,n-1,dp);\n    \n}\n};\n\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Biggest hint:\\n1. Draw the number of possible ways to reach the finish on a grid.\\n2. Look for the pattern\\n3. Put that pattern into code\\n4. Question how one is able to come to these conclusions during coding interviews"
                    },
                    {
                        "username": "sed4ted",
                        "content": "So for this problem i decided to use tgamma from cmath to implement combinatorics formula, but i think i ran into a problem of precition.\\nwhen i use standart tgamma i get some of the answers 1 short, when i use tgammal i get other testcases wrong is this rounding problem for different compilers or smth?"
                    },
                    {
                        "username": "prats02",
                        "content": "how do i optimize this or y isnt this giving me ans\\nclass Solution {\\npublic:\\n    int fact(int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return fact((n+m)-2)/(fact(n-1)*fact(m-1));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1770247,
                "content": [
                    {
                        "username": "bikramleeemboo",
                        "content": "Can please suggest me how to decrease runtime for this following code. thanks in advance.\\n\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return recursive(m, n, 0, 0);\\n    }\\n\\n    private int recursive(int m, int n, int x, int y) {\\n        if(x == m -1 && y == n -1) {\\n            return 1;\\n        }\\n        if(x == m || y == n) return 0;\\n        return recursive(m, n, x + 1, y) + recursive(m, n, x, y + 1);\\n    }\\n}"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "Here, I use tablization in which finding out the unique paths  by making the rows and columns in the dp matrix or the same as the table given i.e,. m,n...Now implement  dp[i][j] = dp[i-1][j] + dp[i][j-1]; by this we get the unique paths "
                    },
                    {
                        "username": "amaan7",
                        "content": "Why i am getting TLE ?? can someone explain !!\\n\\n`class Solution {\\n    public int countPaths(int m ,int n, int i ,int j){\\n        if(i>=m || j >=n){\\n            return 0;\\n        }\\n        if(i==m-1 && j==n-1){\\n            return 1;\\n        }\\n        int downPaths = countPaths(m,n,i+1,j);\\n        int RightPaths = countPaths(m,n,i,j+1);\\n        return downPaths+RightPaths;\\n    }\\n    public int uniquePaths(int m, int n) {\\n        int ans = countPaths(m,n,0,0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First of all, please make sure the code which you are sending is enough for readability, we are programmers, not bloggers."
                    },
                    {
                        "username": "Code2Buzz",
                        "content": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(m,1));\n        for(int i=m-2;i>=0;i--){\n            for(int j=n-2;j>=0;j--){\n                dp[i][j]=dp[i+1][j]+dp[i][j+1];\n            }\n        }\n        return dp[0][0];\n    }\n};\n\nWhat is wrong in above code it's getting AddressSanitizer error ?."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the definition of `dp`. It creates a `std::vector<std::vector<int>>` with dimensions `m x m`.  \\nBut what if `n` is greater than `m`?"
                    },
                    {
                        "username": "user4956si",
                        "content": "I\\'ll try to explain as simply as possible.\\nLet\\'s say, you only have a 1x1 grid. In this case, it doesn\\'t make sense to get to the end so let\\'s assume the number of ways to get to the end would be 1.\\n\\nNow, if you have 2x1 grid, no of of ways of getting to end would be 1. similarly for 3x1 grid, answer would be 1. So, for mx1 grid, total number of ways to get to the end would be 1.\\n\\nSimilarly, total number of ways to get to the end of 1xn grid would also be 1.\\n\\nNow, calculating the number of ways to get to the end is simple. If you are at (m-1,n-2) position number of ways is 1. If you are at (m-2,n-1) number of ways is 1. And mind you, to reach (m-1,n-1) you must first either enter (m-1,n-2) or (m-2,n-1). \\n\\nSo total no of ways of reaching (m-1,n-1) = no of ways of reaching(m-2,n-1) + no of ways of reaching (m-1,n-2).\\n\\nNow we can solve this using dynamic programming technique."
                    },
                    {
                        "username": "ivsvinay2003",
                        "content": "class Solution {\\npublic:\\n    long long int solve(int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(m<0 || n<0){\\n            return 0;\\n        }\\n        if(m==0 && n!=0){\\n            return 1;\\n        }\\n        if(m!=0 && n==0){\\n            return 1;\\n        }\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        return dp[m][n]=1+solve(m-1,n,dp)+solve(m,n-1,dp);\\n    }\\n    long long int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,-1));\\n        long long ans=solve(m-1,n-1,dp);\\n        return (ans+1)/2;\\n    }\\nmay I know what\\'s the problem for this solution?\\n61/63 cases passed!!\\nremaining 2 are left"
                    },
                    {
                        "username": "roundup414",
                        "content": "// Why this code giving TLE \n\n\nclass Solution {\npublic:\n  int solve(int m,int n,vector<vector<int>> dp)\n    {\n        if(m==0 && n==0)\n            return 1;\n        if(m<0 || n<0)\n            return 0;\n        if(dp[m][n]!=-1) return dp[m][n];\n        int  sum=solve(m,n-1,dp)+solve(m-1,n,dp);\n        return dp[m][n]=sum;\n    }\n   int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(n,-1));\n        return solve(m-1,n-1,dp);\n    }\n};\n\n\n\n\n\n\n\n// Why this code doesn't \n\nclass Solution {\npublic:\n\n   int countWaysUtil(int i, int j, vector<vector<int> > &dp) {\n  if(i==0 && j == 0)\n    return 1;\n  if(i<0 || j<0)\n    return 0;\n  if(dp[i][j]!=-1) return dp[i][j];\n    \n  int up = countWaysUtil(i-1,j,dp);\n  int left = countWaysUtil(i,j-1,dp);\n  \n  return dp[i][j] = up+left;\n  \n}\n\nint uniquePaths(int m, int n){\n    vector<vector<int> > dp(m,vector<int>(n,-1));\n    return countWaysUtil(m-1,n-1,dp);\n    \n}\n};\n\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Biggest hint:\\n1. Draw the number of possible ways to reach the finish on a grid.\\n2. Look for the pattern\\n3. Put that pattern into code\\n4. Question how one is able to come to these conclusions during coding interviews"
                    },
                    {
                        "username": "sed4ted",
                        "content": "So for this problem i decided to use tgamma from cmath to implement combinatorics formula, but i think i ran into a problem of precition.\\nwhen i use standart tgamma i get some of the answers 1 short, when i use tgammal i get other testcases wrong is this rounding problem for different compilers or smth?"
                    },
                    {
                        "username": "prats02",
                        "content": "how do i optimize this or y isnt this giving me ans\\nclass Solution {\\npublic:\\n    int fact(int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return fact((n+m)-2)/(fact(n-1)*fact(m-1));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1765176,
                "content": [
                    {
                        "username": "bikramleeemboo",
                        "content": "Can please suggest me how to decrease runtime for this following code. thanks in advance.\\n\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return recursive(m, n, 0, 0);\\n    }\\n\\n    private int recursive(int m, int n, int x, int y) {\\n        if(x == m -1 && y == n -1) {\\n            return 1;\\n        }\\n        if(x == m || y == n) return 0;\\n        return recursive(m, n, x + 1, y) + recursive(m, n, x, y + 1);\\n    }\\n}"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "Here, I use tablization in which finding out the unique paths  by making the rows and columns in the dp matrix or the same as the table given i.e,. m,n...Now implement  dp[i][j] = dp[i-1][j] + dp[i][j-1]; by this we get the unique paths "
                    },
                    {
                        "username": "amaan7",
                        "content": "Why i am getting TLE ?? can someone explain !!\\n\\n`class Solution {\\n    public int countPaths(int m ,int n, int i ,int j){\\n        if(i>=m || j >=n){\\n            return 0;\\n        }\\n        if(i==m-1 && j==n-1){\\n            return 1;\\n        }\\n        int downPaths = countPaths(m,n,i+1,j);\\n        int RightPaths = countPaths(m,n,i,j+1);\\n        return downPaths+RightPaths;\\n    }\\n    public int uniquePaths(int m, int n) {\\n        int ans = countPaths(m,n,0,0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First of all, please make sure the code which you are sending is enough for readability, we are programmers, not bloggers."
                    },
                    {
                        "username": "Code2Buzz",
                        "content": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(m,1));\n        for(int i=m-2;i>=0;i--){\n            for(int j=n-2;j>=0;j--){\n                dp[i][j]=dp[i+1][j]+dp[i][j+1];\n            }\n        }\n        return dp[0][0];\n    }\n};\n\nWhat is wrong in above code it's getting AddressSanitizer error ?."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the definition of `dp`. It creates a `std::vector<std::vector<int>>` with dimensions `m x m`.  \\nBut what if `n` is greater than `m`?"
                    },
                    {
                        "username": "user4956si",
                        "content": "I\\'ll try to explain as simply as possible.\\nLet\\'s say, you only have a 1x1 grid. In this case, it doesn\\'t make sense to get to the end so let\\'s assume the number of ways to get to the end would be 1.\\n\\nNow, if you have 2x1 grid, no of of ways of getting to end would be 1. similarly for 3x1 grid, answer would be 1. So, for mx1 grid, total number of ways to get to the end would be 1.\\n\\nSimilarly, total number of ways to get to the end of 1xn grid would also be 1.\\n\\nNow, calculating the number of ways to get to the end is simple. If you are at (m-1,n-2) position number of ways is 1. If you are at (m-2,n-1) number of ways is 1. And mind you, to reach (m-1,n-1) you must first either enter (m-1,n-2) or (m-2,n-1). \\n\\nSo total no of ways of reaching (m-1,n-1) = no of ways of reaching(m-2,n-1) + no of ways of reaching (m-1,n-2).\\n\\nNow we can solve this using dynamic programming technique."
                    },
                    {
                        "username": "ivsvinay2003",
                        "content": "class Solution {\\npublic:\\n    long long int solve(int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(m<0 || n<0){\\n            return 0;\\n        }\\n        if(m==0 && n!=0){\\n            return 1;\\n        }\\n        if(m!=0 && n==0){\\n            return 1;\\n        }\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        return dp[m][n]=1+solve(m-1,n,dp)+solve(m,n-1,dp);\\n    }\\n    long long int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,-1));\\n        long long ans=solve(m-1,n-1,dp);\\n        return (ans+1)/2;\\n    }\\nmay I know what\\'s the problem for this solution?\\n61/63 cases passed!!\\nremaining 2 are left"
                    },
                    {
                        "username": "roundup414",
                        "content": "// Why this code giving TLE \n\n\nclass Solution {\npublic:\n  int solve(int m,int n,vector<vector<int>> dp)\n    {\n        if(m==0 && n==0)\n            return 1;\n        if(m<0 || n<0)\n            return 0;\n        if(dp[m][n]!=-1) return dp[m][n];\n        int  sum=solve(m,n-1,dp)+solve(m-1,n,dp);\n        return dp[m][n]=sum;\n    }\n   int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(n,-1));\n        return solve(m-1,n-1,dp);\n    }\n};\n\n\n\n\n\n\n\n// Why this code doesn't \n\nclass Solution {\npublic:\n\n   int countWaysUtil(int i, int j, vector<vector<int> > &dp) {\n  if(i==0 && j == 0)\n    return 1;\n  if(i<0 || j<0)\n    return 0;\n  if(dp[i][j]!=-1) return dp[i][j];\n    \n  int up = countWaysUtil(i-1,j,dp);\n  int left = countWaysUtil(i,j-1,dp);\n  \n  return dp[i][j] = up+left;\n  \n}\n\nint uniquePaths(int m, int n){\n    vector<vector<int> > dp(m,vector<int>(n,-1));\n    return countWaysUtil(m-1,n-1,dp);\n    \n}\n};\n\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Biggest hint:\\n1. Draw the number of possible ways to reach the finish on a grid.\\n2. Look for the pattern\\n3. Put that pattern into code\\n4. Question how one is able to come to these conclusions during coding interviews"
                    },
                    {
                        "username": "sed4ted",
                        "content": "So for this problem i decided to use tgamma from cmath to implement combinatorics formula, but i think i ran into a problem of precition.\\nwhen i use standart tgamma i get some of the answers 1 short, when i use tgammal i get other testcases wrong is this rounding problem for different compilers or smth?"
                    },
                    {
                        "username": "prats02",
                        "content": "how do i optimize this or y isnt this giving me ans\\nclass Solution {\\npublic:\\n    int fact(int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return fact((n+m)-2)/(fact(n-1)*fact(m-1));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1757440,
                "content": [
                    {
                        "username": "bikramleeemboo",
                        "content": "Can please suggest me how to decrease runtime for this following code. thanks in advance.\\n\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return recursive(m, n, 0, 0);\\n    }\\n\\n    private int recursive(int m, int n, int x, int y) {\\n        if(x == m -1 && y == n -1) {\\n            return 1;\\n        }\\n        if(x == m || y == n) return 0;\\n        return recursive(m, n, x + 1, y) + recursive(m, n, x, y + 1);\\n    }\\n}"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "Here, I use tablization in which finding out the unique paths  by making the rows and columns in the dp matrix or the same as the table given i.e,. m,n...Now implement  dp[i][j] = dp[i-1][j] + dp[i][j-1]; by this we get the unique paths "
                    },
                    {
                        "username": "amaan7",
                        "content": "Why i am getting TLE ?? can someone explain !!\\n\\n`class Solution {\\n    public int countPaths(int m ,int n, int i ,int j){\\n        if(i>=m || j >=n){\\n            return 0;\\n        }\\n        if(i==m-1 && j==n-1){\\n            return 1;\\n        }\\n        int downPaths = countPaths(m,n,i+1,j);\\n        int RightPaths = countPaths(m,n,i,j+1);\\n        return downPaths+RightPaths;\\n    }\\n    public int uniquePaths(int m, int n) {\\n        int ans = countPaths(m,n,0,0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First of all, please make sure the code which you are sending is enough for readability, we are programmers, not bloggers."
                    },
                    {
                        "username": "Code2Buzz",
                        "content": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(m,1));\n        for(int i=m-2;i>=0;i--){\n            for(int j=n-2;j>=0;j--){\n                dp[i][j]=dp[i+1][j]+dp[i][j+1];\n            }\n        }\n        return dp[0][0];\n    }\n};\n\nWhat is wrong in above code it's getting AddressSanitizer error ?."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the definition of `dp`. It creates a `std::vector<std::vector<int>>` with dimensions `m x m`.  \\nBut what if `n` is greater than `m`?"
                    },
                    {
                        "username": "user4956si",
                        "content": "I\\'ll try to explain as simply as possible.\\nLet\\'s say, you only have a 1x1 grid. In this case, it doesn\\'t make sense to get to the end so let\\'s assume the number of ways to get to the end would be 1.\\n\\nNow, if you have 2x1 grid, no of of ways of getting to end would be 1. similarly for 3x1 grid, answer would be 1. So, for mx1 grid, total number of ways to get to the end would be 1.\\n\\nSimilarly, total number of ways to get to the end of 1xn grid would also be 1.\\n\\nNow, calculating the number of ways to get to the end is simple. If you are at (m-1,n-2) position number of ways is 1. If you are at (m-2,n-1) number of ways is 1. And mind you, to reach (m-1,n-1) you must first either enter (m-1,n-2) or (m-2,n-1). \\n\\nSo total no of ways of reaching (m-1,n-1) = no of ways of reaching(m-2,n-1) + no of ways of reaching (m-1,n-2).\\n\\nNow we can solve this using dynamic programming technique."
                    },
                    {
                        "username": "ivsvinay2003",
                        "content": "class Solution {\\npublic:\\n    long long int solve(int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(m<0 || n<0){\\n            return 0;\\n        }\\n        if(m==0 && n!=0){\\n            return 1;\\n        }\\n        if(m!=0 && n==0){\\n            return 1;\\n        }\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        return dp[m][n]=1+solve(m-1,n,dp)+solve(m,n-1,dp);\\n    }\\n    long long int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,-1));\\n        long long ans=solve(m-1,n-1,dp);\\n        return (ans+1)/2;\\n    }\\nmay I know what\\'s the problem for this solution?\\n61/63 cases passed!!\\nremaining 2 are left"
                    },
                    {
                        "username": "roundup414",
                        "content": "// Why this code giving TLE \n\n\nclass Solution {\npublic:\n  int solve(int m,int n,vector<vector<int>> dp)\n    {\n        if(m==0 && n==0)\n            return 1;\n        if(m<0 || n<0)\n            return 0;\n        if(dp[m][n]!=-1) return dp[m][n];\n        int  sum=solve(m,n-1,dp)+solve(m-1,n,dp);\n        return dp[m][n]=sum;\n    }\n   int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(n,-1));\n        return solve(m-1,n-1,dp);\n    }\n};\n\n\n\n\n\n\n\n// Why this code doesn't \n\nclass Solution {\npublic:\n\n   int countWaysUtil(int i, int j, vector<vector<int> > &dp) {\n  if(i==0 && j == 0)\n    return 1;\n  if(i<0 || j<0)\n    return 0;\n  if(dp[i][j]!=-1) return dp[i][j];\n    \n  int up = countWaysUtil(i-1,j,dp);\n  int left = countWaysUtil(i,j-1,dp);\n  \n  return dp[i][j] = up+left;\n  \n}\n\nint uniquePaths(int m, int n){\n    vector<vector<int> > dp(m,vector<int>(n,-1));\n    return countWaysUtil(m-1,n-1,dp);\n    \n}\n};\n\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Biggest hint:\\n1. Draw the number of possible ways to reach the finish on a grid.\\n2. Look for the pattern\\n3. Put that pattern into code\\n4. Question how one is able to come to these conclusions during coding interviews"
                    },
                    {
                        "username": "sed4ted",
                        "content": "So for this problem i decided to use tgamma from cmath to implement combinatorics formula, but i think i ran into a problem of precition.\\nwhen i use standart tgamma i get some of the answers 1 short, when i use tgammal i get other testcases wrong is this rounding problem for different compilers or smth?"
                    },
                    {
                        "username": "prats02",
                        "content": "how do i optimize this or y isnt this giving me ans\\nclass Solution {\\npublic:\\n    int fact(int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return fact((n+m)-2)/(fact(n-1)*fact(m-1));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1749093,
                "content": [
                    {
                        "username": "Exclusion12",
                        "content": "The output would be 1 if m = 1 and n = 1. This is because there is only one way for the robot to reach the bottom-right corner in this case, which is to stay at the starting position (i.e., grid[0][0]). XD"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int dp[101][101];\\n    int uniquePaths(int m, int n) {\\n        // Bottom up approach\\n        if(m == 1 and n == 1) { //m==0 and n==0\\n            return 1; // agar grid sirf ek box ka hain.\\n        }\\n\\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(i == 1 and j == 1) {\\n                    dp[i][j] = 1;\\n                }else {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n]; // dp[m-1][n-1]\\n\\n    }\\n};"
                    },
                    {
                        "username": "Black_Beard",
                        "content": "It was an easy question but is there any possibility of constant time solution??"
                    },
                    {
                        "username": "singhsarthak691",
                        "content": "Hey friends,can you help me I don\\'t know why I got TLE in this code.\\n//In this code I approch to the botom up solution \\nclass Solution {\\n    \\n    private:\\n    int solve(int i,int j,vector<vector<int>>dp){\\n        if(i==0 && j==0){\\n            return 1;\\n        }\\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n      \\n        return dp[i][j]= solve(i-1,j,dp)+solve(i,j-1,dp);;\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        return ans=solve(m-1,n-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "pkl27",
                        "content": "Need help with my code. Why does this not work?\\n\\n\\'\\'\\'\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        paths = 0\\n\\n        def getpaths(m, n, paths):\\n            if (n - 1) >= 1:\\n                return getpaths(m, n - 1, paths)\\n            if (m - 1) >= 1:\\n                return getpaths(m - 1, n, paths)\\n            if (m, n) == (1, 1):\\n                paths += 1\\n        \\n        getpaths(m, n, paths)\\n        return paths\\n\\'\\'\\'\\'"
                    },
                    {
                        "username": "aknopov",
                        "content": "Not proficient in Python, but I think the condition `if (m, n) == (1, 1)` should be replaced by ` if m==1 or n == 1`"
                    },
                    {
                        "username": "aknopov",
                        "content": "uniquePaths(m, n) = uniquePaths(m-1, n) + uniquePaths(m, n - 1)\\nuniquePaths(1, n) = uniquePaths(m, 1) = 1"
                    },
                    {
                        "username": "hemanthtondur789",
                        "content": "class Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int a[m][n];\\n        a[0][0]=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               if (j==0) a[i][j]=1;\\n               else if (i==0) a[i][j]=1;\\n               else {\\n                   a[i][j]=a[i-1][j]+a[i][j-1];\\n               }\\n            }\\n        }\\n    return a[m-1][n-1];\\n    }\\n};"
                    },
                    {
                        "username": "julabgamun",
                        "content": "class Solution {\\npublic:\\n    long double calculateFactorial(int a){\\n        long double prod = 1;\\n        for(long double i=1;i<=a;i++){\\n            prod = prod*i;\\n        }\\n        return prod;\\n    }\\n    int uniquePaths(int m, int n) {\\n        long double num = calculateFactorial(m-1+n-1);\\n        long double denom = calculateFactorial(m-1) * calculateFactorial(n-1);\\n        int val = num/denom;\\n        return val;\\n    }\\n};\\n\\nFew of the test cases are failing, any idea why? \\n\\nOne such example is m = 36, n = 7, OP: 4496388, mine is 4496387"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "Can this be solved without dynamic programming???\\n"
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Is there a reason why recursion is outperforming iterative implementations for this problem?"
                    }
                ]
            },
            {
                "id": 1745861,
                "content": [
                    {
                        "username": "Exclusion12",
                        "content": "The output would be 1 if m = 1 and n = 1. This is because there is only one way for the robot to reach the bottom-right corner in this case, which is to stay at the starting position (i.e., grid[0][0]). XD"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int dp[101][101];\\n    int uniquePaths(int m, int n) {\\n        // Bottom up approach\\n        if(m == 1 and n == 1) { //m==0 and n==0\\n            return 1; // agar grid sirf ek box ka hain.\\n        }\\n\\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(i == 1 and j == 1) {\\n                    dp[i][j] = 1;\\n                }else {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n]; // dp[m-1][n-1]\\n\\n    }\\n};"
                    },
                    {
                        "username": "Black_Beard",
                        "content": "It was an easy question but is there any possibility of constant time solution??"
                    },
                    {
                        "username": "singhsarthak691",
                        "content": "Hey friends,can you help me I don\\'t know why I got TLE in this code.\\n//In this code I approch to the botom up solution \\nclass Solution {\\n    \\n    private:\\n    int solve(int i,int j,vector<vector<int>>dp){\\n        if(i==0 && j==0){\\n            return 1;\\n        }\\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n      \\n        return dp[i][j]= solve(i-1,j,dp)+solve(i,j-1,dp);;\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        return ans=solve(m-1,n-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "pkl27",
                        "content": "Need help with my code. Why does this not work?\\n\\n\\'\\'\\'\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        paths = 0\\n\\n        def getpaths(m, n, paths):\\n            if (n - 1) >= 1:\\n                return getpaths(m, n - 1, paths)\\n            if (m - 1) >= 1:\\n                return getpaths(m - 1, n, paths)\\n            if (m, n) == (1, 1):\\n                paths += 1\\n        \\n        getpaths(m, n, paths)\\n        return paths\\n\\'\\'\\'\\'"
                    },
                    {
                        "username": "aknopov",
                        "content": "Not proficient in Python, but I think the condition `if (m, n) == (1, 1)` should be replaced by ` if m==1 or n == 1`"
                    },
                    {
                        "username": "aknopov",
                        "content": "uniquePaths(m, n) = uniquePaths(m-1, n) + uniquePaths(m, n - 1)\\nuniquePaths(1, n) = uniquePaths(m, 1) = 1"
                    },
                    {
                        "username": "hemanthtondur789",
                        "content": "class Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int a[m][n];\\n        a[0][0]=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               if (j==0) a[i][j]=1;\\n               else if (i==0) a[i][j]=1;\\n               else {\\n                   a[i][j]=a[i-1][j]+a[i][j-1];\\n               }\\n            }\\n        }\\n    return a[m-1][n-1];\\n    }\\n};"
                    },
                    {
                        "username": "julabgamun",
                        "content": "class Solution {\\npublic:\\n    long double calculateFactorial(int a){\\n        long double prod = 1;\\n        for(long double i=1;i<=a;i++){\\n            prod = prod*i;\\n        }\\n        return prod;\\n    }\\n    int uniquePaths(int m, int n) {\\n        long double num = calculateFactorial(m-1+n-1);\\n        long double denom = calculateFactorial(m-1) * calculateFactorial(n-1);\\n        int val = num/denom;\\n        return val;\\n    }\\n};\\n\\nFew of the test cases are failing, any idea why? \\n\\nOne such example is m = 36, n = 7, OP: 4496388, mine is 4496387"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "Can this be solved without dynamic programming???\\n"
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Is there a reason why recursion is outperforming iterative implementations for this problem?"
                    }
                ]
            },
            {
                "id": 1736187,
                "content": [
                    {
                        "username": "Exclusion12",
                        "content": "The output would be 1 if m = 1 and n = 1. This is because there is only one way for the robot to reach the bottom-right corner in this case, which is to stay at the starting position (i.e., grid[0][0]). XD"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int dp[101][101];\\n    int uniquePaths(int m, int n) {\\n        // Bottom up approach\\n        if(m == 1 and n == 1) { //m==0 and n==0\\n            return 1; // agar grid sirf ek box ka hain.\\n        }\\n\\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(i == 1 and j == 1) {\\n                    dp[i][j] = 1;\\n                }else {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n]; // dp[m-1][n-1]\\n\\n    }\\n};"
                    },
                    {
                        "username": "Black_Beard",
                        "content": "It was an easy question but is there any possibility of constant time solution??"
                    },
                    {
                        "username": "singhsarthak691",
                        "content": "Hey friends,can you help me I don\\'t know why I got TLE in this code.\\n//In this code I approch to the botom up solution \\nclass Solution {\\n    \\n    private:\\n    int solve(int i,int j,vector<vector<int>>dp){\\n        if(i==0 && j==0){\\n            return 1;\\n        }\\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n      \\n        return dp[i][j]= solve(i-1,j,dp)+solve(i,j-1,dp);;\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        return ans=solve(m-1,n-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "pkl27",
                        "content": "Need help with my code. Why does this not work?\\n\\n\\'\\'\\'\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        paths = 0\\n\\n        def getpaths(m, n, paths):\\n            if (n - 1) >= 1:\\n                return getpaths(m, n - 1, paths)\\n            if (m - 1) >= 1:\\n                return getpaths(m - 1, n, paths)\\n            if (m, n) == (1, 1):\\n                paths += 1\\n        \\n        getpaths(m, n, paths)\\n        return paths\\n\\'\\'\\'\\'"
                    },
                    {
                        "username": "aknopov",
                        "content": "Not proficient in Python, but I think the condition `if (m, n) == (1, 1)` should be replaced by ` if m==1 or n == 1`"
                    },
                    {
                        "username": "aknopov",
                        "content": "uniquePaths(m, n) = uniquePaths(m-1, n) + uniquePaths(m, n - 1)\\nuniquePaths(1, n) = uniquePaths(m, 1) = 1"
                    },
                    {
                        "username": "hemanthtondur789",
                        "content": "class Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int a[m][n];\\n        a[0][0]=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               if (j==0) a[i][j]=1;\\n               else if (i==0) a[i][j]=1;\\n               else {\\n                   a[i][j]=a[i-1][j]+a[i][j-1];\\n               }\\n            }\\n        }\\n    return a[m-1][n-1];\\n    }\\n};"
                    },
                    {
                        "username": "julabgamun",
                        "content": "class Solution {\\npublic:\\n    long double calculateFactorial(int a){\\n        long double prod = 1;\\n        for(long double i=1;i<=a;i++){\\n            prod = prod*i;\\n        }\\n        return prod;\\n    }\\n    int uniquePaths(int m, int n) {\\n        long double num = calculateFactorial(m-1+n-1);\\n        long double denom = calculateFactorial(m-1) * calculateFactorial(n-1);\\n        int val = num/denom;\\n        return val;\\n    }\\n};\\n\\nFew of the test cases are failing, any idea why? \\n\\nOne such example is m = 36, n = 7, OP: 4496388, mine is 4496387"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "Can this be solved without dynamic programming???\\n"
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Is there a reason why recursion is outperforming iterative implementations for this problem?"
                    }
                ]
            },
            {
                "id": 1729809,
                "content": [
                    {
                        "username": "Exclusion12",
                        "content": "The output would be 1 if m = 1 and n = 1. This is because there is only one way for the robot to reach the bottom-right corner in this case, which is to stay at the starting position (i.e., grid[0][0]). XD"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int dp[101][101];\\n    int uniquePaths(int m, int n) {\\n        // Bottom up approach\\n        if(m == 1 and n == 1) { //m==0 and n==0\\n            return 1; // agar grid sirf ek box ka hain.\\n        }\\n\\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(i == 1 and j == 1) {\\n                    dp[i][j] = 1;\\n                }else {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n]; // dp[m-1][n-1]\\n\\n    }\\n};"
                    },
                    {
                        "username": "Black_Beard",
                        "content": "It was an easy question but is there any possibility of constant time solution??"
                    },
                    {
                        "username": "singhsarthak691",
                        "content": "Hey friends,can you help me I don\\'t know why I got TLE in this code.\\n//In this code I approch to the botom up solution \\nclass Solution {\\n    \\n    private:\\n    int solve(int i,int j,vector<vector<int>>dp){\\n        if(i==0 && j==0){\\n            return 1;\\n        }\\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n      \\n        return dp[i][j]= solve(i-1,j,dp)+solve(i,j-1,dp);;\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        return ans=solve(m-1,n-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "pkl27",
                        "content": "Need help with my code. Why does this not work?\\n\\n\\'\\'\\'\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        paths = 0\\n\\n        def getpaths(m, n, paths):\\n            if (n - 1) >= 1:\\n                return getpaths(m, n - 1, paths)\\n            if (m - 1) >= 1:\\n                return getpaths(m - 1, n, paths)\\n            if (m, n) == (1, 1):\\n                paths += 1\\n        \\n        getpaths(m, n, paths)\\n        return paths\\n\\'\\'\\'\\'"
                    },
                    {
                        "username": "aknopov",
                        "content": "Not proficient in Python, but I think the condition `if (m, n) == (1, 1)` should be replaced by ` if m==1 or n == 1`"
                    },
                    {
                        "username": "aknopov",
                        "content": "uniquePaths(m, n) = uniquePaths(m-1, n) + uniquePaths(m, n - 1)\\nuniquePaths(1, n) = uniquePaths(m, 1) = 1"
                    },
                    {
                        "username": "hemanthtondur789",
                        "content": "class Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int a[m][n];\\n        a[0][0]=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               if (j==0) a[i][j]=1;\\n               else if (i==0) a[i][j]=1;\\n               else {\\n                   a[i][j]=a[i-1][j]+a[i][j-1];\\n               }\\n            }\\n        }\\n    return a[m-1][n-1];\\n    }\\n};"
                    },
                    {
                        "username": "julabgamun",
                        "content": "class Solution {\\npublic:\\n    long double calculateFactorial(int a){\\n        long double prod = 1;\\n        for(long double i=1;i<=a;i++){\\n            prod = prod*i;\\n        }\\n        return prod;\\n    }\\n    int uniquePaths(int m, int n) {\\n        long double num = calculateFactorial(m-1+n-1);\\n        long double denom = calculateFactorial(m-1) * calculateFactorial(n-1);\\n        int val = num/denom;\\n        return val;\\n    }\\n};\\n\\nFew of the test cases are failing, any idea why? \\n\\nOne such example is m = 36, n = 7, OP: 4496388, mine is 4496387"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "Can this be solved without dynamic programming???\\n"
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Is there a reason why recursion is outperforming iterative implementations for this problem?"
                    }
                ]
            },
            {
                "id": 1725507,
                "content": [
                    {
                        "username": "Exclusion12",
                        "content": "The output would be 1 if m = 1 and n = 1. This is because there is only one way for the robot to reach the bottom-right corner in this case, which is to stay at the starting position (i.e., grid[0][0]). XD"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int dp[101][101];\\n    int uniquePaths(int m, int n) {\\n        // Bottom up approach\\n        if(m == 1 and n == 1) { //m==0 and n==0\\n            return 1; // agar grid sirf ek box ka hain.\\n        }\\n\\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(i == 1 and j == 1) {\\n                    dp[i][j] = 1;\\n                }else {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n]; // dp[m-1][n-1]\\n\\n    }\\n};"
                    },
                    {
                        "username": "Black_Beard",
                        "content": "It was an easy question but is there any possibility of constant time solution??"
                    },
                    {
                        "username": "singhsarthak691",
                        "content": "Hey friends,can you help me I don\\'t know why I got TLE in this code.\\n//In this code I approch to the botom up solution \\nclass Solution {\\n    \\n    private:\\n    int solve(int i,int j,vector<vector<int>>dp){\\n        if(i==0 && j==0){\\n            return 1;\\n        }\\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n      \\n        return dp[i][j]= solve(i-1,j,dp)+solve(i,j-1,dp);;\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        return ans=solve(m-1,n-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "pkl27",
                        "content": "Need help with my code. Why does this not work?\\n\\n\\'\\'\\'\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        paths = 0\\n\\n        def getpaths(m, n, paths):\\n            if (n - 1) >= 1:\\n                return getpaths(m, n - 1, paths)\\n            if (m - 1) >= 1:\\n                return getpaths(m - 1, n, paths)\\n            if (m, n) == (1, 1):\\n                paths += 1\\n        \\n        getpaths(m, n, paths)\\n        return paths\\n\\'\\'\\'\\'"
                    },
                    {
                        "username": "aknopov",
                        "content": "Not proficient in Python, but I think the condition `if (m, n) == (1, 1)` should be replaced by ` if m==1 or n == 1`"
                    },
                    {
                        "username": "aknopov",
                        "content": "uniquePaths(m, n) = uniquePaths(m-1, n) + uniquePaths(m, n - 1)\\nuniquePaths(1, n) = uniquePaths(m, 1) = 1"
                    },
                    {
                        "username": "hemanthtondur789",
                        "content": "class Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int a[m][n];\\n        a[0][0]=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               if (j==0) a[i][j]=1;\\n               else if (i==0) a[i][j]=1;\\n               else {\\n                   a[i][j]=a[i-1][j]+a[i][j-1];\\n               }\\n            }\\n        }\\n    return a[m-1][n-1];\\n    }\\n};"
                    },
                    {
                        "username": "julabgamun",
                        "content": "class Solution {\\npublic:\\n    long double calculateFactorial(int a){\\n        long double prod = 1;\\n        for(long double i=1;i<=a;i++){\\n            prod = prod*i;\\n        }\\n        return prod;\\n    }\\n    int uniquePaths(int m, int n) {\\n        long double num = calculateFactorial(m-1+n-1);\\n        long double denom = calculateFactorial(m-1) * calculateFactorial(n-1);\\n        int val = num/denom;\\n        return val;\\n    }\\n};\\n\\nFew of the test cases are failing, any idea why? \\n\\nOne such example is m = 36, n = 7, OP: 4496388, mine is 4496387"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "Can this be solved without dynamic programming???\\n"
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Is there a reason why recursion is outperforming iterative implementations for this problem?"
                    }
                ]
            },
            {
                "id": 1724014,
                "content": [
                    {
                        "username": "Exclusion12",
                        "content": "The output would be 1 if m = 1 and n = 1. This is because there is only one way for the robot to reach the bottom-right corner in this case, which is to stay at the starting position (i.e., grid[0][0]). XD"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int dp[101][101];\\n    int uniquePaths(int m, int n) {\\n        // Bottom up approach\\n        if(m == 1 and n == 1) { //m==0 and n==0\\n            return 1; // agar grid sirf ek box ka hain.\\n        }\\n\\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(i == 1 and j == 1) {\\n                    dp[i][j] = 1;\\n                }else {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n]; // dp[m-1][n-1]\\n\\n    }\\n};"
                    },
                    {
                        "username": "Black_Beard",
                        "content": "It was an easy question but is there any possibility of constant time solution??"
                    },
                    {
                        "username": "singhsarthak691",
                        "content": "Hey friends,can you help me I don\\'t know why I got TLE in this code.\\n//In this code I approch to the botom up solution \\nclass Solution {\\n    \\n    private:\\n    int solve(int i,int j,vector<vector<int>>dp){\\n        if(i==0 && j==0){\\n            return 1;\\n        }\\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n      \\n        return dp[i][j]= solve(i-1,j,dp)+solve(i,j-1,dp);;\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        return ans=solve(m-1,n-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "pkl27",
                        "content": "Need help with my code. Why does this not work?\\n\\n\\'\\'\\'\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        paths = 0\\n\\n        def getpaths(m, n, paths):\\n            if (n - 1) >= 1:\\n                return getpaths(m, n - 1, paths)\\n            if (m - 1) >= 1:\\n                return getpaths(m - 1, n, paths)\\n            if (m, n) == (1, 1):\\n                paths += 1\\n        \\n        getpaths(m, n, paths)\\n        return paths\\n\\'\\'\\'\\'"
                    },
                    {
                        "username": "aknopov",
                        "content": "Not proficient in Python, but I think the condition `if (m, n) == (1, 1)` should be replaced by ` if m==1 or n == 1`"
                    },
                    {
                        "username": "aknopov",
                        "content": "uniquePaths(m, n) = uniquePaths(m-1, n) + uniquePaths(m, n - 1)\\nuniquePaths(1, n) = uniquePaths(m, 1) = 1"
                    },
                    {
                        "username": "hemanthtondur789",
                        "content": "class Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int a[m][n];\\n        a[0][0]=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               if (j==0) a[i][j]=1;\\n               else if (i==0) a[i][j]=1;\\n               else {\\n                   a[i][j]=a[i-1][j]+a[i][j-1];\\n               }\\n            }\\n        }\\n    return a[m-1][n-1];\\n    }\\n};"
                    },
                    {
                        "username": "julabgamun",
                        "content": "class Solution {\\npublic:\\n    long double calculateFactorial(int a){\\n        long double prod = 1;\\n        for(long double i=1;i<=a;i++){\\n            prod = prod*i;\\n        }\\n        return prod;\\n    }\\n    int uniquePaths(int m, int n) {\\n        long double num = calculateFactorial(m-1+n-1);\\n        long double denom = calculateFactorial(m-1) * calculateFactorial(n-1);\\n        int val = num/denom;\\n        return val;\\n    }\\n};\\n\\nFew of the test cases are failing, any idea why? \\n\\nOne such example is m = 36, n = 7, OP: 4496388, mine is 4496387"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "Can this be solved without dynamic programming???\\n"
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Is there a reason why recursion is outperforming iterative implementations for this problem?"
                    }
                ]
            },
            {
                "id": 1721253,
                "content": [
                    {
                        "username": "Exclusion12",
                        "content": "The output would be 1 if m = 1 and n = 1. This is because there is only one way for the robot to reach the bottom-right corner in this case, which is to stay at the starting position (i.e., grid[0][0]). XD"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int dp[101][101];\\n    int uniquePaths(int m, int n) {\\n        // Bottom up approach\\n        if(m == 1 and n == 1) { //m==0 and n==0\\n            return 1; // agar grid sirf ek box ka hain.\\n        }\\n\\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(i == 1 and j == 1) {\\n                    dp[i][j] = 1;\\n                }else {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n]; // dp[m-1][n-1]\\n\\n    }\\n};"
                    },
                    {
                        "username": "Black_Beard",
                        "content": "It was an easy question but is there any possibility of constant time solution??"
                    },
                    {
                        "username": "singhsarthak691",
                        "content": "Hey friends,can you help me I don\\'t know why I got TLE in this code.\\n//In this code I approch to the botom up solution \\nclass Solution {\\n    \\n    private:\\n    int solve(int i,int j,vector<vector<int>>dp){\\n        if(i==0 && j==0){\\n            return 1;\\n        }\\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n      \\n        return dp[i][j]= solve(i-1,j,dp)+solve(i,j-1,dp);;\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        return ans=solve(m-1,n-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "pkl27",
                        "content": "Need help with my code. Why does this not work?\\n\\n\\'\\'\\'\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        paths = 0\\n\\n        def getpaths(m, n, paths):\\n            if (n - 1) >= 1:\\n                return getpaths(m, n - 1, paths)\\n            if (m - 1) >= 1:\\n                return getpaths(m - 1, n, paths)\\n            if (m, n) == (1, 1):\\n                paths += 1\\n        \\n        getpaths(m, n, paths)\\n        return paths\\n\\'\\'\\'\\'"
                    },
                    {
                        "username": "aknopov",
                        "content": "Not proficient in Python, but I think the condition `if (m, n) == (1, 1)` should be replaced by ` if m==1 or n == 1`"
                    },
                    {
                        "username": "aknopov",
                        "content": "uniquePaths(m, n) = uniquePaths(m-1, n) + uniquePaths(m, n - 1)\\nuniquePaths(1, n) = uniquePaths(m, 1) = 1"
                    },
                    {
                        "username": "hemanthtondur789",
                        "content": "class Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int a[m][n];\\n        a[0][0]=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               if (j==0) a[i][j]=1;\\n               else if (i==0) a[i][j]=1;\\n               else {\\n                   a[i][j]=a[i-1][j]+a[i][j-1];\\n               }\\n            }\\n        }\\n    return a[m-1][n-1];\\n    }\\n};"
                    },
                    {
                        "username": "julabgamun",
                        "content": "class Solution {\\npublic:\\n    long double calculateFactorial(int a){\\n        long double prod = 1;\\n        for(long double i=1;i<=a;i++){\\n            prod = prod*i;\\n        }\\n        return prod;\\n    }\\n    int uniquePaths(int m, int n) {\\n        long double num = calculateFactorial(m-1+n-1);\\n        long double denom = calculateFactorial(m-1) * calculateFactorial(n-1);\\n        int val = num/denom;\\n        return val;\\n    }\\n};\\n\\nFew of the test cases are failing, any idea why? \\n\\nOne such example is m = 36, n = 7, OP: 4496388, mine is 4496387"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "Can this be solved without dynamic programming???\\n"
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Is there a reason why recursion is outperforming iterative implementations for this problem?"
                    }
                ]
            },
            {
                "id": 1707511,
                "content": [
                    {
                        "username": "Exclusion12",
                        "content": "The output would be 1 if m = 1 and n = 1. This is because there is only one way for the robot to reach the bottom-right corner in this case, which is to stay at the starting position (i.e., grid[0][0]). XD"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int dp[101][101];\\n    int uniquePaths(int m, int n) {\\n        // Bottom up approach\\n        if(m == 1 and n == 1) { //m==0 and n==0\\n            return 1; // agar grid sirf ek box ka hain.\\n        }\\n\\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(i == 1 and j == 1) {\\n                    dp[i][j] = 1;\\n                }else {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n]; // dp[m-1][n-1]\\n\\n    }\\n};"
                    },
                    {
                        "username": "Black_Beard",
                        "content": "It was an easy question but is there any possibility of constant time solution??"
                    },
                    {
                        "username": "singhsarthak691",
                        "content": "Hey friends,can you help me I don\\'t know why I got TLE in this code.\\n//In this code I approch to the botom up solution \\nclass Solution {\\n    \\n    private:\\n    int solve(int i,int j,vector<vector<int>>dp){\\n        if(i==0 && j==0){\\n            return 1;\\n        }\\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n      \\n        return dp[i][j]= solve(i-1,j,dp)+solve(i,j-1,dp);;\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        return ans=solve(m-1,n-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "pkl27",
                        "content": "Need help with my code. Why does this not work?\\n\\n\\'\\'\\'\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        paths = 0\\n\\n        def getpaths(m, n, paths):\\n            if (n - 1) >= 1:\\n                return getpaths(m, n - 1, paths)\\n            if (m - 1) >= 1:\\n                return getpaths(m - 1, n, paths)\\n            if (m, n) == (1, 1):\\n                paths += 1\\n        \\n        getpaths(m, n, paths)\\n        return paths\\n\\'\\'\\'\\'"
                    },
                    {
                        "username": "aknopov",
                        "content": "Not proficient in Python, but I think the condition `if (m, n) == (1, 1)` should be replaced by ` if m==1 or n == 1`"
                    },
                    {
                        "username": "aknopov",
                        "content": "uniquePaths(m, n) = uniquePaths(m-1, n) + uniquePaths(m, n - 1)\\nuniquePaths(1, n) = uniquePaths(m, 1) = 1"
                    },
                    {
                        "username": "hemanthtondur789",
                        "content": "class Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int a[m][n];\\n        a[0][0]=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               if (j==0) a[i][j]=1;\\n               else if (i==0) a[i][j]=1;\\n               else {\\n                   a[i][j]=a[i-1][j]+a[i][j-1];\\n               }\\n            }\\n        }\\n    return a[m-1][n-1];\\n    }\\n};"
                    },
                    {
                        "username": "julabgamun",
                        "content": "class Solution {\\npublic:\\n    long double calculateFactorial(int a){\\n        long double prod = 1;\\n        for(long double i=1;i<=a;i++){\\n            prod = prod*i;\\n        }\\n        return prod;\\n    }\\n    int uniquePaths(int m, int n) {\\n        long double num = calculateFactorial(m-1+n-1);\\n        long double denom = calculateFactorial(m-1) * calculateFactorial(n-1);\\n        int val = num/denom;\\n        return val;\\n    }\\n};\\n\\nFew of the test cases are failing, any idea why? \\n\\nOne such example is m = 36, n = 7, OP: 4496388, mine is 4496387"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "Can this be solved without dynamic programming???\\n"
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Is there a reason why recursion is outperforming iterative implementations for this problem?"
                    }
                ]
            },
            {
                "id": 1697031,
                "content": [
                    {
                        "username": "Exclusion12",
                        "content": "The output would be 1 if m = 1 and n = 1. This is because there is only one way for the robot to reach the bottom-right corner in this case, which is to stay at the starting position (i.e., grid[0][0]). XD"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int dp[101][101];\\n    int uniquePaths(int m, int n) {\\n        // Bottom up approach\\n        if(m == 1 and n == 1) { //m==0 and n==0\\n            return 1; // agar grid sirf ek box ka hain.\\n        }\\n\\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(i == 1 and j == 1) {\\n                    dp[i][j] = 1;\\n                }else {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n]; // dp[m-1][n-1]\\n\\n    }\\n};"
                    },
                    {
                        "username": "Black_Beard",
                        "content": "It was an easy question but is there any possibility of constant time solution??"
                    },
                    {
                        "username": "singhsarthak691",
                        "content": "Hey friends,can you help me I don\\'t know why I got TLE in this code.\\n//In this code I approch to the botom up solution \\nclass Solution {\\n    \\n    private:\\n    int solve(int i,int j,vector<vector<int>>dp){\\n        if(i==0 && j==0){\\n            return 1;\\n        }\\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n      \\n        return dp[i][j]= solve(i-1,j,dp)+solve(i,j-1,dp);;\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        return ans=solve(m-1,n-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "pkl27",
                        "content": "Need help with my code. Why does this not work?\\n\\n\\'\\'\\'\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        paths = 0\\n\\n        def getpaths(m, n, paths):\\n            if (n - 1) >= 1:\\n                return getpaths(m, n - 1, paths)\\n            if (m - 1) >= 1:\\n                return getpaths(m - 1, n, paths)\\n            if (m, n) == (1, 1):\\n                paths += 1\\n        \\n        getpaths(m, n, paths)\\n        return paths\\n\\'\\'\\'\\'"
                    },
                    {
                        "username": "aknopov",
                        "content": "Not proficient in Python, but I think the condition `if (m, n) == (1, 1)` should be replaced by ` if m==1 or n == 1`"
                    },
                    {
                        "username": "aknopov",
                        "content": "uniquePaths(m, n) = uniquePaths(m-1, n) + uniquePaths(m, n - 1)\\nuniquePaths(1, n) = uniquePaths(m, 1) = 1"
                    },
                    {
                        "username": "hemanthtondur789",
                        "content": "class Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int a[m][n];\\n        a[0][0]=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               if (j==0) a[i][j]=1;\\n               else if (i==0) a[i][j]=1;\\n               else {\\n                   a[i][j]=a[i-1][j]+a[i][j-1];\\n               }\\n            }\\n        }\\n    return a[m-1][n-1];\\n    }\\n};"
                    },
                    {
                        "username": "julabgamun",
                        "content": "class Solution {\\npublic:\\n    long double calculateFactorial(int a){\\n        long double prod = 1;\\n        for(long double i=1;i<=a;i++){\\n            prod = prod*i;\\n        }\\n        return prod;\\n    }\\n    int uniquePaths(int m, int n) {\\n        long double num = calculateFactorial(m-1+n-1);\\n        long double denom = calculateFactorial(m-1) * calculateFactorial(n-1);\\n        int val = num/denom;\\n        return val;\\n    }\\n};\\n\\nFew of the test cases are failing, any idea why? \\n\\nOne such example is m = 36, n = 7, OP: 4496388, mine is 4496387"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "Can this be solved without dynamic programming???\\n"
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Is there a reason why recursion is outperforming iterative implementations for this problem?"
                    }
                ]
            },
            {
                "id": 1649073,
                "content": [
                    {
                        "username": "Exclusion12",
                        "content": "The output would be 1 if m = 1 and n = 1. This is because there is only one way for the robot to reach the bottom-right corner in this case, which is to stay at the starting position (i.e., grid[0][0]). XD"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int dp[101][101];\\n    int uniquePaths(int m, int n) {\\n        // Bottom up approach\\n        if(m == 1 and n == 1) { //m==0 and n==0\\n            return 1; // agar grid sirf ek box ka hain.\\n        }\\n\\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(i == 1 and j == 1) {\\n                    dp[i][j] = 1;\\n                }else {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n]; // dp[m-1][n-1]\\n\\n    }\\n};"
                    },
                    {
                        "username": "Black_Beard",
                        "content": "It was an easy question but is there any possibility of constant time solution??"
                    },
                    {
                        "username": "singhsarthak691",
                        "content": "Hey friends,can you help me I don\\'t know why I got TLE in this code.\\n//In this code I approch to the botom up solution \\nclass Solution {\\n    \\n    private:\\n    int solve(int i,int j,vector<vector<int>>dp){\\n        if(i==0 && j==0){\\n            return 1;\\n        }\\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n      \\n        return dp[i][j]= solve(i-1,j,dp)+solve(i,j-1,dp);;\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        return ans=solve(m-1,n-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "pkl27",
                        "content": "Need help with my code. Why does this not work?\\n\\n\\'\\'\\'\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        paths = 0\\n\\n        def getpaths(m, n, paths):\\n            if (n - 1) >= 1:\\n                return getpaths(m, n - 1, paths)\\n            if (m - 1) >= 1:\\n                return getpaths(m - 1, n, paths)\\n            if (m, n) == (1, 1):\\n                paths += 1\\n        \\n        getpaths(m, n, paths)\\n        return paths\\n\\'\\'\\'\\'"
                    },
                    {
                        "username": "aknopov",
                        "content": "Not proficient in Python, but I think the condition `if (m, n) == (1, 1)` should be replaced by ` if m==1 or n == 1`"
                    },
                    {
                        "username": "aknopov",
                        "content": "uniquePaths(m, n) = uniquePaths(m-1, n) + uniquePaths(m, n - 1)\\nuniquePaths(1, n) = uniquePaths(m, 1) = 1"
                    },
                    {
                        "username": "hemanthtondur789",
                        "content": "class Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int a[m][n];\\n        a[0][0]=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               if (j==0) a[i][j]=1;\\n               else if (i==0) a[i][j]=1;\\n               else {\\n                   a[i][j]=a[i-1][j]+a[i][j-1];\\n               }\\n            }\\n        }\\n    return a[m-1][n-1];\\n    }\\n};"
                    },
                    {
                        "username": "julabgamun",
                        "content": "class Solution {\\npublic:\\n    long double calculateFactorial(int a){\\n        long double prod = 1;\\n        for(long double i=1;i<=a;i++){\\n            prod = prod*i;\\n        }\\n        return prod;\\n    }\\n    int uniquePaths(int m, int n) {\\n        long double num = calculateFactorial(m-1+n-1);\\n        long double denom = calculateFactorial(m-1) * calculateFactorial(n-1);\\n        int val = num/denom;\\n        return val;\\n    }\\n};\\n\\nFew of the test cases are failing, any idea why? \\n\\nOne such example is m = 36, n = 7, OP: 4496388, mine is 4496387"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "Can this be solved without dynamic programming???\\n"
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Is there a reason why recursion is outperforming iterative implementations for this problem?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Peak Element",
        "question_content": "<p>A peak element is an element that is strictly greater than its neighbors.</p>\n\n<p>Given a <strong>0-indexed</strong> integer array <code>nums</code>, find a peak element, and return its index. If the array contains multiple peaks, return the index to <strong>any of the peaks</strong>.</p>\n\n<p>You may imagine that <code>nums[-1] = nums[n] = -&infin;</code>. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.</p>\n\n<p>You must write an algorithm that runs in <code>O(log n)</code> time.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> 3 is a peak element and your function should return the index number 2.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,1,3,5,6,4]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>nums[i] != nums[i + 1]</code> for all valid <code>i</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1290642,
                "title": "intuition-behind-conditions-complete-explanation-diagram-binary-search",
                "content": "Given an array, we need to find the peak element. \\nAs, the subportions of the array are increasing/decreasing ( only then we would be able to find peak ), there are subportions of array which are sorted, so we could use binary search to get this problem done. But exactly how ? \\n\\nThis is an interesting part.\\n\\nFor a mid element, there could be three possible cases : \\n![image](https://assets.leetcode.com/users/images/d2fdc688-542e-434c-8969-f151b2286313_1624387000.3221495.png)\\n\\n\\nCase 1 : mid lies on the right of our result peak ( Observation : Our peak element search space is leftside )\\nCase 2 : mid is equal to the peak element ( Observation : mid element is greater than its neighbors )\\nCase 3 : mid lies on the left. ( Observation : Our peak element search space is rightside )\\n\\nso, the code becomes \\n\\n```\\nint start = 0;\\nint end = n-1;\\n\\nwhile(start <= end) {\\n\\tint mid = start + (end - start)/2;\\n\\tif(nums[mid] > nums[mid-1] && nums[mid] > nums[mid+1]) return mid;   // if mid == peak ( case 2 )\\n\\telse if(nums[mid] < nums[mid-1]) end = mid - 1; // downward slope and search space left side ( case 1)\\n\\telse if(nums[mid] < nums[mid+1]) start = mid + 1; // upward slope and search space right side ( case 3 )\\n}\\n```\\n\\nSome base cases : \\n\\nThe array could be strictly increasing or strictly decreasing and as we have to return any of the possible peaks, so we could add a condition to check whether the 1st element/last element could be the peak ). This point is also supported by the fact that, we are looking for mid-1/ mid+1 ( and these indices are compremised for 0th index / n-1 th index respectively.\\n\\nSo, our complete code becomes \\n\\n```\\n\\n\\t\\tif(nums.length == 1) return 0; // single element\\n        \\n        int n = nums.length;\\n        \\n\\t\\t// check if 0th/n-1th index is the peak element\\n        if(nums[0] > nums[1]) return 0;\\n        if(nums[n-1] > nums[n-2]) return n-1;\\n\\t\\t\\n\\t\\t// search in the remaining array\\n        int start = 1;\\n        int end = n-2;\\n        \\n        while(start <= end) {\\n            int mid = start + (end - start)/2;\\n            if(nums[mid] > nums[mid-1] && nums[mid] > nums[mid+1]) return mid;\\n            else if(nums[mid] < nums[mid-1]) end = mid - 1;\\n            else if(nums[mid] < nums[mid+1]) start = mid + 1;\\n        }\\n        return -1; // dummy return statement\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nint start = 0;\\nint end = n-1;\\n\\nwhile(start <= end) {\\n\\tint mid = start + (end - start)/2;\\n\\tif(nums[mid] > nums[mid-1] && nums[mid] > nums[mid+1]) return mid;   // if mid == peak ( case 2 )\\n\\telse if(nums[mid] < nums[mid-1]) end = mid - 1; // downward slope and search space left side ( case 1)\\n\\telse if(nums[mid] < nums[mid+1]) start = mid + 1; // upward slope and search space right side ( case 3 )\\n}\\n```\n```\\n\\n\\t\\tif(nums.length == 1) return 0; // single element\\n        \\n        int n = nums.length;\\n        \\n\\t\\t// check if 0th/n-1th index is the peak element\\n        if(nums[0] > nums[1]) return 0;\\n        if(nums[n-1] > nums[n-2]) return n-1;\\n\\t\\t\\n\\t\\t// search in the remaining array\\n        int start = 1;\\n        int end = n-2;\\n        \\n        while(start <= end) {\\n            int mid = start + (end - start)/2;\\n            if(nums[mid] > nums[mid-1] && nums[mid] > nums[mid+1]) return mid;\\n            else if(nums[mid] < nums[mid-1]) end = mid - 1;\\n            else if(nums[mid] < nums[mid+1]) start = mid + 1;\\n        }\\n        return -1; // dummy return statement\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 50232,
                "title": "find-the-maximum-by-binary-search-recursion-and-iteration",
                "content": "Consider that each local maximum is one valid peak.\\nMy solution is to find one local maximum with binary search.\\nBinary search satisfies the O(logn) computational complexity.\\n\\nBinary Search: recursion\\n\\n    class Solution {\\n    public:\\n\\n    int findPeakElement(const vector<int> &num) {\\n        return Helper(num, 0, num.size()-1);\\n    }\\n    int Helper(const vector<int> &num, int low, int high)\\n    {\\n        if(low == high)\\n            return low;\\n        else\\n        {\\n            int mid1 = (low+high)/2;\\n            int mid2 = mid1+1;\\n            if(num[mid1] > num[mid2])\\n                return Helper(num, low, mid1);\\n            else\\n                return Helper(num, mid2, high);\\n        }\\n    }\\n    };\\n\\nBinary Search: iteration\\n\\n    class Solution {\\n    public:\\n        int findPeakElement(const vector<int> &num) \\n        {\\n            int low = 0;\\n            int high = num.size()-1;\\n            \\n            while(low < high)\\n            {\\n                int mid1 = (low+high)/2;\\n                int mid2 = mid1+1;\\n                if(num[mid1] < num[mid2])\\n                    low = mid2;\\n                else\\n                    high = mid1;\\n            }\\n            return low;\\n        }\\n    };\\n\\nSequential Search:\\n\\n    class Solution {\\n    public:\\n        int findPeakElement(const vector<int> &num) {\\n            for(int i = 1; i < num.size(); i ++)\\n            {\\n                if(num[i] < num[i-1])\\n                {// <\\n                    return i-1;\\n                }\\n            }\\n            return num.size()-1;\\n        }\\n    };",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n\\n    int findPeakElement(const vector<int> &num) {\\n        return Helper(num, 0, num.size()-1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 50239,
                "title": "java-solution-and-explanation-using-invariants",
                "content": "I find it useful to reason about binary search problems using invariants. While there are many solutions posted here, neither of them provide (in my opinion) a good explanation about why they work. I just spent some time thinking about this and I thought it might be a good idea to share my thoughts.\\n\\nAssume we initialize left = 0, right = nums.length - 1. The invariant I'm using is the following:\\n\\n**nums[left - 1] < nums[left] && nums[right] > nums[right + 1]**\\n\\nThat basically means that in the current interval we're looking, [left, right] the function started increasing to left and will eventually decrease at right. The behavior between [left, right] falls into the following 3 categories:\\n\\n1) nums[left] > nums[left + 1]. From the invariant, nums[left - 1] < nums[left] => left is a peak\\n\\n2) The function is increasing from left to right i.e. nums[left] < nums[left + 1] < .. < nums[right - 1] < nums[right]. From the invariant, nums[right] > nums[right + 1] => right is a peak\\n\\n3) the function increases for a while and then decreases (in which case the point just before it starts decreasing is a peak) e.g. 2 5 6 3 (6 is the point in question)\\n\\n\\nAs shown, if the invariant above holds, there is at least a peak between [left, right]. Now we need to show 2 things:\\n\\nI) the invariant is initially true. Since left = 0 and right = nums.length - 1 initially and we know that nums[-1] = nums[nums.length] = -oo, this is obviously true\\n\\nII) At every step of the loop the invariant gets reestablished. If we consider the code in the loop, we have mid = (left + right) / 2 and the following 2 cases:\\n\\na) nums[mid] < nums[mid + 1]. It turns out that the interval [mid + 1, right] respects the invariant (nums[mid] < nums[mid + 1] -> part of the cond + nums[right] > nums[right + 1] -> part of the invariant in the previous loop iteration)\\n\\nb) nums[mid] > nums[mid + 1]. Similarly, [left, mid] respects the invariant (nums[left - 1] < nums[left] -> part of the invariant in the previous loop iteration and nums[mid] > nums[mid + 1] -> part of the cond)\\n\\nAs a result, the invariant gets reestablished and it will also hold when we exit the loop. In that case we have an interval of length 2 i.e. right = left + 1. If nums[left] > nums[right], using the invariant (nums[left - 1] < nums[left]), we get that left is a peak. Otherwise right is the peak (nums[left] < nums[right] and nums[right] < nums[right + 1] from the invariant).\\n\\n    public int findPeakElement(int[] nums) {\\n        int N = nums.length;\\n        if (N == 1) {\\n            return 0;\\n        }\\n       \\n        int left = 0, right = N - 1;\\n        while (right - left > 1) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] < nums[mid + 1]) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        \\n        return (left == N - 1 || nums[left] > nums[left + 1]) ? left : right;\\n    }\\n\\n\\nI hope this makes things clear despite the long explanation.",
                "solutionTags": [],
                "code": "I find it useful to reason about binary search problems using invariants. While there are many solutions posted here, neither of them provide (in my opinion) a good explanation about why they work. I just spent some time thinking about this and I thought it might be a good idea to share my thoughts.\\n\\nAssume we initialize left = 0, right = nums.length - 1. The invariant I'm using is the following:\\n\\n**nums[left - 1] < nums[left] && nums[right] > nums[right + 1]**\\n\\nThat basically means that in the current interval we're looking, [left, right] the function started increasing to left and will eventually decrease at right. The behavior between [left, right] falls into the following 3 categories:\\n\\n1) nums[left] > nums[left + 1]. From the invariant, nums[left - 1] < nums[left] => left is a peak\\n\\n2) The function is increasing from left to right i.e. nums[left] < nums[left + 1] < .. < nums[right - 1] < nums[right]. From the invariant, nums[right] > nums[right + 1] => right is a peak\\n\\n3) the function increases for a while and then decreases (in which case the point just before it starts decreasing is a peak) e.g. 2 5 6 3 (6 is the point in question)\\n\\n\\nAs shown, if the invariant above holds, there is at least a peak between [left, right]. Now we need to show 2 things:\\n\\nI) the invariant is initially true. Since left = 0 and right = nums.length - 1 initially and we know that nums[-1] = nums[nums.length] = -oo, this is obviously true\\n\\nII) At every step of the loop the invariant gets reestablished. If we consider the code in the loop, we have mid = (left + right) / 2 and the following 2 cases:\\n\\na) nums[mid] < nums[mid + 1]. It turns out that the interval [mid + 1, right] respects the invariant (nums[mid] < nums[mid + 1] -> part of the cond + nums[right] > nums[right + 1] -> part of the invariant in the previous loop iteration)\\n\\nb) nums[mid] > nums[mid + 1]. Similarly, [left, mid] respects the invariant (nums[left - 1] < nums[left] -> part of the invariant in the previous loop iteration and nums[mid] > nums[mid + 1] -> part of the cond)\\n\\nAs a result, the invariant gets reestablished and it will also hold when we exit the loop. In that case we have an interval of length 2 i.e. right = left + 1. If nums[left] > nums[right], using the invariant (nums[left - 1] < nums[left]), we get that left is a peak. Otherwise right is the peak (nums[left] < nums[right] and nums[right] < nums[right + 1] from the invariant).\\n\\n    public int findPeakElement(int[] nums) {\\n        int N = nums.length;\\n        if (N == 1) {\\n            return 0;\\n        }\\n       \\n        int left = 0, right = N - 1;\\n        while (right - left > 1) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] < nums[mid + 1]) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        \\n        return (left == N - 1 || nums[left] > nums[left + 1]) ? left : right;\\n    }\\n\\n\\nI hope this makes things clear despite the long explanation.",
                "codeTag": "Unknown"
            },
            {
                "id": 50259,
                "title": "my-clean-and-readable-python-solution",
                "content": "    Basic Idea: Binary search\\n\\n    Elaboration: \\n     if an element(not the right-most one) is smaller than its right neighbor, then there must be a peak element on its right, because the elements on its right is either \\n       1. always increasing  -> the right-most element is the peak\\n       2. always decreasing  -> the left-most element is the peak\\n       3. first increasing then decreasing -> the pivot point is the peak\\n       4. first decreasing then increasing -> the left-most element is the peak  \\n\\n       Therefore, we can find the peak only on its right elements( cut the array to half)\\n\\n       The same idea applies to that an element(not the left-most one) is smaller than its left neighbor.\\n\\n\\n\\n    Conditions:\\n         1. array length is 1  -> return the only index \\n         2. array length is 2  -> return the bigger number's index \\n         3. array length is bigger than 2 -> \\n               (1) find mid, compare it with its left and right neighbors  \\n               (2) return mid if nums[mid] greater than both neighbors\\n               (3) take the right half array if nums[mid] smaller than right neighbor\\n               (4) otherwise, take the left half\\n    \\n    Run time: O(logn)\\n    Memory: constant\\n    Test cases: \\n         [1]\\n         [1,2]\\n         [2,1]\\n         [1,2,3]\\n         [3,2,1]\\n         [2,1,3]\\n    \\n    \\n    def findPeakElement(self, nums):\\n        left = 0\\n        right = len(nums)-1\\n    \\n        # handle condition 3\\n        while left < right-1:\\n            mid = (left+right)/2\\n            if nums[mid] > nums[mid+1] and nums[mid] > nums[mid-1]:\\n                return mid\\n                \\n            if nums[mid] < nums[mid+1]:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n                \\n        #handle condition 1 and 2\\n        return left if nums[left] >= nums[right] else right",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "    Basic Idea: Binary search\\n\\n    Elaboration: \\n     if an element(not the right-most one) is smaller than its right neighbor, then there must be a peak element on its right, because the elements on its right is either \\n       1. always increasing  -> the right-most element is the peak\\n       2. always decreasing  -> the left-most element is the peak\\n       3. first increasing then decreasing -> the pivot point is the peak\\n       4. first decreasing then increasing -> the left-most element is the peak  \\n\\n       Therefore, we can find the peak only on its right elements( cut the array to half)\\n\\n       The same idea applies to that an element(not the left-most one) is smaller than its left neighbor.\\n\\n\\n\\n    Conditions:\\n         1. array length is 1  -> return the only index \\n         2. array length is 2  -> return the bigger number's index \\n         3. array length is bigger than 2 -> \\n               (1) find mid, compare it with its left and right neighbors  \\n               (2) return mid if nums[mid] greater than both neighbors\\n               (3) take the right half array if nums[mid] smaller than right neighbor\\n               (4) otherwise, take the left half\\n    \\n    Run time: O(logn)\\n    Memory: constant\\n    Test cases: \\n         [1]\\n         [1,2]\\n         [2,1]\\n         [1,2,3]\\n         [3,2,1]\\n         [2,1,3]\\n    \\n    \\n    def findPeakElement(self, nums):\\n        left = 0\\n        right = len(nums)-1\\n    \\n        # handle condition 3\\n        while left < right-1:\\n            mid = (left+right)/2\\n            if nums[mid] > nums[mid+1] and nums[mid] > nums[mid-1]:\\n                return mid\\n                \\n            if nums[mid] < nums[mid+1]:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n                \\n        #handle condition 1 and 2\\n        return left if nums[left] >= nums[right] else right",
                "codeTag": "Python3"
            },
            {
                "id": 50236,
                "title": "o-logn-solution-javacode",
                "content": "\\nThis problem is similar to Local Minimum. And according to the given condition, num[i] != num[i+1], there must exist a O(logN) solution. So we use binary search for this problem.\\n\\n - If  num[i-1] < num[i] > num[i+1], then num[i] is peak\\n - If num[i-1] < num[i] < num[i+1], then num[i+1...n-1] must contains a peak\\n - If num[i-1] > num[i] > num[i+1], then num[0...i-1] must contains a peak\\n - If num[i-1] > num[i] < num[i+1], then both sides have peak\\n(n is num.length)\\n\\nHere is the code\\n\\n    public int findPeakElement(int[] num) {    \\n        return helper(num,0,num.length-1);\\n    }\\n    \\n    public int helper(int[] num,int start,int end){\\n        if(start == end){\\n            return start;\\n        }else if(start+1 == end){\\n            if(num[start] > num[end]) return start;\\n            return end;\\n        }else{\\n            \\n            int m = (start+end)/2;\\n            \\n            if(num[m] > num[m-1] && num[m] > num[m+1]){\\n    \\n                return m;\\n    \\n            }else if(num[m-1] > num[m] && num[m] > num[m+1]){\\n    \\n                return helper(num,start,m-1);\\n    \\n            }else{\\n    \\n                return helper(num,m+1,end);\\n    \\n            }\\n            \\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "\\nThis problem is similar to Local Minimum. And according to the given condition, num[i] != num[i+1], there must exist a O(logN) solution. So we use binary search for this problem.\\n\\n - If  num[i-1] < num[i] > num[i+1], then num[i] is peak\\n - If num[i-1] < num[i] < num[i+1], then num[i+1...n-1] must contains a peak\\n - If num[i-1] > num[i] > num[i+1], then num[0...i-1] must contains a peak\\n - If num[i-1] > num[i] < num[i+1], then both sides have peak\\n(n is num.length)\\n\\nHere is the code\\n\\n    public int findPeakElement(int[] num) {    \\n        return helper(num,0,num.length-1);\\n    }\\n    \\n    public int helper(int[] num,int start,int end){\\n        if(start == end){\\n            return start;\\n        }else if(start+1 == end){\\n            if(num[start] > num[end]) return start;\\n            return end;\\n        }else{\\n            \\n            int m = (start+end)/2;\\n            \\n            if(num[m] > num[m-1] && num[m] > num[m+1]){\\n    \\n                return m;\\n    \\n            }else if(num[m-1] > num[m] && num[m] > num[m+1]){\\n    \\n                return helper(num,start,m-1);\\n    \\n            }else{\\n    \\n                return helper(num,m+1,end);\\n    \\n            }\\n            \\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3189138,
                "title": "best-c-3-solution-binary-search-iterative-recursive-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can Solved this question using multiple approach. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Linear Search. Brute Force Approach\\n2. Solved using Binary Search (Recursive Approach).\\n3. Solved using Binary Search (Iterative Approach). Optimized Approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N), because in the worst case we traverse the <= N element. Where N is the size of the\\n    Array(nums).\\n                    \\n    Space Complexity : O(1), the space complexity is constant.\\n\\n    Solved using Linear Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n-1; i++){\\n            if(nums[i] > nums[i+1]){\\n                return i;\\n            }\\n        }\\n        return n-1;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 1 Second Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        return max_element(nums.begin(), nums.end()) - nums.begin();\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity\\n    is logarithmic.\\n\\n    Space Complexity : O(logN), Recursion stack space.\\n\\n    Solved using Binary Search (Recursive Approach).\\n\\n*/\\n\\n\\n/***************************************** Approach 2 First Code *****************************************/\\n\\nclass Solution {\\nprivate: \\n    int recursive_binary_search(vector<int>& nums, int low, int high){\\n        if(low == high){\\n            return low;\\n        }\\n        int mid = (low + high) >> 1;\\n        if(nums[mid] > nums[mid+1]){\\n            return recursive_binary_search(nums, low, mid);\\n        }\\n        else{\\n            return recursive_binary_search(nums, mid+1, high);\\n        }\\n    }\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        return recursive_binary_search(nums, 0, nums.size()-1);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity\\n    is logarithmic.\\n\\n    Space Complexity : O(1), since we stored only some constant number of elements, the space complexity is\\n    constant.\\n\\n    Solved using Binary Search (Iterative Approach).\\n\\n*/\\n\\n\\n/***************************************** Approach 3 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int n = nums.size();\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low < high){\\n            int mid = (low + high) >> 1;\\n            if(nums[mid] > nums[mid+1]){\\n                high = mid;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Recursion"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N), because in the worst case we traverse the <= N element. Where N is the size of the\\n    Array(nums).\\n                    \\n    Space Complexity : O(1), the space complexity is constant.\\n\\n    Solved using Linear Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n-1; i++){\\n            if(nums[i] > nums[i+1]){\\n                return i;\\n            }\\n        }\\n        return n-1;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 1 Second Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        return max_element(nums.begin(), nums.end()) - nums.begin();\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity\\n    is logarithmic.\\n\\n    Space Complexity : O(logN), Recursion stack space.\\n\\n    Solved using Binary Search (Recursive Approach).\\n\\n*/\\n\\n\\n/***************************************** Approach 2 First Code *****************************************/\\n\\nclass Solution {\\nprivate: \\n    int recursive_binary_search(vector<int>& nums, int low, int high){\\n        if(low == high){\\n            return low;\\n        }\\n        int mid = (low + high) >> 1;\\n        if(nums[mid] > nums[mid+1]){\\n            return recursive_binary_search(nums, low, mid);\\n        }\\n        else{\\n            return recursive_binary_search(nums, mid+1, high);\\n        }\\n    }\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        return recursive_binary_search(nums, 0, nums.size()-1);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity\\n    is logarithmic.\\n\\n    Space Complexity : O(1), since we stored only some constant number of elements, the space complexity is\\n    constant.\\n\\n    Solved using Binary Search (Iterative Approach).\\n\\n*/\\n\\n\\n/***************************************** Approach 3 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int n = nums.size();\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low < high){\\n            int mid = (low + high) >> 1;\\n            if(nums[mid] > nums[mid+1]){\\n                high = mid;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50367,
                "title": "python-easy-to-understand-o-lgn-solution",
                "content": "```\\nclass Solution(object):\\n    def findPeakElement(self, nums):\\n        l, r = 0, len(nums)-1\\n        while l <= r:\\n            mid = l + (r-l)//2\\n            if (mid-1<0 or nums[mid]>nums[mid-1]) and (mid+1>=len(nums) or nums[mid]>nums[mid+1]):\\n                return mid\\n            elif mid-1>=0 and nums[mid]<nums[mid-1]: # the opposite of the above \"if\" are these two \"elif\"\\n                r = mid - 1\\n            elif mid+1<len(nums) or nums[mid]<nums[mid+1]:\\n                l = mid + 1\\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution(object):\\n    def findPeakElement(self, nums):\\n        l, r = 0, len(nums)-1\\n        while l <= r:\\n            mid = l + (r-l)//2\\n            if (mid-1<0 or nums[mid]>nums[mid-1]) and (mid+1>=len(nums) or nums[mid]>nums[mid+1]):\\n                return mid\\n            elif mid-1>=0 and nums[mid]<nums[mid-1]: # the opposite of the above \"if\" are these two \"elif\"\\n                r = mid - 1\\n            elif mid+1<len(nums) or nums[mid]<nums[mid+1]:\\n                l = mid + 1\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334425,
                "title": "c-simple-and-easy-solutions-from-binary-search-to-a-cool-one-liner-explained",
                "content": "**O(log(n)) Binary Search:**\\nHow does binary search work for this problem?\\nLet\\'s look at mid.\\nIf nums[mid] < nums[mid+1], then there has to be a peak element in the right side of mid.\\nEither the numbers increase until we reach the end and then the last element will be a peak, or at some point a number gets smaller and right there we will have a peak.\\nSame for the left side of mid.\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int lo = 0, hi = nums.size()-1, mid;\\n        \\n        while (lo < hi) {\\n            mid = lo + (hi - lo) / 2;\\n            if (nums[mid] < nums[mid + 1]) \\n                lo = mid + 1;\\n            else hi = mid;\\n        }\\n        \\n        return lo;\\n    }\\n};\\n```\\n****\\n**O(n) Sequential Search:**\\nJust scan the array and find a number that is greater than its neighbors.\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        // edge case - only one element\\n        if (nums.size() == 1) return 0;\\n        \\n        // peak is first element\\n        if (nums[0] > nums[1]) return 0;\\n        \\n        // peak is last element\\n        if (nums.back() > nums[nums.size()-2]) return nums.size()-1;\\n        \\n        // iterate to find peak\\n        for (int i = 0; i < nums.size(); i++) \\n            if ((nums[i] > nums[max(0, i-1)]) && (nums[i] > nums[i+1])) return i;\\n        \\n        return -1;\\n    }\\n};\\n```\\n**A little cheating - one liner solution:**\\nThe maximum element of the array will always be a peak, since there is a constraint nums[i] != nums[i + 1] for all valid i.\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        return max_element(nums.begin(), nums.end()) - nums.begin();\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int lo = 0, hi = nums.size()-1, mid;\\n        \\n        while (lo < hi) {\\n            mid = lo + (hi - lo) / 2;\\n            if (nums[mid] < nums[mid + 1]) \\n                lo = mid + 1;\\n            else hi = mid;\\n        }\\n        \\n        return lo;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        // edge case - only one element\\n        if (nums.size() == 1) return 0;\\n        \\n        // peak is first element\\n        if (nums[0] > nums[1]) return 0;\\n        \\n        // peak is last element\\n        if (nums.back() > nums[nums.size()-2]) return nums.size()-1;\\n        \\n        // iterate to find peak\\n        for (int i = 0; i < nums.size(); i++) \\n            if ((nums[i] > nums[max(0, i-1)]) && (nums[i] > nums[i+1])) return i;\\n        \\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        return max_element(nums.begin(), nums.end()) - nums.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334457,
                "title": "python-from-linear-to-binary-search-with-picture-o-logn",
                "content": "**\\u2714\\uFE0F Solution 1: Linear scan**\\n- Iterate `i` from `0..n-1`, if we found `nums[i-1] < nums[i]` && `nums[i] > nums[i+1]` return `i` as peak.\\n```python\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(n):\\n            if (i == 0 or nums[i-1] < nums[i]) and (i == n-1 or nums[i] > nums[i+1]):  # Found peak\\n                return i\\n        return -1\\n```\\n**Complexity**\\n- Time: `O(N)`\\n- Space: `O(1)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Binary Search**\\n- Binary search starting with `left = 0, right = n-1`, `mid = (left + right) / 2`\\n- If `nums[mid-1] < nums[mid]` && `nums[mid] > nums[mid+1]` return `mid ` as peak.\\n- Else if `nums[mid-1] < nums[mid]` then search peak on the right side.\\n- Else search pick on the left side.\\n![image](https://assets.leetcode.com/users/images/afaf964d-786a-4b1e-8ff0-2ded2bcdee47_1626162427.491468.png)\\n\\n```python\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        left, right = 0, n - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if (mid == 0 or nums[mid-1] < nums[mid]) and (mid == n-1 or nums[mid] > nums[mid+1]):  # Found peak\\n                return mid\\n            if mid == 0 or nums[mid-1] < nums[mid]:  # Find peak on the right\\n                left = mid + 1\\n            else:  # Find peak on the left\\n                right = mid - 1\\n        return -1\\n```\\n**Complexity**\\n- Time: `O(logN)`\\n- Space: `O(1)`\\n\\n\\nIf you think this post is useful, I\\'m happy if **you give a vote**. Any **questions or discussions are welcome!** Thanks.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(n):\\n            if (i == 0 or nums[i-1] < nums[i]) and (i == n-1 or nums[i] > nums[i+1]):  # Found peak\\n                return i\\n        return -1\\n```\n```python\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        left, right = 0, n - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if (mid == 0 or nums[mid-1] < nums[mid]) and (mid == n-1 or nums[mid] > nums[mid+1]):  # Found peak\\n                return mid\\n            if mid == 0 or nums[mid-1] < nums[mid]:  # Find peak on the right\\n                left = mid + 1\\n            else:  # Find peak on the left\\n                right = mid - 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788474,
                "title": "general-binary-search-thought-process-4-templates",
                "content": "***Scroll down to the end to check the solution to this question using all 4 templates***\\nBinary Search can be applied to a problem where we can find a function(if condition of the code) that map elements in left half to True and the other half to False or vice versa . **Don\\'t think it is just for the sorted array**  (Refer here :https://www.youtube.com/watch?time_continue=67&v=GU7DpgHINWQ&feature=emb_logo)\\n\\nPattern : T T T T T F F F \\n\\n![image](https://assets.leetcode.com/users/images/05fce0f4-326d-4d13-b652-e8d9128b6c55_1610744708.2517133.png)\\n\\n**Note: y<=6 is a condition**\\n![image](https://assets.leetcode.com/users/images/e713fc84-28db-4451-a58a-7fa95a44f021_1610744888.7189069.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/cff92a4e-b782-4c1b-bc28-d84b0156d4e8_1610744578.0274403.png)\\n![image](https://assets.leetcode.com/users/images/7cecf4f6-f675-4195-af27-b7d19d20d898_1610745061.9327664.png)\\n\\n\\nNow a Binary Search can be solved using 4 Templates: You can try solving all Binary Search questions using just one template. \\n1. **Find the *First True***:\\n\\n\\t**T** T T T T F F F or F F F F **T** T T T\\n\\tWe always try to go the left when finding the First True and the template will be like :\\n\\t\\n\\t```\\n\\twhile left < right :\\n\\t\\tif condition is true:\\n\\t\\t\\tright = mid \\n\\t\\telse:\\n\\t\\t\\tleft = mid +1\\n\\t```\\n\\t\\n      **Thought Process for this template :**  For FFFFTTTT, if mid is second last True , then it is a possible ans but we need to keep searching left because we want First True or minimal True for it . We move to left part by doing right = mid where mid is a potential solution and throw away the right part\\n\\n2. **Find the *Last True***:\\n\\n\\tT T T T **T** F F F or  F F F F T T T T **T**\\n\\t\\n\\tWe always try to go the right when finding the Last True and the template will be like :\\n\\t\\n\\t```\\n\\twhile left < right :\\n\\t\\tif condition is true:\\n\\t\\t\\tleft = mid \\n\\t\\telse:\\n\\t\\t\\tright = mid - 1\\n\\t```\\n\\t\\n    **Thought Process for this template :**  For T T T T T F F F, if mid is First True , then it is a possible ans but we need to keep searching right because we want Last True or Maximal True for it . We move to right half  by doing left = mid where mid is a potential solution and throw away the left part\\n\\t\\n3. **Find the *First False***:\\nT T T T T **F** F F or  **F** F F F T T T T \\n\\t```\\n\\twhile left < right:\\n\\t\\tif condition is False: \\n\\t\\t\\tleft = mid +1\\n\\t\\telse:\\n\\t\\t\\tright = mid\\n\\t```\\n    **Thought Process this template :**  For T T T T T F F F, if mid is at Last False , then it is a possible ans but we need to keep searching left because we want First False or Minimal False for it . \\n\\n4.  **Find the *Last False*:**\\nT T T T T F F **F**  or F F F F **F** T T T\\n\\t```\\n\\twhile left < right:\\n\\t\\tif condition is False: \\n\\t\\t\\tright  = mid -1\\n\\t\\telse:\\n\\t\\t\\tleft = mid\\n\\t```\\n     **Reason for this template :**  For  F F F F F T T T , if mid is second False , then it is a possible ans but we need to keep searching right because we want Last False or Maximal False for it .\\n\\nYou have to change the condition in the \"if statement\" such that the problem is converted to one of the problem above. You can stick to one template if you want like always finding the First true . Now this \"condition\" in \"if statement\" can be the one which question is asking or it can be the opposite of it .\\n\\n----------------------------------------------------------------------------------------------------------------------------\\n## **Current Problem** : Find Peak Element : \\n\\n**Condition for this question** : We know a elem at index i is a peak elem , if its left and right neighbours are smaller than it i.e. **nums[i] > nums[i-1] and nums[i] > nums[i+1]**\\n\\n**Now Lets solve this question using all the 4 templates above:**\\n1. **Find First True** :\\nIn order to convert this problem to T T T T F F F F  where the ans(finding peak in this question) will be the First True , we need to come up with condition like ***nums[i] >nums[i+1]***\\n![image](https://assets.leetcode.com/users/images/9e8cbbcf-336f-4c3f-89e0-a648a5ae5f3d_1597422263.2014349.png)\\n\\n\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        left =0\\n        right = len(nums)-1\\n        while left < right:\\n            mid = left + (right - left ) //2\\n            if nums[mid] > nums[mid+1]: # True Condition # Dec function # go left # Find First True i.e first elem where this condition will be True\\n                right = mid # include mid # mid is potential solution \\n            else:\\n                left = mid +1\\n        return left\\n```\\n2. **Find Last True:** . In order to convert this problem to T T T T T F F F where the ans will be the Last True , we need to come up with condition like ***nums[i] > nums[i-1]***\\n![image](https://assets.leetcode.com/users/images/c08728b3-26d0-4d3d-9ef9-63b1c67b0d5e_1597422276.0160937.png)\\n\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        left =0\\n        right = len(nums)-1\\n        while left < right:\\n            mid = left + (right - left + 1) //2 # Right biased mid as left = mid in else condition # prevent infinite loop\\n            if nums[mid] > nums[mid-1]: # True condition # go right # inc function # Last True \\n                left = mid # mid is a potential elem\\n            else:\\n                right = mid -1\\n        return left\\n```\\n\\n3. **Find First False :** You have to use a condition in if statement which is opposite of what question is asking . \\n**Opposite Conditions :**   nums[i] < nums[i+1] or nums[i] < nums[i-1].\\nFor first False , we will use nums[i] < nums[i+1]\\nWhen nums[i] < nums[i+1], it means it is the increasing slope and all elems n this inc slope will pass this condition i.e. They will be True. Our Ans will be the first false.(In else condition , we are storing the potential ans in \"right\"var and when loop ends , we can return that)\\n![image](https://assets.leetcode.com/users/images/1036f7cf-8140-4c44-8e10-39beb32537eb_1597270384.8798342.png)\\n\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        left =0\\n        right = len(nums)-1\\n        while(left < right):\\n            mid = left +(right-left)//2\\n            if nums[mid] <  nums[mid+1]: # False Condition # inc function # go right # Find First False\\n\\t\\t\\t# i.e. find First elem when this if will be false\\n                left = mid+1 # exclude mid \\n            else: \\n                right = mid\\n        return left\\n```\\n*  **Find Last False**  : nums[i] < nums[i-1]\\n![image](https://assets.leetcode.com/users/images/2d70357f-0d6b-41a6-93a0-33a33a7a55b2_1597270504.5083344.png)\\n\\n```\\n\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        left =0\\n        right = len(nums)-1\\n        while(left < right):\\n            mid = left +(right-left+1)//2 # Right biased mid as left = mid in else condition # prevent infinite loop\\n            if nums[mid] < nums[mid-1]: # False condition # Dec function # go left # Find Last False i.e the Last elem for which this condition will be False \\n                right = mid - 1\\n            else: # decreasing so peak will be before mid or it can be mid\\n                left = mid\\n        return left\\n```\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\n\\twhile left < right :\\n\\t\\tif condition is true:\\n\\t\\t\\tright = mid \\n\\t\\telse:\\n\\t\\t\\tleft = mid +1\\n\\t```\n```\\n\\twhile left < right :\\n\\t\\tif condition is true:\\n\\t\\t\\tleft = mid \\n\\t\\telse:\\n\\t\\t\\tright = mid - 1\\n\\t```\n```\\n\\twhile left < right:\\n\\t\\tif condition is False: \\n\\t\\t\\tleft = mid +1\\n\\t\\telse:\\n\\t\\t\\tright = mid\\n\\t```\n```\\n\\twhile left < right:\\n\\t\\tif condition is False: \\n\\t\\t\\tright  = mid -1\\n\\t\\telse:\\n\\t\\t\\tleft = mid\\n\\t```\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        left =0\\n        right = len(nums)-1\\n        while left < right:\\n            mid = left + (right - left ) //2\\n            if nums[mid] > nums[mid+1]: # True Condition # Dec function # go left # Find First True i.e first elem where this condition will be True\\n                right = mid # include mid # mid is potential solution \\n            else:\\n                left = mid +1\\n        return left\\n```\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        left =0\\n        right = len(nums)-1\\n        while left < right:\\n            mid = left + (right - left + 1) //2 # Right biased mid as left = mid in else condition # prevent infinite loop\\n            if nums[mid] > nums[mid-1]: # True condition # go right # inc function # Last True \\n                left = mid # mid is a potential elem\\n            else:\\n                right = mid -1\\n        return left\\n```\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        left =0\\n        right = len(nums)-1\\n        while(left < right):\\n            mid = left +(right-left)//2\\n            if nums[mid] <  nums[mid+1]: # False Condition # inc function # go right # Find First False\\n\\t\\t\\t# i.e. find First elem when this if will be false\\n                left = mid+1 # exclude mid \\n            else: \\n                right = mid\\n        return left\\n```\n```\\n\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        left =0\\n        right = len(nums)-1\\n        while(left < right):\\n            mid = left +(right-left+1)//2 # Right biased mid as left = mid in else condition # prevent infinite loop\\n            if nums[mid] < nums[mid-1]: # False condition # Dec function # go left # Find Last False i.e the Last elem for which this condition will be False \\n                right = mid - 1\\n            else: # decreasing so peak will be before mid or it can be mid\\n                left = mid\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334653,
                "title": "python-binary-search-solution-explained",
                "content": "There is a huge hint given in the problem description: we need to find solution with complexity `O(log n)` and we immedietly must think about **binary search**. Let us consider the case `[-inf, 1, 2, 1, 3, 5, 6, 4, inf]`. We need to find place `k`, such that `nums[k] < nums[k+1]` and `nums[k+1] > nums[k+2]`. Let us compare all pairs of adjacent elements and ask question: if the first one is smaller then the second, for our array we have `[True, True, False, True, True, True, False, False]`. Then what we need to find in this array is any two adjacent places where we have pair `True, False`. Note, that first element is always `True` and last is always `False`, so we have `True, .............., False`. \\n\\nNow, let us choose element in the middle, and we can have two options:\\n1) It is `True`, so we have `True, ......, True, ......., False` and in this case for the second half we have property that it starts with `True` and ends with `False`.\\n2) It is `False`, so we have `True, ......, False, ......., False` and in this case for the first half we have property that it starts with `True` and ends with `False`.\\n\\nSo, in any case we save the property that it starts with `True` and ends with `False`. Each time we decrease length of interal twice, so:\\n\\n#### Complexity\\nTime complexity is `O(log n)`, space complexity is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def findPeakElement(self, nums):\\n        beg, end = 0, len(nums) - 1\\n        while beg < end:\\n            mid = (beg + end)//2\\n            if nums[mid] < nums[mid + 1]:\\n                beg = mid + 1\\n            else:\\n                end = mid\\n\\n        return end\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def findPeakElement(self, nums):\\n        beg, end = 0, len(nums) - 1\\n        while beg < end:\\n            mid = (beg + end)//2\\n            if nums[mid] < nums[mid + 1]:\\n                beg = mid + 1\\n            else:\\n                end = mid\\n\\n        return end\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50237,
                "title": "a-concise-standard-binary-search-solution",
                "content": "    int findPeakElement(const vector<int> &num) {\\n        if (num.size() <= 1) return 0;\\n        int mid = 0, l = 0, h = num.size() - 1;\\n        \\n        while (l < h) {\\n            mid = (l + h) / 2;\\n            if (num[mid] > num[mid + 1])\\n                h = mid;\\n            else if (num[mid] < num[mid + 1])\\n                l = mid + 1;\\n        }\\n        \\n        return l;\\n    }",
                "solutionTags": [],
                "code": "    int findPeakElement(const vector<int> &num) {\\n        if (num.size() <= 1) return 0;\\n        int mid = 0, l = 0, h = num.size() - 1;\\n        \\n        while (l < h) {\\n            mid = (l + h) / 2;\\n            if (num[mid] > num[mid + 1])\\n                h = mid;\\n            else if (num[mid] < num[mid + 1])\\n                l = mid + 1;\\n        }\\n        \\n        return l;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 50222,
                "title": "sharing-a-more-standard-binary-search-c-solution",
                "content": "    class Solution {\\n    public:\\n        int findPeakElement(const vector<int> &num) {\\n            int low = 0, high = num.size() - 1;\\n            while (low < high - 1) {\\n                int mid = (low + high) / 2;\\n                if (num[mid] > num[mid - 1] && num[mid] > num[mid + 1]) \\n                    return mid;\\n                else if (num[mid] > num[mid + 1]) \\n                        high = mid - 1;\\n                     else \\n                        low = mid + 1;    \\n            }\\n            return num[low] > num[high] ? low : high;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n        int findPeakElement(const vector<int> &num) {\\n            int low = 0, high = num.size() - 1;\\n            while (low < high - 1) {\\n                int mid = (low + high) / 2;\\n                if (num[mid] > num[mid - 1] && num[mid] > num[mid + 1]) \\n                    return mid;\\n                else if (num[mid] > num[mid + 1]) \\n                        high = mid - 1;\\n                     else \\n                        low = mid + 1;    \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 50304,
                "title": "java-short-and-neat-code-10-line",
                "content": "        public int findPeakElement(int[] a) {\\n            int low = 0, mid = 0, high = a.length - 1;\\n            while(low < high) {\\n                mid = low + (high-low)/2;\\n                if(a[mid] < a[mid+1]) low = mid+1;\\n                else high = mid;\\n            }\\n            return low;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "        public int findPeakElement(int[] a) {\\n            int low = 0, mid = 0, high = a.length - 1;\\n            while(low < high) {\\n                mid = low + (high-low)/2;\\n                if(a[mid] < a[mid+1]) low = mid+1;\\n                else high = mid;\\n            }\\n            return low;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1335492,
                "title": "2-different-approach-c-solution",
                "content": "**Traversing over the array**\\n*for each element from index 1 to n-2 check whether the curr element is more than its left and right element*\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 0;\\n        if(n == 2)return nums[0] > nums[1] ? 0 : 1;\\n        \\n        for(int i = 1; i < n-1; i++)\\n            if(nums[i] > nums[i-1] && nums[i] > nums[i+1]) return i;\\n        \\n        if(nums[0] > nums[1]) return 0;\\n        else if(nums[n-1] > nums[n-2]) return n-1;\\n        return -1;\\n    }\\n};\\n```\\n**Using Binary Search**\\n*check whether the middle element is satisfying the peak element condition or not, if not then if right element is more than mid element, move to right half else move to left half and again repeat the same procedure*\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 0;\\n        if(n == 2)return nums[0] > nums[1] ? 0 : 1;\\n        int i = 1, j = n-2;\\n        while(i <= j){\\n            int mid = j + (i-j)/2;\\n                if(nums[mid] > nums[mid-1] && nums[mid] > nums[mid+1]) return mid;\\n                else if(nums[mid+1] > nums[mid]) i = mid+1;\\n                else if(nums[mid-1] >= nums[mid]) j = mid-1;\\n        }\\n        if(nums[0] > nums[1]) return 0;\\n        else if(nums[n-1] > nums[n-2]) return n-1;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 0;\\n        if(n == 2)return nums[0] > nums[1] ? 0 : 1;\\n        \\n        for(int i = 1; i < n-1; i++)\\n            if(nums[i] > nums[i-1] && nums[i] > nums[i+1]) return i;\\n        \\n        if(nums[0] > nums[1]) return 0;\\n        else if(nums[n-1] > nums[n-2]) return n-1;\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 0;\\n        if(n == 2)return nums[0] > nums[1] ? 0 : 1;\\n        int i = 1, j = n-2;\\n        while(i <= j){\\n            int mid = j + (i-j)/2;\\n                if(nums[mid] > nums[mid-1] && nums[mid] > nums[mid+1]) return mid;\\n                else if(nums[mid+1] > nums[mid]) i = mid+1;\\n                else if(nums[mid-1] >= nums[mid]) j = mid-1;\\n        }\\n        if(nums[0] > nums[1]) return 0;\\n        else if(nums[n-1] > nums[n-2]) return n-1;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144845,
                "title": "c-crisp-explanation-on-why-using-binary-search-with-image",
                "content": "# Intuition\\nUsing binary search because if you notice in question there are two major point has mentioned.. \\n- No two adjacent element is same.\\n- -1th index and nth index is -INFINITY.\\n\\nNow let\\'s explain why this two point is enough to construct a binary search algorithm.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n`For example arr=[3,2,1,3,4,5,3,1]`\\n\\n![lcsol1.PNG](https://assets.leetcode.com/users/images/45c95dfc-787a-4ebf-bf84-73f403b46b22_1675579011.3143616.png)\\n\\nHere we have to find only one peak index. So we will use binary search to find..\\n\\nIf `v[mid-1] < v[mid] && v[mid] > v[mid+1] ` then mid index is a valid answer and we will return it.\\n\\nIf not then there are three possibility.\\n- Possibility-1: Suppose `arr[mid-1]=1 && arr[mid]=2 && arr[mid+1]=3`\\n`[ 1, 2, 3 ] and mid = 2`\\n\\n![123.PNG](https://assets.leetcode.com/users/images/2e59a423-2ede-424d-8315-46554f1f4d41_1675579236.131029.png)\\n    Now we are 100% sure that we will get answer on right side because at right side there are three possibiltiy..\\n \\n1. For example after `1,2,3` there are `4,5,6` so the total array `[1,2,3,4,5,6]` means till index n-1 all elements are strictly    increasing and our answer will be n-1th index.\\n\\n\\n2. And if the right part is not strictly increasing and no two elements are not same then we are sure that we will find a peak on right side. Like after `1,2,3` supoose there are `4,5,6 3` so the total array `[1,2,3,4,5,6,3]` then `5 6 3` will be a valid peak.\\n\\n\\n3. Or it can be like right part is strictly decreasing and after `1,2,3` supoose there are `2 1` so total array `[1,2,3,2,1]` then `2 3 2` will be a valid peak.\\n\\nThat\\'s why here choosing right part will 100% give us a peak index.\\n\\n- Possibility-2: Suppose `arr[mid-1]=3 && arr[mid]=2 && arr[mid+1]=1`\\n`[ 3, 2, 1 ] and mid = 2`\\n\\n![321.PNG](https://assets.leetcode.com/users/images/0ff14605-7fbe-4225-9e50-344303043f3e_1675581325.0701628.png)\\n\\n\\nSame concept will be used like before.. Here choosing left part will 100% give use peak index.\\n\\n- Possibility-3: Suppose `arr[mid-1]=3 && arr[mid]=2 && arr[mid+1]=3`\\n`[ 3, 2, 3 ] and mid = 2`\\n\\n![212.PNG](https://assets.leetcode.com/users/images/41410330-4a24-4ce9-88a5-5f88ecd0b3ab_1675581351.775833.png)\\n\\n\\nSame concept will be used like before.. Here either you can choose left part or right part. Both will give you atleast one peak index.\\n\\n# PLEASE UPVOTE PLEASEEEEEEEEE :)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`O(logn)`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`O(1)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& v) {\\n        int n=v.size()-1;\\n\\n        if(v.size()==1) return 0;\\n        if(v[0]>v[1]) return 0;\\n        if(v[n]>v[n-1]) return n;\\n\\n        int low=1, high=v.size()-2, ans=0;\\n\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(v[mid-1]<v[mid] && v[mid]>v[mid+1]){\\n                ans=mid;\\n                break;\\n            }\\n            if(v[mid-1]>v[mid]){\\n                high=mid-1;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& v) {\\n        int n=v.size()-1;\\n\\n        if(v.size()==1) return 0;\\n        if(v[0]>v[1]) return 0;\\n        if(v[n]>v[n-1]) return n;\\n\\n        int low=1, high=v.size()-2, ans=0;\\n\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(v[mid-1]<v[mid] && v[mid]>v[mid+1]){\\n                ans=mid;\\n                break;\\n            }\\n            if(v[mid-1]>v[mid]){\\n                high=mid-1;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 692986,
                "title": "javascript-simple-binary-and-linear-search",
                "content": "## Binary Search \\n#### Time: O(logN)\\n```javascript\\nvar findPeakElement = function(nums) {\\n    let left = 0, right = nums.length-1, mid;\\n    \\n    while(left < right) {\\n        mid = Math.floor((right+left)/2);\\n        if(nums[mid] > nums[mid+1]) right = mid;\\n        else left = mid+1;\\n    }\\n    return left;\\n};\\n```\\n\\n## Linear Search\\n#### Time: O(N)\\n```javascript\\nvar findPeakElement = function(nums) {\\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] > nums[i+1]) return i;\\n    }\\n    return nums.length-1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar findPeakElement = function(nums) {\\n    let left = 0, right = nums.length-1, mid;\\n    \\n    while(left < right) {\\n        mid = Math.floor((right+left)/2);\\n        if(nums[mid] > nums[mid+1]) right = mid;\\n        else left = mid+1;\\n    }\\n    return left;\\n};\\n```\n```javascript\\nvar findPeakElement = function(nums) {\\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] > nums[i+1]) return i;\\n    }\\n    return nums.length-1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3793037,
                "title": "binary-search-template-solution-intuition-explained-in-detail-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nhey every one, i have made video playlist for binary search where i discuss a template solution and intuition behind it, this template solution will be very useful as this will help you solve many other questions in binary search this question is the part of that playlist:\\n\\nVideo link for question: https://youtu.be/VFC1oxkn5-E\\n\\nPlaylist link: \\nhttps://youtube.com/playlist?list=PLICVjZ3X1AcYYdde4GTp79zfdp_VACSkX\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int left=0;\\n        int right=nums.size()-1;\\n        while(left<right){\\n            int mid=left+(right-left)/2;\\n            if(nums[mid]>nums[mid+1]){\\n                right=mid;\\n            }\\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int left=0;\\n        int right=nums.size()-1;\\n        while(left<right){\\n            int mid=left+(right-left)/2;\\n            if(nums[mid]>nums[mid+1]){\\n                right=mid;\\n            }\\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545227,
                "title": "c-java-python-javascript-time-o-log-n-space-o-1-simple-solution-easy-to-understand",
                "content": "# Intuition:\\nThe problem aims to find a peak element in a given vector `nums`, where a peak element is defined as an element that is greater than its neighboring elements. The provided code uses a binary search approach to find the peak element efficiently.\\n\\n# Approach:\\n1. The code initializes two pointers, `start` and `end`, which represent the start and end indices of the search range.\\n2. A while loop runs until the `start` pointer is less than the `end` pointer.\\n3. Inside the loop, the code calculates the middle index `mid` as the average of `start` and `end`.\\n4. Special cases are handled for `mid` being the first or last index. If `mid` is the first index, the code checks if the element at index 0 is a peak by comparing it with the element at index 1. If it is greater, it returns 0; otherwise, it returns 1. Similarly, if `mid` is the last index, the code checks if the element at index `end - 1` is a peak by comparing it with the element at index `end - 2`. If it is greater, it returns `end - 1`; otherwise, it returns `end - 2`.\\n5. If none of the special cases are met, the code checks if the element at index `mid` is a peak by comparing it with its neighboring elements at indices `mid + 1` and `mid - 1`. If it is greater than both neighbors, it is a peak, and the function returns `mid`.\\n6. If the element at index `mid` is less than its left neighbor (`mid - 1`), the code sets `end` to `mid - 1`, as the peak must be on the left side.\\n7. Otherwise, if the element at index `mid` is less than its right neighbor (`mid + 1`), the code sets `start` to `mid + 1`, as the peak must be on the right side.\\n8. The loop continues with the updated values of `start` and `end` until a peak element is found.\\n9. If the loop completes without finding a peak element, the function returns `start` as the index of the last checked element, which is considered as a potential peak.\\n\\n# Complexity:\\n- The time complexity of the code is O(log n) due to the binary search approach, where n is the size of the input vector `nums`. In each iteration, the search range is halved, resulting in logarithmic time complexity.\\n\\n- The space complexity of the code is O(1) since it uses a constant amount of extra space for the variables `start`, `end`, and `mid`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int start=0,end=nums.size()-1;\\n        while(start<end){\\n            int mid=(start+end)/2;\\n            if(mid==0){\\n                return nums[0] >= nums[1] ? 0 : 1;\\n            }\\n            if (mid == end){\\n                return nums[end - 1] >= nums[end - 2] ? end - 1 : end - 2;\\n            }\\n\\n            if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1]){\\n                return mid;\\n            }\\n            if(nums[mid]<nums[mid-1]){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```\\n# Java\\n```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        int start = 0, end = nums.length - 1;\\n        while (start < end) {\\n            int mid = (start + end) / 2;\\n            if (mid == 0) {\\n                return nums[0] >= nums[1] ? 0 : 1;\\n            }\\n            if (mid == end) {\\n                return nums[end - 1] >= nums[end - 2] ? end - 1 : end - 2;\\n            }\\n\\n            if (nums[mid] > nums[mid + 1] && nums[mid] > nums[mid - 1]) {\\n                return mid;\\n            }\\n            if (nums[mid] < nums[mid - 1]) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n\\n```\\n# Python\\n```\\nclass Solution(object):\\n    def findPeakElement(self, nums):\\n        start = 0\\n        end = len(nums) - 1\\n        while start < end:\\n            mid = (start + end) // 2\\n            if mid == 0:\\n                return 0 if nums[0] >= nums[1] else 1\\n            if mid == end:\\n                return end - 1 if nums[end - 1] >= nums[end - 2] else end - 2\\n\\n            if nums[mid] > nums[mid + 1] and nums[mid] > nums[mid - 1]:\\n                return mid\\n            if nums[mid] < nums[mid - 1]:\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n        return start\\n\\n```\\n# JavaScript\\n```\\nvar findPeakElement = function(nums) {\\n    var start = 0, end = nums.length - 1;\\n    while (start < end) {\\n        var mid = Math.floor((start + end) / 2);\\n        if (mid === 0) {\\n            return nums[0] >= nums[1] ? 0 : 1;\\n        }\\n        if (mid === end) {\\n            return nums[end - 1] >= nums[end - 2] ? end - 1 : end - 2;\\n        }\\n\\n        if (nums[mid] > nums[mid + 1] && nums[mid] > nums[mid - 1]) {\\n            return mid;\\n        }\\n        if (nums[mid] < nums[mid - 1]) {\\n            end = mid - 1;\\n        } else {\\n            start = mid + 1;\\n        }\\n    }\\n    return start;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int start=0,end=nums.size()-1;\\n        while(start<end){\\n            int mid=(start+end)/2;\\n            if(mid==0){\\n                return nums[0] >= nums[1] ? 0 : 1;\\n            }\\n            if (mid == end){\\n                return nums[end - 1] >= nums[end - 2] ? end - 1 : end - 2;\\n            }\\n\\n            if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1]){\\n                return mid;\\n            }\\n            if(nums[mid]<nums[mid-1]){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        int start = 0, end = nums.length - 1;\\n        while (start < end) {\\n            int mid = (start + end) / 2;\\n            if (mid == 0) {\\n                return nums[0] >= nums[1] ? 0 : 1;\\n            }\\n            if (mid == end) {\\n                return nums[end - 1] >= nums[end - 2] ? end - 1 : end - 2;\\n            }\\n\\n            if (nums[mid] > nums[mid + 1] && nums[mid] > nums[mid - 1]) {\\n                return mid;\\n            }\\n            if (nums[mid] < nums[mid - 1]) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def findPeakElement(self, nums):\\n        start = 0\\n        end = len(nums) - 1\\n        while start < end:\\n            mid = (start + end) // 2\\n            if mid == 0:\\n                return 0 if nums[0] >= nums[1] else 1\\n            if mid == end:\\n                return end - 1 if nums[end - 1] >= nums[end - 2] else end - 2\\n\\n            if nums[mid] > nums[mid + 1] and nums[mid] > nums[mid - 1]:\\n                return mid\\n            if nums[mid] < nums[mid - 1]:\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n        return start\\n\\n```\n```\\nvar findPeakElement = function(nums) {\\n    var start = 0, end = nums.length - 1;\\n    while (start < end) {\\n        var mid = Math.floor((start + end) / 2);\\n        if (mid === 0) {\\n            return nums[0] >= nums[1] ? 0 : 1;\\n        }\\n        if (mid === end) {\\n            return nums[end - 1] >= nums[end - 2] ? end - 1 : end - 2;\\n        }\\n\\n        if (nums[mid] > nums[mid + 1] && nums[mid] > nums[mid - 1]) {\\n            return mid;\\n        }\\n        if (nums[mid] < nums[mid - 1]) {\\n            end = mid - 1;\\n        } else {\\n            start = mid + 1;\\n        }\\n    }\\n    return start;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334625,
                "title": "find-peak-element-c-o-logn-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return 0;                   \\\\\\\\ single element is always a peak element\\n\\t\\tif(nums[0]> nums[1]) return 0;     \\\\\\\\ check if first element satisfies the condition\\n        if(nums[n-1] > nums[n-2]) return n-1;    \\\\\\\\ check if last element satisfies the condition\\n        \\n        int left=0,right=nums.size()-1;\\n        \\n        while(left<right){\\n            int mid = left+(right-left)/2;\\n            if(nums[mid]> nums[mid-1] && nums[mid]>nums[mid+1]){    \\\\\\\\check if mid element satisfies the condition\\n                return mid;\\n            }\\n            if(nums[mid] > nums[mid-1] && nums[mid]<nums[mid+1]){      \\n                left = mid+1;     \\\\\\\\move left to mid+1 as nums[mid+1] > nums[mid], thus our answer  lies on right side\\n            }\\n            else{\\n\\t\\t\\t\\tright=mid;         \\\\\\\\ move right to mid as either nums[mid-1] is more than nums[mid] or nums[mid] is more than nums[mid+1] \\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\nUpvote if u like the solution :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return 0;                   \\\\\\\\ single element is always a peak element\\n\\t\\tif(nums[0]> nums[1]) return 0;     \\\\\\\\ check if first element satisfies the condition\\n        if(nums[n-1] > nums[n-2]) return n-1;    \\\\\\\\ check if last element satisfies the condition\\n        \\n        int left=0,right=nums.size()-1;\\n        \\n        while(left<right){\\n            int mid = left+(right-left)/2;\\n            if(nums[mid]> nums[mid-1] && nums[mid]>nums[mid+1]){    \\\\\\\\check if mid element satisfies the condition\\n                return mid;\\n            }\\n            if(nums[mid] > nums[mid-1] && nums[mid]<nums[mid+1]){      \\n                left = mid+1;     \\\\\\\\move left to mid+1 as nums[mid+1] > nums[mid], thus our answer  lies on right side\\n            }\\n            else{\\n\\t\\t\\t\\tright=mid;         \\\\\\\\ move right to mid as either nums[mid-1] is more than nums[mid] or nums[mid] is more than nums[mid+1] \\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527361,
                "title": "python-beats-99",
                "content": "Runtime: **32 ms**, faster than **99.59%** of Python3 online submissions for Find Peak Element.\\nMemory Usage: **12.8** MB, less than **100.00%** of Python3 online submissions for Find Peak Element.\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        low, high = 0, len(nums)-1\\n        while low < high:\\n            mid = low + int((high-low)/2)\\n            if nums[mid] < nums[mid+1]:\\n                low = mid+1\\n            else:\\n                high = mid\\n        return low\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        low, high = 0, len(nums)-1\\n        while low < high:\\n            mid = low + int((high-low)/2)\\n            if nums[mid] < nums[mid+1]:\\n                low = mid+1\\n            else:\\n                high = mid\\n        return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50327,
                "title": "general-binary-search-in-java",
                "content": "We want to check mid and mid+1 elements. `if(nums[mid] < nums[mid+1])`, `lo = mid + 1`, otherwise `hi = mid`.  The reason is that when there are even or odd number of elements, the mid element is always going to have a next one `mid+1`.  We don't need to consider the case when there is less than 1 element as it is not valid case for this problem.  Finally we return `lo` as it will always be a solution since it goes to `mid+1` element in the first case, which is larger.\\n\\n    public int findPeakElement(int[] nums) {\\n        int n = nums.length;\\n        int lo = 0, hi = n - 1;\\n        while(lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if(nums[mid] < nums[mid+1]) {\\n                lo = mid + 1; \\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "We want to check mid and mid+1 elements. `if(nums[mid] < nums[mid+1])`, `lo = mid + 1`, otherwise `hi = mid`.  The reason is that when there are even or odd number of elements, the mid element is always going to have a next one `mid+1`.  We don't need to consider the case when there is less than 1 element as it is not valid case for this problem.  Finally we return `lo` as it will always be a solution since it goes to `mid+1` element in the first case, which is larger.\\n\\n    public int findPeakElement(int[] nums) {\\n        int n = nums.length;\\n        int lo = 0, hi = n - 1;\\n        while(lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if(nums[mid] < nums[mid+1]) {\\n                lo = mid + 1; \\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1440424,
                "title": "python-easy-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef findPeakElement(self, lst: List[int]) -> int:\\n\\t\\t\\tstart, end = 0, len(lst) - 1\\n\\n\\t\\t\\twhile start < end:\\n\\n\\t\\t\\t\\tmid = start + (end - start) // 2\\n\\n\\t\\t\\t\\tif lst[mid] > lst[mid + 1]:\\n\\t\\t\\t\\t\\tend = mid\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstart = mid + 1\\n\\n\\t\\t\\treturn start\\n\\n# if you like the solution, Please upvote!!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef findPeakElement(self, lst: List[int]) -> int:\\n\\t\\t\\tstart, end = 0, len(lst) - 1\\n\\n\\t\\t\\twhile start < end:\\n\\n\\t\\t\\t\\tmid = start + (end - start) // 2\\n\\n\\t\\t\\t\\tif lst[mid] > lst[mid + 1]:\\n\\t\\t\\t\\t\\tend = mid\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstart = mid + 1\\n\\n\\t\\t\\treturn start\\n\\n# if you like the solution, Please upvote!!",
                "codeTag": "Java"
            },
            {
                "id": 2652658,
                "title": "intution-and-thought-behind-the-soln-binary-search-c-3ms-solution-o-1-space-o-log-n-tc",
                "content": "The thought behind the solutiuon is interesting .Consider any arbitiary independent array ,you will find one thing that the array always has one peak elemnt doesn\\'t matter if it is sorted or not, if it is sorted in decreasing manner the leftmost elemnt is the peak elemnt and for increasing manner the right most will be the peak elment . \\n\\nSo now if we find the mid point of the array and check that which of his neighbour is bigger or equal to the mid elemnt , by finding out which neighbour element is bigger we are making sure that one peak element defineatly exist on the side of that neighbour element.\\nfor example [1,2,1,3,5,6,4] if we take the middle element 3 we will check it with 1 and 5 , 5 is  obviousley bigger than 3 , this makes sure that a peak elemnt defineatly lies in the right side of the array (1,2,1,3,**5,6,4**] , here 6 is the peak element.\\n**If you understood please drop a like.**\\n**here is the full code** --- \"HAPPY CODING\"\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& a) {\\n        int n=a.size();\\n        int low=0,hig=n-1;\\n        while(low<=hig){\\n            int mid=(low+hig)/2;\\n            if((mid==0||a[mid]>=a[mid-1])&&(mid==n-1||a[mid]>=a[mid+1])){\\n                return mid;\\n            }\\n            else if(mid>0&&a[mid]<=a[mid-1]){\\n                hig=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& a) {\\n        int n=a.size();\\n        int low=0,hig=n-1;\\n        while(low<=hig){\\n            int mid=(low+hig)/2;\\n            if((mid==0||a[mid]>=a[mid-1])&&(mid==n-1||a[mid]>=a[mid+1])){\\n                return mid;\\n            }\\n            else if(mid>0&&a[mid]<=a[mid-1]){\\n                hig=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1720863,
                "title": "c-binary-search-image-explanation-o-log-n",
                "content": "This is a beautiful question on \"Binary Search on answer\". In \"BS on Ans\" question, we generally need to conclude 2 things. \\n1. Analyse criteria for selecting mid or not\\n2. Analyse criteria for going LEFT or RIGHT sub-array\\n\\n**The image explanation is as follows :**\\n\\n![image](https://assets.leetcode.com/users/images/ddd28e81-e956-4801-851b-c01cabfb8821_1643186320.1767843.jpeg)\\n\\n**CODE :**\\n\\n```\\n    int findPeakElement(vector<int>& nums) {\\n        int low=0; int high= nums.size()-1;\\n        \\n        while(low<=high){\\n            int mid= low+ (high-low)/2;\\n            \\n            if( (mid==0 || nums[mid-1]<nums[mid]) && (mid==nums.size()-1 || nums[mid+1]<nums[mid]) ){\\n                return mid;\\n            }\\n            else if(mid-1>=0 && nums[mid-1]>nums[mid]){ // go to left\\n                high= mid-1;\\n            }\\n            else if(mid+1<=nums.size()-1 && nums[mid+1]>nums[mid]){ // got to right               \\n                low= mid+1;\\n            }\\n        }\\n        return 0; // useless, just for the sake of returning any integer\\n    }\\n```\\n\\nTime Complexity: O(logn)\\nSpace Complexity: O(1)\\n\\nHope this solution helpes. If you have furthur query, don\\'t hesitate to ask in comments !\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n    int findPeakElement(vector<int>& nums) {\\n        int low=0; int high= nums.size()-1;\\n        \\n        while(low<=high){\\n            int mid= low+ (high-low)/2;\\n            \\n            if( (mid==0 || nums[mid-1]<nums[mid]) && (mid==nums.size()-1 || nums[mid+1]<nums[mid]) ){\\n                return mid;\\n            }\\n            else if(mid-1>=0 && nums[mid-1]>nums[mid]){ // go to left\\n                high= mid-1;\\n            }\\n            else if(mid+1<=nums.size()-1 && nums[mid+1]>nums[mid]){ // got to right               \\n                low= mid+1;\\n            }\\n        }\\n        return 0; // useless, just for the sake of returning any integer\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 144068,
                "title": "python-for-humans",
                "content": "### 162. Find Peak Element\\n```\\n\\u7C7B\\u578B\\uFF1A\\u8003\\u8651\\u8FB9\\u754C \\nTime Complexity (logN )\\nTime Spent on this question: 50 mins | \\u91CD\\u5237\\n```\\n\\n\\u8FD9\\u9898\\u5957\\u60EF\\u7528\\u7684\\u6A21\\u677F\\u8981\\u8003\\u8651Edge Case\\uFF0C\\u56E0\\u4E3A\\u5224\\u5B9A\\u6761\\u4EF6\\u662F:\\n\\n\\u4E0A\\u5761\\uFF1A`nums[mid-1] < nums[mid]`\\n\\u4E0B\\u5761\\uFF1A `nums[mid] > nums[mid+1]`\\n\\n\\u7136\\u540E\\u8FD9\\u91CCmid + 1 \\u548C mid - 1\\u5728\\u6570\\u7EC4\\u5927\\u5C0F\\u4E3A 1 \\u6216\\u8005 2\\u7684\\u65F6\\u5019\\uFF0C\\u5F88\\u5BB9\\u6613\\u5C31\\u8D8A\\u754C\\u4E86\\uFF0C\\u6240\\u4EE5\\u5728\\u5927\\u5C0F\\u8303\\u56F4\\u589E\\u52A0\\u6700\\u5C0F\\u503C\\u548C\\u6700\\u5927\\u503C\\u3002\\u5F97\\u5230\\uFF1A\\n`if (mid == 0 or nums[mid-1] < nums[mid]) and (mid == len(nums) - 1 or nums[mid] > nums[mid+1]):`\\n\\n\\n```\\nclass Solution(object):\\n    def findPeakElement(self, nums):\\n        l, r = 0, len(nums) - 1\\n        while l <= r:\\n            mid = l + (r-l) // 2\\n            if (mid == 0 or nums[mid-1] < nums[mid]) and (mid == len(nums) - 1 or nums[mid] > nums[mid+1]):\\n                return mid;\\n            if nums[mid] < nums[mid+1]:\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n```\\n\\n\\u8FD9\\u9053\\u9898\\u76EE\\u4E5F\\u53EF\\u4EE5\\u5957\\u53E6\\u5916\\u4E00\\u4E2A\\u6A21\\u677F\\uFF0C\\u53EF\\u4EE5\\u4E0D\\u7528\\u8003\\u8651\\u8D8A\\u754C\\u7684\\u95EE\\u9898\\uFF1A\\n\\n```\\nclass Solution(object):\\n    def findPeakElement(self, nums):\\n        l, r = 0, len(nums) - 1\\n        while l < r:\\n            mid = l + (r-l) // 2\\n            if nums[mid] < nums[mid+1]:\\n                l = mid + 1\\n            else:\\n                r = mid \\n        return l\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\u7C7B\\u578B\\uFF1A\\u8003\\u8651\\u8FB9\\u754C \\nTime Complexity (logN )\\nTime Spent on this question: 50 mins | \\u91CD\\u5237\\n```\n```\\nclass Solution(object):\\n    def findPeakElement(self, nums):\\n        l, r = 0, len(nums) - 1\\n        while l <= r:\\n            mid = l + (r-l) // 2\\n            if (mid == 0 or nums[mid-1] < nums[mid]) and (mid == len(nums) - 1 or nums[mid] > nums[mid+1]):\\n                return mid;\\n            if nums[mid] < nums[mid+1]:\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n```\n```\\nclass Solution(object):\\n    def findPeakElement(self, nums):\\n        l, r = 0, len(nums) - 1\\n        while l < r:\\n            mid = l + (r-l) // 2\\n            if nums[mid] < nums[mid+1]:\\n                l = mid + 1\\n            else:\\n                r = mid \\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50405,
                "title": "c-binary-search",
                "content": "The logarithmic time complexity suggests to use binary search.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int n = nums.size(), l = 0, r = n - 1;\\n        while (l < r) {\\n            int m = (l + r) / 2, mr = m + 1;\\n            if (nums[m] < nums[mr]) {\\n                l = mr;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```\\n\\nThis *peak finding* problem has some variations and becomes more challenging in higher dimensions. You may refer to [this video](https://www.youtube.com/watch?v=HtSuA80QTyo) if you would like to learn more.",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int n = nums.size(), l = 0, r = n - 1;\\n        while (l < r) {\\n            int m = (l + r) / 2, mr = m + 1;\\n            if (nums[m] < nums[mr]) {\\n                l = mr;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50387,
                "title": "java-binary-search-solution",
                "content": "public class Solution {\\n    public int findPeakElement(int[] num) {\\n        int l = 0;\\n        int r = num.length-1;\\n        int mid = r/2;\\n        while (l<r){\\n            if(num[mid]<num[mid+1]){\\n                l=mid+1;\\n            }else{\\n                r=mid;\\n            }\\n            mid=(l+r)/2;\\n        }\\n        return l;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int findPeakElement(int[] num) {\\n        int l = 0;\\n        int r = num.length-1;\\n        int mid = r/2;\\n        while (l<r){\\n            if(num[mid]<num[mid+1]){\\n                l=mid+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3208776,
                "title": "162-96-79-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution uses a binary search algorithm to find the peak element in O(log n) time. It starts by initializing the left and right pointers to the first and last indices of the array, respectively. It then enters a loop that continues until the left and right pointers converge on a single index.\\n\\nIn each iteration of the loop, the mid index is computed as the average of the left and right pointers. If the element at the mid index is greater than the element at the next index (i.e., nums[mid] > nums[mid+1]), then the peak element must be in the left half of the array, so the right pointer is updated to mid. Otherwise, the peak element must be in the right half of the array, so the left pointer is updated to mid+1.\\n\\nAt the end of the loop, the left pointer points to the peak element, so it is returned as the result.\\n\\nThis algorithm works because if the element at the mid index is not the peak element, then the array must be ascending to the right of the mid index (i.e., nums[mid] < nums[mid+1]). Therefore, the peak element must be in the right half of the array. Similarly, if the element at the mid index is greater than the element at the next index, then the array must be descending to the right of the mid index, so the peak element must be in the left half of the array. By repeating this process with the appropriate half of the array at each step, the algorithm converges on the peak element in O(log n) time.\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n96.79%\\n\\n- Space complexity:\\nBeats\\n76.40%\\n# Code\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        left, right = 0, len(nums)-1\\n        \\n        while left < right:\\n            mid = (left + right) // 2\\n            if nums[mid] > nums[mid+1]:\\n                right = mid\\n            else:\\n                left = mid + 1\\n                \\n        return left\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        left, right = 0, len(nums)-1\\n        \\n        while left < right:\\n            mid = (left + right) // 2\\n            if nums[mid] > nums[mid+1]:\\n                right = mid\\n            else:\\n                left = mid + 1\\n                \\n        return left\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756081,
                "title": "java-100-faster-solution-very-simple-approach-7-lines-only",
                "content": "# Intuition\\nSinmple binary search intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\napproach it like a array with two blocks ( one increasing segment and the other one decreasing). If the mid pointer is in the decreasing part end pointer comes to mid. and it comes till the end pointer reaches the peak element. And if th mid pointer is in the increasing segment the  start pointer comes to the mid position and the binary searches conmtinues till peak found. At peak fount the start and the end pointer both points to the peak element so we return the start index here.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findPeakElement(int[] arr) {\\n         int start = 0;\\n        int end = arr.length - 1;\\n        while (start < end) {\\n//             find the middle element\\n            int mid = start + (end - start) / 2;\\n            if (arr[mid] > arr[mid + 1]) {\\n                end = mid;\\n            } else if (arr[mid] < arr[mid + 1]) {\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n<!-- PLEASE UPVOTE  -->\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findPeakElement(int[] arr) {\\n         int start = 0;\\n        int end = arr.length - 1;\\n        while (start < end) {\\n//             find the middle element\\n            int mid = start + (end - start) / 2;\\n            if (arr[mid] > arr[mid + 1]) {\\n                end = mid;\\n            } else if (arr[mid] < arr[mid + 1]) {\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n<!-- PLEASE UPVOTE  -->\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609368,
                "title": "c-93-faster-linear-search-binary-search-one-liner",
                "content": "```\\nif(liked(\\u2764\\uFE0F)==true) Upvote(\\u2B06\\uFE0F);\\nelse Comment(\\uD83D\\uDCDD);\\nreturn Thank You\\uD83D\\uDE01;\\n```\\n**1. Linear Search :**\\n**`Time Complexity : O(n)`**\\n**`Space Complexity : O(1)`**\\n```\\nint findPeakElement(vector<int>& nums) {\\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i]>nums[i+1])return i;\\n        }\\n        return nums.size()-1;\\n    }\\n```\\n\\n**2. Binary Search :**\\n**`Time Complexity : O(logn)`**\\n**`Space Complexity : O(1)`**\\n```\\nint findPeakElement(vector<int>& nums) {\\n        int i=0, j=nums.size()-1, mid;\\n        while(i<j){\\n            mid=(i+j)/2;\\n            if(nums[mid]>nums[mid+1])j=mid;\\n            else i=mid+1;\\n        }\\n        return i;\\n    }\\n```\\n\\n**3. One Liner :**\\n**`Time Complexity : O(n)`**\\n**`Space Complexity : O(1)`**\\n```\\nint findPeakElement(vector<int>& nums) {\\n        return max_element(nums.begin(), nums.end())-nums.begin();\\n    }\\n```\\n***Liked it? Please Upvote!\\nHappy Coding :)***\\n\\n![image](https://assets.leetcode.com/users/images/a2b12a7d-04ea-4275-97da-35281b49f3fc_1663835919.2018082.jpeg)\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nif(liked(\\u2764\\uFE0F)==true) Upvote(\\u2B06\\uFE0F);\\nelse Comment(\\uD83D\\uDCDD);\\nreturn Thank You\\uD83D\\uDE01;\\n```\n```\\nint findPeakElement(vector<int>& nums) {\\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i]>nums[i+1])return i;\\n        }\\n        return nums.size()-1;\\n    }\\n```\n```\\nint findPeakElement(vector<int>& nums) {\\n        int i=0, j=nums.size()-1, mid;\\n        while(i<j){\\n            mid=(i+j)/2;\\n            if(nums[mid]>nums[mid+1])j=mid;\\n            else i=mid+1;\\n        }\\n        return i;\\n    }\\n```\n```\\nint findPeakElement(vector<int>& nums) {\\n        return max_element(nums.begin(), nums.end())-nums.begin();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1735299,
                "title": "elegant-python-solution-good-comments-o-logn",
                "content": "```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        \\n        l, r = 0, len(nums) - 1\\n        \\n        while l <= r:\\n            m = (l + r) // 2\\n            \\n            # if we access out of bounds, set to negative infinity\\n            leftVal = nums[m - 1] if m - 1 >= 0 else float(\"-inf\")\\n            rightVal = nums[m + 1] if m + 1 < len(nums) else float(\"-inf\")\\n            \\n            # if nums[m] is a local maxima, return m (index)\\n            if nums[m] > leftVal and nums[m] > rightVal:\\n                return m\\n            \\n            # if nums is increasing from m to m + 1\\n            # search in that direction\\n            if nums[m] < nums[m + 1]:\\n                l = m + 1\\n            # otherwise, there is two cases. One is that\\n            # this is a local minima and both other sides are\\n            # higher, in which case it doesn\\'t matter which way we search because either\\n            # will have a solution. Otherwise, nums[m - 1] is greater than nums[m] but nums[m + 1]\\n            # is not, in which case the lefthand side will again have a valid result\\n            else:\\n                r = m - 1\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        \\n        l, r = 0, len(nums) - 1\\n        \\n        while l <= r:\\n            m = (l + r) // 2\\n            \\n            # if we access out of bounds, set to negative infinity\\n            leftVal = nums[m - 1] if m - 1 >= 0 else float(\"-inf\")\\n            rightVal = nums[m + 1] if m + 1 < len(nums) else float(\"-inf\")\\n            \\n            # if nums[m] is a local maxima, return m (index)\\n            if nums[m] > leftVal and nums[m] > rightVal:\\n                return m\\n            \\n            # if nums is increasing from m to m + 1\\n            # search in that direction\\n            if nums[m] < nums[m + 1]:\\n                l = m + 1\\n            # otherwise, there is two cases. One is that\\n            # this is a local minima and both other sides are\\n            # higher, in which case it doesn\\'t matter which way we search because either\\n            # will have a solution. Otherwise, nums[m - 1] is greater than nums[m] but nums[m + 1]\\n            # is not, in which case the lefthand side will again have a valid result\\n            else:\\n                r = m - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633082,
                "title": "c-one-liner-binary-search-linear-solution",
                "content": "Linear Approach:\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        for(int i = 1; i < nums.size(); i++)\\n        {\\n            if(nums[i] < nums[i - 1]) return i - 1;\\n        }\\n        return nums.size() - 1;\\n    }\\n};\\n```\\nBinary-Search:\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int mid, left = 0, right = nums.size() - 1;\\n        while(left < right)\\n        {\\n            mid = left + (right - left) / 2;\\n            if(nums[mid] > nums[mid + 1])\\n            right = mid;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n```\\nOne-Liner:\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        return max_element(nums.begin(), nums.end()) - nums.begin();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        for(int i = 1; i < nums.size(); i++)\\n        {\\n            if(nums[i] < nums[i - 1]) return i - 1;\\n        }\\n        return nums.size() - 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int mid, left = 0, right = nums.size() - 1;\\n        while(left < right)\\n        {\\n            mid = left + (right - left) / 2;\\n            if(nums[mid] > nums[mid + 1])\\n            right = mid;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        return max_element(nums.begin(), nums.end()) - nums.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50433,
                "title": "my-o-log-n-java-solution-using-binary-search",
                "content": "    public class Solution {\\n        public int findPeakElement(int[] num) {\\n            for (int i = 0, j = num.length - 1, mid = j / 2; i < j; mid = (i + j) / 2) {\\n                if (mid == i) { return num[mid] > num[j] ? mid : j; }\\n                i = num[mid] < num[mid + 1] ? mid : i;\\n                j = num[mid] > num[mid + 1] ? mid : j;\\n            }\\n            return 0;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        public int findPeakElement(int[] num) {\\n            for (int i = 0, j = num.length - 1, mid = j / 2; i < j; mid = (i + j) / 2) {\\n                if (mid == i) { return num[mid] > num[j] ? mid : j; }",
                "codeTag": "Java"
            },
            {
                "id": 50373,
                "title": "my-logn-answer-in-c",
                "content": "    class Solution {\\n    public:\\n        int findPeakElement(vector<int>& nums) \\n        {\\n            if(nums.size() <= 1)\\n                return 0;\\n            return peakIndex(nums, 0, nums.size() - 1);\\n        }\\n        \\n        int peakIndex(vector<int>& nums, int begin, int end)\\n        {\\n            if(begin > end)\\n                return -1;\\n            int mid = (begin + end) / 2;\\n            int left = (mid - 1) < 0 ? INT_MIN : nums[mid - 1];\\n            int right = (mid + 1) > (nums.size() - 1) ? INT_MIN : nums[mid + 1];\\n            \\n            if(nums[mid] > right && nums[mid] > left)\\n                return mid;\\n            if(mid > 0 && nums[mid - 1] > nums[mid])\\n                return peakIndex(nums, begin, mid - 1);\\n            else\\n                return peakIndex(nums, mid + 1, end);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int findPeakElement(vector<int>& nums) \\n        {\\n            if(nums.size() <= 1)\\n                return 0;\\n            return peakIndex(nums, 0, nums.size() - 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3713239,
                "title": "binary-search-c-solution-o-log-n-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nI have used binary search to solve this question.\\nfirst of all we should know there are three cases for a element to be the peak element .\\n1st case : when mid is at index 0 and and arr[0] > arr[1]\\n2nd case : when mid is at the last index and arr[arr.size() - 1] > arr[arr.size() - 2]\\n3rd case : when mid is somewhere in between and mid is greater then its left element and right .\\nNow considering these cases i just solved accordingly by shifting start and end.\\n# Complexity\\n- Time complexity:\\nO(log n)\\n\\n- Space complexity:\\n- O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        if (nums.size() == 1) {\\n            return 0;\\n        }\\n        if (nums.size() == 2) {\\n            if (nums[0] > nums[1]) {\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        \\n        int end = nums.size() - 1;\\n        int start = 0;\\n        \\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            \\n            if ((mid == 0 || nums[mid] > nums[mid - 1]) &&\\n                (mid == nums.size() - 1 || nums[mid] > nums[mid + 1])) {\\n                return mid;\\n            }\\n            else if (mid > 0 && nums[mid - 1] > nums[mid]) {\\n                end = mid - 1;\\n            }\\n            else {\\n                start = mid + 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        if (nums.size() == 1) {\\n            return 0;\\n        }\\n        if (nums.size() == 2) {\\n            if (nums[0] > nums[1]) {\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        \\n        int end = nums.size() - 1;\\n        int start = 0;\\n        \\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            \\n            if ((mid == 0 || nums[mid] > nums[mid - 1]) &&\\n                (mid == nums.size() - 1 || nums[mid] > nums[mid + 1])) {\\n                return mid;\\n            }\\n            else if (mid > 0 && nums[mid - 1] > nums[mid]) {\\n                end = mid - 1;\\n            }\\n            else {\\n                start = mid + 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878126,
                "title": "python-99-68-faster-binary-search-o-logn-solution",
                "content": "```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        if n==1 or nums[0]>nums[1]:\\n            return 0\\n        elif nums[n-1]>nums[n-2]:\\n            return n-1\\n        l,h=0,n-1\\n        while l<=h:\\n            m=(l+h)>>1\\n            if nums[m]>nums[m+1] and nums[m]>nums[m-1]:\\n                return m\\n            elif nums[m]>nums[m+1]:\\n                h=m-1\\n            else:\\n                l=m+1 \\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        if n==1 or nums[0]>nums[1]:\\n            return 0\\n        elif nums[n-1]>nums[n-2]:\\n            return n-1\\n        l,h=0,n-1\\n        while l<=h:\\n            m=(l+h)>>1\\n            if nums[m]>nums[m+1] and nums[m]>nums[m-1]:\\n                return m\\n            elif nums[m]>nums[m+1]:\\n                h=m-1\\n            else:\\n                l=m+1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763049,
                "title": "c-binary-search-o-logn",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int left=0, right = nums.size()-1;\\n        while(left<right){\\n            int mid=(left+right)/2;\\n            if(nums[mid]<nums[mid+1]) left =mid+1;\\n            else right=mid;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int left=0, right = nums.size()-1;\\n        while(left<right){\\n            int mid=(left+right)/2;\\n            if(nums[mid]<nums[mid+1]) left =mid+1;\\n            else right=mid;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120747,
                "title": "python-o-log-n-expanation",
                "content": "**UPVOTE IF HELPFUL**\\n\\nIf peak , **return mid**\\nIf slope is increasing , **low = mid + 1**\\nif decreasing , **high = mid**\\n\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        \\n        if len(nums)==1:\\n            return 0\\n        if nums[0]>nums[1]:\\n            return 0\\n        if nums[-1]>nums[-2]:\\n            return len(nums)-1\\n        \\n        l=1\\n        h=len(nums)-1\\n        while l<h:\\n            m=(l+h)//2\\n            if nums[m-1]<nums[m]>nums[m+1]:\\n                return m\\n            elif nums[m-1]<nums[m]<nums[m+1]:\\n                l=m+1\\n            else:\\n                h=m\\n            \\n        return l\\n```\\n![image](https://assets.leetcode.com/users/images/80863752-c737-4a56-b5b1-c9afe2ea39bb_1654576854.5137992.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        \\n        if len(nums)==1:\\n            return 0\\n        if nums[0]>nums[1]:\\n            return 0\\n        if nums[-1]>nums[-2]:\\n            return len(nums)-1\\n        \\n        l=1\\n        h=len(nums)-1\\n        while l<h:\\n            m=(l+h)//2\\n            if nums[m-1]<nums[m]>nums[m+1]:\\n                return m\\n            elif nums[m-1]<nums[m]<nums[m+1]:\\n                l=m+1\\n            else:\\n                h=m\\n            \\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633045,
                "title": "hehehehe-1-liner-linear-binary",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        \\n        int left = 0 , right = nums.size() - 1;\\n        \\n        while(left<right)\\n        {\\n            int mid = left + (right - left)/2;\\n            \\n            if(nums[mid] > nums[mid+1])\\n               right = mid; \\n            \\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        \\n        for(int index = 1 ; index < nums.size() ; index++ )\\n        {\\n            if(nums[index] < nums[index-1]) return index - 1;\\n        }\\n        return nums.size() - 1;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n                return max_element(nums.begin(), nums.end()) - nums.begin();\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        \\n        int left = 0 , right = nums.size() - 1;\\n        \\n        while(left<right)\\n        {\\n            int mid = left + (right - left)/2;\\n            \\n            if(nums[mid] > nums[mid+1])\\n               right = mid; \\n            \\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        \\n        for(int index = 1 ; index < nums.size() ; index++ )\\n        {\\n            if(nums[index] < nums[index-1]) return index - 1;\\n        }\\n        return nums.size() - 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n                return max_element(nums.begin(), nums.end()) - nums.begin();\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336395,
                "title": "java-runtime-0-ms-o-log-n-solution-with-explanation",
                "content": "It is possible to find the solution in O(log(n)) because of constraints  nums[i] != nums[i + 1] for all valid i.\\n\\nFor boundry point you may imagine that  nums[-1] = nums[n] = -\\u221E.\\n\\nLet consider the two situation :\\n1. Array element are in incresing order\\n   nums = [1, 2, 3, 4, 5, 6]  in this case answer is in the right side.\\n   consider the subarray [4, 5, 6] in this case also answer is in right side.\\n   \\n2. Array element are in decresing order\\n   nums = [6, 5, 4, 3, 2, 1]  in this case answer is in the left side.\\n   consider the subarray [6, 5, 4] in this case also answer is in left side.\\n   \\n  ``` conclusion :  we have to keep moving in the direction of  increasing sub-Array. ```\\n   \\n   Now consider an example where nums = [1,2,1,3,5,6,4]   pick out the mid element, and check which side array is growing.\\n   In this case we will move 3->5->6 and answer will be the index of 6.\\n   \\n   Take another example : [1, 4, 3, 2, 1, 6, 4] : in this case as middle element is greater than next element of middle. hence we will move in the left of middle 2->3->4 and answer will be index of 4.\\n   \\n   ```Please upvote guys```\\n   \\n   ```\\n   class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int start = 0, end = nums.length-1;\\n        \\n        while(start < end)\\n        {\\n            int mid = (start + end)/2;\\n            \\n            if(nums[mid] < nums[mid + 1])\\n                start = mid+1;\\n            else\\n                end = mid;\\n        }\\n        \\n        return end;\\n    }\\n}\\n   ```\\n\\n",
                "solutionTags": [],
                "code": "``` conclusion :  we have to keep moving in the direction of  increasing sub-Array. ```\n```Please upvote guys```\n```\\n   class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int start = 0, end = nums.length-1;\\n        \\n        while(start < end)\\n        {\\n            int mid = (start + end)/2;\\n            \\n            if(nums[mid] < nums[mid + 1])\\n                start = mid+1;\\n            else\\n                end = mid;\\n        }\\n        \\n        return end;\\n    }\\n}\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 3810672,
                "title": "python-easy-solution-using-binary-search",
                "content": "```\\nclass Solution:\\n    def findPeakElement(self, nums):\\n        # If the array contains only one element, it is the peak.\\n        if len(nums) == 1:\\n            return 0\\n        \\n        # Check if the first element is greater than the second,\\n        # if so, the first element is a peak.\\n        if nums[0] > nums[1]:\\n            return 0\\n        \\n        # Check if the last element is greater than the second-to-last,\\n        # if so, the last element is a peak.\\n        if nums[len(nums) - 1] > nums[len(nums) - 2]:\\n            return len(nums) - 1\\n        \\n        # Now, use binary search to find the peak element.\\n        # Set two pointers i and j to the second and second-to-last elements,\\n        # respectively, because we already checked the first and last elements.\\n        i = 1\\n        j = len(nums) - 2\\n        \\n        while i <= j:\\n            # Calculate the middle index.\\n            mid = i + (j - i) // 2\\n            \\n            # If the middle element is greater than its neighbors, it\\'s a peak.\\n            if nums[mid] > nums[mid + 1] and nums[mid] > nums[mid - 1]:\\n                return mid\\n            elif nums[mid - 1] < nums[mid]:\\n                #If the element to the left of mid is less than mid, \\n\\t\\t\\t\\t#It indicates that the peak could be on either the left or right side of mid.\\n                i = mid + 1\\n            else:\\n                j = mid - 1\\n        \\n        # If no peak is found, return None.\\n        return None\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findPeakElement(self, nums):\\n        # If the array contains only one element, it is the peak.\\n        if len(nums) == 1:\\n            return 0\\n        \\n        # Check if the first element is greater than the second,\\n        # if so, the first element is a peak.\\n        if nums[0] > nums[1]:\\n            return 0\\n        \\n        # Check if the last element is greater than the second-to-last,\\n        # if so, the last element is a peak.\\n        if nums[len(nums) - 1] > nums[len(nums) - 2]:\\n            return len(nums) - 1\\n        \\n        # Now, use binary search to find the peak element.\\n        # Set two pointers i and j to the second and second-to-last elements,\\n        # respectively, because we already checked the first and last elements.\\n        i = 1\\n        j = len(nums) - 2\\n        \\n        while i <= j:\\n            # Calculate the middle index.\\n            mid = i + (j - i) // 2\\n            \\n            # If the middle element is greater than its neighbors, it\\'s a peak.\\n            if nums[mid] > nums[mid + 1] and nums[mid] > nums[mid - 1]:\\n                return mid\\n            elif nums[mid - 1] < nums[mid]:\\n                #If the element to the left of mid is less than mid, \\n\\t\\t\\t\\t#It indicates that the peak could be on either the left or right side of mid.\\n                i = mid + 1\\n            else:\\n                j = mid - 1\\n        \\n        # If no peak is found, return None.\\n        return None\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291626,
                "title": "easy-to-understand-c-solution-using-binary-search-o-log-n-o-1",
                "content": "# Complexity\\n- Time complexity: $$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int FindPeakElement(int[] nums)\\n    {\\n        var left = 0;\\n        var right = nums.Length - 1;\\n\\n        while (left + 1 < right)\\n        {\\n            var mid = left + (right - left) / 2;\\n\\n            if (nums[mid] < nums[mid + 1])\\n            {\\n                left = mid;\\n            }\\n            else\\n            {\\n                right = mid;\\n            }\\n        }\\n\\n        return nums[left] > nums[right] ? left : right;\\n    }\\n}\\n```\\n\\n![pleaseupvote.jpg](https://assets.leetcode.com/users/images/0b723d0a-4b16-4638-a5b1-47952a45c55f_1678702369.4087837.jpeg)\\n",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int FindPeakElement(int[] nums)\\n    {\\n        var left = 0;\\n        var right = nums.Length - 1;\\n\\n        while (left + 1 < right)\\n        {\\n            var mid = left + (right - left) / 2;\\n\\n            if (nums[mid] < nums[mid + 1])\\n            {\\n                left = mid;\\n            }\\n            else\\n            {\\n                right = mid;\\n            }\\n        }\\n\\n        return nums[left] > nums[right] ? left : right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181321,
                "title": "python-binary-search-explained-with-illustrations",
                "content": "# \\u2705 Upvote if it helps!\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findPeakElement(self, nums):\\n        nums.insert(0, float(\\'-inf\\'))\\n        nums.append(float(\\'-inf\\'))\\n        \\n        l, h = 1, len(nums) - 2\\n        while l <= h:\\n            mid = (l + h) // 2\\n            if nums[mid] > nums[mid-1] and nums[mid] > nums[mid+1]:\\n                return mid - 1\\n            elif nums[mid] > nums[mid-1]:\\n                l = mid + 1\\n            else:\\n                h = mid - 1\\n         \\n```\\n\\n# Explanations\\n<!-- Describe your approach to solving the problem. -->\\n- We can first implement: ```nums[-1] = nums[n] = -\\u221E```\\n- The required ```O(log(n))``` allows us to identify that we should use a binary search.\\n- We define ```l``` and ```h``` which are the *low* and *high* pointers.\\n    - **Don\\'t forget that we begin at ```1``` and that we finish at ```len(nums) - 2``` because we have to take into account the -\\u221E that we added.**\\n- We calculate ```mid```, the *middle* pointer.\\n- We can represent our list on xy axes:\\n<p align=\"center\">\\n    <img src=\"https://assets.leetcode.com/users/images/47d1401e-2a72-4e28-ae1f-ed3f77e62e52_1676304376.3499565.png\" alt=\"drawing\" width=\"350\"/>\\n</p>\\n\\n- First, we check if ```nums[mid]``` is a peak. \\n    - If it\\'s one, we return ```mid-1``` because of the ```-\\u221E``` that we added at the beginning.   \\n- If not, we need to know if we are on an increasing or decreasing part of our curve (by comparing its value to its neighbors).\\n\\n<p align=\"center\">\\n    <img src=\"https://assets.leetcode.com/users/images/9c65d4cb-0f2f-442d-90bf-7e920fc1cd38_1676304639.386689.png\" alt=\"drawing\" width=\"350\"/>\\n</p>\\n\\n- We have **2 cases**:\\n    - **Increasing part:** It means that we have a peak in the right part, so we can update ```l = mid + 1```  \\n    -  **Decreasing part:** It means that we have passed a peak, so we have one in the left part. We can update ```h = mid - 1```\\n\\n- We iterate until ```nums[mid]``` is a peak.\\n- We are sure to find a solution thanks to the -\\u221E that we added at the end and at the beginning. \\n\\n\\n\\n\\n# Complexity\\n- Time complexity: O(log(n))\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def findPeakElement(self, nums):\\n        nums.insert(0, float(\\'-inf\\'))\\n        nums.append(float(\\'-inf\\'))\\n        \\n        l, h = 1, len(nums) - 2\\n        while l <= h:\\n            mid = (l + h) // 2\\n            if nums[mid] > nums[mid-1] and nums[mid] > nums[mid+1]:\\n                return mid - 1\\n            elif nums[mid] > nums[mid-1]:\\n                l = mid + 1\\n            else:\\n                h = mid - 1\\n         \\n```\n```nums[-1] = nums[n] = -\\u221E```\n```O(log(n))```\n```l```\n```h```\n```1```\n```len(nums) - 2```\n```mid```\n```nums[mid]```\n```mid-1```\n```-\\u221E```\n```l = mid + 1```\n```h = mid - 1```\n```nums[mid]```",
                "codeTag": "Java"
            },
            {
                "id": 3050450,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sol(vector<int>& nums, int l, int h)\\n    {\\n        while(l<=h)\\n        {\\n            int m=(l+h)/2;\\n            if(m==0 && nums[m]>nums[m+1])\\n            return m;\\n            if(m==nums.size()-1 && nums[nums.size()-1]>nums[nums.size()-2])\\n            return m;\\n            if(nums[m]>nums[m+1] && nums[m]>nums[m-1])\\n            return m;\\n            if(nums[m+1]> nums[m])\\n            l=m+1;\\n            else \\n            h=m-1;\\n        }\\n        return l;\\n    }\\n    int findPeakElement(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n        return 0;\\n\\n       return sol(nums, 0, n-1);\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sol(vector<int>& nums, int l, int h)\\n    {\\n        while(l<=h)\\n        {\\n            int m=(l+h)/2;\\n            if(m==0 && nums[m]>nums[m+1])\\n            return m;\\n            if(m==nums.size()-1 && nums[nums.size()-1]>nums[nums.size()-2])\\n            return m;\\n            if(nums[m]>nums[m+1] && nums[m]>nums[m-1])\\n            return m;\\n            if(nums[m+1]> nums[m])\\n            l=m+1;\\n            else \\n            h=m-1;\\n        }\\n        return l;\\n    }\\n    int findPeakElement(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n        return 0;\\n\\n       return sol(nums, 0, n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395992,
                "title": "clean-simple-python3-faster-than-99-9-10-lines",
                "content": "![image](https://assets.leetcode.com/users/images/5796320e-742f-400a-a122-cd1813df3ab7_1659932244.513745.png)\\nPlease upvote if it helps :)\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        start, end = 0, len(nums) - 1\\n        nums.append(float(\\'-inf\\')) # index -1 and n will both get this in python\\n        while start <= end: # binary search to eliminate half each time\\n            mid = (start + end) // 2\\n            if nums[mid - 1] < nums[mid] and nums[mid] > nums[mid + 1]:\\n                return mid\\n            if nums[mid - 1] > nums[mid]:\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n```\\nExplanation:\\n\\nWe will binary search and look at 3 elements each time:\\n\\n3 cases:\\n```\\n1. \\n\\t #\\n   # # #     if the middle element is already larger than both neighbors (including the edge cases), return mid\\n        \\n2. \\n\\t # \\n     # #\\n     # # #   if we see a trend up and to the left, traverse the left half, it must contain a peak\\n   \\n3. since the constraint mentions nums[i] != nums[i+1], the only other cases are:\\n\\t\\t #                                 \\n       # #     and      #   #    \\n     # # #              # # #     in both of these cases we can simply traverse the right: it must have a peak\\n\\t \\n```\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        start, end = 0, len(nums) - 1\\n        nums.append(float(\\'-inf\\')) # index -1 and n will both get this in python\\n        while start <= end: # binary search to eliminate half each time\\n            mid = (start + end) // 2\\n            if nums[mid - 1] < nums[mid] and nums[mid] > nums[mid + 1]:\\n                return mid\\n            if nums[mid - 1] > nums[mid]:\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n```\n```\\n1. \\n\\t #\\n   # # #     if the middle element is already larger than both neighbors (including the edge cases), return mid\\n        \\n2. \\n\\t # \\n     # #\\n     # # #   if we see a trend up and to the left, traverse the left half, it must contain a peak\\n   \\n3. since the constraint mentions nums[i] != nums[i+1], the only other cases are:\\n\\t\\t #                                 \\n       # #     and      #   #    \\n     # # #              # # #     in both of these cases we can simply traverse the right: it must have a peak\\n\\t \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766226,
                "title": "best-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& arr) {\\n        int s = 0;\\n        int e = arr.size()-1;\\n        int mid = (s+e)/2;\\n        while(s<e){\\n            if(arr[mid]<arr[mid+1]){\\n                s = mid + 1;\\n            }\\n            else{\\n                e = mid;\\n            }\\n            \\n            mid = (s+e)/2;\\n        }\\n        \\n        return s;\\n    }\\n};\\n```\\n\\n# ****please upvote",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& arr) {\\n        int s = 0;\\n        int e = arr.size()-1;\\n        int mid = (s+e)/2;\\n        while(s<e){\\n            if(arr[mid]<arr[mid+1]){\\n                s = mid + 1;\\n            }\\n            else{\\n                e = mid;\\n            }\\n            \\n            mid = (s+e)/2;\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50370,
                "title": "accepted-java-binary-search-solution",
                "content": "    public static class Solution {\\n      \\n      public int findPeakElement(int[] nums) {\\n          return helper(nums, 0, nums.length - 1);\\n      }\\n      \\n      int helper(int[] a, int lo, int hi) {\\n        if (lo > hi)\\n          return -1;\\n        \\n        int mid = lo + (hi - lo) / 2;\\n        \\n        // if we are so lucky\\n        if ((mid == 0 || a[mid - 1] < a[mid]) && (mid == a.length - 1 || a[mid] > a[mid + 1]))\\n          return mid;\\n        \\n        if (a[mid] < a[mid + 1])\\n          return helper(a, mid + 1, hi);\\n        else\\n          return helper(a, lo, mid - 1);\\n      }\\n    \\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n      \\n      public int findPeakElement(int[] nums) {\\n          return helper(nums, 0, nums.length - 1);\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 50416,
                "title": "the-following-code-looks-ok-but-the-judge-say-i-get-the-wrong-ans-for-1-2-input",
                "content": "        int findPeakElement(const vector<int> &num)\\n       {\\n            if( 0 == num.size())\\n                return -1;\\n            size_t start, end, mid;\\n            start = 0;\\n            end = num.size()-1;\\n            while( start < (end-1))\\n            {\\n                mid = (start+end)/2;\\n                if(num[mid-1]<num[mid] && num[mid]>num[mid+1])\\n                    return mid;\\n                else if (num[mid-1]<num[mid] && num[mid]<num[mid+1])\\n                    start = mid;\\n                else if (num[mid-1]>num[mid] && num[mid]>num[mid+1])\\n                    end = mid;\\n                else\\n                    start = mid; // or end = mid;\\n            }\\n            return num[start]>num[end] ? start : end ;\\n        }\\n    \\t\\n        void test_findPeakElement()\\n       {\\n    \\t\\t\\n            vector<int> num;\\n            num.push_back(1);\\n            num.push_back(2);\\n    \\t    cout<<findPeakElement(num);\\n        }",
                "solutionTags": [],
                "code": "        int findPeakElement(const vector<int> &num)\\n       {\\n            if( 0 == num.size())\\n                return -1;\\n            size_t start, end, mid;\\n            start = 0;\\n            end = num.size()-1;\\n            while( start < (end-1))\\n            {\\n                mid = (start+end)/2;\\n                if(num[mid-1]<num[mid] && num[mid]>num[mid+1])\\n                    return mid;\\n                else if (num[mid-1]<num[mid] && num[mid]<num[mid+1])\\n                    start = mid;\\n                else if (num[mid-1]>num[mid] && num[mid]>num[mid+1])\\n                    end = mid;\\n                else\\n                    start = mid; // or end = mid;\\n            }\\n            return num[start]>num[end] ? start : end ;\\n        }\\n    \\t\\n        void test_findPeakElement()\\n       {\\n    \\t\\t\\n            vector<int> num;\\n            num.push_back(1);\\n            num.push_back(2);\\n    \\t    cout<<findPeakElement(num);\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 3100688,
                "title": "best-o-logn-solution",
                "content": "# Approach 1\\nLinear Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int n = nums.size();\\n        if (nums[0] > nums[1])\\n            return 0;\\n        if (nums[n - 1] > nums[n - 2])\\n            return n - 1;\\n        for (int i = 1; i < n - 1; i++) \\n            if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) \\n                return i;\\n        return -1;\\n    }\\n};\\n```\\n\\n# Approach 2\\nBinary Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return 0;\\n        if (nums[0] > nums[1])\\n            return 0;\\n        if (nums[n - 1] > nums[n - 2])    \\n            return n - 1;    \\n        int low = 1, high = n - 2;\\n        int mid;\\n        while (low <= high) {\\n            mid = (low + high) / 2;\\n            if (nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1])\\n                return mid; \\n            else if (nums[mid - 1] > nums[mid])\\n                high = mid - 1;\\n            else\\n                low = mid + 1;        \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int n = nums.size();\\n        if (nums[0] > nums[1])\\n            return 0;\\n        if (nums[n - 1] > nums[n - 2])\\n            return n - 1;\\n        for (int i = 1; i < n - 1; i++) \\n            if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) \\n                return i;\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return 0;\\n        if (nums[0] > nums[1])\\n            return 0;\\n        if (nums[n - 1] > nums[n - 2])    \\n            return n - 1;    \\n        int low = 1, high = n - 2;\\n        int mid;\\n        while (low <= high) {\\n            mid = (low + high) / 2;\\n            if (nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1])\\n                return mid; \\n            else if (nums[mid - 1] > nums[mid])\\n                high = mid - 1;\\n            else\\n                low = mid + 1;        \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004933,
                "title": "super-easily-understandable-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Binary Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n       int lo=0,hi = nums.length-1;\\n       while(lo<hi){\\n           int mid = lo+(hi-lo)/2;\\n           if(nums[mid] < nums[mid+1])\\n           lo = mid+1;\\n           else \\n           hi = mid;\\n\\n       }\\n       return lo;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n       int lo=0,hi = nums.length-1;\\n       while(lo<hi){\\n           int mid = lo+(hi-lo)/2;\\n           if(nums[mid] < nums[mid+1])\\n           lo = mid+1;\\n           else \\n           hi = mid;\\n\\n       }\\n       return lo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334436,
                "title": "c-easy-clean-solution-using-binary-search",
                "content": "**Solution 1:**\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int l = 0, r = nums.size();\\n        if(r == 1)\\n            return 0;\\n        while(l < r){\\n            int mid = l + (r - l) / 2;\\n            if(mid + 1 < nums.size() and nums[mid] < nums[mid + 1])\\n                l = mid + 1;\\n            else\\n                r = mid;\\n        }\\n        return l;\\n    }\\n};\\n```\\n\\n**Solution 2:**\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int l = 0, r = nums.size();\\n        if(r == 1)\\n            return 0;\\n        int ans = 0;\\n        while(l <= r){\\n            int mid = l + (r - l) / 2;\\n            if(mid + 1 < nums.size() and nums[mid] < nums[mid + 1])\\n                l = mid + 1;\\n            else if(mid - 1 >= 0 and nums[mid] < nums[mid - 1])\\n                r = mid - 1;\\n            else{\\n                ans = mid;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Feel free to share your ideas or any improvements as well.**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int l = 0, r = nums.size();\\n        if(r == 1)\\n            return 0;\\n        while(l < r){\\n            int mid = l + (r - l) / 2;\\n            if(mid + 1 < nums.size() and nums[mid] < nums[mid + 1])\\n                l = mid + 1;\\n            else\\n                r = mid;\\n        }\\n        return l;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int l = 0, r = nums.size();\\n        if(r == 1)\\n            return 0;\\n        int ans = 0;\\n        while(l <= r){\\n            int mid = l + (r - l) / 2;\\n            if(mid + 1 < nums.size() and nums[mid] < nums[mid + 1])\\n                l = mid + 1;\\n            else if(mid - 1 >= 0 and nums[mid] < nums[mid - 1])\\n                r = mid - 1;\\n            else{\\n                ans = mid;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470081,
                "title": "python-js-go-c-o-log-n-binary-search-w-comment",
                "content": "O( log n ) sol. based on recursive binary search\\n\\n```\\nclass Solution:\\n    \\n    \\n    def helper(self, nums, left, right):\\n    \\n        if left == right:\\n            # base case:\\n            return left\\n        \\n        mid = ( left + right ) // 2\\n        \\n\\t\\t# general case\\n        if nums[mid] > nums[mid+1]:\\n\\t\\t\\t# peak is either nums[mid] or on the left hand side\\n            return self.helper(nums, left, mid)\\n        else:\\n\\t\\t\\t# peak is either nums[mid+1] or on the right hand side\\n            return self.helper(nums, mid+1, right)\\n        \\n    def findPeakElement(self, nums: List[int]) -> int:\\n        \\n        return self.helper( nums, 0 , len(nums)-1)\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar findPeakElement = function(nums) {\\n    \\n    var finder = function(left, right){\\n        \\n        // base case aka stop condition\\n        if( left == right ){\\n            return left;\\n        }\\n        \\n        // general cases\\n        let mid = left + Math.floor( (right - left) / 2 );\\n        \\n        if( nums[mid] > nums[mid+1] ){\\n        \\n            // peak is either nums[mid] or on the left hand side\\n            return finder(left, mid);\\n        \\n        }else{\\n            // peak is either nums[mid+1] or on the right hand side\\n            return finder(mid+1, right);\\n        }\\n    }\\n    \\n    return finder(0, nums.length-1);\\n    \\n};\\n```\\n\\n---\\n\\nGo\\n\\n```\\nfunc findPeakElement(nums []int) int {\\n    \\n    var finder func(int, int) int\\n    \\n    finder = func( left int, right int) int{\\n        \\n        // base case aka stop condition\\n        if left == right{\\n            return left\\n        }\\n        \\n        // general case\\n        mid := left + ( right - left ) / 2\\n        \\n        if( nums[mid] > nums[mid+1] ){\\n            \\n            // peak is either nums[mid] or on the left hand side\\n            return finder(left, mid)\\n        }else{\\n            \\n            // peak is either nums[mid+1] or on the right hand side\\n            return finder(mid+1, right)\\n        }\\n          \\n    }\\n    \\n    return finder(0, len(nums)-1 )\\n    \\n}\\n```\\n\\n---\\n\\nC++\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        \\n        std::function<int(int, int)> finder;\\n        finder = [&](int left, int right){\\n            \\n            // base case aka stop condition\\n            if( left == right ){\\n                return left;\\n            }\\n            \\n            // general case\\n            int mid = left + ( right - left ) / 2;\\n            \\n            if( nums[mid] > nums[mid+1] ){\\n                \\n                // peak is either nums[mid] or on the left hand side\\n                return finder( left, mid);\\n            }else{\\n                \\n                // peak is either nums[mid+1] or on the right hand side\\n                return finder( mid+1, right);\\n            }\\n        };\\n        \\n        return finder(0, nums.size()-1 );\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    \\n    \\n    def helper(self, nums, left, right):\\n    \\n        if left == right:\\n            # base case:\\n            return left\\n        \\n        mid = ( left + right ) // 2\\n        \\n\\t\\t# general case\\n        if nums[mid] > nums[mid+1]:\\n\\t\\t\\t# peak is either nums[mid] or on the left hand side\\n            return self.helper(nums, left, mid)\\n        else:\\n\\t\\t\\t# peak is either nums[mid+1] or on the right hand side\\n            return self.helper(nums, mid+1, right)\\n        \\n    def findPeakElement(self, nums: List[int]) -> int:\\n        \\n        return self.helper( nums, 0 , len(nums)-1)\\n```\n```\\nvar findPeakElement = function(nums) {\\n    \\n    var finder = function(left, right){\\n        \\n        // base case aka stop condition\\n        if( left == right ){\\n            return left;\\n        }\\n        \\n        // general cases\\n        let mid = left + Math.floor( (right - left) / 2 );\\n        \\n        if( nums[mid] > nums[mid+1] ){\\n        \\n            // peak is either nums[mid] or on the left hand side\\n            return finder(left, mid);\\n        \\n        }else{\\n            // peak is either nums[mid+1] or on the right hand side\\n            return finder(mid+1, right);\\n        }\\n    }\\n    \\n    return finder(0, nums.length-1);\\n    \\n};\\n```\n```\\nfunc findPeakElement(nums []int) int {\\n    \\n    var finder func(int, int) int\\n    \\n    finder = func( left int, right int) int{\\n        \\n        // base case aka stop condition\\n        if left == right{\\n            return left\\n        }\\n        \\n        // general case\\n        mid := left + ( right - left ) / 2\\n        \\n        if( nums[mid] > nums[mid+1] ){\\n            \\n            // peak is either nums[mid] or on the left hand side\\n            return finder(left, mid)\\n        }else{\\n            \\n            // peak is either nums[mid+1] or on the right hand side\\n            return finder(mid+1, right)\\n        }\\n          \\n    }\\n    \\n    return finder(0, len(nums)-1 )\\n    \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        \\n        std::function<int(int, int)> finder;\\n        finder = [&](int left, int right){\\n            \\n            // base case aka stop condition\\n            if( left == right ){\\n                return left;\\n            }\\n            \\n            // general case\\n            int mid = left + ( right - left ) / 2;\\n            \\n            if( nums[mid] > nums[mid+1] ){\\n                \\n                // peak is either nums[mid] or on the left hand side\\n                return finder( left, mid);\\n            }else{\\n                \\n                // peak is either nums[mid+1] or on the right hand side\\n                return finder( mid+1, right);\\n            }\\n        };\\n        \\n        return finder(0, nums.size()-1 );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 292157,
                "title": "c-binary-search",
                "content": "```\\npublic class Solution {\\n    public int FindPeakElement(int[] nums) {\\n        var n = nums.Length;\\n        if (n == 1) return 0;\\n        if (nums[0] > nums[1]) return 0;\\n        if (nums[n - 2] < nums[n - 1]) return n - 1;\\n\\n        var left = 0;\\n        var right = n - 1;\\n\\n        while (left < right) {\\n            var mid = left + (right - left) / 2;\\n\\n            if (nums[mid-1] < nums[mid] && nums[mid] > nums[mid + 1]) {\\n                return mid;\\n            } else if (nums[mid - 1] < nums[mid]) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n\\n        throw new Exception(\"Never reach, because it always has one.\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int FindPeakElement(int[] nums) {\\n        var n = nums.Length;\\n        if (n == 1) return 0;\\n        if (nums[0] > nums[1]) return 0;\\n        if (nums[n - 2] < nums[n - 1]) return n - 1;\\n\\n        var left = 0;\\n        var right = n - 1;\\n\\n        while (left < right) {\\n            var mid = left + (right - left) / 2;\\n\\n            if (nums[mid-1] < nums[mid] && nums[mid] > nums[mid + 1]) {\\n                return mid;\\n            } else if (nums[mid - 1] < nums[mid]) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n\\n        throw new Exception(\"Never reach, because it always has one.\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 207209,
                "title": "solution-for-this-awful-problem",
                "content": "This is actually a really difficult problem, it doesn\\'t really seem like a fair interview question if you haven\\'t seen it before, but anways.... None of the explainations I\\'ve seen seem to really concisely capture why this solution works so I thought I\\'d give it a go.\\n\\nBasically the idea is you split the array at some mid point. If you found a point meeting the condition, then you are done, otherwise either the element to the left is greater than the mid point or the element to right it is.\\n\\nNotice that when going in the direction of the greater element there are two possibilities:\\n\\n1. The array continues to increase in that direction until the end. Meaning the first(or last) element in array will be a peak.\\n2. It drops back down in value at some point. Meaning that at that inflection point there is a peak. \\n\\nSo since we know for sure there must be a peak in whatever direction the greater element is we limit our search space to that range. Even though there may also be a peak in the other direction, we keep going with the sure thing.\\n\\n```\\npublic class Solution {\\n\\n    public int findPeakElement(int[] nums) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid + 1] > nums[mid]) {\\n                start = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\n    public int findPeakElement(int[] nums) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid + 1] > nums[mid]) {\\n                start = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50338,
                "title": "tricky-problem-tricky-solution",
                "content": "This problem seems easy .....  But I can not solve it quikly .... AS I can not figure out how to \\n\\nfind the refered peek element in O(logN) time.\\n\\nAfter seeing others' posts ....  I want to say it is so tricky to analyze it ......\\n\\nWe just check the mid and mid+1 element and recheck the bigger side as the bigger side will have \\n\\nthe peak element for sure.\\n\\nHere is one C++ CODE:\\n\\n    class Solution {\\n    public:\\n        int findPeakElement(vector<int>& nums) {\\n            int start=0, end=nums.size()-1;\\n            while(end>start){\\n                int mid=(start+end)/2;\\n                if(nums[mid] < nums[mid+1])  start=mid+1;\\n                else end=mid;\\n            }\\n            return start;\\n        }\\n    };\\n\\n\\nThanks to  @gangan  \\n\\nYou can also use the brute force traversal to find the peek element.\\n\\n    class Solution {\\n    public:\\n        int findPeakElement(vector<int>& nums) {\\n            for(int i=1; i<nums.size(); i++){\\n                if(nums[i]<nums[i-1])\\n                    return i-1;\\n            }\\n            return nums.size()-1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int findPeakElement(vector<int>& nums) {\\n            int start=0, end=nums.size()-1;\\n            while(end>start){\\n                int mid=(start+end)/2;\\n                if(nums[mid] < nums[mid+1])  start=mid+1;\\n                else end=mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 50376,
                "title": "simple-8-ms-c-solution-using-binary-search",
                "content": "   \\n\\n     class Solution {\\n    public:\\n        int findPeakElement(const vector<int> &num) {\\n            int left = 0;\\n            int right = num.size()-1;\\n            while(left<right){\\n                int mid = (right+left)/2;\\n                if(num[mid]<num[mid+1]){\\n                    left = mid+1;\\n                }\\n                else right = mid;\\n            }\\n            return right;\\n        }\\n    };\\n\\nThis problem is a binary search,but we should do a litte change.\\n\\nthe PeakElement is the largest in the neighbor,when our elment is small than the next one it means that the \\npeak is in the [mid+1,left],else the peak is in the [right,mid].",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n        int findPeakElement(const vector<int> &num) {\\n            int left = 0;\\n            int right = num.size()-1;\\n            while(left<right){\\n                int mid = (right+left)/2;\\n                if(num[mid]<num[mid+1]){\\n                    left = mid+1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 50407,
                "title": "neat-java-solution",
                "content": "    public class Solution {\\n        public int findPeakElement(int[] num) {\\n            int low = 0;\\n            int high = num.length - 1;\\n            while (low < high) {\\n                int mid = (low + high + 1)/2;\\n                if (mid == 0 || num[mid] > num[mid-1]) {\\n                    low = mid;\\n                } else {\\n                    high = mid-1;\\n                }\\n            }\\n            return low;\\n        }\\n    }\\nMainly use binary search, change `mid` a little bit from the traditional one to avoid infinite loop.",
                "solutionTags": [],
                "code": "class Solution {\\n        public int findPeakElement(int[] num) {\\n            int low = 0;\\n            int high = num.length - 1;\\n            while (low < high) {\\n                int mid = (low + high + 1)/2;\\n                if (mid == 0 || num[mid] > num[mid-1]) {\\n                    low = mid;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 50439,
                "title": "binary-search-solution",
                "content": "My binary search solution:\\n\\n    public int findPeakElement(int[] num) {\\n        int n = num.length;\\n        if (n <= 1) return 0;\\n        // handle the first and last element in num[]\\n        if (num[0] > num[1]) return 0;\\n        if (num[n - 1] > num[n - 2]) return n - 1;\\n        int left = 1, right = n - 2;\\n        while (left < right) {\\n            int mid = (left + right) >> 1;\\n            if (num[mid] > num[mid - 1] && num[mid] > num[mid + 1]) {\\n                return mid;\\n            } else if (num[mid] > num[mid + 1]) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "My binary search solution:\\n\\n    public int findPeakElement(int[] num) {\\n        int n = num.length;\\n        if (n <= 1) return 0;\\n        // handle the first and last element in num[]\\n        if (num[0] > num[1]) return 0;\\n        if (num[n - 1] > num[n - 2]) return n - 1;\\n        int left = 1, right = n - 2;\\n        while (left < right) {\\n            int mid = (left + right) >> 1;\\n            if (num[mid] > num[mid - 1] && num[mid] > num[mid + 1]) {\\n                return mid;\\n            } else if (num[mid] > num[mid + 1]) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4033648,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findPeakElement(int[] arr) {\\n        int start=0;\\n        int end=arr.length-1;\\n        while(start < end){\\n            int mid=start+(end-start)/2;\\n            if(arr[mid] > arr[mid+1]){\\n                // you are in decreasing part\\n                // this might be the answer\\n                //now go to left if there exist any greater value\\n                end = mid;\\n            }else{\\n                //you are in ascending order\\n                // go to right if there exist greater value\\n                start = mid+1;\\n            }\\n        }\\n        //at the end start and end are same so\\n        return start; //or end\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPeakElement(int[] arr) {\\n        int start=0;\\n        int end=arr.length-1;\\n        while(start < end){\\n            int mid=start+(end-start)/2;\\n            if(arr[mid] > arr[mid+1]){\\n                // you are in decreasing part\\n                // this might be the answer\\n                //now go to left if there exist any greater value\\n                end = mid;\\n            }else{\\n                //you are in ascending order\\n                // go to right if there exist greater value\\n                start = mid+1;\\n            }\\n        }\\n        //at the end start and end are same so\\n        return start; //or end\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876558,
                "title": "most-optimal-solution-using-binary-search-with-explanation-c-and-java-code",
                "content": "\\n\\n# Approach\\nThe given algorithm finds a peak element in a given array by performing a binary search to reduce the search space efficiently.\\n\\n- The algorithm first checks if the array has only one element. If so, it returns its index, as it is considered a peak.\\n\\n- Then, it checks if the first and last elements of the array are greater than their adjacent elements. If true, it returns the index of the first or last element, respectively, as it is considered a peak.\\n\\n- If the peak is not at the first or last element, the algorithm sets the search range between the second element and the second-to-last element.\\n\\n- It performs a binary search within this reduced range to find a peak element by comparing the current element with its adjacent elements.\\n\\n- If the current element is greater than its previous and next element, it returns the index of the current element as the peak.\\n\\n- If the current element is only greater than its previous element, the algorithm narrows the search range to the right side of the array.\\n\\n- If the current element is only greater than its next element, the algorithm narrows the search range to the left side of the array.\\n\\n- The binary search continues until a peak element is found, or the search range is empty, in which case it returns -1 if no peak is found.\\n\\n\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(log(n))\\n- Space complexity:\\nO(1)\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return 0;\\n        if(nums[0]>nums[1]) return 0;\\n        if(nums[n-1]>nums[n-2]) return n-1;\\n        int low = 1, high = n-1;\\n        while(low<=high) {\\n            int mid = (low+high)/2;\\n            if((nums[mid]>nums[mid-1]) && (nums[mid]>nums[mid+1])) return mid;\\n            else if(nums[mid]>nums[mid-1]) low = mid+1;\\n            else high = mid-1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n# JAVA Code\\n```\\npublic class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) return 0;\\n        if (nums[0] > nums[1]) return 0;\\n        if (nums[n - 1] > nums[n - 2]) return n - 1;\\n        \\n        int low = 1, high = n - 2;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]) return mid;\\n            else if (nums[mid] > nums[mid - 1]) low = mid + 1;\\n            else high = mid - 1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return 0;\\n        if(nums[0]>nums[1]) return 0;\\n        if(nums[n-1]>nums[n-2]) return n-1;\\n        int low = 1, high = n-1;\\n        while(low<=high) {\\n            int mid = (low+high)/2;\\n            if((nums[mid]>nums[mid-1]) && (nums[mid]>nums[mid+1])) return mid;\\n            else if(nums[mid]>nums[mid-1]) low = mid+1;\\n            else high = mid-1;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) return 0;\\n        if (nums[0] > nums[1]) return 0;\\n        if (nums[n - 1] > nums[n - 2]) return n - 1;\\n        \\n        int low = 1, high = n - 2;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]) return mid;\\n            else if (nums[mid] > nums[mid - 1]) low = mid + 1;\\n            else high = mid - 1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751468,
                "title": "easy-optimised-binary-search-approach-beats-100-beginner-friendly",
                "content": "# Intuition\\nchecking neighbours for 1st and last element and then binary search\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBinary search but in optimised way \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        int n=nums.length;\\n        int start=0;\\n        int end=n-1;\\n            //if length of my array is 1 then return that 1st value itself\\n            if(n==1){\\n            return 0;\\n            }\\n            \\n            //checking 1st and 2nd element of array(if 1st element greater       than 2nd then return 1st element)\\n            if(nums[0]>nums[1]){\\n                return 0;\\n            }\\n            //same checking for last and last second element\\n            else if(nums[n-1]>nums[n-2]){\\n                return n-1;\\n            }\\n           // the above two checking is to be done because question demands one peak and by checking this condition we can get one peak.   \\n\\n            // keeping 1st and last element aside because they\\'re already checked and intiating our start and end from 2nd and last 2nd element resp\\n            \\n            //doing binary search for the case when we have single peak\\n            start=1;\\n            end=n-2;\\n            while(start<=end){\\n            \\n            int mid=start+(end-start)/2;\\n           \\n            if(nums[mid]>nums[mid+1]  && nums[mid]>nums[mid-1]){\\n                return mid;\\n            }\\n\\n            else if(nums[mid]>nums[mid-1]){\\n                start=mid+1;\\n            }\\n\\n            else if(nums[mid]>nums[mid+1]){\\n                end=mid-1;\\n            }\\n            \\n            //these are the conditions we can check for multiple peaks\\n            else if(nums[mid]<nums[mid-1]){\\n                end=mid-1;\\n            }\\n\\n            else if(nums[mid]<nums[mid+1]){\\n                start=mid+1;\\n            }\\n            \\n            }\\n               return -1;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        int n=nums.length;\\n        int start=0;\\n        int end=n-1;\\n            //if length of my array is 1 then return that 1st value itself\\n            if(n==1){\\n            return 0;\\n            }\\n            \\n            //checking 1st and 2nd element of array(if 1st element greater       than 2nd then return 1st element)\\n            if(nums[0]>nums[1]){\\n                return 0;\\n            }\\n            //same checking for last and last second element\\n            else if(nums[n-1]>nums[n-2]){\\n                return n-1;\\n            }\\n           // the above two checking is to be done because question demands one peak and by checking this condition we can get one peak.   \\n\\n            // keeping 1st and last element aside because they\\'re already checked and intiating our start and end from 2nd and last 2nd element resp\\n            \\n            //doing binary search for the case when we have single peak\\n            start=1;\\n            end=n-2;\\n            while(start<=end){\\n            \\n            int mid=start+(end-start)/2;\\n           \\n            if(nums[mid]>nums[mid+1]  && nums[mid]>nums[mid-1]){\\n                return mid;\\n            }\\n\\n            else if(nums[mid]>nums[mid-1]){\\n                start=mid+1;\\n            }\\n\\n            else if(nums[mid]>nums[mid+1]){\\n                end=mid-1;\\n            }\\n            \\n            //these are the conditions we can check for multiple peaks\\n            else if(nums[mid]<nums[mid-1]){\\n                end=mid-1;\\n            }\\n\\n            else if(nums[mid]<nums[mid+1]){\\n                start=mid+1;\\n            }\\n            \\n            }\\n               return -1;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467556,
                "title": "python-simple-clean-solution-using-binary-search",
                "content": "# Code\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l, r = 0, n - 1\\n        while l < r:\\n            mid = (l + r) >> 1\\n            if nums[mid] < nums[mid + 1]:\\n                l =  mid + 1\\n            else:\\n                r = mid \\n        return l\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l, r = 0, n - 1\\n        while l < r:\\n            mid = (l + r) >> 1\\n            if nums[mid] < nums[mid + 1]:\\n                l =  mid + 1\\n            else:\\n                r = mid \\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365002,
                "title": "simple-binary-search-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSo as per the question we can return any index i where nums[i] is greater than any neighbour number.So for that we can divide the array in 2 parts and check if middle number is greater than its next number:\\n 1. if (nums[m]> nums[m+1]), that means the answer can be m or less than m, So for that we have to search in (i, m)\\n 2. and if(nums[m]< nums[m+1]), that means answer can be m+1 or more than m+1, So we have to search in(m+1,j)\\n\\nNow For Boundary Cases:\\n   1. as we are checking for only next element we can elimimate the possibilty of i=0;\\n   2. for j=l-1, this we are checking i<j  so that m which is (i+j)/2 will give floor value which will always be less than j.\\n# Complexity\\n- Time complexity:\\n- O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        int i=0,j=nums.length-1;\\n        \\n        while(i<j){\\n            int m=(i+j)/2;\\n            if(nums[m]<nums[m+1])i=m+1;\\n            else j=m;\\n        }\\n        return i;\\n    } \\n}\\n```\\n\\n\\n\\n> Please upvote and comment if you find this useful.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        int i=0,j=nums.length-1;\\n        \\n        while(i<j){\\n            int m=(i+j)/2;\\n            if(nums[m]<nums[m+1])i=m+1;\\n            else j=m;\\n        }\\n        return i;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309814,
                "title": "recursive-approach-best-approach-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\norder: Olog(n)\\n\\n- Space complexity:\\n- O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint BinarySearch(vector<int> &num, int s, int end) {\\n    if(s == end) return s;\\n    else{\\n        int mid1 = (s+end)/2;\\n        int mid2 = mid1+1;\\n        if(num[mid1] > num[mid2]) return BinarySearch(num, s, mid1);\\n        else return BinarySearch(num, mid2, end);\\n    }\\n}\\nint findPeakElement(vector<int> &num) {\\n    return BinarySearch(num, 0, num.size()-1);\\n}\\n};\\n```\\n\\n![download.jpg](https://assets.leetcode.com/users/images/7ac30bc0-ea04-4429-a3d9-059988aa0726_1679114600.3026392.jpeg)\\nUP VOTE FOR this CUTIE\\nADRENALINE\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint BinarySearch(vector<int> &num, int s, int end) {\\n    if(s == end) return s;\\n    else{\\n        int mid1 = (s+end)/2;\\n        int mid2 = mid1+1;\\n        if(num[mid1] > num[mid2]) return BinarySearch(num, s, mid1);\\n        else return BinarySearch(num, mid2, end);\\n    }\\n}\\nint findPeakElement(vector<int> &num) {\\n    return BinarySearch(num, 0, num.size()-1);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298609,
                "title": "one-line-code-but-time-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        return nums.index(max(nums))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        return nums.index(max(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069667,
                "title": "binary-search-o-log-n-intuitive",
                "content": "\\n# Approach\\nBinary Search\\n\\n# Complexity\\n- Time complexity:\\nO(log N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n\\n        int ans=0;\\n        int n=nums.size();\\n        if(n==1) return ans;\\n\\n        //check if first or last element are peak\\n         if(nums[0]>nums[1]) return 0;\\n         if(nums[n-1]>nums[n-2]) return n-1;\\n\\n         //search in the remaining array\\n            int start=1;\\n            int end=n-2;\\n\\n            while(start<=end)\\n            {\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]>nums[mid+1] && nums[mid]> nums[mid-1])  return mid; //if index found\\n                else if(nums[mid]<nums[mid+1])   start=mid+1; //search in upward slope\\n                else if(nums[mid]>nums[mid+1])   end=mid;//search in downward slope\\n            }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n\\n        int ans=0;\\n        int n=nums.size();\\n        if(n==1) return ans;\\n\\n        //check if first or last element are peak\\n         if(nums[0]>nums[1]) return 0;\\n         if(nums[n-1]>nums[n-2]) return n-1;\\n\\n         //search in the remaining array\\n            int start=1;\\n            int end=n-2;\\n\\n            while(start<=end)\\n            {\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]>nums[mid+1] && nums[mid]> nums[mid-1])  return mid; //if index found\\n                else if(nums[mid]<nums[mid+1])   start=mid+1; //search in upward slope\\n                else if(nums[mid]>nums[mid+1])   end=mid;//search in downward slope\\n            }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731627,
                "title": "find-peak-element-two-approaches",
                "content": "**Brute force : O(n)**\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) \\n    {\\n        vector<int>v;\\n        v.push_back(INT_MIN);\\n        int n=nums.size();\\n        \\n        if(n==1)\\n        {\\n            if(nums[0]==INT_MIN)\\n            {\\n                return 0;\\n            }\\n            else if(nums[0]==INT_MAX)\\n            {\\n                return 0;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back(nums[i]);\\n        }\\n        \\n        v.push_back(INT_MIN);\\n        \\n         int fix=0;\\n        \\n         int N=v.size();\\n        \\n        for(int i=1;i<=N-2;i++)\\n        {\\n            if((v[i]>v[i-1])&&(v[i]>v[i+1]))\\n            {\\n                fix=i;\\n                break;\\n            }\\n        }\\n        \\n        return fix-1;\\n        \\n        \\n    }\\n};\\n```\\n\\n**Binary Search : O(log n)**\\n\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>&arr)\\n    {\\n        \\n        int n=arr.size();\\n        int s=0;\\n        int e=n-1;\\n        int mid=-1;\\n        int flag=0;\\n        int first;\\n        \\n        \\n        if(n==1)\\n        {\\n           return 0;\\n        }\\n        \\n        while(s<=e)\\n        {\\n           int mid=s+(e-s)/2;\\n            \\n           if(((mid-1)>=0)&&((mid+1)<=(n-1)))\\n           {\\n                 if((arr[mid]>arr[mid-1])&&(arr[mid+1]<arr[mid]))\\n                 {\\n                     first=mid;\\n                     flag=1;\\n                     break;\\n                 }\\n                else if(arr[mid]<arr[mid-1])\\n                {\\n                    e=mid-1;\\n                }\\n                else if(arr[mid]<arr[mid+1])\\n                {\\n                    s=mid+1;\\n                } \\n           }\\n            \\n            else if(mid==0)\\n            {\\n                if(arr[0]>arr[1])\\n                {\\n                    return 0;\\n                }\\n                else\\n                {\\n                    return 1;\\n                }\\n                \\n            }\\n            else if(mid==(n-1))\\n            {\\n                if(arr[n-1]>arr[n-2])\\n                {\\n                    return (n-1);\\n                }\\n                else\\n                {\\n                    return (n-2);\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        return first;\\n        \\n        \\n        \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) \\n    {\\n        vector<int>v;\\n        v.push_back(INT_MIN);\\n        int n=nums.size();\\n        \\n        if(n==1)\\n        {\\n            if(nums[0]==INT_MIN)\\n            {\\n                return 0;\\n            }\\n            else if(nums[0]==INT_MAX)\\n            {\\n                return 0;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back(nums[i]);\\n        }\\n        \\n        v.push_back(INT_MIN);\\n        \\n         int fix=0;\\n        \\n         int N=v.size();\\n        \\n        for(int i=1;i<=N-2;i++)\\n        {\\n            if((v[i]>v[i-1])&&(v[i]>v[i+1]))\\n            {\\n                fix=i;\\n                break;\\n            }\\n        }\\n        \\n        return fix-1;\\n        \\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>&arr)\\n    {\\n        \\n        int n=arr.size();\\n        int s=0;\\n        int e=n-1;\\n        int mid=-1;\\n        int flag=0;\\n        int first;\\n        \\n        \\n        if(n==1)\\n        {\\n           return 0;\\n        }\\n        \\n        while(s<=e)\\n        {\\n           int mid=s+(e-s)/2;\\n            \\n           if(((mid-1)>=0)&&((mid+1)<=(n-1)))\\n           {\\n                 if((arr[mid]>arr[mid-1])&&(arr[mid+1]<arr[mid]))\\n                 {\\n                     first=mid;\\n                     flag=1;\\n                     break;\\n                 }\\n                else if(arr[mid]<arr[mid-1])\\n                {\\n                    e=mid-1;\\n                }\\n                else if(arr[mid]<arr[mid+1])\\n                {\\n                    s=mid+1;\\n                } \\n           }\\n            \\n            else if(mid==0)\\n            {\\n                if(arr[0]>arr[1])\\n                {\\n                    return 0;\\n                }\\n                else\\n                {\\n                    return 1;\\n                }\\n                \\n            }\\n            else if(mid==(n-1))\\n            {\\n                if(arr[n-1]>arr[n-2])\\n                {\\n                    return (n-1);\\n                }\\n                else\\n                {\\n                    return (n-2);\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        return first;\\n        \\n        \\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994588,
                "title": "binary-search-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "Why we are using binary search here? This comes in everyone\\'s mind because this is not sorted.\\nSo let me tell you the reason behind it , here we are thinking that if mid is not peak then side which contains greater element must have a peak(we are not saying that other side has no peak for sure) but the side with greater element has surely a peak. That gives us a chance to use binary search. \\n\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& arr) {\\n        int n=arr.size();\\n        \\n        int low=0, high =n-1;\\n        while(low<=high)\\n        {\\n            int mid=low+ (high-low)/2;\\n            if((mid==0 || arr[mid-1]<=arr[mid]) && (mid==n-1 || arr[mid+1]<=arr[mid]))\\n\\t\\t\\t//for the first case if nothing is on the left side(mid==0) we don\\'t need to check the left side else we have to check the left side (mid>0)\\n\\t\\t\\t//for the second case if nothing is on the right side (mid==n-1) we don\\'t need to check the right side else we have to check the right side (mid< n-1)\\n                return mid;\\n            if(mid>0 && arr[mid-1]>=arr[mid])\\n\\t\\t\\t//if arr[mid-1]>=arr[mid] then we go to the left side\\n                high=mid-1;\\n            else\\n\\t\\t\\t//else we will got to right side\\n                low=mid+1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\nIf you are having any doubt regarding the above solution do comment . Also, If you are happy with solution do upvote. Happy Coding!",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& arr) {\\n        int n=arr.size();\\n        \\n        int low=0, high =n-1;\\n        while(low<=high)\\n        {\\n            int mid=low+ (high-low)/2;\\n            if((mid==0 || arr[mid-1]<=arr[mid]) && (mid==n-1 || arr[mid+1]<=arr[mid]))\\n\\t\\t\\t//for the first case if nothing is on the left side(mid==0) we don\\'t need to check the left side else we have to check the left side (mid>0)\\n\\t\\t\\t//for the second case if nothing is on the right side (mid==n-1) we don\\'t need to check the right side else we have to check the right side (mid< n-1)\\n                return mid;\\n            if(mid>0 && arr[mid-1]>=arr[mid])\\n\\t\\t\\t//if arr[mid-1]>=arr[mid] then we go to the left side\\n                high=mid-1;\\n            else\\n\\t\\t\\t//else we will got to right side\\n                low=mid+1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984303,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n***Java***\\n```\\nclass Solution {\\n   public int findPeakElement(int[] num) {    \\n    return helper(num,0,num.length-1);\\n}\\n\\npublic int helper(int[] num,int start,int end){\\n    if(start == end){\\n        return start;\\n    }else if(start+1 == end){\\n        if(num[start] > num[end]) return start;\\n        return end;\\n    }else{\\n        \\n        int m = (start+end)/2;\\n        \\n        if(num[m] > num[m-1] && num[m] > num[m+1]){\\n\\n            return m;\\n\\n        }else if(num[m-1] > num[m] && num[m] > num[m+1]){\\n\\n            return helper(num,start,m-1);\\n\\n        }else{\\n\\n            return helper(num,m+1,end);\\n\\n        }\\n        \\n    }\\n}\\n}\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n     int findPeakElement(vector<int>& nums) {\\n        int l=0,r=nums.size()-1;\\n        while(l<=r){\\n            int mid = l + (r-l)/2;\\n            if(mid==0||nums[mid]>nums[mid-1]){\\n                if((mid==nums.size()-1||nums[mid]>nums[mid+1])){\\n                 return mid;   \\n                }else{\\n                    l=mid+1;\\n                }\\n            }else {\\n                r=mid-1;\\n            }\\n        }\\n               return -1;\\n    }\\n};\\n```\\n\\n***Python***\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        low, high = 0, len(nums)-1\\n        while low < high:\\n            mid = low + int((high-low)/2)\\n            if nums[mid] < nums[mid+1]:\\n                low = mid+1\\n            else:\\n                high = mid\\n        return low\\n```\\n\\n***JavaScript***\\n```\\nvar findPeakElement = function (nums) {\\n  let left = 0;\\n  let right = nums.length - 1;\\n  while (left < right) {\\n    const mid = left + Math.floor((right - left) / 2);\\n    nums[mid] < nums[mid + 1] ? left = mid + 1 : right = mid;\\n  }\\n  return left;\\n};\\n```\\n\\n***Kotlin***\\n```\\nclass Solution {\\n    fun findPeakElement(nums: IntArray): Int {\\n        \\n        var l = 0\\n        var r = nums.size - 1\\n        if(nums.size == 1)\\n            return 0\\n        \\n        while(l <= r) {\\n            \\n            if(l == 0 && nums[l] > nums[l+1])\\n                return l\\n            \\n            if(l > 0 && nums[l] > nums[l+1] && nums[l] > nums[l-1])\\n                return l\\n            \\n            if(r == nums.size-1 && nums[r] > nums[r-1])\\n                return r\\n            \\n            if(r < nums.size - 1 && nums[r] > nums[r+1] && nums[r] > nums[r-1])\\n                return r\\n            \\n            l++\\n            r--\\n        }\\n        return 0\\n    }\\n}\\n```\\n\\n***Swift***\\n```\\nclass Solution {\\n    func findPeakElement(_ nums: [Int]) -> Int {\\n        if nums.count == 1 { return 0 }\\n        \\n        var left = 0\\n        var right = nums.count - 1\\n        \\n        while left < right {\\n            var mid = (left + right) / 2\\n            if nums[mid] < nums[mid + 1] {\\n                left = mid + 1\\n            } else {\\n                right = mid\\n            }\\n        }\\n        \\n        return left\\n    }\\n    \\n}\\n```\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n   public int findPeakElement(int[] num) {    \\n    return helper(num,0,num.length-1);\\n}\\n\\npublic int helper(int[] num,int start,int end){\\n    if(start == end){\\n        return start;\\n    }else if(start+1 == end){\\n        if(num[start] > num[end]) return start;\\n        return end;\\n    }else{\\n        \\n        int m = (start+end)/2;\\n        \\n        if(num[m] > num[m-1] && num[m] > num[m+1]){\\n\\n            return m;\\n\\n        }else if(num[m-1] > num[m] && num[m] > num[m+1]){\\n\\n            return helper(num,start,m-1);\\n\\n        }else{\\n\\n            return helper(num,m+1,end);\\n\\n        }\\n        \\n    }\\n}\\n}\\n```\n```\\nclass Solution {\\npublic:\\n     int findPeakElement(vector<int>& nums) {\\n        int l=0,r=nums.size()-1;\\n        while(l<=r){\\n            int mid = l + (r-l)/2;\\n            if(mid==0||nums[mid]>nums[mid-1]){\\n                if((mid==nums.size()-1||nums[mid]>nums[mid+1])){\\n                 return mid;   \\n                }else{\\n                    l=mid+1;\\n                }\\n            }else {\\n                r=mid-1;\\n            }\\n        }\\n               return -1;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        low, high = 0, len(nums)-1\\n        while low < high:\\n            mid = low + int((high-low)/2)\\n            if nums[mid] < nums[mid+1]:\\n                low = mid+1\\n            else:\\n                high = mid\\n        return low\\n```\n```\\nvar findPeakElement = function (nums) {\\n  let left = 0;\\n  let right = nums.length - 1;\\n  while (left < right) {\\n    const mid = left + Math.floor((right - left) / 2);\\n    nums[mid] < nums[mid + 1] ? left = mid + 1 : right = mid;\\n  }\\n  return left;\\n};\\n```\n```\\nclass Solution {\\n    fun findPeakElement(nums: IntArray): Int {\\n        \\n        var l = 0\\n        var r = nums.size - 1\\n        if(nums.size == 1)\\n            return 0\\n        \\n        while(l <= r) {\\n            \\n            if(l == 0 && nums[l] > nums[l+1])\\n                return l\\n            \\n            if(l > 0 && nums[l] > nums[l+1] && nums[l] > nums[l-1])\\n                return l\\n            \\n            if(r == nums.size-1 && nums[r] > nums[r-1])\\n                return r\\n            \\n            if(r < nums.size - 1 && nums[r] > nums[r+1] && nums[r] > nums[r-1])\\n                return r\\n            \\n            l++\\n            r--\\n        }\\n        return 0\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func findPeakElement(_ nums: [Int]) -> Int {\\n        if nums.count == 1 { return 0 }\\n        \\n        var left = 0\\n        var right = nums.count - 1\\n        \\n        while left < right {\\n            var mid = (left + right) / 2\\n            if nums[mid] < nums[mid + 1] {\\n                left = mid + 1\\n            } else {\\n                right = mid\\n            }\\n        }\\n        \\n        return left\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741548,
                "title": "c-fast-easy-small-code-intuitive",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1) // edge case no.1\\n        {\\n            return 0;\\n        }\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n            if(nums[i-1] < nums[i] && nums[i] > nums[i+1])\\n            {\\n                return i;\\n            }\\n        }\\n        if(nums[nums.size()-1] > nums[nums.size()-2]) // edge case no. 2\\n        {\\n            return nums.size()-1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1) // edge case no.1\\n        {\\n            return 0;\\n        }\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n            if(nums[i-1] < nums[i] && nums[i] > nums[i+1])\\n            {\\n                return i;\\n            }\\n        }\\n        if(nums[nums.size()-1] > nums[nums.size()-2]) // edge case no. 2\\n        {\\n            return nums.size()-1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633023,
                "title": "4-line-code-easy-to-understand-c",
                "content": "Advice : Using Example test case do a dry run for better understanding :)\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n           for(int i = 1; i < nums.size(); i ++)\\n        {\\n            if(nums[i] < nums[i-1])\\n            {\\n                return i-1;\\n            }\\n        }\\n        return nums.size()-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n           for(int i = 1; i < nums.size(); i ++)\\n        {\\n            if(nums[i] < nums[i-1])\\n            {\\n                return i-1;\\n            }\\n        }\\n        return nums.size()-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602160,
                "title": "java-left-1-right-template-0-ms-beating-100-using-the-3rd-lc-template",
                "content": "Pls upvote this, so that I can find when I revise Binary search explore card again, pheww\\n\\n```\\npublic int findPeakElement(int[] nums) {\\n        int left = 0, right = nums.length - 1;\\n        \\n        while(left + 1 < right) {\\n            int mid = left + (right - left)/2;\\n            \\n            if (nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]) {\\n                return mid;\\n                \\n            } else if (nums[mid] < nums[mid + 1]) {\\n                left = mid;\\n                \\n            } else {\\n                right = mid;\\n            }\\n        }\\n        \\n        return nums[left] > nums[right] ? left : right;\\n    }\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\npublic int findPeakElement(int[] nums) {\\n        int left = 0, right = nums.length - 1;\\n        \\n        while(left + 1 < right) {\\n            int mid = left + (right - left)/2;\\n            \\n            if (nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]) {\\n                return mid;\\n                \\n            } else if (nums[mid] < nums[mid + 1]) {\\n                left = mid;\\n                \\n            } else {\\n                right = mid;\\n            }\\n        }\\n        \\n        return nums[left] > nums[right] ? left : right;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1463124,
                "title": "c-binary-search-explanation-mountain-peek-finding",
                "content": "Explanation:\\n1. use this information in ques nums[-1] = -infinity = nums[n];\\n2.  imagine this problem as climbing a moutain where many peaks comes.\\n3. O(logn) --> Variation of binary search to find the peek\\n4. returns the index of number having highest value\\n5. Now whenever you will find a condition where the value next to your middle value is greater then your middle value. This condition will be of a downward slope or climbing down the slope. Similarly you can say whenever you will find middle value greater then previous value then that will be an upward climb case.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int low = 0,n = nums.size(),high = n-1;\\n        if(n == 1){\\n            return 0;\\n        }else if(n == 2){\\n            if(nums[0] > nums[1]){\\n                return 0;\\n            }else\\n                return 1;\\n        } \\n        while(low < high-1){\\n            int middle = low+ (high - low)/2;\\n            if(nums[middle] > nums[middle+1] && nums[middle] > nums[middle-1])\\n                return middle;\\n            else if(nums[middle] > nums[middle+1]){\\n                // downward journey on slope\\n                high = middle -1;\\n            }else{\\n                // upward journey\\n                low = middle +1;\\n            }\\n        }\\n        return nums[low] > nums[high] ? low:high;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int low = 0,n = nums.size(),high = n-1;\\n        if(n == 1){\\n            return 0;\\n        }else if(n == 2){\\n            if(nums[0] > nums[1]){\\n                return 0;\\n            }else\\n                return 1;\\n        } \\n        while(low < high-1){\\n            int middle = low+ (high - low)/2;\\n            if(nums[middle] > nums[middle+1] && nums[middle] > nums[middle-1])\\n                return middle;\\n            else if(nums[middle] > nums[middle+1]){\\n                // downward journey on slope\\n                high = middle -1;\\n            }else{\\n                // upward journey\\n                low = middle +1;\\n            }\\n        }\\n        return nums[low] > nums[high] ? low:high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343101,
                "title": "python-easy-to-understand-o-logn-solution-with-explanation-using-binary-search",
                "content": "**Idea: Binary search**\\nExplanation:\\nIf an element (not the corner-most one) is smaller than its right neighbor, then there must be a peak element on its right, because the elements on its right is either\\n\\n* always increasing  -> the right-most element is the peak\\n* always decreasing  -> the left-most element is the peak\\n* first increasing then decreasing -> the pivot point is the peak\\n* first decreasing then increasing -> the left-most element is the peak  \\n* The same method applies when an element is smaller than its left element.\\n\\nAlgorithm:\\n1. if length of array is 1 -> return the only index\\n2. if length of array is 2 -> return the index of larger number\\n3. if array length is bigger than 2 ->\\n(1) find mid, compare it with its left and right neighbors\\n(2) check if mid is first index of array, return mid if nums[mid]>nums[mid+1]\\n(3) check if mid is last index of array, return mid if nums[mid]>nums[mid-1]\\n(4) return mid if nums[mid] greater than both neighbors\\n(5) check peak element in the left half array\\n(6) otherwise, take the right half\\n\\n//- **last** variable in code is the last index value of the nums array.\\n\\nRun time: O(logn)\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        def binary_search(nums,l,r,last):\\n            if(r<=l):\\n                return -1\\n            mid=l+(r-l)//2\\n            if(mid==0):\\n                if(nums[mid]>nums[mid+1]):\\n                    return mid\\n            elif(mid==last):\\n                if(nums[mid]>nums[mid-1]):\\n                    return mid\\n            elif(nums[mid]>nums[mid+1] and nums[mid]>nums[mid-1] ):\\n                return mid\\n            \\n            a=binary_search(nums,l,mid,last)\\n            if(a==-1):\\n                return binary_search(nums,mid+1,r,last)\\n            else:\\n                return a\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n        if(len(nums)==1):\\n            return 0\\n        if(len(nums)==2):\\n            if(nums[0]>nums[1]):\\n                return 0\\n            else:\\n                return 1\\n        ans=binary_search(nums,0,len(nums),len(nums)-1)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        def binary_search(nums,l,r,last):\\n            if(r<=l):\\n                return -1\\n            mid=l+(r-l)//2\\n            if(mid==0):\\n                if(nums[mid]>nums[mid+1]):\\n                    return mid\\n            elif(mid==last):\\n                if(nums[mid]>nums[mid-1]):\\n                    return mid\\n            elif(nums[mid]>nums[mid+1] and nums[mid]>nums[mid-1] ):\\n                return mid\\n            \\n            a=binary_search(nums,l,mid,last)\\n            if(a==-1):\\n                return binary_search(nums,mid+1,r,last)\\n            else:\\n                return a\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n        if(len(nums)==1):\\n            return 0\\n        if(len(nums)==2):\\n            if(nums[0]>nums[1]):\\n                return 0\\n            else:\\n                return 1\\n        ans=binary_search(nums,0,len(nums),len(nums)-1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335946,
                "title": "linear-time-solution-python",
                "content": "```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        for i in range(len(nums)-1):\\n            if nums[i]>nums[i+1]:\\n                return i\\n        return len(nums)-1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        for i in range(len(nums)-1):\\n            if nums[i]>nums[i+1]:\\n                return i\\n        return len(nums)-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335275,
                "title": "find-peak-element-python-o-log-n-complexity",
                "content": "1. Look at the middle of array. If it is a peak, return\\n2. If it is increasing part, take subarray at right.\\n3. If it is decreasing part, take left subarray\\n4. repeat\\n\\nTime complexity O(log n), memory complexity O(1)\\n\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return 0\\n        l, r = 0, len(nums)-1\\n        \\n        while l<r:\\n            m = (r+l)//2  \\n            if nums[m]>nums[m+1]:\\n                if nums[m]>nums[m-1]: return m\\n                else: \\n                    r = m\\n            else:\\n                l = m+1\\n                \\n        return l\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return 0\\n        l, r = 0, len(nums)-1\\n        \\n        while l<r:\\n            m = (r+l)//2  \\n            if nums[m]>nums[m+1]:\\n                if nums[m]>nums[m-1]: return m\\n                else: \\n                    r = m\\n            else:\\n                l = m+1\\n                \\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335167,
                "title": "c-awesome-binary-search",
                "content": "Approach 1: Brute force [1]\\nDivide and conquer:\\nThe question can be divided into 3-sub question:\\n1) how to find peak in descending array\\n2) how to find peak in ascending array\\n3) how to find peak in other cases, i.e., mixed cases of 1) and 2) \\n\\nSolution:\\nif(nums[i] > nums[i+1]) return i;\\n\\nTime Complexity: O(N)\\nSpace Complexity: O(1)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(const vector<int> &nums) {    \\n        for(int i = 0; i < nums.size()-1; i++)\\n            if(nums[i] > nums[i+1]) return i;\\n        return nums.size() - 1;\\n    }\\n};\\n```\\n\\nApproach 2: binary search.\\nTrick how to find the gating function for if-else statement\\n\\nTime Complexity: O(log(N))\\nSpace Complexity: O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(const vector<int> &nums) {    \\n        int l = 0, r = nums.size() -1;\\n        while(l < r){\\n            int mid = l + (r - l) / 2;\\n            if(nums[mid] > nums[mid + 1]) r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};\\n\\n```\\nApproach 3: Recursive version\\nTime Complexity: O(log(N))\\nSpace Complexity: O(log(N))\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(const vector<int> &nums) {  \\n        return search(nums, 0, nums.size() - 1);        \\n    }\\n    \\nprivate:\\n    int search(const vector<int> &nums, int l, int r){\\n        if(l == r) return l;\\n        int mid = (l + r) / 2;\\n        if(nums[mid] > nums[mid+1]) return search(nums,l, mid);\\n        return search(nums,mid+1,r);\\n    }\\n};\\n```\\nReference:\\n[1]https://leetcode.com/problems/find-peak-element/solution/\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(const vector<int> &nums) {    \\n        for(int i = 0; i < nums.size()-1; i++)\\n            if(nums[i] > nums[i+1]) return i;\\n        return nums.size() - 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(const vector<int> &nums) {    \\n        int l = 0, r = nums.size() -1;\\n        while(l < r){\\n            int mid = l + (r - l) / 2;\\n            if(nums[mid] > nums[mid + 1]) r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(const vector<int> &nums) {  \\n        return search(nums, 0, nums.size() - 1);        \\n    }\\n    \\nprivate:\\n    int search(const vector<int> &nums, int l, int r){\\n        if(l == r) return l;\\n        int mid = (l + r) / 2;\\n        if(nums[mid] > nums[mid+1]) return search(nums,l, mid);\\n        return search(nums,mid+1,r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 814893,
                "title": "c-simple-solution",
                "content": "```\\nint findPeakElement(int* nums, int numsSize)\\n{\\n        int l = 0, r = numsSize - 1;\\n        while (l < r) \\n        {\\n            int mid = (l + r) / 2;\\n            if (nums[mid] > nums[mid + 1])\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findPeakElement(int* nums, int numsSize)\\n{\\n        int l = 0, r = numsSize - 1;\\n        while (l < r) \\n        {\\n            int mid = (l + r) / 2;\\n            if (nums[mid] > nums[mid + 1])\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 733134,
                "title": "java-binary-search-solution-most-intuitive-0-ms-runtime-o-log-n",
                "content": "```\\n// Consider an example  7 8 9 6 5 4 3 -->9 is the peak element\\n//  we get the nums[mid]==6 using binary search\\n// now we return this number if it is a peak otherwise we have to make a a decision as to which side to binary search(left side of mid or right side of mid)\\n// we check number nums[mid-1]\\n// if(nums[mid-1] > nums[mid]) it would make more sense to search in left side of mid\\n// because for nums[mid-1] to not be a peak there has to be a number greater than it to it\\'s left\\n// this goes on until we encounter the largest element\\n// (worst case the largest element is the first element)\\n//therefore we are sure to get atleast one peak element to the left of mid in case nums[mid-1] > num[mid]\\n    \\n    //Time Complexity: O(log(n))\\n\\t//Space Complexity: O(1)\\n\\t\\n    public int findPeakElement(int[] nums) {\\n        if(nums==null || nums.length<1)return -1;\\n        if(nums.length==1)return 0; // if single element present then that\\'s the answer\\n\\t\\t\\n\\t\\t//we are handling the first element and last element separately as it is given nums[-1] = nums[n] = -\\u221E\\n        if(nums[0] > nums[1])return 0; \\n        if(nums[nums.length-1]>nums[nums.length-2])return nums.length-1;\\n        \\n        int left=1;\\n        int right=nums.length-2;\\n        while(left <= right){\\n            int mid=left+(right-left)/2;\\n            \\n            if(nums[mid] > nums[mid-1] && nums[mid] >nums[mid+1])return mid;\\n            else if(nums[mid-1] > nums[mid]){\\n                right=mid-1;\\n            }\\n            else left=mid+1;\\n        }\\n        \\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n// Consider an example  7 8 9 6 5 4 3 -->9 is the peak element\\n//  we get the nums[mid]==6 using binary search\\n// now we return this number if it is a peak otherwise we have to make a a decision as to which side to binary search(left side of mid or right side of mid)\\n// we check number nums[mid-1]\\n// if(nums[mid-1] > nums[mid]) it would make more sense to search in left side of mid\\n// because for nums[mid-1] to not be a peak there has to be a number greater than it to it\\'s left\\n// this goes on until we encounter the largest element\\n// (worst case the largest element is the first element)\\n//therefore we are sure to get atleast one peak element to the left of mid in case nums[mid-1] > num[mid]\\n    \\n    //Time Complexity: O(log(n))\\n\\t//Space Complexity: O(1)\\n\\t\\n    public int findPeakElement(int[] nums) {\\n        if(nums==null || nums.length<1)return -1;\\n        if(nums.length==1)return 0; // if single element present then that\\'s the answer\\n\\t\\t\\n\\t\\t//we are handling the first element and last element separately as it is given nums[-1] = nums[n] = -\\u221E\\n        if(nums[0] > nums[1])return 0; \\n        if(nums[nums.length-1]>nums[nums.length-2])return nums.length-1;\\n        \\n        int left=1;\\n        int right=nums.length-2;\\n        while(left <= right){\\n            int mid=left+(right-left)/2;\\n            \\n            if(nums[mid] > nums[mid-1] && nums[mid] >nums[mid+1])return mid;\\n            else if(nums[mid-1] > nums[mid]){\\n                right=mid-1;\\n            }\\n            else left=mid+1;\\n        }\\n        \\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 344273,
                "title": "python3-binary-search",
                "content": "```\\nclass Solution(object):\\n    def findPeakElement(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums = [-2**32]+nums+[-2**32]\\n        l,r = 0,len(nums)-1\\n        while l <=r:\\n            m = (l+r)//2\\n\\t\\t\\t# we find the target:\\n            if nums[m] > nums[m-1] and nums[m] > nums[m+1]:\\n                return m -1\\n            else:\\n                if nums[m] <nums[m+1]:\\n                    l = m + 1\\n                else:\\n                    r = m - 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution(object):\\n    def findPeakElement(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums = [-2**32]+nums+[-2**32]\\n        l,r = 0,len(nums)-1\\n        while l <=r:\\n            m = (l+r)//2\\n\\t\\t\\t# we find the target:\\n            if nums[m] > nums[m-1] and nums[m] > nums[m+1]:\\n                return m -1\\n            else:\\n                if nums[m] <nums[m+1]:\\n                    l = m + 1\\n                else:\\n                    r = m - 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50263,
                "title": "golang-binary-search-solution",
                "content": "The important point is we can take `nums[-1]` and `nums[len(nums)]` as `-\\u221e`.\\nLet's say we take a middle element and it looks like\\n```\\n           \\u2193 mid\\n..., 100, 200, 150, ...\\n```\\n\\nNow we can find the peak, so we can return `mid`. If this is not the case, either the left or right element of `mid` is bigger than `nums[mid]`. For example,\\n\\n```\\n           \\u2193 mid\\n..., 500, 200, 150, ...\\n```\\n\\n500 is bigger than 200. In this case, because left starts from `-\\u221e`, there is at least one peak on the left side of `mid`. \\nSame applies on the right side.\\n\\n```\\nfunc findPeakElement(nums []int) int {\\n\\tnlen := len(nums)\\n\\tif nlen == 1 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tleft, right := 0, nlen-1\\n\\tfor {\\n\\t\\tmid := left + (right-left)/2\\n\\n\\t\\t// edge case first element\\n\\t\\tif mid == 0 {\\n\\t\\t\\tif nums[mid] > nums[mid+1] {\\n\\t\\t\\t\\treturn mid\\n\\t\\t\\t}\\n\\t\\t\\tleft = mid + 1\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\t// edge case last element\\n\\t\\tif mid == nlen-1 {\\n\\t\\t\\tif nums[mid] > nums[mid-1] {\\n\\t\\t\\t\\treturn mid\\n\\t\\t\\t}\\n\\t\\t\\tright = mid - 1\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tif nums[mid] > nums[mid-1] && nums[mid] > nums[mid+1] {\\n\\t\\t\\treturn mid\\n\\t\\t}\\n\\t\\tif nums[mid] < nums[mid-1] {\\n\\t\\t\\tright = mid - 1\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t}\\n\\t}\\n\\treturn -1 // never reaches here\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n           \\u2193 mid\\n..., 100, 200, 150, ...\\n```\n```\\n           \\u2193 mid\\n..., 500, 200, 150, ...\\n```\n```\\nfunc findPeakElement(nums []int) int {\\n\\tnlen := len(nums)\\n\\tif nlen == 1 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tleft, right := 0, nlen-1\\n\\tfor {\\n\\t\\tmid := left + (right-left)/2\\n\\n\\t\\t// edge case first element\\n\\t\\tif mid == 0 {\\n\\t\\t\\tif nums[mid] > nums[mid+1] {\\n\\t\\t\\t\\treturn mid\\n\\t\\t\\t}\\n\\t\\t\\tleft = mid + 1\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\t// edge case last element\\n\\t\\tif mid == nlen-1 {\\n\\t\\t\\tif nums[mid] > nums[mid-1] {\\n\\t\\t\\t\\treturn mid\\n\\t\\t\\t}\\n\\t\\t\\tright = mid - 1\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tif nums[mid] > nums[mid-1] && nums[mid] > nums[mid+1] {\\n\\t\\t\\treturn mid\\n\\t\\t}\\n\\t\\tif nums[mid] < nums[mid-1] {\\n\\t\\t\\tright = mid - 1\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t}\\n\\t}\\n\\treturn -1 // never reaches here\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 50348,
                "title": "my-binary-search-java-solution",
                "content": "    public class Solution {\\n        public int findPeakElement(int[] num) {\\n            \\n            int length = num.length;\\n            int left = 0;\\n            int right = length-1;\\n    \\n            int a=0;\\n            while(left<=right){   //\\u5de6\\u53f3\\u5f00\\u5de5\\u627epeak\\uff0c\\u76f4\\u5230\\u4e24\\u4e2aelement\\u91cd\\u5408\\u4e3a\\u6b62\\n                if(left==right){\\n                   a = left;\\n                   break;\\n                } \\n                int mid = (left+right)/2;\\n                \\n                if(num[mid]<num[mid+1]){\\n                    left = mid+1;\\n                }else{\\n                    right = mid;\\n                }\\n                \\n            }\\n            return a;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int findPeakElement(int[] num) {\\n            \\n            int length = num.length;\\n            int left = 0;\\n            int right = length-1;\\n    \\n            int a=0;\\n            while(left<=right){   //\\u5de6\\u53f3\\u5f00\\u5de5\\u627epeak\\uff0c\\u76f4\\u5230\\u4e24\\u4e2aelement\\u91cd\\u5408\\u4e3a\\u6b62\\n                if(left==right){\\n                   a = left;\\n                   break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 50384,
                "title": "my-simple-c-logn-solution",
                "content": "Since nums[-1] = nums[n] = INT_MIN, a valid solution is guaranteed to exist.\\n\\n    class Solution {\\n    public:\\n        int findPeakElement(vector<int>& nums) {\\n            int l = 0, r = nums.size();\\n            while (l+1 < r) {\\n                int m = (l+r)/2;\\n                if (m && nums[m] < nums[m-1])\\n                    r = m;\\n                else\\n                    l = m;\\n            }\\n            return l;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int findPeakElement(vector<int>& nums) {\\n            int l = 0, r = nums.size();\\n            while (l+1 < r) {\\n                int m = (l+r)/2;\\n                if (m && nums[m] < nums[m-1])\\n                    r = m;\\n                else\\n                    l = m;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 50400,
                "title": "a-very-simple-accepted-non-recursive-binary-search-java-solution",
                "content": "The idea is to perform a simple binary serach with a little twist. If mid is the peak then return else keep searching in the direction which is higher of two - (mid -1) & (mid + 1).\\n\\nI referred the MIT course notes to get to this solution - [http://courses.csail.mit.edu/6.006/spring11/lectures/lec02.pdf][1]\\n\\n    public int findPeakElement(int[] num) {\\n        if(num == null || num.length < 1) {\\n            return -1;\\n        }\\n        int start = 0;\\n        int end = num.length - 1;\\n        int mid;\\n        long left, right;\\n\\n        while(start <= end) {\\n            mid = (start + end)/2;\\n            left = mid == 0 ? (long)Integer.MIN_VALUE - 1 : num[mid - 1];\\n            right = mid == num.length - 1 ? (long)Integer.MIN_VALUE - 1: num[mid + 1];\\n\\n            if(left < num[mid] && right < num[mid]) {\\n                return mid;\\n            }\\n            if(left < right) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n\\n  [1]: http://courses.csail.mit.edu/6.006/spring11/lectures/lec02.pdf",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "The idea is to perform a simple binary serach with a little twist. If mid is the peak then return else keep searching in the direction which is higher of two - (mid -1) & (mid + 1).\\n\\nI referred the MIT course notes to get to this solution - [http://courses.csail.mit.edu/6.006/spring11/lectures/lec02.pdf][1]\\n\\n    public int findPeakElement(int[] num) {\\n        if(num == null || num.length < 1) {\\n            return -1;\\n        }\\n        int start = 0;\\n        int end = num.length - 1;\\n        int mid;\\n        long left, right;\\n\\n        while(start <= end) {\\n            mid = (start + end)/2;\\n            left = mid == 0 ? (long)Integer.MIN_VALUE - 1 : num[mid - 1];\\n            right = mid == num.length - 1 ? (long)Integer.MIN_VALUE - 1: num[mid + 1];\\n\\n            if(left < num[mid] && right < num[mid]) {\\n                return mid;\\n            }\\n            if(left < right) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n\\n  [1]: http://courses.csail.mit.edu/6.006/spring11/lectures/lec02.pdf",
                "codeTag": "Unknown"
            },
            {
                "id": 4040877,
                "title": "find-peak-element-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        if (nums.size() == 1) {\\n            return 0;\\n        }\\n        if (nums.size() == 2) {\\n            if (nums[0] > nums[1]) {\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        \\n        int end = nums.size() - 1;\\n        int start = 0;\\n        \\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            \\n            if ((mid == 0 || nums[mid] > nums[mid - 1]) &&\\n                (mid == nums.size() - 1 || nums[mid] > nums[mid + 1])) {\\n                return mid;\\n            }\\n            else if (mid > 0 && nums[mid - 1] > nums[mid]) {\\n                end = mid - 1;\\n            }\\n            else {\\n                start = mid + 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        if (nums.size() == 1) {\\n            return 0;\\n        }\\n        if (nums.size() == 2) {\\n            if (nums[0] > nums[1]) {\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        \\n        int end = nums.size() - 1;\\n        int start = 0;\\n        \\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            \\n            if ((mid == 0 || nums[mid] > nums[mid - 1]) &&\\n                (mid == nums.size() - 1 || nums[mid] > nums[mid + 1])) {\\n                return mid;\\n            }\\n            else if (mid > 0 && nums[mid - 1] > nums[mid]) {\\n                end = mid - 1;\\n            }\\n            else {\\n                start = mid + 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929768,
                "title": "simple-c-solution",
                "content": "# Linear Search\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int peak=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<nums[i+1]){\\n                peak=i+1;\\n            }\\n        }\\n        return peak;\\n    }\\n};\\n```\\n# Linear Search\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int> &nums){\\n        int n=nums.size();\\n        if(n==1)return 0;\\n        if(nums[0]>nums[1])return 0;\\n        if(nums[n-1]>nums[n-2])return n-1;\\n\\n        for(int i=1;i<n-1;i++){\\n            if(nums[i]>nums[i+1] && nums[i]>nums[i-1]){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n# Binary Search\\nWhy? Because in binary search we optimize the search space by eliminating one of the half.\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int> &nums){\\n        int n=nums.size();\\n        // Edge Cases\\n        if(n==1)return 0;\\n        if(nums[0]>nums[1])return 0;\\n        if(nums[n-1]>nums[n-2])return n-1;\\n        // Binary Search\\n        int low=1,high=n-2;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1]){\\n                return mid;\\n            }\\n            if(nums[mid]>nums[mid-1]){\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int peak=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<nums[i+1]){\\n                peak=i+1;\\n            }\\n        }\\n        return peak;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int> &nums){\\n        int n=nums.size();\\n        if(n==1)return 0;\\n        if(nums[0]>nums[1])return 0;\\n        if(nums[n-1]>nums[n-2])return n-1;\\n\\n        for(int i=1;i<n-1;i++){\\n            if(nums[i]>nums[i+1] && nums[i]>nums[i-1]){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int> &nums){\\n        int n=nums.size();\\n        // Edge Cases\\n        if(n==1)return 0;\\n        if(nums[0]>nums[1])return 0;\\n        if(nums[n-1]>nums[n-2])return n-1;\\n        // Binary Search\\n        int low=1,high=n-2;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1]){\\n                return mid;\\n            }\\n            if(nums[mid]>nums[mid-1]){\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913224,
                "title": "using-binary-search-beats-100-easy-c-solution-best-detailed-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n    int n=nums.size();\\n    if(n==1)\\n    {\\n      return 0;\\n    } \\n    if(nums[0]>nums[1])\\n    {\\n      return 0;\\n    }\\n    if(nums[n-1]>nums[n-2])\\n    {\\n      return n-1;\\n    }\\n    int left=1;\\n    int right=n-2;\\n    while(left<=right)\\n    {\\n      int mid=(left+right)/2;\\n      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])\\n      {\\n        return mid;\\n      }\\n      else if(nums[mid]>nums[mid-1])\\n      {\\n        left=mid+1;\\n      }\\n      else{\\n        right=mid-1;\\n      }\\n    }\\nreturn -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n    int n=nums.size();\\n    if(n==1)\\n    {\\n      return 0;\\n    } \\n    if(nums[0]>nums[1])\\n    {\\n      return 0;\\n    }\\n    if(nums[n-1]>nums[n-2])\\n    {\\n      return n-1;\\n    }\\n    int left=1;\\n    int right=n-2;\\n    while(left<=right)\\n    {\\n      int mid=(left+right)/2;\\n      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])\\n      {\\n        return mid;\\n      }\\n      else if(nums[mid]>nums[mid-1])\\n      {\\n        left=mid+1;\\n      }\\n      else{\\n        right=mid-1;\\n      }\\n    }\\nreturn -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811558,
                "title": "beats-100-cpp-answered-one-common-doubt",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbhai O(log N) to samjh jane ka !!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsame hi hai baaki sabhi solution se\\nCertainly! In questions involving binary search or similar algorithms, there might be a common doubt regarding whether to return the variable `s` (left pointer) or `e` (right pointer) when the loop ends without finding the exact target element.\\n\\nIn such cases, it\\'s important to understand that both `s` and `e` will converge to the same position when the loop ends. The loop will terminate when `s` becomes greater than `e`, meaning the search space has been exhausted. At this point, `s` will be the first index where the condition inside the loop became false, and `e` will be the last index where the condition inside the loop became true.\\n\\nSince the target element is not present in the array, the final value of `s` or `e` will be the index where the target element should have been if it were present in the array. Hence, both `s` and `e` will point to the element that is just greater than the target (in case of a non-existent target).\\n\\nTherefore, in such scenarios, returning either `s` or `e` will yield the correct result, as they will be equal. There is no practical difference in returning one over the other since they will have the same value at the end of the loop.\\n\\nSo, programmers can choose to return either `s` or `e` based on their preference or coding style. Both options are correct and will provide the same result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int e = nums.size()-1;\\n        int s = 0;\\n        int index;\\n\\n        while(s<e)\\n        {\\n            int m = s + (e-s)/2;\\n            if(nums[m] > nums[m+1])\\n            {\\n                e = m;\\n            }\\n            else\\n            {\\n                s = m+1;\\n            }\\n        }\\n        return e;\\n    }\\n};\\n```\\nPlease upvote if this small doubt you guys always face and ignore it!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int e = nums.size()-1;\\n        int s = 0;\\n        int index;\\n\\n        while(s<e)\\n        {\\n            int m = s + (e-s)/2;\\n            if(nums[m] > nums[m+1])\\n            {\\n                e = m;\\n            }\\n            else\\n            {\\n                s = m+1;\\n            }\\n        }\\n        return e;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806919,
                "title": "c-solution-for-beginners-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven in the question we need to solve it in O(log n), first comes in mind is Binary Search.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo the approach here is simple, take two pointers , one at the starting of the array and one at the end of the array.\\nNow we use binary search, we find the mid index and then compare it with the its next element `nums[mid]>nums[mid+1`\\nIf the mid element is greater , it means all the element on the right will be smaller than the mid , so we set `right=mid;`\\nelse \\nwe set `left=mid+1;`\\n\\n# Complexity\\n- Time complexity:$$O(log n)$$\\n    As we are using BinarySearch approach which as O(log n) complexity.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:$$O(1)$$\\n    As we don\\'t use any extra space apart from the variables we declare which is constant.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int left=0;\\n        int right=nums.size()-1;\\n        int mid=left+(right-left)/2;\\n\\n        while(left<right){\\n            if(nums[mid]>nums[mid+1]){\\n                right=mid;\\n            }\\n            else{\\n                left=mid+1;\\n            }\\n            mid=left+(right-left)/2;\\n        }\\n        return left;\\n    }\\n};\\n```\\n\\n\\n###### PLease Upvote\\uD83E\\uDD79",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int left=0;\\n        int right=nums.size()-1;\\n        int mid=left+(right-left)/2;\\n\\n        while(left<right){\\n            if(nums[mid]>nums[mid+1]){\\n                right=mid;\\n            }\\n            else{\\n                left=mid+1;\\n            }\\n            mid=left+(right-left)/2;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752743,
                "title": "easy-c-solution-simple-binary-search-approach-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums){\\n        int start = 0, end = nums.size()-1;\\n        if(start==end)                    return start;\\n        if(nums[start]>nums[start+1])     return start;\\n        if(nums[end]>nums[end-1])         return end;\\n        start++, end--;\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1])\\n                return mid;\\n            else if(nums[mid-1]>nums[mid])\\n                end = mid-1;\\n            else if(nums[mid+1]>nums[mid])\\n                start = mid+1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums){\\n        int start = 0, end = nums.size()-1;\\n        if(start==end)                    return start;\\n        if(nums[start]>nums[start+1])     return start;\\n        if(nums[end]>nums[end-1])         return end;\\n        start++, end--;\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1])\\n                return mid;\\n            else if(nums[mid-1]>nums[mid])\\n                end = mid-1;\\n            else if(nums[mid+1]>nums[mid])\\n                start = mid+1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678388,
                "title": "o-n-no-binary-search-no-recursion-java",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n```\\nO(n)\\n```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nO(1)\\n```\\n# Code\\n```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        for(int i=nums.length-1;i>=1;i--){\\n            if(nums[i-1]<nums[i]){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nO(n)\\n```\n```\\nO(1)\\n```\n```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        for(int i=nums.length-1;i>=1;i--){\\n            if(nums[i-1]<nums[i]){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588609,
                "title": "find-peak-element-easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(logn) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int findPeakElement(vector<int>& nums) {\\n        int s=0,e=nums.size()-1; \\n        int mid=s+(e-s)/2; \\n        while(s<e){\\n            if(mid==0){\\n                if(nums[0]>nums[1]){\\n                    return mid ; \\n                }\\n                s=mid+1; \\n            }\\n            else if(mid==nums.size()-1){\\n                if(nums[nums.size()-1]>nums[nums.size()-2]){\\n                    return mid ; \\n                }\\n                e=mid-1; \\n            }\\n            else if(nums[mid]>nums[mid+1] and nums[mid]>nums[mid-1]){\\n                return mid; \\n            }\\n            else if(nums[mid]>nums[mid+1]){\\n                e=mid-1; \\n            }\\n            else {\\n                s=mid+1; \\n            }\\n            mid=s+(e-s)/2; \\n        }\\n        return s ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findPeakElement(vector<int>& nums) {\\n        int s=0,e=nums.size()-1; \\n        int mid=s+(e-s)/2; \\n        while(s<e){\\n            if(mid==0){\\n                if(nums[0]>nums[1]){\\n                    return mid ; \\n                }\\n                s=mid+1; \\n            }\\n            else if(mid==nums.size()-1){\\n                if(nums[nums.size()-1]>nums[nums.size()-2]){\\n                    return mid ; \\n                }\\n                e=mid-1; \\n            }\\n            else if(nums[mid]>nums[mid+1] and nums[mid]>nums[mid-1]){\\n                return mid; \\n            }\\n            else if(nums[mid]>nums[mid+1]){\\n                e=mid-1; \\n            }\\n            else {\\n                s=mid+1; \\n            }\\n            mid=s+(e-s)/2; \\n        }\\n        return s ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513675,
                "title": "beginner-friendly-python-solution-using-modified-binary-search",
                "content": "# Code\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        low=0\\n        high=len(nums)-1\\n        while low<=high:\\n            mid=low+(high-low)//2\\n            if mid>0 and nums[mid]<nums[mid-1]:\\n                high=mid-1\\n            elif mid<len(nums)-1 and nums[mid]<nums[mid+1]:\\n                low=mid+1\\n            else:\\n                return mid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        low=0\\n        high=len(nums)-1\\n        while low<=high:\\n            mid=low+(high-low)//2\\n            if mid>0 and nums[mid]<nums[mid-1]:\\n                high=mid-1\\n            elif mid<len(nums)-1 and nums[mid]<nums[mid+1]:\\n                low=mid+1\\n            else:\\n                return mid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400133,
                "title": "if-you-didn-t-figure-out-why-binary-search-work",
                "content": "# I will try to explain it more simply. What we are essentially doing is going in the direction of the rising slope(by choosing the element which is greater than current).\\n# \\n# How does that guarantee the result? Think about it, there are 2 possibilities.\\n# a) rising slope has to keep rising till end of the array \\n# b) rising slope will encounter a lesser element and go down.\\n# \\n# In both scenarios, we will have an answer. \\n# In a) the answer is the end element because we take the boundary as -INFINITY \\n# b) the answer is the largest element before the slope falls. Hope this makes things clearer.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "# I will try to explain it more simply. What we are essentially doing is going in the direction of the rising slope(by choosing the element which is greater than current).\\n# \\n# How does that guarantee the result? Think about it, there are 2 possibilities.\\n# a) rising slope has to keep rising till end of the array \\n# b) rising slope will encounter a lesser element and go down.\\n# \\n# In both scenarios, we will have an answer. \\n# In a) the answer is the end element because we take the boundary as -INFINITY \\n# b) the answer is the largest element before the slope falls. Hope this makes things clearer.",
                "codeTag": "Unknown"
            },
            {
                "id": 3316829,
                "title": "beats-100-0-ms-very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n if mid comes the first element the we have to only check whether it is greater than than second element or not if greater the that will be peak element.\\n\\nif mid comes the last element then we have to only check whether it is greater than than second last element or not if greater the that will be peak element.\\n\\nif both the condition fails then mid must be in between the 1st and last element then we check if it is greater than both neighbour element if so then return mid. and if not then we check if mid+1 elemnt is less than mid element then it may be possible that the peak element is in right side of mid so we use l=mid+1, if not then peak element may be in left side so we use h=mid-1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        if(nums.length==1)\\n            return 0;\\n        int l=0;\\n        int h=nums.length-1;\\n        while(l<=h)\\n        {\\n            int mid=l+(h-l)/2;\\n            if(mid==0)\\n            {\\n                if(nums[mid]>nums[mid+1])\\n                    return mid;\\n                else\\n                    l=mid+1;\\n            }\\n            else if(mid==nums.length-1)\\n            {\\n                if(nums[mid]>nums[mid-1])\\n                    return mid;\\n                else \\n                    h=mid-1;\\n            }\\n            else\\n            {\\n                if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1])\\n                    return mid;\\n                else if(nums[mid+1]>nums[mid])\\n                    l=mid+1;\\n                else\\n                    h=mid-1;\\n            }\\n        }\\n        return -1;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        if(nums.length==1)\\n            return 0;\\n        int l=0;\\n        int h=nums.length-1;\\n        while(l<=h)\\n        {\\n            int mid=l+(h-l)/2;\\n            if(mid==0)\\n            {\\n                if(nums[mid]>nums[mid+1])\\n                    return mid;\\n                else\\n                    l=mid+1;\\n            }\\n            else if(mid==nums.length-1)\\n            {\\n                if(nums[mid]>nums[mid-1])\\n                    return mid;\\n                else \\n                    h=mid-1;\\n            }\\n            else\\n            {\\n                if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1])\\n                    return mid;\\n                else if(nums[mid+1]>nums[mid])\\n                    l=mid+1;\\n                else\\n                    h=mid-1;\\n            }\\n        }\\n        return -1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276978,
                "title": "one-liner-code-python",
                "content": "\\n\\n# Approach\\n- finding the maximum(which will be obviously a peak element)\\n- then finding the index of that number\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        return nums.index(max(nums))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        return nums.index(max(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255385,
                "title": "easy-c-solution-using-binary-search",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(log n)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int s=0,e=nums.size()-1;\\n        int mid=0;\\n        while(s<e){\\n            mid=s+(e-s)/2;\\n            if(nums[mid]<nums[mid+1])\\n                s=mid+1;\\n            else\\n            e=mid;\\n        }\\n        return s;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int s=0,e=nums.size()-1;\\n        int mid=0;\\n        while(s<e){\\n            mid=s+(e-s)/2;\\n            if(nums[mid]<nums[mid+1])\\n                s=mid+1;\\n            else\\n            e=mid;\\n        }\\n        return s;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182286,
                "title": "java-and-python-simple-and-100-faster-solution-both-memory-and-space",
                "content": "Please upvote if understood \\n\\nJava \\n\\n    public int findPeakElement(int[] nums) {\\n        int n = nums.length ;\\n        if(n==1) return 0;\\n        if(n==2){\\n            if(nums[1]>nums[0])return 1;\\n            if(nums[0]>nums[1]) return 0 ;\\n        }\\n        int s = 0 , e = n-1;\\n        while(s<=e){\\n            int m = s+(e-s)/2 ;\\n            \\n            if(m>0 && m<n-1){\\n                if(nums[m]>nums[m-1] && nums[m]>nums[m+1])return m ;\\n                else if(nums[m]<nums[m-1]) e=m-1;\\n                else if(nums[m]<nums[m+1]) s=m+1;\\n            }else if(m == 0){\\n                if(nums[m]>nums[m+1])return 0;\\n                else s=m+1;\\n            } \\n             else if(m==n-1){\\n                 if(nums[m]>nums[m-1]) return m;\\n                 else e=m-1;\\n             } \\n        }\\n        return -1;\\n    }\\n\\nPython \\n \\n\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        s,e,n = 0,len(nums)-1 ,len(nums);\\n        # test case of array of len 1 and 2 \\n        if n==1:return 0 ;\\n        if n==2:\\n            if nums[1]>nums[0]:return 1;\\n            if nums[0]>nums[1]:return 0;\\n        while s<=e:\\n            m = int(s+(e-s)/2);\\n            if m>0 and m<n-1:\\n                if(nums[m]>nums[m-1] and nums[m]>nums[m+1]): return m;\\n                elif nums[m]<nums[m-1]:e=m-1;\\n                elif nums[m]<nums[m+1]:s=m+1;\\n            elif m==0:\\n                if nums[m]>nums[m+1]:return 0;\\n                else : s=m+1;\\n            elif m==n-1:\\n                if nums[m]>nums[m-1]:return n-1;\\n                else :e=m-1;\\n        return -1;",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "Please upvote if understood \\n\\nJava \\n\\n    public int findPeakElement(int[] nums) {\\n        int n = nums.length ;\\n        if(n==1) return 0;\\n        if(n==2){\\n            if(nums[1]>nums[0])return 1;\\n            if(nums[0]>nums[1]) return 0 ;\\n        }\\n        int s = 0 , e = n-1;\\n        while(s<=e){\\n            int m = s+(e-s)/2 ;\\n            \\n            if(m>0 && m<n-1){\\n                if(nums[m]>nums[m-1] && nums[m]>nums[m+1])return m ;\\n                else if(nums[m]<nums[m-1]) e=m-1;\\n                else if(nums[m]<nums[m+1]) s=m+1;\\n            }else if(m == 0){\\n                if(nums[m]>nums[m+1])return 0;\\n                else s=m+1;\\n            } \\n             else if(m==n-1){\\n                 if(nums[m]>nums[m-1]) return m;\\n                 else e=m-1;\\n             } \\n        }\\n        return -1;\\n    }\\n\\nPython \\n \\n\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        s,e,n = 0,len(nums)-1 ,len(nums);\\n        # test case of array of len 1 and 2 \\n        if n==1:return 0 ;\\n        if n==2:\\n            if nums[1]>nums[0]:return 1;\\n            if nums[0]>nums[1]:return 0;\\n        while s<=e:\\n            m = int(s+(e-s)/2);\\n            if m>0 and m<n-1:\\n                if(nums[m]>nums[m-1] and nums[m]>nums[m+1]): return m;\\n                elif nums[m]<nums[m-1]:e=m-1;\\n                elif nums[m]<nums[m+1]:s=m+1;\\n            elif m==0:\\n                if nums[m]>nums[m+1]:return 0;\\n                else : s=m+1;\\n            elif m==n-1:\\n                if nums[m]>nums[m-1]:return n-1;\\n                else :e=m-1;\\n        return -1;",
                "codeTag": "Python3"
            },
            {
                "id": 3128276,
                "title": "o-log-n-binary-search-with-explanation",
                "content": "```\\n/*\\n    a peak will always exist \\n    why ?\\n    say want to make an arr with no peaks \\n    we first put arr[0]\\n    now arr[1]\\n    arr[0]  > arr[-1] already hence we cant put arr[0] > arr[1] as that will make idx=0 a peak\\n    and we cant put arr[1] = arr[0] as it is rule that arr[i] != arr[i+1]\\n    so only option , arr[1] > arr[0]\\n    \\n    now arr[2]\\n    we cant put arr[1] > arr[2] then 1 becomes peak as arr[1] > arr[0] already  \\n    so arr[2] > arr[1]\\n    \\n    and so on \\n    we cant make any arr[i] < arr[i-1] as it will make arr[i-1] a peak \\n    \\n    so all arr[i] > arr[i-1]\\n    by that pattern arr[n-1] > arr[n-2] \\n    and by default arr[n-1] > arr[n] \\n    so n-1 is peak \\n    so a peak always exists\\n    \\n    ---------\\n    approach 1 : do a linear search -> O(n) time , O(1) space \\n    \\n    approach2  :\\n    since log n is asked , lets try binary search \\n    \\n    binary search ;\\n    remove one part of the array \\n    how to do it ?\\n     \\n    we do binary search \\n    check if mid is a peak  , if yes return mid \\n\\n    otherwise :\\n    \\n    case 1 : arr[mid] lies on uphill means arr[mid-1] < arr[mid] < arr[mid+1]\\n    it means there is a peak  ahead of mid , up the hill --> so cut off behind part ie 0 to mid-1\\n    how are we sure there is a peak ahead ?\\n    we keep going up hill (ahead of mid) means arr[i] < arr[i+1]\\n    we want to reach an index where arr[i] > arr[i+1] ==> i is peak\\n    if we dont find such i , we eventually reach i=n-1 \\n    and by default arr[n-1] > arr[n] ==> n-1 is peak\\n    \\n    case 2: arr[mid] lies on downhill , means arr[mid-1] > arr[mid] > arr[mid+1]\\n    so  there is peak behind mid , so cut off ahead part ie mid+1 .... n-1\\n     how are we sure there is a peak behind ?\\n    we start to traverse uphill in reverse direction(behind mid)\\n    we want to reach an index where arr[i] > arr[i-1] ==> i is peak\\n    if we dont find such i , we eventually reach i=0\\n    and by default arr[0] > arr[-1] ==-> 0 is peak\\n    \\n    case 3 : it is a deep point , arr[i-1] > arr[i] < arr[i+1]\\n    we can go either way \\n    \\n    as we cut off parts --> O(log n)\\n    \\n*/\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& arr) {\\n        int n = arr.size();\\n       \\n        int lo = 0 , hi = n-1;\\n        while(lo <= hi)\\n        {\\n            int m= lo + (hi - lo)/2;\\n            \\n            bool greaterThanPrev = m == 0 || arr[m] > arr[m-1];\\n            // as arr[-1] = -inf , greater than prev is true for index = 0\\n            \\n            bool greaterThanNext = m==n-1 || arr[m] > arr[m+1];\\n            // as arr[n] = -inf , greater than next is true for index = n-1\\n            \\n            // check if peak , ie greater than prev and greater than next \\n            if(greaterThanPrev && greaterThanNext) return m; // it is a peak\\n            \\n            // check if lies on uphill ie greaterThanPrev but NOT greaterThanNext\\n            if(greaterThanPrev && !greaterThanNext) \\n            {\\n                // lies on uphill , so peak is ahead => cut off the behind part\\n                lo = m+1;\\n            }\\n            else\\n            {\\n                // lies on downhill ,peak is behind => cut of the ahead part\\n                hi = m-1;\\n            }\\n            \\n        }\\n        return -1; // dummy\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    a peak will always exist \\n    why ?\\n    say want to make an arr with no peaks \\n    we first put arr[0]\\n    now arr[1]\\n    arr[0]  > arr[-1] already hence we cant put arr[0] > arr[1] as that will make idx=0 a peak\\n    and we cant put arr[1] = arr[0] as it is rule that arr[i] != arr[i+1]\\n    so only option , arr[1] > arr[0]\\n    \\n    now arr[2]\\n    we cant put arr[1] > arr[2] then 1 becomes peak as arr[1] > arr[0] already  \\n    so arr[2] > arr[1]\\n    \\n    and so on \\n    we cant make any arr[i] < arr[i-1] as it will make arr[i-1] a peak \\n    \\n    so all arr[i] > arr[i-1]\\n    by that pattern arr[n-1] > arr[n-2] \\n    and by default arr[n-1] > arr[n] \\n    so n-1 is peak \\n    so a peak always exists\\n    \\n    ---------\\n    approach 1 : do a linear search -> O(n) time , O(1) space \\n    \\n    approach2  :\\n    since log n is asked , lets try binary search \\n    \\n    binary search ;\\n    remove one part of the array \\n    how to do it ?\\n     \\n    we do binary search \\n    check if mid is a peak  , if yes return mid \\n\\n    otherwise :\\n    \\n    case 1 : arr[mid] lies on uphill means arr[mid-1] < arr[mid] < arr[mid+1]\\n    it means there is a peak  ahead of mid , up the hill --> so cut off behind part ie 0 to mid-1\\n    how are we sure there is a peak ahead ?\\n    we keep going up hill (ahead of mid) means arr[i] < arr[i+1]\\n    we want to reach an index where arr[i] > arr[i+1] ==> i is peak\\n    if we dont find such i , we eventually reach i=n-1 \\n    and by default arr[n-1] > arr[n] ==> n-1 is peak\\n    \\n    case 2: arr[mid] lies on downhill , means arr[mid-1] > arr[mid] > arr[mid+1]\\n    so  there is peak behind mid , so cut off ahead part ie mid+1 .... n-1\\n     how are we sure there is a peak behind ?\\n    we start to traverse uphill in reverse direction(behind mid)\\n    we want to reach an index where arr[i] > arr[i-1] ==> i is peak\\n    if we dont find such i , we eventually reach i=0\\n    and by default arr[0] > arr[-1] ==-> 0 is peak\\n    \\n    case 3 : it is a deep point , arr[i-1] > arr[i] < arr[i+1]\\n    we can go either way \\n    \\n    as we cut off parts --> O(log n)\\n    \\n*/\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& arr) {\\n        int n = arr.size();\\n       \\n        int lo = 0 , hi = n-1;\\n        while(lo <= hi)\\n        {\\n            int m= lo + (hi - lo)/2;\\n            \\n            bool greaterThanPrev = m == 0 || arr[m] > arr[m-1];\\n            // as arr[-1] = -inf , greater than prev is true for index = 0\\n            \\n            bool greaterThanNext = m==n-1 || arr[m] > arr[m+1];\\n            // as arr[n] = -inf , greater than next is true for index = n-1\\n            \\n            // check if peak , ie greater than prev and greater than next \\n            if(greaterThanPrev && greaterThanNext) return m; // it is a peak\\n            \\n            // check if lies on uphill ie greaterThanPrev but NOT greaterThanNext\\n            if(greaterThanPrev && !greaterThanNext) \\n            {\\n                // lies on uphill , so peak is ahead => cut off the behind part\\n                lo = m+1;\\n            }\\n            else\\n            {\\n                // lies on downhill ,peak is behind => cut of the ahead part\\n                hi = m-1;\\n            }\\n            \\n        }\\n        return -1; // dummy\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098227,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n    int first=0;\\n    int last=nums.length-1;\\n    while(first<last){\\n    int mid=(first+(last-1))/2;\\n        if(nums[mid]>nums[mid+1]){\\n            last=mid;\\n        }else{\\n            first=mid+1;\\n        }\\n\\n    } \\n    return first;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n    int first=0;\\n    int last=nums.length-1;\\n    while(first<last){\\n    int mid=(first+(last-1))/2;\\n        if(nums[mid]>nums[mid+1]){\\n            last=mid;\\n        }else{\\n            first=mid+1;\\n        }\\n\\n    } \\n    return first;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020043,
                "title": "binary-search-java-solution",
                "content": "# Intuition\\n<!-- Theory is well mentioned in LeetCode official solution which is open for everyone.-->\\n\\n# Approach\\nWe have two edge cases when mid is at start and end index. We handled them at starting and rest is just checking wether sequence is in ascending or descending order and changing our start and end pointers accordingly.\\n<!-- -->\\n\\n# Complexity\\n- Time complexity: O(log(n)), at every time we shrink the search space to half resulting in log(n) time complexity.\\n<!-- O(log(n)), at every time we shrink the search space to half resulting in log(n) time complexity. -->\\n\\n- Space complexity :O(1), we are not using any extra space.\\n<!--  -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        return binarySearch(nums, nums.length - 1);\\n    }\\n\\n    public int binarySearch(int[] arr, int n) {\\n        int start = 0, end = n - 1;\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if (mid == 0) {\\n                if(arr[mid] > arr[mid + 1]) {\\n                    return mid;\\n                }\\n            }\\n            if (mid == n) {\\n                if (arr[mid] >= arr[mid - 1]) {\\n                    return mid;\\n                }\\n            }\\n            if (arr[mid] > arr[mid + 1]) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n            \\n        }\\n        return start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        return binarySearch(nums, nums.length - 1);\\n    }\\n\\n    public int binarySearch(int[] arr, int n) {\\n        int start = 0, end = n - 1;\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if (mid == 0) {\\n                if(arr[mid] > arr[mid + 1]) {\\n                    return mid;\\n                }\\n            }\\n            if (mid == n) {\\n                if (arr[mid] >= arr[mid - 1]) {\\n                    return mid;\\n                }\\n            }\\n            if (arr[mid] > arr[mid + 1]) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n            \\n        }\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987187,
                "title": "an-easy-to-understand-c-solution-runtime-2-ms-beats-93-40",
                "content": "<!-- # Intuition\\nDescribe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly, we consider the case where there are only 1 and 2 elements in the array.\\nSecondly, since we might face the problem when we are trying to do comparisons in binary search dealling with `nums[0]` and `nums[lastone]`, we take care of it now.\\nLastly, we handle the binary search for rest of the element if need(i.e. left start at `1` and right start at `nums.size()-2`). In such case, we can do comparison without index errors.\\n# Complexity\\n- Time complexity:`O(logn)`\\nRuntime: 2 ms, Beats 93.40%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(1)`\\nMemory: 8.8 MB, Beats 74.43%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1) return 0;\\n        if(nums.size()==2)\\n            return (nums[0]>nums[1]? 0:1);\\n\\n        if(nums[0]>nums[1])  return 0;\\n        if(nums[nums.size()-1]>nums[nums.size()-2])  \\n            return nums.size()-1;\\n\\n        int l = 1, r = nums.size()-2, mid;       \\n\\n        while(l<=r){\\n            mid = l+(r-l)/2;\\n            if (nums[mid]>nums[mid+1] \\n                    && nums[mid]>nums[mid-1]){\\n                    return mid;\\n                }else if(nums[mid+1]>=nums[mid-1]){\\n                    l = mid+1;\\n                }else{\\n                    r = mid-1;\\n                }\\n        }\\n        return -1;\\n    }\\n};\\n```\\nThis is my first time posting solution, it is welcome to comment below and raise questions. I will do my best to reply all Q.\\n\\n**EDIT**: when we are doing the \"else\" statement in binary search, there are three cases.\\n1. both side are greater than `mid`, and since the last/first element is not a peak, there must be a peak in middle.\\n2. one side is higher than `mid` and by choosing that side, we have the same argument as there must be a peak.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1) return 0;\\n        if(nums.size()==2)\\n            return (nums[0]>nums[1]? 0:1);\\n\\n        if(nums[0]>nums[1])  return 0;\\n        if(nums[nums.size()-1]>nums[nums.size()-2])  \\n            return nums.size()-1;\\n\\n        int l = 1, r = nums.size()-2, mid;       \\n\\n        while(l<=r){\\n            mid = l+(r-l)/2;\\n            if (nums[mid]>nums[mid+1] \\n                    && nums[mid]>nums[mid-1]){\\n                    return mid;\\n                }else if(nums[mid+1]>=nums[mid-1]){\\n                    l = mid+1;\\n                }else{\\n                    r = mid-1;\\n                }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944061,
                "title": "python3-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        return nums.index(max(nums))\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/70c88d43-4548-44bb-bc34-d1dee758adbf_1671848785.203704.png)\\n![image.png](https://assets.leetcode.com/users/images/ba1d33b2-0b58-41c0-b15a-288c4f1f1a5c_1671848816.033144.png)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        return nums.index(max(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2910612,
                "title": "c-2-lines-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe just need to find the index of the maximum element present in the array. We can do this by using [max_element](https://cplusplus.com/reference/algorithm/max_element/) function in STL\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int ans= max_element(nums.begin(),nums.end())-nums.begin();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int ans= max_element(nums.begin(),nums.end())-nums.begin();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804651,
                "title": "binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n         int start=0;\\n        int end=nums.length-1;\\n        while(start<end)\\n        {\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]<nums[mid+1])\\n            {\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid;\\n            }\\n            \\n        }\\n        return start;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n         int start=0;\\n        int end=nums.length-1;\\n        while(start<end)\\n        {\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]<nums[mid+1])\\n            {\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid;\\n            }\\n            \\n        }\\n        return start;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459311,
                "title": "c-binary-search-solution-with-explanation",
                "content": "**1. Why does binary search works here?**\\nAns :- Reasons why binary search may not work - Array is not sorted.\\n\\nWhy binary search works :- \\n1. The boundary elements are always greater than elements outside the array.\\n2. For ex :- In this array [1,2,1,3,5,6,7],  \\nThe initial value of left = 0 and right = nums.size()-1,\\nmid = left + (right - left) / 2;\\ni.e. mid = 0 + (6 - 0)/2 = 3\\nNote: We haven\\'t used mid = (left + right) / 2; because (left + right) can lead to overflow.\\nAccording to the algorithm implimented we will go to left but suppose their is no peak element to the right of nums[mid] (2 is the peak element) but because the boundary element are greater than elements outside the array although the elements to the right are increasing we will surely find peak element at the last.\\n3. To optimise the code further we have checked boundary condition whether the boundary elements are peak elements or not.\\n\\nC++ code :-\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        \\n\\t\\t//if array contains only 1 element that will be the peak element\\n        if(nums.size() == 1) return 0;\\n\\t\\t\\n\\t\\t//Checking if 0th element is peak element\\n        if(nums[0] > nums[1]) return 0;\\n\\t\\t\\n\\t\\t//Checking if last element is peak elementor not\\n        if(nums[nums.size()-1] > nums[nums.size()-2]) return nums.size() - 1;\\n        \\n\\t\\t//Standard binary search\\n        int s = 0, e = nums.size()-1;\\n        \\n        while(s <= e)\\n        {\\n            int mid = s + (e-s)/2;\\n\\t\\t\\t\\n\\t\\t\\t//Checking if mid element is peak element\\n            if(nums[mid] > nums[mid + 1] && nums[mid] > nums[mid - 1]) return mid;\\n\\t\\t\\t\\n            else if(nums[mid] < nums[mid + 1]) s = mid + 1;\\n            else e = mid - 1;\\n        }\\n\\t\\t\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        \\n\\t\\t//if array contains only 1 element that will be the peak element\\n        if(nums.size() == 1) return 0;\\n\\t\\t\\n\\t\\t//Checking if 0th element is peak element\\n        if(nums[0] > nums[1]) return 0;\\n\\t\\t\\n\\t\\t//Checking if last element is peak elementor not\\n        if(nums[nums.size()-1] > nums[nums.size()-2]) return nums.size() - 1;\\n        \\n\\t\\t//Standard binary search\\n        int s = 0, e = nums.size()-1;\\n        \\n        while(s <= e)\\n        {\\n            int mid = s + (e-s)/2;\\n\\t\\t\\t\\n\\t\\t\\t//Checking if mid element is peak element\\n            if(nums[mid] > nums[mid + 1] && nums[mid] > nums[mid - 1]) return mid;\\n\\t\\t\\t\\n            else if(nums[mid] < nums[mid + 1]) s = mid + 1;\\n            else e = mid - 1;\\n        }\\n\\t\\t\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439204,
                "title": "c-binary-search-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        //O(logn)\\n        \\n        int lo = 0 , hi = nums.size() - 1;\\n        while(lo <= hi){\\n            int mid = lo + (hi-lo) / 2 ;\\n            int L = mid - 1 >= 0 ? nums[mid - 1] : INT_MIN ;\\n            int R = mid + 1 < nums.size() ? nums[mid + 1] : INT_MIN ;\\n            \\n            if(nums[mid] >= L and nums[mid] >= R) return mid ;\\n            else if(L >= R) hi = mid - 1 ;\\n            else if(R > L) lo = mid + 1 ;\\n        }\\n        \\n        return -1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        //O(logn)\\n        \\n        int lo = 0 , hi = nums.size() - 1;\\n        while(lo <= hi){\\n            int mid = lo + (hi-lo) / 2 ;\\n            int L = mid - 1 >= 0 ? nums[mid - 1] : INT_MIN ;\\n            int R = mid + 1 < nums.size() ? nums[mid + 1] : INT_MIN ;\\n            \\n            if(nums[mid] >= L and nums[mid] >= R) return mid ;\\n            else if(L >= R) hi = mid - 1 ;\\n            else if(R > L) lo = mid + 1 ;\\n        }\\n        \\n        return -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429613,
                "title": "c-100-faster-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int s=0,e=nums.size()-1;\\n        int mid=s+(e-s)/2;\\n\\t\\t\\t // if size is 1\\n\\t\\tif(e==0)\\n            return 0;\\n\\t\\t\\t\\n\\t\\t\\t// if size is 2\\n        else if(e==1 && nums[0]>nums[1])\\n            return 0;\\n        else if(e==1 && nums[1]>nums[0])\\n            return 1;\\n\\t\\t\\t\\n\\t\\t\\t// if size is greater than 2\\n        else{\\n                while(s<=e)\\n                {\\n\\n                    if(mid!=e && nums[mid+1]>nums[mid])\\n                        s=mid+1;\\n                    else if(mid!=0 && nums[mid-1]>nums[mid])\\n                        e=mid-1;\\n                    else\\n                        break;\\n\\n                    mid=s+(e-s)/2;\\n                }\\n                return mid;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int s=0,e=nums.size()-1;\\n        int mid=s+(e-s)/2;\\n\\t\\t\\t // if size is 1\\n\\t\\tif(e==0)\\n            return 0;\\n\\t\\t\\t\\n\\t\\t\\t// if size is 2\\n        else if(e==1 && nums[0]>nums[1])\\n            return 0;\\n        else if(e==1 && nums[1]>nums[0])\\n            return 1;\\n\\t\\t\\t\\n\\t\\t\\t// if size is greater than 2\\n        else{\\n                while(s<=e)\\n                {\\n\\n                    if(mid!=e && nums[mid+1]>nums[mid])\\n                        s=mid+1;\\n                    else if(mid!=0 && nums[mid-1]>nums[mid])\\n                        e=mid-1;\\n                    else\\n                        break;\\n\\n                    mid=s+(e-s)/2;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2352009,
                "title": "huge-hint-in-question-o-logn-c",
                "content": "**Hint: Both ends have negative infinity associated.** \\nIf an index is not a peak then alteast one of its neighbour is greater than it. \\nIn that case narrow down the search to subarry from that greater element to neg infinity. \\n\\nBecause now atleast one index is bound to be the peak in that range. In case the range is all sorted then the initial neighbour is itself the peak. as shown below.\\n\\n```\\nx<15 \\nx, 15, 18, 20, INT_MIN\\nx, 15, 9, 8, INT_MIN\\n```\\n\\n**Binary Search**\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) \\n    {\\n        int n= nums.size();\\n        int s=0,e=n-1;\\n        \\n        if(n==1) return 0;\\n        \\n        while(s<=e)\\n        {\\n            int mid= (s+e)/2;\\n            \\n            if(mid==0)\\n            {\\n                if(nums[0]>nums[1])\\n                return 0;\\n                \\n                else s=1;\\n                continue;\\n            }\\n            \\n            else if(mid==n-1)\\n            {\\n                if(nums[mid]>nums[mid-1])\\n                return n-1;\\n                \\n                else e= n-2;\\n                continue;\\n            }\\n            \\n            if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1]) return mid;\\n            \\n            if(nums[mid]<=nums[mid-1])\\n            e=mid-1;    \\n            \\n            else\\n            s= mid+1;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nx<15 \\nx, 15, 18, 20, INT_MIN\\nx, 15, 9, 8, INT_MIN\\n```\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) \\n    {\\n        int n= nums.size();\\n        int s=0,e=n-1;\\n        \\n        if(n==1) return 0;\\n        \\n        while(s<=e)\\n        {\\n            int mid= (s+e)/2;\\n            \\n            if(mid==0)\\n            {\\n                if(nums[0]>nums[1])\\n                return 0;\\n                \\n                else s=1;\\n                continue;\\n            }\\n            \\n            else if(mid==n-1)\\n            {\\n                if(nums[mid]>nums[mid-1])\\n                return n-1;\\n                \\n                else e= n-2;\\n                continue;\\n            }\\n            \\n            if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1]) return mid;\\n            \\n            if(nums[mid]<=nums[mid-1])\\n            e=mid-1;    \\n            \\n            else\\n            s= mid+1;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180107,
                "title": "different-and-easiest-code-than-others-with-binary-search-100-faster-and-unique-than-others",
                "content": "```\\npublic class Solution {\\n    public int findPeakElement(int[] a) {\\n        \\n        // Brute Force - O(n)\\n        // int n = a.length;\\n        // for (int i = 0; i < n - 1; i++) {\\n        //     if (a[i] > a[i + 1])\\n        //         return i;\\n        // }\\n        // return n-1;\\n        \\n        // Through Binary Search\\n        int n = a.length;\\n        int start = 0;\\n        int end = n-1;\\n        if (start==end)\\n            return start;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if(mid>0 && mid<n-1){\\n                if(a[mid]>a[(mid-1+n)%n] && a[mid]>a[(mid+1)%n])\\n                    return mid;\\n                else if(a[(mid-1+n)%n]>a[mid])\\n                    end = mid-1;\\n                else if(a[(mid+1)%n]>a[mid])\\n                    start = mid + 1;\\n            }\\n            else if(mid==0){\\n                if(a[0]>a[1])\\n                    return 0;\\n                else\\n                    return 1;\\n            }\\n            else if(mid == n-1){\\n                if(a[n-1]>a[n-2])\\n                    return (n-1);\\n                else\\n                    return (n-2);\\n            }\\n        }\\n        return -1;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int findPeakElement(int[] a) {\\n        \\n        // Brute Force - O(n)\\n        // int n = a.length;\\n        // for (int i = 0; i < n - 1; i++) {\\n        //     if (a[i] > a[i + 1])\\n        //         return i;\\n        // }\\n        // return n-1;\\n        \\n        // Through Binary Search\\n        int n = a.length;\\n        int start = 0;\\n        int end = n-1;\\n        if (start==end)\\n            return start;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if(mid>0 && mid<n-1){\\n                if(a[mid]>a[(mid-1+n)%n] && a[mid]>a[(mid+1)%n])\\n                    return mid;\\n                else if(a[(mid-1+n)%n]>a[mid])\\n                    end = mid-1;\\n                else if(a[(mid+1)%n]>a[mid])\\n                    start = mid + 1;\\n            }\\n            else if(mid==0){\\n                if(a[0]>a[1])\\n                    return 0;\\n                else\\n                    return 1;\\n            }\\n            else if(mid == n-1){\\n                if(a[n-1]>a[n-2])\\n                    return (n-1);\\n                else\\n                    return (n-2);\\n            }\\n        }\\n        return -1;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682822,
                "title": "java-0ms-solution-100",
                "content": "```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        int i=0;\\n        int j=0;\\n        if(nums.length==1){\\n            return 0;\\n        }\\n        \\n        while(j<nums.length){\\n            if(j<nums.length){\\n                j++;\\n            }\\n            if( j<nums.length && nums[i]>nums[j]){\\n                return i;\\n            }\\n            else if(nums[j]>nums[i] && j==nums.length-1){\\n                return j;\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        int i=0;\\n        int j=0;\\n        if(nums.length==1){\\n            return 0;\\n        }\\n        \\n        while(j<nums.length){\\n            if(j<nums.length){\\n                j++;\\n            }\\n            if( j<nums.length && nums[i]>nums[j]){\\n                return i;\\n            }\\n            else if(nums[j]>nums[i] && j==nums.length-1){\\n                return j;\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666467,
                "title": "c-solution-8-lines-easy-to-understand",
                "content": "```\\nint findPeakElement(vector<int>& nums) {\\n        int n = nums.size(), low = 0, high = n-1;\\n        while(true){\\n            int mid = (low+high)/2;\\n            if(low==high)  return low;\\n            if(nums[mid] > nums[mid+1]) high = mid; \\n            else                        low = mid+1;            \\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findPeakElement(vector<int>& nums) {\\n        int n = nums.size(), low = 0, high = n-1;\\n        while(true){\\n            int mid = (low+high)/2;\\n            if(low==high)  return low;\\n            if(nums[mid] > nums[mid+1]) high = mid; \\n            else                        low = mid+1;            \\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1481937,
                "title": "easy-solution-using-stacks-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n      stack<int>st;\\n        int x;\\n        if(nums.size()==1){\\n            x=0;\\n        }\\n        st.push(nums[0]);\\n       int a;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>=st.top()){\\n                st.push(nums[i]);\\n                a=st.top();\\n            }\\n            else if(nums[i]<st.top()){\\n                a=st.top();\\n                break;\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==a){\\n                x=i;\\n                break;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```\\nE",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n      stack<int>st;\\n        int x;\\n        if(nums.size()==1){\\n            x=0;\\n        }\\n        st.push(nums[0]);\\n       int a;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>=st.top()){\\n                st.push(nums[i]);\\n                a=st.top();\\n            }\\n            else if(nums[i]<st.top()){\\n                a=st.top();\\n                break;\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==a){\\n                x=i;\\n                break;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1477294,
                "title": "binary-search-c-100-faster",
                "content": "```\\n  int findPeakElement(vector<int>& nums) {\\n        int l=0,r=nums.size()-1;\\n        while(l<=r){\\n            int mid = l + (r-l)/2;\\n            if(mid==0||nums[mid]>nums[mid-1]){\\n                if((mid==nums.size()-1||nums[mid]>nums[mid+1])){\\n                 return mid;   \\n                }else{\\n                    l=mid+1;\\n                }\\n            }else {\\n                r=mid-1;\\n            }\\n        }\\n               return -1;\\n    }",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n  int findPeakElement(vector<int>& nums) {\\n        int l=0,r=nums.size()-1;\\n        while(l<=r){\\n            int mid = l + (r-l)/2;\\n            if(mid==0||nums[mid]>nums[mid-1]){\\n                if((mid==nums.size()-1||nums[mid]>nums[mid+1])){\\n                 return mid;   \\n                }else{\\n                    l=mid+1;\\n                }\\n            }else {\\n                r=mid-1;\\n            }\\n        }\\n               return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1338891,
                "title": "javascript-easy-solution",
                "content": "```\\nvar findPeakElement = function(a) {\\n    let low = 0\\n    let high = a.length-1\\n    \\n while(low<high){\\n     //for every array there should be atleast one peak exists\\n     \\n    let mid = Math.floor((low+high)/2)\\n    \\n     if(a[mid]<a[mid+1]){\\n         low = mid+1\\n     }\\n     else if(a[mid]>a[mid+1]){\\n         high =mid\\n     } \\n     \\n }\\n\\n    return low\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar findPeakElement = function(a) {\\n    let low = 0\\n    let high = a.length-1\\n    \\n while(low<high){\\n     //for every array there should be atleast one peak exists\\n     \\n    let mid = Math.floor((low+high)/2)\\n    \\n     if(a[mid]<a[mid+1]){\\n         low = mid+1\\n     }\\n     else if(a[mid]>a[mid+1]){\\n         high =mid\\n     } \\n     \\n }\\n\\n    return low\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1335852,
                "title": "c-brute-force-vs-bs-solution-explained-100-time-70-space",
                "content": "Easier bit first, the brute force solution!\\n\\nWe will use a sole support variable, `len`, initialised to be the length of the input minus `1`.\\n\\nThen time to get a few edge cases out of the way, returning `0` if we either had a sole element in the sequence (`!len`) or if the first element is bigger than a second (still a local maximum, in case); specularly to this case, if the last element is bigger than the penultimate, we will return `len`.\\n\\nWith that out of the way, we can just go with `i` from `1` to `len` (excluded) and:\\n* assign `i + 1` to `nxt;\\n* check if `i` points to a number greater than the one pointed by both `prev` and `nxt` and in case return `i`;\\n* update both `prv` and `i` for the next iteration.\\n\\nIn order to make the compiler happy, we will write a `return -1` line at the end of it that, given our specs (no consecutive equal numbers) will never be called and we are done :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size() - 1;\\n        // edge cases:\\n        // mono-element input or first element as a peak\\n        if (!len || nums[0] > nums[1]) return 0;\\n        // last element as a peak\\n        if (nums[len - 1] < nums[len]) return len;\\n        // parsing all the internal elements\\n        for (int i = 1, prv = 0, nxt; i < len;) {\\n            nxt = i + 1;\\n            // checking for a peak\\n            if (nums[prv] < nums[i] && nums[i] > nums[nxt]) return i;\\n            // updating for the next run\\n            prv = i;\\n            i = nxt;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nNow, same code for edge cases, but a different inner loop: we will have `l`, `mid` and `r` to help us in our search, with the first set to `0` and the last replacing `len` in our previous logic.\\n\\nWe will then loop until `l < r` and:\\n* compute `mid` as the average of `l` and `r`;\\n* check if  the current element pointed by `mid` is greater than the following (`nums[mid] > nums[mid + 1]`), in which case, we have 2 options:\\n\\t* if also the previous number is lesser (`nums[mid] > nums[mid - 1]`), then we have a match and can return `mid`;\\n\\t* otherwise, we know that the right part is decreasing, so we want to start look the other way around and thus we will update `r` to be `mid`;\\n* otherwise, we know that the bit at the left of `mid` is not decreasing and update `l` to be `mid`.\\n\\nThe code (which is a bit faster, but also seem to consume a bit more memory).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        // support variables\\n        int l = 0, mid, r = nums.size() - 1;\\n        // edge cases:\\n        // mono-element input or first element as a peak\\n        if (!r || nums[0] > nums[1]) return 0;\\n        // last element as a peak\\n        if (nums[r - 1] < nums[r]) return r;\\n        // binary searching the input\\n        while (l < r) {\\n            mid = (l + r) / 2;\\n            if (nums[mid] > nums[mid + 1]) {\\n                if (nums[mid] > nums[mid - 1]) return mid;\\n                else r = mid;\\n            }\\n            else l = mid;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size() - 1;\\n        // edge cases:\\n        // mono-element input or first element as a peak\\n        if (!len || nums[0] > nums[1]) return 0;\\n        // last element as a peak\\n        if (nums[len - 1] < nums[len]) return len;\\n        // parsing all the internal elements\\n        for (int i = 1, prv = 0, nxt; i < len;) {\\n            nxt = i + 1;\\n            // checking for a peak\\n            if (nums[prv] < nums[i] && nums[i] > nums[nxt]) return i;\\n            // updating for the next run\\n            prv = i;\\n            i = nxt;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        // support variables\\n        int l = 0, mid, r = nums.size() - 1;\\n        // edge cases:\\n        // mono-element input or first element as a peak\\n        if (!r || nums[0] > nums[1]) return 0;\\n        // last element as a peak\\n        if (nums[r - 1] < nums[r]) return r;\\n        // binary searching the input\\n        while (l < r) {\\n            mid = (l + r) / 2;\\n            if (nums[mid] > nums[mid + 1]) {\\n                if (nums[mid] > nums[mid - 1]) return mid;\\n                else r = mid;\\n            }\\n            else l = mid;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335027,
                "title": "c-easy-binary-search-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int helper(vector<int>& a, int l, int r, int n){\\n        int mid = l + (r-l)/2;\\n        if((mid == 0 || a[mid-1]< a[mid]) && (mid==n-1 || a[mid+1] < a[mid])){\\n            return mid;\\n        }else if(mid > 0 && a[mid-1] > a[mid]){\\n            return helper(a,l,mid-1,n);\\n        }\\n        return helper(a,mid+1,r,n);\\n    }\\n    \\n    int findPeakElement(vector<int>& a) {\\n        return helper(a,0,a.size()-1,a.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int helper(vector<int>& a, int l, int r, int n){\\n        int mid = l + (r-l)/2;\\n        if((mid == 0 || a[mid-1]< a[mid]) && (mid==n-1 || a[mid+1] < a[mid])){\\n            return mid;\\n        }else if(mid > 0 && a[mid-1] > a[mid]){\\n            return helper(a,l,mid-1,n);\\n        }\\n        return helper(a,mid+1,r,n);\\n    }\\n    \\n    int findPeakElement(vector<int>& a) {\\n        return helper(a,0,a.size()-1,a.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334609,
                "title": "c-binary-search-with-intuitive-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int> &A) {\\n        int n = A.size();\\n        if(n == 1)\\n            return 0;\\n        \\n        if(A[0] > A[1]) return 0;\\n        if(A[n-1] > A[n-2]) return n-1;\\n\\n        int l = 1, r = n-2; //since, we already checked for 0 and (n-1) indices above\\n        int mid;\\n        \\n        /*\\n            case-1:\\n              mid(peak)\\n                /\\\\\\n            .../  \\\\...\\n            \\n            \\n            case-2:\\n              (peak)\\n                /\\\\\\n            .../  \\\\mid...\\n            \\n            \\n            case-3:\\n                 (peak)\\n                   /\\\\\\n            ...mid/  \\\\...\\n        */\\n        \\n        while(l < r) {\\n            mid = l + (r-l)/2;\\n            \\n            if(A[mid] > A[mid-1] && A[mid] > A[mid+1]) //1. mid is PEAK\\n                return mid;\\n            \\n            if(A[mid] < A[mid-1])      //2. mid is right to PEAK. So, go towards left\\n                r = mid-1;\\n            else if(A[mid] < A[mid+1]) //3. mid is left to PEAK. So, go towards right\\n                l = mid+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int> &A) {\\n        int n = A.size();\\n        if(n == 1)\\n            return 0;\\n        \\n        if(A[0] > A[1]) return 0;\\n        if(A[n-1] > A[n-2]) return n-1;\\n\\n        int l = 1, r = n-2; //since, we already checked for 0 and (n-1) indices above\\n        int mid;\\n        \\n        /*\\n            case-1:\\n              mid(peak)\\n                /\\\\\\n            .../  \\\\...\\n            \\n            \\n            case-2:\\n              (peak)\\n                /\\\\\\n            .../  \\\\mid...\\n            \\n            \\n            case-3:\\n                 (peak)\\n                   /\\\\\\n            ...mid/  \\\\...\\n        */\\n        \\n        while(l < r) {\\n            mid = l + (r-l)/2;\\n            \\n            if(A[mid] > A[mid-1] && A[mid] > A[mid+1]) //1. mid is PEAK\\n                return mid;\\n            \\n            if(A[mid] < A[mid-1])      //2. mid is right to PEAK. So, go towards left\\n                r = mid-1;\\n            else if(A[mid] < A[mid+1]) //3. mid is left to PEAK. So, go towards right\\n                l = mid+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297790,
                "title": "explanation-hints-100-fast",
                "content": "Hello Leetcoders,\\nFirst of all, we have to appreciate this question. It is a good question as we have to apply binary search using clues found in the question.\\n\\nSo what are the clues: \\n1. No two adjacent elements are equal.\\n2. nums[-1] = nums[n] = -\\u221E\\n3. There can be more than 1 peak.\\n\\nIf you are unable to solve the question yet then take these hints/clues and try again this question.\\n\\nExplanation-: \\n\\nFirst of all, we have to check the boundary values, if any boundary value makes a peak return it. If not, then remember this thing.\\n\\nNow my intuition, I will apply binary search and found mid, if mid is greater than adjacents then return it. Otherwise check the direction of slope. \\nExample -: if value at mid is 3 and value at mid-1 is 2 and value at mid+1 is 4, then the slope at left is down and slope at right is up.\\n\\nNow we know that boundary value is not a peak. Then the side of slope which is up reaches to a point and get decreased. So, our peak should be in this side.\\n\\nThats all.\\nHave a look at the solution and try to understand it.\\nAny problem with the code let me know in comments.\\n\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1 || nums[0] > nums[1]) return 0;\\n        if(nums[n-1] > nums[n-2]) return n-1;\\n        int start = 1, end = n-2;\\n        int mid;\\n        \\n        while(start <= end) {\\n            mid = start + (end-start)/2;\\n            if(nums[mid] > nums[mid-1] && nums[mid] > nums[mid+1]) {\\n                return mid;\\n            }\\n            else if(nums[mid-1] < nums[mid] && nums[mid+1] > nums[mid]) {\\n                start = mid+1;\\n            }\\n            else if(nums[mid-1] > nums[mid] && nums[mid+1] < nums[mid]) {\\n                end = mid-1;\\n            }\\n            else if(nums[mid-1] > nums[mid] && nums[mid+1] > nums[mid]) {\\n                end = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\nIf found useful,** please upvote it**",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1 || nums[0] > nums[1]) return 0;\\n        if(nums[n-1] > nums[n-2]) return n-1;\\n        int start = 1, end = n-2;\\n        int mid;\\n        \\n        while(start <= end) {\\n            mid = start + (end-start)/2;\\n            if(nums[mid] > nums[mid-1] && nums[mid] > nums[mid+1]) {\\n                return mid;\\n            }\\n            else if(nums[mid-1] < nums[mid] && nums[mid+1] > nums[mid]) {\\n                start = mid+1;\\n            }\\n            else if(nums[mid-1] > nums[mid] && nums[mid+1] < nums[mid]) {\\n                end = mid-1;\\n            }\\n            else if(nums[mid-1] > nums[mid] && nums[mid+1] > nums[mid]) {\\n                end = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252146,
                "title": "c-binary-search-solution",
                "content": "Remember there can be only 3 case:\\n1. Array is in ascending order, in that case, the last element is always is the peak element\\n2. Array is in decreasing order, in that case, the first element is always is the peak element\\n3. Array has arbitary order of elements and hence we do the following:\\nWe check for mid, if nums[mid] is smaller than nums[mid+1], we start searching in right hand side, as remember, next to mid+1 be smaller or larger, we will definetely have a peak element in the right hand side (at mid+1 itself or until nums.size()-1)\\nIf nums[mid] is smaller than nums[mid-1], we start searching in left hand side, as next to mid-1 be smaller or larger, we will definetely have a peak element in the left hand side (at mid-1 itself or until 0). \\nIf mid is the peak element, return it.\\nThus, we have the following code:\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return 0;\\n        int low=0, high=nums.size()-1;\\n        while(low<=high)\\n        {\\n            int mid = low + (high-low)/2;\\n            if(mid==0)\\n            {\\n                if(nums[mid]>nums[mid+1])\\n                    return mid;\\n            }\\n            else if(mid==nums.size()-1)\\n            {\\n                if(nums[mid]>nums[mid-1])\\n                    return mid;\\n            }\\n            else if(nums[mid]>nums[mid-1]&&nums[mid]>nums[mid+1])\\n                    return mid;\\n            if(nums[mid+1]>nums[mid])\\n                low = mid+1;\\n            else \\n                high = mid-1;\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return 0;\\n        int low=0, high=nums.size()-1;\\n        while(low<=high)\\n        {\\n            int mid = low + (high-low)/2;\\n            if(mid==0)\\n            {\\n                if(nums[mid]>nums[mid+1])\\n                    return mid;\\n            }\\n            else if(mid==nums.size()-1)\\n            {\\n                if(nums[mid]>nums[mid-1])\\n                    return mid;\\n            }\\n            else if(nums[mid]>nums[mid-1]&&nums[mid]>nums[mid+1])\\n                    return mid;\\n            if(nums[mid+1]>nums[mid])\\n                low = mid+1;\\n            else \\n                high = mid-1;\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920848,
                "title": "kotlin-o-logn-time-and-o-1-space",
                "content": "\\n    fun findPeakElement(nums: IntArray): Int {\\n        var l = 0; var r = nums.size - 1\\n\\n        while (l < r) {\\n            val m = l + (r - l) / 2\\n            if (nums[m] > nums[m + 1])\\n                r = m\\n            else\\n                l = m + 1\\n        }\\n\\n        return l\\n    }\\n",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "\\n    fun findPeakElement(nums: IntArray): Int {\\n        var l = 0; var r = nums.size - 1\\n\\n        while (l < r) {\\n            val m = l + (r - l) / 2\\n            if (nums[m] > nums[m + 1])\\n                r = m\\n            else\\n                l = m + 1\\n        }\\n\\n        return l\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 773571,
                "title": "swift-2-solutions-with-mit-ideas",
                "content": "Solutions that get the ideas from MIT class lecture\\n# 1. LINEAR SEARCH\\nO(n)\\n```\\nfunc findPeakElement(_ nums: [Int]) -> Int {\\n\\tfor i in 0..<nums.count-1 {\\n\\t\\tif nums[i] > nums[i + 1] { return i }\\n\\t}\\n\\n\\treturn nums.count - 1\\n}\\n```\\n\\t\\n# 2. BINARY SEARCH\\nO(logn)\\n```\\nfunc findPeakElement(_ nums: [Int]) -> Int {\\n\\tvar left = 0\\n\\tvar right = nums.count - 1\\n\\n\\twhile left < right {\\n\\t\\tlet mid = left + (right - left) / 2\\n\\t\\tif nums[mid] < nums[mid + 1] { left = mid + 1 }\\n\\t\\telse { right = mid }\\n\\t}\\n\\n\\treturn left\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc findPeakElement(_ nums: [Int]) -> Int {\\n\\tfor i in 0..<nums.count-1 {\\n\\t\\tif nums[i] > nums[i + 1] { return i }\\n\\t}\\n\\n\\treturn nums.count - 1\\n}\\n```\n```\\nfunc findPeakElement(_ nums: [Int]) -> Int {\\n\\tvar left = 0\\n\\tvar right = nums.count - 1\\n\\n\\twhile left < right {\\n\\t\\tlet mid = left + (right - left) / 2\\n\\t\\tif nums[mid] < nums[mid + 1] { left = mid + 1 }\\n\\t\\telse { right = mid }\\n\\t}\\n\\n\\treturn left\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 691973,
                "title": "python-detailed-explanation-logn-binary-search-solution",
                "content": "```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : BINARY SEARCH ##\\n        ## question says : The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. ##\\n        ## [1,2,3,1,2,1] => peak elements are 3(i=2) and 2(i=4), so  we can return 3 or 2\\n        \\n        ## LOGIC ##\\n        # plot nums as a graph\\n        # if both left and right side  are less than curr, return as it is peak\\n        #  if left is less and right is greater than, it is increasing sequence, so the graph will come down somewhere right to it, so we move right\\n        # if left is greater and right is lesser than curr, then it is decreasing sequence, so peak will be somewhere left to it, so we move left\\n        # if both elements are less than curr, we can go any one side\\n        \\n\\t\\t## TIME COMPLEXITY : O(lognN) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n\\n        n = len(nums)\\n        nums = [float(\\'-inf\\')] + nums + [float(\\'-inf\\')]\\n        if( n == 1 ): return 0\\n        l = 1\\n        r = n                                   \\n        while(l <= r):                          \\n            mid = l + (r - l)//2              \\n            curr = nums[ mid ]\\n            left = nums[ mid - 1 ]\\n            right = nums[ mid + 1 ]\\n            if( curr > left and curr > right ):\\n                return mid -1                   \\n            elif( curr > left and curr < right ):\\n                l = mid + 1\\n            elif( curr < left and curr > right ):\\n                r = mid - 1\\n            else:                               # both are less, we can go either way\\n                l = mid + 1\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : BINARY SEARCH ##\\n        ## question says : The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. ##\\n        ## [1,2,3,1,2,1] => peak elements are 3(i=2) and 2(i=4), so  we can return 3 or 2\\n        \\n        ## LOGIC ##\\n        # plot nums as a graph\\n        # if both left and right side  are less than curr, return as it is peak\\n        #  if left is less and right is greater than, it is increasing sequence, so the graph will come down somewhere right to it, so we move right\\n        # if left is greater and right is lesser than curr, then it is decreasing sequence, so peak will be somewhere left to it, so we move left\\n        # if both elements are less than curr, we can go any one side\\n        \\n\\t\\t## TIME COMPLEXITY : O(lognN) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n\\n        n = len(nums)\\n        nums = [float(\\'-inf\\')] + nums + [float(\\'-inf\\')]\\n        if( n == 1 ): return 0\\n        l = 1\\n        r = n                                   \\n        while(l <= r):                          \\n            mid = l + (r - l)//2              \\n            curr = nums[ mid ]\\n            left = nums[ mid - 1 ]\\n            right = nums[ mid + 1 ]\\n            if( curr > left and curr > right ):\\n                return mid -1                   \\n            elif( curr > left and curr < right ):\\n                l = mid + 1\\n            elif( curr < left and curr > right ):\\n                r = mid - 1\\n            else:                               # both are less, we can go either way\\n                l = mid + 1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519188,
                "title": "why-binary-search-can-be-use-in-this-question-c-concise-implementation",
                "content": "think about Leetcode 162,we face a problem, why binary search can be used?\\n\\nfirst, let\\'s think about Leetcode 35 Search Insert Position,this is a classical binary search problem.we should learn some standard implementation.\\n\\nLeetcode 35 we can implement in C++ STL\\n\\n```C++\\nLeetcode 35\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int idx = std::lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n        return idx;\\n    }\\n};\\n```\\n\\nor we implement std::lower_bound by myself(**this is equivalent to std::lower_bound** , but compare to [libc++](https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L4175) real implementation, which is complicated,so [lower_bound-cppreference.com](https://en.cppreference.com/w/cpp/algorithm/lower_bound) shows possible implementation, **possible implementation can be implement by myself equivalently** by use \\'left and right \\'variable in below)\\n\\n```C++\\nLeetcode 35\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int nums_size = nums.size();\\n        int left = 0, right = nums_size;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```\\n\\nand std::upper_bound just need modify nums[mid]<target to nums[mid]<=target\\n\\nuse std::lower_bound **preconditions**:\\n\\n>range[left,right) must be partitioned with respect to the expression element < target\\n\\nreturn **first element** in the range `[left, right)` that is *not less* than (i.e. greater or equal to) `value`\\n\\nthe keypoint is partitioned with respect to the expression element < target\\n\\n>generally speaking,which can be achieve use sort algorithm.\\n>\\n>but [1,4,3,5,78]this array also can use std::lower_bound(nums.begin(), nums.end(), 5)\\n>\\n>because 1<target, 4<target,3<target.and return **first element** >=5.\\n\\nuse same pattern, we use nums[mid] < nums[mid + 1] as **partition condition**\\n\\nand because of Leetcode 162 **specificity**\\n\\n>1.The array may contain multiple peaks, in that case return the index to **any one of** the peaks is fine.\\n>\\n>2.Given an input array `nums`, where `nums[i] \\u2260 nums[i+1]`\\n\\nloop invariants are:\\n\\n>1.**nums[left - 1] < nums[left] && nums[right] > nums[right + 1]**(refer to [Java solution and explanation using invariants](https://leetcode.com/problems/find-peak-element/discuss/50239/Java-solution-and-explanation-using-invariants))\\n>\\n>2.range [left,right] **at least** a peak.(the number of peak >= 1)\\n>\\n>3.nums[-1] = nums[n] = -\\u221E\\n\\nso binary search can be used.\\n\\nimplementation below:\\n\\n```C++\\n    class Solution {\\n    public:\\n        int findPeakElement(vector<int>& nums) {\\n            int nums_size = nums.size();\\n            int left = 0, right = nums_size - 1;\\n            while (left < right) {\\n                int mid = left + (right - left) / 2;\\n                if (nums[mid] < nums[mid + 1]) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid;\\n                }\\n            }\\n            return left;\\n        }\\n    };\\n```\\n\\nInitialization: (loop invariants 1,2,3ok)\\n\\nMaintenance loop invariants(and narrow range):\\n\\n>   1.nums[mid] < nums[mid + 1].so **at least a peak** in the right direction of mid(of course in the left direction of mid maybe have peak, or there isn\\'t peak),so left = mid + 1.(loop invariants 1,2,3ok).\\n>\\n>   2.nums[mid]>nums[mid+1].(loop invariants 1,2,3ok).\\n\\nTermination: \\n\\n>   1.left == right\\n>\\n>   2.(loop invariants 1,2,3ok).\\n\\nnotice: we only need a peak!\\n\\nwhy not use nums[mid-1] < nums[mid]?\\n\\n>consider only two elements in nums. in this situation mid == left.and mid + 1 == right.so not exceed range!\\n\\nReference:\\n\\n1.[Java solution and explanation using invariants](https://leetcode.com/problems/find-peak-element/discuss/50239/Java-solution-and-explanation-using-invariants)\\n\\n2.[lower_bound-cppreference.com](https://en.cppreference.com/w/cpp/algorithm/lower_bound)",
                "solutionTags": [],
                "code": "```C++\\nLeetcode 35\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int idx = std::lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n        return idx;\\n    }\\n};\\n```\n```C++\\nLeetcode 35\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int nums_size = nums.size();\\n        int left = 0, right = nums_size;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```\n```C++\\n    class Solution {\\n    public:\\n        int findPeakElement(vector<int>& nums) {\\n            int nums_size = nums.size();\\n            int left = 0, right = nums_size - 1;\\n            while (left < right) {\\n                int mid = left + (right - left) / 2;\\n                if (nums[mid] < nums[mid + 1]) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid;\\n                }\\n            }\\n            return left;\\n        }\\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 402489,
                "title": "easy-to-understand-c-solution-4ms-beats-96",
                "content": "Runtime: 4 ms, faster than 96.88% of C++ online submissions for Find Peak Element.\\nMemory Usage: 8.6 MB, less than 81.82% of C++ online submissions for Find Peak Element.\\n\\n```\\nint findPeakElement(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int low = 0;\\n        int high = n - 1;\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n            \\n            if((mid == 0 || nums[mid] > nums[mid-1]) && (mid == n-1 || nums[mid] > nums[mid+1]))\\n                return mid;\\n            else if(mid < n && nums[mid] < nums[mid+1])\\n                low = mid+1;\\n            else\\n                high = mid - 1;\\n        }\\n        return -1;\\n    }",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "Runtime: 4 ms, faster than 96.88% of C++ online submissions for Find Peak Element.\\nMemory Usage: 8.6 MB, less than 81.82% of C++ online submissions for Find Peak Element.\\n\\n```\\nint findPeakElement(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int low = 0;\\n        int high = n - 1;\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n            \\n            if((mid == 0 || nums[mid] > nums[mid-1]) && (mid == n-1 || nums[mid] > nums[mid+1]))\\n                return mid;\\n            else if(mid < n && nums[mid] < nums[mid+1])\\n                low = mid+1;\\n            else\\n                high = mid - 1;\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 133199,
                "title": "javascript-linear-scan-binary-search-recursive-iterative-solutions",
                "content": "**1) Linear scan**\\nTime complexity O(n)\\nSpace complexity O(1)\\n\\n```js\\nfunction findPeakElement(nums) {\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] > nums[i + 1]) return i;\\n  }\\n\\n  return nums.length - 1;\\n}\\n```\\n\\n**2) Binary search (recursive)**\\nTime complexity O(log2(n))\\nSpace complexity O(log2(n))\\n```js\\nfunction findPeakElement(nums) {\\n  return search(nums, 0, nums.length - 1);\\n}\\n\\nfunction search(nums, l, r) {\\n  if (l === r) return l;\\n\\n  const mid = Math.floor((l + r) / 2);\\n  if (nums[mid] > nums[mid + 1]) return search(nums, l, mid);\\n\\n  return search(nums, mid + 1, r);\\n}\\n```\\n\\n**3) Binary search (iterative)**\\nTime complexity O(log2(n))\\nSpace complexity O(1)\\n```js\\nfunction findPeakElement(nums) {\\n  let l = 0;\\n  let r = nums.length - 1;\\n\\n  while (l < r) {\\n    const mid = Math.floor((l + r) / 2);\\n\\n    if (nums[mid] > nums[mid + 1]) {\\n      r = mid;\\n    } else {\\n      l = mid + 1;\\n    }\\n  }\\n  return l;\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction findPeakElement(nums) {\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] > nums[i + 1]) return i;\\n  }\\n\\n  return nums.length - 1;\\n}\\n```\n```js\\nfunction findPeakElement(nums) {\\n  return search(nums, 0, nums.length - 1);\\n}\\n\\nfunction search(nums, l, r) {\\n  if (l === r) return l;\\n\\n  const mid = Math.floor((l + r) / 2);\\n  if (nums[mid] > nums[mid + 1]) return search(nums, l, mid);\\n\\n  return search(nums, mid + 1, r);\\n}\\n```\n```js\\nfunction findPeakElement(nums) {\\n  let l = 0;\\n  let r = nums.length - 1;\\n\\n  while (l < r) {\\n    const mid = Math.floor((l + r) / 2);\\n\\n    if (nums[mid] > nums[mid + 1]) {\\n      r = mid;\\n    } else {\\n      l = mid + 1;\\n    }\\n  }\\n  return l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 50303,
                "title": "share-my-java-solution-with-detailed-explanation-binary-search",
                "content": "We use binary search for this question. \\nThere are 4 scenarios to consider: \\n1. mid is at the lowest\\n2. mid is at peak\\n3. mid is at the increasing slope\\n4. mid is at the decreasing slope. \\n\\nUse the following algorithm we can achieve O(logn) time complexity and O(1) space complexity. \\n\\n    public class Solution {\\n        public int findPeakElement(int[] nums) {\\n            //corner case\\n            if (nums.length==0 || nums==null){\\n                return 0;\\n            }\\n            int start=0;\\n            int end= nums.length-1;\\n            \\n            while(start+1<end){\\n                int mid = start+ (end-start)/2;\\n                 //peak\\n                if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]){\\n                    return mid;\\n                }\\n                //decreasing\\n                else if(nums[mid]<nums[mid-1]){\\n                    end=mid;\\n                }\\n                //increaseing : A[mid] > A[mid - 1]  \\n                //lowest : A[mid] < A[mid - 1] && A[mid] < A[mid + 1]\\n                else{\\n                    start=mid;\\n                }\\n                \\n            }\\n            if(nums[start]>nums[end]){\\n                return start;\\n            }\\n            else{\\n                return end;\\n            }\\n            \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int findPeakElement(int[] nums) {\\n            //corner case\\n            if (nums.length==0 || nums==null){\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 50356,
                "title": "c-less-10-line-solution-binary-search",
                "content": "     int findPeakElement(vector<int>& nums) {\\n        const int size_num = nums.size();\\n        int i = 0, j = size_num - 1;\\n        while (i < j) {\\n            int mid = i + (j - i) / 2;\\n            if (nums[mid] < nums[mid+1]) i = mid + 1;\\n            else j = mid;\\n        }\\n        return i;\\n    }",
                "solutionTags": [],
                "code": "     int findPeakElement(vector<int>& nums) {\\n        const int size_num = nums.size();\\n        int i = 0, j = size_num - 1;\\n        while (i < j) {\\n            int mid = i + (j - i) / 2;\\n            if (nums[mid] < nums[mid+1]) i = mid + 1;\\n            else j = mid;\\n        }\\n        return i;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4067503,
                "title": "best-python-solution-ever-binary-search-9-lines-only",
                "content": "\\n# Complexity\\n- Time complexity: O(LogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n\\n        s= 0\\n        e = len(nums)-1\\n\\n        while s<e:\\n            m = (s+e)//2\\n            if nums[m]>nums[m+1]:\\n                e = m\\n            else:\\n                s = m+1\\n        return e\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n\\n        s= 0\\n        e = len(nums)-1\\n\\n        while s<e:\\n            m = (s+e)//2\\n            if nums[m]>nums[m+1]:\\n                e = m\\n            else:\\n                s = m+1\\n        return e\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967955,
                "title": "very-easy-approach-in-c",
                "content": "# Intuition\\nIt is given that we have to find in logn time so binary search is the best one.\\n\\n# Approach\\nUsing binary search we find the peak element.\\n\\n# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        auto p=[&](int i){\\n           return (i==0||nums[i-1]<nums[i]);\\n             \\n        };\\n        int l=-1,r=nums.size();\\n        while(r-l>1){\\n           int mid=l+(r-l)/2;\\n           p(mid)?(l=mid):(r=mid);\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        auto p=[&](int i){\\n           return (i==0||nums[i-1]<nums[i]);\\n             \\n        };\\n        int l=-1,r=nums.size();\\n        while(r-l>1){\\n           int mid=l+(r-l)/2;\\n           p(mid)?(l=mid):(r=mid);\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889814,
                "title": "python-easy-solution-100-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        left=0\\n        right=len(nums)-1\\n        if len(nums)==1:\\n            return 0\\n        while left<=right:\\n            mid=(left+right)>>1\\n            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==len(nums)-1 or nums[mid]>=nums[mid+1]) :\\n                return mid\\n            elif nums[mid]<=nums[mid+1]:\\n                left=mid+1\\n            else:\\n                right=mid-1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        left=0\\n        right=len(nums)-1\\n        if len(nums)==1:\\n            return 0\\n        while left<=right:\\n            mid=(left+right)>>1\\n            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==len(nums)-1 or nums[mid]>=nums[mid+1]) :\\n                return mid\\n            elif nums[mid]<=nums[mid+1]:\\n                left=mid+1\\n            else:\\n                right=mid-1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870115,
                "title": "1-r",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:12ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0mb\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        l = 0\\n        h = len(nums)-1\\n        while l<h:\\n            mid = (l+h)//2\\n            if nums[mid]>nums[mid+1]:\\n                h = mid\\n            else:\\n                l = mid+1\\n        return l\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        l = 0\\n        h = len(nums)-1\\n        while l<h:\\n            mid = (l+h)//2\\n            if nums[mid]>nums[mid+1]:\\n                h = mid\\n            else:\\n                l = mid+1\\n        return l\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867451,
                "title": "best-solution-easy-understandable-100-video-explanation-beats-100-users",
                "content": "[https://www.youtube.com/watch?v=exKHRRaF4Mk&t=1s]()\\n\\n# Code\\n```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        int max=nums[0];\\n      for(int i=0;i<nums.length;i++){\\n          if(nums[i]>max){\\n              max=nums[i];\\n          }\\n      }\\n\\n      for(int i=0;i<nums.length;i++){\\n          if(nums[i]==max) return i;\\n      }\\n      return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        int max=nums[0];\\n      for(int i=0;i<nums.length;i++){\\n          if(nums[i]>max){\\n              max=nums[i];\\n          }\\n      }\\n\\n      for(int i=0;i<nums.length;i++){\\n          if(nums[i]==max) return i;\\n      }\\n      return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861740,
                "title": "c-binary-search-approach-best-detailed-explanation-beats-100-runtime-t-c-o-log-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        // T.C = O(log N);\\n\\n        int n = nums.size();\\n\\n        if(n == 1)\\n        {\\n            return 0;\\n        }\\n\\n        if(nums[0] > nums[1])\\n        {\\n            return 0;\\n        }\\n\\n        if(nums[n-1] > nums[n-2])\\n        {\\n            return n-1;\\n        }\\n\\n        int low = 1;\\n        int high = n-2;\\n\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n\\n            if(nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1])\\n            {\\n                return mid;\\n            }\\n\\n            else if(nums[mid] > nums[mid - 1])\\n            {\\n                low = mid + 1;\\n            }\\n\\n            else\\n            {\\n                high = mid -1;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        // T.C = O(log N);\\n\\n        int n = nums.size();\\n\\n        if(n == 1)\\n        {\\n            return 0;\\n        }\\n\\n        if(nums[0] > nums[1])\\n        {\\n            return 0;\\n        }\\n\\n        if(nums[n-1] > nums[n-2])\\n        {\\n            return n-1;\\n        }\\n\\n        int low = 1;\\n        int high = n-2;\\n\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n\\n            if(nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1])\\n            {\\n                return mid;\\n            }\\n\\n            else if(nums[mid] > nums[mid - 1])\\n            {\\n                low = mid + 1;\\n            }\\n\\n            else\\n            {\\n                high = mid -1;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856393,
                "title": "easy-c-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int l = 0 , r = nums.size() - 1;\\n        while(l < r) {\\n            int mid = l + (r - l) / 2;\\n            if(nums[mid] < nums[mid + 1])\\n            l = mid + 1;\\n            else\\n            r = mid;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int l = 0 , r = nums.size() - 1;\\n        while(l < r) {\\n            int mid = l + (r - l) / 2;\\n            if(nums[mid] < nums[mid + 1])\\n            l = mid + 1;\\n            else\\n            r = mid;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841291,
                "title": "binary-search-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince our runtime requirement is O(log n), we need to use binary search. However, this binary search is different from the traditional one. For example, if nums is: 0, 1, 2, 3, 1. Our mid pointer points to 2, and which direction should we go? It seems that either right or left could contain a peak element?\\n\\nActually, there is one direction that is ***guaranteed*** to contain a peak element. All we need to do is to compare the two neighbor elements of mid to mid itself. If right is greater than mid, then we go right. If left is greater than mid, we fo left. The reason is that: if right neighbor is greater than mid, the right portion is either strictly increasing or has a peak point. If it is strictly increasing, the peak point is simply the last element of nums (please read the problem description carefully, the two ends of nums is always greater than any element outside nums). Similary, if left neighbor is greater than mid, that means the left portion of nums is either strictly decreasing or contains a peak element. If it\\'s strictly decreasing, the first element of nums will be our peak element.    \\n\\nFor more details, please feel free to watch Neetcode\\'s Youtube video. It gave me a lot of help to understand this problem. Happy coding!\\n\\nhttps://www.youtube.com/watch?v=kMzJy9es7Hc\\n \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size() - 1;\\n        while (start <= end){\\n            int mid = start + (end - start) / 2;\\n            if(mid + 1 < nums.size() && nums[mid] < nums[mid + 1]){\\n                start = mid + 1;\\n            } else if (mid - 1 >= 0 && nums[mid - 1] > nums[mid]){\\n                end = mid - 1;\\n            } else {\\n                return mid;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size() - 1;\\n        while (start <= end){\\n            int mid = start + (end - start) / 2;\\n            if(mid + 1 < nums.size() && nums[mid] < nums[mid + 1]){\\n                start = mid + 1;\\n            } else if (mid - 1 >= 0 && nums[mid - 1] > nums[mid]){\\n                end = mid - 1;\\n            } else {\\n                return mid;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797118,
                "title": "simple-using-arrays",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        for(int  i=0;i<nums.length-1;i++){\\n            if(nums[i]>nums[i+1]){\\n                return i;\\n            }\\n        }\\n        return nums.length-1;\\n    }\\n}\\n```\\n![1qivbn.jpg](https://assets.leetcode.com/users/images/a169dbd7-b34d-4a99-8359-a8a813239d9a_1689869293.2703924.jpeg)",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        for(int  i=0;i<nums.length-1;i++){\\n            if(nums[i]>nums[i+1]){\\n                return i;\\n            }\\n        }\\n        return nums.length-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796707,
                "title": "find-the-peak-element",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/505c2b70-2b55-4398-bf2d-50123576dc6c_1689939982.9395442.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        low=0\\n        high=n-1\\n        if n==1:\\n            return 0\\n        \\n        while low<=high:\\n            mid=(low+high)//2\\n            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n-1 or nums[mid]>=nums[mid+1]) :\\n                return mid\\n            elif nums[mid]<=nums[mid+1]:\\n                low=mid+1\\n            else:\\n                high=mid-1\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        low=0\\n        high=n-1\\n        if n==1:\\n            return 0\\n        \\n        while low<=high:\\n            mid=(low+high)//2\\n            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n-1 or nums[mid]>=nums[mid+1]) :\\n                return mid\\n            elif nums[mid]<=nums[mid+1]:\\n                low=mid+1\\n            else:\\n                high=mid-1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738074,
                "title": "c-binary-search-approach-best-detailed-explanation-beats-100-runtime-beats-96-memory-usage",
                "content": "# Intuition\\nPeak element must be strictly greater than neighbouring elements\\n\\n# Approach\\n- Initialize with the binary search code snippet.\\n### Edge cases:\\n    - Only 1 element in the array: return 0\\n    - 2 elements in the array: return the bigger element\\'s index\\n### Middle element bigger than previous neighbour: \\n- Check if the middle element is greater than neighbouring previous element (index of previous element can\\'t be less than 0)\\n    - Check again if the next neighbouring element is smaller than the current middle element\\n        - return the middle index\\n    - If next neighbour is bigger, It could be an answer, hence, shift the search space to the right.\\n\\n### Middle element not bigger than previous neighbour:\\n- Since previous element is bigger, it could be the answer, hence, shift the search space to the left.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n $$O(log n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int s=0;\\n        int e=nums.size()-1;\\n        while(s<=e){\\n            int mid= s + (e-s)/2;\\n            if(s==e){\\n                return s;\\n            }\\n            if(e-s==1){\\n                if(nums[s]>nums[e]){\\n                    return s;\\n                }\\n                else{\\n                    return e;\\n                }\\n            }\\n            if(mid-1>=0 && nums[mid-1]<nums[mid]){\\n                if(mid+1<nums.size() && nums[mid]>nums[mid+1]){\\n                    return mid;\\n                }\\n                else{\\n                    s=mid+1;\\n                }\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int s=0;\\n        int e=nums.size()-1;\\n        while(s<=e){\\n            int mid= s + (e-s)/2;\\n            if(s==e){\\n                return s;\\n            }\\n            if(e-s==1){\\n                if(nums[s]>nums[e]){\\n                    return s;\\n                }\\n                else{\\n                    return e;\\n                }\\n            }\\n            if(mid-1>=0 && nums[mid-1]<nums[mid]){\\n                if(mid+1<nums.size() && nums[mid]>nums[mid+1]){\\n                    return mid;\\n                }\\n                else{\\n                    s=mid+1;\\n                }\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722675,
                "title": "find-peak-element-java-solution-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findPeakElement(int[] arr) {\\n        int x = 0;\\n        int y = arr.length -1;\\n\\n        while(x < y){\\n            int mid = x + (y - x) / 2;\\n\\n            if(arr[mid] > arr[mid + 1]){\\n                y = mid;\\n            }\\n            else{\\n                x = mid + 1;\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPeakElement(int[] arr) {\\n        int x = 0;\\n        int y = arr.length -1;\\n\\n        while(x < y){\\n            int mid = x + (y - x) / 2;\\n\\n            if(arr[mid] > arr[mid + 1]){\\n                y = mid;\\n            }\\n            else{\\n                x = mid + 1;\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713329,
                "title": "beats-100-easy-java-code-using-2-approaches",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary search\\n\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        //linear search\\n        //tc=O(n), sc=o(1)\\n        // int n=nums.length;\\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     if((i==0 || nums[i-1]<nums[i]) && (i==n-1 || nums[i]>nums[i+1]))\\n        //     return i;\\n        // }\\n        // return 0;\\n\\n        //Binary Search\\n        //tc=O(log n)\\n        int n=nums.length;\\n        if(n==1) return 0;\\n        if(nums[0]>nums[1]) return 0;\\n        if(nums[n-1]>nums[n-2]) return n-1;\\n        int l=1, r=n-2;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2;\\n            if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]) return mid;\\n            else if(nums[mid]>nums[mid-1]) l=mid+1;\\n            else  r=mid-1;                //if(nums[mid]>nums[mid+1])\\n        }\\n        return -1;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        //linear search\\n        //tc=O(n), sc=o(1)\\n        // int n=nums.length;\\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     if((i==0 || nums[i-1]<nums[i]) && (i==n-1 || nums[i]>nums[i+1]))\\n        //     return i;\\n        // }\\n        // return 0;\\n\\n        //Binary Search\\n        //tc=O(log n)\\n        int n=nums.length;\\n        if(n==1) return 0;\\n        if(nums[0]>nums[1]) return 0;\\n        if(nums[n-1]>nums[n-2]) return n-1;\\n        int l=1, r=n-2;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2;\\n            if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]) return mid;\\n            else if(nums[mid]>nums[mid-1]) l=mid+1;\\n            else  r=mid-1;                //if(nums[mid]>nums[mid+1])\\n        }\\n        return -1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617766,
                "title": "java-simple-solution-using-binary-search-tc-o-log-n-sc-o-1",
                "content": "# Intuition\\n\\nsearch in the array using binary search, if the mid element is grater then the (mid+1)  them we are  in the right side of the peek element and if mid element is less  then the (mid + 1)  element then we are in the left side of th peak element.\\n\\n\\nWhen we are in the left side of the peek element as we are calculating the left sided mid element, we have to take the      start = mid+1 otherwise it could stuck in an infinite look, for example consider there is only two element and check. \\n\\nOn the other hand when we are in the right side of the peek element the mid element could be the peek as well so we use end = mid.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(Log n)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findPeakElement(int[] arr) {\\n        int start=0,end = arr.length-1;\\n        int mid = (start+end)/2;\\n\\n        while(start<end){\\n             mid = (start+end)/2;\\n\\n            if(mid<arr.length-1 && arr[mid] > arr[mid+1]){\\n                end = mid;\\n            }\\n            else{\\n                start = mid+1;\\n            }\\n        }\\n        return end;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findPeakElement(int[] arr) {\\n        int start=0,end = arr.length-1;\\n        int mid = (start+end)/2;\\n\\n        while(start<end){\\n             mid = (start+end)/2;\\n\\n            if(mid<arr.length-1 && arr[mid] > arr[mid+1]){\\n                end = mid;\\n            }\\n            else{\\n                start = mid+1;\\n            }\\n        }\\n        return end;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593036,
                "title": "aditya-verma-approach",
                "content": "# Code\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    int findPeakElement(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        int start = 0, end = n - 1;\\n        while (start < end)\\n        {\\n            int mid = start + (end - start) / 2;\\n            if (mid > 0 && mid < n - 1)\\n            {\\n                if (nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1])\\n                    return mid;\\n                else if (nums[mid - 1] > nums[mid])\\n                    end = mid - 1;\\n                else\\n                    start = mid + 1;\\n            }\\n            else if (mid == 0)\\n            {\\n                if (nums[0] > nums[1])\\n                    return 0;\\n                else\\n                    return 1;\\n            }\\n            else if (mid == n - 1)\\n            {\\n                if (nums[n - 1] > nums[n - 2])\\n                    return n - 1;\\n                else\\n                    return n - 2;\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    int findPeakElement(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        int start = 0, end = n - 1;\\n        while (start < end)\\n        {\\n            int mid = start + (end - start) / 2;\\n            if (mid > 0 && mid < n - 1)\\n            {\\n                if (nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1])\\n                    return mid;\\n                else if (nums[mid - 1] > nums[mid])\\n                    end = mid - 1;\\n                else\\n                    start = mid + 1;\\n            }\\n            else if (mid == 0)\\n            {\\n                if (nums[0] > nums[1])\\n                    return 0;\\n                else\\n                    return 1;\\n            }\\n            else if (mid == n - 1)\\n            {\\n                if (nums[n - 1] > nums[n - 2])\\n                    return n - 1;\\n                else\\n                    return n - 2;\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3482419,
                "title": "java-beats-100-with-plusultra-p",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        int n = nums.length;\\n        \\n        if(n == 1 || nums[0] > nums[1]) return 0;\\n\\n        if(nums[n - 1] > nums[n - 2]) return n - 1;\\n\\n        int l = 0;\\n        int r = n - 1;\\n\\n        while(l <= r)\\n        {\\n            int m = (l + r)/2;\\n            \\n            int minus = m == 0 ? Integer.MIN_VALUE : nums[m-1];\\n            int plusUltra = m == n - 1 ? Integer.MIN_VALUE : nums[m+1];\\n            if(minus < nums[m] && plusUltra < nums[m]) return m;\\n\\n            if(minus < nums[m]) l = m + 1;\\n            else r = m - 1;\\n        }\\n\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        int n = nums.length;\\n        \\n        if(n == 1 || nums[0] > nums[1]) return 0;\\n\\n        if(nums[n - 1] > nums[n - 2]) return n - 1;\\n\\n        int l = 0;\\n        int r = n - 1;\\n\\n        while(l <= r)\\n        {\\n            int m = (l + r)/2;\\n            \\n            int minus = m == 0 ? Integer.MIN_VALUE : nums[m-1];\\n            int plusUltra = m == n - 1 ? Integer.MIN_VALUE : nums[m+1];\\n            if(minus < nums[m] && plusUltra < nums[m]) return m;\\n\\n            if(minus < nums[m]) l = m + 1;\\n            else r = m - 1;\\n        }\\n\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472298,
                "title": "o-n-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& v) {\\n        int n=v.size();\\n        if(n==1||n==0) return 0;\\n        if(v[0]>v[1]) return 0;\\n        if(v[n-1]>v[n-2]) return n-1;\\n        for(int i=1;i<v.size()-1;i++){\\n            if(v[i]>v[i-1]&&v[i]>v[i+1]) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& v) {\\n        int n=v.size();\\n        if(n==1||n==0) return 0;\\n        if(v[0]>v[1]) return 0;\\n        if(v[n-1]>v[n-2]) return n-1;\\n        for(int i=1;i<v.size()-1;i++){\\n            if(v[i]>v[i-1]&&v[i]>v[i+1]) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463847,
                "title": "java-solution-for-find-the-peak-element-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA peak element is an element that is greater than its neighbors.\\nThe algorithm uses a linear scan of the input array and compares each element with its neighboring elements to check if it is a peak. If an element is found to be a peak, it is recorded along with its index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach of the given solution is to find a peak element in the input array. A peak element is defined as an element that is greater than its neighbors. The solution iterates over each element in the array from the second to second last element, and for each element checks if it is greater than its previous and next element. If it is greater than its neighbors, it checks if it is greater than the current maximum peak element. If it is, then it updates the maximum peak element and its index. Finally, it checks if the last element in the array is greater than the current maximum peak element and returns the index of the maximum peak element.\\n\\nThe solution iterates over each element of the input array once and performs constant time operations on each element, so the time complexity of the algorithm is O(n), where n is the length of the input array. The algorithm uses a constant amount of additional space to store the current maximum peak element and its index, so the space complexity of the algorithm is O(1).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) where n is the length of the input array, since it performs a linear scan of the array.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), as it only uses a constant amount of additional space to store the variables used in the algorithm. Therefore, the space complexity of the algorithm is constant, i.e., O(1).\\n\\n# Code\\n```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        int max = nums[0];\\n        int index = 0;\\n        for(int i=1; i<=nums.length-2; i++)\\n        {\\n            int prev = nums[i-1];\\n            int curr = nums[i];\\n            int next = nums[i+1];\\n            if(curr > prev && curr > next && curr > max)\\n            {\\n                index = i;\\n                max = curr;\\n            }\\n        }\\n        if(nums[nums.length-1] > max)\\n        {\\n            return nums.length-1;\\n        }\\n        return index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        int max = nums[0];\\n        int index = 0;\\n        for(int i=1; i<=nums.length-2; i++)\\n        {\\n            int prev = nums[i-1];\\n            int curr = nums[i];\\n            int next = nums[i+1];\\n            if(curr > prev && curr > next && curr > max)\\n            {\\n                index = i;\\n                max = curr;\\n            }\\n        }\\n        if(nums[nums.length-1] > max)\\n        {\\n            return nums.length-1;\\n        }\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356466,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Binary Search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(log N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int l = 0, r = nums.size()-1;\\n        while(l < r) {\\n            int mid = (l + r) / 2;\\n            if(nums[mid] < nums[mid+1]) l = mid + 1;\\n            else r = mid;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int l = 0, r = nums.size()-1;\\n        while(l < r) {\\n            int mid = (l + r) / 2;\\n            if(nums[mid] < nums[mid+1]) l = mid + 1;\\n            else r = mid;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335387,
                "title": "easy-binary-search-problem-o-logn-love-babbar-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        while(start<end){\\n            int mid = start + (end - start)/2;\\n            if(nums[mid]<nums[mid+1]){\\n                start = mid + 1;\\n            }\\n            else{\\n                end = mid;\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        while(start<end){\\n            int mid = start + (end - start)/2;\\n            if(nums[mid]<nums[mid+1]){\\n                start = mid + 1;\\n            }\\n            else{\\n                end = mid;\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318271,
                "title": "2ms-simple-binary-search-algorithm",
                "content": "Simple binary search algorithm , just focus on one constraint i.e\\r\\n**nums[i] != nums[i + 1] for all valid i.** this is important thing to decide which side we should go.\\r\\n```\\r\\nclass Solution\\r\\n{\\r\\npublic:\\r\\n    int findPeakElement(vector<int> &nums)\\r\\n    {\\r\\n\\r\\n        int low = 0, high = nums.size() - 1;\\r\\n       \\r\\n\\r\\n        while (low < high)\\r\\n        {\\r\\n            int mid = low + (high - low) / 2;\\r\\n\\r\\n            if (nums[mid + 1] < nums[mid])\\r\\n            {\\r\\n                high = mid;\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n\\r\\n                low = mid + 1;\\r\\n            }\\r\\n        }\\r\\n        return low;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\r\\nclass Solution\\r\\n{\\r\\npublic:\\r\\n    int findPeakElement(vector<int> &nums)\\r\\n    {\\r\\n\\r\\n        int low = 0, high = nums.size() - 1;\\r\\n       \\r\\n\\r\\n        while (low < high)\\r\\n        {\\r\\n            int mid = low + (high - low) / 2;\\r\\n\\r\\n            if (nums[mid + 1] < nums[mid])\\r\\n            {\\r\\n                high = mid;\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n\\r\\n                low = mid + 1;\\r\\n            }\\r\\n        }\\r\\n        return low;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564746,
                "content": [
                    {
                        "username": "amoicity",
                        "content": "When people see ths question, I think most people will immediately come up with the linear search solution, which is to examine each num and compare it with its two neighbours. No braniner, right? Then people are thinking why this kind of question would  appear in the question pool and why it\\'s even rated as Medium. Then they might go to the Solution tab and see someone writing up a big article explaining a better solution and probably think, why bother? That\\'s an overkill. \\n\\nThese types of questions are so undervalued by people. And these are the questions we should pay more attention to. I\\'m sure in a real question, the interviewer will not be satisfied by the linear solution. Why? Because the straightforward linear scan solution isn\\'t using all of the clues given in the question. These clues, including\\n1. No adjacent two numbers are the same\\n2. the two end of the arrays are -\\u221E\\n3. You can return any peak.\\n\\nare all the clues that we can base upon to get to the final BS solution. When you are reading a question, pay great attention to these clues. If your solution does not involve all of the clue provided, you might not get the optimal solution. This is not any random question, it\\'s asked by Facebook, Google, etc., for multiple times. There is a reason why it exist and please don\\'t downvote it without even attempting to understand it."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@olsonpm](/olsonpm) I guess criticism of premature optimization originally intended to direct programmer\\'s effort into the best way of optimizing code. But now it\\'s most often used as an argument against any optimization."
                    },
                    {
                        "username": "olsonpm",
                        "content": "Questions like this that don\\'t enforce the optimal solution are a poor way to test devs.  In the real world, investing time into an unnecessary optimization is called premature optimization, and is a poor use of time as well as over-complicates the code."
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Mate, your tip is the best discussion section post template i always want to see :)"
                    },
                    {
                        "username": "sergei99",
                        "content": "Thanks mate. I had initially though that there was a mistake in the task description, but after your comment just sat down and wrote a few example lists of numbers. And then it took just a dozen lines of C++ code, including all the edge cases, to get 0ms execution time with 100% users beaten. :-)"
                    },
                    {
                        "username": "vaibhavbhatt59",
                        "content": "thanks bro i am going for see the solution  but bymistake i open discussion and see your comment on top . then i give another try to the question  and i did it . thanks bro\\n"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "i was getting frustrated and was going to look out for solutions but this comment pushed me and it clicked after few more minutes .... great question btw\\n"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "why u shudn\\'t skip questions with large no of downvotes without reading yourself"
                    },
                    {
                        "username": "madhavmaheshwarimm20",
                        "content": "[@armashhashmi](/armashhashmi) in constraints last point"
                    },
                    {
                        "username": "pyush98",
                        "content": "[@armashhashmi](/armashhashmi) \\n\\nnums[i] != nums[i + 1] for all valid i\\n\\nwrittein at bottom in smallest possible text XD"
                    },
                    {
                        "username": "armashhashmi",
                        "content": "where is it written in the question that \"No adjacent two numbers are same\" ?\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "after reading this (all before the 3 clues) I went and solved it in log(n) time, thanks for motivating me for doing so."
                    },
                    {
                        "username": "sohamdixit",
                        "content": "Agreed, but also for such questions where there is a trivial solution, I think the testcases need to be strong enough to not accept the trivial solution. In this case an O(n) solution should give a TLE, but it gets accepted, giving a misleading and false sense of having solved the problem in the best possible time to many people."
                    },
                    {
                        "username": "lavishmalik",
                        "content": "In both the questions you have to find peak elements but the catch is:\\n\\n-In leetcode 852 the array is increasingly and decreasingly sorted i.e its a bitonic array so you can apply modified binary search and find the global peak easily.\\n\\n-In this question(162), the given array is not sorted so they have given that there will be many peak elements and you can find any peak using binary search and return it .\\nBut you can\\'t find global peak in this question  just by applying binary search like previous question(852) because array is unsorted therefore after finding mid you can\\'t decide which side to go  for finding global peak.\\n\\n//Pls upvote if you like my solution\\n"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "the same code works for this also\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "So, How we do this."
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "The question doesn\\'t say the array is sorted, how do we know to use binary search ?"
                    },
                    {
                        "username": "cheekubhai",
                        "content": "The indexes form a sorted array"
                    },
                    {
                        "username": "premranjn",
                        "content": "there is a concept called binary search on answer, the sole idea of binary search in not only about finding a target in a sorted array, but to half the sample space after each decision.\\nSo here :\\nint findPeakElement(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if((mid == nums.size()-1)||nums[mid]>nums[mid+1] && ((mid == 0) || nums[mid]>nums[mid-1]))\\n                return mid;\\n            else if(mid==0)\\n                start = mid+1;\\n            else if(mid == nums.size()-1)\\n                end = mid-1;\\n            else if(nums[mid-1] < nums[mid])\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        return -1;\\n    }\\nif you would notice I am removing the half of the sample space each time i find the mid, using certain parameters.\\nHope It Helps ;)"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "[@ahmad-saeed](/ahmad-saeed) Sorting is an O(NLogN) process which is worse than doing a plain old linear search. Besides, you are supposed to return the index of the peak in its original position so you shouldn\\'t mutate the array in any way."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@pstrait](/pstrait) then i can just sort it in O(log n) then return the last in o(1) which satisfies the requirement without searching!"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "because  they said to do in 0(log n)  which is time complexty of binary search"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "Who said binary search can only applied on sorted arrays ?"
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "[@ssy55ssy](/ssy55ssy) can you please tell why that will work "
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "when the element is larger than it\\'s former element but it\\'s smaller than it\\'s later element,then the peak must appear behind it"
                    },
                    {
                        "username": "deadbycoffee",
                        "content": "I think it was just helpful that there could be multiple peaks. And because of that, you\\'re able to have a better chance of moving the left and right borders of the search based on what\\'s higher, mid, mid - 1, or mid + 1. Eventually either finding a peak or not finding one."
                    },
                    {
                        "username": "Altum_pax",
                        "content": "[@pstrait](/pstrait) Exactly that\\'s the catch!"
                    },
                    {
                        "username": "pstrait",
                        "content": "The array isn\\'t sorted; if it was sorted, the answer would just be the last element."
                    },
                    {
                        "username": "heejincs",
                        "content": "We can do simple binary search that check [mid] point and [mid+1] point and take half which has higher value, i.e. take left half if nums[mid]>nums[mid+1].\\nIt is not easy to show or proof why this works. \\nThe simple proof is that we take part of numbers that boundary condition holds true.\\nThat is, we only take search range (l, r) if nums[l-1]<nums[l] and num[r]>num[r+1]. Note that initial search range (l,r) where l=0 and r=len(nums)-1 holds true. Then, each step we reduce the search range half making sure the boundary condition holds true. Note that the other half the condition does not hold true.\\nTherefore, when it finally is reduced to a single number, it is the local maximum since the boundary condition for a single number is same as the condition for local maximum.\\n\\n"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I dont\\' understand the advantage of doing a linear search from 2 directions - \\n\\nlike what if your array is almost sorted with the peak occurring somewhere far away from mids\\n\\nlike 1,2,7,11,9,15,16,......,10000\\n\\nsay if you try a binary search on this array, it gives you almost nothing"
                    },
                    {
                        "username": "juciy_eggplant",
                        "content": "We know that for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF. From these conditions, we can prove that there must exist such an i that is peak, nums[i] > nums[i-1] and nums[i] > nums[i+1]:\\nSuppose there is no  i such that nums[i] > nums[i-1] and nums[i] > nums[i+1], then there are two cases:\\n1. if nums[i] > nums[i-1], it implies nums[i] < nums[i+1] for all i. however, this contradicts nums[n] == -INF\\n2. if nums[i] > nums[i+1], it implies nums[i] < nums[i-1] for all i which contradicts nums[-1] == -INF\\nQED\\n\\nNow we know that there must exist a peak i, we can derive the algorithm\\n1. if nums[m] < nums[m+1], then we know the right half is also an array where for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF (or to be more precise any x such that x < nums[i_0] && x < nums[i_n-1] and we know there must exist a peak\\n2. if nums[m] > nums[m+1], same logic applies for the left half"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Oh ok! I get it now. The whole magic lies in the sentence \"an element is always considered to be strictly greater than a neighbor that is outside the array.\" \\nThanks for the great comment! "
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Thank you very much for explanation sir :) Best explanation :)"
                    },
                    {
                        "username": "brianSalk",
                        "content": "In the comments section I see a lot of people saying that they do not know how they could come up with the binary search solution on their own in a short amount of time like the time that is allowed during an interview.\\n\\nFirst of all, you should be familiar with binary search, for it is a very common algorithm that can be modified to solve many problems that involve searching.\\nSecond, the question says that your algorithm must run in O(logN), which means that linear scan is out of the question.\\nIf you ever have a problem that involves searching for some element in a list in O(logN) time, you are probably limited to some variation of binary search as your only choice.  \\n\\n"
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "exactly O(logN) implies binary search modification.\\n"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe problem should state that there is only one peak in the sequence. Otherwise logarithmic complexity is not possible.\\n\\nFor example:\\n[1,2,1,3,4,5,0] has two peaks: 2 and 5. In such case, the search is O(n)."
                    },
                    {
                        "username": "pstrait",
                        "content": "No because you can stop at the first peak."
                    },
                    {
                        "username": "zeddysoft",
                        "content": "Hello folks,\\n\\nCan anyone here enlighten me on the significance of a question that has more downvote than upvotes. more specifically, should this type of question be avoided?\\n"
                    },
                    {
                        "username": "chaudharyrittik_26",
                        "content": "i also have the same question, can you tell me if you\\'ve got the answer\\n\\n"
                    },
                    {
                        "username": "thebigjuicyd",
                        "content": "no idea what you are talking about"
                    },
                    {
                        "username": "Ricola",
                        "content": "I don't get why I got this error while I never used an array in my answer.\\n\\nI think they edited the question, because the beginning of the solution is \"public int findPeakElement(List nums) {\" and in the answers, I saw people using an array of int.\\n\\nI tried using an array it doesn't work either."
                    },
                    {
                        "username": "tourist44",
                        "content": "It should say that peak element is an elemet which is greater than or equals to its neighbours and not strictly greater than its neighbours.\\nThats when this outcome would be correct.\\n![image](https://assets.leetcode.com/users/images/3e017fa3-9f28-4ac9-87b7-e3b0da7817f1_1600229691.3791375.png)\\n"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "one reason the answer is not -1 is because in the constraint it's mentioned that nums[-1] =nums[n]=-infinity hence if an array contains single digit then we will return 0 as it's bigger than -infinity. maybe that's why it's saying wrong answer. \nyou can see as it's written here-\nIn other words, an element is always considered to be strictly greater than a neighbor that is outside the array. Hence the answer would be 2 and not -1.\n"
                    },
                    {
                        "username": "davidtn",
                        "content": "Your test case is bad input because 1 of the 3 constraints down at the bottom is that no adjacent elements equal each other."
                    }
                ]
            },
            {
                "id": 1567741,
                "content": [
                    {
                        "username": "amoicity",
                        "content": "When people see ths question, I think most people will immediately come up with the linear search solution, which is to examine each num and compare it with its two neighbours. No braniner, right? Then people are thinking why this kind of question would  appear in the question pool and why it\\'s even rated as Medium. Then they might go to the Solution tab and see someone writing up a big article explaining a better solution and probably think, why bother? That\\'s an overkill. \\n\\nThese types of questions are so undervalued by people. And these are the questions we should pay more attention to. I\\'m sure in a real question, the interviewer will not be satisfied by the linear solution. Why? Because the straightforward linear scan solution isn\\'t using all of the clues given in the question. These clues, including\\n1. No adjacent two numbers are the same\\n2. the two end of the arrays are -\\u221E\\n3. You can return any peak.\\n\\nare all the clues that we can base upon to get to the final BS solution. When you are reading a question, pay great attention to these clues. If your solution does not involve all of the clue provided, you might not get the optimal solution. This is not any random question, it\\'s asked by Facebook, Google, etc., for multiple times. There is a reason why it exist and please don\\'t downvote it without even attempting to understand it."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@olsonpm](/olsonpm) I guess criticism of premature optimization originally intended to direct programmer\\'s effort into the best way of optimizing code. But now it\\'s most often used as an argument against any optimization."
                    },
                    {
                        "username": "olsonpm",
                        "content": "Questions like this that don\\'t enforce the optimal solution are a poor way to test devs.  In the real world, investing time into an unnecessary optimization is called premature optimization, and is a poor use of time as well as over-complicates the code."
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Mate, your tip is the best discussion section post template i always want to see :)"
                    },
                    {
                        "username": "sergei99",
                        "content": "Thanks mate. I had initially though that there was a mistake in the task description, but after your comment just sat down and wrote a few example lists of numbers. And then it took just a dozen lines of C++ code, including all the edge cases, to get 0ms execution time with 100% users beaten. :-)"
                    },
                    {
                        "username": "vaibhavbhatt59",
                        "content": "thanks bro i am going for see the solution  but bymistake i open discussion and see your comment on top . then i give another try to the question  and i did it . thanks bro\\n"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "i was getting frustrated and was going to look out for solutions but this comment pushed me and it clicked after few more minutes .... great question btw\\n"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "why u shudn\\'t skip questions with large no of downvotes without reading yourself"
                    },
                    {
                        "username": "madhavmaheshwarimm20",
                        "content": "[@armashhashmi](/armashhashmi) in constraints last point"
                    },
                    {
                        "username": "pyush98",
                        "content": "[@armashhashmi](/armashhashmi) \\n\\nnums[i] != nums[i + 1] for all valid i\\n\\nwrittein at bottom in smallest possible text XD"
                    },
                    {
                        "username": "armashhashmi",
                        "content": "where is it written in the question that \"No adjacent two numbers are same\" ?\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "after reading this (all before the 3 clues) I went and solved it in log(n) time, thanks for motivating me for doing so."
                    },
                    {
                        "username": "sohamdixit",
                        "content": "Agreed, but also for such questions where there is a trivial solution, I think the testcases need to be strong enough to not accept the trivial solution. In this case an O(n) solution should give a TLE, but it gets accepted, giving a misleading and false sense of having solved the problem in the best possible time to many people."
                    },
                    {
                        "username": "lavishmalik",
                        "content": "In both the questions you have to find peak elements but the catch is:\\n\\n-In leetcode 852 the array is increasingly and decreasingly sorted i.e its a bitonic array so you can apply modified binary search and find the global peak easily.\\n\\n-In this question(162), the given array is not sorted so they have given that there will be many peak elements and you can find any peak using binary search and return it .\\nBut you can\\'t find global peak in this question  just by applying binary search like previous question(852) because array is unsorted therefore after finding mid you can\\'t decide which side to go  for finding global peak.\\n\\n//Pls upvote if you like my solution\\n"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "the same code works for this also\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "So, How we do this."
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "The question doesn\\'t say the array is sorted, how do we know to use binary search ?"
                    },
                    {
                        "username": "cheekubhai",
                        "content": "The indexes form a sorted array"
                    },
                    {
                        "username": "premranjn",
                        "content": "there is a concept called binary search on answer, the sole idea of binary search in not only about finding a target in a sorted array, but to half the sample space after each decision.\\nSo here :\\nint findPeakElement(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if((mid == nums.size()-1)||nums[mid]>nums[mid+1] && ((mid == 0) || nums[mid]>nums[mid-1]))\\n                return mid;\\n            else if(mid==0)\\n                start = mid+1;\\n            else if(mid == nums.size()-1)\\n                end = mid-1;\\n            else if(nums[mid-1] < nums[mid])\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        return -1;\\n    }\\nif you would notice I am removing the half of the sample space each time i find the mid, using certain parameters.\\nHope It Helps ;)"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "[@ahmad-saeed](/ahmad-saeed) Sorting is an O(NLogN) process which is worse than doing a plain old linear search. Besides, you are supposed to return the index of the peak in its original position so you shouldn\\'t mutate the array in any way."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@pstrait](/pstrait) then i can just sort it in O(log n) then return the last in o(1) which satisfies the requirement without searching!"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "because  they said to do in 0(log n)  which is time complexty of binary search"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "Who said binary search can only applied on sorted arrays ?"
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "[@ssy55ssy](/ssy55ssy) can you please tell why that will work "
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "when the element is larger than it\\'s former element but it\\'s smaller than it\\'s later element,then the peak must appear behind it"
                    },
                    {
                        "username": "deadbycoffee",
                        "content": "I think it was just helpful that there could be multiple peaks. And because of that, you\\'re able to have a better chance of moving the left and right borders of the search based on what\\'s higher, mid, mid - 1, or mid + 1. Eventually either finding a peak or not finding one."
                    },
                    {
                        "username": "Altum_pax",
                        "content": "[@pstrait](/pstrait) Exactly that\\'s the catch!"
                    },
                    {
                        "username": "pstrait",
                        "content": "The array isn\\'t sorted; if it was sorted, the answer would just be the last element."
                    },
                    {
                        "username": "heejincs",
                        "content": "We can do simple binary search that check [mid] point and [mid+1] point and take half which has higher value, i.e. take left half if nums[mid]>nums[mid+1].\\nIt is not easy to show or proof why this works. \\nThe simple proof is that we take part of numbers that boundary condition holds true.\\nThat is, we only take search range (l, r) if nums[l-1]<nums[l] and num[r]>num[r+1]. Note that initial search range (l,r) where l=0 and r=len(nums)-1 holds true. Then, each step we reduce the search range half making sure the boundary condition holds true. Note that the other half the condition does not hold true.\\nTherefore, when it finally is reduced to a single number, it is the local maximum since the boundary condition for a single number is same as the condition for local maximum.\\n\\n"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I dont\\' understand the advantage of doing a linear search from 2 directions - \\n\\nlike what if your array is almost sorted with the peak occurring somewhere far away from mids\\n\\nlike 1,2,7,11,9,15,16,......,10000\\n\\nsay if you try a binary search on this array, it gives you almost nothing"
                    },
                    {
                        "username": "juciy_eggplant",
                        "content": "We know that for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF. From these conditions, we can prove that there must exist such an i that is peak, nums[i] > nums[i-1] and nums[i] > nums[i+1]:\\nSuppose there is no  i such that nums[i] > nums[i-1] and nums[i] > nums[i+1], then there are two cases:\\n1. if nums[i] > nums[i-1], it implies nums[i] < nums[i+1] for all i. however, this contradicts nums[n] == -INF\\n2. if nums[i] > nums[i+1], it implies nums[i] < nums[i-1] for all i which contradicts nums[-1] == -INF\\nQED\\n\\nNow we know that there must exist a peak i, we can derive the algorithm\\n1. if nums[m] < nums[m+1], then we know the right half is also an array where for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF (or to be more precise any x such that x < nums[i_0] && x < nums[i_n-1] and we know there must exist a peak\\n2. if nums[m] > nums[m+1], same logic applies for the left half"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Oh ok! I get it now. The whole magic lies in the sentence \"an element is always considered to be strictly greater than a neighbor that is outside the array.\" \\nThanks for the great comment! "
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Thank you very much for explanation sir :) Best explanation :)"
                    },
                    {
                        "username": "brianSalk",
                        "content": "In the comments section I see a lot of people saying that they do not know how they could come up with the binary search solution on their own in a short amount of time like the time that is allowed during an interview.\\n\\nFirst of all, you should be familiar with binary search, for it is a very common algorithm that can be modified to solve many problems that involve searching.\\nSecond, the question says that your algorithm must run in O(logN), which means that linear scan is out of the question.\\nIf you ever have a problem that involves searching for some element in a list in O(logN) time, you are probably limited to some variation of binary search as your only choice.  \\n\\n"
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "exactly O(logN) implies binary search modification.\\n"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe problem should state that there is only one peak in the sequence. Otherwise logarithmic complexity is not possible.\\n\\nFor example:\\n[1,2,1,3,4,5,0] has two peaks: 2 and 5. In such case, the search is O(n)."
                    },
                    {
                        "username": "pstrait",
                        "content": "No because you can stop at the first peak."
                    },
                    {
                        "username": "zeddysoft",
                        "content": "Hello folks,\\n\\nCan anyone here enlighten me on the significance of a question that has more downvote than upvotes. more specifically, should this type of question be avoided?\\n"
                    },
                    {
                        "username": "chaudharyrittik_26",
                        "content": "i also have the same question, can you tell me if you\\'ve got the answer\\n\\n"
                    },
                    {
                        "username": "thebigjuicyd",
                        "content": "no idea what you are talking about"
                    },
                    {
                        "username": "Ricola",
                        "content": "I don't get why I got this error while I never used an array in my answer.\\n\\nI think they edited the question, because the beginning of the solution is \"public int findPeakElement(List nums) {\" and in the answers, I saw people using an array of int.\\n\\nI tried using an array it doesn't work either."
                    },
                    {
                        "username": "tourist44",
                        "content": "It should say that peak element is an elemet which is greater than or equals to its neighbours and not strictly greater than its neighbours.\\nThats when this outcome would be correct.\\n![image](https://assets.leetcode.com/users/images/3e017fa3-9f28-4ac9-87b7-e3b0da7817f1_1600229691.3791375.png)\\n"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "one reason the answer is not -1 is because in the constraint it's mentioned that nums[-1] =nums[n]=-infinity hence if an array contains single digit then we will return 0 as it's bigger than -infinity. maybe that's why it's saying wrong answer. \nyou can see as it's written here-\nIn other words, an element is always considered to be strictly greater than a neighbor that is outside the array. Hence the answer would be 2 and not -1.\n"
                    },
                    {
                        "username": "davidtn",
                        "content": "Your test case is bad input because 1 of the 3 constraints down at the bottom is that no adjacent elements equal each other."
                    }
                ]
            },
            {
                "id": 1570420,
                "content": [
                    {
                        "username": "amoicity",
                        "content": "When people see ths question, I think most people will immediately come up with the linear search solution, which is to examine each num and compare it with its two neighbours. No braniner, right? Then people are thinking why this kind of question would  appear in the question pool and why it\\'s even rated as Medium. Then they might go to the Solution tab and see someone writing up a big article explaining a better solution and probably think, why bother? That\\'s an overkill. \\n\\nThese types of questions are so undervalued by people. And these are the questions we should pay more attention to. I\\'m sure in a real question, the interviewer will not be satisfied by the linear solution. Why? Because the straightforward linear scan solution isn\\'t using all of the clues given in the question. These clues, including\\n1. No adjacent two numbers are the same\\n2. the two end of the arrays are -\\u221E\\n3. You can return any peak.\\n\\nare all the clues that we can base upon to get to the final BS solution. When you are reading a question, pay great attention to these clues. If your solution does not involve all of the clue provided, you might not get the optimal solution. This is not any random question, it\\'s asked by Facebook, Google, etc., for multiple times. There is a reason why it exist and please don\\'t downvote it without even attempting to understand it."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@olsonpm](/olsonpm) I guess criticism of premature optimization originally intended to direct programmer\\'s effort into the best way of optimizing code. But now it\\'s most often used as an argument against any optimization."
                    },
                    {
                        "username": "olsonpm",
                        "content": "Questions like this that don\\'t enforce the optimal solution are a poor way to test devs.  In the real world, investing time into an unnecessary optimization is called premature optimization, and is a poor use of time as well as over-complicates the code."
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Mate, your tip is the best discussion section post template i always want to see :)"
                    },
                    {
                        "username": "sergei99",
                        "content": "Thanks mate. I had initially though that there was a mistake in the task description, but after your comment just sat down and wrote a few example lists of numbers. And then it took just a dozen lines of C++ code, including all the edge cases, to get 0ms execution time with 100% users beaten. :-)"
                    },
                    {
                        "username": "vaibhavbhatt59",
                        "content": "thanks bro i am going for see the solution  but bymistake i open discussion and see your comment on top . then i give another try to the question  and i did it . thanks bro\\n"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "i was getting frustrated and was going to look out for solutions but this comment pushed me and it clicked after few more minutes .... great question btw\\n"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "why u shudn\\'t skip questions with large no of downvotes without reading yourself"
                    },
                    {
                        "username": "madhavmaheshwarimm20",
                        "content": "[@armashhashmi](/armashhashmi) in constraints last point"
                    },
                    {
                        "username": "pyush98",
                        "content": "[@armashhashmi](/armashhashmi) \\n\\nnums[i] != nums[i + 1] for all valid i\\n\\nwrittein at bottom in smallest possible text XD"
                    },
                    {
                        "username": "armashhashmi",
                        "content": "where is it written in the question that \"No adjacent two numbers are same\" ?\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "after reading this (all before the 3 clues) I went and solved it in log(n) time, thanks for motivating me for doing so."
                    },
                    {
                        "username": "sohamdixit",
                        "content": "Agreed, but also for such questions where there is a trivial solution, I think the testcases need to be strong enough to not accept the trivial solution. In this case an O(n) solution should give a TLE, but it gets accepted, giving a misleading and false sense of having solved the problem in the best possible time to many people."
                    },
                    {
                        "username": "lavishmalik",
                        "content": "In both the questions you have to find peak elements but the catch is:\\n\\n-In leetcode 852 the array is increasingly and decreasingly sorted i.e its a bitonic array so you can apply modified binary search and find the global peak easily.\\n\\n-In this question(162), the given array is not sorted so they have given that there will be many peak elements and you can find any peak using binary search and return it .\\nBut you can\\'t find global peak in this question  just by applying binary search like previous question(852) because array is unsorted therefore after finding mid you can\\'t decide which side to go  for finding global peak.\\n\\n//Pls upvote if you like my solution\\n"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "the same code works for this also\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "So, How we do this."
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "The question doesn\\'t say the array is sorted, how do we know to use binary search ?"
                    },
                    {
                        "username": "cheekubhai",
                        "content": "The indexes form a sorted array"
                    },
                    {
                        "username": "premranjn",
                        "content": "there is a concept called binary search on answer, the sole idea of binary search in not only about finding a target in a sorted array, but to half the sample space after each decision.\\nSo here :\\nint findPeakElement(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if((mid == nums.size()-1)||nums[mid]>nums[mid+1] && ((mid == 0) || nums[mid]>nums[mid-1]))\\n                return mid;\\n            else if(mid==0)\\n                start = mid+1;\\n            else if(mid == nums.size()-1)\\n                end = mid-1;\\n            else if(nums[mid-1] < nums[mid])\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        return -1;\\n    }\\nif you would notice I am removing the half of the sample space each time i find the mid, using certain parameters.\\nHope It Helps ;)"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "[@ahmad-saeed](/ahmad-saeed) Sorting is an O(NLogN) process which is worse than doing a plain old linear search. Besides, you are supposed to return the index of the peak in its original position so you shouldn\\'t mutate the array in any way."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@pstrait](/pstrait) then i can just sort it in O(log n) then return the last in o(1) which satisfies the requirement without searching!"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "because  they said to do in 0(log n)  which is time complexty of binary search"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "Who said binary search can only applied on sorted arrays ?"
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "[@ssy55ssy](/ssy55ssy) can you please tell why that will work "
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "when the element is larger than it\\'s former element but it\\'s smaller than it\\'s later element,then the peak must appear behind it"
                    },
                    {
                        "username": "deadbycoffee",
                        "content": "I think it was just helpful that there could be multiple peaks. And because of that, you\\'re able to have a better chance of moving the left and right borders of the search based on what\\'s higher, mid, mid - 1, or mid + 1. Eventually either finding a peak or not finding one."
                    },
                    {
                        "username": "Altum_pax",
                        "content": "[@pstrait](/pstrait) Exactly that\\'s the catch!"
                    },
                    {
                        "username": "pstrait",
                        "content": "The array isn\\'t sorted; if it was sorted, the answer would just be the last element."
                    },
                    {
                        "username": "heejincs",
                        "content": "We can do simple binary search that check [mid] point and [mid+1] point and take half which has higher value, i.e. take left half if nums[mid]>nums[mid+1].\\nIt is not easy to show or proof why this works. \\nThe simple proof is that we take part of numbers that boundary condition holds true.\\nThat is, we only take search range (l, r) if nums[l-1]<nums[l] and num[r]>num[r+1]. Note that initial search range (l,r) where l=0 and r=len(nums)-1 holds true. Then, each step we reduce the search range half making sure the boundary condition holds true. Note that the other half the condition does not hold true.\\nTherefore, when it finally is reduced to a single number, it is the local maximum since the boundary condition for a single number is same as the condition for local maximum.\\n\\n"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I dont\\' understand the advantage of doing a linear search from 2 directions - \\n\\nlike what if your array is almost sorted with the peak occurring somewhere far away from mids\\n\\nlike 1,2,7,11,9,15,16,......,10000\\n\\nsay if you try a binary search on this array, it gives you almost nothing"
                    },
                    {
                        "username": "juciy_eggplant",
                        "content": "We know that for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF. From these conditions, we can prove that there must exist such an i that is peak, nums[i] > nums[i-1] and nums[i] > nums[i+1]:\\nSuppose there is no  i such that nums[i] > nums[i-1] and nums[i] > nums[i+1], then there are two cases:\\n1. if nums[i] > nums[i-1], it implies nums[i] < nums[i+1] for all i. however, this contradicts nums[n] == -INF\\n2. if nums[i] > nums[i+1], it implies nums[i] < nums[i-1] for all i which contradicts nums[-1] == -INF\\nQED\\n\\nNow we know that there must exist a peak i, we can derive the algorithm\\n1. if nums[m] < nums[m+1], then we know the right half is also an array where for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF (or to be more precise any x such that x < nums[i_0] && x < nums[i_n-1] and we know there must exist a peak\\n2. if nums[m] > nums[m+1], same logic applies for the left half"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Oh ok! I get it now. The whole magic lies in the sentence \"an element is always considered to be strictly greater than a neighbor that is outside the array.\" \\nThanks for the great comment! "
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Thank you very much for explanation sir :) Best explanation :)"
                    },
                    {
                        "username": "brianSalk",
                        "content": "In the comments section I see a lot of people saying that they do not know how they could come up with the binary search solution on their own in a short amount of time like the time that is allowed during an interview.\\n\\nFirst of all, you should be familiar with binary search, for it is a very common algorithm that can be modified to solve many problems that involve searching.\\nSecond, the question says that your algorithm must run in O(logN), which means that linear scan is out of the question.\\nIf you ever have a problem that involves searching for some element in a list in O(logN) time, you are probably limited to some variation of binary search as your only choice.  \\n\\n"
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "exactly O(logN) implies binary search modification.\\n"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe problem should state that there is only one peak in the sequence. Otherwise logarithmic complexity is not possible.\\n\\nFor example:\\n[1,2,1,3,4,5,0] has two peaks: 2 and 5. In such case, the search is O(n)."
                    },
                    {
                        "username": "pstrait",
                        "content": "No because you can stop at the first peak."
                    },
                    {
                        "username": "zeddysoft",
                        "content": "Hello folks,\\n\\nCan anyone here enlighten me on the significance of a question that has more downvote than upvotes. more specifically, should this type of question be avoided?\\n"
                    },
                    {
                        "username": "chaudharyrittik_26",
                        "content": "i also have the same question, can you tell me if you\\'ve got the answer\\n\\n"
                    },
                    {
                        "username": "thebigjuicyd",
                        "content": "no idea what you are talking about"
                    },
                    {
                        "username": "Ricola",
                        "content": "I don't get why I got this error while I never used an array in my answer.\\n\\nI think they edited the question, because the beginning of the solution is \"public int findPeakElement(List nums) {\" and in the answers, I saw people using an array of int.\\n\\nI tried using an array it doesn't work either."
                    },
                    {
                        "username": "tourist44",
                        "content": "It should say that peak element is an elemet which is greater than or equals to its neighbours and not strictly greater than its neighbours.\\nThats when this outcome would be correct.\\n![image](https://assets.leetcode.com/users/images/3e017fa3-9f28-4ac9-87b7-e3b0da7817f1_1600229691.3791375.png)\\n"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "one reason the answer is not -1 is because in the constraint it's mentioned that nums[-1] =nums[n]=-infinity hence if an array contains single digit then we will return 0 as it's bigger than -infinity. maybe that's why it's saying wrong answer. \nyou can see as it's written here-\nIn other words, an element is always considered to be strictly greater than a neighbor that is outside the array. Hence the answer would be 2 and not -1.\n"
                    },
                    {
                        "username": "davidtn",
                        "content": "Your test case is bad input because 1 of the 3 constraints down at the bottom is that no adjacent elements equal each other."
                    }
                ]
            },
            {
                "id": 1565066,
                "content": [
                    {
                        "username": "amoicity",
                        "content": "When people see ths question, I think most people will immediately come up with the linear search solution, which is to examine each num and compare it with its two neighbours. No braniner, right? Then people are thinking why this kind of question would  appear in the question pool and why it\\'s even rated as Medium. Then they might go to the Solution tab and see someone writing up a big article explaining a better solution and probably think, why bother? That\\'s an overkill. \\n\\nThese types of questions are so undervalued by people. And these are the questions we should pay more attention to. I\\'m sure in a real question, the interviewer will not be satisfied by the linear solution. Why? Because the straightforward linear scan solution isn\\'t using all of the clues given in the question. These clues, including\\n1. No adjacent two numbers are the same\\n2. the two end of the arrays are -\\u221E\\n3. You can return any peak.\\n\\nare all the clues that we can base upon to get to the final BS solution. When you are reading a question, pay great attention to these clues. If your solution does not involve all of the clue provided, you might not get the optimal solution. This is not any random question, it\\'s asked by Facebook, Google, etc., for multiple times. There is a reason why it exist and please don\\'t downvote it without even attempting to understand it."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@olsonpm](/olsonpm) I guess criticism of premature optimization originally intended to direct programmer\\'s effort into the best way of optimizing code. But now it\\'s most often used as an argument against any optimization."
                    },
                    {
                        "username": "olsonpm",
                        "content": "Questions like this that don\\'t enforce the optimal solution are a poor way to test devs.  In the real world, investing time into an unnecessary optimization is called premature optimization, and is a poor use of time as well as over-complicates the code."
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Mate, your tip is the best discussion section post template i always want to see :)"
                    },
                    {
                        "username": "sergei99",
                        "content": "Thanks mate. I had initially though that there was a mistake in the task description, but after your comment just sat down and wrote a few example lists of numbers. And then it took just a dozen lines of C++ code, including all the edge cases, to get 0ms execution time with 100% users beaten. :-)"
                    },
                    {
                        "username": "vaibhavbhatt59",
                        "content": "thanks bro i am going for see the solution  but bymistake i open discussion and see your comment on top . then i give another try to the question  and i did it . thanks bro\\n"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "i was getting frustrated and was going to look out for solutions but this comment pushed me and it clicked after few more minutes .... great question btw\\n"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "why u shudn\\'t skip questions with large no of downvotes without reading yourself"
                    },
                    {
                        "username": "madhavmaheshwarimm20",
                        "content": "[@armashhashmi](/armashhashmi) in constraints last point"
                    },
                    {
                        "username": "pyush98",
                        "content": "[@armashhashmi](/armashhashmi) \\n\\nnums[i] != nums[i + 1] for all valid i\\n\\nwrittein at bottom in smallest possible text XD"
                    },
                    {
                        "username": "armashhashmi",
                        "content": "where is it written in the question that \"No adjacent two numbers are same\" ?\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "after reading this (all before the 3 clues) I went and solved it in log(n) time, thanks for motivating me for doing so."
                    },
                    {
                        "username": "sohamdixit",
                        "content": "Agreed, but also for such questions where there is a trivial solution, I think the testcases need to be strong enough to not accept the trivial solution. In this case an O(n) solution should give a TLE, but it gets accepted, giving a misleading and false sense of having solved the problem in the best possible time to many people."
                    },
                    {
                        "username": "lavishmalik",
                        "content": "In both the questions you have to find peak elements but the catch is:\\n\\n-In leetcode 852 the array is increasingly and decreasingly sorted i.e its a bitonic array so you can apply modified binary search and find the global peak easily.\\n\\n-In this question(162), the given array is not sorted so they have given that there will be many peak elements and you can find any peak using binary search and return it .\\nBut you can\\'t find global peak in this question  just by applying binary search like previous question(852) because array is unsorted therefore after finding mid you can\\'t decide which side to go  for finding global peak.\\n\\n//Pls upvote if you like my solution\\n"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "the same code works for this also\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "So, How we do this."
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "The question doesn\\'t say the array is sorted, how do we know to use binary search ?"
                    },
                    {
                        "username": "cheekubhai",
                        "content": "The indexes form a sorted array"
                    },
                    {
                        "username": "premranjn",
                        "content": "there is a concept called binary search on answer, the sole idea of binary search in not only about finding a target in a sorted array, but to half the sample space after each decision.\\nSo here :\\nint findPeakElement(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if((mid == nums.size()-1)||nums[mid]>nums[mid+1] && ((mid == 0) || nums[mid]>nums[mid-1]))\\n                return mid;\\n            else if(mid==0)\\n                start = mid+1;\\n            else if(mid == nums.size()-1)\\n                end = mid-1;\\n            else if(nums[mid-1] < nums[mid])\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        return -1;\\n    }\\nif you would notice I am removing the half of the sample space each time i find the mid, using certain parameters.\\nHope It Helps ;)"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "[@ahmad-saeed](/ahmad-saeed) Sorting is an O(NLogN) process which is worse than doing a plain old linear search. Besides, you are supposed to return the index of the peak in its original position so you shouldn\\'t mutate the array in any way."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@pstrait](/pstrait) then i can just sort it in O(log n) then return the last in o(1) which satisfies the requirement without searching!"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "because  they said to do in 0(log n)  which is time complexty of binary search"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "Who said binary search can only applied on sorted arrays ?"
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "[@ssy55ssy](/ssy55ssy) can you please tell why that will work "
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "when the element is larger than it\\'s former element but it\\'s smaller than it\\'s later element,then the peak must appear behind it"
                    },
                    {
                        "username": "deadbycoffee",
                        "content": "I think it was just helpful that there could be multiple peaks. And because of that, you\\'re able to have a better chance of moving the left and right borders of the search based on what\\'s higher, mid, mid - 1, or mid + 1. Eventually either finding a peak or not finding one."
                    },
                    {
                        "username": "Altum_pax",
                        "content": "[@pstrait](/pstrait) Exactly that\\'s the catch!"
                    },
                    {
                        "username": "pstrait",
                        "content": "The array isn\\'t sorted; if it was sorted, the answer would just be the last element."
                    },
                    {
                        "username": "heejincs",
                        "content": "We can do simple binary search that check [mid] point and [mid+1] point and take half which has higher value, i.e. take left half if nums[mid]>nums[mid+1].\\nIt is not easy to show or proof why this works. \\nThe simple proof is that we take part of numbers that boundary condition holds true.\\nThat is, we only take search range (l, r) if nums[l-1]<nums[l] and num[r]>num[r+1]. Note that initial search range (l,r) where l=0 and r=len(nums)-1 holds true. Then, each step we reduce the search range half making sure the boundary condition holds true. Note that the other half the condition does not hold true.\\nTherefore, when it finally is reduced to a single number, it is the local maximum since the boundary condition for a single number is same as the condition for local maximum.\\n\\n"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I dont\\' understand the advantage of doing a linear search from 2 directions - \\n\\nlike what if your array is almost sorted with the peak occurring somewhere far away from mids\\n\\nlike 1,2,7,11,9,15,16,......,10000\\n\\nsay if you try a binary search on this array, it gives you almost nothing"
                    },
                    {
                        "username": "juciy_eggplant",
                        "content": "We know that for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF. From these conditions, we can prove that there must exist such an i that is peak, nums[i] > nums[i-1] and nums[i] > nums[i+1]:\\nSuppose there is no  i such that nums[i] > nums[i-1] and nums[i] > nums[i+1], then there are two cases:\\n1. if nums[i] > nums[i-1], it implies nums[i] < nums[i+1] for all i. however, this contradicts nums[n] == -INF\\n2. if nums[i] > nums[i+1], it implies nums[i] < nums[i-1] for all i which contradicts nums[-1] == -INF\\nQED\\n\\nNow we know that there must exist a peak i, we can derive the algorithm\\n1. if nums[m] < nums[m+1], then we know the right half is also an array where for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF (or to be more precise any x such that x < nums[i_0] && x < nums[i_n-1] and we know there must exist a peak\\n2. if nums[m] > nums[m+1], same logic applies for the left half"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Oh ok! I get it now. The whole magic lies in the sentence \"an element is always considered to be strictly greater than a neighbor that is outside the array.\" \\nThanks for the great comment! "
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Thank you very much for explanation sir :) Best explanation :)"
                    },
                    {
                        "username": "brianSalk",
                        "content": "In the comments section I see a lot of people saying that they do not know how they could come up with the binary search solution on their own in a short amount of time like the time that is allowed during an interview.\\n\\nFirst of all, you should be familiar with binary search, for it is a very common algorithm that can be modified to solve many problems that involve searching.\\nSecond, the question says that your algorithm must run in O(logN), which means that linear scan is out of the question.\\nIf you ever have a problem that involves searching for some element in a list in O(logN) time, you are probably limited to some variation of binary search as your only choice.  \\n\\n"
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "exactly O(logN) implies binary search modification.\\n"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe problem should state that there is only one peak in the sequence. Otherwise logarithmic complexity is not possible.\\n\\nFor example:\\n[1,2,1,3,4,5,0] has two peaks: 2 and 5. In such case, the search is O(n)."
                    },
                    {
                        "username": "pstrait",
                        "content": "No because you can stop at the first peak."
                    },
                    {
                        "username": "zeddysoft",
                        "content": "Hello folks,\\n\\nCan anyone here enlighten me on the significance of a question that has more downvote than upvotes. more specifically, should this type of question be avoided?\\n"
                    },
                    {
                        "username": "chaudharyrittik_26",
                        "content": "i also have the same question, can you tell me if you\\'ve got the answer\\n\\n"
                    },
                    {
                        "username": "thebigjuicyd",
                        "content": "no idea what you are talking about"
                    },
                    {
                        "username": "Ricola",
                        "content": "I don't get why I got this error while I never used an array in my answer.\\n\\nI think they edited the question, because the beginning of the solution is \"public int findPeakElement(List nums) {\" and in the answers, I saw people using an array of int.\\n\\nI tried using an array it doesn't work either."
                    },
                    {
                        "username": "tourist44",
                        "content": "It should say that peak element is an elemet which is greater than or equals to its neighbours and not strictly greater than its neighbours.\\nThats when this outcome would be correct.\\n![image](https://assets.leetcode.com/users/images/3e017fa3-9f28-4ac9-87b7-e3b0da7817f1_1600229691.3791375.png)\\n"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "one reason the answer is not -1 is because in the constraint it's mentioned that nums[-1] =nums[n]=-infinity hence if an array contains single digit then we will return 0 as it's bigger than -infinity. maybe that's why it's saying wrong answer. \nyou can see as it's written here-\nIn other words, an element is always considered to be strictly greater than a neighbor that is outside the array. Hence the answer would be 2 and not -1.\n"
                    },
                    {
                        "username": "davidtn",
                        "content": "Your test case is bad input because 1 of the 3 constraints down at the bottom is that no adjacent elements equal each other."
                    }
                ]
            },
            {
                "id": 1568447,
                "content": [
                    {
                        "username": "amoicity",
                        "content": "When people see ths question, I think most people will immediately come up with the linear search solution, which is to examine each num and compare it with its two neighbours. No braniner, right? Then people are thinking why this kind of question would  appear in the question pool and why it\\'s even rated as Medium. Then they might go to the Solution tab and see someone writing up a big article explaining a better solution and probably think, why bother? That\\'s an overkill. \\n\\nThese types of questions are so undervalued by people. And these are the questions we should pay more attention to. I\\'m sure in a real question, the interviewer will not be satisfied by the linear solution. Why? Because the straightforward linear scan solution isn\\'t using all of the clues given in the question. These clues, including\\n1. No adjacent two numbers are the same\\n2. the two end of the arrays are -\\u221E\\n3. You can return any peak.\\n\\nare all the clues that we can base upon to get to the final BS solution. When you are reading a question, pay great attention to these clues. If your solution does not involve all of the clue provided, you might not get the optimal solution. This is not any random question, it\\'s asked by Facebook, Google, etc., for multiple times. There is a reason why it exist and please don\\'t downvote it without even attempting to understand it."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@olsonpm](/olsonpm) I guess criticism of premature optimization originally intended to direct programmer\\'s effort into the best way of optimizing code. But now it\\'s most often used as an argument against any optimization."
                    },
                    {
                        "username": "olsonpm",
                        "content": "Questions like this that don\\'t enforce the optimal solution are a poor way to test devs.  In the real world, investing time into an unnecessary optimization is called premature optimization, and is a poor use of time as well as over-complicates the code."
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Mate, your tip is the best discussion section post template i always want to see :)"
                    },
                    {
                        "username": "sergei99",
                        "content": "Thanks mate. I had initially though that there was a mistake in the task description, but after your comment just sat down and wrote a few example lists of numbers. And then it took just a dozen lines of C++ code, including all the edge cases, to get 0ms execution time with 100% users beaten. :-)"
                    },
                    {
                        "username": "vaibhavbhatt59",
                        "content": "thanks bro i am going for see the solution  but bymistake i open discussion and see your comment on top . then i give another try to the question  and i did it . thanks bro\\n"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "i was getting frustrated and was going to look out for solutions but this comment pushed me and it clicked after few more minutes .... great question btw\\n"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "why u shudn\\'t skip questions with large no of downvotes without reading yourself"
                    },
                    {
                        "username": "madhavmaheshwarimm20",
                        "content": "[@armashhashmi](/armashhashmi) in constraints last point"
                    },
                    {
                        "username": "pyush98",
                        "content": "[@armashhashmi](/armashhashmi) \\n\\nnums[i] != nums[i + 1] for all valid i\\n\\nwrittein at bottom in smallest possible text XD"
                    },
                    {
                        "username": "armashhashmi",
                        "content": "where is it written in the question that \"No adjacent two numbers are same\" ?\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "after reading this (all before the 3 clues) I went and solved it in log(n) time, thanks for motivating me for doing so."
                    },
                    {
                        "username": "sohamdixit",
                        "content": "Agreed, but also for such questions where there is a trivial solution, I think the testcases need to be strong enough to not accept the trivial solution. In this case an O(n) solution should give a TLE, but it gets accepted, giving a misleading and false sense of having solved the problem in the best possible time to many people."
                    },
                    {
                        "username": "lavishmalik",
                        "content": "In both the questions you have to find peak elements but the catch is:\\n\\n-In leetcode 852 the array is increasingly and decreasingly sorted i.e its a bitonic array so you can apply modified binary search and find the global peak easily.\\n\\n-In this question(162), the given array is not sorted so they have given that there will be many peak elements and you can find any peak using binary search and return it .\\nBut you can\\'t find global peak in this question  just by applying binary search like previous question(852) because array is unsorted therefore after finding mid you can\\'t decide which side to go  for finding global peak.\\n\\n//Pls upvote if you like my solution\\n"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "the same code works for this also\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "So, How we do this."
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "The question doesn\\'t say the array is sorted, how do we know to use binary search ?"
                    },
                    {
                        "username": "cheekubhai",
                        "content": "The indexes form a sorted array"
                    },
                    {
                        "username": "premranjn",
                        "content": "there is a concept called binary search on answer, the sole idea of binary search in not only about finding a target in a sorted array, but to half the sample space after each decision.\\nSo here :\\nint findPeakElement(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if((mid == nums.size()-1)||nums[mid]>nums[mid+1] && ((mid == 0) || nums[mid]>nums[mid-1]))\\n                return mid;\\n            else if(mid==0)\\n                start = mid+1;\\n            else if(mid == nums.size()-1)\\n                end = mid-1;\\n            else if(nums[mid-1] < nums[mid])\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        return -1;\\n    }\\nif you would notice I am removing the half of the sample space each time i find the mid, using certain parameters.\\nHope It Helps ;)"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "[@ahmad-saeed](/ahmad-saeed) Sorting is an O(NLogN) process which is worse than doing a plain old linear search. Besides, you are supposed to return the index of the peak in its original position so you shouldn\\'t mutate the array in any way."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@pstrait](/pstrait) then i can just sort it in O(log n) then return the last in o(1) which satisfies the requirement without searching!"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "because  they said to do in 0(log n)  which is time complexty of binary search"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "Who said binary search can only applied on sorted arrays ?"
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "[@ssy55ssy](/ssy55ssy) can you please tell why that will work "
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "when the element is larger than it\\'s former element but it\\'s smaller than it\\'s later element,then the peak must appear behind it"
                    },
                    {
                        "username": "deadbycoffee",
                        "content": "I think it was just helpful that there could be multiple peaks. And because of that, you\\'re able to have a better chance of moving the left and right borders of the search based on what\\'s higher, mid, mid - 1, or mid + 1. Eventually either finding a peak or not finding one."
                    },
                    {
                        "username": "Altum_pax",
                        "content": "[@pstrait](/pstrait) Exactly that\\'s the catch!"
                    },
                    {
                        "username": "pstrait",
                        "content": "The array isn\\'t sorted; if it was sorted, the answer would just be the last element."
                    },
                    {
                        "username": "heejincs",
                        "content": "We can do simple binary search that check [mid] point and [mid+1] point and take half which has higher value, i.e. take left half if nums[mid]>nums[mid+1].\\nIt is not easy to show or proof why this works. \\nThe simple proof is that we take part of numbers that boundary condition holds true.\\nThat is, we only take search range (l, r) if nums[l-1]<nums[l] and num[r]>num[r+1]. Note that initial search range (l,r) where l=0 and r=len(nums)-1 holds true. Then, each step we reduce the search range half making sure the boundary condition holds true. Note that the other half the condition does not hold true.\\nTherefore, when it finally is reduced to a single number, it is the local maximum since the boundary condition for a single number is same as the condition for local maximum.\\n\\n"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I dont\\' understand the advantage of doing a linear search from 2 directions - \\n\\nlike what if your array is almost sorted with the peak occurring somewhere far away from mids\\n\\nlike 1,2,7,11,9,15,16,......,10000\\n\\nsay if you try a binary search on this array, it gives you almost nothing"
                    },
                    {
                        "username": "juciy_eggplant",
                        "content": "We know that for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF. From these conditions, we can prove that there must exist such an i that is peak, nums[i] > nums[i-1] and nums[i] > nums[i+1]:\\nSuppose there is no  i such that nums[i] > nums[i-1] and nums[i] > nums[i+1], then there are two cases:\\n1. if nums[i] > nums[i-1], it implies nums[i] < nums[i+1] for all i. however, this contradicts nums[n] == -INF\\n2. if nums[i] > nums[i+1], it implies nums[i] < nums[i-1] for all i which contradicts nums[-1] == -INF\\nQED\\n\\nNow we know that there must exist a peak i, we can derive the algorithm\\n1. if nums[m] < nums[m+1], then we know the right half is also an array where for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF (or to be more precise any x such that x < nums[i_0] && x < nums[i_n-1] and we know there must exist a peak\\n2. if nums[m] > nums[m+1], same logic applies for the left half"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Oh ok! I get it now. The whole magic lies in the sentence \"an element is always considered to be strictly greater than a neighbor that is outside the array.\" \\nThanks for the great comment! "
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Thank you very much for explanation sir :) Best explanation :)"
                    },
                    {
                        "username": "brianSalk",
                        "content": "In the comments section I see a lot of people saying that they do not know how they could come up with the binary search solution on their own in a short amount of time like the time that is allowed during an interview.\\n\\nFirst of all, you should be familiar with binary search, for it is a very common algorithm that can be modified to solve many problems that involve searching.\\nSecond, the question says that your algorithm must run in O(logN), which means that linear scan is out of the question.\\nIf you ever have a problem that involves searching for some element in a list in O(logN) time, you are probably limited to some variation of binary search as your only choice.  \\n\\n"
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "exactly O(logN) implies binary search modification.\\n"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe problem should state that there is only one peak in the sequence. Otherwise logarithmic complexity is not possible.\\n\\nFor example:\\n[1,2,1,3,4,5,0] has two peaks: 2 and 5. In such case, the search is O(n)."
                    },
                    {
                        "username": "pstrait",
                        "content": "No because you can stop at the first peak."
                    },
                    {
                        "username": "zeddysoft",
                        "content": "Hello folks,\\n\\nCan anyone here enlighten me on the significance of a question that has more downvote than upvotes. more specifically, should this type of question be avoided?\\n"
                    },
                    {
                        "username": "chaudharyrittik_26",
                        "content": "i also have the same question, can you tell me if you\\'ve got the answer\\n\\n"
                    },
                    {
                        "username": "thebigjuicyd",
                        "content": "no idea what you are talking about"
                    },
                    {
                        "username": "Ricola",
                        "content": "I don't get why I got this error while I never used an array in my answer.\\n\\nI think they edited the question, because the beginning of the solution is \"public int findPeakElement(List nums) {\" and in the answers, I saw people using an array of int.\\n\\nI tried using an array it doesn't work either."
                    },
                    {
                        "username": "tourist44",
                        "content": "It should say that peak element is an elemet which is greater than or equals to its neighbours and not strictly greater than its neighbours.\\nThats when this outcome would be correct.\\n![image](https://assets.leetcode.com/users/images/3e017fa3-9f28-4ac9-87b7-e3b0da7817f1_1600229691.3791375.png)\\n"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "one reason the answer is not -1 is because in the constraint it's mentioned that nums[-1] =nums[n]=-infinity hence if an array contains single digit then we will return 0 as it's bigger than -infinity. maybe that's why it's saying wrong answer. \nyou can see as it's written here-\nIn other words, an element is always considered to be strictly greater than a neighbor that is outside the array. Hence the answer would be 2 and not -1.\n"
                    },
                    {
                        "username": "davidtn",
                        "content": "Your test case is bad input because 1 of the 3 constraints down at the bottom is that no adjacent elements equal each other."
                    }
                ]
            },
            {
                "id": 1570789,
                "content": [
                    {
                        "username": "amoicity",
                        "content": "When people see ths question, I think most people will immediately come up with the linear search solution, which is to examine each num and compare it with its two neighbours. No braniner, right? Then people are thinking why this kind of question would  appear in the question pool and why it\\'s even rated as Medium. Then they might go to the Solution tab and see someone writing up a big article explaining a better solution and probably think, why bother? That\\'s an overkill. \\n\\nThese types of questions are so undervalued by people. And these are the questions we should pay more attention to. I\\'m sure in a real question, the interviewer will not be satisfied by the linear solution. Why? Because the straightforward linear scan solution isn\\'t using all of the clues given in the question. These clues, including\\n1. No adjacent two numbers are the same\\n2. the two end of the arrays are -\\u221E\\n3. You can return any peak.\\n\\nare all the clues that we can base upon to get to the final BS solution. When you are reading a question, pay great attention to these clues. If your solution does not involve all of the clue provided, you might not get the optimal solution. This is not any random question, it\\'s asked by Facebook, Google, etc., for multiple times. There is a reason why it exist and please don\\'t downvote it without even attempting to understand it."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@olsonpm](/olsonpm) I guess criticism of premature optimization originally intended to direct programmer\\'s effort into the best way of optimizing code. But now it\\'s most often used as an argument against any optimization."
                    },
                    {
                        "username": "olsonpm",
                        "content": "Questions like this that don\\'t enforce the optimal solution are a poor way to test devs.  In the real world, investing time into an unnecessary optimization is called premature optimization, and is a poor use of time as well as over-complicates the code."
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Mate, your tip is the best discussion section post template i always want to see :)"
                    },
                    {
                        "username": "sergei99",
                        "content": "Thanks mate. I had initially though that there was a mistake in the task description, but after your comment just sat down and wrote a few example lists of numbers. And then it took just a dozen lines of C++ code, including all the edge cases, to get 0ms execution time with 100% users beaten. :-)"
                    },
                    {
                        "username": "vaibhavbhatt59",
                        "content": "thanks bro i am going for see the solution  but bymistake i open discussion and see your comment on top . then i give another try to the question  and i did it . thanks bro\\n"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "i was getting frustrated and was going to look out for solutions but this comment pushed me and it clicked after few more minutes .... great question btw\\n"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "why u shudn\\'t skip questions with large no of downvotes without reading yourself"
                    },
                    {
                        "username": "madhavmaheshwarimm20",
                        "content": "[@armashhashmi](/armashhashmi) in constraints last point"
                    },
                    {
                        "username": "pyush98",
                        "content": "[@armashhashmi](/armashhashmi) \\n\\nnums[i] != nums[i + 1] for all valid i\\n\\nwrittein at bottom in smallest possible text XD"
                    },
                    {
                        "username": "armashhashmi",
                        "content": "where is it written in the question that \"No adjacent two numbers are same\" ?\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "after reading this (all before the 3 clues) I went and solved it in log(n) time, thanks for motivating me for doing so."
                    },
                    {
                        "username": "sohamdixit",
                        "content": "Agreed, but also for such questions where there is a trivial solution, I think the testcases need to be strong enough to not accept the trivial solution. In this case an O(n) solution should give a TLE, but it gets accepted, giving a misleading and false sense of having solved the problem in the best possible time to many people."
                    },
                    {
                        "username": "lavishmalik",
                        "content": "In both the questions you have to find peak elements but the catch is:\\n\\n-In leetcode 852 the array is increasingly and decreasingly sorted i.e its a bitonic array so you can apply modified binary search and find the global peak easily.\\n\\n-In this question(162), the given array is not sorted so they have given that there will be many peak elements and you can find any peak using binary search and return it .\\nBut you can\\'t find global peak in this question  just by applying binary search like previous question(852) because array is unsorted therefore after finding mid you can\\'t decide which side to go  for finding global peak.\\n\\n//Pls upvote if you like my solution\\n"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "the same code works for this also\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "So, How we do this."
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "The question doesn\\'t say the array is sorted, how do we know to use binary search ?"
                    },
                    {
                        "username": "cheekubhai",
                        "content": "The indexes form a sorted array"
                    },
                    {
                        "username": "premranjn",
                        "content": "there is a concept called binary search on answer, the sole idea of binary search in not only about finding a target in a sorted array, but to half the sample space after each decision.\\nSo here :\\nint findPeakElement(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if((mid == nums.size()-1)||nums[mid]>nums[mid+1] && ((mid == 0) || nums[mid]>nums[mid-1]))\\n                return mid;\\n            else if(mid==0)\\n                start = mid+1;\\n            else if(mid == nums.size()-1)\\n                end = mid-1;\\n            else if(nums[mid-1] < nums[mid])\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        return -1;\\n    }\\nif you would notice I am removing the half of the sample space each time i find the mid, using certain parameters.\\nHope It Helps ;)"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "[@ahmad-saeed](/ahmad-saeed) Sorting is an O(NLogN) process which is worse than doing a plain old linear search. Besides, you are supposed to return the index of the peak in its original position so you shouldn\\'t mutate the array in any way."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@pstrait](/pstrait) then i can just sort it in O(log n) then return the last in o(1) which satisfies the requirement without searching!"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "because  they said to do in 0(log n)  which is time complexty of binary search"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "Who said binary search can only applied on sorted arrays ?"
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "[@ssy55ssy](/ssy55ssy) can you please tell why that will work "
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "when the element is larger than it\\'s former element but it\\'s smaller than it\\'s later element,then the peak must appear behind it"
                    },
                    {
                        "username": "deadbycoffee",
                        "content": "I think it was just helpful that there could be multiple peaks. And because of that, you\\'re able to have a better chance of moving the left and right borders of the search based on what\\'s higher, mid, mid - 1, or mid + 1. Eventually either finding a peak or not finding one."
                    },
                    {
                        "username": "Altum_pax",
                        "content": "[@pstrait](/pstrait) Exactly that\\'s the catch!"
                    },
                    {
                        "username": "pstrait",
                        "content": "The array isn\\'t sorted; if it was sorted, the answer would just be the last element."
                    },
                    {
                        "username": "heejincs",
                        "content": "We can do simple binary search that check [mid] point and [mid+1] point and take half which has higher value, i.e. take left half if nums[mid]>nums[mid+1].\\nIt is not easy to show or proof why this works. \\nThe simple proof is that we take part of numbers that boundary condition holds true.\\nThat is, we only take search range (l, r) if nums[l-1]<nums[l] and num[r]>num[r+1]. Note that initial search range (l,r) where l=0 and r=len(nums)-1 holds true. Then, each step we reduce the search range half making sure the boundary condition holds true. Note that the other half the condition does not hold true.\\nTherefore, when it finally is reduced to a single number, it is the local maximum since the boundary condition for a single number is same as the condition for local maximum.\\n\\n"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I dont\\' understand the advantage of doing a linear search from 2 directions - \\n\\nlike what if your array is almost sorted with the peak occurring somewhere far away from mids\\n\\nlike 1,2,7,11,9,15,16,......,10000\\n\\nsay if you try a binary search on this array, it gives you almost nothing"
                    },
                    {
                        "username": "juciy_eggplant",
                        "content": "We know that for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF. From these conditions, we can prove that there must exist such an i that is peak, nums[i] > nums[i-1] and nums[i] > nums[i+1]:\\nSuppose there is no  i such that nums[i] > nums[i-1] and nums[i] > nums[i+1], then there are two cases:\\n1. if nums[i] > nums[i-1], it implies nums[i] < nums[i+1] for all i. however, this contradicts nums[n] == -INF\\n2. if nums[i] > nums[i+1], it implies nums[i] < nums[i-1] for all i which contradicts nums[-1] == -INF\\nQED\\n\\nNow we know that there must exist a peak i, we can derive the algorithm\\n1. if nums[m] < nums[m+1], then we know the right half is also an array where for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF (or to be more precise any x such that x < nums[i_0] && x < nums[i_n-1] and we know there must exist a peak\\n2. if nums[m] > nums[m+1], same logic applies for the left half"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Oh ok! I get it now. The whole magic lies in the sentence \"an element is always considered to be strictly greater than a neighbor that is outside the array.\" \\nThanks for the great comment! "
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Thank you very much for explanation sir :) Best explanation :)"
                    },
                    {
                        "username": "brianSalk",
                        "content": "In the comments section I see a lot of people saying that they do not know how they could come up with the binary search solution on their own in a short amount of time like the time that is allowed during an interview.\\n\\nFirst of all, you should be familiar with binary search, for it is a very common algorithm that can be modified to solve many problems that involve searching.\\nSecond, the question says that your algorithm must run in O(logN), which means that linear scan is out of the question.\\nIf you ever have a problem that involves searching for some element in a list in O(logN) time, you are probably limited to some variation of binary search as your only choice.  \\n\\n"
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "exactly O(logN) implies binary search modification.\\n"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe problem should state that there is only one peak in the sequence. Otherwise logarithmic complexity is not possible.\\n\\nFor example:\\n[1,2,1,3,4,5,0] has two peaks: 2 and 5. In such case, the search is O(n)."
                    },
                    {
                        "username": "pstrait",
                        "content": "No because you can stop at the first peak."
                    },
                    {
                        "username": "zeddysoft",
                        "content": "Hello folks,\\n\\nCan anyone here enlighten me on the significance of a question that has more downvote than upvotes. more specifically, should this type of question be avoided?\\n"
                    },
                    {
                        "username": "chaudharyrittik_26",
                        "content": "i also have the same question, can you tell me if you\\'ve got the answer\\n\\n"
                    },
                    {
                        "username": "thebigjuicyd",
                        "content": "no idea what you are talking about"
                    },
                    {
                        "username": "Ricola",
                        "content": "I don't get why I got this error while I never used an array in my answer.\\n\\nI think they edited the question, because the beginning of the solution is \"public int findPeakElement(List nums) {\" and in the answers, I saw people using an array of int.\\n\\nI tried using an array it doesn't work either."
                    },
                    {
                        "username": "tourist44",
                        "content": "It should say that peak element is an elemet which is greater than or equals to its neighbours and not strictly greater than its neighbours.\\nThats when this outcome would be correct.\\n![image](https://assets.leetcode.com/users/images/3e017fa3-9f28-4ac9-87b7-e3b0da7817f1_1600229691.3791375.png)\\n"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "one reason the answer is not -1 is because in the constraint it's mentioned that nums[-1] =nums[n]=-infinity hence if an array contains single digit then we will return 0 as it's bigger than -infinity. maybe that's why it's saying wrong answer. \nyou can see as it's written here-\nIn other words, an element is always considered to be strictly greater than a neighbor that is outside the array. Hence the answer would be 2 and not -1.\n"
                    },
                    {
                        "username": "davidtn",
                        "content": "Your test case is bad input because 1 of the 3 constraints down at the bottom is that no adjacent elements equal each other."
                    }
                ]
            },
            {
                "id": 1566757,
                "content": [
                    {
                        "username": "amoicity",
                        "content": "When people see ths question, I think most people will immediately come up with the linear search solution, which is to examine each num and compare it with its two neighbours. No braniner, right? Then people are thinking why this kind of question would  appear in the question pool and why it\\'s even rated as Medium. Then they might go to the Solution tab and see someone writing up a big article explaining a better solution and probably think, why bother? That\\'s an overkill. \\n\\nThese types of questions are so undervalued by people. And these are the questions we should pay more attention to. I\\'m sure in a real question, the interviewer will not be satisfied by the linear solution. Why? Because the straightforward linear scan solution isn\\'t using all of the clues given in the question. These clues, including\\n1. No adjacent two numbers are the same\\n2. the two end of the arrays are -\\u221E\\n3. You can return any peak.\\n\\nare all the clues that we can base upon to get to the final BS solution. When you are reading a question, pay great attention to these clues. If your solution does not involve all of the clue provided, you might not get the optimal solution. This is not any random question, it\\'s asked by Facebook, Google, etc., for multiple times. There is a reason why it exist and please don\\'t downvote it without even attempting to understand it."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@olsonpm](/olsonpm) I guess criticism of premature optimization originally intended to direct programmer\\'s effort into the best way of optimizing code. But now it\\'s most often used as an argument against any optimization."
                    },
                    {
                        "username": "olsonpm",
                        "content": "Questions like this that don\\'t enforce the optimal solution are a poor way to test devs.  In the real world, investing time into an unnecessary optimization is called premature optimization, and is a poor use of time as well as over-complicates the code."
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Mate, your tip is the best discussion section post template i always want to see :)"
                    },
                    {
                        "username": "sergei99",
                        "content": "Thanks mate. I had initially though that there was a mistake in the task description, but after your comment just sat down and wrote a few example lists of numbers. And then it took just a dozen lines of C++ code, including all the edge cases, to get 0ms execution time with 100% users beaten. :-)"
                    },
                    {
                        "username": "vaibhavbhatt59",
                        "content": "thanks bro i am going for see the solution  but bymistake i open discussion and see your comment on top . then i give another try to the question  and i did it . thanks bro\\n"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "i was getting frustrated and was going to look out for solutions but this comment pushed me and it clicked after few more minutes .... great question btw\\n"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "why u shudn\\'t skip questions with large no of downvotes without reading yourself"
                    },
                    {
                        "username": "madhavmaheshwarimm20",
                        "content": "[@armashhashmi](/armashhashmi) in constraints last point"
                    },
                    {
                        "username": "pyush98",
                        "content": "[@armashhashmi](/armashhashmi) \\n\\nnums[i] != nums[i + 1] for all valid i\\n\\nwrittein at bottom in smallest possible text XD"
                    },
                    {
                        "username": "armashhashmi",
                        "content": "where is it written in the question that \"No adjacent two numbers are same\" ?\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "after reading this (all before the 3 clues) I went and solved it in log(n) time, thanks for motivating me for doing so."
                    },
                    {
                        "username": "sohamdixit",
                        "content": "Agreed, but also for such questions where there is a trivial solution, I think the testcases need to be strong enough to not accept the trivial solution. In this case an O(n) solution should give a TLE, but it gets accepted, giving a misleading and false sense of having solved the problem in the best possible time to many people."
                    },
                    {
                        "username": "lavishmalik",
                        "content": "In both the questions you have to find peak elements but the catch is:\\n\\n-In leetcode 852 the array is increasingly and decreasingly sorted i.e its a bitonic array so you can apply modified binary search and find the global peak easily.\\n\\n-In this question(162), the given array is not sorted so they have given that there will be many peak elements and you can find any peak using binary search and return it .\\nBut you can\\'t find global peak in this question  just by applying binary search like previous question(852) because array is unsorted therefore after finding mid you can\\'t decide which side to go  for finding global peak.\\n\\n//Pls upvote if you like my solution\\n"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "the same code works for this also\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "So, How we do this."
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "The question doesn\\'t say the array is sorted, how do we know to use binary search ?"
                    },
                    {
                        "username": "cheekubhai",
                        "content": "The indexes form a sorted array"
                    },
                    {
                        "username": "premranjn",
                        "content": "there is a concept called binary search on answer, the sole idea of binary search in not only about finding a target in a sorted array, but to half the sample space after each decision.\\nSo here :\\nint findPeakElement(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if((mid == nums.size()-1)||nums[mid]>nums[mid+1] && ((mid == 0) || nums[mid]>nums[mid-1]))\\n                return mid;\\n            else if(mid==0)\\n                start = mid+1;\\n            else if(mid == nums.size()-1)\\n                end = mid-1;\\n            else if(nums[mid-1] < nums[mid])\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        return -1;\\n    }\\nif you would notice I am removing the half of the sample space each time i find the mid, using certain parameters.\\nHope It Helps ;)"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "[@ahmad-saeed](/ahmad-saeed) Sorting is an O(NLogN) process which is worse than doing a plain old linear search. Besides, you are supposed to return the index of the peak in its original position so you shouldn\\'t mutate the array in any way."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@pstrait](/pstrait) then i can just sort it in O(log n) then return the last in o(1) which satisfies the requirement without searching!"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "because  they said to do in 0(log n)  which is time complexty of binary search"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "Who said binary search can only applied on sorted arrays ?"
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "[@ssy55ssy](/ssy55ssy) can you please tell why that will work "
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "when the element is larger than it\\'s former element but it\\'s smaller than it\\'s later element,then the peak must appear behind it"
                    },
                    {
                        "username": "deadbycoffee",
                        "content": "I think it was just helpful that there could be multiple peaks. And because of that, you\\'re able to have a better chance of moving the left and right borders of the search based on what\\'s higher, mid, mid - 1, or mid + 1. Eventually either finding a peak or not finding one."
                    },
                    {
                        "username": "Altum_pax",
                        "content": "[@pstrait](/pstrait) Exactly that\\'s the catch!"
                    },
                    {
                        "username": "pstrait",
                        "content": "The array isn\\'t sorted; if it was sorted, the answer would just be the last element."
                    },
                    {
                        "username": "heejincs",
                        "content": "We can do simple binary search that check [mid] point and [mid+1] point and take half which has higher value, i.e. take left half if nums[mid]>nums[mid+1].\\nIt is not easy to show or proof why this works. \\nThe simple proof is that we take part of numbers that boundary condition holds true.\\nThat is, we only take search range (l, r) if nums[l-1]<nums[l] and num[r]>num[r+1]. Note that initial search range (l,r) where l=0 and r=len(nums)-1 holds true. Then, each step we reduce the search range half making sure the boundary condition holds true. Note that the other half the condition does not hold true.\\nTherefore, when it finally is reduced to a single number, it is the local maximum since the boundary condition for a single number is same as the condition for local maximum.\\n\\n"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I dont\\' understand the advantage of doing a linear search from 2 directions - \\n\\nlike what if your array is almost sorted with the peak occurring somewhere far away from mids\\n\\nlike 1,2,7,11,9,15,16,......,10000\\n\\nsay if you try a binary search on this array, it gives you almost nothing"
                    },
                    {
                        "username": "juciy_eggplant",
                        "content": "We know that for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF. From these conditions, we can prove that there must exist such an i that is peak, nums[i] > nums[i-1] and nums[i] > nums[i+1]:\\nSuppose there is no  i such that nums[i] > nums[i-1] and nums[i] > nums[i+1], then there are two cases:\\n1. if nums[i] > nums[i-1], it implies nums[i] < nums[i+1] for all i. however, this contradicts nums[n] == -INF\\n2. if nums[i] > nums[i+1], it implies nums[i] < nums[i-1] for all i which contradicts nums[-1] == -INF\\nQED\\n\\nNow we know that there must exist a peak i, we can derive the algorithm\\n1. if nums[m] < nums[m+1], then we know the right half is also an array where for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF (or to be more precise any x such that x < nums[i_0] && x < nums[i_n-1] and we know there must exist a peak\\n2. if nums[m] > nums[m+1], same logic applies for the left half"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Oh ok! I get it now. The whole magic lies in the sentence \"an element is always considered to be strictly greater than a neighbor that is outside the array.\" \\nThanks for the great comment! "
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Thank you very much for explanation sir :) Best explanation :)"
                    },
                    {
                        "username": "brianSalk",
                        "content": "In the comments section I see a lot of people saying that they do not know how they could come up with the binary search solution on their own in a short amount of time like the time that is allowed during an interview.\\n\\nFirst of all, you should be familiar with binary search, for it is a very common algorithm that can be modified to solve many problems that involve searching.\\nSecond, the question says that your algorithm must run in O(logN), which means that linear scan is out of the question.\\nIf you ever have a problem that involves searching for some element in a list in O(logN) time, you are probably limited to some variation of binary search as your only choice.  \\n\\n"
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "exactly O(logN) implies binary search modification.\\n"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe problem should state that there is only one peak in the sequence. Otherwise logarithmic complexity is not possible.\\n\\nFor example:\\n[1,2,1,3,4,5,0] has two peaks: 2 and 5. In such case, the search is O(n)."
                    },
                    {
                        "username": "pstrait",
                        "content": "No because you can stop at the first peak."
                    },
                    {
                        "username": "zeddysoft",
                        "content": "Hello folks,\\n\\nCan anyone here enlighten me on the significance of a question that has more downvote than upvotes. more specifically, should this type of question be avoided?\\n"
                    },
                    {
                        "username": "chaudharyrittik_26",
                        "content": "i also have the same question, can you tell me if you\\'ve got the answer\\n\\n"
                    },
                    {
                        "username": "thebigjuicyd",
                        "content": "no idea what you are talking about"
                    },
                    {
                        "username": "Ricola",
                        "content": "I don't get why I got this error while I never used an array in my answer.\\n\\nI think they edited the question, because the beginning of the solution is \"public int findPeakElement(List nums) {\" and in the answers, I saw people using an array of int.\\n\\nI tried using an array it doesn't work either."
                    },
                    {
                        "username": "tourist44",
                        "content": "It should say that peak element is an elemet which is greater than or equals to its neighbours and not strictly greater than its neighbours.\\nThats when this outcome would be correct.\\n![image](https://assets.leetcode.com/users/images/3e017fa3-9f28-4ac9-87b7-e3b0da7817f1_1600229691.3791375.png)\\n"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "one reason the answer is not -1 is because in the constraint it's mentioned that nums[-1] =nums[n]=-infinity hence if an array contains single digit then we will return 0 as it's bigger than -infinity. maybe that's why it's saying wrong answer. \nyou can see as it's written here-\nIn other words, an element is always considered to be strictly greater than a neighbor that is outside the array. Hence the answer would be 2 and not -1.\n"
                    },
                    {
                        "username": "davidtn",
                        "content": "Your test case is bad input because 1 of the 3 constraints down at the bottom is that no adjacent elements equal each other."
                    }
                ]
            },
            {
                "id": 1566847,
                "content": [
                    {
                        "username": "amoicity",
                        "content": "When people see ths question, I think most people will immediately come up with the linear search solution, which is to examine each num and compare it with its two neighbours. No braniner, right? Then people are thinking why this kind of question would  appear in the question pool and why it\\'s even rated as Medium. Then they might go to the Solution tab and see someone writing up a big article explaining a better solution and probably think, why bother? That\\'s an overkill. \\n\\nThese types of questions are so undervalued by people. And these are the questions we should pay more attention to. I\\'m sure in a real question, the interviewer will not be satisfied by the linear solution. Why? Because the straightforward linear scan solution isn\\'t using all of the clues given in the question. These clues, including\\n1. No adjacent two numbers are the same\\n2. the two end of the arrays are -\\u221E\\n3. You can return any peak.\\n\\nare all the clues that we can base upon to get to the final BS solution. When you are reading a question, pay great attention to these clues. If your solution does not involve all of the clue provided, you might not get the optimal solution. This is not any random question, it\\'s asked by Facebook, Google, etc., for multiple times. There is a reason why it exist and please don\\'t downvote it without even attempting to understand it."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@olsonpm](/olsonpm) I guess criticism of premature optimization originally intended to direct programmer\\'s effort into the best way of optimizing code. But now it\\'s most often used as an argument against any optimization."
                    },
                    {
                        "username": "olsonpm",
                        "content": "Questions like this that don\\'t enforce the optimal solution are a poor way to test devs.  In the real world, investing time into an unnecessary optimization is called premature optimization, and is a poor use of time as well as over-complicates the code."
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Mate, your tip is the best discussion section post template i always want to see :)"
                    },
                    {
                        "username": "sergei99",
                        "content": "Thanks mate. I had initially though that there was a mistake in the task description, but after your comment just sat down and wrote a few example lists of numbers. And then it took just a dozen lines of C++ code, including all the edge cases, to get 0ms execution time with 100% users beaten. :-)"
                    },
                    {
                        "username": "vaibhavbhatt59",
                        "content": "thanks bro i am going for see the solution  but bymistake i open discussion and see your comment on top . then i give another try to the question  and i did it . thanks bro\\n"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "i was getting frustrated and was going to look out for solutions but this comment pushed me and it clicked after few more minutes .... great question btw\\n"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "why u shudn\\'t skip questions with large no of downvotes without reading yourself"
                    },
                    {
                        "username": "madhavmaheshwarimm20",
                        "content": "[@armashhashmi](/armashhashmi) in constraints last point"
                    },
                    {
                        "username": "pyush98",
                        "content": "[@armashhashmi](/armashhashmi) \\n\\nnums[i] != nums[i + 1] for all valid i\\n\\nwrittein at bottom in smallest possible text XD"
                    },
                    {
                        "username": "armashhashmi",
                        "content": "where is it written in the question that \"No adjacent two numbers are same\" ?\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "after reading this (all before the 3 clues) I went and solved it in log(n) time, thanks for motivating me for doing so."
                    },
                    {
                        "username": "sohamdixit",
                        "content": "Agreed, but also for such questions where there is a trivial solution, I think the testcases need to be strong enough to not accept the trivial solution. In this case an O(n) solution should give a TLE, but it gets accepted, giving a misleading and false sense of having solved the problem in the best possible time to many people."
                    },
                    {
                        "username": "lavishmalik",
                        "content": "In both the questions you have to find peak elements but the catch is:\\n\\n-In leetcode 852 the array is increasingly and decreasingly sorted i.e its a bitonic array so you can apply modified binary search and find the global peak easily.\\n\\n-In this question(162), the given array is not sorted so they have given that there will be many peak elements and you can find any peak using binary search and return it .\\nBut you can\\'t find global peak in this question  just by applying binary search like previous question(852) because array is unsorted therefore after finding mid you can\\'t decide which side to go  for finding global peak.\\n\\n//Pls upvote if you like my solution\\n"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "the same code works for this also\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "So, How we do this."
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "The question doesn\\'t say the array is sorted, how do we know to use binary search ?"
                    },
                    {
                        "username": "cheekubhai",
                        "content": "The indexes form a sorted array"
                    },
                    {
                        "username": "premranjn",
                        "content": "there is a concept called binary search on answer, the sole idea of binary search in not only about finding a target in a sorted array, but to half the sample space after each decision.\\nSo here :\\nint findPeakElement(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if((mid == nums.size()-1)||nums[mid]>nums[mid+1] && ((mid == 0) || nums[mid]>nums[mid-1]))\\n                return mid;\\n            else if(mid==0)\\n                start = mid+1;\\n            else if(mid == nums.size()-1)\\n                end = mid-1;\\n            else if(nums[mid-1] < nums[mid])\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        return -1;\\n    }\\nif you would notice I am removing the half of the sample space each time i find the mid, using certain parameters.\\nHope It Helps ;)"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "[@ahmad-saeed](/ahmad-saeed) Sorting is an O(NLogN) process which is worse than doing a plain old linear search. Besides, you are supposed to return the index of the peak in its original position so you shouldn\\'t mutate the array in any way."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@pstrait](/pstrait) then i can just sort it in O(log n) then return the last in o(1) which satisfies the requirement without searching!"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "because  they said to do in 0(log n)  which is time complexty of binary search"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "Who said binary search can only applied on sorted arrays ?"
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "[@ssy55ssy](/ssy55ssy) can you please tell why that will work "
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "when the element is larger than it\\'s former element but it\\'s smaller than it\\'s later element,then the peak must appear behind it"
                    },
                    {
                        "username": "deadbycoffee",
                        "content": "I think it was just helpful that there could be multiple peaks. And because of that, you\\'re able to have a better chance of moving the left and right borders of the search based on what\\'s higher, mid, mid - 1, or mid + 1. Eventually either finding a peak or not finding one."
                    },
                    {
                        "username": "Altum_pax",
                        "content": "[@pstrait](/pstrait) Exactly that\\'s the catch!"
                    },
                    {
                        "username": "pstrait",
                        "content": "The array isn\\'t sorted; if it was sorted, the answer would just be the last element."
                    },
                    {
                        "username": "heejincs",
                        "content": "We can do simple binary search that check [mid] point and [mid+1] point and take half which has higher value, i.e. take left half if nums[mid]>nums[mid+1].\\nIt is not easy to show or proof why this works. \\nThe simple proof is that we take part of numbers that boundary condition holds true.\\nThat is, we only take search range (l, r) if nums[l-1]<nums[l] and num[r]>num[r+1]. Note that initial search range (l,r) where l=0 and r=len(nums)-1 holds true. Then, each step we reduce the search range half making sure the boundary condition holds true. Note that the other half the condition does not hold true.\\nTherefore, when it finally is reduced to a single number, it is the local maximum since the boundary condition for a single number is same as the condition for local maximum.\\n\\n"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I dont\\' understand the advantage of doing a linear search from 2 directions - \\n\\nlike what if your array is almost sorted with the peak occurring somewhere far away from mids\\n\\nlike 1,2,7,11,9,15,16,......,10000\\n\\nsay if you try a binary search on this array, it gives you almost nothing"
                    },
                    {
                        "username": "juciy_eggplant",
                        "content": "We know that for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF. From these conditions, we can prove that there must exist such an i that is peak, nums[i] > nums[i-1] and nums[i] > nums[i+1]:\\nSuppose there is no  i such that nums[i] > nums[i-1] and nums[i] > nums[i+1], then there are two cases:\\n1. if nums[i] > nums[i-1], it implies nums[i] < nums[i+1] for all i. however, this contradicts nums[n] == -INF\\n2. if nums[i] > nums[i+1], it implies nums[i] < nums[i-1] for all i which contradicts nums[-1] == -INF\\nQED\\n\\nNow we know that there must exist a peak i, we can derive the algorithm\\n1. if nums[m] < nums[m+1], then we know the right half is also an array where for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF (or to be more precise any x such that x < nums[i_0] && x < nums[i_n-1] and we know there must exist a peak\\n2. if nums[m] > nums[m+1], same logic applies for the left half"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Oh ok! I get it now. The whole magic lies in the sentence \"an element is always considered to be strictly greater than a neighbor that is outside the array.\" \\nThanks for the great comment! "
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Thank you very much for explanation sir :) Best explanation :)"
                    },
                    {
                        "username": "brianSalk",
                        "content": "In the comments section I see a lot of people saying that they do not know how they could come up with the binary search solution on their own in a short amount of time like the time that is allowed during an interview.\\n\\nFirst of all, you should be familiar with binary search, for it is a very common algorithm that can be modified to solve many problems that involve searching.\\nSecond, the question says that your algorithm must run in O(logN), which means that linear scan is out of the question.\\nIf you ever have a problem that involves searching for some element in a list in O(logN) time, you are probably limited to some variation of binary search as your only choice.  \\n\\n"
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "exactly O(logN) implies binary search modification.\\n"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe problem should state that there is only one peak in the sequence. Otherwise logarithmic complexity is not possible.\\n\\nFor example:\\n[1,2,1,3,4,5,0] has two peaks: 2 and 5. In such case, the search is O(n)."
                    },
                    {
                        "username": "pstrait",
                        "content": "No because you can stop at the first peak."
                    },
                    {
                        "username": "zeddysoft",
                        "content": "Hello folks,\\n\\nCan anyone here enlighten me on the significance of a question that has more downvote than upvotes. more specifically, should this type of question be avoided?\\n"
                    },
                    {
                        "username": "chaudharyrittik_26",
                        "content": "i also have the same question, can you tell me if you\\'ve got the answer\\n\\n"
                    },
                    {
                        "username": "thebigjuicyd",
                        "content": "no idea what you are talking about"
                    },
                    {
                        "username": "Ricola",
                        "content": "I don't get why I got this error while I never used an array in my answer.\\n\\nI think they edited the question, because the beginning of the solution is \"public int findPeakElement(List nums) {\" and in the answers, I saw people using an array of int.\\n\\nI tried using an array it doesn't work either."
                    },
                    {
                        "username": "tourist44",
                        "content": "It should say that peak element is an elemet which is greater than or equals to its neighbours and not strictly greater than its neighbours.\\nThats when this outcome would be correct.\\n![image](https://assets.leetcode.com/users/images/3e017fa3-9f28-4ac9-87b7-e3b0da7817f1_1600229691.3791375.png)\\n"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "one reason the answer is not -1 is because in the constraint it's mentioned that nums[-1] =nums[n]=-infinity hence if an array contains single digit then we will return 0 as it's bigger than -infinity. maybe that's why it's saying wrong answer. \nyou can see as it's written here-\nIn other words, an element is always considered to be strictly greater than a neighbor that is outside the array. Hence the answer would be 2 and not -1.\n"
                    },
                    {
                        "username": "davidtn",
                        "content": "Your test case is bad input because 1 of the 3 constraints down at the bottom is that no adjacent elements equal each other."
                    }
                ]
            },
            {
                "id": 1565945,
                "content": [
                    {
                        "username": "amoicity",
                        "content": "When people see ths question, I think most people will immediately come up with the linear search solution, which is to examine each num and compare it with its two neighbours. No braniner, right? Then people are thinking why this kind of question would  appear in the question pool and why it\\'s even rated as Medium. Then they might go to the Solution tab and see someone writing up a big article explaining a better solution and probably think, why bother? That\\'s an overkill. \\n\\nThese types of questions are so undervalued by people. And these are the questions we should pay more attention to. I\\'m sure in a real question, the interviewer will not be satisfied by the linear solution. Why? Because the straightforward linear scan solution isn\\'t using all of the clues given in the question. These clues, including\\n1. No adjacent two numbers are the same\\n2. the two end of the arrays are -\\u221E\\n3. You can return any peak.\\n\\nare all the clues that we can base upon to get to the final BS solution. When you are reading a question, pay great attention to these clues. If your solution does not involve all of the clue provided, you might not get the optimal solution. This is not any random question, it\\'s asked by Facebook, Google, etc., for multiple times. There is a reason why it exist and please don\\'t downvote it without even attempting to understand it."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@olsonpm](/olsonpm) I guess criticism of premature optimization originally intended to direct programmer\\'s effort into the best way of optimizing code. But now it\\'s most often used as an argument against any optimization."
                    },
                    {
                        "username": "olsonpm",
                        "content": "Questions like this that don\\'t enforce the optimal solution are a poor way to test devs.  In the real world, investing time into an unnecessary optimization is called premature optimization, and is a poor use of time as well as over-complicates the code."
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Mate, your tip is the best discussion section post template i always want to see :)"
                    },
                    {
                        "username": "sergei99",
                        "content": "Thanks mate. I had initially though that there was a mistake in the task description, but after your comment just sat down and wrote a few example lists of numbers. And then it took just a dozen lines of C++ code, including all the edge cases, to get 0ms execution time with 100% users beaten. :-)"
                    },
                    {
                        "username": "vaibhavbhatt59",
                        "content": "thanks bro i am going for see the solution  but bymistake i open discussion and see your comment on top . then i give another try to the question  and i did it . thanks bro\\n"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "i was getting frustrated and was going to look out for solutions but this comment pushed me and it clicked after few more minutes .... great question btw\\n"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "why u shudn\\'t skip questions with large no of downvotes without reading yourself"
                    },
                    {
                        "username": "madhavmaheshwarimm20",
                        "content": "[@armashhashmi](/armashhashmi) in constraints last point"
                    },
                    {
                        "username": "pyush98",
                        "content": "[@armashhashmi](/armashhashmi) \\n\\nnums[i] != nums[i + 1] for all valid i\\n\\nwrittein at bottom in smallest possible text XD"
                    },
                    {
                        "username": "armashhashmi",
                        "content": "where is it written in the question that \"No adjacent two numbers are same\" ?\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "after reading this (all before the 3 clues) I went and solved it in log(n) time, thanks for motivating me for doing so."
                    },
                    {
                        "username": "sohamdixit",
                        "content": "Agreed, but also for such questions where there is a trivial solution, I think the testcases need to be strong enough to not accept the trivial solution. In this case an O(n) solution should give a TLE, but it gets accepted, giving a misleading and false sense of having solved the problem in the best possible time to many people."
                    },
                    {
                        "username": "lavishmalik",
                        "content": "In both the questions you have to find peak elements but the catch is:\\n\\n-In leetcode 852 the array is increasingly and decreasingly sorted i.e its a bitonic array so you can apply modified binary search and find the global peak easily.\\n\\n-In this question(162), the given array is not sorted so they have given that there will be many peak elements and you can find any peak using binary search and return it .\\nBut you can\\'t find global peak in this question  just by applying binary search like previous question(852) because array is unsorted therefore after finding mid you can\\'t decide which side to go  for finding global peak.\\n\\n//Pls upvote if you like my solution\\n"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "the same code works for this also\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "So, How we do this."
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "The question doesn\\'t say the array is sorted, how do we know to use binary search ?"
                    },
                    {
                        "username": "cheekubhai",
                        "content": "The indexes form a sorted array"
                    },
                    {
                        "username": "premranjn",
                        "content": "there is a concept called binary search on answer, the sole idea of binary search in not only about finding a target in a sorted array, but to half the sample space after each decision.\\nSo here :\\nint findPeakElement(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if((mid == nums.size()-1)||nums[mid]>nums[mid+1] && ((mid == 0) || nums[mid]>nums[mid-1]))\\n                return mid;\\n            else if(mid==0)\\n                start = mid+1;\\n            else if(mid == nums.size()-1)\\n                end = mid-1;\\n            else if(nums[mid-1] < nums[mid])\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        return -1;\\n    }\\nif you would notice I am removing the half of the sample space each time i find the mid, using certain parameters.\\nHope It Helps ;)"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "[@ahmad-saeed](/ahmad-saeed) Sorting is an O(NLogN) process which is worse than doing a plain old linear search. Besides, you are supposed to return the index of the peak in its original position so you shouldn\\'t mutate the array in any way."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@pstrait](/pstrait) then i can just sort it in O(log n) then return the last in o(1) which satisfies the requirement without searching!"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "because  they said to do in 0(log n)  which is time complexty of binary search"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "Who said binary search can only applied on sorted arrays ?"
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "[@ssy55ssy](/ssy55ssy) can you please tell why that will work "
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "when the element is larger than it\\'s former element but it\\'s smaller than it\\'s later element,then the peak must appear behind it"
                    },
                    {
                        "username": "deadbycoffee",
                        "content": "I think it was just helpful that there could be multiple peaks. And because of that, you\\'re able to have a better chance of moving the left and right borders of the search based on what\\'s higher, mid, mid - 1, or mid + 1. Eventually either finding a peak or not finding one."
                    },
                    {
                        "username": "Altum_pax",
                        "content": "[@pstrait](/pstrait) Exactly that\\'s the catch!"
                    },
                    {
                        "username": "pstrait",
                        "content": "The array isn\\'t sorted; if it was sorted, the answer would just be the last element."
                    },
                    {
                        "username": "heejincs",
                        "content": "We can do simple binary search that check [mid] point and [mid+1] point and take half which has higher value, i.e. take left half if nums[mid]>nums[mid+1].\\nIt is not easy to show or proof why this works. \\nThe simple proof is that we take part of numbers that boundary condition holds true.\\nThat is, we only take search range (l, r) if nums[l-1]<nums[l] and num[r]>num[r+1]. Note that initial search range (l,r) where l=0 and r=len(nums)-1 holds true. Then, each step we reduce the search range half making sure the boundary condition holds true. Note that the other half the condition does not hold true.\\nTherefore, when it finally is reduced to a single number, it is the local maximum since the boundary condition for a single number is same as the condition for local maximum.\\n\\n"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I dont\\' understand the advantage of doing a linear search from 2 directions - \\n\\nlike what if your array is almost sorted with the peak occurring somewhere far away from mids\\n\\nlike 1,2,7,11,9,15,16,......,10000\\n\\nsay if you try a binary search on this array, it gives you almost nothing"
                    },
                    {
                        "username": "juciy_eggplant",
                        "content": "We know that for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF. From these conditions, we can prove that there must exist such an i that is peak, nums[i] > nums[i-1] and nums[i] > nums[i+1]:\\nSuppose there is no  i such that nums[i] > nums[i-1] and nums[i] > nums[i+1], then there are two cases:\\n1. if nums[i] > nums[i-1], it implies nums[i] < nums[i+1] for all i. however, this contradicts nums[n] == -INF\\n2. if nums[i] > nums[i+1], it implies nums[i] < nums[i-1] for all i which contradicts nums[-1] == -INF\\nQED\\n\\nNow we know that there must exist a peak i, we can derive the algorithm\\n1. if nums[m] < nums[m+1], then we know the right half is also an array where for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF (or to be more precise any x such that x < nums[i_0] && x < nums[i_n-1] and we know there must exist a peak\\n2. if nums[m] > nums[m+1], same logic applies for the left half"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Oh ok! I get it now. The whole magic lies in the sentence \"an element is always considered to be strictly greater than a neighbor that is outside the array.\" \\nThanks for the great comment! "
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Thank you very much for explanation sir :) Best explanation :)"
                    },
                    {
                        "username": "brianSalk",
                        "content": "In the comments section I see a lot of people saying that they do not know how they could come up with the binary search solution on their own in a short amount of time like the time that is allowed during an interview.\\n\\nFirst of all, you should be familiar with binary search, for it is a very common algorithm that can be modified to solve many problems that involve searching.\\nSecond, the question says that your algorithm must run in O(logN), which means that linear scan is out of the question.\\nIf you ever have a problem that involves searching for some element in a list in O(logN) time, you are probably limited to some variation of binary search as your only choice.  \\n\\n"
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "exactly O(logN) implies binary search modification.\\n"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe problem should state that there is only one peak in the sequence. Otherwise logarithmic complexity is not possible.\\n\\nFor example:\\n[1,2,1,3,4,5,0] has two peaks: 2 and 5. In such case, the search is O(n)."
                    },
                    {
                        "username": "pstrait",
                        "content": "No because you can stop at the first peak."
                    },
                    {
                        "username": "zeddysoft",
                        "content": "Hello folks,\\n\\nCan anyone here enlighten me on the significance of a question that has more downvote than upvotes. more specifically, should this type of question be avoided?\\n"
                    },
                    {
                        "username": "chaudharyrittik_26",
                        "content": "i also have the same question, can you tell me if you\\'ve got the answer\\n\\n"
                    },
                    {
                        "username": "thebigjuicyd",
                        "content": "no idea what you are talking about"
                    },
                    {
                        "username": "Ricola",
                        "content": "I don't get why I got this error while I never used an array in my answer.\\n\\nI think they edited the question, because the beginning of the solution is \"public int findPeakElement(List nums) {\" and in the answers, I saw people using an array of int.\\n\\nI tried using an array it doesn't work either."
                    },
                    {
                        "username": "tourist44",
                        "content": "It should say that peak element is an elemet which is greater than or equals to its neighbours and not strictly greater than its neighbours.\\nThats when this outcome would be correct.\\n![image](https://assets.leetcode.com/users/images/3e017fa3-9f28-4ac9-87b7-e3b0da7817f1_1600229691.3791375.png)\\n"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "one reason the answer is not -1 is because in the constraint it's mentioned that nums[-1] =nums[n]=-infinity hence if an array contains single digit then we will return 0 as it's bigger than -infinity. maybe that's why it's saying wrong answer. \nyou can see as it's written here-\nIn other words, an element is always considered to be strictly greater than a neighbor that is outside the array. Hence the answer would be 2 and not -1.\n"
                    },
                    {
                        "username": "davidtn",
                        "content": "Your test case is bad input because 1 of the 3 constraints down at the bottom is that no adjacent elements equal each other."
                    }
                ]
            },
            {
                "id": 1570166,
                "content": [
                    {
                        "username": "amoicity",
                        "content": "When people see ths question, I think most people will immediately come up with the linear search solution, which is to examine each num and compare it with its two neighbours. No braniner, right? Then people are thinking why this kind of question would  appear in the question pool and why it\\'s even rated as Medium. Then they might go to the Solution tab and see someone writing up a big article explaining a better solution and probably think, why bother? That\\'s an overkill. \\n\\nThese types of questions are so undervalued by people. And these are the questions we should pay more attention to. I\\'m sure in a real question, the interviewer will not be satisfied by the linear solution. Why? Because the straightforward linear scan solution isn\\'t using all of the clues given in the question. These clues, including\\n1. No adjacent two numbers are the same\\n2. the two end of the arrays are -\\u221E\\n3. You can return any peak.\\n\\nare all the clues that we can base upon to get to the final BS solution. When you are reading a question, pay great attention to these clues. If your solution does not involve all of the clue provided, you might not get the optimal solution. This is not any random question, it\\'s asked by Facebook, Google, etc., for multiple times. There is a reason why it exist and please don\\'t downvote it without even attempting to understand it."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@olsonpm](/olsonpm) I guess criticism of premature optimization originally intended to direct programmer\\'s effort into the best way of optimizing code. But now it\\'s most often used as an argument against any optimization."
                    },
                    {
                        "username": "olsonpm",
                        "content": "Questions like this that don\\'t enforce the optimal solution are a poor way to test devs.  In the real world, investing time into an unnecessary optimization is called premature optimization, and is a poor use of time as well as over-complicates the code."
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Mate, your tip is the best discussion section post template i always want to see :)"
                    },
                    {
                        "username": "sergei99",
                        "content": "Thanks mate. I had initially though that there was a mistake in the task description, but after your comment just sat down and wrote a few example lists of numbers. And then it took just a dozen lines of C++ code, including all the edge cases, to get 0ms execution time with 100% users beaten. :-)"
                    },
                    {
                        "username": "vaibhavbhatt59",
                        "content": "thanks bro i am going for see the solution  but bymistake i open discussion and see your comment on top . then i give another try to the question  and i did it . thanks bro\\n"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "i was getting frustrated and was going to look out for solutions but this comment pushed me and it clicked after few more minutes .... great question btw\\n"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "why u shudn\\'t skip questions with large no of downvotes without reading yourself"
                    },
                    {
                        "username": "madhavmaheshwarimm20",
                        "content": "[@armashhashmi](/armashhashmi) in constraints last point"
                    },
                    {
                        "username": "pyush98",
                        "content": "[@armashhashmi](/armashhashmi) \\n\\nnums[i] != nums[i + 1] for all valid i\\n\\nwrittein at bottom in smallest possible text XD"
                    },
                    {
                        "username": "armashhashmi",
                        "content": "where is it written in the question that \"No adjacent two numbers are same\" ?\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "after reading this (all before the 3 clues) I went and solved it in log(n) time, thanks for motivating me for doing so."
                    },
                    {
                        "username": "sohamdixit",
                        "content": "Agreed, but also for such questions where there is a trivial solution, I think the testcases need to be strong enough to not accept the trivial solution. In this case an O(n) solution should give a TLE, but it gets accepted, giving a misleading and false sense of having solved the problem in the best possible time to many people."
                    },
                    {
                        "username": "lavishmalik",
                        "content": "In both the questions you have to find peak elements but the catch is:\\n\\n-In leetcode 852 the array is increasingly and decreasingly sorted i.e its a bitonic array so you can apply modified binary search and find the global peak easily.\\n\\n-In this question(162), the given array is not sorted so they have given that there will be many peak elements and you can find any peak using binary search and return it .\\nBut you can\\'t find global peak in this question  just by applying binary search like previous question(852) because array is unsorted therefore after finding mid you can\\'t decide which side to go  for finding global peak.\\n\\n//Pls upvote if you like my solution\\n"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "the same code works for this also\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "So, How we do this."
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "The question doesn\\'t say the array is sorted, how do we know to use binary search ?"
                    },
                    {
                        "username": "cheekubhai",
                        "content": "The indexes form a sorted array"
                    },
                    {
                        "username": "premranjn",
                        "content": "there is a concept called binary search on answer, the sole idea of binary search in not only about finding a target in a sorted array, but to half the sample space after each decision.\\nSo here :\\nint findPeakElement(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if((mid == nums.size()-1)||nums[mid]>nums[mid+1] && ((mid == 0) || nums[mid]>nums[mid-1]))\\n                return mid;\\n            else if(mid==0)\\n                start = mid+1;\\n            else if(mid == nums.size()-1)\\n                end = mid-1;\\n            else if(nums[mid-1] < nums[mid])\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        return -1;\\n    }\\nif you would notice I am removing the half of the sample space each time i find the mid, using certain parameters.\\nHope It Helps ;)"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "[@ahmad-saeed](/ahmad-saeed) Sorting is an O(NLogN) process which is worse than doing a plain old linear search. Besides, you are supposed to return the index of the peak in its original position so you shouldn\\'t mutate the array in any way."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@pstrait](/pstrait) then i can just sort it in O(log n) then return the last in o(1) which satisfies the requirement without searching!"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "because  they said to do in 0(log n)  which is time complexty of binary search"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "Who said binary search can only applied on sorted arrays ?"
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "[@ssy55ssy](/ssy55ssy) can you please tell why that will work "
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "when the element is larger than it\\'s former element but it\\'s smaller than it\\'s later element,then the peak must appear behind it"
                    },
                    {
                        "username": "deadbycoffee",
                        "content": "I think it was just helpful that there could be multiple peaks. And because of that, you\\'re able to have a better chance of moving the left and right borders of the search based on what\\'s higher, mid, mid - 1, or mid + 1. Eventually either finding a peak or not finding one."
                    },
                    {
                        "username": "Altum_pax",
                        "content": "[@pstrait](/pstrait) Exactly that\\'s the catch!"
                    },
                    {
                        "username": "pstrait",
                        "content": "The array isn\\'t sorted; if it was sorted, the answer would just be the last element."
                    },
                    {
                        "username": "heejincs",
                        "content": "We can do simple binary search that check [mid] point and [mid+1] point and take half which has higher value, i.e. take left half if nums[mid]>nums[mid+1].\\nIt is not easy to show or proof why this works. \\nThe simple proof is that we take part of numbers that boundary condition holds true.\\nThat is, we only take search range (l, r) if nums[l-1]<nums[l] and num[r]>num[r+1]. Note that initial search range (l,r) where l=0 and r=len(nums)-1 holds true. Then, each step we reduce the search range half making sure the boundary condition holds true. Note that the other half the condition does not hold true.\\nTherefore, when it finally is reduced to a single number, it is the local maximum since the boundary condition for a single number is same as the condition for local maximum.\\n\\n"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I dont\\' understand the advantage of doing a linear search from 2 directions - \\n\\nlike what if your array is almost sorted with the peak occurring somewhere far away from mids\\n\\nlike 1,2,7,11,9,15,16,......,10000\\n\\nsay if you try a binary search on this array, it gives you almost nothing"
                    },
                    {
                        "username": "juciy_eggplant",
                        "content": "We know that for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF. From these conditions, we can prove that there must exist such an i that is peak, nums[i] > nums[i-1] and nums[i] > nums[i+1]:\\nSuppose there is no  i such that nums[i] > nums[i-1] and nums[i] > nums[i+1], then there are two cases:\\n1. if nums[i] > nums[i-1], it implies nums[i] < nums[i+1] for all i. however, this contradicts nums[n] == -INF\\n2. if nums[i] > nums[i+1], it implies nums[i] < nums[i-1] for all i which contradicts nums[-1] == -INF\\nQED\\n\\nNow we know that there must exist a peak i, we can derive the algorithm\\n1. if nums[m] < nums[m+1], then we know the right half is also an array where for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF (or to be more precise any x such that x < nums[i_0] && x < nums[i_n-1] and we know there must exist a peak\\n2. if nums[m] > nums[m+1], same logic applies for the left half"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Oh ok! I get it now. The whole magic lies in the sentence \"an element is always considered to be strictly greater than a neighbor that is outside the array.\" \\nThanks for the great comment! "
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Thank you very much for explanation sir :) Best explanation :)"
                    },
                    {
                        "username": "brianSalk",
                        "content": "In the comments section I see a lot of people saying that they do not know how they could come up with the binary search solution on their own in a short amount of time like the time that is allowed during an interview.\\n\\nFirst of all, you should be familiar with binary search, for it is a very common algorithm that can be modified to solve many problems that involve searching.\\nSecond, the question says that your algorithm must run in O(logN), which means that linear scan is out of the question.\\nIf you ever have a problem that involves searching for some element in a list in O(logN) time, you are probably limited to some variation of binary search as your only choice.  \\n\\n"
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "exactly O(logN) implies binary search modification.\\n"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe problem should state that there is only one peak in the sequence. Otherwise logarithmic complexity is not possible.\\n\\nFor example:\\n[1,2,1,3,4,5,0] has two peaks: 2 and 5. In such case, the search is O(n)."
                    },
                    {
                        "username": "pstrait",
                        "content": "No because you can stop at the first peak."
                    },
                    {
                        "username": "zeddysoft",
                        "content": "Hello folks,\\n\\nCan anyone here enlighten me on the significance of a question that has more downvote than upvotes. more specifically, should this type of question be avoided?\\n"
                    },
                    {
                        "username": "chaudharyrittik_26",
                        "content": "i also have the same question, can you tell me if you\\'ve got the answer\\n\\n"
                    },
                    {
                        "username": "thebigjuicyd",
                        "content": "no idea what you are talking about"
                    },
                    {
                        "username": "Ricola",
                        "content": "I don't get why I got this error while I never used an array in my answer.\\n\\nI think they edited the question, because the beginning of the solution is \"public int findPeakElement(List nums) {\" and in the answers, I saw people using an array of int.\\n\\nI tried using an array it doesn't work either."
                    },
                    {
                        "username": "tourist44",
                        "content": "It should say that peak element is an elemet which is greater than or equals to its neighbours and not strictly greater than its neighbours.\\nThats when this outcome would be correct.\\n![image](https://assets.leetcode.com/users/images/3e017fa3-9f28-4ac9-87b7-e3b0da7817f1_1600229691.3791375.png)\\n"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "one reason the answer is not -1 is because in the constraint it's mentioned that nums[-1] =nums[n]=-infinity hence if an array contains single digit then we will return 0 as it's bigger than -infinity. maybe that's why it's saying wrong answer. \nyou can see as it's written here-\nIn other words, an element is always considered to be strictly greater than a neighbor that is outside the array. Hence the answer would be 2 and not -1.\n"
                    },
                    {
                        "username": "davidtn",
                        "content": "Your test case is bad input because 1 of the 3 constraints down at the bottom is that no adjacent elements equal each other."
                    }
                ]
            },
            {
                "id": 1564746,
                "content": [
                    {
                        "username": "amoicity",
                        "content": "When people see ths question, I think most people will immediately come up with the linear search solution, which is to examine each num and compare it with its two neighbours. No braniner, right? Then people are thinking why this kind of question would  appear in the question pool and why it\\'s even rated as Medium. Then they might go to the Solution tab and see someone writing up a big article explaining a better solution and probably think, why bother? That\\'s an overkill. \\n\\nThese types of questions are so undervalued by people. And these are the questions we should pay more attention to. I\\'m sure in a real question, the interviewer will not be satisfied by the linear solution. Why? Because the straightforward linear scan solution isn\\'t using all of the clues given in the question. These clues, including\\n1. No adjacent two numbers are the same\\n2. the two end of the arrays are -\\u221E\\n3. You can return any peak.\\n\\nare all the clues that we can base upon to get to the final BS solution. When you are reading a question, pay great attention to these clues. If your solution does not involve all of the clue provided, you might not get the optimal solution. This is not any random question, it\\'s asked by Facebook, Google, etc., for multiple times. There is a reason why it exist and please don\\'t downvote it without even attempting to understand it."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@olsonpm](/olsonpm) I guess criticism of premature optimization originally intended to direct programmer\\'s effort into the best way of optimizing code. But now it\\'s most often used as an argument against any optimization."
                    },
                    {
                        "username": "olsonpm",
                        "content": "Questions like this that don\\'t enforce the optimal solution are a poor way to test devs.  In the real world, investing time into an unnecessary optimization is called premature optimization, and is a poor use of time as well as over-complicates the code."
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Mate, your tip is the best discussion section post template i always want to see :)"
                    },
                    {
                        "username": "sergei99",
                        "content": "Thanks mate. I had initially though that there was a mistake in the task description, but after your comment just sat down and wrote a few example lists of numbers. And then it took just a dozen lines of C++ code, including all the edge cases, to get 0ms execution time with 100% users beaten. :-)"
                    },
                    {
                        "username": "vaibhavbhatt59",
                        "content": "thanks bro i am going for see the solution  but bymistake i open discussion and see your comment on top . then i give another try to the question  and i did it . thanks bro\\n"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "i was getting frustrated and was going to look out for solutions but this comment pushed me and it clicked after few more minutes .... great question btw\\n"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "why u shudn\\'t skip questions with large no of downvotes without reading yourself"
                    },
                    {
                        "username": "madhavmaheshwarimm20",
                        "content": "[@armashhashmi](/armashhashmi) in constraints last point"
                    },
                    {
                        "username": "pyush98",
                        "content": "[@armashhashmi](/armashhashmi) \\n\\nnums[i] != nums[i + 1] for all valid i\\n\\nwrittein at bottom in smallest possible text XD"
                    },
                    {
                        "username": "armashhashmi",
                        "content": "where is it written in the question that \"No adjacent two numbers are same\" ?\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "after reading this (all before the 3 clues) I went and solved it in log(n) time, thanks for motivating me for doing so."
                    },
                    {
                        "username": "sohamdixit",
                        "content": "Agreed, but also for such questions where there is a trivial solution, I think the testcases need to be strong enough to not accept the trivial solution. In this case an O(n) solution should give a TLE, but it gets accepted, giving a misleading and false sense of having solved the problem in the best possible time to many people."
                    },
                    {
                        "username": "lavishmalik",
                        "content": "In both the questions you have to find peak elements but the catch is:\\n\\n-In leetcode 852 the array is increasingly and decreasingly sorted i.e its a bitonic array so you can apply modified binary search and find the global peak easily.\\n\\n-In this question(162), the given array is not sorted so they have given that there will be many peak elements and you can find any peak using binary search and return it .\\nBut you can\\'t find global peak in this question  just by applying binary search like previous question(852) because array is unsorted therefore after finding mid you can\\'t decide which side to go  for finding global peak.\\n\\n//Pls upvote if you like my solution\\n"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "the same code works for this also\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "So, How we do this."
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "The question doesn\\'t say the array is sorted, how do we know to use binary search ?"
                    },
                    {
                        "username": "cheekubhai",
                        "content": "The indexes form a sorted array"
                    },
                    {
                        "username": "premranjn",
                        "content": "there is a concept called binary search on answer, the sole idea of binary search in not only about finding a target in a sorted array, but to half the sample space after each decision.\\nSo here :\\nint findPeakElement(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if((mid == nums.size()-1)||nums[mid]>nums[mid+1] && ((mid == 0) || nums[mid]>nums[mid-1]))\\n                return mid;\\n            else if(mid==0)\\n                start = mid+1;\\n            else if(mid == nums.size()-1)\\n                end = mid-1;\\n            else if(nums[mid-1] < nums[mid])\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        return -1;\\n    }\\nif you would notice I am removing the half of the sample space each time i find the mid, using certain parameters.\\nHope It Helps ;)"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "[@ahmad-saeed](/ahmad-saeed) Sorting is an O(NLogN) process which is worse than doing a plain old linear search. Besides, you are supposed to return the index of the peak in its original position so you shouldn\\'t mutate the array in any way."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@pstrait](/pstrait) then i can just sort it in O(log n) then return the last in o(1) which satisfies the requirement without searching!"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "because  they said to do in 0(log n)  which is time complexty of binary search"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "Who said binary search can only applied on sorted arrays ?"
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "[@ssy55ssy](/ssy55ssy) can you please tell why that will work "
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "when the element is larger than it\\'s former element but it\\'s smaller than it\\'s later element,then the peak must appear behind it"
                    },
                    {
                        "username": "deadbycoffee",
                        "content": "I think it was just helpful that there could be multiple peaks. And because of that, you\\'re able to have a better chance of moving the left and right borders of the search based on what\\'s higher, mid, mid - 1, or mid + 1. Eventually either finding a peak or not finding one."
                    },
                    {
                        "username": "Altum_pax",
                        "content": "[@pstrait](/pstrait) Exactly that\\'s the catch!"
                    },
                    {
                        "username": "pstrait",
                        "content": "The array isn\\'t sorted; if it was sorted, the answer would just be the last element."
                    },
                    {
                        "username": "heejincs",
                        "content": "We can do simple binary search that check [mid] point and [mid+1] point and take half which has higher value, i.e. take left half if nums[mid]>nums[mid+1].\\nIt is not easy to show or proof why this works. \\nThe simple proof is that we take part of numbers that boundary condition holds true.\\nThat is, we only take search range (l, r) if nums[l-1]<nums[l] and num[r]>num[r+1]. Note that initial search range (l,r) where l=0 and r=len(nums)-1 holds true. Then, each step we reduce the search range half making sure the boundary condition holds true. Note that the other half the condition does not hold true.\\nTherefore, when it finally is reduced to a single number, it is the local maximum since the boundary condition for a single number is same as the condition for local maximum.\\n\\n"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I dont\\' understand the advantage of doing a linear search from 2 directions - \\n\\nlike what if your array is almost sorted with the peak occurring somewhere far away from mids\\n\\nlike 1,2,7,11,9,15,16,......,10000\\n\\nsay if you try a binary search on this array, it gives you almost nothing"
                    },
                    {
                        "username": "juciy_eggplant",
                        "content": "We know that for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF. From these conditions, we can prove that there must exist such an i that is peak, nums[i] > nums[i-1] and nums[i] > nums[i+1]:\\nSuppose there is no  i such that nums[i] > nums[i-1] and nums[i] > nums[i+1], then there are two cases:\\n1. if nums[i] > nums[i-1], it implies nums[i] < nums[i+1] for all i. however, this contradicts nums[n] == -INF\\n2. if nums[i] > nums[i+1], it implies nums[i] < nums[i-1] for all i which contradicts nums[-1] == -INF\\nQED\\n\\nNow we know that there must exist a peak i, we can derive the algorithm\\n1. if nums[m] < nums[m+1], then we know the right half is also an array where for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF (or to be more precise any x such that x < nums[i_0] && x < nums[i_n-1] and we know there must exist a peak\\n2. if nums[m] > nums[m+1], same logic applies for the left half"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Oh ok! I get it now. The whole magic lies in the sentence \"an element is always considered to be strictly greater than a neighbor that is outside the array.\" \\nThanks for the great comment! "
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Thank you very much for explanation sir :) Best explanation :)"
                    },
                    {
                        "username": "brianSalk",
                        "content": "In the comments section I see a lot of people saying that they do not know how they could come up with the binary search solution on their own in a short amount of time like the time that is allowed during an interview.\\n\\nFirst of all, you should be familiar with binary search, for it is a very common algorithm that can be modified to solve many problems that involve searching.\\nSecond, the question says that your algorithm must run in O(logN), which means that linear scan is out of the question.\\nIf you ever have a problem that involves searching for some element in a list in O(logN) time, you are probably limited to some variation of binary search as your only choice.  \\n\\n"
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "exactly O(logN) implies binary search modification.\\n"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe problem should state that there is only one peak in the sequence. Otherwise logarithmic complexity is not possible.\\n\\nFor example:\\n[1,2,1,3,4,5,0] has two peaks: 2 and 5. In such case, the search is O(n)."
                    },
                    {
                        "username": "pstrait",
                        "content": "No because you can stop at the first peak."
                    },
                    {
                        "username": "zeddysoft",
                        "content": "Hello folks,\\n\\nCan anyone here enlighten me on the significance of a question that has more downvote than upvotes. more specifically, should this type of question be avoided?\\n"
                    },
                    {
                        "username": "chaudharyrittik_26",
                        "content": "i also have the same question, can you tell me if you\\'ve got the answer\\n\\n"
                    },
                    {
                        "username": "thebigjuicyd",
                        "content": "no idea what you are talking about"
                    },
                    {
                        "username": "Ricola",
                        "content": "I don't get why I got this error while I never used an array in my answer.\\n\\nI think they edited the question, because the beginning of the solution is \"public int findPeakElement(List nums) {\" and in the answers, I saw people using an array of int.\\n\\nI tried using an array it doesn't work either."
                    },
                    {
                        "username": "tourist44",
                        "content": "It should say that peak element is an elemet which is greater than or equals to its neighbours and not strictly greater than its neighbours.\\nThats when this outcome would be correct.\\n![image](https://assets.leetcode.com/users/images/3e017fa3-9f28-4ac9-87b7-e3b0da7817f1_1600229691.3791375.png)\\n"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "one reason the answer is not -1 is because in the constraint it's mentioned that nums[-1] =nums[n]=-infinity hence if an array contains single digit then we will return 0 as it's bigger than -infinity. maybe that's why it's saying wrong answer. \nyou can see as it's written here-\nIn other words, an element is always considered to be strictly greater than a neighbor that is outside the array. Hence the answer would be 2 and not -1.\n"
                    },
                    {
                        "username": "davidtn",
                        "content": "Your test case is bad input because 1 of the 3 constraints down at the bottom is that no adjacent elements equal each other."
                    }
                ]
            },
            {
                "id": 1567741,
                "content": [
                    {
                        "username": "amoicity",
                        "content": "When people see ths question, I think most people will immediately come up with the linear search solution, which is to examine each num and compare it with its two neighbours. No braniner, right? Then people are thinking why this kind of question would  appear in the question pool and why it\\'s even rated as Medium. Then they might go to the Solution tab and see someone writing up a big article explaining a better solution and probably think, why bother? That\\'s an overkill. \\n\\nThese types of questions are so undervalued by people. And these are the questions we should pay more attention to. I\\'m sure in a real question, the interviewer will not be satisfied by the linear solution. Why? Because the straightforward linear scan solution isn\\'t using all of the clues given in the question. These clues, including\\n1. No adjacent two numbers are the same\\n2. the two end of the arrays are -\\u221E\\n3. You can return any peak.\\n\\nare all the clues that we can base upon to get to the final BS solution. When you are reading a question, pay great attention to these clues. If your solution does not involve all of the clue provided, you might not get the optimal solution. This is not any random question, it\\'s asked by Facebook, Google, etc., for multiple times. There is a reason why it exist and please don\\'t downvote it without even attempting to understand it."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@olsonpm](/olsonpm) I guess criticism of premature optimization originally intended to direct programmer\\'s effort into the best way of optimizing code. But now it\\'s most often used as an argument against any optimization."
                    },
                    {
                        "username": "olsonpm",
                        "content": "Questions like this that don\\'t enforce the optimal solution are a poor way to test devs.  In the real world, investing time into an unnecessary optimization is called premature optimization, and is a poor use of time as well as over-complicates the code."
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Mate, your tip is the best discussion section post template i always want to see :)"
                    },
                    {
                        "username": "sergei99",
                        "content": "Thanks mate. I had initially though that there was a mistake in the task description, but after your comment just sat down and wrote a few example lists of numbers. And then it took just a dozen lines of C++ code, including all the edge cases, to get 0ms execution time with 100% users beaten. :-)"
                    },
                    {
                        "username": "vaibhavbhatt59",
                        "content": "thanks bro i am going for see the solution  but bymistake i open discussion and see your comment on top . then i give another try to the question  and i did it . thanks bro\\n"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "i was getting frustrated and was going to look out for solutions but this comment pushed me and it clicked after few more minutes .... great question btw\\n"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "why u shudn\\'t skip questions with large no of downvotes without reading yourself"
                    },
                    {
                        "username": "madhavmaheshwarimm20",
                        "content": "[@armashhashmi](/armashhashmi) in constraints last point"
                    },
                    {
                        "username": "pyush98",
                        "content": "[@armashhashmi](/armashhashmi) \\n\\nnums[i] != nums[i + 1] for all valid i\\n\\nwrittein at bottom in smallest possible text XD"
                    },
                    {
                        "username": "armashhashmi",
                        "content": "where is it written in the question that \"No adjacent two numbers are same\" ?\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "after reading this (all before the 3 clues) I went and solved it in log(n) time, thanks for motivating me for doing so."
                    },
                    {
                        "username": "sohamdixit",
                        "content": "Agreed, but also for such questions where there is a trivial solution, I think the testcases need to be strong enough to not accept the trivial solution. In this case an O(n) solution should give a TLE, but it gets accepted, giving a misleading and false sense of having solved the problem in the best possible time to many people."
                    },
                    {
                        "username": "lavishmalik",
                        "content": "In both the questions you have to find peak elements but the catch is:\\n\\n-In leetcode 852 the array is increasingly and decreasingly sorted i.e its a bitonic array so you can apply modified binary search and find the global peak easily.\\n\\n-In this question(162), the given array is not sorted so they have given that there will be many peak elements and you can find any peak using binary search and return it .\\nBut you can\\'t find global peak in this question  just by applying binary search like previous question(852) because array is unsorted therefore after finding mid you can\\'t decide which side to go  for finding global peak.\\n\\n//Pls upvote if you like my solution\\n"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "the same code works for this also\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "So, How we do this."
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "The question doesn\\'t say the array is sorted, how do we know to use binary search ?"
                    },
                    {
                        "username": "cheekubhai",
                        "content": "The indexes form a sorted array"
                    },
                    {
                        "username": "premranjn",
                        "content": "there is a concept called binary search on answer, the sole idea of binary search in not only about finding a target in a sorted array, but to half the sample space after each decision.\\nSo here :\\nint findPeakElement(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if((mid == nums.size()-1)||nums[mid]>nums[mid+1] && ((mid == 0) || nums[mid]>nums[mid-1]))\\n                return mid;\\n            else if(mid==0)\\n                start = mid+1;\\n            else if(mid == nums.size()-1)\\n                end = mid-1;\\n            else if(nums[mid-1] < nums[mid])\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        return -1;\\n    }\\nif you would notice I am removing the half of the sample space each time i find the mid, using certain parameters.\\nHope It Helps ;)"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "[@ahmad-saeed](/ahmad-saeed) Sorting is an O(NLogN) process which is worse than doing a plain old linear search. Besides, you are supposed to return the index of the peak in its original position so you shouldn\\'t mutate the array in any way."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@pstrait](/pstrait) then i can just sort it in O(log n) then return the last in o(1) which satisfies the requirement without searching!"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "because  they said to do in 0(log n)  which is time complexty of binary search"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "Who said binary search can only applied on sorted arrays ?"
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "[@ssy55ssy](/ssy55ssy) can you please tell why that will work "
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "when the element is larger than it\\'s former element but it\\'s smaller than it\\'s later element,then the peak must appear behind it"
                    },
                    {
                        "username": "deadbycoffee",
                        "content": "I think it was just helpful that there could be multiple peaks. And because of that, you\\'re able to have a better chance of moving the left and right borders of the search based on what\\'s higher, mid, mid - 1, or mid + 1. Eventually either finding a peak or not finding one."
                    },
                    {
                        "username": "Altum_pax",
                        "content": "[@pstrait](/pstrait) Exactly that\\'s the catch!"
                    },
                    {
                        "username": "pstrait",
                        "content": "The array isn\\'t sorted; if it was sorted, the answer would just be the last element."
                    },
                    {
                        "username": "heejincs",
                        "content": "We can do simple binary search that check [mid] point and [mid+1] point and take half which has higher value, i.e. take left half if nums[mid]>nums[mid+1].\\nIt is not easy to show or proof why this works. \\nThe simple proof is that we take part of numbers that boundary condition holds true.\\nThat is, we only take search range (l, r) if nums[l-1]<nums[l] and num[r]>num[r+1]. Note that initial search range (l,r) where l=0 and r=len(nums)-1 holds true. Then, each step we reduce the search range half making sure the boundary condition holds true. Note that the other half the condition does not hold true.\\nTherefore, when it finally is reduced to a single number, it is the local maximum since the boundary condition for a single number is same as the condition for local maximum.\\n\\n"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I dont\\' understand the advantage of doing a linear search from 2 directions - \\n\\nlike what if your array is almost sorted with the peak occurring somewhere far away from mids\\n\\nlike 1,2,7,11,9,15,16,......,10000\\n\\nsay if you try a binary search on this array, it gives you almost nothing"
                    },
                    {
                        "username": "juciy_eggplant",
                        "content": "We know that for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF. From these conditions, we can prove that there must exist such an i that is peak, nums[i] > nums[i-1] and nums[i] > nums[i+1]:\\nSuppose there is no  i such that nums[i] > nums[i-1] and nums[i] > nums[i+1], then there are two cases:\\n1. if nums[i] > nums[i-1], it implies nums[i] < nums[i+1] for all i. however, this contradicts nums[n] == -INF\\n2. if nums[i] > nums[i+1], it implies nums[i] < nums[i-1] for all i which contradicts nums[-1] == -INF\\nQED\\n\\nNow we know that there must exist a peak i, we can derive the algorithm\\n1. if nums[m] < nums[m+1], then we know the right half is also an array where for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF (or to be more precise any x such that x < nums[i_0] && x < nums[i_n-1] and we know there must exist a peak\\n2. if nums[m] > nums[m+1], same logic applies for the left half"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Oh ok! I get it now. The whole magic lies in the sentence \"an element is always considered to be strictly greater than a neighbor that is outside the array.\" \\nThanks for the great comment! "
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Thank you very much for explanation sir :) Best explanation :)"
                    },
                    {
                        "username": "brianSalk",
                        "content": "In the comments section I see a lot of people saying that they do not know how they could come up with the binary search solution on their own in a short amount of time like the time that is allowed during an interview.\\n\\nFirst of all, you should be familiar with binary search, for it is a very common algorithm that can be modified to solve many problems that involve searching.\\nSecond, the question says that your algorithm must run in O(logN), which means that linear scan is out of the question.\\nIf you ever have a problem that involves searching for some element in a list in O(logN) time, you are probably limited to some variation of binary search as your only choice.  \\n\\n"
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "exactly O(logN) implies binary search modification.\\n"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe problem should state that there is only one peak in the sequence. Otherwise logarithmic complexity is not possible.\\n\\nFor example:\\n[1,2,1,3,4,5,0] has two peaks: 2 and 5. In such case, the search is O(n)."
                    },
                    {
                        "username": "pstrait",
                        "content": "No because you can stop at the first peak."
                    },
                    {
                        "username": "zeddysoft",
                        "content": "Hello folks,\\n\\nCan anyone here enlighten me on the significance of a question that has more downvote than upvotes. more specifically, should this type of question be avoided?\\n"
                    },
                    {
                        "username": "chaudharyrittik_26",
                        "content": "i also have the same question, can you tell me if you\\'ve got the answer\\n\\n"
                    },
                    {
                        "username": "thebigjuicyd",
                        "content": "no idea what you are talking about"
                    },
                    {
                        "username": "Ricola",
                        "content": "I don't get why I got this error while I never used an array in my answer.\\n\\nI think they edited the question, because the beginning of the solution is \"public int findPeakElement(List nums) {\" and in the answers, I saw people using an array of int.\\n\\nI tried using an array it doesn't work either."
                    },
                    {
                        "username": "tourist44",
                        "content": "It should say that peak element is an elemet which is greater than or equals to its neighbours and not strictly greater than its neighbours.\\nThats when this outcome would be correct.\\n![image](https://assets.leetcode.com/users/images/3e017fa3-9f28-4ac9-87b7-e3b0da7817f1_1600229691.3791375.png)\\n"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "one reason the answer is not -1 is because in the constraint it's mentioned that nums[-1] =nums[n]=-infinity hence if an array contains single digit then we will return 0 as it's bigger than -infinity. maybe that's why it's saying wrong answer. \nyou can see as it's written here-\nIn other words, an element is always considered to be strictly greater than a neighbor that is outside the array. Hence the answer would be 2 and not -1.\n"
                    },
                    {
                        "username": "davidtn",
                        "content": "Your test case is bad input because 1 of the 3 constraints down at the bottom is that no adjacent elements equal each other."
                    }
                ]
            },
            {
                "id": 1570420,
                "content": [
                    {
                        "username": "amoicity",
                        "content": "When people see ths question, I think most people will immediately come up with the linear search solution, which is to examine each num and compare it with its two neighbours. No braniner, right? Then people are thinking why this kind of question would  appear in the question pool and why it\\'s even rated as Medium. Then they might go to the Solution tab and see someone writing up a big article explaining a better solution and probably think, why bother? That\\'s an overkill. \\n\\nThese types of questions are so undervalued by people. And these are the questions we should pay more attention to. I\\'m sure in a real question, the interviewer will not be satisfied by the linear solution. Why? Because the straightforward linear scan solution isn\\'t using all of the clues given in the question. These clues, including\\n1. No adjacent two numbers are the same\\n2. the two end of the arrays are -\\u221E\\n3. You can return any peak.\\n\\nare all the clues that we can base upon to get to the final BS solution. When you are reading a question, pay great attention to these clues. If your solution does not involve all of the clue provided, you might not get the optimal solution. This is not any random question, it\\'s asked by Facebook, Google, etc., for multiple times. There is a reason why it exist and please don\\'t downvote it without even attempting to understand it."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@olsonpm](/olsonpm) I guess criticism of premature optimization originally intended to direct programmer\\'s effort into the best way of optimizing code. But now it\\'s most often used as an argument against any optimization."
                    },
                    {
                        "username": "olsonpm",
                        "content": "Questions like this that don\\'t enforce the optimal solution are a poor way to test devs.  In the real world, investing time into an unnecessary optimization is called premature optimization, and is a poor use of time as well as over-complicates the code."
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Mate, your tip is the best discussion section post template i always want to see :)"
                    },
                    {
                        "username": "sergei99",
                        "content": "Thanks mate. I had initially though that there was a mistake in the task description, but after your comment just sat down and wrote a few example lists of numbers. And then it took just a dozen lines of C++ code, including all the edge cases, to get 0ms execution time with 100% users beaten. :-)"
                    },
                    {
                        "username": "vaibhavbhatt59",
                        "content": "thanks bro i am going for see the solution  but bymistake i open discussion and see your comment on top . then i give another try to the question  and i did it . thanks bro\\n"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "i was getting frustrated and was going to look out for solutions but this comment pushed me and it clicked after few more minutes .... great question btw\\n"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "why u shudn\\'t skip questions with large no of downvotes without reading yourself"
                    },
                    {
                        "username": "madhavmaheshwarimm20",
                        "content": "[@armashhashmi](/armashhashmi) in constraints last point"
                    },
                    {
                        "username": "pyush98",
                        "content": "[@armashhashmi](/armashhashmi) \\n\\nnums[i] != nums[i + 1] for all valid i\\n\\nwrittein at bottom in smallest possible text XD"
                    },
                    {
                        "username": "armashhashmi",
                        "content": "where is it written in the question that \"No adjacent two numbers are same\" ?\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "after reading this (all before the 3 clues) I went and solved it in log(n) time, thanks for motivating me for doing so."
                    },
                    {
                        "username": "sohamdixit",
                        "content": "Agreed, but also for such questions where there is a trivial solution, I think the testcases need to be strong enough to not accept the trivial solution. In this case an O(n) solution should give a TLE, but it gets accepted, giving a misleading and false sense of having solved the problem in the best possible time to many people."
                    },
                    {
                        "username": "lavishmalik",
                        "content": "In both the questions you have to find peak elements but the catch is:\\n\\n-In leetcode 852 the array is increasingly and decreasingly sorted i.e its a bitonic array so you can apply modified binary search and find the global peak easily.\\n\\n-In this question(162), the given array is not sorted so they have given that there will be many peak elements and you can find any peak using binary search and return it .\\nBut you can\\'t find global peak in this question  just by applying binary search like previous question(852) because array is unsorted therefore after finding mid you can\\'t decide which side to go  for finding global peak.\\n\\n//Pls upvote if you like my solution\\n"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "the same code works for this also\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "So, How we do this."
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "The question doesn\\'t say the array is sorted, how do we know to use binary search ?"
                    },
                    {
                        "username": "cheekubhai",
                        "content": "The indexes form a sorted array"
                    },
                    {
                        "username": "premranjn",
                        "content": "there is a concept called binary search on answer, the sole idea of binary search in not only about finding a target in a sorted array, but to half the sample space after each decision.\\nSo here :\\nint findPeakElement(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if((mid == nums.size()-1)||nums[mid]>nums[mid+1] && ((mid == 0) || nums[mid]>nums[mid-1]))\\n                return mid;\\n            else if(mid==0)\\n                start = mid+1;\\n            else if(mid == nums.size()-1)\\n                end = mid-1;\\n            else if(nums[mid-1] < nums[mid])\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        return -1;\\n    }\\nif you would notice I am removing the half of the sample space each time i find the mid, using certain parameters.\\nHope It Helps ;)"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "[@ahmad-saeed](/ahmad-saeed) Sorting is an O(NLogN) process which is worse than doing a plain old linear search. Besides, you are supposed to return the index of the peak in its original position so you shouldn\\'t mutate the array in any way."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@pstrait](/pstrait) then i can just sort it in O(log n) then return the last in o(1) which satisfies the requirement without searching!"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "because  they said to do in 0(log n)  which is time complexty of binary search"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "Who said binary search can only applied on sorted arrays ?"
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "[@ssy55ssy](/ssy55ssy) can you please tell why that will work "
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "when the element is larger than it\\'s former element but it\\'s smaller than it\\'s later element,then the peak must appear behind it"
                    },
                    {
                        "username": "deadbycoffee",
                        "content": "I think it was just helpful that there could be multiple peaks. And because of that, you\\'re able to have a better chance of moving the left and right borders of the search based on what\\'s higher, mid, mid - 1, or mid + 1. Eventually either finding a peak or not finding one."
                    },
                    {
                        "username": "Altum_pax",
                        "content": "[@pstrait](/pstrait) Exactly that\\'s the catch!"
                    },
                    {
                        "username": "pstrait",
                        "content": "The array isn\\'t sorted; if it was sorted, the answer would just be the last element."
                    },
                    {
                        "username": "heejincs",
                        "content": "We can do simple binary search that check [mid] point and [mid+1] point and take half which has higher value, i.e. take left half if nums[mid]>nums[mid+1].\\nIt is not easy to show or proof why this works. \\nThe simple proof is that we take part of numbers that boundary condition holds true.\\nThat is, we only take search range (l, r) if nums[l-1]<nums[l] and num[r]>num[r+1]. Note that initial search range (l,r) where l=0 and r=len(nums)-1 holds true. Then, each step we reduce the search range half making sure the boundary condition holds true. Note that the other half the condition does not hold true.\\nTherefore, when it finally is reduced to a single number, it is the local maximum since the boundary condition for a single number is same as the condition for local maximum.\\n\\n"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I dont\\' understand the advantage of doing a linear search from 2 directions - \\n\\nlike what if your array is almost sorted with the peak occurring somewhere far away from mids\\n\\nlike 1,2,7,11,9,15,16,......,10000\\n\\nsay if you try a binary search on this array, it gives you almost nothing"
                    },
                    {
                        "username": "juciy_eggplant",
                        "content": "We know that for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF. From these conditions, we can prove that there must exist such an i that is peak, nums[i] > nums[i-1] and nums[i] > nums[i+1]:\\nSuppose there is no  i such that nums[i] > nums[i-1] and nums[i] > nums[i+1], then there are two cases:\\n1. if nums[i] > nums[i-1], it implies nums[i] < nums[i+1] for all i. however, this contradicts nums[n] == -INF\\n2. if nums[i] > nums[i+1], it implies nums[i] < nums[i-1] for all i which contradicts nums[-1] == -INF\\nQED\\n\\nNow we know that there must exist a peak i, we can derive the algorithm\\n1. if nums[m] < nums[m+1], then we know the right half is also an array where for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF (or to be more precise any x such that x < nums[i_0] && x < nums[i_n-1] and we know there must exist a peak\\n2. if nums[m] > nums[m+1], same logic applies for the left half"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Oh ok! I get it now. The whole magic lies in the sentence \"an element is always considered to be strictly greater than a neighbor that is outside the array.\" \\nThanks for the great comment! "
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Thank you very much for explanation sir :) Best explanation :)"
                    },
                    {
                        "username": "brianSalk",
                        "content": "In the comments section I see a lot of people saying that they do not know how they could come up with the binary search solution on their own in a short amount of time like the time that is allowed during an interview.\\n\\nFirst of all, you should be familiar with binary search, for it is a very common algorithm that can be modified to solve many problems that involve searching.\\nSecond, the question says that your algorithm must run in O(logN), which means that linear scan is out of the question.\\nIf you ever have a problem that involves searching for some element in a list in O(logN) time, you are probably limited to some variation of binary search as your only choice.  \\n\\n"
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "exactly O(logN) implies binary search modification.\\n"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe problem should state that there is only one peak in the sequence. Otherwise logarithmic complexity is not possible.\\n\\nFor example:\\n[1,2,1,3,4,5,0] has two peaks: 2 and 5. In such case, the search is O(n)."
                    },
                    {
                        "username": "pstrait",
                        "content": "No because you can stop at the first peak."
                    },
                    {
                        "username": "zeddysoft",
                        "content": "Hello folks,\\n\\nCan anyone here enlighten me on the significance of a question that has more downvote than upvotes. more specifically, should this type of question be avoided?\\n"
                    },
                    {
                        "username": "chaudharyrittik_26",
                        "content": "i also have the same question, can you tell me if you\\'ve got the answer\\n\\n"
                    },
                    {
                        "username": "thebigjuicyd",
                        "content": "no idea what you are talking about"
                    },
                    {
                        "username": "Ricola",
                        "content": "I don't get why I got this error while I never used an array in my answer.\\n\\nI think they edited the question, because the beginning of the solution is \"public int findPeakElement(List nums) {\" and in the answers, I saw people using an array of int.\\n\\nI tried using an array it doesn't work either."
                    },
                    {
                        "username": "tourist44",
                        "content": "It should say that peak element is an elemet which is greater than or equals to its neighbours and not strictly greater than its neighbours.\\nThats when this outcome would be correct.\\n![image](https://assets.leetcode.com/users/images/3e017fa3-9f28-4ac9-87b7-e3b0da7817f1_1600229691.3791375.png)\\n"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "one reason the answer is not -1 is because in the constraint it's mentioned that nums[-1] =nums[n]=-infinity hence if an array contains single digit then we will return 0 as it's bigger than -infinity. maybe that's why it's saying wrong answer. \nyou can see as it's written here-\nIn other words, an element is always considered to be strictly greater than a neighbor that is outside the array. Hence the answer would be 2 and not -1.\n"
                    },
                    {
                        "username": "davidtn",
                        "content": "Your test case is bad input because 1 of the 3 constraints down at the bottom is that no adjacent elements equal each other."
                    }
                ]
            },
            {
                "id": 1565066,
                "content": [
                    {
                        "username": "amoicity",
                        "content": "When people see ths question, I think most people will immediately come up with the linear search solution, which is to examine each num and compare it with its two neighbours. No braniner, right? Then people are thinking why this kind of question would  appear in the question pool and why it\\'s even rated as Medium. Then they might go to the Solution tab and see someone writing up a big article explaining a better solution and probably think, why bother? That\\'s an overkill. \\n\\nThese types of questions are so undervalued by people. And these are the questions we should pay more attention to. I\\'m sure in a real question, the interviewer will not be satisfied by the linear solution. Why? Because the straightforward linear scan solution isn\\'t using all of the clues given in the question. These clues, including\\n1. No adjacent two numbers are the same\\n2. the two end of the arrays are -\\u221E\\n3. You can return any peak.\\n\\nare all the clues that we can base upon to get to the final BS solution. When you are reading a question, pay great attention to these clues. If your solution does not involve all of the clue provided, you might not get the optimal solution. This is not any random question, it\\'s asked by Facebook, Google, etc., for multiple times. There is a reason why it exist and please don\\'t downvote it without even attempting to understand it."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@olsonpm](/olsonpm) I guess criticism of premature optimization originally intended to direct programmer\\'s effort into the best way of optimizing code. But now it\\'s most often used as an argument against any optimization."
                    },
                    {
                        "username": "olsonpm",
                        "content": "Questions like this that don\\'t enforce the optimal solution are a poor way to test devs.  In the real world, investing time into an unnecessary optimization is called premature optimization, and is a poor use of time as well as over-complicates the code."
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Mate, your tip is the best discussion section post template i always want to see :)"
                    },
                    {
                        "username": "sergei99",
                        "content": "Thanks mate. I had initially though that there was a mistake in the task description, but after your comment just sat down and wrote a few example lists of numbers. And then it took just a dozen lines of C++ code, including all the edge cases, to get 0ms execution time with 100% users beaten. :-)"
                    },
                    {
                        "username": "vaibhavbhatt59",
                        "content": "thanks bro i am going for see the solution  but bymistake i open discussion and see your comment on top . then i give another try to the question  and i did it . thanks bro\\n"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "i was getting frustrated and was going to look out for solutions but this comment pushed me and it clicked after few more minutes .... great question btw\\n"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "why u shudn\\'t skip questions with large no of downvotes without reading yourself"
                    },
                    {
                        "username": "madhavmaheshwarimm20",
                        "content": "[@armashhashmi](/armashhashmi) in constraints last point"
                    },
                    {
                        "username": "pyush98",
                        "content": "[@armashhashmi](/armashhashmi) \\n\\nnums[i] != nums[i + 1] for all valid i\\n\\nwrittein at bottom in smallest possible text XD"
                    },
                    {
                        "username": "armashhashmi",
                        "content": "where is it written in the question that \"No adjacent two numbers are same\" ?\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "after reading this (all before the 3 clues) I went and solved it in log(n) time, thanks for motivating me for doing so."
                    },
                    {
                        "username": "sohamdixit",
                        "content": "Agreed, but also for such questions where there is a trivial solution, I think the testcases need to be strong enough to not accept the trivial solution. In this case an O(n) solution should give a TLE, but it gets accepted, giving a misleading and false sense of having solved the problem in the best possible time to many people."
                    },
                    {
                        "username": "lavishmalik",
                        "content": "In both the questions you have to find peak elements but the catch is:\\n\\n-In leetcode 852 the array is increasingly and decreasingly sorted i.e its a bitonic array so you can apply modified binary search and find the global peak easily.\\n\\n-In this question(162), the given array is not sorted so they have given that there will be many peak elements and you can find any peak using binary search and return it .\\nBut you can\\'t find global peak in this question  just by applying binary search like previous question(852) because array is unsorted therefore after finding mid you can\\'t decide which side to go  for finding global peak.\\n\\n//Pls upvote if you like my solution\\n"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "the same code works for this also\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "So, How we do this."
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "The question doesn\\'t say the array is sorted, how do we know to use binary search ?"
                    },
                    {
                        "username": "cheekubhai",
                        "content": "The indexes form a sorted array"
                    },
                    {
                        "username": "premranjn",
                        "content": "there is a concept called binary search on answer, the sole idea of binary search in not only about finding a target in a sorted array, but to half the sample space after each decision.\\nSo here :\\nint findPeakElement(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if((mid == nums.size()-1)||nums[mid]>nums[mid+1] && ((mid == 0) || nums[mid]>nums[mid-1]))\\n                return mid;\\n            else if(mid==0)\\n                start = mid+1;\\n            else if(mid == nums.size()-1)\\n                end = mid-1;\\n            else if(nums[mid-1] < nums[mid])\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        return -1;\\n    }\\nif you would notice I am removing the half of the sample space each time i find the mid, using certain parameters.\\nHope It Helps ;)"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "[@ahmad-saeed](/ahmad-saeed) Sorting is an O(NLogN) process which is worse than doing a plain old linear search. Besides, you are supposed to return the index of the peak in its original position so you shouldn\\'t mutate the array in any way."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@pstrait](/pstrait) then i can just sort it in O(log n) then return the last in o(1) which satisfies the requirement without searching!"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "because  they said to do in 0(log n)  which is time complexty of binary search"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "Who said binary search can only applied on sorted arrays ?"
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "[@ssy55ssy](/ssy55ssy) can you please tell why that will work "
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "when the element is larger than it\\'s former element but it\\'s smaller than it\\'s later element,then the peak must appear behind it"
                    },
                    {
                        "username": "deadbycoffee",
                        "content": "I think it was just helpful that there could be multiple peaks. And because of that, you\\'re able to have a better chance of moving the left and right borders of the search based on what\\'s higher, mid, mid - 1, or mid + 1. Eventually either finding a peak or not finding one."
                    },
                    {
                        "username": "Altum_pax",
                        "content": "[@pstrait](/pstrait) Exactly that\\'s the catch!"
                    },
                    {
                        "username": "pstrait",
                        "content": "The array isn\\'t sorted; if it was sorted, the answer would just be the last element."
                    },
                    {
                        "username": "heejincs",
                        "content": "We can do simple binary search that check [mid] point and [mid+1] point and take half which has higher value, i.e. take left half if nums[mid]>nums[mid+1].\\nIt is not easy to show or proof why this works. \\nThe simple proof is that we take part of numbers that boundary condition holds true.\\nThat is, we only take search range (l, r) if nums[l-1]<nums[l] and num[r]>num[r+1]. Note that initial search range (l,r) where l=0 and r=len(nums)-1 holds true. Then, each step we reduce the search range half making sure the boundary condition holds true. Note that the other half the condition does not hold true.\\nTherefore, when it finally is reduced to a single number, it is the local maximum since the boundary condition for a single number is same as the condition for local maximum.\\n\\n"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I dont\\' understand the advantage of doing a linear search from 2 directions - \\n\\nlike what if your array is almost sorted with the peak occurring somewhere far away from mids\\n\\nlike 1,2,7,11,9,15,16,......,10000\\n\\nsay if you try a binary search on this array, it gives you almost nothing"
                    },
                    {
                        "username": "juciy_eggplant",
                        "content": "We know that for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF. From these conditions, we can prove that there must exist such an i that is peak, nums[i] > nums[i-1] and nums[i] > nums[i+1]:\\nSuppose there is no  i such that nums[i] > nums[i-1] and nums[i] > nums[i+1], then there are two cases:\\n1. if nums[i] > nums[i-1], it implies nums[i] < nums[i+1] for all i. however, this contradicts nums[n] == -INF\\n2. if nums[i] > nums[i+1], it implies nums[i] < nums[i-1] for all i which contradicts nums[-1] == -INF\\nQED\\n\\nNow we know that there must exist a peak i, we can derive the algorithm\\n1. if nums[m] < nums[m+1], then we know the right half is also an array where for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF (or to be more precise any x such that x < nums[i_0] && x < nums[i_n-1] and we know there must exist a peak\\n2. if nums[m] > nums[m+1], same logic applies for the left half"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Oh ok! I get it now. The whole magic lies in the sentence \"an element is always considered to be strictly greater than a neighbor that is outside the array.\" \\nThanks for the great comment! "
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Thank you very much for explanation sir :) Best explanation :)"
                    },
                    {
                        "username": "brianSalk",
                        "content": "In the comments section I see a lot of people saying that they do not know how they could come up with the binary search solution on their own in a short amount of time like the time that is allowed during an interview.\\n\\nFirst of all, you should be familiar with binary search, for it is a very common algorithm that can be modified to solve many problems that involve searching.\\nSecond, the question says that your algorithm must run in O(logN), which means that linear scan is out of the question.\\nIf you ever have a problem that involves searching for some element in a list in O(logN) time, you are probably limited to some variation of binary search as your only choice.  \\n\\n"
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "exactly O(logN) implies binary search modification.\\n"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe problem should state that there is only one peak in the sequence. Otherwise logarithmic complexity is not possible.\\n\\nFor example:\\n[1,2,1,3,4,5,0] has two peaks: 2 and 5. In such case, the search is O(n)."
                    },
                    {
                        "username": "pstrait",
                        "content": "No because you can stop at the first peak."
                    },
                    {
                        "username": "zeddysoft",
                        "content": "Hello folks,\\n\\nCan anyone here enlighten me on the significance of a question that has more downvote than upvotes. more specifically, should this type of question be avoided?\\n"
                    },
                    {
                        "username": "chaudharyrittik_26",
                        "content": "i also have the same question, can you tell me if you\\'ve got the answer\\n\\n"
                    },
                    {
                        "username": "thebigjuicyd",
                        "content": "no idea what you are talking about"
                    },
                    {
                        "username": "Ricola",
                        "content": "I don't get why I got this error while I never used an array in my answer.\\n\\nI think they edited the question, because the beginning of the solution is \"public int findPeakElement(List nums) {\" and in the answers, I saw people using an array of int.\\n\\nI tried using an array it doesn't work either."
                    },
                    {
                        "username": "tourist44",
                        "content": "It should say that peak element is an elemet which is greater than or equals to its neighbours and not strictly greater than its neighbours.\\nThats when this outcome would be correct.\\n![image](https://assets.leetcode.com/users/images/3e017fa3-9f28-4ac9-87b7-e3b0da7817f1_1600229691.3791375.png)\\n"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "one reason the answer is not -1 is because in the constraint it's mentioned that nums[-1] =nums[n]=-infinity hence if an array contains single digit then we will return 0 as it's bigger than -infinity. maybe that's why it's saying wrong answer. \nyou can see as it's written here-\nIn other words, an element is always considered to be strictly greater than a neighbor that is outside the array. Hence the answer would be 2 and not -1.\n"
                    },
                    {
                        "username": "davidtn",
                        "content": "Your test case is bad input because 1 of the 3 constraints down at the bottom is that no adjacent elements equal each other."
                    }
                ]
            },
            {
                "id": 1568447,
                "content": [
                    {
                        "username": "amoicity",
                        "content": "When people see ths question, I think most people will immediately come up with the linear search solution, which is to examine each num and compare it with its two neighbours. No braniner, right? Then people are thinking why this kind of question would  appear in the question pool and why it\\'s even rated as Medium. Then they might go to the Solution tab and see someone writing up a big article explaining a better solution and probably think, why bother? That\\'s an overkill. \\n\\nThese types of questions are so undervalued by people. And these are the questions we should pay more attention to. I\\'m sure in a real question, the interviewer will not be satisfied by the linear solution. Why? Because the straightforward linear scan solution isn\\'t using all of the clues given in the question. These clues, including\\n1. No adjacent two numbers are the same\\n2. the two end of the arrays are -\\u221E\\n3. You can return any peak.\\n\\nare all the clues that we can base upon to get to the final BS solution. When you are reading a question, pay great attention to these clues. If your solution does not involve all of the clue provided, you might not get the optimal solution. This is not any random question, it\\'s asked by Facebook, Google, etc., for multiple times. There is a reason why it exist and please don\\'t downvote it without even attempting to understand it."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@olsonpm](/olsonpm) I guess criticism of premature optimization originally intended to direct programmer\\'s effort into the best way of optimizing code. But now it\\'s most often used as an argument against any optimization."
                    },
                    {
                        "username": "olsonpm",
                        "content": "Questions like this that don\\'t enforce the optimal solution are a poor way to test devs.  In the real world, investing time into an unnecessary optimization is called premature optimization, and is a poor use of time as well as over-complicates the code."
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Mate, your tip is the best discussion section post template i always want to see :)"
                    },
                    {
                        "username": "sergei99",
                        "content": "Thanks mate. I had initially though that there was a mistake in the task description, but after your comment just sat down and wrote a few example lists of numbers. And then it took just a dozen lines of C++ code, including all the edge cases, to get 0ms execution time with 100% users beaten. :-)"
                    },
                    {
                        "username": "vaibhavbhatt59",
                        "content": "thanks bro i am going for see the solution  but bymistake i open discussion and see your comment on top . then i give another try to the question  and i did it . thanks bro\\n"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "i was getting frustrated and was going to look out for solutions but this comment pushed me and it clicked after few more minutes .... great question btw\\n"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "why u shudn\\'t skip questions with large no of downvotes without reading yourself"
                    },
                    {
                        "username": "madhavmaheshwarimm20",
                        "content": "[@armashhashmi](/armashhashmi) in constraints last point"
                    },
                    {
                        "username": "pyush98",
                        "content": "[@armashhashmi](/armashhashmi) \\n\\nnums[i] != nums[i + 1] for all valid i\\n\\nwrittein at bottom in smallest possible text XD"
                    },
                    {
                        "username": "armashhashmi",
                        "content": "where is it written in the question that \"No adjacent two numbers are same\" ?\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "after reading this (all before the 3 clues) I went and solved it in log(n) time, thanks for motivating me for doing so."
                    },
                    {
                        "username": "sohamdixit",
                        "content": "Agreed, but also for such questions where there is a trivial solution, I think the testcases need to be strong enough to not accept the trivial solution. In this case an O(n) solution should give a TLE, but it gets accepted, giving a misleading and false sense of having solved the problem in the best possible time to many people."
                    },
                    {
                        "username": "lavishmalik",
                        "content": "In both the questions you have to find peak elements but the catch is:\\n\\n-In leetcode 852 the array is increasingly and decreasingly sorted i.e its a bitonic array so you can apply modified binary search and find the global peak easily.\\n\\n-In this question(162), the given array is not sorted so they have given that there will be many peak elements and you can find any peak using binary search and return it .\\nBut you can\\'t find global peak in this question  just by applying binary search like previous question(852) because array is unsorted therefore after finding mid you can\\'t decide which side to go  for finding global peak.\\n\\n//Pls upvote if you like my solution\\n"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "the same code works for this also\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "So, How we do this."
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "The question doesn\\'t say the array is sorted, how do we know to use binary search ?"
                    },
                    {
                        "username": "cheekubhai",
                        "content": "The indexes form a sorted array"
                    },
                    {
                        "username": "premranjn",
                        "content": "there is a concept called binary search on answer, the sole idea of binary search in not only about finding a target in a sorted array, but to half the sample space after each decision.\\nSo here :\\nint findPeakElement(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if((mid == nums.size()-1)||nums[mid]>nums[mid+1] && ((mid == 0) || nums[mid]>nums[mid-1]))\\n                return mid;\\n            else if(mid==0)\\n                start = mid+1;\\n            else if(mid == nums.size()-1)\\n                end = mid-1;\\n            else if(nums[mid-1] < nums[mid])\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        return -1;\\n    }\\nif you would notice I am removing the half of the sample space each time i find the mid, using certain parameters.\\nHope It Helps ;)"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "[@ahmad-saeed](/ahmad-saeed) Sorting is an O(NLogN) process which is worse than doing a plain old linear search. Besides, you are supposed to return the index of the peak in its original position so you shouldn\\'t mutate the array in any way."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@pstrait](/pstrait) then i can just sort it in O(log n) then return the last in o(1) which satisfies the requirement without searching!"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "because  they said to do in 0(log n)  which is time complexty of binary search"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "Who said binary search can only applied on sorted arrays ?"
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "[@ssy55ssy](/ssy55ssy) can you please tell why that will work "
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "when the element is larger than it\\'s former element but it\\'s smaller than it\\'s later element,then the peak must appear behind it"
                    },
                    {
                        "username": "deadbycoffee",
                        "content": "I think it was just helpful that there could be multiple peaks. And because of that, you\\'re able to have a better chance of moving the left and right borders of the search based on what\\'s higher, mid, mid - 1, or mid + 1. Eventually either finding a peak or not finding one."
                    },
                    {
                        "username": "Altum_pax",
                        "content": "[@pstrait](/pstrait) Exactly that\\'s the catch!"
                    },
                    {
                        "username": "pstrait",
                        "content": "The array isn\\'t sorted; if it was sorted, the answer would just be the last element."
                    },
                    {
                        "username": "heejincs",
                        "content": "We can do simple binary search that check [mid] point and [mid+1] point and take half which has higher value, i.e. take left half if nums[mid]>nums[mid+1].\\nIt is not easy to show or proof why this works. \\nThe simple proof is that we take part of numbers that boundary condition holds true.\\nThat is, we only take search range (l, r) if nums[l-1]<nums[l] and num[r]>num[r+1]. Note that initial search range (l,r) where l=0 and r=len(nums)-1 holds true. Then, each step we reduce the search range half making sure the boundary condition holds true. Note that the other half the condition does not hold true.\\nTherefore, when it finally is reduced to a single number, it is the local maximum since the boundary condition for a single number is same as the condition for local maximum.\\n\\n"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I dont\\' understand the advantage of doing a linear search from 2 directions - \\n\\nlike what if your array is almost sorted with the peak occurring somewhere far away from mids\\n\\nlike 1,2,7,11,9,15,16,......,10000\\n\\nsay if you try a binary search on this array, it gives you almost nothing"
                    },
                    {
                        "username": "juciy_eggplant",
                        "content": "We know that for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF. From these conditions, we can prove that there must exist such an i that is peak, nums[i] > nums[i-1] and nums[i] > nums[i+1]:\\nSuppose there is no  i such that nums[i] > nums[i-1] and nums[i] > nums[i+1], then there are two cases:\\n1. if nums[i] > nums[i-1], it implies nums[i] < nums[i+1] for all i. however, this contradicts nums[n] == -INF\\n2. if nums[i] > nums[i+1], it implies nums[i] < nums[i-1] for all i which contradicts nums[-1] == -INF\\nQED\\n\\nNow we know that there must exist a peak i, we can derive the algorithm\\n1. if nums[m] < nums[m+1], then we know the right half is also an array where for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF (or to be more precise any x such that x < nums[i_0] && x < nums[i_n-1] and we know there must exist a peak\\n2. if nums[m] > nums[m+1], same logic applies for the left half"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Oh ok! I get it now. The whole magic lies in the sentence \"an element is always considered to be strictly greater than a neighbor that is outside the array.\" \\nThanks for the great comment! "
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Thank you very much for explanation sir :) Best explanation :)"
                    },
                    {
                        "username": "brianSalk",
                        "content": "In the comments section I see a lot of people saying that they do not know how they could come up with the binary search solution on their own in a short amount of time like the time that is allowed during an interview.\\n\\nFirst of all, you should be familiar with binary search, for it is a very common algorithm that can be modified to solve many problems that involve searching.\\nSecond, the question says that your algorithm must run in O(logN), which means that linear scan is out of the question.\\nIf you ever have a problem that involves searching for some element in a list in O(logN) time, you are probably limited to some variation of binary search as your only choice.  \\n\\n"
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "exactly O(logN) implies binary search modification.\\n"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe problem should state that there is only one peak in the sequence. Otherwise logarithmic complexity is not possible.\\n\\nFor example:\\n[1,2,1,3,4,5,0] has two peaks: 2 and 5. In such case, the search is O(n)."
                    },
                    {
                        "username": "pstrait",
                        "content": "No because you can stop at the first peak."
                    },
                    {
                        "username": "zeddysoft",
                        "content": "Hello folks,\\n\\nCan anyone here enlighten me on the significance of a question that has more downvote than upvotes. more specifically, should this type of question be avoided?\\n"
                    },
                    {
                        "username": "chaudharyrittik_26",
                        "content": "i also have the same question, can you tell me if you\\'ve got the answer\\n\\n"
                    },
                    {
                        "username": "thebigjuicyd",
                        "content": "no idea what you are talking about"
                    },
                    {
                        "username": "Ricola",
                        "content": "I don't get why I got this error while I never used an array in my answer.\\n\\nI think they edited the question, because the beginning of the solution is \"public int findPeakElement(List nums) {\" and in the answers, I saw people using an array of int.\\n\\nI tried using an array it doesn't work either."
                    },
                    {
                        "username": "tourist44",
                        "content": "It should say that peak element is an elemet which is greater than or equals to its neighbours and not strictly greater than its neighbours.\\nThats when this outcome would be correct.\\n![image](https://assets.leetcode.com/users/images/3e017fa3-9f28-4ac9-87b7-e3b0da7817f1_1600229691.3791375.png)\\n"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "one reason the answer is not -1 is because in the constraint it's mentioned that nums[-1] =nums[n]=-infinity hence if an array contains single digit then we will return 0 as it's bigger than -infinity. maybe that's why it's saying wrong answer. \nyou can see as it's written here-\nIn other words, an element is always considered to be strictly greater than a neighbor that is outside the array. Hence the answer would be 2 and not -1.\n"
                    },
                    {
                        "username": "davidtn",
                        "content": "Your test case is bad input because 1 of the 3 constraints down at the bottom is that no adjacent elements equal each other."
                    }
                ]
            },
            {
                "id": 1570789,
                "content": [
                    {
                        "username": "amoicity",
                        "content": "When people see ths question, I think most people will immediately come up with the linear search solution, which is to examine each num and compare it with its two neighbours. No braniner, right? Then people are thinking why this kind of question would  appear in the question pool and why it\\'s even rated as Medium. Then they might go to the Solution tab and see someone writing up a big article explaining a better solution and probably think, why bother? That\\'s an overkill. \\n\\nThese types of questions are so undervalued by people. And these are the questions we should pay more attention to. I\\'m sure in a real question, the interviewer will not be satisfied by the linear solution. Why? Because the straightforward linear scan solution isn\\'t using all of the clues given in the question. These clues, including\\n1. No adjacent two numbers are the same\\n2. the two end of the arrays are -\\u221E\\n3. You can return any peak.\\n\\nare all the clues that we can base upon to get to the final BS solution. When you are reading a question, pay great attention to these clues. If your solution does not involve all of the clue provided, you might not get the optimal solution. This is not any random question, it\\'s asked by Facebook, Google, etc., for multiple times. There is a reason why it exist and please don\\'t downvote it without even attempting to understand it."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@olsonpm](/olsonpm) I guess criticism of premature optimization originally intended to direct programmer\\'s effort into the best way of optimizing code. But now it\\'s most often used as an argument against any optimization."
                    },
                    {
                        "username": "olsonpm",
                        "content": "Questions like this that don\\'t enforce the optimal solution are a poor way to test devs.  In the real world, investing time into an unnecessary optimization is called premature optimization, and is a poor use of time as well as over-complicates the code."
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Mate, your tip is the best discussion section post template i always want to see :)"
                    },
                    {
                        "username": "sergei99",
                        "content": "Thanks mate. I had initially though that there was a mistake in the task description, but after your comment just sat down and wrote a few example lists of numbers. And then it took just a dozen lines of C++ code, including all the edge cases, to get 0ms execution time with 100% users beaten. :-)"
                    },
                    {
                        "username": "vaibhavbhatt59",
                        "content": "thanks bro i am going for see the solution  but bymistake i open discussion and see your comment on top . then i give another try to the question  and i did it . thanks bro\\n"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "i was getting frustrated and was going to look out for solutions but this comment pushed me and it clicked after few more minutes .... great question btw\\n"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "why u shudn\\'t skip questions with large no of downvotes without reading yourself"
                    },
                    {
                        "username": "madhavmaheshwarimm20",
                        "content": "[@armashhashmi](/armashhashmi) in constraints last point"
                    },
                    {
                        "username": "pyush98",
                        "content": "[@armashhashmi](/armashhashmi) \\n\\nnums[i] != nums[i + 1] for all valid i\\n\\nwrittein at bottom in smallest possible text XD"
                    },
                    {
                        "username": "armashhashmi",
                        "content": "where is it written in the question that \"No adjacent two numbers are same\" ?\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "after reading this (all before the 3 clues) I went and solved it in log(n) time, thanks for motivating me for doing so."
                    },
                    {
                        "username": "sohamdixit",
                        "content": "Agreed, but also for such questions where there is a trivial solution, I think the testcases need to be strong enough to not accept the trivial solution. In this case an O(n) solution should give a TLE, but it gets accepted, giving a misleading and false sense of having solved the problem in the best possible time to many people."
                    },
                    {
                        "username": "lavishmalik",
                        "content": "In both the questions you have to find peak elements but the catch is:\\n\\n-In leetcode 852 the array is increasingly and decreasingly sorted i.e its a bitonic array so you can apply modified binary search and find the global peak easily.\\n\\n-In this question(162), the given array is not sorted so they have given that there will be many peak elements and you can find any peak using binary search and return it .\\nBut you can\\'t find global peak in this question  just by applying binary search like previous question(852) because array is unsorted therefore after finding mid you can\\'t decide which side to go  for finding global peak.\\n\\n//Pls upvote if you like my solution\\n"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "the same code works for this also\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "So, How we do this."
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "The question doesn\\'t say the array is sorted, how do we know to use binary search ?"
                    },
                    {
                        "username": "cheekubhai",
                        "content": "The indexes form a sorted array"
                    },
                    {
                        "username": "premranjn",
                        "content": "there is a concept called binary search on answer, the sole idea of binary search in not only about finding a target in a sorted array, but to half the sample space after each decision.\\nSo here :\\nint findPeakElement(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if((mid == nums.size()-1)||nums[mid]>nums[mid+1] && ((mid == 0) || nums[mid]>nums[mid-1]))\\n                return mid;\\n            else if(mid==0)\\n                start = mid+1;\\n            else if(mid == nums.size()-1)\\n                end = mid-1;\\n            else if(nums[mid-1] < nums[mid])\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        return -1;\\n    }\\nif you would notice I am removing the half of the sample space each time i find the mid, using certain parameters.\\nHope It Helps ;)"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "[@ahmad-saeed](/ahmad-saeed) Sorting is an O(NLogN) process which is worse than doing a plain old linear search. Besides, you are supposed to return the index of the peak in its original position so you shouldn\\'t mutate the array in any way."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@pstrait](/pstrait) then i can just sort it in O(log n) then return the last in o(1) which satisfies the requirement without searching!"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "because  they said to do in 0(log n)  which is time complexty of binary search"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "Who said binary search can only applied on sorted arrays ?"
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "[@ssy55ssy](/ssy55ssy) can you please tell why that will work "
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "when the element is larger than it\\'s former element but it\\'s smaller than it\\'s later element,then the peak must appear behind it"
                    },
                    {
                        "username": "deadbycoffee",
                        "content": "I think it was just helpful that there could be multiple peaks. And because of that, you\\'re able to have a better chance of moving the left and right borders of the search based on what\\'s higher, mid, mid - 1, or mid + 1. Eventually either finding a peak or not finding one."
                    },
                    {
                        "username": "Altum_pax",
                        "content": "[@pstrait](/pstrait) Exactly that\\'s the catch!"
                    },
                    {
                        "username": "pstrait",
                        "content": "The array isn\\'t sorted; if it was sorted, the answer would just be the last element."
                    },
                    {
                        "username": "heejincs",
                        "content": "We can do simple binary search that check [mid] point and [mid+1] point and take half which has higher value, i.e. take left half if nums[mid]>nums[mid+1].\\nIt is not easy to show or proof why this works. \\nThe simple proof is that we take part of numbers that boundary condition holds true.\\nThat is, we only take search range (l, r) if nums[l-1]<nums[l] and num[r]>num[r+1]. Note that initial search range (l,r) where l=0 and r=len(nums)-1 holds true. Then, each step we reduce the search range half making sure the boundary condition holds true. Note that the other half the condition does not hold true.\\nTherefore, when it finally is reduced to a single number, it is the local maximum since the boundary condition for a single number is same as the condition for local maximum.\\n\\n"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I dont\\' understand the advantage of doing a linear search from 2 directions - \\n\\nlike what if your array is almost sorted with the peak occurring somewhere far away from mids\\n\\nlike 1,2,7,11,9,15,16,......,10000\\n\\nsay if you try a binary search on this array, it gives you almost nothing"
                    },
                    {
                        "username": "juciy_eggplant",
                        "content": "We know that for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF. From these conditions, we can prove that there must exist such an i that is peak, nums[i] > nums[i-1] and nums[i] > nums[i+1]:\\nSuppose there is no  i such that nums[i] > nums[i-1] and nums[i] > nums[i+1], then there are two cases:\\n1. if nums[i] > nums[i-1], it implies nums[i] < nums[i+1] for all i. however, this contradicts nums[n] == -INF\\n2. if nums[i] > nums[i+1], it implies nums[i] < nums[i-1] for all i which contradicts nums[-1] == -INF\\nQED\\n\\nNow we know that there must exist a peak i, we can derive the algorithm\\n1. if nums[m] < nums[m+1], then we know the right half is also an array where for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF (or to be more precise any x such that x < nums[i_0] && x < nums[i_n-1] and we know there must exist a peak\\n2. if nums[m] > nums[m+1], same logic applies for the left half"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Oh ok! I get it now. The whole magic lies in the sentence \"an element is always considered to be strictly greater than a neighbor that is outside the array.\" \\nThanks for the great comment! "
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Thank you very much for explanation sir :) Best explanation :)"
                    },
                    {
                        "username": "brianSalk",
                        "content": "In the comments section I see a lot of people saying that they do not know how they could come up with the binary search solution on their own in a short amount of time like the time that is allowed during an interview.\\n\\nFirst of all, you should be familiar with binary search, for it is a very common algorithm that can be modified to solve many problems that involve searching.\\nSecond, the question says that your algorithm must run in O(logN), which means that linear scan is out of the question.\\nIf you ever have a problem that involves searching for some element in a list in O(logN) time, you are probably limited to some variation of binary search as your only choice.  \\n\\n"
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "exactly O(logN) implies binary search modification.\\n"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe problem should state that there is only one peak in the sequence. Otherwise logarithmic complexity is not possible.\\n\\nFor example:\\n[1,2,1,3,4,5,0] has two peaks: 2 and 5. In such case, the search is O(n)."
                    },
                    {
                        "username": "pstrait",
                        "content": "No because you can stop at the first peak."
                    },
                    {
                        "username": "zeddysoft",
                        "content": "Hello folks,\\n\\nCan anyone here enlighten me on the significance of a question that has more downvote than upvotes. more specifically, should this type of question be avoided?\\n"
                    },
                    {
                        "username": "chaudharyrittik_26",
                        "content": "i also have the same question, can you tell me if you\\'ve got the answer\\n\\n"
                    },
                    {
                        "username": "thebigjuicyd",
                        "content": "no idea what you are talking about"
                    },
                    {
                        "username": "Ricola",
                        "content": "I don't get why I got this error while I never used an array in my answer.\\n\\nI think they edited the question, because the beginning of the solution is \"public int findPeakElement(List nums) {\" and in the answers, I saw people using an array of int.\\n\\nI tried using an array it doesn't work either."
                    },
                    {
                        "username": "tourist44",
                        "content": "It should say that peak element is an elemet which is greater than or equals to its neighbours and not strictly greater than its neighbours.\\nThats when this outcome would be correct.\\n![image](https://assets.leetcode.com/users/images/3e017fa3-9f28-4ac9-87b7-e3b0da7817f1_1600229691.3791375.png)\\n"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "one reason the answer is not -1 is because in the constraint it's mentioned that nums[-1] =nums[n]=-infinity hence if an array contains single digit then we will return 0 as it's bigger than -infinity. maybe that's why it's saying wrong answer. \nyou can see as it's written here-\nIn other words, an element is always considered to be strictly greater than a neighbor that is outside the array. Hence the answer would be 2 and not -1.\n"
                    },
                    {
                        "username": "davidtn",
                        "content": "Your test case is bad input because 1 of the 3 constraints down at the bottom is that no adjacent elements equal each other."
                    }
                ]
            },
            {
                "id": 1566757,
                "content": [
                    {
                        "username": "amoicity",
                        "content": "When people see ths question, I think most people will immediately come up with the linear search solution, which is to examine each num and compare it with its two neighbours. No braniner, right? Then people are thinking why this kind of question would  appear in the question pool and why it\\'s even rated as Medium. Then they might go to the Solution tab and see someone writing up a big article explaining a better solution and probably think, why bother? That\\'s an overkill. \\n\\nThese types of questions are so undervalued by people. And these are the questions we should pay more attention to. I\\'m sure in a real question, the interviewer will not be satisfied by the linear solution. Why? Because the straightforward linear scan solution isn\\'t using all of the clues given in the question. These clues, including\\n1. No adjacent two numbers are the same\\n2. the two end of the arrays are -\\u221E\\n3. You can return any peak.\\n\\nare all the clues that we can base upon to get to the final BS solution. When you are reading a question, pay great attention to these clues. If your solution does not involve all of the clue provided, you might not get the optimal solution. This is not any random question, it\\'s asked by Facebook, Google, etc., for multiple times. There is a reason why it exist and please don\\'t downvote it without even attempting to understand it."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@olsonpm](/olsonpm) I guess criticism of premature optimization originally intended to direct programmer\\'s effort into the best way of optimizing code. But now it\\'s most often used as an argument against any optimization."
                    },
                    {
                        "username": "olsonpm",
                        "content": "Questions like this that don\\'t enforce the optimal solution are a poor way to test devs.  In the real world, investing time into an unnecessary optimization is called premature optimization, and is a poor use of time as well as over-complicates the code."
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Mate, your tip is the best discussion section post template i always want to see :)"
                    },
                    {
                        "username": "sergei99",
                        "content": "Thanks mate. I had initially though that there was a mistake in the task description, but after your comment just sat down and wrote a few example lists of numbers. And then it took just a dozen lines of C++ code, including all the edge cases, to get 0ms execution time with 100% users beaten. :-)"
                    },
                    {
                        "username": "vaibhavbhatt59",
                        "content": "thanks bro i am going for see the solution  but bymistake i open discussion and see your comment on top . then i give another try to the question  and i did it . thanks bro\\n"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "i was getting frustrated and was going to look out for solutions but this comment pushed me and it clicked after few more minutes .... great question btw\\n"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "why u shudn\\'t skip questions with large no of downvotes without reading yourself"
                    },
                    {
                        "username": "madhavmaheshwarimm20",
                        "content": "[@armashhashmi](/armashhashmi) in constraints last point"
                    },
                    {
                        "username": "pyush98",
                        "content": "[@armashhashmi](/armashhashmi) \\n\\nnums[i] != nums[i + 1] for all valid i\\n\\nwrittein at bottom in smallest possible text XD"
                    },
                    {
                        "username": "armashhashmi",
                        "content": "where is it written in the question that \"No adjacent two numbers are same\" ?\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "after reading this (all before the 3 clues) I went and solved it in log(n) time, thanks for motivating me for doing so."
                    },
                    {
                        "username": "sohamdixit",
                        "content": "Agreed, but also for such questions where there is a trivial solution, I think the testcases need to be strong enough to not accept the trivial solution. In this case an O(n) solution should give a TLE, but it gets accepted, giving a misleading and false sense of having solved the problem in the best possible time to many people."
                    },
                    {
                        "username": "lavishmalik",
                        "content": "In both the questions you have to find peak elements but the catch is:\\n\\n-In leetcode 852 the array is increasingly and decreasingly sorted i.e its a bitonic array so you can apply modified binary search and find the global peak easily.\\n\\n-In this question(162), the given array is not sorted so they have given that there will be many peak elements and you can find any peak using binary search and return it .\\nBut you can\\'t find global peak in this question  just by applying binary search like previous question(852) because array is unsorted therefore after finding mid you can\\'t decide which side to go  for finding global peak.\\n\\n//Pls upvote if you like my solution\\n"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "the same code works for this also\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "So, How we do this."
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "The question doesn\\'t say the array is sorted, how do we know to use binary search ?"
                    },
                    {
                        "username": "cheekubhai",
                        "content": "The indexes form a sorted array"
                    },
                    {
                        "username": "premranjn",
                        "content": "there is a concept called binary search on answer, the sole idea of binary search in not only about finding a target in a sorted array, but to half the sample space after each decision.\\nSo here :\\nint findPeakElement(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if((mid == nums.size()-1)||nums[mid]>nums[mid+1] && ((mid == 0) || nums[mid]>nums[mid-1]))\\n                return mid;\\n            else if(mid==0)\\n                start = mid+1;\\n            else if(mid == nums.size()-1)\\n                end = mid-1;\\n            else if(nums[mid-1] < nums[mid])\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        return -1;\\n    }\\nif you would notice I am removing the half of the sample space each time i find the mid, using certain parameters.\\nHope It Helps ;)"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "[@ahmad-saeed](/ahmad-saeed) Sorting is an O(NLogN) process which is worse than doing a plain old linear search. Besides, you are supposed to return the index of the peak in its original position so you shouldn\\'t mutate the array in any way."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@pstrait](/pstrait) then i can just sort it in O(log n) then return the last in o(1) which satisfies the requirement without searching!"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "because  they said to do in 0(log n)  which is time complexty of binary search"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "Who said binary search can only applied on sorted arrays ?"
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "[@ssy55ssy](/ssy55ssy) can you please tell why that will work "
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "when the element is larger than it\\'s former element but it\\'s smaller than it\\'s later element,then the peak must appear behind it"
                    },
                    {
                        "username": "deadbycoffee",
                        "content": "I think it was just helpful that there could be multiple peaks. And because of that, you\\'re able to have a better chance of moving the left and right borders of the search based on what\\'s higher, mid, mid - 1, or mid + 1. Eventually either finding a peak or not finding one."
                    },
                    {
                        "username": "Altum_pax",
                        "content": "[@pstrait](/pstrait) Exactly that\\'s the catch!"
                    },
                    {
                        "username": "pstrait",
                        "content": "The array isn\\'t sorted; if it was sorted, the answer would just be the last element."
                    },
                    {
                        "username": "heejincs",
                        "content": "We can do simple binary search that check [mid] point and [mid+1] point and take half which has higher value, i.e. take left half if nums[mid]>nums[mid+1].\\nIt is not easy to show or proof why this works. \\nThe simple proof is that we take part of numbers that boundary condition holds true.\\nThat is, we only take search range (l, r) if nums[l-1]<nums[l] and num[r]>num[r+1]. Note that initial search range (l,r) where l=0 and r=len(nums)-1 holds true. Then, each step we reduce the search range half making sure the boundary condition holds true. Note that the other half the condition does not hold true.\\nTherefore, when it finally is reduced to a single number, it is the local maximum since the boundary condition for a single number is same as the condition for local maximum.\\n\\n"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I dont\\' understand the advantage of doing a linear search from 2 directions - \\n\\nlike what if your array is almost sorted with the peak occurring somewhere far away from mids\\n\\nlike 1,2,7,11,9,15,16,......,10000\\n\\nsay if you try a binary search on this array, it gives you almost nothing"
                    },
                    {
                        "username": "juciy_eggplant",
                        "content": "We know that for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF. From these conditions, we can prove that there must exist such an i that is peak, nums[i] > nums[i-1] and nums[i] > nums[i+1]:\\nSuppose there is no  i such that nums[i] > nums[i-1] and nums[i] > nums[i+1], then there are two cases:\\n1. if nums[i] > nums[i-1], it implies nums[i] < nums[i+1] for all i. however, this contradicts nums[n] == -INF\\n2. if nums[i] > nums[i+1], it implies nums[i] < nums[i-1] for all i which contradicts nums[-1] == -INF\\nQED\\n\\nNow we know that there must exist a peak i, we can derive the algorithm\\n1. if nums[m] < nums[m+1], then we know the right half is also an array where for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF (or to be more precise any x such that x < nums[i_0] && x < nums[i_n-1] and we know there must exist a peak\\n2. if nums[m] > nums[m+1], same logic applies for the left half"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Oh ok! I get it now. The whole magic lies in the sentence \"an element is always considered to be strictly greater than a neighbor that is outside the array.\" \\nThanks for the great comment! "
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Thank you very much for explanation sir :) Best explanation :)"
                    },
                    {
                        "username": "brianSalk",
                        "content": "In the comments section I see a lot of people saying that they do not know how they could come up with the binary search solution on their own in a short amount of time like the time that is allowed during an interview.\\n\\nFirst of all, you should be familiar with binary search, for it is a very common algorithm that can be modified to solve many problems that involve searching.\\nSecond, the question says that your algorithm must run in O(logN), which means that linear scan is out of the question.\\nIf you ever have a problem that involves searching for some element in a list in O(logN) time, you are probably limited to some variation of binary search as your only choice.  \\n\\n"
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "exactly O(logN) implies binary search modification.\\n"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe problem should state that there is only one peak in the sequence. Otherwise logarithmic complexity is not possible.\\n\\nFor example:\\n[1,2,1,3,4,5,0] has two peaks: 2 and 5. In such case, the search is O(n)."
                    },
                    {
                        "username": "pstrait",
                        "content": "No because you can stop at the first peak."
                    },
                    {
                        "username": "zeddysoft",
                        "content": "Hello folks,\\n\\nCan anyone here enlighten me on the significance of a question that has more downvote than upvotes. more specifically, should this type of question be avoided?\\n"
                    },
                    {
                        "username": "chaudharyrittik_26",
                        "content": "i also have the same question, can you tell me if you\\'ve got the answer\\n\\n"
                    },
                    {
                        "username": "thebigjuicyd",
                        "content": "no idea what you are talking about"
                    },
                    {
                        "username": "Ricola",
                        "content": "I don't get why I got this error while I never used an array in my answer.\\n\\nI think they edited the question, because the beginning of the solution is \"public int findPeakElement(List nums) {\" and in the answers, I saw people using an array of int.\\n\\nI tried using an array it doesn't work either."
                    },
                    {
                        "username": "tourist44",
                        "content": "It should say that peak element is an elemet which is greater than or equals to its neighbours and not strictly greater than its neighbours.\\nThats when this outcome would be correct.\\n![image](https://assets.leetcode.com/users/images/3e017fa3-9f28-4ac9-87b7-e3b0da7817f1_1600229691.3791375.png)\\n"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "one reason the answer is not -1 is because in the constraint it's mentioned that nums[-1] =nums[n]=-infinity hence if an array contains single digit then we will return 0 as it's bigger than -infinity. maybe that's why it's saying wrong answer. \nyou can see as it's written here-\nIn other words, an element is always considered to be strictly greater than a neighbor that is outside the array. Hence the answer would be 2 and not -1.\n"
                    },
                    {
                        "username": "davidtn",
                        "content": "Your test case is bad input because 1 of the 3 constraints down at the bottom is that no adjacent elements equal each other."
                    }
                ]
            },
            {
                "id": 1566847,
                "content": [
                    {
                        "username": "amoicity",
                        "content": "When people see ths question, I think most people will immediately come up with the linear search solution, which is to examine each num and compare it with its two neighbours. No braniner, right? Then people are thinking why this kind of question would  appear in the question pool and why it\\'s even rated as Medium. Then they might go to the Solution tab and see someone writing up a big article explaining a better solution and probably think, why bother? That\\'s an overkill. \\n\\nThese types of questions are so undervalued by people. And these are the questions we should pay more attention to. I\\'m sure in a real question, the interviewer will not be satisfied by the linear solution. Why? Because the straightforward linear scan solution isn\\'t using all of the clues given in the question. These clues, including\\n1. No adjacent two numbers are the same\\n2. the two end of the arrays are -\\u221E\\n3. You can return any peak.\\n\\nare all the clues that we can base upon to get to the final BS solution. When you are reading a question, pay great attention to these clues. If your solution does not involve all of the clue provided, you might not get the optimal solution. This is not any random question, it\\'s asked by Facebook, Google, etc., for multiple times. There is a reason why it exist and please don\\'t downvote it without even attempting to understand it."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@olsonpm](/olsonpm) I guess criticism of premature optimization originally intended to direct programmer\\'s effort into the best way of optimizing code. But now it\\'s most often used as an argument against any optimization."
                    },
                    {
                        "username": "olsonpm",
                        "content": "Questions like this that don\\'t enforce the optimal solution are a poor way to test devs.  In the real world, investing time into an unnecessary optimization is called premature optimization, and is a poor use of time as well as over-complicates the code."
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Mate, your tip is the best discussion section post template i always want to see :)"
                    },
                    {
                        "username": "sergei99",
                        "content": "Thanks mate. I had initially though that there was a mistake in the task description, but after your comment just sat down and wrote a few example lists of numbers. And then it took just a dozen lines of C++ code, including all the edge cases, to get 0ms execution time with 100% users beaten. :-)"
                    },
                    {
                        "username": "vaibhavbhatt59",
                        "content": "thanks bro i am going for see the solution  but bymistake i open discussion and see your comment on top . then i give another try to the question  and i did it . thanks bro\\n"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "i was getting frustrated and was going to look out for solutions but this comment pushed me and it clicked after few more minutes .... great question btw\\n"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "why u shudn\\'t skip questions with large no of downvotes without reading yourself"
                    },
                    {
                        "username": "madhavmaheshwarimm20",
                        "content": "[@armashhashmi](/armashhashmi) in constraints last point"
                    },
                    {
                        "username": "pyush98",
                        "content": "[@armashhashmi](/armashhashmi) \\n\\nnums[i] != nums[i + 1] for all valid i\\n\\nwrittein at bottom in smallest possible text XD"
                    },
                    {
                        "username": "armashhashmi",
                        "content": "where is it written in the question that \"No adjacent two numbers are same\" ?\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "after reading this (all before the 3 clues) I went and solved it in log(n) time, thanks for motivating me for doing so."
                    },
                    {
                        "username": "sohamdixit",
                        "content": "Agreed, but also for such questions where there is a trivial solution, I think the testcases need to be strong enough to not accept the trivial solution. In this case an O(n) solution should give a TLE, but it gets accepted, giving a misleading and false sense of having solved the problem in the best possible time to many people."
                    },
                    {
                        "username": "lavishmalik",
                        "content": "In both the questions you have to find peak elements but the catch is:\\n\\n-In leetcode 852 the array is increasingly and decreasingly sorted i.e its a bitonic array so you can apply modified binary search and find the global peak easily.\\n\\n-In this question(162), the given array is not sorted so they have given that there will be many peak elements and you can find any peak using binary search and return it .\\nBut you can\\'t find global peak in this question  just by applying binary search like previous question(852) because array is unsorted therefore after finding mid you can\\'t decide which side to go  for finding global peak.\\n\\n//Pls upvote if you like my solution\\n"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "the same code works for this also\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "So, How we do this."
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "The question doesn\\'t say the array is sorted, how do we know to use binary search ?"
                    },
                    {
                        "username": "cheekubhai",
                        "content": "The indexes form a sorted array"
                    },
                    {
                        "username": "premranjn",
                        "content": "there is a concept called binary search on answer, the sole idea of binary search in not only about finding a target in a sorted array, but to half the sample space after each decision.\\nSo here :\\nint findPeakElement(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if((mid == nums.size()-1)||nums[mid]>nums[mid+1] && ((mid == 0) || nums[mid]>nums[mid-1]))\\n                return mid;\\n            else if(mid==0)\\n                start = mid+1;\\n            else if(mid == nums.size()-1)\\n                end = mid-1;\\n            else if(nums[mid-1] < nums[mid])\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        return -1;\\n    }\\nif you would notice I am removing the half of the sample space each time i find the mid, using certain parameters.\\nHope It Helps ;)"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "[@ahmad-saeed](/ahmad-saeed) Sorting is an O(NLogN) process which is worse than doing a plain old linear search. Besides, you are supposed to return the index of the peak in its original position so you shouldn\\'t mutate the array in any way."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@pstrait](/pstrait) then i can just sort it in O(log n) then return the last in o(1) which satisfies the requirement without searching!"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "because  they said to do in 0(log n)  which is time complexty of binary search"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "Who said binary search can only applied on sorted arrays ?"
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "[@ssy55ssy](/ssy55ssy) can you please tell why that will work "
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "when the element is larger than it\\'s former element but it\\'s smaller than it\\'s later element,then the peak must appear behind it"
                    },
                    {
                        "username": "deadbycoffee",
                        "content": "I think it was just helpful that there could be multiple peaks. And because of that, you\\'re able to have a better chance of moving the left and right borders of the search based on what\\'s higher, mid, mid - 1, or mid + 1. Eventually either finding a peak or not finding one."
                    },
                    {
                        "username": "Altum_pax",
                        "content": "[@pstrait](/pstrait) Exactly that\\'s the catch!"
                    },
                    {
                        "username": "pstrait",
                        "content": "The array isn\\'t sorted; if it was sorted, the answer would just be the last element."
                    },
                    {
                        "username": "heejincs",
                        "content": "We can do simple binary search that check [mid] point and [mid+1] point and take half which has higher value, i.e. take left half if nums[mid]>nums[mid+1].\\nIt is not easy to show or proof why this works. \\nThe simple proof is that we take part of numbers that boundary condition holds true.\\nThat is, we only take search range (l, r) if nums[l-1]<nums[l] and num[r]>num[r+1]. Note that initial search range (l,r) where l=0 and r=len(nums)-1 holds true. Then, each step we reduce the search range half making sure the boundary condition holds true. Note that the other half the condition does not hold true.\\nTherefore, when it finally is reduced to a single number, it is the local maximum since the boundary condition for a single number is same as the condition for local maximum.\\n\\n"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I dont\\' understand the advantage of doing a linear search from 2 directions - \\n\\nlike what if your array is almost sorted with the peak occurring somewhere far away from mids\\n\\nlike 1,2,7,11,9,15,16,......,10000\\n\\nsay if you try a binary search on this array, it gives you almost nothing"
                    },
                    {
                        "username": "juciy_eggplant",
                        "content": "We know that for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF. From these conditions, we can prove that there must exist such an i that is peak, nums[i] > nums[i-1] and nums[i] > nums[i+1]:\\nSuppose there is no  i such that nums[i] > nums[i-1] and nums[i] > nums[i+1], then there are two cases:\\n1. if nums[i] > nums[i-1], it implies nums[i] < nums[i+1] for all i. however, this contradicts nums[n] == -INF\\n2. if nums[i] > nums[i+1], it implies nums[i] < nums[i-1] for all i which contradicts nums[-1] == -INF\\nQED\\n\\nNow we know that there must exist a peak i, we can derive the algorithm\\n1. if nums[m] < nums[m+1], then we know the right half is also an array where for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF (or to be more precise any x such that x < nums[i_0] && x < nums[i_n-1] and we know there must exist a peak\\n2. if nums[m] > nums[m+1], same logic applies for the left half"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Oh ok! I get it now. The whole magic lies in the sentence \"an element is always considered to be strictly greater than a neighbor that is outside the array.\" \\nThanks for the great comment! "
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Thank you very much for explanation sir :) Best explanation :)"
                    },
                    {
                        "username": "brianSalk",
                        "content": "In the comments section I see a lot of people saying that they do not know how they could come up with the binary search solution on their own in a short amount of time like the time that is allowed during an interview.\\n\\nFirst of all, you should be familiar with binary search, for it is a very common algorithm that can be modified to solve many problems that involve searching.\\nSecond, the question says that your algorithm must run in O(logN), which means that linear scan is out of the question.\\nIf you ever have a problem that involves searching for some element in a list in O(logN) time, you are probably limited to some variation of binary search as your only choice.  \\n\\n"
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "exactly O(logN) implies binary search modification.\\n"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe problem should state that there is only one peak in the sequence. Otherwise logarithmic complexity is not possible.\\n\\nFor example:\\n[1,2,1,3,4,5,0] has two peaks: 2 and 5. In such case, the search is O(n)."
                    },
                    {
                        "username": "pstrait",
                        "content": "No because you can stop at the first peak."
                    },
                    {
                        "username": "zeddysoft",
                        "content": "Hello folks,\\n\\nCan anyone here enlighten me on the significance of a question that has more downvote than upvotes. more specifically, should this type of question be avoided?\\n"
                    },
                    {
                        "username": "chaudharyrittik_26",
                        "content": "i also have the same question, can you tell me if you\\'ve got the answer\\n\\n"
                    },
                    {
                        "username": "thebigjuicyd",
                        "content": "no idea what you are talking about"
                    },
                    {
                        "username": "Ricola",
                        "content": "I don't get why I got this error while I never used an array in my answer.\\n\\nI think they edited the question, because the beginning of the solution is \"public int findPeakElement(List nums) {\" and in the answers, I saw people using an array of int.\\n\\nI tried using an array it doesn't work either."
                    },
                    {
                        "username": "tourist44",
                        "content": "It should say that peak element is an elemet which is greater than or equals to its neighbours and not strictly greater than its neighbours.\\nThats when this outcome would be correct.\\n![image](https://assets.leetcode.com/users/images/3e017fa3-9f28-4ac9-87b7-e3b0da7817f1_1600229691.3791375.png)\\n"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "one reason the answer is not -1 is because in the constraint it's mentioned that nums[-1] =nums[n]=-infinity hence if an array contains single digit then we will return 0 as it's bigger than -infinity. maybe that's why it's saying wrong answer. \nyou can see as it's written here-\nIn other words, an element is always considered to be strictly greater than a neighbor that is outside the array. Hence the answer would be 2 and not -1.\n"
                    },
                    {
                        "username": "davidtn",
                        "content": "Your test case is bad input because 1 of the 3 constraints down at the bottom is that no adjacent elements equal each other."
                    }
                ]
            },
            {
                "id": 1565945,
                "content": [
                    {
                        "username": "amoicity",
                        "content": "When people see ths question, I think most people will immediately come up with the linear search solution, which is to examine each num and compare it with its two neighbours. No braniner, right? Then people are thinking why this kind of question would  appear in the question pool and why it\\'s even rated as Medium. Then they might go to the Solution tab and see someone writing up a big article explaining a better solution and probably think, why bother? That\\'s an overkill. \\n\\nThese types of questions are so undervalued by people. And these are the questions we should pay more attention to. I\\'m sure in a real question, the interviewer will not be satisfied by the linear solution. Why? Because the straightforward linear scan solution isn\\'t using all of the clues given in the question. These clues, including\\n1. No adjacent two numbers are the same\\n2. the two end of the arrays are -\\u221E\\n3. You can return any peak.\\n\\nare all the clues that we can base upon to get to the final BS solution. When you are reading a question, pay great attention to these clues. If your solution does not involve all of the clue provided, you might not get the optimal solution. This is not any random question, it\\'s asked by Facebook, Google, etc., for multiple times. There is a reason why it exist and please don\\'t downvote it without even attempting to understand it."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@olsonpm](/olsonpm) I guess criticism of premature optimization originally intended to direct programmer\\'s effort into the best way of optimizing code. But now it\\'s most often used as an argument against any optimization."
                    },
                    {
                        "username": "olsonpm",
                        "content": "Questions like this that don\\'t enforce the optimal solution are a poor way to test devs.  In the real world, investing time into an unnecessary optimization is called premature optimization, and is a poor use of time as well as over-complicates the code."
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Mate, your tip is the best discussion section post template i always want to see :)"
                    },
                    {
                        "username": "sergei99",
                        "content": "Thanks mate. I had initially though that there was a mistake in the task description, but after your comment just sat down and wrote a few example lists of numbers. And then it took just a dozen lines of C++ code, including all the edge cases, to get 0ms execution time with 100% users beaten. :-)"
                    },
                    {
                        "username": "vaibhavbhatt59",
                        "content": "thanks bro i am going for see the solution  but bymistake i open discussion and see your comment on top . then i give another try to the question  and i did it . thanks bro\\n"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "i was getting frustrated and was going to look out for solutions but this comment pushed me and it clicked after few more minutes .... great question btw\\n"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "why u shudn\\'t skip questions with large no of downvotes without reading yourself"
                    },
                    {
                        "username": "madhavmaheshwarimm20",
                        "content": "[@armashhashmi](/armashhashmi) in constraints last point"
                    },
                    {
                        "username": "pyush98",
                        "content": "[@armashhashmi](/armashhashmi) \\n\\nnums[i] != nums[i + 1] for all valid i\\n\\nwrittein at bottom in smallest possible text XD"
                    },
                    {
                        "username": "armashhashmi",
                        "content": "where is it written in the question that \"No adjacent two numbers are same\" ?\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "after reading this (all before the 3 clues) I went and solved it in log(n) time, thanks for motivating me for doing so."
                    },
                    {
                        "username": "sohamdixit",
                        "content": "Agreed, but also for such questions where there is a trivial solution, I think the testcases need to be strong enough to not accept the trivial solution. In this case an O(n) solution should give a TLE, but it gets accepted, giving a misleading and false sense of having solved the problem in the best possible time to many people."
                    },
                    {
                        "username": "lavishmalik",
                        "content": "In both the questions you have to find peak elements but the catch is:\\n\\n-In leetcode 852 the array is increasingly and decreasingly sorted i.e its a bitonic array so you can apply modified binary search and find the global peak easily.\\n\\n-In this question(162), the given array is not sorted so they have given that there will be many peak elements and you can find any peak using binary search and return it .\\nBut you can\\'t find global peak in this question  just by applying binary search like previous question(852) because array is unsorted therefore after finding mid you can\\'t decide which side to go  for finding global peak.\\n\\n//Pls upvote if you like my solution\\n"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "the same code works for this also\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "So, How we do this."
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "The question doesn\\'t say the array is sorted, how do we know to use binary search ?"
                    },
                    {
                        "username": "cheekubhai",
                        "content": "The indexes form a sorted array"
                    },
                    {
                        "username": "premranjn",
                        "content": "there is a concept called binary search on answer, the sole idea of binary search in not only about finding a target in a sorted array, but to half the sample space after each decision.\\nSo here :\\nint findPeakElement(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if((mid == nums.size()-1)||nums[mid]>nums[mid+1] && ((mid == 0) || nums[mid]>nums[mid-1]))\\n                return mid;\\n            else if(mid==0)\\n                start = mid+1;\\n            else if(mid == nums.size()-1)\\n                end = mid-1;\\n            else if(nums[mid-1] < nums[mid])\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        return -1;\\n    }\\nif you would notice I am removing the half of the sample space each time i find the mid, using certain parameters.\\nHope It Helps ;)"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "[@ahmad-saeed](/ahmad-saeed) Sorting is an O(NLogN) process which is worse than doing a plain old linear search. Besides, you are supposed to return the index of the peak in its original position so you shouldn\\'t mutate the array in any way."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@pstrait](/pstrait) then i can just sort it in O(log n) then return the last in o(1) which satisfies the requirement without searching!"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "because  they said to do in 0(log n)  which is time complexty of binary search"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "Who said binary search can only applied on sorted arrays ?"
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "[@ssy55ssy](/ssy55ssy) can you please tell why that will work "
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "when the element is larger than it\\'s former element but it\\'s smaller than it\\'s later element,then the peak must appear behind it"
                    },
                    {
                        "username": "deadbycoffee",
                        "content": "I think it was just helpful that there could be multiple peaks. And because of that, you\\'re able to have a better chance of moving the left and right borders of the search based on what\\'s higher, mid, mid - 1, or mid + 1. Eventually either finding a peak or not finding one."
                    },
                    {
                        "username": "Altum_pax",
                        "content": "[@pstrait](/pstrait) Exactly that\\'s the catch!"
                    },
                    {
                        "username": "pstrait",
                        "content": "The array isn\\'t sorted; if it was sorted, the answer would just be the last element."
                    },
                    {
                        "username": "heejincs",
                        "content": "We can do simple binary search that check [mid] point and [mid+1] point and take half which has higher value, i.e. take left half if nums[mid]>nums[mid+1].\\nIt is not easy to show or proof why this works. \\nThe simple proof is that we take part of numbers that boundary condition holds true.\\nThat is, we only take search range (l, r) if nums[l-1]<nums[l] and num[r]>num[r+1]. Note that initial search range (l,r) where l=0 and r=len(nums)-1 holds true. Then, each step we reduce the search range half making sure the boundary condition holds true. Note that the other half the condition does not hold true.\\nTherefore, when it finally is reduced to a single number, it is the local maximum since the boundary condition for a single number is same as the condition for local maximum.\\n\\n"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I dont\\' understand the advantage of doing a linear search from 2 directions - \\n\\nlike what if your array is almost sorted with the peak occurring somewhere far away from mids\\n\\nlike 1,2,7,11,9,15,16,......,10000\\n\\nsay if you try a binary search on this array, it gives you almost nothing"
                    },
                    {
                        "username": "juciy_eggplant",
                        "content": "We know that for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF. From these conditions, we can prove that there must exist such an i that is peak, nums[i] > nums[i-1] and nums[i] > nums[i+1]:\\nSuppose there is no  i such that nums[i] > nums[i-1] and nums[i] > nums[i+1], then there are two cases:\\n1. if nums[i] > nums[i-1], it implies nums[i] < nums[i+1] for all i. however, this contradicts nums[n] == -INF\\n2. if nums[i] > nums[i+1], it implies nums[i] < nums[i-1] for all i which contradicts nums[-1] == -INF\\nQED\\n\\nNow we know that there must exist a peak i, we can derive the algorithm\\n1. if nums[m] < nums[m+1], then we know the right half is also an array where for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF (or to be more precise any x such that x < nums[i_0] && x < nums[i_n-1] and we know there must exist a peak\\n2. if nums[m] > nums[m+1], same logic applies for the left half"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Oh ok! I get it now. The whole magic lies in the sentence \"an element is always considered to be strictly greater than a neighbor that is outside the array.\" \\nThanks for the great comment! "
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Thank you very much for explanation sir :) Best explanation :)"
                    },
                    {
                        "username": "brianSalk",
                        "content": "In the comments section I see a lot of people saying that they do not know how they could come up with the binary search solution on their own in a short amount of time like the time that is allowed during an interview.\\n\\nFirst of all, you should be familiar with binary search, for it is a very common algorithm that can be modified to solve many problems that involve searching.\\nSecond, the question says that your algorithm must run in O(logN), which means that linear scan is out of the question.\\nIf you ever have a problem that involves searching for some element in a list in O(logN) time, you are probably limited to some variation of binary search as your only choice.  \\n\\n"
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "exactly O(logN) implies binary search modification.\\n"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe problem should state that there is only one peak in the sequence. Otherwise logarithmic complexity is not possible.\\n\\nFor example:\\n[1,2,1,3,4,5,0] has two peaks: 2 and 5. In such case, the search is O(n)."
                    },
                    {
                        "username": "pstrait",
                        "content": "No because you can stop at the first peak."
                    },
                    {
                        "username": "zeddysoft",
                        "content": "Hello folks,\\n\\nCan anyone here enlighten me on the significance of a question that has more downvote than upvotes. more specifically, should this type of question be avoided?\\n"
                    },
                    {
                        "username": "chaudharyrittik_26",
                        "content": "i also have the same question, can you tell me if you\\'ve got the answer\\n\\n"
                    },
                    {
                        "username": "thebigjuicyd",
                        "content": "no idea what you are talking about"
                    },
                    {
                        "username": "Ricola",
                        "content": "I don't get why I got this error while I never used an array in my answer.\\n\\nI think they edited the question, because the beginning of the solution is \"public int findPeakElement(List nums) {\" and in the answers, I saw people using an array of int.\\n\\nI tried using an array it doesn't work either."
                    },
                    {
                        "username": "tourist44",
                        "content": "It should say that peak element is an elemet which is greater than or equals to its neighbours and not strictly greater than its neighbours.\\nThats when this outcome would be correct.\\n![image](https://assets.leetcode.com/users/images/3e017fa3-9f28-4ac9-87b7-e3b0da7817f1_1600229691.3791375.png)\\n"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "one reason the answer is not -1 is because in the constraint it's mentioned that nums[-1] =nums[n]=-infinity hence if an array contains single digit then we will return 0 as it's bigger than -infinity. maybe that's why it's saying wrong answer. \nyou can see as it's written here-\nIn other words, an element is always considered to be strictly greater than a neighbor that is outside the array. Hence the answer would be 2 and not -1.\n"
                    },
                    {
                        "username": "davidtn",
                        "content": "Your test case is bad input because 1 of the 3 constraints down at the bottom is that no adjacent elements equal each other."
                    }
                ]
            },
            {
                "id": 1570166,
                "content": [
                    {
                        "username": "amoicity",
                        "content": "When people see ths question, I think most people will immediately come up with the linear search solution, which is to examine each num and compare it with its two neighbours. No braniner, right? Then people are thinking why this kind of question would  appear in the question pool and why it\\'s even rated as Medium. Then they might go to the Solution tab and see someone writing up a big article explaining a better solution and probably think, why bother? That\\'s an overkill. \\n\\nThese types of questions are so undervalued by people. And these are the questions we should pay more attention to. I\\'m sure in a real question, the interviewer will not be satisfied by the linear solution. Why? Because the straightforward linear scan solution isn\\'t using all of the clues given in the question. These clues, including\\n1. No adjacent two numbers are the same\\n2. the two end of the arrays are -\\u221E\\n3. You can return any peak.\\n\\nare all the clues that we can base upon to get to the final BS solution. When you are reading a question, pay great attention to these clues. If your solution does not involve all of the clue provided, you might not get the optimal solution. This is not any random question, it\\'s asked by Facebook, Google, etc., for multiple times. There is a reason why it exist and please don\\'t downvote it without even attempting to understand it."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@olsonpm](/olsonpm) I guess criticism of premature optimization originally intended to direct programmer\\'s effort into the best way of optimizing code. But now it\\'s most often used as an argument against any optimization."
                    },
                    {
                        "username": "olsonpm",
                        "content": "Questions like this that don\\'t enforce the optimal solution are a poor way to test devs.  In the real world, investing time into an unnecessary optimization is called premature optimization, and is a poor use of time as well as over-complicates the code."
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Mate, your tip is the best discussion section post template i always want to see :)"
                    },
                    {
                        "username": "sergei99",
                        "content": "Thanks mate. I had initially though that there was a mistake in the task description, but after your comment just sat down and wrote a few example lists of numbers. And then it took just a dozen lines of C++ code, including all the edge cases, to get 0ms execution time with 100% users beaten. :-)"
                    },
                    {
                        "username": "vaibhavbhatt59",
                        "content": "thanks bro i am going for see the solution  but bymistake i open discussion and see your comment on top . then i give another try to the question  and i did it . thanks bro\\n"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "i was getting frustrated and was going to look out for solutions but this comment pushed me and it clicked after few more minutes .... great question btw\\n"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "why u shudn\\'t skip questions with large no of downvotes without reading yourself"
                    },
                    {
                        "username": "madhavmaheshwarimm20",
                        "content": "[@armashhashmi](/armashhashmi) in constraints last point"
                    },
                    {
                        "username": "pyush98",
                        "content": "[@armashhashmi](/armashhashmi) \\n\\nnums[i] != nums[i + 1] for all valid i\\n\\nwrittein at bottom in smallest possible text XD"
                    },
                    {
                        "username": "armashhashmi",
                        "content": "where is it written in the question that \"No adjacent two numbers are same\" ?\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "after reading this (all before the 3 clues) I went and solved it in log(n) time, thanks for motivating me for doing so."
                    },
                    {
                        "username": "sohamdixit",
                        "content": "Agreed, but also for such questions where there is a trivial solution, I think the testcases need to be strong enough to not accept the trivial solution. In this case an O(n) solution should give a TLE, but it gets accepted, giving a misleading and false sense of having solved the problem in the best possible time to many people."
                    },
                    {
                        "username": "lavishmalik",
                        "content": "In both the questions you have to find peak elements but the catch is:\\n\\n-In leetcode 852 the array is increasingly and decreasingly sorted i.e its a bitonic array so you can apply modified binary search and find the global peak easily.\\n\\n-In this question(162), the given array is not sorted so they have given that there will be many peak elements and you can find any peak using binary search and return it .\\nBut you can\\'t find global peak in this question  just by applying binary search like previous question(852) because array is unsorted therefore after finding mid you can\\'t decide which side to go  for finding global peak.\\n\\n//Pls upvote if you like my solution\\n"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "the same code works for this also\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "So, How we do this."
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "The question doesn\\'t say the array is sorted, how do we know to use binary search ?"
                    },
                    {
                        "username": "cheekubhai",
                        "content": "The indexes form a sorted array"
                    },
                    {
                        "username": "premranjn",
                        "content": "there is a concept called binary search on answer, the sole idea of binary search in not only about finding a target in a sorted array, but to half the sample space after each decision.\\nSo here :\\nint findPeakElement(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if((mid == nums.size()-1)||nums[mid]>nums[mid+1] && ((mid == 0) || nums[mid]>nums[mid-1]))\\n                return mid;\\n            else if(mid==0)\\n                start = mid+1;\\n            else if(mid == nums.size()-1)\\n                end = mid-1;\\n            else if(nums[mid-1] < nums[mid])\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        return -1;\\n    }\\nif you would notice I am removing the half of the sample space each time i find the mid, using certain parameters.\\nHope It Helps ;)"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "[@ahmad-saeed](/ahmad-saeed) Sorting is an O(NLogN) process which is worse than doing a plain old linear search. Besides, you are supposed to return the index of the peak in its original position so you shouldn\\'t mutate the array in any way."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@pstrait](/pstrait) then i can just sort it in O(log n) then return the last in o(1) which satisfies the requirement without searching!"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "because  they said to do in 0(log n)  which is time complexty of binary search"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "Who said binary search can only applied on sorted arrays ?"
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "[@ssy55ssy](/ssy55ssy) can you please tell why that will work "
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "when the element is larger than it\\'s former element but it\\'s smaller than it\\'s later element,then the peak must appear behind it"
                    },
                    {
                        "username": "deadbycoffee",
                        "content": "I think it was just helpful that there could be multiple peaks. And because of that, you\\'re able to have a better chance of moving the left and right borders of the search based on what\\'s higher, mid, mid - 1, or mid + 1. Eventually either finding a peak or not finding one."
                    },
                    {
                        "username": "Altum_pax",
                        "content": "[@pstrait](/pstrait) Exactly that\\'s the catch!"
                    },
                    {
                        "username": "pstrait",
                        "content": "The array isn\\'t sorted; if it was sorted, the answer would just be the last element."
                    },
                    {
                        "username": "heejincs",
                        "content": "We can do simple binary search that check [mid] point and [mid+1] point and take half which has higher value, i.e. take left half if nums[mid]>nums[mid+1].\\nIt is not easy to show or proof why this works. \\nThe simple proof is that we take part of numbers that boundary condition holds true.\\nThat is, we only take search range (l, r) if nums[l-1]<nums[l] and num[r]>num[r+1]. Note that initial search range (l,r) where l=0 and r=len(nums)-1 holds true. Then, each step we reduce the search range half making sure the boundary condition holds true. Note that the other half the condition does not hold true.\\nTherefore, when it finally is reduced to a single number, it is the local maximum since the boundary condition for a single number is same as the condition for local maximum.\\n\\n"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I dont\\' understand the advantage of doing a linear search from 2 directions - \\n\\nlike what if your array is almost sorted with the peak occurring somewhere far away from mids\\n\\nlike 1,2,7,11,9,15,16,......,10000\\n\\nsay if you try a binary search on this array, it gives you almost nothing"
                    },
                    {
                        "username": "juciy_eggplant",
                        "content": "We know that for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF. From these conditions, we can prove that there must exist such an i that is peak, nums[i] > nums[i-1] and nums[i] > nums[i+1]:\\nSuppose there is no  i such that nums[i] > nums[i-1] and nums[i] > nums[i+1], then there are two cases:\\n1. if nums[i] > nums[i-1], it implies nums[i] < nums[i+1] for all i. however, this contradicts nums[n] == -INF\\n2. if nums[i] > nums[i+1], it implies nums[i] < nums[i-1] for all i which contradicts nums[-1] == -INF\\nQED\\n\\nNow we know that there must exist a peak i, we can derive the algorithm\\n1. if nums[m] < nums[m+1], then we know the right half is also an array where for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF (or to be more precise any x such that x < nums[i_0] && x < nums[i_n-1] and we know there must exist a peak\\n2. if nums[m] > nums[m+1], same logic applies for the left half"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Oh ok! I get it now. The whole magic lies in the sentence \"an element is always considered to be strictly greater than a neighbor that is outside the array.\" \\nThanks for the great comment! "
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Thank you very much for explanation sir :) Best explanation :)"
                    },
                    {
                        "username": "brianSalk",
                        "content": "In the comments section I see a lot of people saying that they do not know how they could come up with the binary search solution on their own in a short amount of time like the time that is allowed during an interview.\\n\\nFirst of all, you should be familiar with binary search, for it is a very common algorithm that can be modified to solve many problems that involve searching.\\nSecond, the question says that your algorithm must run in O(logN), which means that linear scan is out of the question.\\nIf you ever have a problem that involves searching for some element in a list in O(logN) time, you are probably limited to some variation of binary search as your only choice.  \\n\\n"
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "exactly O(logN) implies binary search modification.\\n"
                    },
                    {
                        "username": "liyiou",
                        "content": "\\nThe problem should state that there is only one peak in the sequence. Otherwise logarithmic complexity is not possible.\\n\\nFor example:\\n[1,2,1,3,4,5,0] has two peaks: 2 and 5. In such case, the search is O(n)."
                    },
                    {
                        "username": "pstrait",
                        "content": "No because you can stop at the first peak."
                    },
                    {
                        "username": "zeddysoft",
                        "content": "Hello folks,\\n\\nCan anyone here enlighten me on the significance of a question that has more downvote than upvotes. more specifically, should this type of question be avoided?\\n"
                    },
                    {
                        "username": "chaudharyrittik_26",
                        "content": "i also have the same question, can you tell me if you\\'ve got the answer\\n\\n"
                    },
                    {
                        "username": "thebigjuicyd",
                        "content": "no idea what you are talking about"
                    },
                    {
                        "username": "Ricola",
                        "content": "I don't get why I got this error while I never used an array in my answer.\\n\\nI think they edited the question, because the beginning of the solution is \"public int findPeakElement(List nums) {\" and in the answers, I saw people using an array of int.\\n\\nI tried using an array it doesn't work either."
                    },
                    {
                        "username": "tourist44",
                        "content": "It should say that peak element is an elemet which is greater than or equals to its neighbours and not strictly greater than its neighbours.\\nThats when this outcome would be correct.\\n![image](https://assets.leetcode.com/users/images/3e017fa3-9f28-4ac9-87b7-e3b0da7817f1_1600229691.3791375.png)\\n"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "one reason the answer is not -1 is because in the constraint it's mentioned that nums[-1] =nums[n]=-infinity hence if an array contains single digit then we will return 0 as it's bigger than -infinity. maybe that's why it's saying wrong answer. \nyou can see as it's written here-\nIn other words, an element is always considered to be strictly greater than a neighbor that is outside the array. Hence the answer would be 2 and not -1.\n"
                    },
                    {
                        "username": "davidtn",
                        "content": "Your test case is bad input because 1 of the 3 constraints down at the bottom is that no adjacent elements equal each other."
                    }
                ]
            },
            {
                "id": 1571355,
                "content": [
                    {
                        "username": "Eric_Song",
                        "content": "Many people give the solution of O(lg(n)) time complexity. But all these solutions are based on some certain data structure such as binary tree. Build such a tree will cost another O(nlg(n)) time. So why not directly find the max of the array?"
                    },
                    {
                        "username": "jerry_TAMU",
                        "content": "not a binary tree, it is binary search."
                    },
                    {
                        "username": "kritikjain9",
                        "content": "In the question description, it is mentioned that \"You may imagine that nums[-1] = nums[n] = -\\u221E\", my question is what does this mean? Like why is it mentioned there anyway?"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "It means the first and last indexes can also be peak element. let say 1 2 3 4 5 here peak is 5 as 5>4 and 5>-infinity. "
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "for [ -2147483648 ] why ans is 0   as -1 and n contains value INT_MIN\\nwhich is equal but not less???"
                    },
                    {
                        "username": "adamlhh",
                        "content": "Let\\'s say input array is of the same value, for example, [1,1,1], then there is no peak element. However, OJ seems to treat each element a valid peak element."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "if u see there is a point arr[i]!=arr[i+1]"
                    },
                    {
                        "username": "sanjoyd",
                        "content": "The problem says that \"A peak element is an element that is greater than its neighbors.\" but for there to be a logN solution the statement needs to be \"A peak element is an element that is greater than *or equal to* its neighbors.\".\\n\\nIn particular, given what the problem says today, there may be sequences *without a peak element*. (e.g. [1,1])."
                    },
                    {
                        "username": "alok5",
                        "content": "\\n![Peak element time distribution for C++, Python and Java][2]\\n\\n  [2]: http://s29.postimg.org/u675h1bbr/Peak_Element.png"
                    },
                    {
                        "username": "lx19930",
                        "content": "Global maximum must be a local maximum.\\n\\nreturn nums.index(max(nums))"
                    },
                    {
                        "username": "jason3410",
                        "content": "Far away from O(log(n)) dude."
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "But in the problem statement, they clearly mentioned that you have to write the algorithm that takes O(logn)."
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "Though it is short and sweet, it still takes O(n) and not O(logN)"
                    },
                    {
                        "username": "dark",
                        "content": "this problem is quite easy and simple"
                    },
                    {
                        "username": "user7412hz",
                        "content": "i\\'ll just leave a little hint on the concept here!!\\nThe word peak tells it\\'s kinda like a hill or a mountain. So , the peak of the mountain doesn\\'t necessarily have to be at center. \\nlet\\'s say the peak is close to the right side like [1,2,1,3,5,6,4] this one. you\\'ll have to climb more on the left side (meaning increase the left side and find the peak) and vice versa..."
                    },
                    {
                        "username": "krobzh",
                        "content": "I think the key point of this problem is to find there must be a peak in [mid+1, r] if nums[mid] < nums[mid+1].\nAnd there will always be at least one peak element whatever the array is. "
                    }
                ]
            },
            {
                "id": 1576168,
                "content": [
                    {
                        "username": "Eric_Song",
                        "content": "Many people give the solution of O(lg(n)) time complexity. But all these solutions are based on some certain data structure such as binary tree. Build such a tree will cost another O(nlg(n)) time. So why not directly find the max of the array?"
                    },
                    {
                        "username": "jerry_TAMU",
                        "content": "not a binary tree, it is binary search."
                    },
                    {
                        "username": "kritikjain9",
                        "content": "In the question description, it is mentioned that \"You may imagine that nums[-1] = nums[n] = -\\u221E\", my question is what does this mean? Like why is it mentioned there anyway?"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "It means the first and last indexes can also be peak element. let say 1 2 3 4 5 here peak is 5 as 5>4 and 5>-infinity. "
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "for [ -2147483648 ] why ans is 0   as -1 and n contains value INT_MIN\\nwhich is equal but not less???"
                    },
                    {
                        "username": "adamlhh",
                        "content": "Let\\'s say input array is of the same value, for example, [1,1,1], then there is no peak element. However, OJ seems to treat each element a valid peak element."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "if u see there is a point arr[i]!=arr[i+1]"
                    },
                    {
                        "username": "sanjoyd",
                        "content": "The problem says that \"A peak element is an element that is greater than its neighbors.\" but for there to be a logN solution the statement needs to be \"A peak element is an element that is greater than *or equal to* its neighbors.\".\\n\\nIn particular, given what the problem says today, there may be sequences *without a peak element*. (e.g. [1,1])."
                    },
                    {
                        "username": "alok5",
                        "content": "\\n![Peak element time distribution for C++, Python and Java][2]\\n\\n  [2]: http://s29.postimg.org/u675h1bbr/Peak_Element.png"
                    },
                    {
                        "username": "lx19930",
                        "content": "Global maximum must be a local maximum.\\n\\nreturn nums.index(max(nums))"
                    },
                    {
                        "username": "jason3410",
                        "content": "Far away from O(log(n)) dude."
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "But in the problem statement, they clearly mentioned that you have to write the algorithm that takes O(logn)."
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "Though it is short and sweet, it still takes O(n) and not O(logN)"
                    },
                    {
                        "username": "dark",
                        "content": "this problem is quite easy and simple"
                    },
                    {
                        "username": "user7412hz",
                        "content": "i\\'ll just leave a little hint on the concept here!!\\nThe word peak tells it\\'s kinda like a hill or a mountain. So , the peak of the mountain doesn\\'t necessarily have to be at center. \\nlet\\'s say the peak is close to the right side like [1,2,1,3,5,6,4] this one. you\\'ll have to climb more on the left side (meaning increase the left side and find the peak) and vice versa..."
                    },
                    {
                        "username": "krobzh",
                        "content": "I think the key point of this problem is to find there must be a peak in [mid+1, r] if nums[mid] < nums[mid+1].\nAnd there will always be at least one peak element whatever the array is. "
                    }
                ]
            },
            {
                "id": 1575529,
                "content": [
                    {
                        "username": "Eric_Song",
                        "content": "Many people give the solution of O(lg(n)) time complexity. But all these solutions are based on some certain data structure such as binary tree. Build such a tree will cost another O(nlg(n)) time. So why not directly find the max of the array?"
                    },
                    {
                        "username": "jerry_TAMU",
                        "content": "not a binary tree, it is binary search."
                    },
                    {
                        "username": "kritikjain9",
                        "content": "In the question description, it is mentioned that \"You may imagine that nums[-1] = nums[n] = -\\u221E\", my question is what does this mean? Like why is it mentioned there anyway?"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "It means the first and last indexes can also be peak element. let say 1 2 3 4 5 here peak is 5 as 5>4 and 5>-infinity. "
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "for [ -2147483648 ] why ans is 0   as -1 and n contains value INT_MIN\\nwhich is equal but not less???"
                    },
                    {
                        "username": "adamlhh",
                        "content": "Let\\'s say input array is of the same value, for example, [1,1,1], then there is no peak element. However, OJ seems to treat each element a valid peak element."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "if u see there is a point arr[i]!=arr[i+1]"
                    },
                    {
                        "username": "sanjoyd",
                        "content": "The problem says that \"A peak element is an element that is greater than its neighbors.\" but for there to be a logN solution the statement needs to be \"A peak element is an element that is greater than *or equal to* its neighbors.\".\\n\\nIn particular, given what the problem says today, there may be sequences *without a peak element*. (e.g. [1,1])."
                    },
                    {
                        "username": "alok5",
                        "content": "\\n![Peak element time distribution for C++, Python and Java][2]\\n\\n  [2]: http://s29.postimg.org/u675h1bbr/Peak_Element.png"
                    },
                    {
                        "username": "lx19930",
                        "content": "Global maximum must be a local maximum.\\n\\nreturn nums.index(max(nums))"
                    },
                    {
                        "username": "jason3410",
                        "content": "Far away from O(log(n)) dude."
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "But in the problem statement, they clearly mentioned that you have to write the algorithm that takes O(logn)."
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "Though it is short and sweet, it still takes O(n) and not O(logN)"
                    },
                    {
                        "username": "dark",
                        "content": "this problem is quite easy and simple"
                    },
                    {
                        "username": "user7412hz",
                        "content": "i\\'ll just leave a little hint on the concept here!!\\nThe word peak tells it\\'s kinda like a hill or a mountain. So , the peak of the mountain doesn\\'t necessarily have to be at center. \\nlet\\'s say the peak is close to the right side like [1,2,1,3,5,6,4] this one. you\\'ll have to climb more on the left side (meaning increase the left side and find the peak) and vice versa..."
                    },
                    {
                        "username": "krobzh",
                        "content": "I think the key point of this problem is to find there must be a peak in [mid+1, r] if nums[mid] < nums[mid+1].\nAnd there will always be at least one peak element whatever the array is. "
                    }
                ]
            },
            {
                "id": 1569505,
                "content": [
                    {
                        "username": "Eric_Song",
                        "content": "Many people give the solution of O(lg(n)) time complexity. But all these solutions are based on some certain data structure such as binary tree. Build such a tree will cost another O(nlg(n)) time. So why not directly find the max of the array?"
                    },
                    {
                        "username": "jerry_TAMU",
                        "content": "not a binary tree, it is binary search."
                    },
                    {
                        "username": "kritikjain9",
                        "content": "In the question description, it is mentioned that \"You may imagine that nums[-1] = nums[n] = -\\u221E\", my question is what does this mean? Like why is it mentioned there anyway?"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "It means the first and last indexes can also be peak element. let say 1 2 3 4 5 here peak is 5 as 5>4 and 5>-infinity. "
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "for [ -2147483648 ] why ans is 0   as -1 and n contains value INT_MIN\\nwhich is equal but not less???"
                    },
                    {
                        "username": "adamlhh",
                        "content": "Let\\'s say input array is of the same value, for example, [1,1,1], then there is no peak element. However, OJ seems to treat each element a valid peak element."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "if u see there is a point arr[i]!=arr[i+1]"
                    },
                    {
                        "username": "sanjoyd",
                        "content": "The problem says that \"A peak element is an element that is greater than its neighbors.\" but for there to be a logN solution the statement needs to be \"A peak element is an element that is greater than *or equal to* its neighbors.\".\\n\\nIn particular, given what the problem says today, there may be sequences *without a peak element*. (e.g. [1,1])."
                    },
                    {
                        "username": "alok5",
                        "content": "\\n![Peak element time distribution for C++, Python and Java][2]\\n\\n  [2]: http://s29.postimg.org/u675h1bbr/Peak_Element.png"
                    },
                    {
                        "username": "lx19930",
                        "content": "Global maximum must be a local maximum.\\n\\nreturn nums.index(max(nums))"
                    },
                    {
                        "username": "jason3410",
                        "content": "Far away from O(log(n)) dude."
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "But in the problem statement, they clearly mentioned that you have to write the algorithm that takes O(logn)."
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "Though it is short and sweet, it still takes O(n) and not O(logN)"
                    },
                    {
                        "username": "dark",
                        "content": "this problem is quite easy and simple"
                    },
                    {
                        "username": "user7412hz",
                        "content": "i\\'ll just leave a little hint on the concept here!!\\nThe word peak tells it\\'s kinda like a hill or a mountain. So , the peak of the mountain doesn\\'t necessarily have to be at center. \\nlet\\'s say the peak is close to the right side like [1,2,1,3,5,6,4] this one. you\\'ll have to climb more on the left side (meaning increase the left side and find the peak) and vice versa..."
                    },
                    {
                        "username": "krobzh",
                        "content": "I think the key point of this problem is to find there must be a peak in [mid+1, r] if nums[mid] < nums[mid+1].\nAnd there will always be at least one peak element whatever the array is. "
                    }
                ]
            },
            {
                "id": 1571352,
                "content": [
                    {
                        "username": "Eric_Song",
                        "content": "Many people give the solution of O(lg(n)) time complexity. But all these solutions are based on some certain data structure such as binary tree. Build such a tree will cost another O(nlg(n)) time. So why not directly find the max of the array?"
                    },
                    {
                        "username": "jerry_TAMU",
                        "content": "not a binary tree, it is binary search."
                    },
                    {
                        "username": "kritikjain9",
                        "content": "In the question description, it is mentioned that \"You may imagine that nums[-1] = nums[n] = -\\u221E\", my question is what does this mean? Like why is it mentioned there anyway?"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "It means the first and last indexes can also be peak element. let say 1 2 3 4 5 here peak is 5 as 5>4 and 5>-infinity. "
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "for [ -2147483648 ] why ans is 0   as -1 and n contains value INT_MIN\\nwhich is equal but not less???"
                    },
                    {
                        "username": "adamlhh",
                        "content": "Let\\'s say input array is of the same value, for example, [1,1,1], then there is no peak element. However, OJ seems to treat each element a valid peak element."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "if u see there is a point arr[i]!=arr[i+1]"
                    },
                    {
                        "username": "sanjoyd",
                        "content": "The problem says that \"A peak element is an element that is greater than its neighbors.\" but for there to be a logN solution the statement needs to be \"A peak element is an element that is greater than *or equal to* its neighbors.\".\\n\\nIn particular, given what the problem says today, there may be sequences *without a peak element*. (e.g. [1,1])."
                    },
                    {
                        "username": "alok5",
                        "content": "\\n![Peak element time distribution for C++, Python and Java][2]\\n\\n  [2]: http://s29.postimg.org/u675h1bbr/Peak_Element.png"
                    },
                    {
                        "username": "lx19930",
                        "content": "Global maximum must be a local maximum.\\n\\nreturn nums.index(max(nums))"
                    },
                    {
                        "username": "jason3410",
                        "content": "Far away from O(log(n)) dude."
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "But in the problem statement, they clearly mentioned that you have to write the algorithm that takes O(logn)."
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "Though it is short and sweet, it still takes O(n) and not O(logN)"
                    },
                    {
                        "username": "dark",
                        "content": "this problem is quite easy and simple"
                    },
                    {
                        "username": "user7412hz",
                        "content": "i\\'ll just leave a little hint on the concept here!!\\nThe word peak tells it\\'s kinda like a hill or a mountain. So , the peak of the mountain doesn\\'t necessarily have to be at center. \\nlet\\'s say the peak is close to the right side like [1,2,1,3,5,6,4] this one. you\\'ll have to climb more on the left side (meaning increase the left side and find the peak) and vice versa..."
                    },
                    {
                        "username": "krobzh",
                        "content": "I think the key point of this problem is to find there must be a peak in [mid+1, r] if nums[mid] < nums[mid+1].\nAnd there will always be at least one peak element whatever the array is. "
                    }
                ]
            },
            {
                "id": 1568990,
                "content": [
                    {
                        "username": "Eric_Song",
                        "content": "Many people give the solution of O(lg(n)) time complexity. But all these solutions are based on some certain data structure such as binary tree. Build such a tree will cost another O(nlg(n)) time. So why not directly find the max of the array?"
                    },
                    {
                        "username": "jerry_TAMU",
                        "content": "not a binary tree, it is binary search."
                    },
                    {
                        "username": "kritikjain9",
                        "content": "In the question description, it is mentioned that \"You may imagine that nums[-1] = nums[n] = -\\u221E\", my question is what does this mean? Like why is it mentioned there anyway?"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "It means the first and last indexes can also be peak element. let say 1 2 3 4 5 here peak is 5 as 5>4 and 5>-infinity. "
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "for [ -2147483648 ] why ans is 0   as -1 and n contains value INT_MIN\\nwhich is equal but not less???"
                    },
                    {
                        "username": "adamlhh",
                        "content": "Let\\'s say input array is of the same value, for example, [1,1,1], then there is no peak element. However, OJ seems to treat each element a valid peak element."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "if u see there is a point arr[i]!=arr[i+1]"
                    },
                    {
                        "username": "sanjoyd",
                        "content": "The problem says that \"A peak element is an element that is greater than its neighbors.\" but for there to be a logN solution the statement needs to be \"A peak element is an element that is greater than *or equal to* its neighbors.\".\\n\\nIn particular, given what the problem says today, there may be sequences *without a peak element*. (e.g. [1,1])."
                    },
                    {
                        "username": "alok5",
                        "content": "\\n![Peak element time distribution for C++, Python and Java][2]\\n\\n  [2]: http://s29.postimg.org/u675h1bbr/Peak_Element.png"
                    },
                    {
                        "username": "lx19930",
                        "content": "Global maximum must be a local maximum.\\n\\nreturn nums.index(max(nums))"
                    },
                    {
                        "username": "jason3410",
                        "content": "Far away from O(log(n)) dude."
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "But in the problem statement, they clearly mentioned that you have to write the algorithm that takes O(logn)."
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "Though it is short and sweet, it still takes O(n) and not O(logN)"
                    },
                    {
                        "username": "dark",
                        "content": "this problem is quite easy and simple"
                    },
                    {
                        "username": "user7412hz",
                        "content": "i\\'ll just leave a little hint on the concept here!!\\nThe word peak tells it\\'s kinda like a hill or a mountain. So , the peak of the mountain doesn\\'t necessarily have to be at center. \\nlet\\'s say the peak is close to the right side like [1,2,1,3,5,6,4] this one. you\\'ll have to climb more on the left side (meaning increase the left side and find the peak) and vice versa..."
                    },
                    {
                        "username": "krobzh",
                        "content": "I think the key point of this problem is to find there must be a peak in [mid+1, r] if nums[mid] < nums[mid+1].\nAnd there will always be at least one peak element whatever the array is. "
                    }
                ]
            },
            {
                "id": 1567728,
                "content": [
                    {
                        "username": "Eric_Song",
                        "content": "Many people give the solution of O(lg(n)) time complexity. But all these solutions are based on some certain data structure such as binary tree. Build such a tree will cost another O(nlg(n)) time. So why not directly find the max of the array?"
                    },
                    {
                        "username": "jerry_TAMU",
                        "content": "not a binary tree, it is binary search."
                    },
                    {
                        "username": "kritikjain9",
                        "content": "In the question description, it is mentioned that \"You may imagine that nums[-1] = nums[n] = -\\u221E\", my question is what does this mean? Like why is it mentioned there anyway?"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "It means the first and last indexes can also be peak element. let say 1 2 3 4 5 here peak is 5 as 5>4 and 5>-infinity. "
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "for [ -2147483648 ] why ans is 0   as -1 and n contains value INT_MIN\\nwhich is equal but not less???"
                    },
                    {
                        "username": "adamlhh",
                        "content": "Let\\'s say input array is of the same value, for example, [1,1,1], then there is no peak element. However, OJ seems to treat each element a valid peak element."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "if u see there is a point arr[i]!=arr[i+1]"
                    },
                    {
                        "username": "sanjoyd",
                        "content": "The problem says that \"A peak element is an element that is greater than its neighbors.\" but for there to be a logN solution the statement needs to be \"A peak element is an element that is greater than *or equal to* its neighbors.\".\\n\\nIn particular, given what the problem says today, there may be sequences *without a peak element*. (e.g. [1,1])."
                    },
                    {
                        "username": "alok5",
                        "content": "\\n![Peak element time distribution for C++, Python and Java][2]\\n\\n  [2]: http://s29.postimg.org/u675h1bbr/Peak_Element.png"
                    },
                    {
                        "username": "lx19930",
                        "content": "Global maximum must be a local maximum.\\n\\nreturn nums.index(max(nums))"
                    },
                    {
                        "username": "jason3410",
                        "content": "Far away from O(log(n)) dude."
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "But in the problem statement, they clearly mentioned that you have to write the algorithm that takes O(logn)."
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "Though it is short and sweet, it still takes O(n) and not O(logN)"
                    },
                    {
                        "username": "dark",
                        "content": "this problem is quite easy and simple"
                    },
                    {
                        "username": "user7412hz",
                        "content": "i\\'ll just leave a little hint on the concept here!!\\nThe word peak tells it\\'s kinda like a hill or a mountain. So , the peak of the mountain doesn\\'t necessarily have to be at center. \\nlet\\'s say the peak is close to the right side like [1,2,1,3,5,6,4] this one. you\\'ll have to climb more on the left side (meaning increase the left side and find the peak) and vice versa..."
                    },
                    {
                        "username": "krobzh",
                        "content": "I think the key point of this problem is to find there must be a peak in [mid+1, r] if nums[mid] < nums[mid+1].\nAnd there will always be at least one peak element whatever the array is. "
                    }
                ]
            },
            {
                "id": 1568991,
                "content": [
                    {
                        "username": "Eric_Song",
                        "content": "Many people give the solution of O(lg(n)) time complexity. But all these solutions are based on some certain data structure such as binary tree. Build such a tree will cost another O(nlg(n)) time. So why not directly find the max of the array?"
                    },
                    {
                        "username": "jerry_TAMU",
                        "content": "not a binary tree, it is binary search."
                    },
                    {
                        "username": "kritikjain9",
                        "content": "In the question description, it is mentioned that \"You may imagine that nums[-1] = nums[n] = -\\u221E\", my question is what does this mean? Like why is it mentioned there anyway?"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "It means the first and last indexes can also be peak element. let say 1 2 3 4 5 here peak is 5 as 5>4 and 5>-infinity. "
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "for [ -2147483648 ] why ans is 0   as -1 and n contains value INT_MIN\\nwhich is equal but not less???"
                    },
                    {
                        "username": "adamlhh",
                        "content": "Let\\'s say input array is of the same value, for example, [1,1,1], then there is no peak element. However, OJ seems to treat each element a valid peak element."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "if u see there is a point arr[i]!=arr[i+1]"
                    },
                    {
                        "username": "sanjoyd",
                        "content": "The problem says that \"A peak element is an element that is greater than its neighbors.\" but for there to be a logN solution the statement needs to be \"A peak element is an element that is greater than *or equal to* its neighbors.\".\\n\\nIn particular, given what the problem says today, there may be sequences *without a peak element*. (e.g. [1,1])."
                    },
                    {
                        "username": "alok5",
                        "content": "\\n![Peak element time distribution for C++, Python and Java][2]\\n\\n  [2]: http://s29.postimg.org/u675h1bbr/Peak_Element.png"
                    },
                    {
                        "username": "lx19930",
                        "content": "Global maximum must be a local maximum.\\n\\nreturn nums.index(max(nums))"
                    },
                    {
                        "username": "jason3410",
                        "content": "Far away from O(log(n)) dude."
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "But in the problem statement, they clearly mentioned that you have to write the algorithm that takes O(logn)."
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "Though it is short and sweet, it still takes O(n) and not O(logN)"
                    },
                    {
                        "username": "dark",
                        "content": "this problem is quite easy and simple"
                    },
                    {
                        "username": "user7412hz",
                        "content": "i\\'ll just leave a little hint on the concept here!!\\nThe word peak tells it\\'s kinda like a hill or a mountain. So , the peak of the mountain doesn\\'t necessarily have to be at center. \\nlet\\'s say the peak is close to the right side like [1,2,1,3,5,6,4] this one. you\\'ll have to climb more on the left side (meaning increase the left side and find the peak) and vice versa..."
                    },
                    {
                        "username": "krobzh",
                        "content": "I think the key point of this problem is to find there must be a peak in [mid+1, r] if nums[mid] < nums[mid+1].\nAnd there will always be at least one peak element whatever the array is. "
                    }
                ]
            },
            {
                "id": 2024979,
                "content": [
                    {
                        "username": "Eric_Song",
                        "content": "Many people give the solution of O(lg(n)) time complexity. But all these solutions are based on some certain data structure such as binary tree. Build such a tree will cost another O(nlg(n)) time. So why not directly find the max of the array?"
                    },
                    {
                        "username": "jerry_TAMU",
                        "content": "not a binary tree, it is binary search."
                    },
                    {
                        "username": "kritikjain9",
                        "content": "In the question description, it is mentioned that \"You may imagine that nums[-1] = nums[n] = -\\u221E\", my question is what does this mean? Like why is it mentioned there anyway?"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "It means the first and last indexes can also be peak element. let say 1 2 3 4 5 here peak is 5 as 5>4 and 5>-infinity. "
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "for [ -2147483648 ] why ans is 0   as -1 and n contains value INT_MIN\\nwhich is equal but not less???"
                    },
                    {
                        "username": "adamlhh",
                        "content": "Let\\'s say input array is of the same value, for example, [1,1,1], then there is no peak element. However, OJ seems to treat each element a valid peak element."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "if u see there is a point arr[i]!=arr[i+1]"
                    },
                    {
                        "username": "sanjoyd",
                        "content": "The problem says that \"A peak element is an element that is greater than its neighbors.\" but for there to be a logN solution the statement needs to be \"A peak element is an element that is greater than *or equal to* its neighbors.\".\\n\\nIn particular, given what the problem says today, there may be sequences *without a peak element*. (e.g. [1,1])."
                    },
                    {
                        "username": "alok5",
                        "content": "\\n![Peak element time distribution for C++, Python and Java][2]\\n\\n  [2]: http://s29.postimg.org/u675h1bbr/Peak_Element.png"
                    },
                    {
                        "username": "lx19930",
                        "content": "Global maximum must be a local maximum.\\n\\nreturn nums.index(max(nums))"
                    },
                    {
                        "username": "jason3410",
                        "content": "Far away from O(log(n)) dude."
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "But in the problem statement, they clearly mentioned that you have to write the algorithm that takes O(logn)."
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "Though it is short and sweet, it still takes O(n) and not O(logN)"
                    },
                    {
                        "username": "dark",
                        "content": "this problem is quite easy and simple"
                    },
                    {
                        "username": "user7412hz",
                        "content": "i\\'ll just leave a little hint on the concept here!!\\nThe word peak tells it\\'s kinda like a hill or a mountain. So , the peak of the mountain doesn\\'t necessarily have to be at center. \\nlet\\'s say the peak is close to the right side like [1,2,1,3,5,6,4] this one. you\\'ll have to climb more on the left side (meaning increase the left side and find the peak) and vice versa..."
                    },
                    {
                        "username": "krobzh",
                        "content": "I think the key point of this problem is to find there must be a peak in [mid+1, r] if nums[mid] < nums[mid+1].\nAnd there will always be at least one peak element whatever the array is. "
                    }
                ]
            },
            {
                "id": 2008260,
                "content": [
                    {
                        "username": "Eric_Song",
                        "content": "Many people give the solution of O(lg(n)) time complexity. But all these solutions are based on some certain data structure such as binary tree. Build such a tree will cost another O(nlg(n)) time. So why not directly find the max of the array?"
                    },
                    {
                        "username": "jerry_TAMU",
                        "content": "not a binary tree, it is binary search."
                    },
                    {
                        "username": "kritikjain9",
                        "content": "In the question description, it is mentioned that \"You may imagine that nums[-1] = nums[n] = -\\u221E\", my question is what does this mean? Like why is it mentioned there anyway?"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "It means the first and last indexes can also be peak element. let say 1 2 3 4 5 here peak is 5 as 5>4 and 5>-infinity. "
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "for [ -2147483648 ] why ans is 0   as -1 and n contains value INT_MIN\\nwhich is equal but not less???"
                    },
                    {
                        "username": "adamlhh",
                        "content": "Let\\'s say input array is of the same value, for example, [1,1,1], then there is no peak element. However, OJ seems to treat each element a valid peak element."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "if u see there is a point arr[i]!=arr[i+1]"
                    },
                    {
                        "username": "sanjoyd",
                        "content": "The problem says that \"A peak element is an element that is greater than its neighbors.\" but for there to be a logN solution the statement needs to be \"A peak element is an element that is greater than *or equal to* its neighbors.\".\\n\\nIn particular, given what the problem says today, there may be sequences *without a peak element*. (e.g. [1,1])."
                    },
                    {
                        "username": "alok5",
                        "content": "\\n![Peak element time distribution for C++, Python and Java][2]\\n\\n  [2]: http://s29.postimg.org/u675h1bbr/Peak_Element.png"
                    },
                    {
                        "username": "lx19930",
                        "content": "Global maximum must be a local maximum.\\n\\nreturn nums.index(max(nums))"
                    },
                    {
                        "username": "jason3410",
                        "content": "Far away from O(log(n)) dude."
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "But in the problem statement, they clearly mentioned that you have to write the algorithm that takes O(logn)."
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "Though it is short and sweet, it still takes O(n) and not O(logN)"
                    },
                    {
                        "username": "dark",
                        "content": "this problem is quite easy and simple"
                    },
                    {
                        "username": "user7412hz",
                        "content": "i\\'ll just leave a little hint on the concept here!!\\nThe word peak tells it\\'s kinda like a hill or a mountain. So , the peak of the mountain doesn\\'t necessarily have to be at center. \\nlet\\'s say the peak is close to the right side like [1,2,1,3,5,6,4] this one. you\\'ll have to climb more on the left side (meaning increase the left side and find the peak) and vice versa..."
                    },
                    {
                        "username": "krobzh",
                        "content": "I think the key point of this problem is to find there must be a peak in [mid+1, r] if nums[mid] < nums[mid+1].\nAnd there will always be at least one peak element whatever the array is. "
                    }
                ]
            },
            {
                "id": 1761942,
                "content": [
                    {
                        "username": "_drigger",
                        "content": "solution is very easy just applies binary search since first and last element will always kind of form peak and if they are not then there must be two element in the array which are in peak and BS will find one.\n[1,8,2,3,4,5,6] like for this case last index is peak."
                    },
                    {
                        "username": "saivardhanpallerla",
                        "content": "![image](https://assets.leetcode.com/users/images/d4138763-ca2c-46c3-b59b-dfb37fd313a7_1646126770.165714.png)\\n"
                    },
                    {
                        "username": "sohamvyas73",
                        "content": "As per the problem statement\\nnums[-1] = nums[n] = -\\u221E\\n\\nHow can there be a testcase like [1,2,3]?"
                    },
                    {
                        "username": "user2204m",
                        "content": "There are about 1944 up votes but 2190 down votes. Is there any reason for this?"
                    },
                    {
                        "username": "sastagi",
                        "content": "What is the expected output for this: 1,2,1,3,5,6,7\\n\\nI get answer as 6, which is not a peak actually."
                    },
                    {
                        "username": "VAINOI",
                        "content": "you forgot your array start with index-0?"
                    },
                    {
                        "username": "anshuman113",
                        "content": "thats not a mountain array"
                    },
                    {
                        "username": "am_",
                        "content": "eg: [1,2,3,3,3,1]\\nBinary search only works when given a position, you have a sense of which direction to choose. Say you are mid landed at index 3. There is no way of knowing that. The only solution i can think of is removing consecutive duplicates. Any other solution?"
                    },
                    {
                        "username": "throwawayleetcoder19843",
                        "content": "I was not quite satsfied with a little of hand-waving proof offered in other posts (although I appreciate all of them for the effort).You can come up with a bullet-proof proof using this idea:\\n\\n- Step1: Show that for any contiguous subarray of the array there IS a peak in that subarray if the very left in element in the array is bigger than the immediate element outside of the subarray  and the very right element in the array is bigger than the immediate element outside of subarray. (This holds true for initial case as we assume -- - inf for elements outside of initial array)\\nThe proof is not hard. We know there is a maximum in the array which is a peak\\n\\n- Step 2: show that in your BST algorithm, anytime you reduce the search space, your new search space satisfy the conditon mentioned in step 1 (the very left element bigger than the immediate element outside, the very right element bigger than the immediate element outside). Therefore, there is a peak in that subsegment and you can just focus on finding that peak ( reducing the search space to n/2, and so on...)\\n"
                    },
                    {
                        "username": "pkumarP",
                        "content": "\\nip-[1,2,1,3,5,6,4]\\nOutput --3\\nExpected - 5\\nCan anybody help me to undertand why it is not considerred as valid result.\\n"
                    },
                    {
                        "username": "ultrarelativistic",
                        "content": "mathematically incorrect. there are unsolvable entries. \\n\\nper canton some inf values can be larger than other inf\\'s. therefore, so num = [-\\u221E, -\\u221E-1, -\\u221E-2, -\\u221E-1, -\\u221E] is unsolvable.\\n\\nAlso, binary search has a requirement of the list being sorted (https://en.wikipedia.org/wiki/Binary_search_algorithm); this problem does not require a sorted list and hence the left node verse the right node does not have significance in making a decision."
                    },
                    {
                        "username": "jhuynh3",
                        "content": "I think this question is a great question which utlizies the binary search algorithm.\n\nIt makes us think of what constitutes the base case for a peak and this problem also makes us think of which side we should recurse on."
                    }
                ]
            },
            {
                "id": 1576467,
                "content": [
                    {
                        "username": "_drigger",
                        "content": "solution is very easy just applies binary search since first and last element will always kind of form peak and if they are not then there must be two element in the array which are in peak and BS will find one.\n[1,8,2,3,4,5,6] like for this case last index is peak."
                    },
                    {
                        "username": "saivardhanpallerla",
                        "content": "![image](https://assets.leetcode.com/users/images/d4138763-ca2c-46c3-b59b-dfb37fd313a7_1646126770.165714.png)\\n"
                    },
                    {
                        "username": "sohamvyas73",
                        "content": "As per the problem statement\\nnums[-1] = nums[n] = -\\u221E\\n\\nHow can there be a testcase like [1,2,3]?"
                    },
                    {
                        "username": "user2204m",
                        "content": "There are about 1944 up votes but 2190 down votes. Is there any reason for this?"
                    },
                    {
                        "username": "sastagi",
                        "content": "What is the expected output for this: 1,2,1,3,5,6,7\\n\\nI get answer as 6, which is not a peak actually."
                    },
                    {
                        "username": "VAINOI",
                        "content": "you forgot your array start with index-0?"
                    },
                    {
                        "username": "anshuman113",
                        "content": "thats not a mountain array"
                    },
                    {
                        "username": "am_",
                        "content": "eg: [1,2,3,3,3,1]\\nBinary search only works when given a position, you have a sense of which direction to choose. Say you are mid landed at index 3. There is no way of knowing that. The only solution i can think of is removing consecutive duplicates. Any other solution?"
                    },
                    {
                        "username": "throwawayleetcoder19843",
                        "content": "I was not quite satsfied with a little of hand-waving proof offered in other posts (although I appreciate all of them for the effort).You can come up with a bullet-proof proof using this idea:\\n\\n- Step1: Show that for any contiguous subarray of the array there IS a peak in that subarray if the very left in element in the array is bigger than the immediate element outside of the subarray  and the very right element in the array is bigger than the immediate element outside of subarray. (This holds true for initial case as we assume -- - inf for elements outside of initial array)\\nThe proof is not hard. We know there is a maximum in the array which is a peak\\n\\n- Step 2: show that in your BST algorithm, anytime you reduce the search space, your new search space satisfy the conditon mentioned in step 1 (the very left element bigger than the immediate element outside, the very right element bigger than the immediate element outside). Therefore, there is a peak in that subsegment and you can just focus on finding that peak ( reducing the search space to n/2, and so on...)\\n"
                    },
                    {
                        "username": "pkumarP",
                        "content": "\\nip-[1,2,1,3,5,6,4]\\nOutput --3\\nExpected - 5\\nCan anybody help me to undertand why it is not considerred as valid result.\\n"
                    },
                    {
                        "username": "ultrarelativistic",
                        "content": "mathematically incorrect. there are unsolvable entries. \\n\\nper canton some inf values can be larger than other inf\\'s. therefore, so num = [-\\u221E, -\\u221E-1, -\\u221E-2, -\\u221E-1, -\\u221E] is unsolvable.\\n\\nAlso, binary search has a requirement of the list being sorted (https://en.wikipedia.org/wiki/Binary_search_algorithm); this problem does not require a sorted list and hence the left node verse the right node does not have significance in making a decision."
                    },
                    {
                        "username": "jhuynh3",
                        "content": "I think this question is a great question which utlizies the binary search algorithm.\n\nIt makes us think of what constitutes the base case for a peak and this problem also makes us think of which side we should recurse on."
                    }
                ]
            },
            {
                "id": 1575388,
                "content": [
                    {
                        "username": "_drigger",
                        "content": "solution is very easy just applies binary search since first and last element will always kind of form peak and if they are not then there must be two element in the array which are in peak and BS will find one.\n[1,8,2,3,4,5,6] like for this case last index is peak."
                    },
                    {
                        "username": "saivardhanpallerla",
                        "content": "![image](https://assets.leetcode.com/users/images/d4138763-ca2c-46c3-b59b-dfb37fd313a7_1646126770.165714.png)\\n"
                    },
                    {
                        "username": "sohamvyas73",
                        "content": "As per the problem statement\\nnums[-1] = nums[n] = -\\u221E\\n\\nHow can there be a testcase like [1,2,3]?"
                    },
                    {
                        "username": "user2204m",
                        "content": "There are about 1944 up votes but 2190 down votes. Is there any reason for this?"
                    },
                    {
                        "username": "sastagi",
                        "content": "What is the expected output for this: 1,2,1,3,5,6,7\\n\\nI get answer as 6, which is not a peak actually."
                    },
                    {
                        "username": "VAINOI",
                        "content": "you forgot your array start with index-0?"
                    },
                    {
                        "username": "anshuman113",
                        "content": "thats not a mountain array"
                    },
                    {
                        "username": "am_",
                        "content": "eg: [1,2,3,3,3,1]\\nBinary search only works when given a position, you have a sense of which direction to choose. Say you are mid landed at index 3. There is no way of knowing that. The only solution i can think of is removing consecutive duplicates. Any other solution?"
                    },
                    {
                        "username": "throwawayleetcoder19843",
                        "content": "I was not quite satsfied with a little of hand-waving proof offered in other posts (although I appreciate all of them for the effort).You can come up with a bullet-proof proof using this idea:\\n\\n- Step1: Show that for any contiguous subarray of the array there IS a peak in that subarray if the very left in element in the array is bigger than the immediate element outside of the subarray  and the very right element in the array is bigger than the immediate element outside of subarray. (This holds true for initial case as we assume -- - inf for elements outside of initial array)\\nThe proof is not hard. We know there is a maximum in the array which is a peak\\n\\n- Step 2: show that in your BST algorithm, anytime you reduce the search space, your new search space satisfy the conditon mentioned in step 1 (the very left element bigger than the immediate element outside, the very right element bigger than the immediate element outside). Therefore, there is a peak in that subsegment and you can just focus on finding that peak ( reducing the search space to n/2, and so on...)\\n"
                    },
                    {
                        "username": "pkumarP",
                        "content": "\\nip-[1,2,1,3,5,6,4]\\nOutput --3\\nExpected - 5\\nCan anybody help me to undertand why it is not considerred as valid result.\\n"
                    },
                    {
                        "username": "ultrarelativistic",
                        "content": "mathematically incorrect. there are unsolvable entries. \\n\\nper canton some inf values can be larger than other inf\\'s. therefore, so num = [-\\u221E, -\\u221E-1, -\\u221E-2, -\\u221E-1, -\\u221E] is unsolvable.\\n\\nAlso, binary search has a requirement of the list being sorted (https://en.wikipedia.org/wiki/Binary_search_algorithm); this problem does not require a sorted list and hence the left node verse the right node does not have significance in making a decision."
                    },
                    {
                        "username": "jhuynh3",
                        "content": "I think this question is a great question which utlizies the binary search algorithm.\n\nIt makes us think of what constitutes the base case for a peak and this problem also makes us think of which side we should recurse on."
                    }
                ]
            },
            {
                "id": 1574321,
                "content": [
                    {
                        "username": "_drigger",
                        "content": "solution is very easy just applies binary search since first and last element will always kind of form peak and if they are not then there must be two element in the array which are in peak and BS will find one.\n[1,8,2,3,4,5,6] like for this case last index is peak."
                    },
                    {
                        "username": "saivardhanpallerla",
                        "content": "![image](https://assets.leetcode.com/users/images/d4138763-ca2c-46c3-b59b-dfb37fd313a7_1646126770.165714.png)\\n"
                    },
                    {
                        "username": "sohamvyas73",
                        "content": "As per the problem statement\\nnums[-1] = nums[n] = -\\u221E\\n\\nHow can there be a testcase like [1,2,3]?"
                    },
                    {
                        "username": "user2204m",
                        "content": "There are about 1944 up votes but 2190 down votes. Is there any reason for this?"
                    },
                    {
                        "username": "sastagi",
                        "content": "What is the expected output for this: 1,2,1,3,5,6,7\\n\\nI get answer as 6, which is not a peak actually."
                    },
                    {
                        "username": "VAINOI",
                        "content": "you forgot your array start with index-0?"
                    },
                    {
                        "username": "anshuman113",
                        "content": "thats not a mountain array"
                    },
                    {
                        "username": "am_",
                        "content": "eg: [1,2,3,3,3,1]\\nBinary search only works when given a position, you have a sense of which direction to choose. Say you are mid landed at index 3. There is no way of knowing that. The only solution i can think of is removing consecutive duplicates. Any other solution?"
                    },
                    {
                        "username": "throwawayleetcoder19843",
                        "content": "I was not quite satsfied with a little of hand-waving proof offered in other posts (although I appreciate all of them for the effort).You can come up with a bullet-proof proof using this idea:\\n\\n- Step1: Show that for any contiguous subarray of the array there IS a peak in that subarray if the very left in element in the array is bigger than the immediate element outside of the subarray  and the very right element in the array is bigger than the immediate element outside of subarray. (This holds true for initial case as we assume -- - inf for elements outside of initial array)\\nThe proof is not hard. We know there is a maximum in the array which is a peak\\n\\n- Step 2: show that in your BST algorithm, anytime you reduce the search space, your new search space satisfy the conditon mentioned in step 1 (the very left element bigger than the immediate element outside, the very right element bigger than the immediate element outside). Therefore, there is a peak in that subsegment and you can just focus on finding that peak ( reducing the search space to n/2, and so on...)\\n"
                    },
                    {
                        "username": "pkumarP",
                        "content": "\\nip-[1,2,1,3,5,6,4]\\nOutput --3\\nExpected - 5\\nCan anybody help me to undertand why it is not considerred as valid result.\\n"
                    },
                    {
                        "username": "ultrarelativistic",
                        "content": "mathematically incorrect. there are unsolvable entries. \\n\\nper canton some inf values can be larger than other inf\\'s. therefore, so num = [-\\u221E, -\\u221E-1, -\\u221E-2, -\\u221E-1, -\\u221E] is unsolvable.\\n\\nAlso, binary search has a requirement of the list being sorted (https://en.wikipedia.org/wiki/Binary_search_algorithm); this problem does not require a sorted list and hence the left node verse the right node does not have significance in making a decision."
                    },
                    {
                        "username": "jhuynh3",
                        "content": "I think this question is a great question which utlizies the binary search algorithm.\n\nIt makes us think of what constitutes the base case for a peak and this problem also makes us think of which side we should recurse on."
                    }
                ]
            },
            {
                "id": 1574271,
                "content": [
                    {
                        "username": "_drigger",
                        "content": "solution is very easy just applies binary search since first and last element will always kind of form peak and if they are not then there must be two element in the array which are in peak and BS will find one.\n[1,8,2,3,4,5,6] like for this case last index is peak."
                    },
                    {
                        "username": "saivardhanpallerla",
                        "content": "![image](https://assets.leetcode.com/users/images/d4138763-ca2c-46c3-b59b-dfb37fd313a7_1646126770.165714.png)\\n"
                    },
                    {
                        "username": "sohamvyas73",
                        "content": "As per the problem statement\\nnums[-1] = nums[n] = -\\u221E\\n\\nHow can there be a testcase like [1,2,3]?"
                    },
                    {
                        "username": "user2204m",
                        "content": "There are about 1944 up votes but 2190 down votes. Is there any reason for this?"
                    },
                    {
                        "username": "sastagi",
                        "content": "What is the expected output for this: 1,2,1,3,5,6,7\\n\\nI get answer as 6, which is not a peak actually."
                    },
                    {
                        "username": "VAINOI",
                        "content": "you forgot your array start with index-0?"
                    },
                    {
                        "username": "anshuman113",
                        "content": "thats not a mountain array"
                    },
                    {
                        "username": "am_",
                        "content": "eg: [1,2,3,3,3,1]\\nBinary search only works when given a position, you have a sense of which direction to choose. Say you are mid landed at index 3. There is no way of knowing that. The only solution i can think of is removing consecutive duplicates. Any other solution?"
                    },
                    {
                        "username": "throwawayleetcoder19843",
                        "content": "I was not quite satsfied with a little of hand-waving proof offered in other posts (although I appreciate all of them for the effort).You can come up with a bullet-proof proof using this idea:\\n\\n- Step1: Show that for any contiguous subarray of the array there IS a peak in that subarray if the very left in element in the array is bigger than the immediate element outside of the subarray  and the very right element in the array is bigger than the immediate element outside of subarray. (This holds true for initial case as we assume -- - inf for elements outside of initial array)\\nThe proof is not hard. We know there is a maximum in the array which is a peak\\n\\n- Step 2: show that in your BST algorithm, anytime you reduce the search space, your new search space satisfy the conditon mentioned in step 1 (the very left element bigger than the immediate element outside, the very right element bigger than the immediate element outside). Therefore, there is a peak in that subsegment and you can just focus on finding that peak ( reducing the search space to n/2, and so on...)\\n"
                    },
                    {
                        "username": "pkumarP",
                        "content": "\\nip-[1,2,1,3,5,6,4]\\nOutput --3\\nExpected - 5\\nCan anybody help me to undertand why it is not considerred as valid result.\\n"
                    },
                    {
                        "username": "ultrarelativistic",
                        "content": "mathematically incorrect. there are unsolvable entries. \\n\\nper canton some inf values can be larger than other inf\\'s. therefore, so num = [-\\u221E, -\\u221E-1, -\\u221E-2, -\\u221E-1, -\\u221E] is unsolvable.\\n\\nAlso, binary search has a requirement of the list being sorted (https://en.wikipedia.org/wiki/Binary_search_algorithm); this problem does not require a sorted list and hence the left node verse the right node does not have significance in making a decision."
                    },
                    {
                        "username": "jhuynh3",
                        "content": "I think this question is a great question which utlizies the binary search algorithm.\n\nIt makes us think of what constitutes the base case for a peak and this problem also makes us think of which side we should recurse on."
                    }
                ]
            },
            {
                "id": 1574035,
                "content": [
                    {
                        "username": "_drigger",
                        "content": "solution is very easy just applies binary search since first and last element will always kind of form peak and if they are not then there must be two element in the array which are in peak and BS will find one.\n[1,8,2,3,4,5,6] like for this case last index is peak."
                    },
                    {
                        "username": "saivardhanpallerla",
                        "content": "![image](https://assets.leetcode.com/users/images/d4138763-ca2c-46c3-b59b-dfb37fd313a7_1646126770.165714.png)\\n"
                    },
                    {
                        "username": "sohamvyas73",
                        "content": "As per the problem statement\\nnums[-1] = nums[n] = -\\u221E\\n\\nHow can there be a testcase like [1,2,3]?"
                    },
                    {
                        "username": "user2204m",
                        "content": "There are about 1944 up votes but 2190 down votes. Is there any reason for this?"
                    },
                    {
                        "username": "sastagi",
                        "content": "What is the expected output for this: 1,2,1,3,5,6,7\\n\\nI get answer as 6, which is not a peak actually."
                    },
                    {
                        "username": "VAINOI",
                        "content": "you forgot your array start with index-0?"
                    },
                    {
                        "username": "anshuman113",
                        "content": "thats not a mountain array"
                    },
                    {
                        "username": "am_",
                        "content": "eg: [1,2,3,3,3,1]\\nBinary search only works when given a position, you have a sense of which direction to choose. Say you are mid landed at index 3. There is no way of knowing that. The only solution i can think of is removing consecutive duplicates. Any other solution?"
                    },
                    {
                        "username": "throwawayleetcoder19843",
                        "content": "I was not quite satsfied with a little of hand-waving proof offered in other posts (although I appreciate all of them for the effort).You can come up with a bullet-proof proof using this idea:\\n\\n- Step1: Show that for any contiguous subarray of the array there IS a peak in that subarray if the very left in element in the array is bigger than the immediate element outside of the subarray  and the very right element in the array is bigger than the immediate element outside of subarray. (This holds true for initial case as we assume -- - inf for elements outside of initial array)\\nThe proof is not hard. We know there is a maximum in the array which is a peak\\n\\n- Step 2: show that in your BST algorithm, anytime you reduce the search space, your new search space satisfy the conditon mentioned in step 1 (the very left element bigger than the immediate element outside, the very right element bigger than the immediate element outside). Therefore, there is a peak in that subsegment and you can just focus on finding that peak ( reducing the search space to n/2, and so on...)\\n"
                    },
                    {
                        "username": "pkumarP",
                        "content": "\\nip-[1,2,1,3,5,6,4]\\nOutput --3\\nExpected - 5\\nCan anybody help me to undertand why it is not considerred as valid result.\\n"
                    },
                    {
                        "username": "ultrarelativistic",
                        "content": "mathematically incorrect. there are unsolvable entries. \\n\\nper canton some inf values can be larger than other inf\\'s. therefore, so num = [-\\u221E, -\\u221E-1, -\\u221E-2, -\\u221E-1, -\\u221E] is unsolvable.\\n\\nAlso, binary search has a requirement of the list being sorted (https://en.wikipedia.org/wiki/Binary_search_algorithm); this problem does not require a sorted list and hence the left node verse the right node does not have significance in making a decision."
                    },
                    {
                        "username": "jhuynh3",
                        "content": "I think this question is a great question which utlizies the binary search algorithm.\n\nIt makes us think of what constitutes the base case for a peak and this problem also makes us think of which side we should recurse on."
                    }
                ]
            },
            {
                "id": 1573680,
                "content": [
                    {
                        "username": "_drigger",
                        "content": "solution is very easy just applies binary search since first and last element will always kind of form peak and if they are not then there must be two element in the array which are in peak and BS will find one.\n[1,8,2,3,4,5,6] like for this case last index is peak."
                    },
                    {
                        "username": "saivardhanpallerla",
                        "content": "![image](https://assets.leetcode.com/users/images/d4138763-ca2c-46c3-b59b-dfb37fd313a7_1646126770.165714.png)\\n"
                    },
                    {
                        "username": "sohamvyas73",
                        "content": "As per the problem statement\\nnums[-1] = nums[n] = -\\u221E\\n\\nHow can there be a testcase like [1,2,3]?"
                    },
                    {
                        "username": "user2204m",
                        "content": "There are about 1944 up votes but 2190 down votes. Is there any reason for this?"
                    },
                    {
                        "username": "sastagi",
                        "content": "What is the expected output for this: 1,2,1,3,5,6,7\\n\\nI get answer as 6, which is not a peak actually."
                    },
                    {
                        "username": "VAINOI",
                        "content": "you forgot your array start with index-0?"
                    },
                    {
                        "username": "anshuman113",
                        "content": "thats not a mountain array"
                    },
                    {
                        "username": "am_",
                        "content": "eg: [1,2,3,3,3,1]\\nBinary search only works when given a position, you have a sense of which direction to choose. Say you are mid landed at index 3. There is no way of knowing that. The only solution i can think of is removing consecutive duplicates. Any other solution?"
                    },
                    {
                        "username": "throwawayleetcoder19843",
                        "content": "I was not quite satsfied with a little of hand-waving proof offered in other posts (although I appreciate all of them for the effort).You can come up with a bullet-proof proof using this idea:\\n\\n- Step1: Show that for any contiguous subarray of the array there IS a peak in that subarray if the very left in element in the array is bigger than the immediate element outside of the subarray  and the very right element in the array is bigger than the immediate element outside of subarray. (This holds true for initial case as we assume -- - inf for elements outside of initial array)\\nThe proof is not hard. We know there is a maximum in the array which is a peak\\n\\n- Step 2: show that in your BST algorithm, anytime you reduce the search space, your new search space satisfy the conditon mentioned in step 1 (the very left element bigger than the immediate element outside, the very right element bigger than the immediate element outside). Therefore, there is a peak in that subsegment and you can just focus on finding that peak ( reducing the search space to n/2, and so on...)\\n"
                    },
                    {
                        "username": "pkumarP",
                        "content": "\\nip-[1,2,1,3,5,6,4]\\nOutput --3\\nExpected - 5\\nCan anybody help me to undertand why it is not considerred as valid result.\\n"
                    },
                    {
                        "username": "ultrarelativistic",
                        "content": "mathematically incorrect. there are unsolvable entries. \\n\\nper canton some inf values can be larger than other inf\\'s. therefore, so num = [-\\u221E, -\\u221E-1, -\\u221E-2, -\\u221E-1, -\\u221E] is unsolvable.\\n\\nAlso, binary search has a requirement of the list being sorted (https://en.wikipedia.org/wiki/Binary_search_algorithm); this problem does not require a sorted list and hence the left node verse the right node does not have significance in making a decision."
                    },
                    {
                        "username": "jhuynh3",
                        "content": "I think this question is a great question which utlizies the binary search algorithm.\n\nIt makes us think of what constitutes the base case for a peak and this problem also makes us think of which side we should recurse on."
                    }
                ]
            },
            {
                "id": 1573553,
                "content": [
                    {
                        "username": "_drigger",
                        "content": "solution is very easy just applies binary search since first and last element will always kind of form peak and if they are not then there must be two element in the array which are in peak and BS will find one.\n[1,8,2,3,4,5,6] like for this case last index is peak."
                    },
                    {
                        "username": "saivardhanpallerla",
                        "content": "![image](https://assets.leetcode.com/users/images/d4138763-ca2c-46c3-b59b-dfb37fd313a7_1646126770.165714.png)\\n"
                    },
                    {
                        "username": "sohamvyas73",
                        "content": "As per the problem statement\\nnums[-1] = nums[n] = -\\u221E\\n\\nHow can there be a testcase like [1,2,3]?"
                    },
                    {
                        "username": "user2204m",
                        "content": "There are about 1944 up votes but 2190 down votes. Is there any reason for this?"
                    },
                    {
                        "username": "sastagi",
                        "content": "What is the expected output for this: 1,2,1,3,5,6,7\\n\\nI get answer as 6, which is not a peak actually."
                    },
                    {
                        "username": "VAINOI",
                        "content": "you forgot your array start with index-0?"
                    },
                    {
                        "username": "anshuman113",
                        "content": "thats not a mountain array"
                    },
                    {
                        "username": "am_",
                        "content": "eg: [1,2,3,3,3,1]\\nBinary search only works when given a position, you have a sense of which direction to choose. Say you are mid landed at index 3. There is no way of knowing that. The only solution i can think of is removing consecutive duplicates. Any other solution?"
                    },
                    {
                        "username": "throwawayleetcoder19843",
                        "content": "I was not quite satsfied with a little of hand-waving proof offered in other posts (although I appreciate all of them for the effort).You can come up with a bullet-proof proof using this idea:\\n\\n- Step1: Show that for any contiguous subarray of the array there IS a peak in that subarray if the very left in element in the array is bigger than the immediate element outside of the subarray  and the very right element in the array is bigger than the immediate element outside of subarray. (This holds true for initial case as we assume -- - inf for elements outside of initial array)\\nThe proof is not hard. We know there is a maximum in the array which is a peak\\n\\n- Step 2: show that in your BST algorithm, anytime you reduce the search space, your new search space satisfy the conditon mentioned in step 1 (the very left element bigger than the immediate element outside, the very right element bigger than the immediate element outside). Therefore, there is a peak in that subsegment and you can just focus on finding that peak ( reducing the search space to n/2, and so on...)\\n"
                    },
                    {
                        "username": "pkumarP",
                        "content": "\\nip-[1,2,1,3,5,6,4]\\nOutput --3\\nExpected - 5\\nCan anybody help me to undertand why it is not considerred as valid result.\\n"
                    },
                    {
                        "username": "ultrarelativistic",
                        "content": "mathematically incorrect. there are unsolvable entries. \\n\\nper canton some inf values can be larger than other inf\\'s. therefore, so num = [-\\u221E, -\\u221E-1, -\\u221E-2, -\\u221E-1, -\\u221E] is unsolvable.\\n\\nAlso, binary search has a requirement of the list being sorted (https://en.wikipedia.org/wiki/Binary_search_algorithm); this problem does not require a sorted list and hence the left node verse the right node does not have significance in making a decision."
                    },
                    {
                        "username": "jhuynh3",
                        "content": "I think this question is a great question which utlizies the binary search algorithm.\n\nIt makes us think of what constitutes the base case for a peak and this problem also makes us think of which side we should recurse on."
                    }
                ]
            },
            {
                "id": 1573522,
                "content": [
                    {
                        "username": "_drigger",
                        "content": "solution is very easy just applies binary search since first and last element will always kind of form peak and if they are not then there must be two element in the array which are in peak and BS will find one.\n[1,8,2,3,4,5,6] like for this case last index is peak."
                    },
                    {
                        "username": "saivardhanpallerla",
                        "content": "![image](https://assets.leetcode.com/users/images/d4138763-ca2c-46c3-b59b-dfb37fd313a7_1646126770.165714.png)\\n"
                    },
                    {
                        "username": "sohamvyas73",
                        "content": "As per the problem statement\\nnums[-1] = nums[n] = -\\u221E\\n\\nHow can there be a testcase like [1,2,3]?"
                    },
                    {
                        "username": "user2204m",
                        "content": "There are about 1944 up votes but 2190 down votes. Is there any reason for this?"
                    },
                    {
                        "username": "sastagi",
                        "content": "What is the expected output for this: 1,2,1,3,5,6,7\\n\\nI get answer as 6, which is not a peak actually."
                    },
                    {
                        "username": "VAINOI",
                        "content": "you forgot your array start with index-0?"
                    },
                    {
                        "username": "anshuman113",
                        "content": "thats not a mountain array"
                    },
                    {
                        "username": "am_",
                        "content": "eg: [1,2,3,3,3,1]\\nBinary search only works when given a position, you have a sense of which direction to choose. Say you are mid landed at index 3. There is no way of knowing that. The only solution i can think of is removing consecutive duplicates. Any other solution?"
                    },
                    {
                        "username": "throwawayleetcoder19843",
                        "content": "I was not quite satsfied with a little of hand-waving proof offered in other posts (although I appreciate all of them for the effort).You can come up with a bullet-proof proof using this idea:\\n\\n- Step1: Show that for any contiguous subarray of the array there IS a peak in that subarray if the very left in element in the array is bigger than the immediate element outside of the subarray  and the very right element in the array is bigger than the immediate element outside of subarray. (This holds true for initial case as we assume -- - inf for elements outside of initial array)\\nThe proof is not hard. We know there is a maximum in the array which is a peak\\n\\n- Step 2: show that in your BST algorithm, anytime you reduce the search space, your new search space satisfy the conditon mentioned in step 1 (the very left element bigger than the immediate element outside, the very right element bigger than the immediate element outside). Therefore, there is a peak in that subsegment and you can just focus on finding that peak ( reducing the search space to n/2, and so on...)\\n"
                    },
                    {
                        "username": "pkumarP",
                        "content": "\\nip-[1,2,1,3,5,6,4]\\nOutput --3\\nExpected - 5\\nCan anybody help me to undertand why it is not considerred as valid result.\\n"
                    },
                    {
                        "username": "ultrarelativistic",
                        "content": "mathematically incorrect. there are unsolvable entries. \\n\\nper canton some inf values can be larger than other inf\\'s. therefore, so num = [-\\u221E, -\\u221E-1, -\\u221E-2, -\\u221E-1, -\\u221E] is unsolvable.\\n\\nAlso, binary search has a requirement of the list being sorted (https://en.wikipedia.org/wiki/Binary_search_algorithm); this problem does not require a sorted list and hence the left node verse the right node does not have significance in making a decision."
                    },
                    {
                        "username": "jhuynh3",
                        "content": "I think this question is a great question which utlizies the binary search algorithm.\n\nIt makes us think of what constitutes the base case for a peak and this problem also makes us think of which side we should recurse on."
                    }
                ]
            },
            {
                "id": 1572259,
                "content": [
                    {
                        "username": "_drigger",
                        "content": "solution is very easy just applies binary search since first and last element will always kind of form peak and if they are not then there must be two element in the array which are in peak and BS will find one.\n[1,8,2,3,4,5,6] like for this case last index is peak."
                    },
                    {
                        "username": "saivardhanpallerla",
                        "content": "![image](https://assets.leetcode.com/users/images/d4138763-ca2c-46c3-b59b-dfb37fd313a7_1646126770.165714.png)\\n"
                    },
                    {
                        "username": "sohamvyas73",
                        "content": "As per the problem statement\\nnums[-1] = nums[n] = -\\u221E\\n\\nHow can there be a testcase like [1,2,3]?"
                    },
                    {
                        "username": "user2204m",
                        "content": "There are about 1944 up votes but 2190 down votes. Is there any reason for this?"
                    },
                    {
                        "username": "sastagi",
                        "content": "What is the expected output for this: 1,2,1,3,5,6,7\\n\\nI get answer as 6, which is not a peak actually."
                    },
                    {
                        "username": "VAINOI",
                        "content": "you forgot your array start with index-0?"
                    },
                    {
                        "username": "anshuman113",
                        "content": "thats not a mountain array"
                    },
                    {
                        "username": "am_",
                        "content": "eg: [1,2,3,3,3,1]\\nBinary search only works when given a position, you have a sense of which direction to choose. Say you are mid landed at index 3. There is no way of knowing that. The only solution i can think of is removing consecutive duplicates. Any other solution?"
                    },
                    {
                        "username": "throwawayleetcoder19843",
                        "content": "I was not quite satsfied with a little of hand-waving proof offered in other posts (although I appreciate all of them for the effort).You can come up with a bullet-proof proof using this idea:\\n\\n- Step1: Show that for any contiguous subarray of the array there IS a peak in that subarray if the very left in element in the array is bigger than the immediate element outside of the subarray  and the very right element in the array is bigger than the immediate element outside of subarray. (This holds true for initial case as we assume -- - inf for elements outside of initial array)\\nThe proof is not hard. We know there is a maximum in the array which is a peak\\n\\n- Step 2: show that in your BST algorithm, anytime you reduce the search space, your new search space satisfy the conditon mentioned in step 1 (the very left element bigger than the immediate element outside, the very right element bigger than the immediate element outside). Therefore, there is a peak in that subsegment and you can just focus on finding that peak ( reducing the search space to n/2, and so on...)\\n"
                    },
                    {
                        "username": "pkumarP",
                        "content": "\\nip-[1,2,1,3,5,6,4]\\nOutput --3\\nExpected - 5\\nCan anybody help me to undertand why it is not considerred as valid result.\\n"
                    },
                    {
                        "username": "ultrarelativistic",
                        "content": "mathematically incorrect. there are unsolvable entries. \\n\\nper canton some inf values can be larger than other inf\\'s. therefore, so num = [-\\u221E, -\\u221E-1, -\\u221E-2, -\\u221E-1, -\\u221E] is unsolvable.\\n\\nAlso, binary search has a requirement of the list being sorted (https://en.wikipedia.org/wiki/Binary_search_algorithm); this problem does not require a sorted list and hence the left node verse the right node does not have significance in making a decision."
                    },
                    {
                        "username": "jhuynh3",
                        "content": "I think this question is a great question which utlizies the binary search algorithm.\n\nIt makes us think of what constitutes the base case for a peak and this problem also makes us think of which side we should recurse on."
                    }
                ]
            },
            {
                "id": 1572214,
                "content": [
                    {
                        "username": "xelad1",
                        "content": "That is to say, is the binary search implementation a worst case run time of O(n) like linear search, but with an average case of log(n)? From what I can tell certain edge cases (for example if we change a nuber in the solution example to be an array of [1,2,1,3,4,6,6]) and we go right we'll end up having to check the whole half of the other array to find a peak.\n\nReally curious here if my reasoning is correct, not trying to be a smartass. Thanks for any input."
                    },
                    {
                        "username": "jbreda",
                        "content": "the optimal solution claims to be a binary search, which can work if the array is monotonically increasing until a peak and then monotonically decreasing there after. (excluding cases where it is strictly monotonically decreasing or monotonically increasing). \\n\\nHowever, the question provides examples where it has multiple peaks or ups and downs. I don\\'t see how binary search could work when this is the case."
                    },
                    {
                        "username": "hsu2",
                        "content": "the problem should define \"peak\" as greater than or equal to its neighbors or give the constraint that all numbers are unique, so that the popular binary search will work."
                    },
                    {
                        "username": "FreeTymeKiyan",
                        "content": "Actually all the input arrays have only one peak. Obviously the solution won't be the same if there is an input of several peaks in an array. \\n\\nSay int[] num = {1, 2, 1, 3, 1, 4, 1}, num[i] is not equal to num[i + 1]."
                    },
                    {
                        "username": "jaswinder1997",
                        "content": "Why cannot we use binary search using while loop to find peak element in an array instead of using recursion as discussed in approach??\\n\\nThanks in Advance"
                    },
                    {
                        "username": "xchen182",
                        "content": "return distance(nums.begin(), max_element(nums.begin(),nums.end()));\\n//it only returns the index of max but peak.\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "This is very very simple, not medium. You label wrong."
                    },
                    {
                        "username": "abhisheak",
                        "content": "Let us say that we have a tint peak at the start:\\n[1,2,3,1,100,200,300,400,500,600,700]\\n\\nThe peak is 3. Most of the solutions seems to miss this case and incorrectly assumes that the peak exists in the 2nd half of the array and gives the answer as the last index.\\n\\nDo we have fool proof solution that covers this test case?"
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "The last constrain is so important that being put into the bottom of the context, and after all the examples. Shouldn\\'t such condition put into the first place?"
                    },
                    {
                        "username": "awilliams15",
                        "content": "For those struggling to understand why we know for sure we can do this in O(log n) time... Remember that in a scenario like nums = [3, 2, 1], 3 is a valid peak. "
                    }
                ]
            },
            {
                "id": 1572047,
                "content": [
                    {
                        "username": "xelad1",
                        "content": "That is to say, is the binary search implementation a worst case run time of O(n) like linear search, but with an average case of log(n)? From what I can tell certain edge cases (for example if we change a nuber in the solution example to be an array of [1,2,1,3,4,6,6]) and we go right we'll end up having to check the whole half of the other array to find a peak.\n\nReally curious here if my reasoning is correct, not trying to be a smartass. Thanks for any input."
                    },
                    {
                        "username": "jbreda",
                        "content": "the optimal solution claims to be a binary search, which can work if the array is monotonically increasing until a peak and then monotonically decreasing there after. (excluding cases where it is strictly monotonically decreasing or monotonically increasing). \\n\\nHowever, the question provides examples where it has multiple peaks or ups and downs. I don\\'t see how binary search could work when this is the case."
                    },
                    {
                        "username": "hsu2",
                        "content": "the problem should define \"peak\" as greater than or equal to its neighbors or give the constraint that all numbers are unique, so that the popular binary search will work."
                    },
                    {
                        "username": "FreeTymeKiyan",
                        "content": "Actually all the input arrays have only one peak. Obviously the solution won't be the same if there is an input of several peaks in an array. \\n\\nSay int[] num = {1, 2, 1, 3, 1, 4, 1}, num[i] is not equal to num[i + 1]."
                    },
                    {
                        "username": "jaswinder1997",
                        "content": "Why cannot we use binary search using while loop to find peak element in an array instead of using recursion as discussed in approach??\\n\\nThanks in Advance"
                    },
                    {
                        "username": "xchen182",
                        "content": "return distance(nums.begin(), max_element(nums.begin(),nums.end()));\\n//it only returns the index of max but peak.\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "This is very very simple, not medium. You label wrong."
                    },
                    {
                        "username": "abhisheak",
                        "content": "Let us say that we have a tint peak at the start:\\n[1,2,3,1,100,200,300,400,500,600,700]\\n\\nThe peak is 3. Most of the solutions seems to miss this case and incorrectly assumes that the peak exists in the 2nd half of the array and gives the answer as the last index.\\n\\nDo we have fool proof solution that covers this test case?"
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "The last constrain is so important that being put into the bottom of the context, and after all the examples. Shouldn\\'t such condition put into the first place?"
                    },
                    {
                        "username": "awilliams15",
                        "content": "For those struggling to understand why we know for sure we can do this in O(log n) time... Remember that in a scenario like nums = [3, 2, 1], 3 is a valid peak. "
                    }
                ]
            },
            {
                "id": 1571354,
                "content": [
                    {
                        "username": "xelad1",
                        "content": "That is to say, is the binary search implementation a worst case run time of O(n) like linear search, but with an average case of log(n)? From what I can tell certain edge cases (for example if we change a nuber in the solution example to be an array of [1,2,1,3,4,6,6]) and we go right we'll end up having to check the whole half of the other array to find a peak.\n\nReally curious here if my reasoning is correct, not trying to be a smartass. Thanks for any input."
                    },
                    {
                        "username": "jbreda",
                        "content": "the optimal solution claims to be a binary search, which can work if the array is monotonically increasing until a peak and then monotonically decreasing there after. (excluding cases where it is strictly monotonically decreasing or monotonically increasing). \\n\\nHowever, the question provides examples where it has multiple peaks or ups and downs. I don\\'t see how binary search could work when this is the case."
                    },
                    {
                        "username": "hsu2",
                        "content": "the problem should define \"peak\" as greater than or equal to its neighbors or give the constraint that all numbers are unique, so that the popular binary search will work."
                    },
                    {
                        "username": "FreeTymeKiyan",
                        "content": "Actually all the input arrays have only one peak. Obviously the solution won't be the same if there is an input of several peaks in an array. \\n\\nSay int[] num = {1, 2, 1, 3, 1, 4, 1}, num[i] is not equal to num[i + 1]."
                    },
                    {
                        "username": "jaswinder1997",
                        "content": "Why cannot we use binary search using while loop to find peak element in an array instead of using recursion as discussed in approach??\\n\\nThanks in Advance"
                    },
                    {
                        "username": "xchen182",
                        "content": "return distance(nums.begin(), max_element(nums.begin(),nums.end()));\\n//it only returns the index of max but peak.\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "This is very very simple, not medium. You label wrong."
                    },
                    {
                        "username": "abhisheak",
                        "content": "Let us say that we have a tint peak at the start:\\n[1,2,3,1,100,200,300,400,500,600,700]\\n\\nThe peak is 3. Most of the solutions seems to miss this case and incorrectly assumes that the peak exists in the 2nd half of the array and gives the answer as the last index.\\n\\nDo we have fool proof solution that covers this test case?"
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "The last constrain is so important that being put into the bottom of the context, and after all the examples. Shouldn\\'t such condition put into the first place?"
                    },
                    {
                        "username": "awilliams15",
                        "content": "For those struggling to understand why we know for sure we can do this in O(log n) time... Remember that in a scenario like nums = [3, 2, 1], 3 is a valid peak. "
                    }
                ]
            },
            {
                "id": 1571356,
                "content": [
                    {
                        "username": "xelad1",
                        "content": "That is to say, is the binary search implementation a worst case run time of O(n) like linear search, but with an average case of log(n)? From what I can tell certain edge cases (for example if we change a nuber in the solution example to be an array of [1,2,1,3,4,6,6]) and we go right we'll end up having to check the whole half of the other array to find a peak.\n\nReally curious here if my reasoning is correct, not trying to be a smartass. Thanks for any input."
                    },
                    {
                        "username": "jbreda",
                        "content": "the optimal solution claims to be a binary search, which can work if the array is monotonically increasing until a peak and then monotonically decreasing there after. (excluding cases where it is strictly monotonically decreasing or monotonically increasing). \\n\\nHowever, the question provides examples where it has multiple peaks or ups and downs. I don\\'t see how binary search could work when this is the case."
                    },
                    {
                        "username": "hsu2",
                        "content": "the problem should define \"peak\" as greater than or equal to its neighbors or give the constraint that all numbers are unique, so that the popular binary search will work."
                    },
                    {
                        "username": "FreeTymeKiyan",
                        "content": "Actually all the input arrays have only one peak. Obviously the solution won't be the same if there is an input of several peaks in an array. \\n\\nSay int[] num = {1, 2, 1, 3, 1, 4, 1}, num[i] is not equal to num[i + 1]."
                    },
                    {
                        "username": "jaswinder1997",
                        "content": "Why cannot we use binary search using while loop to find peak element in an array instead of using recursion as discussed in approach??\\n\\nThanks in Advance"
                    },
                    {
                        "username": "xchen182",
                        "content": "return distance(nums.begin(), max_element(nums.begin(),nums.end()));\\n//it only returns the index of max but peak.\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "This is very very simple, not medium. You label wrong."
                    },
                    {
                        "username": "abhisheak",
                        "content": "Let us say that we have a tint peak at the start:\\n[1,2,3,1,100,200,300,400,500,600,700]\\n\\nThe peak is 3. Most of the solutions seems to miss this case and incorrectly assumes that the peak exists in the 2nd half of the array and gives the answer as the last index.\\n\\nDo we have fool proof solution that covers this test case?"
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "The last constrain is so important that being put into the bottom of the context, and after all the examples. Shouldn\\'t such condition put into the first place?"
                    },
                    {
                        "username": "awilliams15",
                        "content": "For those struggling to understand why we know for sure we can do this in O(log n) time... Remember that in a scenario like nums = [3, 2, 1], 3 is a valid peak. "
                    }
                ]
            },
            {
                "id": 1575043,
                "content": [
                    {
                        "username": "xelad1",
                        "content": "That is to say, is the binary search implementation a worst case run time of O(n) like linear search, but with an average case of log(n)? From what I can tell certain edge cases (for example if we change a nuber in the solution example to be an array of [1,2,1,3,4,6,6]) and we go right we'll end up having to check the whole half of the other array to find a peak.\n\nReally curious here if my reasoning is correct, not trying to be a smartass. Thanks for any input."
                    },
                    {
                        "username": "jbreda",
                        "content": "the optimal solution claims to be a binary search, which can work if the array is monotonically increasing until a peak and then monotonically decreasing there after. (excluding cases where it is strictly monotonically decreasing or monotonically increasing). \\n\\nHowever, the question provides examples where it has multiple peaks or ups and downs. I don\\'t see how binary search could work when this is the case."
                    },
                    {
                        "username": "hsu2",
                        "content": "the problem should define \"peak\" as greater than or equal to its neighbors or give the constraint that all numbers are unique, so that the popular binary search will work."
                    },
                    {
                        "username": "FreeTymeKiyan",
                        "content": "Actually all the input arrays have only one peak. Obviously the solution won't be the same if there is an input of several peaks in an array. \\n\\nSay int[] num = {1, 2, 1, 3, 1, 4, 1}, num[i] is not equal to num[i + 1]."
                    },
                    {
                        "username": "jaswinder1997",
                        "content": "Why cannot we use binary search using while loop to find peak element in an array instead of using recursion as discussed in approach??\\n\\nThanks in Advance"
                    },
                    {
                        "username": "xchen182",
                        "content": "return distance(nums.begin(), max_element(nums.begin(),nums.end()));\\n//it only returns the index of max but peak.\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "This is very very simple, not medium. You label wrong."
                    },
                    {
                        "username": "abhisheak",
                        "content": "Let us say that we have a tint peak at the start:\\n[1,2,3,1,100,200,300,400,500,600,700]\\n\\nThe peak is 3. Most of the solutions seems to miss this case and incorrectly assumes that the peak exists in the 2nd half of the array and gives the answer as the last index.\\n\\nDo we have fool proof solution that covers this test case?"
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "The last constrain is so important that being put into the bottom of the context, and after all the examples. Shouldn\\'t such condition put into the first place?"
                    },
                    {
                        "username": "awilliams15",
                        "content": "For those struggling to understand why we know for sure we can do this in O(log n) time... Remember that in a scenario like nums = [3, 2, 1], 3 is a valid peak. "
                    }
                ]
            },
            {
                "id": 1574538,
                "content": [
                    {
                        "username": "xelad1",
                        "content": "That is to say, is the binary search implementation a worst case run time of O(n) like linear search, but with an average case of log(n)? From what I can tell certain edge cases (for example if we change a nuber in the solution example to be an array of [1,2,1,3,4,6,6]) and we go right we'll end up having to check the whole half of the other array to find a peak.\n\nReally curious here if my reasoning is correct, not trying to be a smartass. Thanks for any input."
                    },
                    {
                        "username": "jbreda",
                        "content": "the optimal solution claims to be a binary search, which can work if the array is monotonically increasing until a peak and then monotonically decreasing there after. (excluding cases where it is strictly monotonically decreasing or monotonically increasing). \\n\\nHowever, the question provides examples where it has multiple peaks or ups and downs. I don\\'t see how binary search could work when this is the case."
                    },
                    {
                        "username": "hsu2",
                        "content": "the problem should define \"peak\" as greater than or equal to its neighbors or give the constraint that all numbers are unique, so that the popular binary search will work."
                    },
                    {
                        "username": "FreeTymeKiyan",
                        "content": "Actually all the input arrays have only one peak. Obviously the solution won't be the same if there is an input of several peaks in an array. \\n\\nSay int[] num = {1, 2, 1, 3, 1, 4, 1}, num[i] is not equal to num[i + 1]."
                    },
                    {
                        "username": "jaswinder1997",
                        "content": "Why cannot we use binary search using while loop to find peak element in an array instead of using recursion as discussed in approach??\\n\\nThanks in Advance"
                    },
                    {
                        "username": "xchen182",
                        "content": "return distance(nums.begin(), max_element(nums.begin(),nums.end()));\\n//it only returns the index of max but peak.\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "This is very very simple, not medium. You label wrong."
                    },
                    {
                        "username": "abhisheak",
                        "content": "Let us say that we have a tint peak at the start:\\n[1,2,3,1,100,200,300,400,500,600,700]\\n\\nThe peak is 3. Most of the solutions seems to miss this case and incorrectly assumes that the peak exists in the 2nd half of the array and gives the answer as the last index.\\n\\nDo we have fool proof solution that covers this test case?"
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "The last constrain is so important that being put into the bottom of the context, and after all the examples. Shouldn\\'t such condition put into the first place?"
                    },
                    {
                        "username": "awilliams15",
                        "content": "For those struggling to understand why we know for sure we can do this in O(log n) time... Remember that in a scenario like nums = [3, 2, 1], 3 is a valid peak. "
                    }
                ]
            },
            {
                "id": 1572185,
                "content": [
                    {
                        "username": "xelad1",
                        "content": "That is to say, is the binary search implementation a worst case run time of O(n) like linear search, but with an average case of log(n)? From what I can tell certain edge cases (for example if we change a nuber in the solution example to be an array of [1,2,1,3,4,6,6]) and we go right we'll end up having to check the whole half of the other array to find a peak.\n\nReally curious here if my reasoning is correct, not trying to be a smartass. Thanks for any input."
                    },
                    {
                        "username": "jbreda",
                        "content": "the optimal solution claims to be a binary search, which can work if the array is monotonically increasing until a peak and then monotonically decreasing there after. (excluding cases where it is strictly monotonically decreasing or monotonically increasing). \\n\\nHowever, the question provides examples where it has multiple peaks or ups and downs. I don\\'t see how binary search could work when this is the case."
                    },
                    {
                        "username": "hsu2",
                        "content": "the problem should define \"peak\" as greater than or equal to its neighbors or give the constraint that all numbers are unique, so that the popular binary search will work."
                    },
                    {
                        "username": "FreeTymeKiyan",
                        "content": "Actually all the input arrays have only one peak. Obviously the solution won't be the same if there is an input of several peaks in an array. \\n\\nSay int[] num = {1, 2, 1, 3, 1, 4, 1}, num[i] is not equal to num[i + 1]."
                    },
                    {
                        "username": "jaswinder1997",
                        "content": "Why cannot we use binary search using while loop to find peak element in an array instead of using recursion as discussed in approach??\\n\\nThanks in Advance"
                    },
                    {
                        "username": "xchen182",
                        "content": "return distance(nums.begin(), max_element(nums.begin(),nums.end()));\\n//it only returns the index of max but peak.\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "This is very very simple, not medium. You label wrong."
                    },
                    {
                        "username": "abhisheak",
                        "content": "Let us say that we have a tint peak at the start:\\n[1,2,3,1,100,200,300,400,500,600,700]\\n\\nThe peak is 3. Most of the solutions seems to miss this case and incorrectly assumes that the peak exists in the 2nd half of the array and gives the answer as the last index.\\n\\nDo we have fool proof solution that covers this test case?"
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "The last constrain is so important that being put into the bottom of the context, and after all the examples. Shouldn\\'t such condition put into the first place?"
                    },
                    {
                        "username": "awilliams15",
                        "content": "For those struggling to understand why we know for sure we can do this in O(log n) time... Remember that in a scenario like nums = [3, 2, 1], 3 is a valid peak. "
                    }
                ]
            },
            {
                "id": 1571353,
                "content": [
                    {
                        "username": "xelad1",
                        "content": "That is to say, is the binary search implementation a worst case run time of O(n) like linear search, but with an average case of log(n)? From what I can tell certain edge cases (for example if we change a nuber in the solution example to be an array of [1,2,1,3,4,6,6]) and we go right we'll end up having to check the whole half of the other array to find a peak.\n\nReally curious here if my reasoning is correct, not trying to be a smartass. Thanks for any input."
                    },
                    {
                        "username": "jbreda",
                        "content": "the optimal solution claims to be a binary search, which can work if the array is monotonically increasing until a peak and then monotonically decreasing there after. (excluding cases where it is strictly monotonically decreasing or monotonically increasing). \\n\\nHowever, the question provides examples where it has multiple peaks or ups and downs. I don\\'t see how binary search could work when this is the case."
                    },
                    {
                        "username": "hsu2",
                        "content": "the problem should define \"peak\" as greater than or equal to its neighbors or give the constraint that all numbers are unique, so that the popular binary search will work."
                    },
                    {
                        "username": "FreeTymeKiyan",
                        "content": "Actually all the input arrays have only one peak. Obviously the solution won't be the same if there is an input of several peaks in an array. \\n\\nSay int[] num = {1, 2, 1, 3, 1, 4, 1}, num[i] is not equal to num[i + 1]."
                    },
                    {
                        "username": "jaswinder1997",
                        "content": "Why cannot we use binary search using while loop to find peak element in an array instead of using recursion as discussed in approach??\\n\\nThanks in Advance"
                    },
                    {
                        "username": "xchen182",
                        "content": "return distance(nums.begin(), max_element(nums.begin(),nums.end()));\\n//it only returns the index of max but peak.\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "This is very very simple, not medium. You label wrong."
                    },
                    {
                        "username": "abhisheak",
                        "content": "Let us say that we have a tint peak at the start:\\n[1,2,3,1,100,200,300,400,500,600,700]\\n\\nThe peak is 3. Most of the solutions seems to miss this case and incorrectly assumes that the peak exists in the 2nd half of the array and gives the answer as the last index.\\n\\nDo we have fool proof solution that covers this test case?"
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "The last constrain is so important that being put into the bottom of the context, and after all the examples. Shouldn\\'t such condition put into the first place?"
                    },
                    {
                        "username": "awilliams15",
                        "content": "For those struggling to understand why we know for sure we can do this in O(log n) time... Remember that in a scenario like nums = [3, 2, 1], 3 is a valid peak. "
                    }
                ]
            },
            {
                "id": 2075433,
                "content": [
                    {
                        "username": "xelad1",
                        "content": "That is to say, is the binary search implementation a worst case run time of O(n) like linear search, but with an average case of log(n)? From what I can tell certain edge cases (for example if we change a nuber in the solution example to be an array of [1,2,1,3,4,6,6]) and we go right we'll end up having to check the whole half of the other array to find a peak.\n\nReally curious here if my reasoning is correct, not trying to be a smartass. Thanks for any input."
                    },
                    {
                        "username": "jbreda",
                        "content": "the optimal solution claims to be a binary search, which can work if the array is monotonically increasing until a peak and then monotonically decreasing there after. (excluding cases where it is strictly monotonically decreasing or monotonically increasing). \\n\\nHowever, the question provides examples where it has multiple peaks or ups and downs. I don\\'t see how binary search could work when this is the case."
                    },
                    {
                        "username": "hsu2",
                        "content": "the problem should define \"peak\" as greater than or equal to its neighbors or give the constraint that all numbers are unique, so that the popular binary search will work."
                    },
                    {
                        "username": "FreeTymeKiyan",
                        "content": "Actually all the input arrays have only one peak. Obviously the solution won't be the same if there is an input of several peaks in an array. \\n\\nSay int[] num = {1, 2, 1, 3, 1, 4, 1}, num[i] is not equal to num[i + 1]."
                    },
                    {
                        "username": "jaswinder1997",
                        "content": "Why cannot we use binary search using while loop to find peak element in an array instead of using recursion as discussed in approach??\\n\\nThanks in Advance"
                    },
                    {
                        "username": "xchen182",
                        "content": "return distance(nums.begin(), max_element(nums.begin(),nums.end()));\\n//it only returns the index of max but peak.\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "This is very very simple, not medium. You label wrong."
                    },
                    {
                        "username": "abhisheak",
                        "content": "Let us say that we have a tint peak at the start:\\n[1,2,3,1,100,200,300,400,500,600,700]\\n\\nThe peak is 3. Most of the solutions seems to miss this case and incorrectly assumes that the peak exists in the 2nd half of the array and gives the answer as the last index.\\n\\nDo we have fool proof solution that covers this test case?"
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "The last constrain is so important that being put into the bottom of the context, and after all the examples. Shouldn\\'t such condition put into the first place?"
                    },
                    {
                        "username": "awilliams15",
                        "content": "For those struggling to understand why we know for sure we can do this in O(log n) time... Remember that in a scenario like nums = [3, 2, 1], 3 is a valid peak. "
                    }
                ]
            },
            {
                "id": 2066339,
                "content": [
                    {
                        "username": "xelad1",
                        "content": "That is to say, is the binary search implementation a worst case run time of O(n) like linear search, but with an average case of log(n)? From what I can tell certain edge cases (for example if we change a nuber in the solution example to be an array of [1,2,1,3,4,6,6]) and we go right we'll end up having to check the whole half of the other array to find a peak.\n\nReally curious here if my reasoning is correct, not trying to be a smartass. Thanks for any input."
                    },
                    {
                        "username": "jbreda",
                        "content": "the optimal solution claims to be a binary search, which can work if the array is monotonically increasing until a peak and then monotonically decreasing there after. (excluding cases where it is strictly monotonically decreasing or monotonically increasing). \\n\\nHowever, the question provides examples where it has multiple peaks or ups and downs. I don\\'t see how binary search could work when this is the case."
                    },
                    {
                        "username": "hsu2",
                        "content": "the problem should define \"peak\" as greater than or equal to its neighbors or give the constraint that all numbers are unique, so that the popular binary search will work."
                    },
                    {
                        "username": "FreeTymeKiyan",
                        "content": "Actually all the input arrays have only one peak. Obviously the solution won't be the same if there is an input of several peaks in an array. \\n\\nSay int[] num = {1, 2, 1, 3, 1, 4, 1}, num[i] is not equal to num[i + 1]."
                    },
                    {
                        "username": "jaswinder1997",
                        "content": "Why cannot we use binary search using while loop to find peak element in an array instead of using recursion as discussed in approach??\\n\\nThanks in Advance"
                    },
                    {
                        "username": "xchen182",
                        "content": "return distance(nums.begin(), max_element(nums.begin(),nums.end()));\\n//it only returns the index of max but peak.\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "This is very very simple, not medium. You label wrong."
                    },
                    {
                        "username": "abhisheak",
                        "content": "Let us say that we have a tint peak at the start:\\n[1,2,3,1,100,200,300,400,500,600,700]\\n\\nThe peak is 3. Most of the solutions seems to miss this case and incorrectly assumes that the peak exists in the 2nd half of the array and gives the answer as the last index.\\n\\nDo we have fool proof solution that covers this test case?"
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "The last constrain is so important that being put into the bottom of the context, and after all the examples. Shouldn\\'t such condition put into the first place?"
                    },
                    {
                        "username": "awilliams15",
                        "content": "For those struggling to understand why we know for sure we can do this in O(log n) time... Remember that in a scenario like nums = [3, 2, 1], 3 is a valid peak. "
                    }
                ]
            },
            {
                "id": 2064420,
                "content": [
                    {
                        "username": "alisktl",
                        "content": "I believe the problem cannot be solved in O(log n) time. For example, given the sequence [1, 2, 1, 2, 3, 4, 5, 7, 7], the correct answer should be 1. However, the solution with a time complexity of O(log n) would yield 8, which is incorrect."
                    },
                    {
                        "username": "sergei99",
                        "content": "It wouldn\\'t if you write it properly."
                    },
                    {
                        "username": "GrimShinigami",
                        "content": "I wanted to ask the experienced folks that instead of using full linear search I divided the array into two parts just initially and did the linear search then simultaneously so the complexity comes down to O(n/2) should I just implement binary search too or this is good enough time complexity as the solution already runs in 0ms so should there even be a need.\\nHere is my code for reference:\\nint findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1)\\n        return 0;\\n        int low=0,high=0,n=nums.size();\\n        if(n%2==0)\\n        {\\n            high=n/2;\\n            low=(n/2)-1;\\n        }\\n        else\\n        {\\n            high=n/2;\\n            low=n/2;\\n        }\\n        while(low>=0 && high<n)\\n        {\\n            if(low>0)\\n            {\\n                if(nums[low]>nums[low-1] && nums[low]>nums[low+1])\\n                return low;\\n            }\\n            else\\n            {\\n                if(nums[low]>nums[low+1])\\n                return low;\\n            }\\n            if(high<n-1)\\n            {\\n                if(nums[high]>nums[high-1] && nums[high]>nums[high+1])\\n                return high;\\n            }\\n            else\\n            {\\n                if(nums[high]>nums[high-1])\\n                return high;\\n            }\\n            --low;\\n            ++high;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "GrimShinigami",
                        "content": "[@sergei99](/sergei99) Yeah the number of accesses is same but I guess it works due to small size of the number of test cases"
                    },
                    {
                        "username": "sergei99",
                        "content": "You have not reduced the asymptotic complexity. $$O(n/2)$$ is the same as $$O(n)$$. Your code performs exactly same amount of memory accesses. comparisons and arithmetics as it did before, and it now also does more branching (`if`\\'s within the loop), which is generally bad for performance. I guess you should have unrolled the loop 2 times to get rid of than branching.\\nHowever, if it runs at 0ms, I think there is no point in optimizing it further - just with this amount of input data it doesn\\'t matter whether it\\'s $$O(n)$$ or $$O(log(n))$$ or $$O(1))$$. The task states that we need to solve in it $$O(log(n))$$, but they haven\\'t implemented any control measures for it whatsoever."
                    },
                    {
                        "username": "mochiball",
                        "content": "I think its easy to know this is a binary search problem . How do we know which half to search if our middle element is not what we want ? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Compare nums[mid] with nums[mid+1]. If nums[mid] is greater then the peak index might be mid or something lower so set your right pointer to mid and carry on. Otherwise, set your left pointer to mid+1 and carry on. The search ends when your left and right pointers are the same."
                    },
                    {
                        "username": "Huangzizhou",
                        "content": "This is essentially finding a local minima, which is the root of derivative (or difference in discrete case). The \"function derivative\" is positive on the left and negative on the right, so bisection can for sure find a root."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "This is definitely a easy question and not a binary search solution."
                    },
                    {
                        "username": "sk4142",
                        "content": "- - coming before nums[0] and after nums[n - 1] is a key to this problem. \n- Another key is that, although there may be duplicates in the array, adjacent elements are necessarily unique. \n- Hint: Search for monotonically (strictly) increasing subsequences."
                    },
                    {
                        "username": "user7413Id",
                        "content": "i beat this question by 100% among 2.4million submissions . reply me back to get the code."
                    },
                    {
                        "username": "Thetensordude",
                        "content": "Finally met with a scenario when the code works and beats 96% but I don\\'t know why! Maybe the neurons in my head knows but my mind does not know lol"
                    },
                    {
                        "username": "yuedai",
                        "content": "The question doesn\\'t say element should not be identical."
                    },
                    {
                        "username": "gargiegs",
                        "content": "I think the description should mention that the elements don\\'t repeat"
                    }
                ]
            },
            {
                "id": 2062827,
                "content": [
                    {
                        "username": "alisktl",
                        "content": "I believe the problem cannot be solved in O(log n) time. For example, given the sequence [1, 2, 1, 2, 3, 4, 5, 7, 7], the correct answer should be 1. However, the solution with a time complexity of O(log n) would yield 8, which is incorrect."
                    },
                    {
                        "username": "sergei99",
                        "content": "It wouldn\\'t if you write it properly."
                    },
                    {
                        "username": "GrimShinigami",
                        "content": "I wanted to ask the experienced folks that instead of using full linear search I divided the array into two parts just initially and did the linear search then simultaneously so the complexity comes down to O(n/2) should I just implement binary search too or this is good enough time complexity as the solution already runs in 0ms so should there even be a need.\\nHere is my code for reference:\\nint findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1)\\n        return 0;\\n        int low=0,high=0,n=nums.size();\\n        if(n%2==0)\\n        {\\n            high=n/2;\\n            low=(n/2)-1;\\n        }\\n        else\\n        {\\n            high=n/2;\\n            low=n/2;\\n        }\\n        while(low>=0 && high<n)\\n        {\\n            if(low>0)\\n            {\\n                if(nums[low]>nums[low-1] && nums[low]>nums[low+1])\\n                return low;\\n            }\\n            else\\n            {\\n                if(nums[low]>nums[low+1])\\n                return low;\\n            }\\n            if(high<n-1)\\n            {\\n                if(nums[high]>nums[high-1] && nums[high]>nums[high+1])\\n                return high;\\n            }\\n            else\\n            {\\n                if(nums[high]>nums[high-1])\\n                return high;\\n            }\\n            --low;\\n            ++high;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "GrimShinigami",
                        "content": "[@sergei99](/sergei99) Yeah the number of accesses is same but I guess it works due to small size of the number of test cases"
                    },
                    {
                        "username": "sergei99",
                        "content": "You have not reduced the asymptotic complexity. $$O(n/2)$$ is the same as $$O(n)$$. Your code performs exactly same amount of memory accesses. comparisons and arithmetics as it did before, and it now also does more branching (`if`\\'s within the loop), which is generally bad for performance. I guess you should have unrolled the loop 2 times to get rid of than branching.\\nHowever, if it runs at 0ms, I think there is no point in optimizing it further - just with this amount of input data it doesn\\'t matter whether it\\'s $$O(n)$$ or $$O(log(n))$$ or $$O(1))$$. The task states that we need to solve in it $$O(log(n))$$, but they haven\\'t implemented any control measures for it whatsoever."
                    },
                    {
                        "username": "mochiball",
                        "content": "I think its easy to know this is a binary search problem . How do we know which half to search if our middle element is not what we want ? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Compare nums[mid] with nums[mid+1]. If nums[mid] is greater then the peak index might be mid or something lower so set your right pointer to mid and carry on. Otherwise, set your left pointer to mid+1 and carry on. The search ends when your left and right pointers are the same."
                    },
                    {
                        "username": "Huangzizhou",
                        "content": "This is essentially finding a local minima, which is the root of derivative (or difference in discrete case). The \"function derivative\" is positive on the left and negative on the right, so bisection can for sure find a root."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "This is definitely a easy question and not a binary search solution."
                    },
                    {
                        "username": "sk4142",
                        "content": "- - coming before nums[0] and after nums[n - 1] is a key to this problem. \n- Another key is that, although there may be duplicates in the array, adjacent elements are necessarily unique. \n- Hint: Search for monotonically (strictly) increasing subsequences."
                    },
                    {
                        "username": "user7413Id",
                        "content": "i beat this question by 100% among 2.4million submissions . reply me back to get the code."
                    },
                    {
                        "username": "Thetensordude",
                        "content": "Finally met with a scenario when the code works and beats 96% but I don\\'t know why! Maybe the neurons in my head knows but my mind does not know lol"
                    },
                    {
                        "username": "yuedai",
                        "content": "The question doesn\\'t say element should not be identical."
                    },
                    {
                        "username": "gargiegs",
                        "content": "I think the description should mention that the elements don\\'t repeat"
                    }
                ]
            },
            {
                "id": 2062437,
                "content": [
                    {
                        "username": "alisktl",
                        "content": "I believe the problem cannot be solved in O(log n) time. For example, given the sequence [1, 2, 1, 2, 3, 4, 5, 7, 7], the correct answer should be 1. However, the solution with a time complexity of O(log n) would yield 8, which is incorrect."
                    },
                    {
                        "username": "sergei99",
                        "content": "It wouldn\\'t if you write it properly."
                    },
                    {
                        "username": "GrimShinigami",
                        "content": "I wanted to ask the experienced folks that instead of using full linear search I divided the array into two parts just initially and did the linear search then simultaneously so the complexity comes down to O(n/2) should I just implement binary search too or this is good enough time complexity as the solution already runs in 0ms so should there even be a need.\\nHere is my code for reference:\\nint findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1)\\n        return 0;\\n        int low=0,high=0,n=nums.size();\\n        if(n%2==0)\\n        {\\n            high=n/2;\\n            low=(n/2)-1;\\n        }\\n        else\\n        {\\n            high=n/2;\\n            low=n/2;\\n        }\\n        while(low>=0 && high<n)\\n        {\\n            if(low>0)\\n            {\\n                if(nums[low]>nums[low-1] && nums[low]>nums[low+1])\\n                return low;\\n            }\\n            else\\n            {\\n                if(nums[low]>nums[low+1])\\n                return low;\\n            }\\n            if(high<n-1)\\n            {\\n                if(nums[high]>nums[high-1] && nums[high]>nums[high+1])\\n                return high;\\n            }\\n            else\\n            {\\n                if(nums[high]>nums[high-1])\\n                return high;\\n            }\\n            --low;\\n            ++high;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "GrimShinigami",
                        "content": "[@sergei99](/sergei99) Yeah the number of accesses is same but I guess it works due to small size of the number of test cases"
                    },
                    {
                        "username": "sergei99",
                        "content": "You have not reduced the asymptotic complexity. $$O(n/2)$$ is the same as $$O(n)$$. Your code performs exactly same amount of memory accesses. comparisons and arithmetics as it did before, and it now also does more branching (`if`\\'s within the loop), which is generally bad for performance. I guess you should have unrolled the loop 2 times to get rid of than branching.\\nHowever, if it runs at 0ms, I think there is no point in optimizing it further - just with this amount of input data it doesn\\'t matter whether it\\'s $$O(n)$$ or $$O(log(n))$$ or $$O(1))$$. The task states that we need to solve in it $$O(log(n))$$, but they haven\\'t implemented any control measures for it whatsoever."
                    },
                    {
                        "username": "mochiball",
                        "content": "I think its easy to know this is a binary search problem . How do we know which half to search if our middle element is not what we want ? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Compare nums[mid] with nums[mid+1]. If nums[mid] is greater then the peak index might be mid or something lower so set your right pointer to mid and carry on. Otherwise, set your left pointer to mid+1 and carry on. The search ends when your left and right pointers are the same."
                    },
                    {
                        "username": "Huangzizhou",
                        "content": "This is essentially finding a local minima, which is the root of derivative (or difference in discrete case). The \"function derivative\" is positive on the left and negative on the right, so bisection can for sure find a root."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "This is definitely a easy question and not a binary search solution."
                    },
                    {
                        "username": "sk4142",
                        "content": "- - coming before nums[0] and after nums[n - 1] is a key to this problem. \n- Another key is that, although there may be duplicates in the array, adjacent elements are necessarily unique. \n- Hint: Search for monotonically (strictly) increasing subsequences."
                    },
                    {
                        "username": "user7413Id",
                        "content": "i beat this question by 100% among 2.4million submissions . reply me back to get the code."
                    },
                    {
                        "username": "Thetensordude",
                        "content": "Finally met with a scenario when the code works and beats 96% but I don\\'t know why! Maybe the neurons in my head knows but my mind does not know lol"
                    },
                    {
                        "username": "yuedai",
                        "content": "The question doesn\\'t say element should not be identical."
                    },
                    {
                        "username": "gargiegs",
                        "content": "I think the description should mention that the elements don\\'t repeat"
                    }
                ]
            },
            {
                "id": 2061771,
                "content": [
                    {
                        "username": "alisktl",
                        "content": "I believe the problem cannot be solved in O(log n) time. For example, given the sequence [1, 2, 1, 2, 3, 4, 5, 7, 7], the correct answer should be 1. However, the solution with a time complexity of O(log n) would yield 8, which is incorrect."
                    },
                    {
                        "username": "sergei99",
                        "content": "It wouldn\\'t if you write it properly."
                    },
                    {
                        "username": "GrimShinigami",
                        "content": "I wanted to ask the experienced folks that instead of using full linear search I divided the array into two parts just initially and did the linear search then simultaneously so the complexity comes down to O(n/2) should I just implement binary search too or this is good enough time complexity as the solution already runs in 0ms so should there even be a need.\\nHere is my code for reference:\\nint findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1)\\n        return 0;\\n        int low=0,high=0,n=nums.size();\\n        if(n%2==0)\\n        {\\n            high=n/2;\\n            low=(n/2)-1;\\n        }\\n        else\\n        {\\n            high=n/2;\\n            low=n/2;\\n        }\\n        while(low>=0 && high<n)\\n        {\\n            if(low>0)\\n            {\\n                if(nums[low]>nums[low-1] && nums[low]>nums[low+1])\\n                return low;\\n            }\\n            else\\n            {\\n                if(nums[low]>nums[low+1])\\n                return low;\\n            }\\n            if(high<n-1)\\n            {\\n                if(nums[high]>nums[high-1] && nums[high]>nums[high+1])\\n                return high;\\n            }\\n            else\\n            {\\n                if(nums[high]>nums[high-1])\\n                return high;\\n            }\\n            --low;\\n            ++high;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "GrimShinigami",
                        "content": "[@sergei99](/sergei99) Yeah the number of accesses is same but I guess it works due to small size of the number of test cases"
                    },
                    {
                        "username": "sergei99",
                        "content": "You have not reduced the asymptotic complexity. $$O(n/2)$$ is the same as $$O(n)$$. Your code performs exactly same amount of memory accesses. comparisons and arithmetics as it did before, and it now also does more branching (`if`\\'s within the loop), which is generally bad for performance. I guess you should have unrolled the loop 2 times to get rid of than branching.\\nHowever, if it runs at 0ms, I think there is no point in optimizing it further - just with this amount of input data it doesn\\'t matter whether it\\'s $$O(n)$$ or $$O(log(n))$$ or $$O(1))$$. The task states that we need to solve in it $$O(log(n))$$, but they haven\\'t implemented any control measures for it whatsoever."
                    },
                    {
                        "username": "mochiball",
                        "content": "I think its easy to know this is a binary search problem . How do we know which half to search if our middle element is not what we want ? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Compare nums[mid] with nums[mid+1]. If nums[mid] is greater then the peak index might be mid or something lower so set your right pointer to mid and carry on. Otherwise, set your left pointer to mid+1 and carry on. The search ends when your left and right pointers are the same."
                    },
                    {
                        "username": "Huangzizhou",
                        "content": "This is essentially finding a local minima, which is the root of derivative (or difference in discrete case). The \"function derivative\" is positive on the left and negative on the right, so bisection can for sure find a root."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "This is definitely a easy question and not a binary search solution."
                    },
                    {
                        "username": "sk4142",
                        "content": "- - coming before nums[0] and after nums[n - 1] is a key to this problem. \n- Another key is that, although there may be duplicates in the array, adjacent elements are necessarily unique. \n- Hint: Search for monotonically (strictly) increasing subsequences."
                    },
                    {
                        "username": "user7413Id",
                        "content": "i beat this question by 100% among 2.4million submissions . reply me back to get the code."
                    },
                    {
                        "username": "Thetensordude",
                        "content": "Finally met with a scenario when the code works and beats 96% but I don\\'t know why! Maybe the neurons in my head knows but my mind does not know lol"
                    },
                    {
                        "username": "yuedai",
                        "content": "The question doesn\\'t say element should not be identical."
                    },
                    {
                        "username": "gargiegs",
                        "content": "I think the description should mention that the elements don\\'t repeat"
                    }
                ]
            },
            {
                "id": 2048993,
                "content": [
                    {
                        "username": "alisktl",
                        "content": "I believe the problem cannot be solved in O(log n) time. For example, given the sequence [1, 2, 1, 2, 3, 4, 5, 7, 7], the correct answer should be 1. However, the solution with a time complexity of O(log n) would yield 8, which is incorrect."
                    },
                    {
                        "username": "sergei99",
                        "content": "It wouldn\\'t if you write it properly."
                    },
                    {
                        "username": "GrimShinigami",
                        "content": "I wanted to ask the experienced folks that instead of using full linear search I divided the array into two parts just initially and did the linear search then simultaneously so the complexity comes down to O(n/2) should I just implement binary search too or this is good enough time complexity as the solution already runs in 0ms so should there even be a need.\\nHere is my code for reference:\\nint findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1)\\n        return 0;\\n        int low=0,high=0,n=nums.size();\\n        if(n%2==0)\\n        {\\n            high=n/2;\\n            low=(n/2)-1;\\n        }\\n        else\\n        {\\n            high=n/2;\\n            low=n/2;\\n        }\\n        while(low>=0 && high<n)\\n        {\\n            if(low>0)\\n            {\\n                if(nums[low]>nums[low-1] && nums[low]>nums[low+1])\\n                return low;\\n            }\\n            else\\n            {\\n                if(nums[low]>nums[low+1])\\n                return low;\\n            }\\n            if(high<n-1)\\n            {\\n                if(nums[high]>nums[high-1] && nums[high]>nums[high+1])\\n                return high;\\n            }\\n            else\\n            {\\n                if(nums[high]>nums[high-1])\\n                return high;\\n            }\\n            --low;\\n            ++high;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "GrimShinigami",
                        "content": "[@sergei99](/sergei99) Yeah the number of accesses is same but I guess it works due to small size of the number of test cases"
                    },
                    {
                        "username": "sergei99",
                        "content": "You have not reduced the asymptotic complexity. $$O(n/2)$$ is the same as $$O(n)$$. Your code performs exactly same amount of memory accesses. comparisons and arithmetics as it did before, and it now also does more branching (`if`\\'s within the loop), which is generally bad for performance. I guess you should have unrolled the loop 2 times to get rid of than branching.\\nHowever, if it runs at 0ms, I think there is no point in optimizing it further - just with this amount of input data it doesn\\'t matter whether it\\'s $$O(n)$$ or $$O(log(n))$$ or $$O(1))$$. The task states that we need to solve in it $$O(log(n))$$, but they haven\\'t implemented any control measures for it whatsoever."
                    },
                    {
                        "username": "mochiball",
                        "content": "I think its easy to know this is a binary search problem . How do we know which half to search if our middle element is not what we want ? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Compare nums[mid] with nums[mid+1]. If nums[mid] is greater then the peak index might be mid or something lower so set your right pointer to mid and carry on. Otherwise, set your left pointer to mid+1 and carry on. The search ends when your left and right pointers are the same."
                    },
                    {
                        "username": "Huangzizhou",
                        "content": "This is essentially finding a local minima, which is the root of derivative (or difference in discrete case). The \"function derivative\" is positive on the left and negative on the right, so bisection can for sure find a root."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "This is definitely a easy question and not a binary search solution."
                    },
                    {
                        "username": "sk4142",
                        "content": "- - coming before nums[0] and after nums[n - 1] is a key to this problem. \n- Another key is that, although there may be duplicates in the array, adjacent elements are necessarily unique. \n- Hint: Search for monotonically (strictly) increasing subsequences."
                    },
                    {
                        "username": "user7413Id",
                        "content": "i beat this question by 100% among 2.4million submissions . reply me back to get the code."
                    },
                    {
                        "username": "Thetensordude",
                        "content": "Finally met with a scenario when the code works and beats 96% but I don\\'t know why! Maybe the neurons in my head knows but my mind does not know lol"
                    },
                    {
                        "username": "yuedai",
                        "content": "The question doesn\\'t say element should not be identical."
                    },
                    {
                        "username": "gargiegs",
                        "content": "I think the description should mention that the elements don\\'t repeat"
                    }
                ]
            },
            {
                "id": 2048208,
                "content": [
                    {
                        "username": "alisktl",
                        "content": "I believe the problem cannot be solved in O(log n) time. For example, given the sequence [1, 2, 1, 2, 3, 4, 5, 7, 7], the correct answer should be 1. However, the solution with a time complexity of O(log n) would yield 8, which is incorrect."
                    },
                    {
                        "username": "sergei99",
                        "content": "It wouldn\\'t if you write it properly."
                    },
                    {
                        "username": "GrimShinigami",
                        "content": "I wanted to ask the experienced folks that instead of using full linear search I divided the array into two parts just initially and did the linear search then simultaneously so the complexity comes down to O(n/2) should I just implement binary search too or this is good enough time complexity as the solution already runs in 0ms so should there even be a need.\\nHere is my code for reference:\\nint findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1)\\n        return 0;\\n        int low=0,high=0,n=nums.size();\\n        if(n%2==0)\\n        {\\n            high=n/2;\\n            low=(n/2)-1;\\n        }\\n        else\\n        {\\n            high=n/2;\\n            low=n/2;\\n        }\\n        while(low>=0 && high<n)\\n        {\\n            if(low>0)\\n            {\\n                if(nums[low]>nums[low-1] && nums[low]>nums[low+1])\\n                return low;\\n            }\\n            else\\n            {\\n                if(nums[low]>nums[low+1])\\n                return low;\\n            }\\n            if(high<n-1)\\n            {\\n                if(nums[high]>nums[high-1] && nums[high]>nums[high+1])\\n                return high;\\n            }\\n            else\\n            {\\n                if(nums[high]>nums[high-1])\\n                return high;\\n            }\\n            --low;\\n            ++high;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "GrimShinigami",
                        "content": "[@sergei99](/sergei99) Yeah the number of accesses is same but I guess it works due to small size of the number of test cases"
                    },
                    {
                        "username": "sergei99",
                        "content": "You have not reduced the asymptotic complexity. $$O(n/2)$$ is the same as $$O(n)$$. Your code performs exactly same amount of memory accesses. comparisons and arithmetics as it did before, and it now also does more branching (`if`\\'s within the loop), which is generally bad for performance. I guess you should have unrolled the loop 2 times to get rid of than branching.\\nHowever, if it runs at 0ms, I think there is no point in optimizing it further - just with this amount of input data it doesn\\'t matter whether it\\'s $$O(n)$$ or $$O(log(n))$$ or $$O(1))$$. The task states that we need to solve in it $$O(log(n))$$, but they haven\\'t implemented any control measures for it whatsoever."
                    },
                    {
                        "username": "mochiball",
                        "content": "I think its easy to know this is a binary search problem . How do we know which half to search if our middle element is not what we want ? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Compare nums[mid] with nums[mid+1]. If nums[mid] is greater then the peak index might be mid or something lower so set your right pointer to mid and carry on. Otherwise, set your left pointer to mid+1 and carry on. The search ends when your left and right pointers are the same."
                    },
                    {
                        "username": "Huangzizhou",
                        "content": "This is essentially finding a local minima, which is the root of derivative (or difference in discrete case). The \"function derivative\" is positive on the left and negative on the right, so bisection can for sure find a root."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "This is definitely a easy question and not a binary search solution."
                    },
                    {
                        "username": "sk4142",
                        "content": "- - coming before nums[0] and after nums[n - 1] is a key to this problem. \n- Another key is that, although there may be duplicates in the array, adjacent elements are necessarily unique. \n- Hint: Search for monotonically (strictly) increasing subsequences."
                    },
                    {
                        "username": "user7413Id",
                        "content": "i beat this question by 100% among 2.4million submissions . reply me back to get the code."
                    },
                    {
                        "username": "Thetensordude",
                        "content": "Finally met with a scenario when the code works and beats 96% but I don\\'t know why! Maybe the neurons in my head knows but my mind does not know lol"
                    },
                    {
                        "username": "yuedai",
                        "content": "The question doesn\\'t say element should not be identical."
                    },
                    {
                        "username": "gargiegs",
                        "content": "I think the description should mention that the elements don\\'t repeat"
                    }
                ]
            },
            {
                "id": 2048007,
                "content": [
                    {
                        "username": "alisktl",
                        "content": "I believe the problem cannot be solved in O(log n) time. For example, given the sequence [1, 2, 1, 2, 3, 4, 5, 7, 7], the correct answer should be 1. However, the solution with a time complexity of O(log n) would yield 8, which is incorrect."
                    },
                    {
                        "username": "sergei99",
                        "content": "It wouldn\\'t if you write it properly."
                    },
                    {
                        "username": "GrimShinigami",
                        "content": "I wanted to ask the experienced folks that instead of using full linear search I divided the array into two parts just initially and did the linear search then simultaneously so the complexity comes down to O(n/2) should I just implement binary search too or this is good enough time complexity as the solution already runs in 0ms so should there even be a need.\\nHere is my code for reference:\\nint findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1)\\n        return 0;\\n        int low=0,high=0,n=nums.size();\\n        if(n%2==0)\\n        {\\n            high=n/2;\\n            low=(n/2)-1;\\n        }\\n        else\\n        {\\n            high=n/2;\\n            low=n/2;\\n        }\\n        while(low>=0 && high<n)\\n        {\\n            if(low>0)\\n            {\\n                if(nums[low]>nums[low-1] && nums[low]>nums[low+1])\\n                return low;\\n            }\\n            else\\n            {\\n                if(nums[low]>nums[low+1])\\n                return low;\\n            }\\n            if(high<n-1)\\n            {\\n                if(nums[high]>nums[high-1] && nums[high]>nums[high+1])\\n                return high;\\n            }\\n            else\\n            {\\n                if(nums[high]>nums[high-1])\\n                return high;\\n            }\\n            --low;\\n            ++high;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "GrimShinigami",
                        "content": "[@sergei99](/sergei99) Yeah the number of accesses is same but I guess it works due to small size of the number of test cases"
                    },
                    {
                        "username": "sergei99",
                        "content": "You have not reduced the asymptotic complexity. $$O(n/2)$$ is the same as $$O(n)$$. Your code performs exactly same amount of memory accesses. comparisons and arithmetics as it did before, and it now also does more branching (`if`\\'s within the loop), which is generally bad for performance. I guess you should have unrolled the loop 2 times to get rid of than branching.\\nHowever, if it runs at 0ms, I think there is no point in optimizing it further - just with this amount of input data it doesn\\'t matter whether it\\'s $$O(n)$$ or $$O(log(n))$$ or $$O(1))$$. The task states that we need to solve in it $$O(log(n))$$, but they haven\\'t implemented any control measures for it whatsoever."
                    },
                    {
                        "username": "mochiball",
                        "content": "I think its easy to know this is a binary search problem . How do we know which half to search if our middle element is not what we want ? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Compare nums[mid] with nums[mid+1]. If nums[mid] is greater then the peak index might be mid or something lower so set your right pointer to mid and carry on. Otherwise, set your left pointer to mid+1 and carry on. The search ends when your left and right pointers are the same."
                    },
                    {
                        "username": "Huangzizhou",
                        "content": "This is essentially finding a local minima, which is the root of derivative (or difference in discrete case). The \"function derivative\" is positive on the left and negative on the right, so bisection can for sure find a root."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "This is definitely a easy question and not a binary search solution."
                    },
                    {
                        "username": "sk4142",
                        "content": "- - coming before nums[0] and after nums[n - 1] is a key to this problem. \n- Another key is that, although there may be duplicates in the array, adjacent elements are necessarily unique. \n- Hint: Search for monotonically (strictly) increasing subsequences."
                    },
                    {
                        "username": "user7413Id",
                        "content": "i beat this question by 100% among 2.4million submissions . reply me back to get the code."
                    },
                    {
                        "username": "Thetensordude",
                        "content": "Finally met with a scenario when the code works and beats 96% but I don\\'t know why! Maybe the neurons in my head knows but my mind does not know lol"
                    },
                    {
                        "username": "yuedai",
                        "content": "The question doesn\\'t say element should not be identical."
                    },
                    {
                        "username": "gargiegs",
                        "content": "I think the description should mention that the elements don\\'t repeat"
                    }
                ]
            },
            {
                "id": 2042937,
                "content": [
                    {
                        "username": "alisktl",
                        "content": "I believe the problem cannot be solved in O(log n) time. For example, given the sequence [1, 2, 1, 2, 3, 4, 5, 7, 7], the correct answer should be 1. However, the solution with a time complexity of O(log n) would yield 8, which is incorrect."
                    },
                    {
                        "username": "sergei99",
                        "content": "It wouldn\\'t if you write it properly."
                    },
                    {
                        "username": "GrimShinigami",
                        "content": "I wanted to ask the experienced folks that instead of using full linear search I divided the array into two parts just initially and did the linear search then simultaneously so the complexity comes down to O(n/2) should I just implement binary search too or this is good enough time complexity as the solution already runs in 0ms so should there even be a need.\\nHere is my code for reference:\\nint findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1)\\n        return 0;\\n        int low=0,high=0,n=nums.size();\\n        if(n%2==0)\\n        {\\n            high=n/2;\\n            low=(n/2)-1;\\n        }\\n        else\\n        {\\n            high=n/2;\\n            low=n/2;\\n        }\\n        while(low>=0 && high<n)\\n        {\\n            if(low>0)\\n            {\\n                if(nums[low]>nums[low-1] && nums[low]>nums[low+1])\\n                return low;\\n            }\\n            else\\n            {\\n                if(nums[low]>nums[low+1])\\n                return low;\\n            }\\n            if(high<n-1)\\n            {\\n                if(nums[high]>nums[high-1] && nums[high]>nums[high+1])\\n                return high;\\n            }\\n            else\\n            {\\n                if(nums[high]>nums[high-1])\\n                return high;\\n            }\\n            --low;\\n            ++high;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "GrimShinigami",
                        "content": "[@sergei99](/sergei99) Yeah the number of accesses is same but I guess it works due to small size of the number of test cases"
                    },
                    {
                        "username": "sergei99",
                        "content": "You have not reduced the asymptotic complexity. $$O(n/2)$$ is the same as $$O(n)$$. Your code performs exactly same amount of memory accesses. comparisons and arithmetics as it did before, and it now also does more branching (`if`\\'s within the loop), which is generally bad for performance. I guess you should have unrolled the loop 2 times to get rid of than branching.\\nHowever, if it runs at 0ms, I think there is no point in optimizing it further - just with this amount of input data it doesn\\'t matter whether it\\'s $$O(n)$$ or $$O(log(n))$$ or $$O(1))$$. The task states that we need to solve in it $$O(log(n))$$, but they haven\\'t implemented any control measures for it whatsoever."
                    },
                    {
                        "username": "mochiball",
                        "content": "I think its easy to know this is a binary search problem . How do we know which half to search if our middle element is not what we want ? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Compare nums[mid] with nums[mid+1]. If nums[mid] is greater then the peak index might be mid or something lower so set your right pointer to mid and carry on. Otherwise, set your left pointer to mid+1 and carry on. The search ends when your left and right pointers are the same."
                    },
                    {
                        "username": "Huangzizhou",
                        "content": "This is essentially finding a local minima, which is the root of derivative (or difference in discrete case). The \"function derivative\" is positive on the left and negative on the right, so bisection can for sure find a root."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "This is definitely a easy question and not a binary search solution."
                    },
                    {
                        "username": "sk4142",
                        "content": "- - coming before nums[0] and after nums[n - 1] is a key to this problem. \n- Another key is that, although there may be duplicates in the array, adjacent elements are necessarily unique. \n- Hint: Search for monotonically (strictly) increasing subsequences."
                    },
                    {
                        "username": "user7413Id",
                        "content": "i beat this question by 100% among 2.4million submissions . reply me back to get the code."
                    },
                    {
                        "username": "Thetensordude",
                        "content": "Finally met with a scenario when the code works and beats 96% but I don\\'t know why! Maybe the neurons in my head knows but my mind does not know lol"
                    },
                    {
                        "username": "yuedai",
                        "content": "The question doesn\\'t say element should not be identical."
                    },
                    {
                        "username": "gargiegs",
                        "content": "I think the description should mention that the elements don\\'t repeat"
                    }
                ]
            },
            {
                "id": 2036328,
                "content": [
                    {
                        "username": "alisktl",
                        "content": "I believe the problem cannot be solved in O(log n) time. For example, given the sequence [1, 2, 1, 2, 3, 4, 5, 7, 7], the correct answer should be 1. However, the solution with a time complexity of O(log n) would yield 8, which is incorrect."
                    },
                    {
                        "username": "sergei99",
                        "content": "It wouldn\\'t if you write it properly."
                    },
                    {
                        "username": "GrimShinigami",
                        "content": "I wanted to ask the experienced folks that instead of using full linear search I divided the array into two parts just initially and did the linear search then simultaneously so the complexity comes down to O(n/2) should I just implement binary search too or this is good enough time complexity as the solution already runs in 0ms so should there even be a need.\\nHere is my code for reference:\\nint findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1)\\n        return 0;\\n        int low=0,high=0,n=nums.size();\\n        if(n%2==0)\\n        {\\n            high=n/2;\\n            low=(n/2)-1;\\n        }\\n        else\\n        {\\n            high=n/2;\\n            low=n/2;\\n        }\\n        while(low>=0 && high<n)\\n        {\\n            if(low>0)\\n            {\\n                if(nums[low]>nums[low-1] && nums[low]>nums[low+1])\\n                return low;\\n            }\\n            else\\n            {\\n                if(nums[low]>nums[low+1])\\n                return low;\\n            }\\n            if(high<n-1)\\n            {\\n                if(nums[high]>nums[high-1] && nums[high]>nums[high+1])\\n                return high;\\n            }\\n            else\\n            {\\n                if(nums[high]>nums[high-1])\\n                return high;\\n            }\\n            --low;\\n            ++high;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "GrimShinigami",
                        "content": "[@sergei99](/sergei99) Yeah the number of accesses is same but I guess it works due to small size of the number of test cases"
                    },
                    {
                        "username": "sergei99",
                        "content": "You have not reduced the asymptotic complexity. $$O(n/2)$$ is the same as $$O(n)$$. Your code performs exactly same amount of memory accesses. comparisons and arithmetics as it did before, and it now also does more branching (`if`\\'s within the loop), which is generally bad for performance. I guess you should have unrolled the loop 2 times to get rid of than branching.\\nHowever, if it runs at 0ms, I think there is no point in optimizing it further - just with this amount of input data it doesn\\'t matter whether it\\'s $$O(n)$$ or $$O(log(n))$$ or $$O(1))$$. The task states that we need to solve in it $$O(log(n))$$, but they haven\\'t implemented any control measures for it whatsoever."
                    },
                    {
                        "username": "mochiball",
                        "content": "I think its easy to know this is a binary search problem . How do we know which half to search if our middle element is not what we want ? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Compare nums[mid] with nums[mid+1]. If nums[mid] is greater then the peak index might be mid or something lower so set your right pointer to mid and carry on. Otherwise, set your left pointer to mid+1 and carry on. The search ends when your left and right pointers are the same."
                    },
                    {
                        "username": "Huangzizhou",
                        "content": "This is essentially finding a local minima, which is the root of derivative (or difference in discrete case). The \"function derivative\" is positive on the left and negative on the right, so bisection can for sure find a root."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "This is definitely a easy question and not a binary search solution."
                    },
                    {
                        "username": "sk4142",
                        "content": "- - coming before nums[0] and after nums[n - 1] is a key to this problem. \n- Another key is that, although there may be duplicates in the array, adjacent elements are necessarily unique. \n- Hint: Search for monotonically (strictly) increasing subsequences."
                    },
                    {
                        "username": "user7413Id",
                        "content": "i beat this question by 100% among 2.4million submissions . reply me back to get the code."
                    },
                    {
                        "username": "Thetensordude",
                        "content": "Finally met with a scenario when the code works and beats 96% but I don\\'t know why! Maybe the neurons in my head knows but my mind does not know lol"
                    },
                    {
                        "username": "yuedai",
                        "content": "The question doesn\\'t say element should not be identical."
                    },
                    {
                        "username": "gargiegs",
                        "content": "I think the description should mention that the elements don\\'t repeat"
                    }
                ]
            },
            {
                "id": 2034729,
                "content": [
                    {
                        "username": "alisktl",
                        "content": "I believe the problem cannot be solved in O(log n) time. For example, given the sequence [1, 2, 1, 2, 3, 4, 5, 7, 7], the correct answer should be 1. However, the solution with a time complexity of O(log n) would yield 8, which is incorrect."
                    },
                    {
                        "username": "sergei99",
                        "content": "It wouldn\\'t if you write it properly."
                    },
                    {
                        "username": "GrimShinigami",
                        "content": "I wanted to ask the experienced folks that instead of using full linear search I divided the array into two parts just initially and did the linear search then simultaneously so the complexity comes down to O(n/2) should I just implement binary search too or this is good enough time complexity as the solution already runs in 0ms so should there even be a need.\\nHere is my code for reference:\\nint findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1)\\n        return 0;\\n        int low=0,high=0,n=nums.size();\\n        if(n%2==0)\\n        {\\n            high=n/2;\\n            low=(n/2)-1;\\n        }\\n        else\\n        {\\n            high=n/2;\\n            low=n/2;\\n        }\\n        while(low>=0 && high<n)\\n        {\\n            if(low>0)\\n            {\\n                if(nums[low]>nums[low-1] && nums[low]>nums[low+1])\\n                return low;\\n            }\\n            else\\n            {\\n                if(nums[low]>nums[low+1])\\n                return low;\\n            }\\n            if(high<n-1)\\n            {\\n                if(nums[high]>nums[high-1] && nums[high]>nums[high+1])\\n                return high;\\n            }\\n            else\\n            {\\n                if(nums[high]>nums[high-1])\\n                return high;\\n            }\\n            --low;\\n            ++high;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "GrimShinigami",
                        "content": "[@sergei99](/sergei99) Yeah the number of accesses is same but I guess it works due to small size of the number of test cases"
                    },
                    {
                        "username": "sergei99",
                        "content": "You have not reduced the asymptotic complexity. $$O(n/2)$$ is the same as $$O(n)$$. Your code performs exactly same amount of memory accesses. comparisons and arithmetics as it did before, and it now also does more branching (`if`\\'s within the loop), which is generally bad for performance. I guess you should have unrolled the loop 2 times to get rid of than branching.\\nHowever, if it runs at 0ms, I think there is no point in optimizing it further - just with this amount of input data it doesn\\'t matter whether it\\'s $$O(n)$$ or $$O(log(n))$$ or $$O(1))$$. The task states that we need to solve in it $$O(log(n))$$, but they haven\\'t implemented any control measures for it whatsoever."
                    },
                    {
                        "username": "mochiball",
                        "content": "I think its easy to know this is a binary search problem . How do we know which half to search if our middle element is not what we want ? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Compare nums[mid] with nums[mid+1]. If nums[mid] is greater then the peak index might be mid or something lower so set your right pointer to mid and carry on. Otherwise, set your left pointer to mid+1 and carry on. The search ends when your left and right pointers are the same."
                    },
                    {
                        "username": "Huangzizhou",
                        "content": "This is essentially finding a local minima, which is the root of derivative (or difference in discrete case). The \"function derivative\" is positive on the left and negative on the right, so bisection can for sure find a root."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "This is definitely a easy question and not a binary search solution."
                    },
                    {
                        "username": "sk4142",
                        "content": "- - coming before nums[0] and after nums[n - 1] is a key to this problem. \n- Another key is that, although there may be duplicates in the array, adjacent elements are necessarily unique. \n- Hint: Search for monotonically (strictly) increasing subsequences."
                    },
                    {
                        "username": "user7413Id",
                        "content": "i beat this question by 100% among 2.4million submissions . reply me back to get the code."
                    },
                    {
                        "username": "Thetensordude",
                        "content": "Finally met with a scenario when the code works and beats 96% but I don\\'t know why! Maybe the neurons in my head knows but my mind does not know lol"
                    },
                    {
                        "username": "yuedai",
                        "content": "The question doesn\\'t say element should not be identical."
                    },
                    {
                        "username": "gargiegs",
                        "content": "I think the description should mention that the elements don\\'t repeat"
                    }
                ]
            },
            {
                "id": 2032798,
                "content": [
                    {
                        "username": "RudrSharma",
                        "content": "int n = nums.size() ; \\n        int lo = 0 ; \\n        int hi   = n - 1 ; \\n        if(n==1)return 0;\\n        if(nums[0]>nums[1])return 0;\\n        if(nums[n-1]>nums[n-2])return n-1;\\n        int mid ; \\n        while (lo <= hi){\\n            mid  = lo + (hi - lo) / 2 ; \\n            if (nums[mid] > nums[mid+1] && nums[mid] > nums[mid-1]){\\n                return mid ; \\n            }\\n            else if (nums[mid] > nums[mid-1]){\\n                lo = mid ; \\n            }\\n            else hi = mid ;  \\n        }\\n        return -1  ; "
                    },
                    {
                        "username": "ishukhurana96",
                        "content": "How can you be so sure that if mid element is greater than mid-1 element then solution will be in right half only and vice versa if A[mid]<A[mid-1]??"
                    },
                    {
                        "username": "uniqs",
                        "content": "I wrote almost the same code, and it went wrong at some strange points. the error message is not helpful at all. if there is a vote for all the questions, i shall give this question score 0 in total score [0, 100], or even -1 if it is allowed."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "int left = 0, right = nums.size() - 1;\\n\\n    while (left < right) {\\n        int mid = left + (right - left) / 2;\\n\\n        if (nums[mid] > nums[mid + 1]) {\\n            right = mid;\\n        } else {\\n             left = mid + 1;\\n        }\\n    }\\n\\n    return left; \\nHow is this approach working in this question, when it is not mentioned anywhere that the array is sorted or not?"
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Reread constraints of task:  `nums[-1] = nums[n] = -\\u221E`. Draw a graph on paper where left and right edges are -\\u221E and you\\'ll see that the graph always has a peak. The peak can be either in the center of the array, or on its left side, or on its right."
                    },
                    {
                        "username": "Domesan",
                        "content": "[9, 2, 1, 7, 8, 6, 7] the output should point to number 9 or 8 right but the ans according to the logic is 7 at index 6? how come this"
                    },
                    {
                        "username": "vishwasamar1802",
                        "content": "i have used binary search still i am getting TLE \\nplease help me \\ngiving my code below........\\n\\n\\n\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        int st=0, end=nums.length-1, mid=0;\\n        if(nums.length==1) return 0;\\n        if(nums.length ==2)\\n            if(nums[0]>nums[1]) return 0;\\n            else return 1;\\n        while(st<=end){\\n            mid = st+(end-st)/2;\\n            if(mid==0 || mid==nums.length-1){\\n                if(mid==0 && nums[mid] > nums[mid+1]) return mid;\\n                if(mid==nums.length-1 && nums[mid] > nums[mid-1]) return mid;\\n            }\\n            if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1]) return mid;\\n            if(nums[mid]>nums[mid-1]) st=mid+1;\\n            if(nums[mid]>nums[mid+1]) end=mid-1;\\n\\n        }return mid;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Logan_SunSunSun",
                        "content": "A graphical explanation for using binary search in this question:\n\nStarting off, the left and right bounds are negative infinities, thus the whole array is of shape: /--------\\ . The middle elements' conditions are:\n1. If nums[0] > nums[n - 1], there would be a peak in the middle or at nums[0], because the height gap between nums[0] and nums[n - 1] needs to be covered by the middle nodes, resulting at least a peak at nums[0].\n2. If nums[0] < nums[n - 1], same reason for a peak possibly in middle or at least a peak at nums[n - 1].\n3. If nums[0] == nums[n - 1], then because there are no plateaus in the array, the range between nums[0] and nums[n  1] needs to be covered by slopes, thus there will for sure be a peak.\n\nIn conclusion: there will for sure be a peak in the initial nums.\n\nWhen we update the left and right pointers, we choose the middle pointers local slope:\n1. if it is a rising slope: /, then we update the former left bound rising slope: \n(/----------)/------\\   \nthe same shape of array is retained, thus the update guarantees a slope in the new range.\n2. If it is a falling slope: \\, similar updated problem set:\n /--------\\ (--------\\ )\n\n thus a valid update.\n\nIn the end, the two bounding slopes meet /\\ , and a peak is found.\n\nActually, any choice of the new position of left / right pointers are valid from our analysis. The /---\\ shaped structure will be retained as long as we check the new slope direction. It is just that binary search is the most efficient (Shannons equation), resulting in a O(logN) runtime.\n\nRecursion can be applied because of the same substructure in a fractal manner.\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "nums = [1,2,1,3,5,6,7]\\n\\nhow come the expected answer is index 6 instead of index 1 ?\\nim confused..\\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@atharva598](/atharva598) re-read the nums array . It's a custom test case . \n\nthere is only one peak element here which is index 1. But leetcode expecting answer is index 6(last index). the last index has only one neighbour and it's not satisfying the problem statement \n\nA peak element is an element that is strictly greater than its neighbours(plural).\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "both of them will be accepted, read the question carefully."
                    },
                    {
                        "username": "ganeshrocks140",
                        "content": "is question is all about returning the index of max element \\n\\nis my thinking correct???"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "I think the description is not that good . In python, reversing indexing is possible i.e., nums[-1] means last index in python."
                    },
                    {
                        "username": "psionl0",
                        "content": "``1 <= nums.length <= 1000``\\nLittle incentive to come up with a binary search solution."
                    },
                    {
                        "username": "Vishal_Parasram",
                        "content": "Can anyone help me why I\\'m getting error \\n `class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int start = 0; \\n        int end = nums.length;`\\n `\\n\\n        while (start <= end){\\n            int mid = start + (end - start) / 2;\\n\\n            if (nums < mid){\\n                end = mid + 1;\\n            }\\n            else if ( nums > mid){\\n                start = mid - 1;\\n            }\\n            else {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2030674,
                "content": [
                    {
                        "username": "RudrSharma",
                        "content": "int n = nums.size() ; \\n        int lo = 0 ; \\n        int hi   = n - 1 ; \\n        if(n==1)return 0;\\n        if(nums[0]>nums[1])return 0;\\n        if(nums[n-1]>nums[n-2])return n-1;\\n        int mid ; \\n        while (lo <= hi){\\n            mid  = lo + (hi - lo) / 2 ; \\n            if (nums[mid] > nums[mid+1] && nums[mid] > nums[mid-1]){\\n                return mid ; \\n            }\\n            else if (nums[mid] > nums[mid-1]){\\n                lo = mid ; \\n            }\\n            else hi = mid ;  \\n        }\\n        return -1  ; "
                    },
                    {
                        "username": "ishukhurana96",
                        "content": "How can you be so sure that if mid element is greater than mid-1 element then solution will be in right half only and vice versa if A[mid]<A[mid-1]??"
                    },
                    {
                        "username": "uniqs",
                        "content": "I wrote almost the same code, and it went wrong at some strange points. the error message is not helpful at all. if there is a vote for all the questions, i shall give this question score 0 in total score [0, 100], or even -1 if it is allowed."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "int left = 0, right = nums.size() - 1;\\n\\n    while (left < right) {\\n        int mid = left + (right - left) / 2;\\n\\n        if (nums[mid] > nums[mid + 1]) {\\n            right = mid;\\n        } else {\\n             left = mid + 1;\\n        }\\n    }\\n\\n    return left; \\nHow is this approach working in this question, when it is not mentioned anywhere that the array is sorted or not?"
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Reread constraints of task:  `nums[-1] = nums[n] = -\\u221E`. Draw a graph on paper where left and right edges are -\\u221E and you\\'ll see that the graph always has a peak. The peak can be either in the center of the array, or on its left side, or on its right."
                    },
                    {
                        "username": "Domesan",
                        "content": "[9, 2, 1, 7, 8, 6, 7] the output should point to number 9 or 8 right but the ans according to the logic is 7 at index 6? how come this"
                    },
                    {
                        "username": "vishwasamar1802",
                        "content": "i have used binary search still i am getting TLE \\nplease help me \\ngiving my code below........\\n\\n\\n\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        int st=0, end=nums.length-1, mid=0;\\n        if(nums.length==1) return 0;\\n        if(nums.length ==2)\\n            if(nums[0]>nums[1]) return 0;\\n            else return 1;\\n        while(st<=end){\\n            mid = st+(end-st)/2;\\n            if(mid==0 || mid==nums.length-1){\\n                if(mid==0 && nums[mid] > nums[mid+1]) return mid;\\n                if(mid==nums.length-1 && nums[mid] > nums[mid-1]) return mid;\\n            }\\n            if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1]) return mid;\\n            if(nums[mid]>nums[mid-1]) st=mid+1;\\n            if(nums[mid]>nums[mid+1]) end=mid-1;\\n\\n        }return mid;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Logan_SunSunSun",
                        "content": "A graphical explanation for using binary search in this question:\n\nStarting off, the left and right bounds are negative infinities, thus the whole array is of shape: /--------\\ . The middle elements' conditions are:\n1. If nums[0] > nums[n - 1], there would be a peak in the middle or at nums[0], because the height gap between nums[0] and nums[n - 1] needs to be covered by the middle nodes, resulting at least a peak at nums[0].\n2. If nums[0] < nums[n - 1], same reason for a peak possibly in middle or at least a peak at nums[n - 1].\n3. If nums[0] == nums[n - 1], then because there are no plateaus in the array, the range between nums[0] and nums[n  1] needs to be covered by slopes, thus there will for sure be a peak.\n\nIn conclusion: there will for sure be a peak in the initial nums.\n\nWhen we update the left and right pointers, we choose the middle pointers local slope:\n1. if it is a rising slope: /, then we update the former left bound rising slope: \n(/----------)/------\\   \nthe same shape of array is retained, thus the update guarantees a slope in the new range.\n2. If it is a falling slope: \\, similar updated problem set:\n /--------\\ (--------\\ )\n\n thus a valid update.\n\nIn the end, the two bounding slopes meet /\\ , and a peak is found.\n\nActually, any choice of the new position of left / right pointers are valid from our analysis. The /---\\ shaped structure will be retained as long as we check the new slope direction. It is just that binary search is the most efficient (Shannons equation), resulting in a O(logN) runtime.\n\nRecursion can be applied because of the same substructure in a fractal manner.\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "nums = [1,2,1,3,5,6,7]\\n\\nhow come the expected answer is index 6 instead of index 1 ?\\nim confused..\\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@atharva598](/atharva598) re-read the nums array . It's a custom test case . \n\nthere is only one peak element here which is index 1. But leetcode expecting answer is index 6(last index). the last index has only one neighbour and it's not satisfying the problem statement \n\nA peak element is an element that is strictly greater than its neighbours(plural).\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "both of them will be accepted, read the question carefully."
                    },
                    {
                        "username": "ganeshrocks140",
                        "content": "is question is all about returning the index of max element \\n\\nis my thinking correct???"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "I think the description is not that good . In python, reversing indexing is possible i.e., nums[-1] means last index in python."
                    },
                    {
                        "username": "psionl0",
                        "content": "``1 <= nums.length <= 1000``\\nLittle incentive to come up with a binary search solution."
                    },
                    {
                        "username": "Vishal_Parasram",
                        "content": "Can anyone help me why I\\'m getting error \\n `class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int start = 0; \\n        int end = nums.length;`\\n `\\n\\n        while (start <= end){\\n            int mid = start + (end - start) / 2;\\n\\n            if (nums < mid){\\n                end = mid + 1;\\n            }\\n            else if ( nums > mid){\\n                start = mid - 1;\\n            }\\n            else {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2003158,
                "content": [
                    {
                        "username": "RudrSharma",
                        "content": "int n = nums.size() ; \\n        int lo = 0 ; \\n        int hi   = n - 1 ; \\n        if(n==1)return 0;\\n        if(nums[0]>nums[1])return 0;\\n        if(nums[n-1]>nums[n-2])return n-1;\\n        int mid ; \\n        while (lo <= hi){\\n            mid  = lo + (hi - lo) / 2 ; \\n            if (nums[mid] > nums[mid+1] && nums[mid] > nums[mid-1]){\\n                return mid ; \\n            }\\n            else if (nums[mid] > nums[mid-1]){\\n                lo = mid ; \\n            }\\n            else hi = mid ;  \\n        }\\n        return -1  ; "
                    },
                    {
                        "username": "ishukhurana96",
                        "content": "How can you be so sure that if mid element is greater than mid-1 element then solution will be in right half only and vice versa if A[mid]<A[mid-1]??"
                    },
                    {
                        "username": "uniqs",
                        "content": "I wrote almost the same code, and it went wrong at some strange points. the error message is not helpful at all. if there is a vote for all the questions, i shall give this question score 0 in total score [0, 100], or even -1 if it is allowed."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "int left = 0, right = nums.size() - 1;\\n\\n    while (left < right) {\\n        int mid = left + (right - left) / 2;\\n\\n        if (nums[mid] > nums[mid + 1]) {\\n            right = mid;\\n        } else {\\n             left = mid + 1;\\n        }\\n    }\\n\\n    return left; \\nHow is this approach working in this question, when it is not mentioned anywhere that the array is sorted or not?"
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Reread constraints of task:  `nums[-1] = nums[n] = -\\u221E`. Draw a graph on paper where left and right edges are -\\u221E and you\\'ll see that the graph always has a peak. The peak can be either in the center of the array, or on its left side, or on its right."
                    },
                    {
                        "username": "Domesan",
                        "content": "[9, 2, 1, 7, 8, 6, 7] the output should point to number 9 or 8 right but the ans according to the logic is 7 at index 6? how come this"
                    },
                    {
                        "username": "vishwasamar1802",
                        "content": "i have used binary search still i am getting TLE \\nplease help me \\ngiving my code below........\\n\\n\\n\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        int st=0, end=nums.length-1, mid=0;\\n        if(nums.length==1) return 0;\\n        if(nums.length ==2)\\n            if(nums[0]>nums[1]) return 0;\\n            else return 1;\\n        while(st<=end){\\n            mid = st+(end-st)/2;\\n            if(mid==0 || mid==nums.length-1){\\n                if(mid==0 && nums[mid] > nums[mid+1]) return mid;\\n                if(mid==nums.length-1 && nums[mid] > nums[mid-1]) return mid;\\n            }\\n            if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1]) return mid;\\n            if(nums[mid]>nums[mid-1]) st=mid+1;\\n            if(nums[mid]>nums[mid+1]) end=mid-1;\\n\\n        }return mid;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Logan_SunSunSun",
                        "content": "A graphical explanation for using binary search in this question:\n\nStarting off, the left and right bounds are negative infinities, thus the whole array is of shape: /--------\\ . The middle elements' conditions are:\n1. If nums[0] > nums[n - 1], there would be a peak in the middle or at nums[0], because the height gap between nums[0] and nums[n - 1] needs to be covered by the middle nodes, resulting at least a peak at nums[0].\n2. If nums[0] < nums[n - 1], same reason for a peak possibly in middle or at least a peak at nums[n - 1].\n3. If nums[0] == nums[n - 1], then because there are no plateaus in the array, the range between nums[0] and nums[n  1] needs to be covered by slopes, thus there will for sure be a peak.\n\nIn conclusion: there will for sure be a peak in the initial nums.\n\nWhen we update the left and right pointers, we choose the middle pointers local slope:\n1. if it is a rising slope: /, then we update the former left bound rising slope: \n(/----------)/------\\   \nthe same shape of array is retained, thus the update guarantees a slope in the new range.\n2. If it is a falling slope: \\, similar updated problem set:\n /--------\\ (--------\\ )\n\n thus a valid update.\n\nIn the end, the two bounding slopes meet /\\ , and a peak is found.\n\nActually, any choice of the new position of left / right pointers are valid from our analysis. The /---\\ shaped structure will be retained as long as we check the new slope direction. It is just that binary search is the most efficient (Shannons equation), resulting in a O(logN) runtime.\n\nRecursion can be applied because of the same substructure in a fractal manner.\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "nums = [1,2,1,3,5,6,7]\\n\\nhow come the expected answer is index 6 instead of index 1 ?\\nim confused..\\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@atharva598](/atharva598) re-read the nums array . It's a custom test case . \n\nthere is only one peak element here which is index 1. But leetcode expecting answer is index 6(last index). the last index has only one neighbour and it's not satisfying the problem statement \n\nA peak element is an element that is strictly greater than its neighbours(plural).\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "both of them will be accepted, read the question carefully."
                    },
                    {
                        "username": "ganeshrocks140",
                        "content": "is question is all about returning the index of max element \\n\\nis my thinking correct???"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "I think the description is not that good . In python, reversing indexing is possible i.e., nums[-1] means last index in python."
                    },
                    {
                        "username": "psionl0",
                        "content": "``1 <= nums.length <= 1000``\\nLittle incentive to come up with a binary search solution."
                    },
                    {
                        "username": "Vishal_Parasram",
                        "content": "Can anyone help me why I\\'m getting error \\n `class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int start = 0; \\n        int end = nums.length;`\\n `\\n\\n        while (start <= end){\\n            int mid = start + (end - start) / 2;\\n\\n            if (nums < mid){\\n                end = mid + 1;\\n            }\\n            else if ( nums > mid){\\n                start = mid - 1;\\n            }\\n            else {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2000598,
                "content": [
                    {
                        "username": "RudrSharma",
                        "content": "int n = nums.size() ; \\n        int lo = 0 ; \\n        int hi   = n - 1 ; \\n        if(n==1)return 0;\\n        if(nums[0]>nums[1])return 0;\\n        if(nums[n-1]>nums[n-2])return n-1;\\n        int mid ; \\n        while (lo <= hi){\\n            mid  = lo + (hi - lo) / 2 ; \\n            if (nums[mid] > nums[mid+1] && nums[mid] > nums[mid-1]){\\n                return mid ; \\n            }\\n            else if (nums[mid] > nums[mid-1]){\\n                lo = mid ; \\n            }\\n            else hi = mid ;  \\n        }\\n        return -1  ; "
                    },
                    {
                        "username": "ishukhurana96",
                        "content": "How can you be so sure that if mid element is greater than mid-1 element then solution will be in right half only and vice versa if A[mid]<A[mid-1]??"
                    },
                    {
                        "username": "uniqs",
                        "content": "I wrote almost the same code, and it went wrong at some strange points. the error message is not helpful at all. if there is a vote for all the questions, i shall give this question score 0 in total score [0, 100], or even -1 if it is allowed."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "int left = 0, right = nums.size() - 1;\\n\\n    while (left < right) {\\n        int mid = left + (right - left) / 2;\\n\\n        if (nums[mid] > nums[mid + 1]) {\\n            right = mid;\\n        } else {\\n             left = mid + 1;\\n        }\\n    }\\n\\n    return left; \\nHow is this approach working in this question, when it is not mentioned anywhere that the array is sorted or not?"
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Reread constraints of task:  `nums[-1] = nums[n] = -\\u221E`. Draw a graph on paper where left and right edges are -\\u221E and you\\'ll see that the graph always has a peak. The peak can be either in the center of the array, or on its left side, or on its right."
                    },
                    {
                        "username": "Domesan",
                        "content": "[9, 2, 1, 7, 8, 6, 7] the output should point to number 9 or 8 right but the ans according to the logic is 7 at index 6? how come this"
                    },
                    {
                        "username": "vishwasamar1802",
                        "content": "i have used binary search still i am getting TLE \\nplease help me \\ngiving my code below........\\n\\n\\n\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        int st=0, end=nums.length-1, mid=0;\\n        if(nums.length==1) return 0;\\n        if(nums.length ==2)\\n            if(nums[0]>nums[1]) return 0;\\n            else return 1;\\n        while(st<=end){\\n            mid = st+(end-st)/2;\\n            if(mid==0 || mid==nums.length-1){\\n                if(mid==0 && nums[mid] > nums[mid+1]) return mid;\\n                if(mid==nums.length-1 && nums[mid] > nums[mid-1]) return mid;\\n            }\\n            if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1]) return mid;\\n            if(nums[mid]>nums[mid-1]) st=mid+1;\\n            if(nums[mid]>nums[mid+1]) end=mid-1;\\n\\n        }return mid;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Logan_SunSunSun",
                        "content": "A graphical explanation for using binary search in this question:\n\nStarting off, the left and right bounds are negative infinities, thus the whole array is of shape: /--------\\ . The middle elements' conditions are:\n1. If nums[0] > nums[n - 1], there would be a peak in the middle or at nums[0], because the height gap between nums[0] and nums[n - 1] needs to be covered by the middle nodes, resulting at least a peak at nums[0].\n2. If nums[0] < nums[n - 1], same reason for a peak possibly in middle or at least a peak at nums[n - 1].\n3. If nums[0] == nums[n - 1], then because there are no plateaus in the array, the range between nums[0] and nums[n  1] needs to be covered by slopes, thus there will for sure be a peak.\n\nIn conclusion: there will for sure be a peak in the initial nums.\n\nWhen we update the left and right pointers, we choose the middle pointers local slope:\n1. if it is a rising slope: /, then we update the former left bound rising slope: \n(/----------)/------\\   \nthe same shape of array is retained, thus the update guarantees a slope in the new range.\n2. If it is a falling slope: \\, similar updated problem set:\n /--------\\ (--------\\ )\n\n thus a valid update.\n\nIn the end, the two bounding slopes meet /\\ , and a peak is found.\n\nActually, any choice of the new position of left / right pointers are valid from our analysis. The /---\\ shaped structure will be retained as long as we check the new slope direction. It is just that binary search is the most efficient (Shannons equation), resulting in a O(logN) runtime.\n\nRecursion can be applied because of the same substructure in a fractal manner.\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "nums = [1,2,1,3,5,6,7]\\n\\nhow come the expected answer is index 6 instead of index 1 ?\\nim confused..\\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@atharva598](/atharva598) re-read the nums array . It's a custom test case . \n\nthere is only one peak element here which is index 1. But leetcode expecting answer is index 6(last index). the last index has only one neighbour and it's not satisfying the problem statement \n\nA peak element is an element that is strictly greater than its neighbours(plural).\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "both of them will be accepted, read the question carefully."
                    },
                    {
                        "username": "ganeshrocks140",
                        "content": "is question is all about returning the index of max element \\n\\nis my thinking correct???"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "I think the description is not that good . In python, reversing indexing is possible i.e., nums[-1] means last index in python."
                    },
                    {
                        "username": "psionl0",
                        "content": "``1 <= nums.length <= 1000``\\nLittle incentive to come up with a binary search solution."
                    },
                    {
                        "username": "Vishal_Parasram",
                        "content": "Can anyone help me why I\\'m getting error \\n `class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int start = 0; \\n        int end = nums.length;`\\n `\\n\\n        while (start <= end){\\n            int mid = start + (end - start) / 2;\\n\\n            if (nums < mid){\\n                end = mid + 1;\\n            }\\n            else if ( nums > mid){\\n                start = mid - 1;\\n            }\\n            else {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1999153,
                "content": [
                    {
                        "username": "RudrSharma",
                        "content": "int n = nums.size() ; \\n        int lo = 0 ; \\n        int hi   = n - 1 ; \\n        if(n==1)return 0;\\n        if(nums[0]>nums[1])return 0;\\n        if(nums[n-1]>nums[n-2])return n-1;\\n        int mid ; \\n        while (lo <= hi){\\n            mid  = lo + (hi - lo) / 2 ; \\n            if (nums[mid] > nums[mid+1] && nums[mid] > nums[mid-1]){\\n                return mid ; \\n            }\\n            else if (nums[mid] > nums[mid-1]){\\n                lo = mid ; \\n            }\\n            else hi = mid ;  \\n        }\\n        return -1  ; "
                    },
                    {
                        "username": "ishukhurana96",
                        "content": "How can you be so sure that if mid element is greater than mid-1 element then solution will be in right half only and vice versa if A[mid]<A[mid-1]??"
                    },
                    {
                        "username": "uniqs",
                        "content": "I wrote almost the same code, and it went wrong at some strange points. the error message is not helpful at all. if there is a vote for all the questions, i shall give this question score 0 in total score [0, 100], or even -1 if it is allowed."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "int left = 0, right = nums.size() - 1;\\n\\n    while (left < right) {\\n        int mid = left + (right - left) / 2;\\n\\n        if (nums[mid] > nums[mid + 1]) {\\n            right = mid;\\n        } else {\\n             left = mid + 1;\\n        }\\n    }\\n\\n    return left; \\nHow is this approach working in this question, when it is not mentioned anywhere that the array is sorted or not?"
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Reread constraints of task:  `nums[-1] = nums[n] = -\\u221E`. Draw a graph on paper where left and right edges are -\\u221E and you\\'ll see that the graph always has a peak. The peak can be either in the center of the array, or on its left side, or on its right."
                    },
                    {
                        "username": "Domesan",
                        "content": "[9, 2, 1, 7, 8, 6, 7] the output should point to number 9 or 8 right but the ans according to the logic is 7 at index 6? how come this"
                    },
                    {
                        "username": "vishwasamar1802",
                        "content": "i have used binary search still i am getting TLE \\nplease help me \\ngiving my code below........\\n\\n\\n\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        int st=0, end=nums.length-1, mid=0;\\n        if(nums.length==1) return 0;\\n        if(nums.length ==2)\\n            if(nums[0]>nums[1]) return 0;\\n            else return 1;\\n        while(st<=end){\\n            mid = st+(end-st)/2;\\n            if(mid==0 || mid==nums.length-1){\\n                if(mid==0 && nums[mid] > nums[mid+1]) return mid;\\n                if(mid==nums.length-1 && nums[mid] > nums[mid-1]) return mid;\\n            }\\n            if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1]) return mid;\\n            if(nums[mid]>nums[mid-1]) st=mid+1;\\n            if(nums[mid]>nums[mid+1]) end=mid-1;\\n\\n        }return mid;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Logan_SunSunSun",
                        "content": "A graphical explanation for using binary search in this question:\n\nStarting off, the left and right bounds are negative infinities, thus the whole array is of shape: /--------\\ . The middle elements' conditions are:\n1. If nums[0] > nums[n - 1], there would be a peak in the middle or at nums[0], because the height gap between nums[0] and nums[n - 1] needs to be covered by the middle nodes, resulting at least a peak at nums[0].\n2. If nums[0] < nums[n - 1], same reason for a peak possibly in middle or at least a peak at nums[n - 1].\n3. If nums[0] == nums[n - 1], then because there are no plateaus in the array, the range between nums[0] and nums[n  1] needs to be covered by slopes, thus there will for sure be a peak.\n\nIn conclusion: there will for sure be a peak in the initial nums.\n\nWhen we update the left and right pointers, we choose the middle pointers local slope:\n1. if it is a rising slope: /, then we update the former left bound rising slope: \n(/----------)/------\\   \nthe same shape of array is retained, thus the update guarantees a slope in the new range.\n2. If it is a falling slope: \\, similar updated problem set:\n /--------\\ (--------\\ )\n\n thus a valid update.\n\nIn the end, the two bounding slopes meet /\\ , and a peak is found.\n\nActually, any choice of the new position of left / right pointers are valid from our analysis. The /---\\ shaped structure will be retained as long as we check the new slope direction. It is just that binary search is the most efficient (Shannons equation), resulting in a O(logN) runtime.\n\nRecursion can be applied because of the same substructure in a fractal manner.\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "nums = [1,2,1,3,5,6,7]\\n\\nhow come the expected answer is index 6 instead of index 1 ?\\nim confused..\\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@atharva598](/atharva598) re-read the nums array . It's a custom test case . \n\nthere is only one peak element here which is index 1. But leetcode expecting answer is index 6(last index). the last index has only one neighbour and it's not satisfying the problem statement \n\nA peak element is an element that is strictly greater than its neighbours(plural).\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "both of them will be accepted, read the question carefully."
                    },
                    {
                        "username": "ganeshrocks140",
                        "content": "is question is all about returning the index of max element \\n\\nis my thinking correct???"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "I think the description is not that good . In python, reversing indexing is possible i.e., nums[-1] means last index in python."
                    },
                    {
                        "username": "psionl0",
                        "content": "``1 <= nums.length <= 1000``\\nLittle incentive to come up with a binary search solution."
                    },
                    {
                        "username": "Vishal_Parasram",
                        "content": "Can anyone help me why I\\'m getting error \\n `class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int start = 0; \\n        int end = nums.length;`\\n `\\n\\n        while (start <= end){\\n            int mid = start + (end - start) / 2;\\n\\n            if (nums < mid){\\n                end = mid + 1;\\n            }\\n            else if ( nums > mid){\\n                start = mid - 1;\\n            }\\n            else {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1997959,
                "content": [
                    {
                        "username": "RudrSharma",
                        "content": "int n = nums.size() ; \\n        int lo = 0 ; \\n        int hi   = n - 1 ; \\n        if(n==1)return 0;\\n        if(nums[0]>nums[1])return 0;\\n        if(nums[n-1]>nums[n-2])return n-1;\\n        int mid ; \\n        while (lo <= hi){\\n            mid  = lo + (hi - lo) / 2 ; \\n            if (nums[mid] > nums[mid+1] && nums[mid] > nums[mid-1]){\\n                return mid ; \\n            }\\n            else if (nums[mid] > nums[mid-1]){\\n                lo = mid ; \\n            }\\n            else hi = mid ;  \\n        }\\n        return -1  ; "
                    },
                    {
                        "username": "ishukhurana96",
                        "content": "How can you be so sure that if mid element is greater than mid-1 element then solution will be in right half only and vice versa if A[mid]<A[mid-1]??"
                    },
                    {
                        "username": "uniqs",
                        "content": "I wrote almost the same code, and it went wrong at some strange points. the error message is not helpful at all. if there is a vote for all the questions, i shall give this question score 0 in total score [0, 100], or even -1 if it is allowed."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "int left = 0, right = nums.size() - 1;\\n\\n    while (left < right) {\\n        int mid = left + (right - left) / 2;\\n\\n        if (nums[mid] > nums[mid + 1]) {\\n            right = mid;\\n        } else {\\n             left = mid + 1;\\n        }\\n    }\\n\\n    return left; \\nHow is this approach working in this question, when it is not mentioned anywhere that the array is sorted or not?"
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Reread constraints of task:  `nums[-1] = nums[n] = -\\u221E`. Draw a graph on paper where left and right edges are -\\u221E and you\\'ll see that the graph always has a peak. The peak can be either in the center of the array, or on its left side, or on its right."
                    },
                    {
                        "username": "Domesan",
                        "content": "[9, 2, 1, 7, 8, 6, 7] the output should point to number 9 or 8 right but the ans according to the logic is 7 at index 6? how come this"
                    },
                    {
                        "username": "vishwasamar1802",
                        "content": "i have used binary search still i am getting TLE \\nplease help me \\ngiving my code below........\\n\\n\\n\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        int st=0, end=nums.length-1, mid=0;\\n        if(nums.length==1) return 0;\\n        if(nums.length ==2)\\n            if(nums[0]>nums[1]) return 0;\\n            else return 1;\\n        while(st<=end){\\n            mid = st+(end-st)/2;\\n            if(mid==0 || mid==nums.length-1){\\n                if(mid==0 && nums[mid] > nums[mid+1]) return mid;\\n                if(mid==nums.length-1 && nums[mid] > nums[mid-1]) return mid;\\n            }\\n            if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1]) return mid;\\n            if(nums[mid]>nums[mid-1]) st=mid+1;\\n            if(nums[mid]>nums[mid+1]) end=mid-1;\\n\\n        }return mid;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Logan_SunSunSun",
                        "content": "A graphical explanation for using binary search in this question:\n\nStarting off, the left and right bounds are negative infinities, thus the whole array is of shape: /--------\\ . The middle elements' conditions are:\n1. If nums[0] > nums[n - 1], there would be a peak in the middle or at nums[0], because the height gap between nums[0] and nums[n - 1] needs to be covered by the middle nodes, resulting at least a peak at nums[0].\n2. If nums[0] < nums[n - 1], same reason for a peak possibly in middle or at least a peak at nums[n - 1].\n3. If nums[0] == nums[n - 1], then because there are no plateaus in the array, the range between nums[0] and nums[n  1] needs to be covered by slopes, thus there will for sure be a peak.\n\nIn conclusion: there will for sure be a peak in the initial nums.\n\nWhen we update the left and right pointers, we choose the middle pointers local slope:\n1. if it is a rising slope: /, then we update the former left bound rising slope: \n(/----------)/------\\   \nthe same shape of array is retained, thus the update guarantees a slope in the new range.\n2. If it is a falling slope: \\, similar updated problem set:\n /--------\\ (--------\\ )\n\n thus a valid update.\n\nIn the end, the two bounding slopes meet /\\ , and a peak is found.\n\nActually, any choice of the new position of left / right pointers are valid from our analysis. The /---\\ shaped structure will be retained as long as we check the new slope direction. It is just that binary search is the most efficient (Shannons equation), resulting in a O(logN) runtime.\n\nRecursion can be applied because of the same substructure in a fractal manner.\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "nums = [1,2,1,3,5,6,7]\\n\\nhow come the expected answer is index 6 instead of index 1 ?\\nim confused..\\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@atharva598](/atharva598) re-read the nums array . It's a custom test case . \n\nthere is only one peak element here which is index 1. But leetcode expecting answer is index 6(last index). the last index has only one neighbour and it's not satisfying the problem statement \n\nA peak element is an element that is strictly greater than its neighbours(plural).\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "both of them will be accepted, read the question carefully."
                    },
                    {
                        "username": "ganeshrocks140",
                        "content": "is question is all about returning the index of max element \\n\\nis my thinking correct???"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "I think the description is not that good . In python, reversing indexing is possible i.e., nums[-1] means last index in python."
                    },
                    {
                        "username": "psionl0",
                        "content": "``1 <= nums.length <= 1000``\\nLittle incentive to come up with a binary search solution."
                    },
                    {
                        "username": "Vishal_Parasram",
                        "content": "Can anyone help me why I\\'m getting error \\n `class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int start = 0; \\n        int end = nums.length;`\\n `\\n\\n        while (start <= end){\\n            int mid = start + (end - start) / 2;\\n\\n            if (nums < mid){\\n                end = mid + 1;\\n            }\\n            else if ( nums > mid){\\n                start = mid - 1;\\n            }\\n            else {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1992807,
                "content": [
                    {
                        "username": "RudrSharma",
                        "content": "int n = nums.size() ; \\n        int lo = 0 ; \\n        int hi   = n - 1 ; \\n        if(n==1)return 0;\\n        if(nums[0]>nums[1])return 0;\\n        if(nums[n-1]>nums[n-2])return n-1;\\n        int mid ; \\n        while (lo <= hi){\\n            mid  = lo + (hi - lo) / 2 ; \\n            if (nums[mid] > nums[mid+1] && nums[mid] > nums[mid-1]){\\n                return mid ; \\n            }\\n            else if (nums[mid] > nums[mid-1]){\\n                lo = mid ; \\n            }\\n            else hi = mid ;  \\n        }\\n        return -1  ; "
                    },
                    {
                        "username": "ishukhurana96",
                        "content": "How can you be so sure that if mid element is greater than mid-1 element then solution will be in right half only and vice versa if A[mid]<A[mid-1]??"
                    },
                    {
                        "username": "uniqs",
                        "content": "I wrote almost the same code, and it went wrong at some strange points. the error message is not helpful at all. if there is a vote for all the questions, i shall give this question score 0 in total score [0, 100], or even -1 if it is allowed."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "int left = 0, right = nums.size() - 1;\\n\\n    while (left < right) {\\n        int mid = left + (right - left) / 2;\\n\\n        if (nums[mid] > nums[mid + 1]) {\\n            right = mid;\\n        } else {\\n             left = mid + 1;\\n        }\\n    }\\n\\n    return left; \\nHow is this approach working in this question, when it is not mentioned anywhere that the array is sorted or not?"
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Reread constraints of task:  `nums[-1] = nums[n] = -\\u221E`. Draw a graph on paper where left and right edges are -\\u221E and you\\'ll see that the graph always has a peak. The peak can be either in the center of the array, or on its left side, or on its right."
                    },
                    {
                        "username": "Domesan",
                        "content": "[9, 2, 1, 7, 8, 6, 7] the output should point to number 9 or 8 right but the ans according to the logic is 7 at index 6? how come this"
                    },
                    {
                        "username": "vishwasamar1802",
                        "content": "i have used binary search still i am getting TLE \\nplease help me \\ngiving my code below........\\n\\n\\n\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        int st=0, end=nums.length-1, mid=0;\\n        if(nums.length==1) return 0;\\n        if(nums.length ==2)\\n            if(nums[0]>nums[1]) return 0;\\n            else return 1;\\n        while(st<=end){\\n            mid = st+(end-st)/2;\\n            if(mid==0 || mid==nums.length-1){\\n                if(mid==0 && nums[mid] > nums[mid+1]) return mid;\\n                if(mid==nums.length-1 && nums[mid] > nums[mid-1]) return mid;\\n            }\\n            if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1]) return mid;\\n            if(nums[mid]>nums[mid-1]) st=mid+1;\\n            if(nums[mid]>nums[mid+1]) end=mid-1;\\n\\n        }return mid;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Logan_SunSunSun",
                        "content": "A graphical explanation for using binary search in this question:\n\nStarting off, the left and right bounds are negative infinities, thus the whole array is of shape: /--------\\ . The middle elements' conditions are:\n1. If nums[0] > nums[n - 1], there would be a peak in the middle or at nums[0], because the height gap between nums[0] and nums[n - 1] needs to be covered by the middle nodes, resulting at least a peak at nums[0].\n2. If nums[0] < nums[n - 1], same reason for a peak possibly in middle or at least a peak at nums[n - 1].\n3. If nums[0] == nums[n - 1], then because there are no plateaus in the array, the range between nums[0] and nums[n  1] needs to be covered by slopes, thus there will for sure be a peak.\n\nIn conclusion: there will for sure be a peak in the initial nums.\n\nWhen we update the left and right pointers, we choose the middle pointers local slope:\n1. if it is a rising slope: /, then we update the former left bound rising slope: \n(/----------)/------\\   \nthe same shape of array is retained, thus the update guarantees a slope in the new range.\n2. If it is a falling slope: \\, similar updated problem set:\n /--------\\ (--------\\ )\n\n thus a valid update.\n\nIn the end, the two bounding slopes meet /\\ , and a peak is found.\n\nActually, any choice of the new position of left / right pointers are valid from our analysis. The /---\\ shaped structure will be retained as long as we check the new slope direction. It is just that binary search is the most efficient (Shannons equation), resulting in a O(logN) runtime.\n\nRecursion can be applied because of the same substructure in a fractal manner.\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "nums = [1,2,1,3,5,6,7]\\n\\nhow come the expected answer is index 6 instead of index 1 ?\\nim confused..\\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@atharva598](/atharva598) re-read the nums array . It's a custom test case . \n\nthere is only one peak element here which is index 1. But leetcode expecting answer is index 6(last index). the last index has only one neighbour and it's not satisfying the problem statement \n\nA peak element is an element that is strictly greater than its neighbours(plural).\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "both of them will be accepted, read the question carefully."
                    },
                    {
                        "username": "ganeshrocks140",
                        "content": "is question is all about returning the index of max element \\n\\nis my thinking correct???"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "I think the description is not that good . In python, reversing indexing is possible i.e., nums[-1] means last index in python."
                    },
                    {
                        "username": "psionl0",
                        "content": "``1 <= nums.length <= 1000``\\nLittle incentive to come up with a binary search solution."
                    },
                    {
                        "username": "Vishal_Parasram",
                        "content": "Can anyone help me why I\\'m getting error \\n `class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int start = 0; \\n        int end = nums.length;`\\n `\\n\\n        while (start <= end){\\n            int mid = start + (end - start) / 2;\\n\\n            if (nums < mid){\\n                end = mid + 1;\\n            }\\n            else if ( nums > mid){\\n                start = mid - 1;\\n            }\\n            else {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1985528,
                "content": [
                    {
                        "username": "RudrSharma",
                        "content": "int n = nums.size() ; \\n        int lo = 0 ; \\n        int hi   = n - 1 ; \\n        if(n==1)return 0;\\n        if(nums[0]>nums[1])return 0;\\n        if(nums[n-1]>nums[n-2])return n-1;\\n        int mid ; \\n        while (lo <= hi){\\n            mid  = lo + (hi - lo) / 2 ; \\n            if (nums[mid] > nums[mid+1] && nums[mid] > nums[mid-1]){\\n                return mid ; \\n            }\\n            else if (nums[mid] > nums[mid-1]){\\n                lo = mid ; \\n            }\\n            else hi = mid ;  \\n        }\\n        return -1  ; "
                    },
                    {
                        "username": "ishukhurana96",
                        "content": "How can you be so sure that if mid element is greater than mid-1 element then solution will be in right half only and vice versa if A[mid]<A[mid-1]??"
                    },
                    {
                        "username": "uniqs",
                        "content": "I wrote almost the same code, and it went wrong at some strange points. the error message is not helpful at all. if there is a vote for all the questions, i shall give this question score 0 in total score [0, 100], or even -1 if it is allowed."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "int left = 0, right = nums.size() - 1;\\n\\n    while (left < right) {\\n        int mid = left + (right - left) / 2;\\n\\n        if (nums[mid] > nums[mid + 1]) {\\n            right = mid;\\n        } else {\\n             left = mid + 1;\\n        }\\n    }\\n\\n    return left; \\nHow is this approach working in this question, when it is not mentioned anywhere that the array is sorted or not?"
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Reread constraints of task:  `nums[-1] = nums[n] = -\\u221E`. Draw a graph on paper where left and right edges are -\\u221E and you\\'ll see that the graph always has a peak. The peak can be either in the center of the array, or on its left side, or on its right."
                    },
                    {
                        "username": "Domesan",
                        "content": "[9, 2, 1, 7, 8, 6, 7] the output should point to number 9 or 8 right but the ans according to the logic is 7 at index 6? how come this"
                    },
                    {
                        "username": "vishwasamar1802",
                        "content": "i have used binary search still i am getting TLE \\nplease help me \\ngiving my code below........\\n\\n\\n\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        int st=0, end=nums.length-1, mid=0;\\n        if(nums.length==1) return 0;\\n        if(nums.length ==2)\\n            if(nums[0]>nums[1]) return 0;\\n            else return 1;\\n        while(st<=end){\\n            mid = st+(end-st)/2;\\n            if(mid==0 || mid==nums.length-1){\\n                if(mid==0 && nums[mid] > nums[mid+1]) return mid;\\n                if(mid==nums.length-1 && nums[mid] > nums[mid-1]) return mid;\\n            }\\n            if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1]) return mid;\\n            if(nums[mid]>nums[mid-1]) st=mid+1;\\n            if(nums[mid]>nums[mid+1]) end=mid-1;\\n\\n        }return mid;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Logan_SunSunSun",
                        "content": "A graphical explanation for using binary search in this question:\n\nStarting off, the left and right bounds are negative infinities, thus the whole array is of shape: /--------\\ . The middle elements' conditions are:\n1. If nums[0] > nums[n - 1], there would be a peak in the middle or at nums[0], because the height gap between nums[0] and nums[n - 1] needs to be covered by the middle nodes, resulting at least a peak at nums[0].\n2. If nums[0] < nums[n - 1], same reason for a peak possibly in middle or at least a peak at nums[n - 1].\n3. If nums[0] == nums[n - 1], then because there are no plateaus in the array, the range between nums[0] and nums[n  1] needs to be covered by slopes, thus there will for sure be a peak.\n\nIn conclusion: there will for sure be a peak in the initial nums.\n\nWhen we update the left and right pointers, we choose the middle pointers local slope:\n1. if it is a rising slope: /, then we update the former left bound rising slope: \n(/----------)/------\\   \nthe same shape of array is retained, thus the update guarantees a slope in the new range.\n2. If it is a falling slope: \\, similar updated problem set:\n /--------\\ (--------\\ )\n\n thus a valid update.\n\nIn the end, the two bounding slopes meet /\\ , and a peak is found.\n\nActually, any choice of the new position of left / right pointers are valid from our analysis. The /---\\ shaped structure will be retained as long as we check the new slope direction. It is just that binary search is the most efficient (Shannons equation), resulting in a O(logN) runtime.\n\nRecursion can be applied because of the same substructure in a fractal manner.\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "nums = [1,2,1,3,5,6,7]\\n\\nhow come the expected answer is index 6 instead of index 1 ?\\nim confused..\\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@atharva598](/atharva598) re-read the nums array . It's a custom test case . \n\nthere is only one peak element here which is index 1. But leetcode expecting answer is index 6(last index). the last index has only one neighbour and it's not satisfying the problem statement \n\nA peak element is an element that is strictly greater than its neighbours(plural).\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "both of them will be accepted, read the question carefully."
                    },
                    {
                        "username": "ganeshrocks140",
                        "content": "is question is all about returning the index of max element \\n\\nis my thinking correct???"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "I think the description is not that good . In python, reversing indexing is possible i.e., nums[-1] means last index in python."
                    },
                    {
                        "username": "psionl0",
                        "content": "``1 <= nums.length <= 1000``\\nLittle incentive to come up with a binary search solution."
                    },
                    {
                        "username": "Vishal_Parasram",
                        "content": "Can anyone help me why I\\'m getting error \\n `class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int start = 0; \\n        int end = nums.length;`\\n `\\n\\n        while (start <= end){\\n            int mid = start + (end - start) / 2;\\n\\n            if (nums < mid){\\n                end = mid + 1;\\n            }\\n            else if ( nums > mid){\\n                start = mid - 1;\\n            }\\n            else {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1985016,
                "content": [
                    {
                        "username": "RudrSharma",
                        "content": "int n = nums.size() ; \\n        int lo = 0 ; \\n        int hi   = n - 1 ; \\n        if(n==1)return 0;\\n        if(nums[0]>nums[1])return 0;\\n        if(nums[n-1]>nums[n-2])return n-1;\\n        int mid ; \\n        while (lo <= hi){\\n            mid  = lo + (hi - lo) / 2 ; \\n            if (nums[mid] > nums[mid+1] && nums[mid] > nums[mid-1]){\\n                return mid ; \\n            }\\n            else if (nums[mid] > nums[mid-1]){\\n                lo = mid ; \\n            }\\n            else hi = mid ;  \\n        }\\n        return -1  ; "
                    },
                    {
                        "username": "ishukhurana96",
                        "content": "How can you be so sure that if mid element is greater than mid-1 element then solution will be in right half only and vice versa if A[mid]<A[mid-1]??"
                    },
                    {
                        "username": "uniqs",
                        "content": "I wrote almost the same code, and it went wrong at some strange points. the error message is not helpful at all. if there is a vote for all the questions, i shall give this question score 0 in total score [0, 100], or even -1 if it is allowed."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "int left = 0, right = nums.size() - 1;\\n\\n    while (left < right) {\\n        int mid = left + (right - left) / 2;\\n\\n        if (nums[mid] > nums[mid + 1]) {\\n            right = mid;\\n        } else {\\n             left = mid + 1;\\n        }\\n    }\\n\\n    return left; \\nHow is this approach working in this question, when it is not mentioned anywhere that the array is sorted or not?"
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Reread constraints of task:  `nums[-1] = nums[n] = -\\u221E`. Draw a graph on paper where left and right edges are -\\u221E and you\\'ll see that the graph always has a peak. The peak can be either in the center of the array, or on its left side, or on its right."
                    },
                    {
                        "username": "Domesan",
                        "content": "[9, 2, 1, 7, 8, 6, 7] the output should point to number 9 or 8 right but the ans according to the logic is 7 at index 6? how come this"
                    },
                    {
                        "username": "vishwasamar1802",
                        "content": "i have used binary search still i am getting TLE \\nplease help me \\ngiving my code below........\\n\\n\\n\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        int st=0, end=nums.length-1, mid=0;\\n        if(nums.length==1) return 0;\\n        if(nums.length ==2)\\n            if(nums[0]>nums[1]) return 0;\\n            else return 1;\\n        while(st<=end){\\n            mid = st+(end-st)/2;\\n            if(mid==0 || mid==nums.length-1){\\n                if(mid==0 && nums[mid] > nums[mid+1]) return mid;\\n                if(mid==nums.length-1 && nums[mid] > nums[mid-1]) return mid;\\n            }\\n            if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1]) return mid;\\n            if(nums[mid]>nums[mid-1]) st=mid+1;\\n            if(nums[mid]>nums[mid+1]) end=mid-1;\\n\\n        }return mid;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Logan_SunSunSun",
                        "content": "A graphical explanation for using binary search in this question:\n\nStarting off, the left and right bounds are negative infinities, thus the whole array is of shape: /--------\\ . The middle elements' conditions are:\n1. If nums[0] > nums[n - 1], there would be a peak in the middle or at nums[0], because the height gap between nums[0] and nums[n - 1] needs to be covered by the middle nodes, resulting at least a peak at nums[0].\n2. If nums[0] < nums[n - 1], same reason for a peak possibly in middle or at least a peak at nums[n - 1].\n3. If nums[0] == nums[n - 1], then because there are no plateaus in the array, the range between nums[0] and nums[n  1] needs to be covered by slopes, thus there will for sure be a peak.\n\nIn conclusion: there will for sure be a peak in the initial nums.\n\nWhen we update the left and right pointers, we choose the middle pointers local slope:\n1. if it is a rising slope: /, then we update the former left bound rising slope: \n(/----------)/------\\   \nthe same shape of array is retained, thus the update guarantees a slope in the new range.\n2. If it is a falling slope: \\, similar updated problem set:\n /--------\\ (--------\\ )\n\n thus a valid update.\n\nIn the end, the two bounding slopes meet /\\ , and a peak is found.\n\nActually, any choice of the new position of left / right pointers are valid from our analysis. The /---\\ shaped structure will be retained as long as we check the new slope direction. It is just that binary search is the most efficient (Shannons equation), resulting in a O(logN) runtime.\n\nRecursion can be applied because of the same substructure in a fractal manner.\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "nums = [1,2,1,3,5,6,7]\\n\\nhow come the expected answer is index 6 instead of index 1 ?\\nim confused..\\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@atharva598](/atharva598) re-read the nums array . It's a custom test case . \n\nthere is only one peak element here which is index 1. But leetcode expecting answer is index 6(last index). the last index has only one neighbour and it's not satisfying the problem statement \n\nA peak element is an element that is strictly greater than its neighbours(plural).\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "both of them will be accepted, read the question carefully."
                    },
                    {
                        "username": "ganeshrocks140",
                        "content": "is question is all about returning the index of max element \\n\\nis my thinking correct???"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "I think the description is not that good . In python, reversing indexing is possible i.e., nums[-1] means last index in python."
                    },
                    {
                        "username": "psionl0",
                        "content": "``1 <= nums.length <= 1000``\\nLittle incentive to come up with a binary search solution."
                    },
                    {
                        "username": "Vishal_Parasram",
                        "content": "Can anyone help me why I\\'m getting error \\n `class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int start = 0; \\n        int end = nums.length;`\\n `\\n\\n        while (start <= end){\\n            int mid = start + (end - start) / 2;\\n\\n            if (nums < mid){\\n                end = mid + 1;\\n            }\\n            else if ( nums > mid){\\n                start = mid - 1;\\n            }\\n            else {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1977361,
                "content": [
                    {
                        "username": "RudrSharma",
                        "content": "int n = nums.size() ; \\n        int lo = 0 ; \\n        int hi   = n - 1 ; \\n        if(n==1)return 0;\\n        if(nums[0]>nums[1])return 0;\\n        if(nums[n-1]>nums[n-2])return n-1;\\n        int mid ; \\n        while (lo <= hi){\\n            mid  = lo + (hi - lo) / 2 ; \\n            if (nums[mid] > nums[mid+1] && nums[mid] > nums[mid-1]){\\n                return mid ; \\n            }\\n            else if (nums[mid] > nums[mid-1]){\\n                lo = mid ; \\n            }\\n            else hi = mid ;  \\n        }\\n        return -1  ; "
                    },
                    {
                        "username": "ishukhurana96",
                        "content": "How can you be so sure that if mid element is greater than mid-1 element then solution will be in right half only and vice versa if A[mid]<A[mid-1]??"
                    },
                    {
                        "username": "uniqs",
                        "content": "I wrote almost the same code, and it went wrong at some strange points. the error message is not helpful at all. if there is a vote for all the questions, i shall give this question score 0 in total score [0, 100], or even -1 if it is allowed."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "int left = 0, right = nums.size() - 1;\\n\\n    while (left < right) {\\n        int mid = left + (right - left) / 2;\\n\\n        if (nums[mid] > nums[mid + 1]) {\\n            right = mid;\\n        } else {\\n             left = mid + 1;\\n        }\\n    }\\n\\n    return left; \\nHow is this approach working in this question, when it is not mentioned anywhere that the array is sorted or not?"
                    },
                    {
                        "username": "eduAlexandrPirogov",
                        "content": "Reread constraints of task:  `nums[-1] = nums[n] = -\\u221E`. Draw a graph on paper where left and right edges are -\\u221E and you\\'ll see that the graph always has a peak. The peak can be either in the center of the array, or on its left side, or on its right."
                    },
                    {
                        "username": "Domesan",
                        "content": "[9, 2, 1, 7, 8, 6, 7] the output should point to number 9 or 8 right but the ans according to the logic is 7 at index 6? how come this"
                    },
                    {
                        "username": "vishwasamar1802",
                        "content": "i have used binary search still i am getting TLE \\nplease help me \\ngiving my code below........\\n\\n\\n\\nclass Solution {\\n    public int findPeakElement(int[] nums) {\\n        int st=0, end=nums.length-1, mid=0;\\n        if(nums.length==1) return 0;\\n        if(nums.length ==2)\\n            if(nums[0]>nums[1]) return 0;\\n            else return 1;\\n        while(st<=end){\\n            mid = st+(end-st)/2;\\n            if(mid==0 || mid==nums.length-1){\\n                if(mid==0 && nums[mid] > nums[mid+1]) return mid;\\n                if(mid==nums.length-1 && nums[mid] > nums[mid-1]) return mid;\\n            }\\n            if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1]) return mid;\\n            if(nums[mid]>nums[mid-1]) st=mid+1;\\n            if(nums[mid]>nums[mid+1]) end=mid-1;\\n\\n        }return mid;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Logan_SunSunSun",
                        "content": "A graphical explanation for using binary search in this question:\n\nStarting off, the left and right bounds are negative infinities, thus the whole array is of shape: /--------\\ . The middle elements' conditions are:\n1. If nums[0] > nums[n - 1], there would be a peak in the middle or at nums[0], because the height gap between nums[0] and nums[n - 1] needs to be covered by the middle nodes, resulting at least a peak at nums[0].\n2. If nums[0] < nums[n - 1], same reason for a peak possibly in middle or at least a peak at nums[n - 1].\n3. If nums[0] == nums[n - 1], then because there are no plateaus in the array, the range between nums[0] and nums[n  1] needs to be covered by slopes, thus there will for sure be a peak.\n\nIn conclusion: there will for sure be a peak in the initial nums.\n\nWhen we update the left and right pointers, we choose the middle pointers local slope:\n1. if it is a rising slope: /, then we update the former left bound rising slope: \n(/----------)/------\\   \nthe same shape of array is retained, thus the update guarantees a slope in the new range.\n2. If it is a falling slope: \\, similar updated problem set:\n /--------\\ (--------\\ )\n\n thus a valid update.\n\nIn the end, the two bounding slopes meet /\\ , and a peak is found.\n\nActually, any choice of the new position of left / right pointers are valid from our analysis. The /---\\ shaped structure will be retained as long as we check the new slope direction. It is just that binary search is the most efficient (Shannons equation), resulting in a O(logN) runtime.\n\nRecursion can be applied because of the same substructure in a fractal manner.\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "nums = [1,2,1,3,5,6,7]\\n\\nhow come the expected answer is index 6 instead of index 1 ?\\nim confused..\\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@atharva598](/atharva598) re-read the nums array . It's a custom test case . \n\nthere is only one peak element here which is index 1. But leetcode expecting answer is index 6(last index). the last index has only one neighbour and it's not satisfying the problem statement \n\nA peak element is an element that is strictly greater than its neighbours(plural).\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "both of them will be accepted, read the question carefully."
                    },
                    {
                        "username": "ganeshrocks140",
                        "content": "is question is all about returning the index of max element \\n\\nis my thinking correct???"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "I think the description is not that good . In python, reversing indexing is possible i.e., nums[-1] means last index in python."
                    },
                    {
                        "username": "psionl0",
                        "content": "``1 <= nums.length <= 1000``\\nLittle incentive to come up with a binary search solution."
                    },
                    {
                        "username": "Vishal_Parasram",
                        "content": "Can anyone help me why I\\'m getting error \\n `class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int start = 0; \\n        int end = nums.length;`\\n `\\n\\n        while (start <= end){\\n            int mid = start + (end - start) / 2;\\n\\n            if (nums < mid){\\n                end = mid + 1;\\n            }\\n            else if ( nums > mid){\\n                start = mid - 1;\\n            }\\n            else {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1976114,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "very easy leet\n`return nums.index(max(nums))`"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "This solution is very inefficient in this specific question. The time complexity is O(n). The time complexity of the optimal solution should be O(logN).  "
                    },
                    {
                        "username": "shubhamarya7103",
                        "content": "finding peak element and finding the greatest element in array is the same thing right ? if not how ? "
                    },
                    {
                        "username": "abinaya13897",
                        "content": "There can be many peak element but only one greater element"
                    },
                    {
                        "username": "GandhiHarsh",
                        "content": "class Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<long long > ans;      \\n        int n=nums.size();\\n        vector<long long> pre(n,0);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n\\n        }\\n        set<int> s;\\n        multiset<long long> st;\\n        s.insert(-1);\\n        st.insert(pre[n-1]);\\n        st.insert(0);\\n        for(auto x: removeQueries){\\n            auto it=lower_bound(s.begin(),s.end(),x);\\n            int left,right;\\n            if(it==s.end()){\\n                right=n-1;\\n            }else{\\n                right=(*it)-1;\\n            }\\n            it--;\\n            left=(*it);\\n            auto it2=st.begin();\\n            if(left==-1){\\n                it2=st.find(pre[right]);\\n            }else{\\n                it2=st.find(pre[right]-pre[left]);\\n            }\\n            st.erase(it2);\\n            if(pre[right]-pre[x]!=0)\\n                st.insert(pre[right]-pre[x]);\\n            if(x!=0){\\n                if(left==-1){\\n                    st.insert(pre[x-1] );\\n                }else{\\n                    if(pre[x-1]-pre[left]!=0)\\n                        st.insert(pre[x-1]-pre[left]);\\n                    \\n                }\\n            }\\n            it2=st.end();\\n            it2--;\\n            \\n            ans.push_back(*it2);\\n            s.insert(x);\\n        }\\n        return ans;\\n    }\\n};\\ncan anyone plz tell me what is the bug in this code "
                    },
                    {
                        "username": "Sujal04",
                        "content": "having problem for mid ==0 and mid == size()-1;\\n"
                    },
                    {
                        "username": "karanpatel5",
                        "content": "As they have asked that we can return any peak. that\\'s why we can solve it by binary search. Question no. 852 have exactly same code as the solution"
                    },
                    {
                        "username": "vaidehisawant",
                        "content": "When passed a testcase of  [1,2,3,5,3,2,1] these array elements the output comes out to be 3 instead of 5 which shouldn't be accepted as solution as correct answer is 5 as it is strictly greater than its neighbours am i missing out something or is the code incorrect for accepting the response any suggestions?"
                    },
                    {
                        "username": "Arvind321",
                        "content": "htttttt"
                    },
                    {
                        "username": "Akarsh_S",
                        "content": " Can some one tell me my mistake? It is not working for case nums ={2,1}.\\n \\n     while(s<=e){\\n        if(s==e)\\n        {\\n           return s;\\n        }\\n        else if (nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1] && mid+1<nums.size() && mid-1>=0)\\n        {// peak element\\n           return mid;\\n        }\\n        else if(nums[mid]<nums[mid+1] && mid+1<nums.size() && mid-1>=0)\\n        {//right search\\n            s=mid+1;\\n        }\\n        else if(nums[mid]>nums[mid+1] && mid+1<nums.size() && mid-1>=0)\\n        {//left search\\n            e=mid-1;\\n        }\\n        else\\n        {\\n           return mid;\\n        }\\n        mid = s + (e-s)/2;\\n     }\\n"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "class Solution {\\npublic:\\n\\n    int findPeakElement(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        if(n==1){\\n            return 0;\\n        }\\n\\n        int low=0;\\n        int high=n-1;\\n\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            \\n            //checking if mid is peak\\n            if(mid==0 && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            else if(mid==n-1 && nums[mid]>nums[mid-1]){\\n                return mid;\\n            }\\n            else if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]){\\n                 return mid;\\n            }\\n            //mid is not peak element\\n            else{\\n\\n                if(mid==0 && nums[mid+1]>nums[mid]){\\n                    low=mid+1;\\n                }\\n                else if(mid==n-1 && nums[mid-1]>nums[mid]){\\n                    high=mid-1;\\n                }\\n                else if(nums[mid+1]>nums[mid]){\\n                    low=mid+1;\\n                }\\n                else{\\n                    high=mid-1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n\\n\\nabove code is giving following error Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6030000000d0 overflowed to 0x6030000000cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\ncan anybody help me why it is giving above error?\\n\\n"
                    },
                    {
                        "username": "wangdrew",
                        "content": "The peak of an array is not necessarily the max element in the array. I went into this question with the implicit assumption that peak == max element and was struggling to arrive at a binary search algo. For example:\n\n[1,2,9,3,5,6,8,2,1]\n\nthe max element is 9, but the solution is 8 since that is a valid peak. Perhaps this is why there are so many downvotes."
                    }
                ]
            },
            {
                "id": 1972868,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "very easy leet\n`return nums.index(max(nums))`"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "This solution is very inefficient in this specific question. The time complexity is O(n). The time complexity of the optimal solution should be O(logN).  "
                    },
                    {
                        "username": "shubhamarya7103",
                        "content": "finding peak element and finding the greatest element in array is the same thing right ? if not how ? "
                    },
                    {
                        "username": "abinaya13897",
                        "content": "There can be many peak element but only one greater element"
                    },
                    {
                        "username": "GandhiHarsh",
                        "content": "class Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<long long > ans;      \\n        int n=nums.size();\\n        vector<long long> pre(n,0);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n\\n        }\\n        set<int> s;\\n        multiset<long long> st;\\n        s.insert(-1);\\n        st.insert(pre[n-1]);\\n        st.insert(0);\\n        for(auto x: removeQueries){\\n            auto it=lower_bound(s.begin(),s.end(),x);\\n            int left,right;\\n            if(it==s.end()){\\n                right=n-1;\\n            }else{\\n                right=(*it)-1;\\n            }\\n            it--;\\n            left=(*it);\\n            auto it2=st.begin();\\n            if(left==-1){\\n                it2=st.find(pre[right]);\\n            }else{\\n                it2=st.find(pre[right]-pre[left]);\\n            }\\n            st.erase(it2);\\n            if(pre[right]-pre[x]!=0)\\n                st.insert(pre[right]-pre[x]);\\n            if(x!=0){\\n                if(left==-1){\\n                    st.insert(pre[x-1] );\\n                }else{\\n                    if(pre[x-1]-pre[left]!=0)\\n                        st.insert(pre[x-1]-pre[left]);\\n                    \\n                }\\n            }\\n            it2=st.end();\\n            it2--;\\n            \\n            ans.push_back(*it2);\\n            s.insert(x);\\n        }\\n        return ans;\\n    }\\n};\\ncan anyone plz tell me what is the bug in this code "
                    },
                    {
                        "username": "Sujal04",
                        "content": "having problem for mid ==0 and mid == size()-1;\\n"
                    },
                    {
                        "username": "karanpatel5",
                        "content": "As they have asked that we can return any peak. that\\'s why we can solve it by binary search. Question no. 852 have exactly same code as the solution"
                    },
                    {
                        "username": "vaidehisawant",
                        "content": "When passed a testcase of  [1,2,3,5,3,2,1] these array elements the output comes out to be 3 instead of 5 which shouldn't be accepted as solution as correct answer is 5 as it is strictly greater than its neighbours am i missing out something or is the code incorrect for accepting the response any suggestions?"
                    },
                    {
                        "username": "Arvind321",
                        "content": "htttttt"
                    },
                    {
                        "username": "Akarsh_S",
                        "content": " Can some one tell me my mistake? It is not working for case nums ={2,1}.\\n \\n     while(s<=e){\\n        if(s==e)\\n        {\\n           return s;\\n        }\\n        else if (nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1] && mid+1<nums.size() && mid-1>=0)\\n        {// peak element\\n           return mid;\\n        }\\n        else if(nums[mid]<nums[mid+1] && mid+1<nums.size() && mid-1>=0)\\n        {//right search\\n            s=mid+1;\\n        }\\n        else if(nums[mid]>nums[mid+1] && mid+1<nums.size() && mid-1>=0)\\n        {//left search\\n            e=mid-1;\\n        }\\n        else\\n        {\\n           return mid;\\n        }\\n        mid = s + (e-s)/2;\\n     }\\n"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "class Solution {\\npublic:\\n\\n    int findPeakElement(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        if(n==1){\\n            return 0;\\n        }\\n\\n        int low=0;\\n        int high=n-1;\\n\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            \\n            //checking if mid is peak\\n            if(mid==0 && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            else if(mid==n-1 && nums[mid]>nums[mid-1]){\\n                return mid;\\n            }\\n            else if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]){\\n                 return mid;\\n            }\\n            //mid is not peak element\\n            else{\\n\\n                if(mid==0 && nums[mid+1]>nums[mid]){\\n                    low=mid+1;\\n                }\\n                else if(mid==n-1 && nums[mid-1]>nums[mid]){\\n                    high=mid-1;\\n                }\\n                else if(nums[mid+1]>nums[mid]){\\n                    low=mid+1;\\n                }\\n                else{\\n                    high=mid-1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n\\n\\nabove code is giving following error Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6030000000d0 overflowed to 0x6030000000cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\ncan anybody help me why it is giving above error?\\n\\n"
                    },
                    {
                        "username": "wangdrew",
                        "content": "The peak of an array is not necessarily the max element in the array. I went into this question with the implicit assumption that peak == max element and was struggling to arrive at a binary search algo. For example:\n\n[1,2,9,3,5,6,8,2,1]\n\nthe max element is 9, but the solution is 8 since that is a valid peak. Perhaps this is why there are so many downvotes."
                    }
                ]
            },
            {
                "id": 1960980,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "very easy leet\n`return nums.index(max(nums))`"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "This solution is very inefficient in this specific question. The time complexity is O(n). The time complexity of the optimal solution should be O(logN).  "
                    },
                    {
                        "username": "shubhamarya7103",
                        "content": "finding peak element and finding the greatest element in array is the same thing right ? if not how ? "
                    },
                    {
                        "username": "abinaya13897",
                        "content": "There can be many peak element but only one greater element"
                    },
                    {
                        "username": "GandhiHarsh",
                        "content": "class Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<long long > ans;      \\n        int n=nums.size();\\n        vector<long long> pre(n,0);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n\\n        }\\n        set<int> s;\\n        multiset<long long> st;\\n        s.insert(-1);\\n        st.insert(pre[n-1]);\\n        st.insert(0);\\n        for(auto x: removeQueries){\\n            auto it=lower_bound(s.begin(),s.end(),x);\\n            int left,right;\\n            if(it==s.end()){\\n                right=n-1;\\n            }else{\\n                right=(*it)-1;\\n            }\\n            it--;\\n            left=(*it);\\n            auto it2=st.begin();\\n            if(left==-1){\\n                it2=st.find(pre[right]);\\n            }else{\\n                it2=st.find(pre[right]-pre[left]);\\n            }\\n            st.erase(it2);\\n            if(pre[right]-pre[x]!=0)\\n                st.insert(pre[right]-pre[x]);\\n            if(x!=0){\\n                if(left==-1){\\n                    st.insert(pre[x-1] );\\n                }else{\\n                    if(pre[x-1]-pre[left]!=0)\\n                        st.insert(pre[x-1]-pre[left]);\\n                    \\n                }\\n            }\\n            it2=st.end();\\n            it2--;\\n            \\n            ans.push_back(*it2);\\n            s.insert(x);\\n        }\\n        return ans;\\n    }\\n};\\ncan anyone plz tell me what is the bug in this code "
                    },
                    {
                        "username": "Sujal04",
                        "content": "having problem for mid ==0 and mid == size()-1;\\n"
                    },
                    {
                        "username": "karanpatel5",
                        "content": "As they have asked that we can return any peak. that\\'s why we can solve it by binary search. Question no. 852 have exactly same code as the solution"
                    },
                    {
                        "username": "vaidehisawant",
                        "content": "When passed a testcase of  [1,2,3,5,3,2,1] these array elements the output comes out to be 3 instead of 5 which shouldn't be accepted as solution as correct answer is 5 as it is strictly greater than its neighbours am i missing out something or is the code incorrect for accepting the response any suggestions?"
                    },
                    {
                        "username": "Arvind321",
                        "content": "htttttt"
                    },
                    {
                        "username": "Akarsh_S",
                        "content": " Can some one tell me my mistake? It is not working for case nums ={2,1}.\\n \\n     while(s<=e){\\n        if(s==e)\\n        {\\n           return s;\\n        }\\n        else if (nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1] && mid+1<nums.size() && mid-1>=0)\\n        {// peak element\\n           return mid;\\n        }\\n        else if(nums[mid]<nums[mid+1] && mid+1<nums.size() && mid-1>=0)\\n        {//right search\\n            s=mid+1;\\n        }\\n        else if(nums[mid]>nums[mid+1] && mid+1<nums.size() && mid-1>=0)\\n        {//left search\\n            e=mid-1;\\n        }\\n        else\\n        {\\n           return mid;\\n        }\\n        mid = s + (e-s)/2;\\n     }\\n"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "class Solution {\\npublic:\\n\\n    int findPeakElement(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        if(n==1){\\n            return 0;\\n        }\\n\\n        int low=0;\\n        int high=n-1;\\n\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            \\n            //checking if mid is peak\\n            if(mid==0 && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            else if(mid==n-1 && nums[mid]>nums[mid-1]){\\n                return mid;\\n            }\\n            else if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]){\\n                 return mid;\\n            }\\n            //mid is not peak element\\n            else{\\n\\n                if(mid==0 && nums[mid+1]>nums[mid]){\\n                    low=mid+1;\\n                }\\n                else if(mid==n-1 && nums[mid-1]>nums[mid]){\\n                    high=mid-1;\\n                }\\n                else if(nums[mid+1]>nums[mid]){\\n                    low=mid+1;\\n                }\\n                else{\\n                    high=mid-1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n\\n\\nabove code is giving following error Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6030000000d0 overflowed to 0x6030000000cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\ncan anybody help me why it is giving above error?\\n\\n"
                    },
                    {
                        "username": "wangdrew",
                        "content": "The peak of an array is not necessarily the max element in the array. I went into this question with the implicit assumption that peak == max element and was struggling to arrive at a binary search algo. For example:\n\n[1,2,9,3,5,6,8,2,1]\n\nthe max element is 9, but the solution is 8 since that is a valid peak. Perhaps this is why there are so many downvotes."
                    }
                ]
            },
            {
                "id": 1956493,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "very easy leet\n`return nums.index(max(nums))`"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "This solution is very inefficient in this specific question. The time complexity is O(n). The time complexity of the optimal solution should be O(logN).  "
                    },
                    {
                        "username": "shubhamarya7103",
                        "content": "finding peak element and finding the greatest element in array is the same thing right ? if not how ? "
                    },
                    {
                        "username": "abinaya13897",
                        "content": "There can be many peak element but only one greater element"
                    },
                    {
                        "username": "GandhiHarsh",
                        "content": "class Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<long long > ans;      \\n        int n=nums.size();\\n        vector<long long> pre(n,0);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n\\n        }\\n        set<int> s;\\n        multiset<long long> st;\\n        s.insert(-1);\\n        st.insert(pre[n-1]);\\n        st.insert(0);\\n        for(auto x: removeQueries){\\n            auto it=lower_bound(s.begin(),s.end(),x);\\n            int left,right;\\n            if(it==s.end()){\\n                right=n-1;\\n            }else{\\n                right=(*it)-1;\\n            }\\n            it--;\\n            left=(*it);\\n            auto it2=st.begin();\\n            if(left==-1){\\n                it2=st.find(pre[right]);\\n            }else{\\n                it2=st.find(pre[right]-pre[left]);\\n            }\\n            st.erase(it2);\\n            if(pre[right]-pre[x]!=0)\\n                st.insert(pre[right]-pre[x]);\\n            if(x!=0){\\n                if(left==-1){\\n                    st.insert(pre[x-1] );\\n                }else{\\n                    if(pre[x-1]-pre[left]!=0)\\n                        st.insert(pre[x-1]-pre[left]);\\n                    \\n                }\\n            }\\n            it2=st.end();\\n            it2--;\\n            \\n            ans.push_back(*it2);\\n            s.insert(x);\\n        }\\n        return ans;\\n    }\\n};\\ncan anyone plz tell me what is the bug in this code "
                    },
                    {
                        "username": "Sujal04",
                        "content": "having problem for mid ==0 and mid == size()-1;\\n"
                    },
                    {
                        "username": "karanpatel5",
                        "content": "As they have asked that we can return any peak. that\\'s why we can solve it by binary search. Question no. 852 have exactly same code as the solution"
                    },
                    {
                        "username": "vaidehisawant",
                        "content": "When passed a testcase of  [1,2,3,5,3,2,1] these array elements the output comes out to be 3 instead of 5 which shouldn't be accepted as solution as correct answer is 5 as it is strictly greater than its neighbours am i missing out something or is the code incorrect for accepting the response any suggestions?"
                    },
                    {
                        "username": "Arvind321",
                        "content": "htttttt"
                    },
                    {
                        "username": "Akarsh_S",
                        "content": " Can some one tell me my mistake? It is not working for case nums ={2,1}.\\n \\n     while(s<=e){\\n        if(s==e)\\n        {\\n           return s;\\n        }\\n        else if (nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1] && mid+1<nums.size() && mid-1>=0)\\n        {// peak element\\n           return mid;\\n        }\\n        else if(nums[mid]<nums[mid+1] && mid+1<nums.size() && mid-1>=0)\\n        {//right search\\n            s=mid+1;\\n        }\\n        else if(nums[mid]>nums[mid+1] && mid+1<nums.size() && mid-1>=0)\\n        {//left search\\n            e=mid-1;\\n        }\\n        else\\n        {\\n           return mid;\\n        }\\n        mid = s + (e-s)/2;\\n     }\\n"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "class Solution {\\npublic:\\n\\n    int findPeakElement(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        if(n==1){\\n            return 0;\\n        }\\n\\n        int low=0;\\n        int high=n-1;\\n\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            \\n            //checking if mid is peak\\n            if(mid==0 && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            else if(mid==n-1 && nums[mid]>nums[mid-1]){\\n                return mid;\\n            }\\n            else if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]){\\n                 return mid;\\n            }\\n            //mid is not peak element\\n            else{\\n\\n                if(mid==0 && nums[mid+1]>nums[mid]){\\n                    low=mid+1;\\n                }\\n                else if(mid==n-1 && nums[mid-1]>nums[mid]){\\n                    high=mid-1;\\n                }\\n                else if(nums[mid+1]>nums[mid]){\\n                    low=mid+1;\\n                }\\n                else{\\n                    high=mid-1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n\\n\\nabove code is giving following error Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6030000000d0 overflowed to 0x6030000000cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\ncan anybody help me why it is giving above error?\\n\\n"
                    },
                    {
                        "username": "wangdrew",
                        "content": "The peak of an array is not necessarily the max element in the array. I went into this question with the implicit assumption that peak == max element and was struggling to arrive at a binary search algo. For example:\n\n[1,2,9,3,5,6,8,2,1]\n\nthe max element is 9, but the solution is 8 since that is a valid peak. Perhaps this is why there are so many downvotes."
                    }
                ]
            },
            {
                "id": 1955901,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "very easy leet\n`return nums.index(max(nums))`"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "This solution is very inefficient in this specific question. The time complexity is O(n). The time complexity of the optimal solution should be O(logN).  "
                    },
                    {
                        "username": "shubhamarya7103",
                        "content": "finding peak element and finding the greatest element in array is the same thing right ? if not how ? "
                    },
                    {
                        "username": "abinaya13897",
                        "content": "There can be many peak element but only one greater element"
                    },
                    {
                        "username": "GandhiHarsh",
                        "content": "class Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<long long > ans;      \\n        int n=nums.size();\\n        vector<long long> pre(n,0);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n\\n        }\\n        set<int> s;\\n        multiset<long long> st;\\n        s.insert(-1);\\n        st.insert(pre[n-1]);\\n        st.insert(0);\\n        for(auto x: removeQueries){\\n            auto it=lower_bound(s.begin(),s.end(),x);\\n            int left,right;\\n            if(it==s.end()){\\n                right=n-1;\\n            }else{\\n                right=(*it)-1;\\n            }\\n            it--;\\n            left=(*it);\\n            auto it2=st.begin();\\n            if(left==-1){\\n                it2=st.find(pre[right]);\\n            }else{\\n                it2=st.find(pre[right]-pre[left]);\\n            }\\n            st.erase(it2);\\n            if(pre[right]-pre[x]!=0)\\n                st.insert(pre[right]-pre[x]);\\n            if(x!=0){\\n                if(left==-1){\\n                    st.insert(pre[x-1] );\\n                }else{\\n                    if(pre[x-1]-pre[left]!=0)\\n                        st.insert(pre[x-1]-pre[left]);\\n                    \\n                }\\n            }\\n            it2=st.end();\\n            it2--;\\n            \\n            ans.push_back(*it2);\\n            s.insert(x);\\n        }\\n        return ans;\\n    }\\n};\\ncan anyone plz tell me what is the bug in this code "
                    },
                    {
                        "username": "Sujal04",
                        "content": "having problem for mid ==0 and mid == size()-1;\\n"
                    },
                    {
                        "username": "karanpatel5",
                        "content": "As they have asked that we can return any peak. that\\'s why we can solve it by binary search. Question no. 852 have exactly same code as the solution"
                    },
                    {
                        "username": "vaidehisawant",
                        "content": "When passed a testcase of  [1,2,3,5,3,2,1] these array elements the output comes out to be 3 instead of 5 which shouldn't be accepted as solution as correct answer is 5 as it is strictly greater than its neighbours am i missing out something or is the code incorrect for accepting the response any suggestions?"
                    },
                    {
                        "username": "Arvind321",
                        "content": "htttttt"
                    },
                    {
                        "username": "Akarsh_S",
                        "content": " Can some one tell me my mistake? It is not working for case nums ={2,1}.\\n \\n     while(s<=e){\\n        if(s==e)\\n        {\\n           return s;\\n        }\\n        else if (nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1] && mid+1<nums.size() && mid-1>=0)\\n        {// peak element\\n           return mid;\\n        }\\n        else if(nums[mid]<nums[mid+1] && mid+1<nums.size() && mid-1>=0)\\n        {//right search\\n            s=mid+1;\\n        }\\n        else if(nums[mid]>nums[mid+1] && mid+1<nums.size() && mid-1>=0)\\n        {//left search\\n            e=mid-1;\\n        }\\n        else\\n        {\\n           return mid;\\n        }\\n        mid = s + (e-s)/2;\\n     }\\n"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "class Solution {\\npublic:\\n\\n    int findPeakElement(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        if(n==1){\\n            return 0;\\n        }\\n\\n        int low=0;\\n        int high=n-1;\\n\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            \\n            //checking if mid is peak\\n            if(mid==0 && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            else if(mid==n-1 && nums[mid]>nums[mid-1]){\\n                return mid;\\n            }\\n            else if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]){\\n                 return mid;\\n            }\\n            //mid is not peak element\\n            else{\\n\\n                if(mid==0 && nums[mid+1]>nums[mid]){\\n                    low=mid+1;\\n                }\\n                else if(mid==n-1 && nums[mid-1]>nums[mid]){\\n                    high=mid-1;\\n                }\\n                else if(nums[mid+1]>nums[mid]){\\n                    low=mid+1;\\n                }\\n                else{\\n                    high=mid-1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n\\n\\nabove code is giving following error Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6030000000d0 overflowed to 0x6030000000cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\ncan anybody help me why it is giving above error?\\n\\n"
                    },
                    {
                        "username": "wangdrew",
                        "content": "The peak of an array is not necessarily the max element in the array. I went into this question with the implicit assumption that peak == max element and was struggling to arrive at a binary search algo. For example:\n\n[1,2,9,3,5,6,8,2,1]\n\nthe max element is 9, but the solution is 8 since that is a valid peak. Perhaps this is why there are so many downvotes."
                    }
                ]
            },
            {
                "id": 1954764,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "very easy leet\n`return nums.index(max(nums))`"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "This solution is very inefficient in this specific question. The time complexity is O(n). The time complexity of the optimal solution should be O(logN).  "
                    },
                    {
                        "username": "shubhamarya7103",
                        "content": "finding peak element and finding the greatest element in array is the same thing right ? if not how ? "
                    },
                    {
                        "username": "abinaya13897",
                        "content": "There can be many peak element but only one greater element"
                    },
                    {
                        "username": "GandhiHarsh",
                        "content": "class Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<long long > ans;      \\n        int n=nums.size();\\n        vector<long long> pre(n,0);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n\\n        }\\n        set<int> s;\\n        multiset<long long> st;\\n        s.insert(-1);\\n        st.insert(pre[n-1]);\\n        st.insert(0);\\n        for(auto x: removeQueries){\\n            auto it=lower_bound(s.begin(),s.end(),x);\\n            int left,right;\\n            if(it==s.end()){\\n                right=n-1;\\n            }else{\\n                right=(*it)-1;\\n            }\\n            it--;\\n            left=(*it);\\n            auto it2=st.begin();\\n            if(left==-1){\\n                it2=st.find(pre[right]);\\n            }else{\\n                it2=st.find(pre[right]-pre[left]);\\n            }\\n            st.erase(it2);\\n            if(pre[right]-pre[x]!=0)\\n                st.insert(pre[right]-pre[x]);\\n            if(x!=0){\\n                if(left==-1){\\n                    st.insert(pre[x-1] );\\n                }else{\\n                    if(pre[x-1]-pre[left]!=0)\\n                        st.insert(pre[x-1]-pre[left]);\\n                    \\n                }\\n            }\\n            it2=st.end();\\n            it2--;\\n            \\n            ans.push_back(*it2);\\n            s.insert(x);\\n        }\\n        return ans;\\n    }\\n};\\ncan anyone plz tell me what is the bug in this code "
                    },
                    {
                        "username": "Sujal04",
                        "content": "having problem for mid ==0 and mid == size()-1;\\n"
                    },
                    {
                        "username": "karanpatel5",
                        "content": "As they have asked that we can return any peak. that\\'s why we can solve it by binary search. Question no. 852 have exactly same code as the solution"
                    },
                    {
                        "username": "vaidehisawant",
                        "content": "When passed a testcase of  [1,2,3,5,3,2,1] these array elements the output comes out to be 3 instead of 5 which shouldn't be accepted as solution as correct answer is 5 as it is strictly greater than its neighbours am i missing out something or is the code incorrect for accepting the response any suggestions?"
                    },
                    {
                        "username": "Arvind321",
                        "content": "htttttt"
                    },
                    {
                        "username": "Akarsh_S",
                        "content": " Can some one tell me my mistake? It is not working for case nums ={2,1}.\\n \\n     while(s<=e){\\n        if(s==e)\\n        {\\n           return s;\\n        }\\n        else if (nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1] && mid+1<nums.size() && mid-1>=0)\\n        {// peak element\\n           return mid;\\n        }\\n        else if(nums[mid]<nums[mid+1] && mid+1<nums.size() && mid-1>=0)\\n        {//right search\\n            s=mid+1;\\n        }\\n        else if(nums[mid]>nums[mid+1] && mid+1<nums.size() && mid-1>=0)\\n        {//left search\\n            e=mid-1;\\n        }\\n        else\\n        {\\n           return mid;\\n        }\\n        mid = s + (e-s)/2;\\n     }\\n"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "class Solution {\\npublic:\\n\\n    int findPeakElement(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        if(n==1){\\n            return 0;\\n        }\\n\\n        int low=0;\\n        int high=n-1;\\n\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            \\n            //checking if mid is peak\\n            if(mid==0 && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            else if(mid==n-1 && nums[mid]>nums[mid-1]){\\n                return mid;\\n            }\\n            else if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]){\\n                 return mid;\\n            }\\n            //mid is not peak element\\n            else{\\n\\n                if(mid==0 && nums[mid+1]>nums[mid]){\\n                    low=mid+1;\\n                }\\n                else if(mid==n-1 && nums[mid-1]>nums[mid]){\\n                    high=mid-1;\\n                }\\n                else if(nums[mid+1]>nums[mid]){\\n                    low=mid+1;\\n                }\\n                else{\\n                    high=mid-1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n\\n\\nabove code is giving following error Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6030000000d0 overflowed to 0x6030000000cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\ncan anybody help me why it is giving above error?\\n\\n"
                    },
                    {
                        "username": "wangdrew",
                        "content": "The peak of an array is not necessarily the max element in the array. I went into this question with the implicit assumption that peak == max element and was struggling to arrive at a binary search algo. For example:\n\n[1,2,9,3,5,6,8,2,1]\n\nthe max element is 9, but the solution is 8 since that is a valid peak. Perhaps this is why there are so many downvotes."
                    }
                ]
            },
            {
                "id": 1953146,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "very easy leet\n`return nums.index(max(nums))`"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "This solution is very inefficient in this specific question. The time complexity is O(n). The time complexity of the optimal solution should be O(logN).  "
                    },
                    {
                        "username": "shubhamarya7103",
                        "content": "finding peak element and finding the greatest element in array is the same thing right ? if not how ? "
                    },
                    {
                        "username": "abinaya13897",
                        "content": "There can be many peak element but only one greater element"
                    },
                    {
                        "username": "GandhiHarsh",
                        "content": "class Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<long long > ans;      \\n        int n=nums.size();\\n        vector<long long> pre(n,0);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n\\n        }\\n        set<int> s;\\n        multiset<long long> st;\\n        s.insert(-1);\\n        st.insert(pre[n-1]);\\n        st.insert(0);\\n        for(auto x: removeQueries){\\n            auto it=lower_bound(s.begin(),s.end(),x);\\n            int left,right;\\n            if(it==s.end()){\\n                right=n-1;\\n            }else{\\n                right=(*it)-1;\\n            }\\n            it--;\\n            left=(*it);\\n            auto it2=st.begin();\\n            if(left==-1){\\n                it2=st.find(pre[right]);\\n            }else{\\n                it2=st.find(pre[right]-pre[left]);\\n            }\\n            st.erase(it2);\\n            if(pre[right]-pre[x]!=0)\\n                st.insert(pre[right]-pre[x]);\\n            if(x!=0){\\n                if(left==-1){\\n                    st.insert(pre[x-1] );\\n                }else{\\n                    if(pre[x-1]-pre[left]!=0)\\n                        st.insert(pre[x-1]-pre[left]);\\n                    \\n                }\\n            }\\n            it2=st.end();\\n            it2--;\\n            \\n            ans.push_back(*it2);\\n            s.insert(x);\\n        }\\n        return ans;\\n    }\\n};\\ncan anyone plz tell me what is the bug in this code "
                    },
                    {
                        "username": "Sujal04",
                        "content": "having problem for mid ==0 and mid == size()-1;\\n"
                    },
                    {
                        "username": "karanpatel5",
                        "content": "As they have asked that we can return any peak. that\\'s why we can solve it by binary search. Question no. 852 have exactly same code as the solution"
                    },
                    {
                        "username": "vaidehisawant",
                        "content": "When passed a testcase of  [1,2,3,5,3,2,1] these array elements the output comes out to be 3 instead of 5 which shouldn't be accepted as solution as correct answer is 5 as it is strictly greater than its neighbours am i missing out something or is the code incorrect for accepting the response any suggestions?"
                    },
                    {
                        "username": "Arvind321",
                        "content": "htttttt"
                    },
                    {
                        "username": "Akarsh_S",
                        "content": " Can some one tell me my mistake? It is not working for case nums ={2,1}.\\n \\n     while(s<=e){\\n        if(s==e)\\n        {\\n           return s;\\n        }\\n        else if (nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1] && mid+1<nums.size() && mid-1>=0)\\n        {// peak element\\n           return mid;\\n        }\\n        else if(nums[mid]<nums[mid+1] && mid+1<nums.size() && mid-1>=0)\\n        {//right search\\n            s=mid+1;\\n        }\\n        else if(nums[mid]>nums[mid+1] && mid+1<nums.size() && mid-1>=0)\\n        {//left search\\n            e=mid-1;\\n        }\\n        else\\n        {\\n           return mid;\\n        }\\n        mid = s + (e-s)/2;\\n     }\\n"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "class Solution {\\npublic:\\n\\n    int findPeakElement(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        if(n==1){\\n            return 0;\\n        }\\n\\n        int low=0;\\n        int high=n-1;\\n\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            \\n            //checking if mid is peak\\n            if(mid==0 && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            else if(mid==n-1 && nums[mid]>nums[mid-1]){\\n                return mid;\\n            }\\n            else if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]){\\n                 return mid;\\n            }\\n            //mid is not peak element\\n            else{\\n\\n                if(mid==0 && nums[mid+1]>nums[mid]){\\n                    low=mid+1;\\n                }\\n                else if(mid==n-1 && nums[mid-1]>nums[mid]){\\n                    high=mid-1;\\n                }\\n                else if(nums[mid+1]>nums[mid]){\\n                    low=mid+1;\\n                }\\n                else{\\n                    high=mid-1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n\\n\\nabove code is giving following error Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6030000000d0 overflowed to 0x6030000000cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\ncan anybody help me why it is giving above error?\\n\\n"
                    },
                    {
                        "username": "wangdrew",
                        "content": "The peak of an array is not necessarily the max element in the array. I went into this question with the implicit assumption that peak == max element and was struggling to arrive at a binary search algo. For example:\n\n[1,2,9,3,5,6,8,2,1]\n\nthe max element is 9, but the solution is 8 since that is a valid peak. Perhaps this is why there are so many downvotes."
                    }
                ]
            },
            {
                "id": 1936997,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "very easy leet\n`return nums.index(max(nums))`"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "This solution is very inefficient in this specific question. The time complexity is O(n). The time complexity of the optimal solution should be O(logN).  "
                    },
                    {
                        "username": "shubhamarya7103",
                        "content": "finding peak element and finding the greatest element in array is the same thing right ? if not how ? "
                    },
                    {
                        "username": "abinaya13897",
                        "content": "There can be many peak element but only one greater element"
                    },
                    {
                        "username": "GandhiHarsh",
                        "content": "class Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<long long > ans;      \\n        int n=nums.size();\\n        vector<long long> pre(n,0);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n\\n        }\\n        set<int> s;\\n        multiset<long long> st;\\n        s.insert(-1);\\n        st.insert(pre[n-1]);\\n        st.insert(0);\\n        for(auto x: removeQueries){\\n            auto it=lower_bound(s.begin(),s.end(),x);\\n            int left,right;\\n            if(it==s.end()){\\n                right=n-1;\\n            }else{\\n                right=(*it)-1;\\n            }\\n            it--;\\n            left=(*it);\\n            auto it2=st.begin();\\n            if(left==-1){\\n                it2=st.find(pre[right]);\\n            }else{\\n                it2=st.find(pre[right]-pre[left]);\\n            }\\n            st.erase(it2);\\n            if(pre[right]-pre[x]!=0)\\n                st.insert(pre[right]-pre[x]);\\n            if(x!=0){\\n                if(left==-1){\\n                    st.insert(pre[x-1] );\\n                }else{\\n                    if(pre[x-1]-pre[left]!=0)\\n                        st.insert(pre[x-1]-pre[left]);\\n                    \\n                }\\n            }\\n            it2=st.end();\\n            it2--;\\n            \\n            ans.push_back(*it2);\\n            s.insert(x);\\n        }\\n        return ans;\\n    }\\n};\\ncan anyone plz tell me what is the bug in this code "
                    },
                    {
                        "username": "Sujal04",
                        "content": "having problem for mid ==0 and mid == size()-1;\\n"
                    },
                    {
                        "username": "karanpatel5",
                        "content": "As they have asked that we can return any peak. that\\'s why we can solve it by binary search. Question no. 852 have exactly same code as the solution"
                    },
                    {
                        "username": "vaidehisawant",
                        "content": "When passed a testcase of  [1,2,3,5,3,2,1] these array elements the output comes out to be 3 instead of 5 which shouldn't be accepted as solution as correct answer is 5 as it is strictly greater than its neighbours am i missing out something or is the code incorrect for accepting the response any suggestions?"
                    },
                    {
                        "username": "Arvind321",
                        "content": "htttttt"
                    },
                    {
                        "username": "Akarsh_S",
                        "content": " Can some one tell me my mistake? It is not working for case nums ={2,1}.\\n \\n     while(s<=e){\\n        if(s==e)\\n        {\\n           return s;\\n        }\\n        else if (nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1] && mid+1<nums.size() && mid-1>=0)\\n        {// peak element\\n           return mid;\\n        }\\n        else if(nums[mid]<nums[mid+1] && mid+1<nums.size() && mid-1>=0)\\n        {//right search\\n            s=mid+1;\\n        }\\n        else if(nums[mid]>nums[mid+1] && mid+1<nums.size() && mid-1>=0)\\n        {//left search\\n            e=mid-1;\\n        }\\n        else\\n        {\\n           return mid;\\n        }\\n        mid = s + (e-s)/2;\\n     }\\n"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "class Solution {\\npublic:\\n\\n    int findPeakElement(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        if(n==1){\\n            return 0;\\n        }\\n\\n        int low=0;\\n        int high=n-1;\\n\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            \\n            //checking if mid is peak\\n            if(mid==0 && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            else if(mid==n-1 && nums[mid]>nums[mid-1]){\\n                return mid;\\n            }\\n            else if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]){\\n                 return mid;\\n            }\\n            //mid is not peak element\\n            else{\\n\\n                if(mid==0 && nums[mid+1]>nums[mid]){\\n                    low=mid+1;\\n                }\\n                else if(mid==n-1 && nums[mid-1]>nums[mid]){\\n                    high=mid-1;\\n                }\\n                else if(nums[mid+1]>nums[mid]){\\n                    low=mid+1;\\n                }\\n                else{\\n                    high=mid-1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n\\n\\nabove code is giving following error Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6030000000d0 overflowed to 0x6030000000cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\ncan anybody help me why it is giving above error?\\n\\n"
                    },
                    {
                        "username": "wangdrew",
                        "content": "The peak of an array is not necessarily the max element in the array. I went into this question with the implicit assumption that peak == max element and was struggling to arrive at a binary search algo. For example:\n\n[1,2,9,3,5,6,8,2,1]\n\nthe max element is 9, but the solution is 8 since that is a valid peak. Perhaps this is why there are so many downvotes."
                    }
                ]
            },
            {
                "id": 1932871,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "very easy leet\n`return nums.index(max(nums))`"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "This solution is very inefficient in this specific question. The time complexity is O(n). The time complexity of the optimal solution should be O(logN).  "
                    },
                    {
                        "username": "shubhamarya7103",
                        "content": "finding peak element and finding the greatest element in array is the same thing right ? if not how ? "
                    },
                    {
                        "username": "abinaya13897",
                        "content": "There can be many peak element but only one greater element"
                    },
                    {
                        "username": "GandhiHarsh",
                        "content": "class Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<long long > ans;      \\n        int n=nums.size();\\n        vector<long long> pre(n,0);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n\\n        }\\n        set<int> s;\\n        multiset<long long> st;\\n        s.insert(-1);\\n        st.insert(pre[n-1]);\\n        st.insert(0);\\n        for(auto x: removeQueries){\\n            auto it=lower_bound(s.begin(),s.end(),x);\\n            int left,right;\\n            if(it==s.end()){\\n                right=n-1;\\n            }else{\\n                right=(*it)-1;\\n            }\\n            it--;\\n            left=(*it);\\n            auto it2=st.begin();\\n            if(left==-1){\\n                it2=st.find(pre[right]);\\n            }else{\\n                it2=st.find(pre[right]-pre[left]);\\n            }\\n            st.erase(it2);\\n            if(pre[right]-pre[x]!=0)\\n                st.insert(pre[right]-pre[x]);\\n            if(x!=0){\\n                if(left==-1){\\n                    st.insert(pre[x-1] );\\n                }else{\\n                    if(pre[x-1]-pre[left]!=0)\\n                        st.insert(pre[x-1]-pre[left]);\\n                    \\n                }\\n            }\\n            it2=st.end();\\n            it2--;\\n            \\n            ans.push_back(*it2);\\n            s.insert(x);\\n        }\\n        return ans;\\n    }\\n};\\ncan anyone plz tell me what is the bug in this code "
                    },
                    {
                        "username": "Sujal04",
                        "content": "having problem for mid ==0 and mid == size()-1;\\n"
                    },
                    {
                        "username": "karanpatel5",
                        "content": "As they have asked that we can return any peak. that\\'s why we can solve it by binary search. Question no. 852 have exactly same code as the solution"
                    },
                    {
                        "username": "vaidehisawant",
                        "content": "When passed a testcase of  [1,2,3,5,3,2,1] these array elements the output comes out to be 3 instead of 5 which shouldn't be accepted as solution as correct answer is 5 as it is strictly greater than its neighbours am i missing out something or is the code incorrect for accepting the response any suggestions?"
                    },
                    {
                        "username": "Arvind321",
                        "content": "htttttt"
                    },
                    {
                        "username": "Akarsh_S",
                        "content": " Can some one tell me my mistake? It is not working for case nums ={2,1}.\\n \\n     while(s<=e){\\n        if(s==e)\\n        {\\n           return s;\\n        }\\n        else if (nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1] && mid+1<nums.size() && mid-1>=0)\\n        {// peak element\\n           return mid;\\n        }\\n        else if(nums[mid]<nums[mid+1] && mid+1<nums.size() && mid-1>=0)\\n        {//right search\\n            s=mid+1;\\n        }\\n        else if(nums[mid]>nums[mid+1] && mid+1<nums.size() && mid-1>=0)\\n        {//left search\\n            e=mid-1;\\n        }\\n        else\\n        {\\n           return mid;\\n        }\\n        mid = s + (e-s)/2;\\n     }\\n"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "class Solution {\\npublic:\\n\\n    int findPeakElement(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        if(n==1){\\n            return 0;\\n        }\\n\\n        int low=0;\\n        int high=n-1;\\n\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            \\n            //checking if mid is peak\\n            if(mid==0 && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            else if(mid==n-1 && nums[mid]>nums[mid-1]){\\n                return mid;\\n            }\\n            else if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]){\\n                 return mid;\\n            }\\n            //mid is not peak element\\n            else{\\n\\n                if(mid==0 && nums[mid+1]>nums[mid]){\\n                    low=mid+1;\\n                }\\n                else if(mid==n-1 && nums[mid-1]>nums[mid]){\\n                    high=mid-1;\\n                }\\n                else if(nums[mid+1]>nums[mid]){\\n                    low=mid+1;\\n                }\\n                else{\\n                    high=mid-1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n\\n\\nabove code is giving following error Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6030000000d0 overflowed to 0x6030000000cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\ncan anybody help me why it is giving above error?\\n\\n"
                    },
                    {
                        "username": "wangdrew",
                        "content": "The peak of an array is not necessarily the max element in the array. I went into this question with the implicit assumption that peak == max element and was struggling to arrive at a binary search algo. For example:\n\n[1,2,9,3,5,6,8,2,1]\n\nthe max element is 9, but the solution is 8 since that is a valid peak. Perhaps this is why there are so many downvotes."
                    }
                ]
            },
            {
                "id": 1932094,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "very easy leet\n`return nums.index(max(nums))`"
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "This solution is very inefficient in this specific question. The time complexity is O(n). The time complexity of the optimal solution should be O(logN).  "
                    },
                    {
                        "username": "shubhamarya7103",
                        "content": "finding peak element and finding the greatest element in array is the same thing right ? if not how ? "
                    },
                    {
                        "username": "abinaya13897",
                        "content": "There can be many peak element but only one greater element"
                    },
                    {
                        "username": "GandhiHarsh",
                        "content": "class Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<long long > ans;      \\n        int n=nums.size();\\n        vector<long long> pre(n,0);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n\\n        }\\n        set<int> s;\\n        multiset<long long> st;\\n        s.insert(-1);\\n        st.insert(pre[n-1]);\\n        st.insert(0);\\n        for(auto x: removeQueries){\\n            auto it=lower_bound(s.begin(),s.end(),x);\\n            int left,right;\\n            if(it==s.end()){\\n                right=n-1;\\n            }else{\\n                right=(*it)-1;\\n            }\\n            it--;\\n            left=(*it);\\n            auto it2=st.begin();\\n            if(left==-1){\\n                it2=st.find(pre[right]);\\n            }else{\\n                it2=st.find(pre[right]-pre[left]);\\n            }\\n            st.erase(it2);\\n            if(pre[right]-pre[x]!=0)\\n                st.insert(pre[right]-pre[x]);\\n            if(x!=0){\\n                if(left==-1){\\n                    st.insert(pre[x-1] );\\n                }else{\\n                    if(pre[x-1]-pre[left]!=0)\\n                        st.insert(pre[x-1]-pre[left]);\\n                    \\n                }\\n            }\\n            it2=st.end();\\n            it2--;\\n            \\n            ans.push_back(*it2);\\n            s.insert(x);\\n        }\\n        return ans;\\n    }\\n};\\ncan anyone plz tell me what is the bug in this code "
                    },
                    {
                        "username": "Sujal04",
                        "content": "having problem for mid ==0 and mid == size()-1;\\n"
                    },
                    {
                        "username": "karanpatel5",
                        "content": "As they have asked that we can return any peak. that\\'s why we can solve it by binary search. Question no. 852 have exactly same code as the solution"
                    },
                    {
                        "username": "vaidehisawant",
                        "content": "When passed a testcase of  [1,2,3,5,3,2,1] these array elements the output comes out to be 3 instead of 5 which shouldn't be accepted as solution as correct answer is 5 as it is strictly greater than its neighbours am i missing out something or is the code incorrect for accepting the response any suggestions?"
                    },
                    {
                        "username": "Arvind321",
                        "content": "htttttt"
                    },
                    {
                        "username": "Akarsh_S",
                        "content": " Can some one tell me my mistake? It is not working for case nums ={2,1}.\\n \\n     while(s<=e){\\n        if(s==e)\\n        {\\n           return s;\\n        }\\n        else if (nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1] && mid+1<nums.size() && mid-1>=0)\\n        {// peak element\\n           return mid;\\n        }\\n        else if(nums[mid]<nums[mid+1] && mid+1<nums.size() && mid-1>=0)\\n        {//right search\\n            s=mid+1;\\n        }\\n        else if(nums[mid]>nums[mid+1] && mid+1<nums.size() && mid-1>=0)\\n        {//left search\\n            e=mid-1;\\n        }\\n        else\\n        {\\n           return mid;\\n        }\\n        mid = s + (e-s)/2;\\n     }\\n"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "class Solution {\\npublic:\\n\\n    int findPeakElement(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        if(n==1){\\n            return 0;\\n        }\\n\\n        int low=0;\\n        int high=n-1;\\n\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            \\n            //checking if mid is peak\\n            if(mid==0 && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            else if(mid==n-1 && nums[mid]>nums[mid-1]){\\n                return mid;\\n            }\\n            else if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]){\\n                 return mid;\\n            }\\n            //mid is not peak element\\n            else{\\n\\n                if(mid==0 && nums[mid+1]>nums[mid]){\\n                    low=mid+1;\\n                }\\n                else if(mid==n-1 && nums[mid-1]>nums[mid]){\\n                    high=mid-1;\\n                }\\n                else if(nums[mid+1]>nums[mid]){\\n                    low=mid+1;\\n                }\\n                else{\\n                    high=mid-1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n\\n\\nabove code is giving following error Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6030000000d0 overflowed to 0x6030000000cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\ncan anybody help me why it is giving above error?\\n\\n"
                    },
                    {
                        "username": "wangdrew",
                        "content": "The peak of an array is not necessarily the max element in the array. I went into this question with the implicit assumption that peak == max element and was struggling to arrive at a binary search algo. For example:\n\n[1,2,9,3,5,6,8,2,1]\n\nthe max element is 9, but the solution is 8 since that is a valid peak. Perhaps this is why there are so many downvotes."
                    }
                ]
            },
            {
                "id": 1930726,
                "content": [
                    {
                        "username": "misfy",
                        "content": "I think the tests are bad. To really test the O(log n) complexity the vector should contain much more than 1000 elements. Coding this thing with a for loop is trivial but it will easily pass all tests. "
                    },
                    {
                        "username": "prototye",
                        "content": "What if we were asked index of all the peak elements, can we modify our binary search in such a way that we can search for all the peaks? If not all can we modify it enough to find the leftmost peak element?\\nAs in example 2 if the question asked for the leftmost peak element then it would have been 2, index = 1."
                    },
                    {
                        "username": "sudheer_m",
                        "content": "Hello!\\n\\nShouldn\\'t the question say >= instead of strictly greater than in the definition of a peak? \\nWe will be able to guarantee that peak will be in the increasing half (the half in which a[i]>a[mid]) only if there is >=.\\nReason: What if, in the increasing half we have the same number repeating?..  We can\\'t find the peak in that case!\\n\\nEg.  5 5 5 3 4 4 4.\\nHere if we choose 3 as mid element and go to one of the greater halves (here both the halves are greater than 3) then we will not be able to find the peak, if it is defined with strict inequatily.\\n\\nSo I guess the definition should have >=."
                    },
                    {
                        "username": "armashhashmi",
                        "content": "how can we know that adjacent elements will never be equal??\\n"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "check constraints"
                    },
                    {
                        "username": "Msey",
                        "content": "just find the maximum"
                    },
                    {
                        "username": "lewislunsj",
                        "content": "I would have saved so much time if I have paid attention to the constraints.\\n```nums[i] != nums[i + 1] for all valid i.```"
                    },
                    {
                        "username": "Steven_00",
                        "content": "There isn\\'t any description said \\u201Cadjacent elements cannot be the same\", right? Why I saw other guys and testcases all assume nums[i] != nums[i+1]?"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "check constraints.."
                    },
                    {
                        "username": "am_kumar01",
                        "content": "why does this code gives tle? plss help\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n     int n = nums.size();\\n    int s = 0, e = n - 1;\\n    while (s < e) {\\n        int mid = s + (e - s) / 2;\\n        if (nums[mid] > nums[mid-1]) {\\n            s = mid; // search in the right half\\n        } else {\\n            e = mid - 1; // search in the left half\\n        }\\n    }\\n    return s; \\n    }\\n};\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I solved this but still no idea how I did so!"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "Not a hint, just for acknowledgement : nums[i] != nums[i+1]"
                    }
                ]
            },
            {
                "id": 1920845,
                "content": [
                    {
                        "username": "misfy",
                        "content": "I think the tests are bad. To really test the O(log n) complexity the vector should contain much more than 1000 elements. Coding this thing with a for loop is trivial but it will easily pass all tests. "
                    },
                    {
                        "username": "prototye",
                        "content": "What if we were asked index of all the peak elements, can we modify our binary search in such a way that we can search for all the peaks? If not all can we modify it enough to find the leftmost peak element?\\nAs in example 2 if the question asked for the leftmost peak element then it would have been 2, index = 1."
                    },
                    {
                        "username": "sudheer_m",
                        "content": "Hello!\\n\\nShouldn\\'t the question say >= instead of strictly greater than in the definition of a peak? \\nWe will be able to guarantee that peak will be in the increasing half (the half in which a[i]>a[mid]) only if there is >=.\\nReason: What if, in the increasing half we have the same number repeating?..  We can\\'t find the peak in that case!\\n\\nEg.  5 5 5 3 4 4 4.\\nHere if we choose 3 as mid element and go to one of the greater halves (here both the halves are greater than 3) then we will not be able to find the peak, if it is defined with strict inequatily.\\n\\nSo I guess the definition should have >=."
                    },
                    {
                        "username": "armashhashmi",
                        "content": "how can we know that adjacent elements will never be equal??\\n"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "check constraints"
                    },
                    {
                        "username": "Msey",
                        "content": "just find the maximum"
                    },
                    {
                        "username": "lewislunsj",
                        "content": "I would have saved so much time if I have paid attention to the constraints.\\n```nums[i] != nums[i + 1] for all valid i.```"
                    },
                    {
                        "username": "Steven_00",
                        "content": "There isn\\'t any description said \\u201Cadjacent elements cannot be the same\", right? Why I saw other guys and testcases all assume nums[i] != nums[i+1]?"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "check constraints.."
                    },
                    {
                        "username": "am_kumar01",
                        "content": "why does this code gives tle? plss help\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n     int n = nums.size();\\n    int s = 0, e = n - 1;\\n    while (s < e) {\\n        int mid = s + (e - s) / 2;\\n        if (nums[mid] > nums[mid-1]) {\\n            s = mid; // search in the right half\\n        } else {\\n            e = mid - 1; // search in the left half\\n        }\\n    }\\n    return s; \\n    }\\n};\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I solved this but still no idea how I did so!"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "Not a hint, just for acknowledgement : nums[i] != nums[i+1]"
                    }
                ]
            },
            {
                "id": 1920777,
                "content": [
                    {
                        "username": "misfy",
                        "content": "I think the tests are bad. To really test the O(log n) complexity the vector should contain much more than 1000 elements. Coding this thing with a for loop is trivial but it will easily pass all tests. "
                    },
                    {
                        "username": "prototye",
                        "content": "What if we were asked index of all the peak elements, can we modify our binary search in such a way that we can search for all the peaks? If not all can we modify it enough to find the leftmost peak element?\\nAs in example 2 if the question asked for the leftmost peak element then it would have been 2, index = 1."
                    },
                    {
                        "username": "sudheer_m",
                        "content": "Hello!\\n\\nShouldn\\'t the question say >= instead of strictly greater than in the definition of a peak? \\nWe will be able to guarantee that peak will be in the increasing half (the half in which a[i]>a[mid]) only if there is >=.\\nReason: What if, in the increasing half we have the same number repeating?..  We can\\'t find the peak in that case!\\n\\nEg.  5 5 5 3 4 4 4.\\nHere if we choose 3 as mid element and go to one of the greater halves (here both the halves are greater than 3) then we will not be able to find the peak, if it is defined with strict inequatily.\\n\\nSo I guess the definition should have >=."
                    },
                    {
                        "username": "armashhashmi",
                        "content": "how can we know that adjacent elements will never be equal??\\n"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "check constraints"
                    },
                    {
                        "username": "Msey",
                        "content": "just find the maximum"
                    },
                    {
                        "username": "lewislunsj",
                        "content": "I would have saved so much time if I have paid attention to the constraints.\\n```nums[i] != nums[i + 1] for all valid i.```"
                    },
                    {
                        "username": "Steven_00",
                        "content": "There isn\\'t any description said \\u201Cadjacent elements cannot be the same\", right? Why I saw other guys and testcases all assume nums[i] != nums[i+1]?"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "check constraints.."
                    },
                    {
                        "username": "am_kumar01",
                        "content": "why does this code gives tle? plss help\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n     int n = nums.size();\\n    int s = 0, e = n - 1;\\n    while (s < e) {\\n        int mid = s + (e - s) / 2;\\n        if (nums[mid] > nums[mid-1]) {\\n            s = mid; // search in the right half\\n        } else {\\n            e = mid - 1; // search in the left half\\n        }\\n    }\\n    return s; \\n    }\\n};\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I solved this but still no idea how I did so!"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "Not a hint, just for acknowledgement : nums[i] != nums[i+1]"
                    }
                ]
            },
            {
                "id": 1919323,
                "content": [
                    {
                        "username": "misfy",
                        "content": "I think the tests are bad. To really test the O(log n) complexity the vector should contain much more than 1000 elements. Coding this thing with a for loop is trivial but it will easily pass all tests. "
                    },
                    {
                        "username": "prototye",
                        "content": "What if we were asked index of all the peak elements, can we modify our binary search in such a way that we can search for all the peaks? If not all can we modify it enough to find the leftmost peak element?\\nAs in example 2 if the question asked for the leftmost peak element then it would have been 2, index = 1."
                    },
                    {
                        "username": "sudheer_m",
                        "content": "Hello!\\n\\nShouldn\\'t the question say >= instead of strictly greater than in the definition of a peak? \\nWe will be able to guarantee that peak will be in the increasing half (the half in which a[i]>a[mid]) only if there is >=.\\nReason: What if, in the increasing half we have the same number repeating?..  We can\\'t find the peak in that case!\\n\\nEg.  5 5 5 3 4 4 4.\\nHere if we choose 3 as mid element and go to one of the greater halves (here both the halves are greater than 3) then we will not be able to find the peak, if it is defined with strict inequatily.\\n\\nSo I guess the definition should have >=."
                    },
                    {
                        "username": "armashhashmi",
                        "content": "how can we know that adjacent elements will never be equal??\\n"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "check constraints"
                    },
                    {
                        "username": "Msey",
                        "content": "just find the maximum"
                    },
                    {
                        "username": "lewislunsj",
                        "content": "I would have saved so much time if I have paid attention to the constraints.\\n```nums[i] != nums[i + 1] for all valid i.```"
                    },
                    {
                        "username": "Steven_00",
                        "content": "There isn\\'t any description said \\u201Cadjacent elements cannot be the same\", right? Why I saw other guys and testcases all assume nums[i] != nums[i+1]?"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "check constraints.."
                    },
                    {
                        "username": "am_kumar01",
                        "content": "why does this code gives tle? plss help\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n     int n = nums.size();\\n    int s = 0, e = n - 1;\\n    while (s < e) {\\n        int mid = s + (e - s) / 2;\\n        if (nums[mid] > nums[mid-1]) {\\n            s = mid; // search in the right half\\n        } else {\\n            e = mid - 1; // search in the left half\\n        }\\n    }\\n    return s; \\n    }\\n};\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I solved this but still no idea how I did so!"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "Not a hint, just for acknowledgement : nums[i] != nums[i+1]"
                    }
                ]
            },
            {
                "id": 1912421,
                "content": [
                    {
                        "username": "misfy",
                        "content": "I think the tests are bad. To really test the O(log n) complexity the vector should contain much more than 1000 elements. Coding this thing with a for loop is trivial but it will easily pass all tests. "
                    },
                    {
                        "username": "prototye",
                        "content": "What if we were asked index of all the peak elements, can we modify our binary search in such a way that we can search for all the peaks? If not all can we modify it enough to find the leftmost peak element?\\nAs in example 2 if the question asked for the leftmost peak element then it would have been 2, index = 1."
                    },
                    {
                        "username": "sudheer_m",
                        "content": "Hello!\\n\\nShouldn\\'t the question say >= instead of strictly greater than in the definition of a peak? \\nWe will be able to guarantee that peak will be in the increasing half (the half in which a[i]>a[mid]) only if there is >=.\\nReason: What if, in the increasing half we have the same number repeating?..  We can\\'t find the peak in that case!\\n\\nEg.  5 5 5 3 4 4 4.\\nHere if we choose 3 as mid element and go to one of the greater halves (here both the halves are greater than 3) then we will not be able to find the peak, if it is defined with strict inequatily.\\n\\nSo I guess the definition should have >=."
                    },
                    {
                        "username": "armashhashmi",
                        "content": "how can we know that adjacent elements will never be equal??\\n"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "check constraints"
                    },
                    {
                        "username": "Msey",
                        "content": "just find the maximum"
                    },
                    {
                        "username": "lewislunsj",
                        "content": "I would have saved so much time if I have paid attention to the constraints.\\n```nums[i] != nums[i + 1] for all valid i.```"
                    },
                    {
                        "username": "Steven_00",
                        "content": "There isn\\'t any description said \\u201Cadjacent elements cannot be the same\", right? Why I saw other guys and testcases all assume nums[i] != nums[i+1]?"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "check constraints.."
                    },
                    {
                        "username": "am_kumar01",
                        "content": "why does this code gives tle? plss help\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n     int n = nums.size();\\n    int s = 0, e = n - 1;\\n    while (s < e) {\\n        int mid = s + (e - s) / 2;\\n        if (nums[mid] > nums[mid-1]) {\\n            s = mid; // search in the right half\\n        } else {\\n            e = mid - 1; // search in the left half\\n        }\\n    }\\n    return s; \\n    }\\n};\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I solved this but still no idea how I did so!"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "Not a hint, just for acknowledgement : nums[i] != nums[i+1]"
                    }
                ]
            },
            {
                "id": 1896465,
                "content": [
                    {
                        "username": "misfy",
                        "content": "I think the tests are bad. To really test the O(log n) complexity the vector should contain much more than 1000 elements. Coding this thing with a for loop is trivial but it will easily pass all tests. "
                    },
                    {
                        "username": "prototye",
                        "content": "What if we were asked index of all the peak elements, can we modify our binary search in such a way that we can search for all the peaks? If not all can we modify it enough to find the leftmost peak element?\\nAs in example 2 if the question asked for the leftmost peak element then it would have been 2, index = 1."
                    },
                    {
                        "username": "sudheer_m",
                        "content": "Hello!\\n\\nShouldn\\'t the question say >= instead of strictly greater than in the definition of a peak? \\nWe will be able to guarantee that peak will be in the increasing half (the half in which a[i]>a[mid]) only if there is >=.\\nReason: What if, in the increasing half we have the same number repeating?..  We can\\'t find the peak in that case!\\n\\nEg.  5 5 5 3 4 4 4.\\nHere if we choose 3 as mid element and go to one of the greater halves (here both the halves are greater than 3) then we will not be able to find the peak, if it is defined with strict inequatily.\\n\\nSo I guess the definition should have >=."
                    },
                    {
                        "username": "armashhashmi",
                        "content": "how can we know that adjacent elements will never be equal??\\n"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "check constraints"
                    },
                    {
                        "username": "Msey",
                        "content": "just find the maximum"
                    },
                    {
                        "username": "lewislunsj",
                        "content": "I would have saved so much time if I have paid attention to the constraints.\\n```nums[i] != nums[i + 1] for all valid i.```"
                    },
                    {
                        "username": "Steven_00",
                        "content": "There isn\\'t any description said \\u201Cadjacent elements cannot be the same\", right? Why I saw other guys and testcases all assume nums[i] != nums[i+1]?"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "check constraints.."
                    },
                    {
                        "username": "am_kumar01",
                        "content": "why does this code gives tle? plss help\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n     int n = nums.size();\\n    int s = 0, e = n - 1;\\n    while (s < e) {\\n        int mid = s + (e - s) / 2;\\n        if (nums[mid] > nums[mid-1]) {\\n            s = mid; // search in the right half\\n        } else {\\n            e = mid - 1; // search in the left half\\n        }\\n    }\\n    return s; \\n    }\\n};\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I solved this but still no idea how I did so!"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "Not a hint, just for acknowledgement : nums[i] != nums[i+1]"
                    }
                ]
            },
            {
                "id": 1891036,
                "content": [
                    {
                        "username": "misfy",
                        "content": "I think the tests are bad. To really test the O(log n) complexity the vector should contain much more than 1000 elements. Coding this thing with a for loop is trivial but it will easily pass all tests. "
                    },
                    {
                        "username": "prototye",
                        "content": "What if we were asked index of all the peak elements, can we modify our binary search in such a way that we can search for all the peaks? If not all can we modify it enough to find the leftmost peak element?\\nAs in example 2 if the question asked for the leftmost peak element then it would have been 2, index = 1."
                    },
                    {
                        "username": "sudheer_m",
                        "content": "Hello!\\n\\nShouldn\\'t the question say >= instead of strictly greater than in the definition of a peak? \\nWe will be able to guarantee that peak will be in the increasing half (the half in which a[i]>a[mid]) only if there is >=.\\nReason: What if, in the increasing half we have the same number repeating?..  We can\\'t find the peak in that case!\\n\\nEg.  5 5 5 3 4 4 4.\\nHere if we choose 3 as mid element and go to one of the greater halves (here both the halves are greater than 3) then we will not be able to find the peak, if it is defined with strict inequatily.\\n\\nSo I guess the definition should have >=."
                    },
                    {
                        "username": "armashhashmi",
                        "content": "how can we know that adjacent elements will never be equal??\\n"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "check constraints"
                    },
                    {
                        "username": "Msey",
                        "content": "just find the maximum"
                    },
                    {
                        "username": "lewislunsj",
                        "content": "I would have saved so much time if I have paid attention to the constraints.\\n```nums[i] != nums[i + 1] for all valid i.```"
                    },
                    {
                        "username": "Steven_00",
                        "content": "There isn\\'t any description said \\u201Cadjacent elements cannot be the same\", right? Why I saw other guys and testcases all assume nums[i] != nums[i+1]?"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "check constraints.."
                    },
                    {
                        "username": "am_kumar01",
                        "content": "why does this code gives tle? plss help\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n     int n = nums.size();\\n    int s = 0, e = n - 1;\\n    while (s < e) {\\n        int mid = s + (e - s) / 2;\\n        if (nums[mid] > nums[mid-1]) {\\n            s = mid; // search in the right half\\n        } else {\\n            e = mid - 1; // search in the left half\\n        }\\n    }\\n    return s; \\n    }\\n};\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I solved this but still no idea how I did so!"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "Not a hint, just for acknowledgement : nums[i] != nums[i+1]"
                    }
                ]
            },
            {
                "id": 1888407,
                "content": [
                    {
                        "username": "misfy",
                        "content": "I think the tests are bad. To really test the O(log n) complexity the vector should contain much more than 1000 elements. Coding this thing with a for loop is trivial but it will easily pass all tests. "
                    },
                    {
                        "username": "prototye",
                        "content": "What if we were asked index of all the peak elements, can we modify our binary search in such a way that we can search for all the peaks? If not all can we modify it enough to find the leftmost peak element?\\nAs in example 2 if the question asked for the leftmost peak element then it would have been 2, index = 1."
                    },
                    {
                        "username": "sudheer_m",
                        "content": "Hello!\\n\\nShouldn\\'t the question say >= instead of strictly greater than in the definition of a peak? \\nWe will be able to guarantee that peak will be in the increasing half (the half in which a[i]>a[mid]) only if there is >=.\\nReason: What if, in the increasing half we have the same number repeating?..  We can\\'t find the peak in that case!\\n\\nEg.  5 5 5 3 4 4 4.\\nHere if we choose 3 as mid element and go to one of the greater halves (here both the halves are greater than 3) then we will not be able to find the peak, if it is defined with strict inequatily.\\n\\nSo I guess the definition should have >=."
                    },
                    {
                        "username": "armashhashmi",
                        "content": "how can we know that adjacent elements will never be equal??\\n"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "check constraints"
                    },
                    {
                        "username": "Msey",
                        "content": "just find the maximum"
                    },
                    {
                        "username": "lewislunsj",
                        "content": "I would have saved so much time if I have paid attention to the constraints.\\n```nums[i] != nums[i + 1] for all valid i.```"
                    },
                    {
                        "username": "Steven_00",
                        "content": "There isn\\'t any description said \\u201Cadjacent elements cannot be the same\", right? Why I saw other guys and testcases all assume nums[i] != nums[i+1]?"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "check constraints.."
                    },
                    {
                        "username": "am_kumar01",
                        "content": "why does this code gives tle? plss help\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n     int n = nums.size();\\n    int s = 0, e = n - 1;\\n    while (s < e) {\\n        int mid = s + (e - s) / 2;\\n        if (nums[mid] > nums[mid-1]) {\\n            s = mid; // search in the right half\\n        } else {\\n            e = mid - 1; // search in the left half\\n        }\\n    }\\n    return s; \\n    }\\n};\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I solved this but still no idea how I did so!"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "Not a hint, just for acknowledgement : nums[i] != nums[i+1]"
                    }
                ]
            },
            {
                "id": 1888057,
                "content": [
                    {
                        "username": "misfy",
                        "content": "I think the tests are bad. To really test the O(log n) complexity the vector should contain much more than 1000 elements. Coding this thing with a for loop is trivial but it will easily pass all tests. "
                    },
                    {
                        "username": "prototye",
                        "content": "What if we were asked index of all the peak elements, can we modify our binary search in such a way that we can search for all the peaks? If not all can we modify it enough to find the leftmost peak element?\\nAs in example 2 if the question asked for the leftmost peak element then it would have been 2, index = 1."
                    },
                    {
                        "username": "sudheer_m",
                        "content": "Hello!\\n\\nShouldn\\'t the question say >= instead of strictly greater than in the definition of a peak? \\nWe will be able to guarantee that peak will be in the increasing half (the half in which a[i]>a[mid]) only if there is >=.\\nReason: What if, in the increasing half we have the same number repeating?..  We can\\'t find the peak in that case!\\n\\nEg.  5 5 5 3 4 4 4.\\nHere if we choose 3 as mid element and go to one of the greater halves (here both the halves are greater than 3) then we will not be able to find the peak, if it is defined with strict inequatily.\\n\\nSo I guess the definition should have >=."
                    },
                    {
                        "username": "armashhashmi",
                        "content": "how can we know that adjacent elements will never be equal??\\n"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "check constraints"
                    },
                    {
                        "username": "Msey",
                        "content": "just find the maximum"
                    },
                    {
                        "username": "lewislunsj",
                        "content": "I would have saved so much time if I have paid attention to the constraints.\\n```nums[i] != nums[i + 1] for all valid i.```"
                    },
                    {
                        "username": "Steven_00",
                        "content": "There isn\\'t any description said \\u201Cadjacent elements cannot be the same\", right? Why I saw other guys and testcases all assume nums[i] != nums[i+1]?"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "check constraints.."
                    },
                    {
                        "username": "am_kumar01",
                        "content": "why does this code gives tle? plss help\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n     int n = nums.size();\\n    int s = 0, e = n - 1;\\n    while (s < e) {\\n        int mid = s + (e - s) / 2;\\n        if (nums[mid] > nums[mid-1]) {\\n            s = mid; // search in the right half\\n        } else {\\n            e = mid - 1; // search in the left half\\n        }\\n    }\\n    return s; \\n    }\\n};\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I solved this but still no idea how I did so!"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "Not a hint, just for acknowledgement : nums[i] != nums[i+1]"
                    }
                ]
            },
            {
                "id": 1882298,
                "content": [
                    {
                        "username": "misfy",
                        "content": "I think the tests are bad. To really test the O(log n) complexity the vector should contain much more than 1000 elements. Coding this thing with a for loop is trivial but it will easily pass all tests. "
                    },
                    {
                        "username": "prototye",
                        "content": "What if we were asked index of all the peak elements, can we modify our binary search in such a way that we can search for all the peaks? If not all can we modify it enough to find the leftmost peak element?\\nAs in example 2 if the question asked for the leftmost peak element then it would have been 2, index = 1."
                    },
                    {
                        "username": "sudheer_m",
                        "content": "Hello!\\n\\nShouldn\\'t the question say >= instead of strictly greater than in the definition of a peak? \\nWe will be able to guarantee that peak will be in the increasing half (the half in which a[i]>a[mid]) only if there is >=.\\nReason: What if, in the increasing half we have the same number repeating?..  We can\\'t find the peak in that case!\\n\\nEg.  5 5 5 3 4 4 4.\\nHere if we choose 3 as mid element and go to one of the greater halves (here both the halves are greater than 3) then we will not be able to find the peak, if it is defined with strict inequatily.\\n\\nSo I guess the definition should have >=."
                    },
                    {
                        "username": "armashhashmi",
                        "content": "how can we know that adjacent elements will never be equal??\\n"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "check constraints"
                    },
                    {
                        "username": "Msey",
                        "content": "just find the maximum"
                    },
                    {
                        "username": "lewislunsj",
                        "content": "I would have saved so much time if I have paid attention to the constraints.\\n```nums[i] != nums[i + 1] for all valid i.```"
                    },
                    {
                        "username": "Steven_00",
                        "content": "There isn\\'t any description said \\u201Cadjacent elements cannot be the same\", right? Why I saw other guys and testcases all assume nums[i] != nums[i+1]?"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "check constraints.."
                    },
                    {
                        "username": "am_kumar01",
                        "content": "why does this code gives tle? plss help\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n     int n = nums.size();\\n    int s = 0, e = n - 1;\\n    while (s < e) {\\n        int mid = s + (e - s) / 2;\\n        if (nums[mid] > nums[mid-1]) {\\n            s = mid; // search in the right half\\n        } else {\\n            e = mid - 1; // search in the left half\\n        }\\n    }\\n    return s; \\n    }\\n};\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I solved this but still no idea how I did so!"
                    },
                    {
                        "username": "dxtkastb",
                        "content": "Not a hint, just for acknowledgement : nums[i] != nums[i+1]"
                    }
                ]
            },
            {
                "id": 1872716,
                "content": [
                    {
                        "username": "yash_visavadia",
                        "content": "How this is true for having a peak \n`nums = [1, 2]`\neven if we consider inf at both ends\n`nums = [inf, 1, 2, inf ]`\n\nany suggestions are most welcomed"
                    },
                    {
                        "username": "uphar_gaur",
                        "content": "bhai -inf ho \\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "if array is sorted then it is obvious that ans should be the last element of the array"
                    },
                    {
                        "username": "ayushmanglik2003",
                        "content": "Same Question as 852. Peak element in the Mountain Array."
                    },
                    {
                        "username": "Vikas_Chaudhary9966",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int size = nums.size();\\n        int left = 0;\\n        int right = size-1;\\n        while(left<right)\\n        {\\n            int mid = (left+right)/2;\\n            if(mid == 0)\\n            {\\n                return nums[left]>=nums[left+1] ? left : left+1;\\n            }\\n            if(mid == right)\\n            {\\n                return nums[right]>=nums[right-1] ? right : right-1;\\n            }\\n            if(nums[mid]>=nums[mid-1] && nums[mid]>=nums[mid+1])\\n            {\\n                return mid;\\n            }\\n            if(nums[mid]<nums[mid-1])\\n            {\\n                right = mid-1;\\n            }\\n            else\\n            left = mid+1;\\n        }\\n        return left;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "utkarsh-kesarwaNi",
                        "content": "Hi,\\n\\nO(N) solution is also getting accepted which should not be the case.\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1){\\n    return 0;\\n  }\\n  for(int i=0;i<nums.size();i++){\\n    if(i==0 && nums[0]>nums[1]){\\n      return 0;\\n    }\\n    if(i==nums.size()-1 && nums[i]>nums[i-1]){\\n      return nums.size()-1;\\n    }\\n    if(nums[i]>nums[i+1] && nums[i]>nums[i-1]){\\n      return i;\\n    }\\n  }\\n  return -1;\\n    }\\n}; "
                    },
                    {
                        "username": "nitheshb12",
                        "content": "[5, 6, 7, 8, 9, 10, 1, 2, 3] the correct output of this code should be index 5 but,\\n leetcode says its index 8 whyy? even the output is 8"
                    },
                    {
                        "username": "d0poor01",
                        "content": "Interesting that the question says there are multiple peaks but it only wants one peak. Then it\\'s fair to say if I find a global max then that\\'s the only peak I need to find? "
                    },
                    {
                        "username": "imperium8894",
                        "content": "    int ans=0;\\n    \\n    void helper(vector<int>&nums,int low,int high){\\n    \\n    if(low>high)return;\\n\\n    int mid=low+(high-low)/2;\\n    if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]){\\n        ans=mid;\\n        return;\\n    }\\n\\n    helper(nums,low,mid-1);\\n    helper(nums,mid+1,high);\\n    }\\n\\n    int findPeakElement(vector<int>& nums) {\\n        \\n    int n=nums.size();\\n\\n    if(n==1)return 0;\\n\\n    nums.push_back(INT_MIN);\\n    nums.insert(nums.begin()+0,INT_MIN);\\n   \\n    helper(nums,1,n);\\n   \\n    return ans-1;\\n    }\\n\\n\\nWhat will be the Time Complexity of this code(I called recursive function 2 times)?\\nThanks a lot!"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "someone help me in this\\n\\n int findPeakElement(vector<int>& a) {\\n       \\n        int i;\\n        int n=a.size();\\n      for( i=0;i<n;i++)\\n      {\\n          if(i==0)\\n            if(a[i]>a[i+1])\\n                return i;\\n            \\n          else if(i==n-1)\\n            if(a[i]>a[i-1])\\n                return i;\\n                \\n          else\\n            if(a[i]>a[i-1] && a[i]>a[i+1])\\n                return i;\\n      }\\n      return -1;\\n    }"
                    },
                    {
                        "username": "igorknyshev",
                        "content": "It worth explicitly mention` nums[i] != nums[i + 1] for all valid I` in task description instead of constraints section. It can bring idea of solution.\\n"
                    }
                ]
            },
            {
                "id": 1870411,
                "content": [
                    {
                        "username": "yash_visavadia",
                        "content": "How this is true for having a peak \n`nums = [1, 2]`\neven if we consider inf at both ends\n`nums = [inf, 1, 2, inf ]`\n\nany suggestions are most welcomed"
                    },
                    {
                        "username": "uphar_gaur",
                        "content": "bhai -inf ho \\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "if array is sorted then it is obvious that ans should be the last element of the array"
                    },
                    {
                        "username": "ayushmanglik2003",
                        "content": "Same Question as 852. Peak element in the Mountain Array."
                    },
                    {
                        "username": "Vikas_Chaudhary9966",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int size = nums.size();\\n        int left = 0;\\n        int right = size-1;\\n        while(left<right)\\n        {\\n            int mid = (left+right)/2;\\n            if(mid == 0)\\n            {\\n                return nums[left]>=nums[left+1] ? left : left+1;\\n            }\\n            if(mid == right)\\n            {\\n                return nums[right]>=nums[right-1] ? right : right-1;\\n            }\\n            if(nums[mid]>=nums[mid-1] && nums[mid]>=nums[mid+1])\\n            {\\n                return mid;\\n            }\\n            if(nums[mid]<nums[mid-1])\\n            {\\n                right = mid-1;\\n            }\\n            else\\n            left = mid+1;\\n        }\\n        return left;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "utkarsh-kesarwaNi",
                        "content": "Hi,\\n\\nO(N) solution is also getting accepted which should not be the case.\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1){\\n    return 0;\\n  }\\n  for(int i=0;i<nums.size();i++){\\n    if(i==0 && nums[0]>nums[1]){\\n      return 0;\\n    }\\n    if(i==nums.size()-1 && nums[i]>nums[i-1]){\\n      return nums.size()-1;\\n    }\\n    if(nums[i]>nums[i+1] && nums[i]>nums[i-1]){\\n      return i;\\n    }\\n  }\\n  return -1;\\n    }\\n}; "
                    },
                    {
                        "username": "nitheshb12",
                        "content": "[5, 6, 7, 8, 9, 10, 1, 2, 3] the correct output of this code should be index 5 but,\\n leetcode says its index 8 whyy? even the output is 8"
                    },
                    {
                        "username": "d0poor01",
                        "content": "Interesting that the question says there are multiple peaks but it only wants one peak. Then it\\'s fair to say if I find a global max then that\\'s the only peak I need to find? "
                    },
                    {
                        "username": "imperium8894",
                        "content": "    int ans=0;\\n    \\n    void helper(vector<int>&nums,int low,int high){\\n    \\n    if(low>high)return;\\n\\n    int mid=low+(high-low)/2;\\n    if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]){\\n        ans=mid;\\n        return;\\n    }\\n\\n    helper(nums,low,mid-1);\\n    helper(nums,mid+1,high);\\n    }\\n\\n    int findPeakElement(vector<int>& nums) {\\n        \\n    int n=nums.size();\\n\\n    if(n==1)return 0;\\n\\n    nums.push_back(INT_MIN);\\n    nums.insert(nums.begin()+0,INT_MIN);\\n   \\n    helper(nums,1,n);\\n   \\n    return ans-1;\\n    }\\n\\n\\nWhat will be the Time Complexity of this code(I called recursive function 2 times)?\\nThanks a lot!"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "someone help me in this\\n\\n int findPeakElement(vector<int>& a) {\\n       \\n        int i;\\n        int n=a.size();\\n      for( i=0;i<n;i++)\\n      {\\n          if(i==0)\\n            if(a[i]>a[i+1])\\n                return i;\\n            \\n          else if(i==n-1)\\n            if(a[i]>a[i-1])\\n                return i;\\n                \\n          else\\n            if(a[i]>a[i-1] && a[i]>a[i+1])\\n                return i;\\n      }\\n      return -1;\\n    }"
                    },
                    {
                        "username": "igorknyshev",
                        "content": "It worth explicitly mention` nums[i] != nums[i + 1] for all valid I` in task description instead of constraints section. It can bring idea of solution.\\n"
                    }
                ]
            },
            {
                "id": 1868412,
                "content": [
                    {
                        "username": "yash_visavadia",
                        "content": "How this is true for having a peak \n`nums = [1, 2]`\neven if we consider inf at both ends\n`nums = [inf, 1, 2, inf ]`\n\nany suggestions are most welcomed"
                    },
                    {
                        "username": "uphar_gaur",
                        "content": "bhai -inf ho \\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "if array is sorted then it is obvious that ans should be the last element of the array"
                    },
                    {
                        "username": "ayushmanglik2003",
                        "content": "Same Question as 852. Peak element in the Mountain Array."
                    },
                    {
                        "username": "Vikas_Chaudhary9966",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int size = nums.size();\\n        int left = 0;\\n        int right = size-1;\\n        while(left<right)\\n        {\\n            int mid = (left+right)/2;\\n            if(mid == 0)\\n            {\\n                return nums[left]>=nums[left+1] ? left : left+1;\\n            }\\n            if(mid == right)\\n            {\\n                return nums[right]>=nums[right-1] ? right : right-1;\\n            }\\n            if(nums[mid]>=nums[mid-1] && nums[mid]>=nums[mid+1])\\n            {\\n                return mid;\\n            }\\n            if(nums[mid]<nums[mid-1])\\n            {\\n                right = mid-1;\\n            }\\n            else\\n            left = mid+1;\\n        }\\n        return left;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "utkarsh-kesarwaNi",
                        "content": "Hi,\\n\\nO(N) solution is also getting accepted which should not be the case.\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1){\\n    return 0;\\n  }\\n  for(int i=0;i<nums.size();i++){\\n    if(i==0 && nums[0]>nums[1]){\\n      return 0;\\n    }\\n    if(i==nums.size()-1 && nums[i]>nums[i-1]){\\n      return nums.size()-1;\\n    }\\n    if(nums[i]>nums[i+1] && nums[i]>nums[i-1]){\\n      return i;\\n    }\\n  }\\n  return -1;\\n    }\\n}; "
                    },
                    {
                        "username": "nitheshb12",
                        "content": "[5, 6, 7, 8, 9, 10, 1, 2, 3] the correct output of this code should be index 5 but,\\n leetcode says its index 8 whyy? even the output is 8"
                    },
                    {
                        "username": "d0poor01",
                        "content": "Interesting that the question says there are multiple peaks but it only wants one peak. Then it\\'s fair to say if I find a global max then that\\'s the only peak I need to find? "
                    },
                    {
                        "username": "imperium8894",
                        "content": "    int ans=0;\\n    \\n    void helper(vector<int>&nums,int low,int high){\\n    \\n    if(low>high)return;\\n\\n    int mid=low+(high-low)/2;\\n    if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]){\\n        ans=mid;\\n        return;\\n    }\\n\\n    helper(nums,low,mid-1);\\n    helper(nums,mid+1,high);\\n    }\\n\\n    int findPeakElement(vector<int>& nums) {\\n        \\n    int n=nums.size();\\n\\n    if(n==1)return 0;\\n\\n    nums.push_back(INT_MIN);\\n    nums.insert(nums.begin()+0,INT_MIN);\\n   \\n    helper(nums,1,n);\\n   \\n    return ans-1;\\n    }\\n\\n\\nWhat will be the Time Complexity of this code(I called recursive function 2 times)?\\nThanks a lot!"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "someone help me in this\\n\\n int findPeakElement(vector<int>& a) {\\n       \\n        int i;\\n        int n=a.size();\\n      for( i=0;i<n;i++)\\n      {\\n          if(i==0)\\n            if(a[i]>a[i+1])\\n                return i;\\n            \\n          else if(i==n-1)\\n            if(a[i]>a[i-1])\\n                return i;\\n                \\n          else\\n            if(a[i]>a[i-1] && a[i]>a[i+1])\\n                return i;\\n      }\\n      return -1;\\n    }"
                    },
                    {
                        "username": "igorknyshev",
                        "content": "It worth explicitly mention` nums[i] != nums[i + 1] for all valid I` in task description instead of constraints section. It can bring idea of solution.\\n"
                    }
                ]
            },
            {
                "id": 1862007,
                "content": [
                    {
                        "username": "yash_visavadia",
                        "content": "How this is true for having a peak \n`nums = [1, 2]`\neven if we consider inf at both ends\n`nums = [inf, 1, 2, inf ]`\n\nany suggestions are most welcomed"
                    },
                    {
                        "username": "uphar_gaur",
                        "content": "bhai -inf ho \\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "if array is sorted then it is obvious that ans should be the last element of the array"
                    },
                    {
                        "username": "ayushmanglik2003",
                        "content": "Same Question as 852. Peak element in the Mountain Array."
                    },
                    {
                        "username": "Vikas_Chaudhary9966",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int size = nums.size();\\n        int left = 0;\\n        int right = size-1;\\n        while(left<right)\\n        {\\n            int mid = (left+right)/2;\\n            if(mid == 0)\\n            {\\n                return nums[left]>=nums[left+1] ? left : left+1;\\n            }\\n            if(mid == right)\\n            {\\n                return nums[right]>=nums[right-1] ? right : right-1;\\n            }\\n            if(nums[mid]>=nums[mid-1] && nums[mid]>=nums[mid+1])\\n            {\\n                return mid;\\n            }\\n            if(nums[mid]<nums[mid-1])\\n            {\\n                right = mid-1;\\n            }\\n            else\\n            left = mid+1;\\n        }\\n        return left;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "utkarsh-kesarwaNi",
                        "content": "Hi,\\n\\nO(N) solution is also getting accepted which should not be the case.\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1){\\n    return 0;\\n  }\\n  for(int i=0;i<nums.size();i++){\\n    if(i==0 && nums[0]>nums[1]){\\n      return 0;\\n    }\\n    if(i==nums.size()-1 && nums[i]>nums[i-1]){\\n      return nums.size()-1;\\n    }\\n    if(nums[i]>nums[i+1] && nums[i]>nums[i-1]){\\n      return i;\\n    }\\n  }\\n  return -1;\\n    }\\n}; "
                    },
                    {
                        "username": "nitheshb12",
                        "content": "[5, 6, 7, 8, 9, 10, 1, 2, 3] the correct output of this code should be index 5 but,\\n leetcode says its index 8 whyy? even the output is 8"
                    },
                    {
                        "username": "d0poor01",
                        "content": "Interesting that the question says there are multiple peaks but it only wants one peak. Then it\\'s fair to say if I find a global max then that\\'s the only peak I need to find? "
                    },
                    {
                        "username": "imperium8894",
                        "content": "    int ans=0;\\n    \\n    void helper(vector<int>&nums,int low,int high){\\n    \\n    if(low>high)return;\\n\\n    int mid=low+(high-low)/2;\\n    if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]){\\n        ans=mid;\\n        return;\\n    }\\n\\n    helper(nums,low,mid-1);\\n    helper(nums,mid+1,high);\\n    }\\n\\n    int findPeakElement(vector<int>& nums) {\\n        \\n    int n=nums.size();\\n\\n    if(n==1)return 0;\\n\\n    nums.push_back(INT_MIN);\\n    nums.insert(nums.begin()+0,INT_MIN);\\n   \\n    helper(nums,1,n);\\n   \\n    return ans-1;\\n    }\\n\\n\\nWhat will be the Time Complexity of this code(I called recursive function 2 times)?\\nThanks a lot!"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "someone help me in this\\n\\n int findPeakElement(vector<int>& a) {\\n       \\n        int i;\\n        int n=a.size();\\n      for( i=0;i<n;i++)\\n      {\\n          if(i==0)\\n            if(a[i]>a[i+1])\\n                return i;\\n            \\n          else if(i==n-1)\\n            if(a[i]>a[i-1])\\n                return i;\\n                \\n          else\\n            if(a[i]>a[i-1] && a[i]>a[i+1])\\n                return i;\\n      }\\n      return -1;\\n    }"
                    },
                    {
                        "username": "igorknyshev",
                        "content": "It worth explicitly mention` nums[i] != nums[i + 1] for all valid I` in task description instead of constraints section. It can bring idea of solution.\\n"
                    }
                ]
            },
            {
                "id": 1857531,
                "content": [
                    {
                        "username": "yash_visavadia",
                        "content": "How this is true for having a peak \n`nums = [1, 2]`\neven if we consider inf at both ends\n`nums = [inf, 1, 2, inf ]`\n\nany suggestions are most welcomed"
                    },
                    {
                        "username": "uphar_gaur",
                        "content": "bhai -inf ho \\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "if array is sorted then it is obvious that ans should be the last element of the array"
                    },
                    {
                        "username": "ayushmanglik2003",
                        "content": "Same Question as 852. Peak element in the Mountain Array."
                    },
                    {
                        "username": "Vikas_Chaudhary9966",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int size = nums.size();\\n        int left = 0;\\n        int right = size-1;\\n        while(left<right)\\n        {\\n            int mid = (left+right)/2;\\n            if(mid == 0)\\n            {\\n                return nums[left]>=nums[left+1] ? left : left+1;\\n            }\\n            if(mid == right)\\n            {\\n                return nums[right]>=nums[right-1] ? right : right-1;\\n            }\\n            if(nums[mid]>=nums[mid-1] && nums[mid]>=nums[mid+1])\\n            {\\n                return mid;\\n            }\\n            if(nums[mid]<nums[mid-1])\\n            {\\n                right = mid-1;\\n            }\\n            else\\n            left = mid+1;\\n        }\\n        return left;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "utkarsh-kesarwaNi",
                        "content": "Hi,\\n\\nO(N) solution is also getting accepted which should not be the case.\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1){\\n    return 0;\\n  }\\n  for(int i=0;i<nums.size();i++){\\n    if(i==0 && nums[0]>nums[1]){\\n      return 0;\\n    }\\n    if(i==nums.size()-1 && nums[i]>nums[i-1]){\\n      return nums.size()-1;\\n    }\\n    if(nums[i]>nums[i+1] && nums[i]>nums[i-1]){\\n      return i;\\n    }\\n  }\\n  return -1;\\n    }\\n}; "
                    },
                    {
                        "username": "nitheshb12",
                        "content": "[5, 6, 7, 8, 9, 10, 1, 2, 3] the correct output of this code should be index 5 but,\\n leetcode says its index 8 whyy? even the output is 8"
                    },
                    {
                        "username": "d0poor01",
                        "content": "Interesting that the question says there are multiple peaks but it only wants one peak. Then it\\'s fair to say if I find a global max then that\\'s the only peak I need to find? "
                    },
                    {
                        "username": "imperium8894",
                        "content": "    int ans=0;\\n    \\n    void helper(vector<int>&nums,int low,int high){\\n    \\n    if(low>high)return;\\n\\n    int mid=low+(high-low)/2;\\n    if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]){\\n        ans=mid;\\n        return;\\n    }\\n\\n    helper(nums,low,mid-1);\\n    helper(nums,mid+1,high);\\n    }\\n\\n    int findPeakElement(vector<int>& nums) {\\n        \\n    int n=nums.size();\\n\\n    if(n==1)return 0;\\n\\n    nums.push_back(INT_MIN);\\n    nums.insert(nums.begin()+0,INT_MIN);\\n   \\n    helper(nums,1,n);\\n   \\n    return ans-1;\\n    }\\n\\n\\nWhat will be the Time Complexity of this code(I called recursive function 2 times)?\\nThanks a lot!"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "someone help me in this\\n\\n int findPeakElement(vector<int>& a) {\\n       \\n        int i;\\n        int n=a.size();\\n      for( i=0;i<n;i++)\\n      {\\n          if(i==0)\\n            if(a[i]>a[i+1])\\n                return i;\\n            \\n          else if(i==n-1)\\n            if(a[i]>a[i-1])\\n                return i;\\n                \\n          else\\n            if(a[i]>a[i-1] && a[i]>a[i+1])\\n                return i;\\n      }\\n      return -1;\\n    }"
                    },
                    {
                        "username": "igorknyshev",
                        "content": "It worth explicitly mention` nums[i] != nums[i + 1] for all valid I` in task description instead of constraints section. It can bring idea of solution.\\n"
                    }
                ]
            },
            {
                "id": 1846496,
                "content": [
                    {
                        "username": "yash_visavadia",
                        "content": "How this is true for having a peak \n`nums = [1, 2]`\neven if we consider inf at both ends\n`nums = [inf, 1, 2, inf ]`\n\nany suggestions are most welcomed"
                    },
                    {
                        "username": "uphar_gaur",
                        "content": "bhai -inf ho \\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "if array is sorted then it is obvious that ans should be the last element of the array"
                    },
                    {
                        "username": "ayushmanglik2003",
                        "content": "Same Question as 852. Peak element in the Mountain Array."
                    },
                    {
                        "username": "Vikas_Chaudhary9966",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int size = nums.size();\\n        int left = 0;\\n        int right = size-1;\\n        while(left<right)\\n        {\\n            int mid = (left+right)/2;\\n            if(mid == 0)\\n            {\\n                return nums[left]>=nums[left+1] ? left : left+1;\\n            }\\n            if(mid == right)\\n            {\\n                return nums[right]>=nums[right-1] ? right : right-1;\\n            }\\n            if(nums[mid]>=nums[mid-1] && nums[mid]>=nums[mid+1])\\n            {\\n                return mid;\\n            }\\n            if(nums[mid]<nums[mid-1])\\n            {\\n                right = mid-1;\\n            }\\n            else\\n            left = mid+1;\\n        }\\n        return left;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "utkarsh-kesarwaNi",
                        "content": "Hi,\\n\\nO(N) solution is also getting accepted which should not be the case.\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1){\\n    return 0;\\n  }\\n  for(int i=0;i<nums.size();i++){\\n    if(i==0 && nums[0]>nums[1]){\\n      return 0;\\n    }\\n    if(i==nums.size()-1 && nums[i]>nums[i-1]){\\n      return nums.size()-1;\\n    }\\n    if(nums[i]>nums[i+1] && nums[i]>nums[i-1]){\\n      return i;\\n    }\\n  }\\n  return -1;\\n    }\\n}; "
                    },
                    {
                        "username": "nitheshb12",
                        "content": "[5, 6, 7, 8, 9, 10, 1, 2, 3] the correct output of this code should be index 5 but,\\n leetcode says its index 8 whyy? even the output is 8"
                    },
                    {
                        "username": "d0poor01",
                        "content": "Interesting that the question says there are multiple peaks but it only wants one peak. Then it\\'s fair to say if I find a global max then that\\'s the only peak I need to find? "
                    },
                    {
                        "username": "imperium8894",
                        "content": "    int ans=0;\\n    \\n    void helper(vector<int>&nums,int low,int high){\\n    \\n    if(low>high)return;\\n\\n    int mid=low+(high-low)/2;\\n    if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]){\\n        ans=mid;\\n        return;\\n    }\\n\\n    helper(nums,low,mid-1);\\n    helper(nums,mid+1,high);\\n    }\\n\\n    int findPeakElement(vector<int>& nums) {\\n        \\n    int n=nums.size();\\n\\n    if(n==1)return 0;\\n\\n    nums.push_back(INT_MIN);\\n    nums.insert(nums.begin()+0,INT_MIN);\\n   \\n    helper(nums,1,n);\\n   \\n    return ans-1;\\n    }\\n\\n\\nWhat will be the Time Complexity of this code(I called recursive function 2 times)?\\nThanks a lot!"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "someone help me in this\\n\\n int findPeakElement(vector<int>& a) {\\n       \\n        int i;\\n        int n=a.size();\\n      for( i=0;i<n;i++)\\n      {\\n          if(i==0)\\n            if(a[i]>a[i+1])\\n                return i;\\n            \\n          else if(i==n-1)\\n            if(a[i]>a[i-1])\\n                return i;\\n                \\n          else\\n            if(a[i]>a[i-1] && a[i]>a[i+1])\\n                return i;\\n      }\\n      return -1;\\n    }"
                    },
                    {
                        "username": "igorknyshev",
                        "content": "It worth explicitly mention` nums[i] != nums[i + 1] for all valid I` in task description instead of constraints section. It can bring idea of solution.\\n"
                    }
                ]
            },
            {
                "id": 1840132,
                "content": [
                    {
                        "username": "yash_visavadia",
                        "content": "How this is true for having a peak \n`nums = [1, 2]`\neven if we consider inf at both ends\n`nums = [inf, 1, 2, inf ]`\n\nany suggestions are most welcomed"
                    },
                    {
                        "username": "uphar_gaur",
                        "content": "bhai -inf ho \\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "if array is sorted then it is obvious that ans should be the last element of the array"
                    },
                    {
                        "username": "ayushmanglik2003",
                        "content": "Same Question as 852. Peak element in the Mountain Array."
                    },
                    {
                        "username": "Vikas_Chaudhary9966",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int size = nums.size();\\n        int left = 0;\\n        int right = size-1;\\n        while(left<right)\\n        {\\n            int mid = (left+right)/2;\\n            if(mid == 0)\\n            {\\n                return nums[left]>=nums[left+1] ? left : left+1;\\n            }\\n            if(mid == right)\\n            {\\n                return nums[right]>=nums[right-1] ? right : right-1;\\n            }\\n            if(nums[mid]>=nums[mid-1] && nums[mid]>=nums[mid+1])\\n            {\\n                return mid;\\n            }\\n            if(nums[mid]<nums[mid-1])\\n            {\\n                right = mid-1;\\n            }\\n            else\\n            left = mid+1;\\n        }\\n        return left;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "utkarsh-kesarwaNi",
                        "content": "Hi,\\n\\nO(N) solution is also getting accepted which should not be the case.\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1){\\n    return 0;\\n  }\\n  for(int i=0;i<nums.size();i++){\\n    if(i==0 && nums[0]>nums[1]){\\n      return 0;\\n    }\\n    if(i==nums.size()-1 && nums[i]>nums[i-1]){\\n      return nums.size()-1;\\n    }\\n    if(nums[i]>nums[i+1] && nums[i]>nums[i-1]){\\n      return i;\\n    }\\n  }\\n  return -1;\\n    }\\n}; "
                    },
                    {
                        "username": "nitheshb12",
                        "content": "[5, 6, 7, 8, 9, 10, 1, 2, 3] the correct output of this code should be index 5 but,\\n leetcode says its index 8 whyy? even the output is 8"
                    },
                    {
                        "username": "d0poor01",
                        "content": "Interesting that the question says there are multiple peaks but it only wants one peak. Then it\\'s fair to say if I find a global max then that\\'s the only peak I need to find? "
                    },
                    {
                        "username": "imperium8894",
                        "content": "    int ans=0;\\n    \\n    void helper(vector<int>&nums,int low,int high){\\n    \\n    if(low>high)return;\\n\\n    int mid=low+(high-low)/2;\\n    if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]){\\n        ans=mid;\\n        return;\\n    }\\n\\n    helper(nums,low,mid-1);\\n    helper(nums,mid+1,high);\\n    }\\n\\n    int findPeakElement(vector<int>& nums) {\\n        \\n    int n=nums.size();\\n\\n    if(n==1)return 0;\\n\\n    nums.push_back(INT_MIN);\\n    nums.insert(nums.begin()+0,INT_MIN);\\n   \\n    helper(nums,1,n);\\n   \\n    return ans-1;\\n    }\\n\\n\\nWhat will be the Time Complexity of this code(I called recursive function 2 times)?\\nThanks a lot!"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "someone help me in this\\n\\n int findPeakElement(vector<int>& a) {\\n       \\n        int i;\\n        int n=a.size();\\n      for( i=0;i<n;i++)\\n      {\\n          if(i==0)\\n            if(a[i]>a[i+1])\\n                return i;\\n            \\n          else if(i==n-1)\\n            if(a[i]>a[i-1])\\n                return i;\\n                \\n          else\\n            if(a[i]>a[i-1] && a[i]>a[i+1])\\n                return i;\\n      }\\n      return -1;\\n    }"
                    },
                    {
                        "username": "igorknyshev",
                        "content": "It worth explicitly mention` nums[i] != nums[i + 1] for all valid I` in task description instead of constraints section. It can bring idea of solution.\\n"
                    }
                ]
            },
            {
                "id": 1831028,
                "content": [
                    {
                        "username": "yash_visavadia",
                        "content": "How this is true for having a peak \n`nums = [1, 2]`\neven if we consider inf at both ends\n`nums = [inf, 1, 2, inf ]`\n\nany suggestions are most welcomed"
                    },
                    {
                        "username": "uphar_gaur",
                        "content": "bhai -inf ho \\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "if array is sorted then it is obvious that ans should be the last element of the array"
                    },
                    {
                        "username": "ayushmanglik2003",
                        "content": "Same Question as 852. Peak element in the Mountain Array."
                    },
                    {
                        "username": "Vikas_Chaudhary9966",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int size = nums.size();\\n        int left = 0;\\n        int right = size-1;\\n        while(left<right)\\n        {\\n            int mid = (left+right)/2;\\n            if(mid == 0)\\n            {\\n                return nums[left]>=nums[left+1] ? left : left+1;\\n            }\\n            if(mid == right)\\n            {\\n                return nums[right]>=nums[right-1] ? right : right-1;\\n            }\\n            if(nums[mid]>=nums[mid-1] && nums[mid]>=nums[mid+1])\\n            {\\n                return mid;\\n            }\\n            if(nums[mid]<nums[mid-1])\\n            {\\n                right = mid-1;\\n            }\\n            else\\n            left = mid+1;\\n        }\\n        return left;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "utkarsh-kesarwaNi",
                        "content": "Hi,\\n\\nO(N) solution is also getting accepted which should not be the case.\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1){\\n    return 0;\\n  }\\n  for(int i=0;i<nums.size();i++){\\n    if(i==0 && nums[0]>nums[1]){\\n      return 0;\\n    }\\n    if(i==nums.size()-1 && nums[i]>nums[i-1]){\\n      return nums.size()-1;\\n    }\\n    if(nums[i]>nums[i+1] && nums[i]>nums[i-1]){\\n      return i;\\n    }\\n  }\\n  return -1;\\n    }\\n}; "
                    },
                    {
                        "username": "nitheshb12",
                        "content": "[5, 6, 7, 8, 9, 10, 1, 2, 3] the correct output of this code should be index 5 but,\\n leetcode says its index 8 whyy? even the output is 8"
                    },
                    {
                        "username": "d0poor01",
                        "content": "Interesting that the question says there are multiple peaks but it only wants one peak. Then it\\'s fair to say if I find a global max then that\\'s the only peak I need to find? "
                    },
                    {
                        "username": "imperium8894",
                        "content": "    int ans=0;\\n    \\n    void helper(vector<int>&nums,int low,int high){\\n    \\n    if(low>high)return;\\n\\n    int mid=low+(high-low)/2;\\n    if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]){\\n        ans=mid;\\n        return;\\n    }\\n\\n    helper(nums,low,mid-1);\\n    helper(nums,mid+1,high);\\n    }\\n\\n    int findPeakElement(vector<int>& nums) {\\n        \\n    int n=nums.size();\\n\\n    if(n==1)return 0;\\n\\n    nums.push_back(INT_MIN);\\n    nums.insert(nums.begin()+0,INT_MIN);\\n   \\n    helper(nums,1,n);\\n   \\n    return ans-1;\\n    }\\n\\n\\nWhat will be the Time Complexity of this code(I called recursive function 2 times)?\\nThanks a lot!"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "someone help me in this\\n\\n int findPeakElement(vector<int>& a) {\\n       \\n        int i;\\n        int n=a.size();\\n      for( i=0;i<n;i++)\\n      {\\n          if(i==0)\\n            if(a[i]>a[i+1])\\n                return i;\\n            \\n          else if(i==n-1)\\n            if(a[i]>a[i-1])\\n                return i;\\n                \\n          else\\n            if(a[i]>a[i-1] && a[i]>a[i+1])\\n                return i;\\n      }\\n      return -1;\\n    }"
                    },
                    {
                        "username": "igorknyshev",
                        "content": "It worth explicitly mention` nums[i] != nums[i + 1] for all valid I` in task description instead of constraints section. It can bring idea of solution.\\n"
                    }
                ]
            },
            {
                "id": 1827395,
                "content": [
                    {
                        "username": "yash_visavadia",
                        "content": "How this is true for having a peak \n`nums = [1, 2]`\neven if we consider inf at both ends\n`nums = [inf, 1, 2, inf ]`\n\nany suggestions are most welcomed"
                    },
                    {
                        "username": "uphar_gaur",
                        "content": "bhai -inf ho \\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "if array is sorted then it is obvious that ans should be the last element of the array"
                    },
                    {
                        "username": "ayushmanglik2003",
                        "content": "Same Question as 852. Peak element in the Mountain Array."
                    },
                    {
                        "username": "Vikas_Chaudhary9966",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int size = nums.size();\\n        int left = 0;\\n        int right = size-1;\\n        while(left<right)\\n        {\\n            int mid = (left+right)/2;\\n            if(mid == 0)\\n            {\\n                return nums[left]>=nums[left+1] ? left : left+1;\\n            }\\n            if(mid == right)\\n            {\\n                return nums[right]>=nums[right-1] ? right : right-1;\\n            }\\n            if(nums[mid]>=nums[mid-1] && nums[mid]>=nums[mid+1])\\n            {\\n                return mid;\\n            }\\n            if(nums[mid]<nums[mid-1])\\n            {\\n                right = mid-1;\\n            }\\n            else\\n            left = mid+1;\\n        }\\n        return left;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "utkarsh-kesarwaNi",
                        "content": "Hi,\\n\\nO(N) solution is also getting accepted which should not be the case.\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1){\\n    return 0;\\n  }\\n  for(int i=0;i<nums.size();i++){\\n    if(i==0 && nums[0]>nums[1]){\\n      return 0;\\n    }\\n    if(i==nums.size()-1 && nums[i]>nums[i-1]){\\n      return nums.size()-1;\\n    }\\n    if(nums[i]>nums[i+1] && nums[i]>nums[i-1]){\\n      return i;\\n    }\\n  }\\n  return -1;\\n    }\\n}; "
                    },
                    {
                        "username": "nitheshb12",
                        "content": "[5, 6, 7, 8, 9, 10, 1, 2, 3] the correct output of this code should be index 5 but,\\n leetcode says its index 8 whyy? even the output is 8"
                    },
                    {
                        "username": "d0poor01",
                        "content": "Interesting that the question says there are multiple peaks but it only wants one peak. Then it\\'s fair to say if I find a global max then that\\'s the only peak I need to find? "
                    },
                    {
                        "username": "imperium8894",
                        "content": "    int ans=0;\\n    \\n    void helper(vector<int>&nums,int low,int high){\\n    \\n    if(low>high)return;\\n\\n    int mid=low+(high-low)/2;\\n    if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]){\\n        ans=mid;\\n        return;\\n    }\\n\\n    helper(nums,low,mid-1);\\n    helper(nums,mid+1,high);\\n    }\\n\\n    int findPeakElement(vector<int>& nums) {\\n        \\n    int n=nums.size();\\n\\n    if(n==1)return 0;\\n\\n    nums.push_back(INT_MIN);\\n    nums.insert(nums.begin()+0,INT_MIN);\\n   \\n    helper(nums,1,n);\\n   \\n    return ans-1;\\n    }\\n\\n\\nWhat will be the Time Complexity of this code(I called recursive function 2 times)?\\nThanks a lot!"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "someone help me in this\\n\\n int findPeakElement(vector<int>& a) {\\n       \\n        int i;\\n        int n=a.size();\\n      for( i=0;i<n;i++)\\n      {\\n          if(i==0)\\n            if(a[i]>a[i+1])\\n                return i;\\n            \\n          else if(i==n-1)\\n            if(a[i]>a[i-1])\\n                return i;\\n                \\n          else\\n            if(a[i]>a[i-1] && a[i]>a[i+1])\\n                return i;\\n      }\\n      return -1;\\n    }"
                    },
                    {
                        "username": "igorknyshev",
                        "content": "It worth explicitly mention` nums[i] != nums[i + 1] for all valid I` in task description instead of constraints section. It can bring idea of solution.\\n"
                    }
                ]
            },
            {
                "id": 1815429,
                "content": [
                    {
                        "username": "yash_visavadia",
                        "content": "How this is true for having a peak \n`nums = [1, 2]`\neven if we consider inf at both ends\n`nums = [inf, 1, 2, inf ]`\n\nany suggestions are most welcomed"
                    },
                    {
                        "username": "uphar_gaur",
                        "content": "bhai -inf ho \\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "if array is sorted then it is obvious that ans should be the last element of the array"
                    },
                    {
                        "username": "ayushmanglik2003",
                        "content": "Same Question as 852. Peak element in the Mountain Array."
                    },
                    {
                        "username": "Vikas_Chaudhary9966",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int size = nums.size();\\n        int left = 0;\\n        int right = size-1;\\n        while(left<right)\\n        {\\n            int mid = (left+right)/2;\\n            if(mid == 0)\\n            {\\n                return nums[left]>=nums[left+1] ? left : left+1;\\n            }\\n            if(mid == right)\\n            {\\n                return nums[right]>=nums[right-1] ? right : right-1;\\n            }\\n            if(nums[mid]>=nums[mid-1] && nums[mid]>=nums[mid+1])\\n            {\\n                return mid;\\n            }\\n            if(nums[mid]<nums[mid-1])\\n            {\\n                right = mid-1;\\n            }\\n            else\\n            left = mid+1;\\n        }\\n        return left;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "utkarsh-kesarwaNi",
                        "content": "Hi,\\n\\nO(N) solution is also getting accepted which should not be the case.\\n\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        if(nums.size()==1){\\n    return 0;\\n  }\\n  for(int i=0;i<nums.size();i++){\\n    if(i==0 && nums[0]>nums[1]){\\n      return 0;\\n    }\\n    if(i==nums.size()-1 && nums[i]>nums[i-1]){\\n      return nums.size()-1;\\n    }\\n    if(nums[i]>nums[i+1] && nums[i]>nums[i-1]){\\n      return i;\\n    }\\n  }\\n  return -1;\\n    }\\n}; "
                    },
                    {
                        "username": "nitheshb12",
                        "content": "[5, 6, 7, 8, 9, 10, 1, 2, 3] the correct output of this code should be index 5 but,\\n leetcode says its index 8 whyy? even the output is 8"
                    },
                    {
                        "username": "d0poor01",
                        "content": "Interesting that the question says there are multiple peaks but it only wants one peak. Then it\\'s fair to say if I find a global max then that\\'s the only peak I need to find? "
                    },
                    {
                        "username": "imperium8894",
                        "content": "    int ans=0;\\n    \\n    void helper(vector<int>&nums,int low,int high){\\n    \\n    if(low>high)return;\\n\\n    int mid=low+(high-low)/2;\\n    if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]){\\n        ans=mid;\\n        return;\\n    }\\n\\n    helper(nums,low,mid-1);\\n    helper(nums,mid+1,high);\\n    }\\n\\n    int findPeakElement(vector<int>& nums) {\\n        \\n    int n=nums.size();\\n\\n    if(n==1)return 0;\\n\\n    nums.push_back(INT_MIN);\\n    nums.insert(nums.begin()+0,INT_MIN);\\n   \\n    helper(nums,1,n);\\n   \\n    return ans-1;\\n    }\\n\\n\\nWhat will be the Time Complexity of this code(I called recursive function 2 times)?\\nThanks a lot!"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "someone help me in this\\n\\n int findPeakElement(vector<int>& a) {\\n       \\n        int i;\\n        int n=a.size();\\n      for( i=0;i<n;i++)\\n      {\\n          if(i==0)\\n            if(a[i]>a[i+1])\\n                return i;\\n            \\n          else if(i==n-1)\\n            if(a[i]>a[i-1])\\n                return i;\\n                \\n          else\\n            if(a[i]>a[i-1] && a[i]>a[i+1])\\n                return i;\\n      }\\n      return -1;\\n    }"
                    },
                    {
                        "username": "igorknyshev",
                        "content": "It worth explicitly mention` nums[i] != nums[i + 1] for all valid I` in task description instead of constraints section. It can bring idea of solution.\\n"
                    }
                ]
            },
            {
                "id": 1808736,
                "content": [
                    {
                        "username": "sannyranjan",
                        "content": "class Solution {\\n    public int findPeakElement(int[] arr) {\\n        int start =0;\\n\\t\\tint end=arr.length-1;\\n\\t\\twhile (start<end) {\\n\\t\\tint mid =start +(end-start)/2;\\n\\t\\t\\t\\n\\t\\t\\tif(arr[mid]>arr[mid+1]) {\\n\\t\\t\\t\\tend = mid;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t   start=mid+1;\\n\\t\\t\\t}\\n\\n    }\\n\\t\\treturn start;\\n    }\\n}"
                    },
                    {
                        "username": "_aka5h",
                        "content": " `nums[i] != nums[i + 1] for all valid i`\\nWhy the most important observation for this problem given in constraint and not in problem statement itself?"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "so frustrating, I have done this question on dev C++ but same code is not working for leetcode. I tried the same test case on dev c++ and its working but on leetcode its showing runtime error.\\n\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000190 overflowed to 0x60200000018c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nCODE:\\nclass Solution {\\npublic:\\n    int findPeakElementHelper( vector<int> &nums ){\\n\\n        int n = nums.size();\\n        int low = 0;\\n        int high = n - 1;\\n\\n        while(low<=high){\\n\\n            int mid = (low + high)/2;\\n\\n            if( (nums[mid-1]<= nums[mid] || mid==0) && (nums[mid]>=nums[mid+1] || mid==n-1 ) )\\n                return mid;\\n\\n            else if( nums[mid-1] >= nums[mid] && mid!=0 )\\n                high = mid - 1;\\n            \\n            else if( nums[mid]<= nums[mid+1] && mid!= n-1 )\\n                low = mid + 1;\\n        }\\n\\n        return -1;\\n\\n    }\\n\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n\\n        return findPeakElementHelper(nums);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "infantsanthosh1995",
                        "content": "Will this come under o(logn) time complexity ??? Please anyone confirm\n\nclass Solution:\n    def findPeakElement(self, nums) :\n        for i in range(1,len(nums)-1):\n            if nums[i]>nums[i-1] and nums[i]>nums[i+1]:\n                return i\n        if len(nums)==1:\n            return 0\n        return nums.index(max(nums))\n"
                    },
                    {
                        "username": "pawanChandra999999",
                        "content": "I think at the worst case it is O(N) T.C in  case of the peak element is last one. :)\\nso your code T.C is O(N).iterating linearly and not reducing the search space. :)"
                    },
                    {
                        "username": "PentaMa",
                        "content": "This question is very badly written, as it allows you to just simply search for the max number of the array using binary search without actually breaking its rule, and the runtime is still O(log(n)) :)"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "For any given point the array, we can have below conditions:\\n1. If element at point is greater that neighbours, then return the element.\\n2. If element at point is greater than next element, then peak can occur on the left of this element.\\n3. If element at point is lesser than next element, then peak can occur on the right of this element.\\n4. If element at point is smaller than neighbours, then peak can occur on the right of this element."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n       int search(vector<int>nums,int start,int end)\\n    {\\n        if (start == end) return start;\\n\\n        int mid = (start+end)/2;\\n\\n        if(nums[mid] <nums[mid+1])\\n        {\\n            return search(nums,mid+1,end);\\n        }\\n        return search(nums,start ,mid);\\n    }\\n\\n\\n    int findPeakElement(vector<int>&nums)\\n    {\\n        int start =0;\\n        int end = nums.size()-1;\\n\\n\\n        return search(nums, start,end);\\n    }\\n\\n    \\n};"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "try to use MAX function "
                    },
                    {
                        "username": "rana_19",
                        "content": "For those who think how to apply Binary Search when the array is not sorted.\\n- Find mid element and check whether it is greater than its neighbors.\\n- If not, reduce search space (same as in binary search) and try recursively search in left side of mid.\\n- Then similarly perform above step right side of mid.\\n- Think about base cases.\\nSo finally this runs in O(logn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1808470,
                "content": [
                    {
                        "username": "sannyranjan",
                        "content": "class Solution {\\n    public int findPeakElement(int[] arr) {\\n        int start =0;\\n\\t\\tint end=arr.length-1;\\n\\t\\twhile (start<end) {\\n\\t\\tint mid =start +(end-start)/2;\\n\\t\\t\\t\\n\\t\\t\\tif(arr[mid]>arr[mid+1]) {\\n\\t\\t\\t\\tend = mid;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t   start=mid+1;\\n\\t\\t\\t}\\n\\n    }\\n\\t\\treturn start;\\n    }\\n}"
                    },
                    {
                        "username": "_aka5h",
                        "content": " `nums[i] != nums[i + 1] for all valid i`\\nWhy the most important observation for this problem given in constraint and not in problem statement itself?"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "so frustrating, I have done this question on dev C++ but same code is not working for leetcode. I tried the same test case on dev c++ and its working but on leetcode its showing runtime error.\\n\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000190 overflowed to 0x60200000018c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nCODE:\\nclass Solution {\\npublic:\\n    int findPeakElementHelper( vector<int> &nums ){\\n\\n        int n = nums.size();\\n        int low = 0;\\n        int high = n - 1;\\n\\n        while(low<=high){\\n\\n            int mid = (low + high)/2;\\n\\n            if( (nums[mid-1]<= nums[mid] || mid==0) && (nums[mid]>=nums[mid+1] || mid==n-1 ) )\\n                return mid;\\n\\n            else if( nums[mid-1] >= nums[mid] && mid!=0 )\\n                high = mid - 1;\\n            \\n            else if( nums[mid]<= nums[mid+1] && mid!= n-1 )\\n                low = mid + 1;\\n        }\\n\\n        return -1;\\n\\n    }\\n\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n\\n        return findPeakElementHelper(nums);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "infantsanthosh1995",
                        "content": "Will this come under o(logn) time complexity ??? Please anyone confirm\n\nclass Solution:\n    def findPeakElement(self, nums) :\n        for i in range(1,len(nums)-1):\n            if nums[i]>nums[i-1] and nums[i]>nums[i+1]:\n                return i\n        if len(nums)==1:\n            return 0\n        return nums.index(max(nums))\n"
                    },
                    {
                        "username": "pawanChandra999999",
                        "content": "I think at the worst case it is O(N) T.C in  case of the peak element is last one. :)\\nso your code T.C is O(N).iterating linearly and not reducing the search space. :)"
                    },
                    {
                        "username": "PentaMa",
                        "content": "This question is very badly written, as it allows you to just simply search for the max number of the array using binary search without actually breaking its rule, and the runtime is still O(log(n)) :)"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "For any given point the array, we can have below conditions:\\n1. If element at point is greater that neighbours, then return the element.\\n2. If element at point is greater than next element, then peak can occur on the left of this element.\\n3. If element at point is lesser than next element, then peak can occur on the right of this element.\\n4. If element at point is smaller than neighbours, then peak can occur on the right of this element."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n       int search(vector<int>nums,int start,int end)\\n    {\\n        if (start == end) return start;\\n\\n        int mid = (start+end)/2;\\n\\n        if(nums[mid] <nums[mid+1])\\n        {\\n            return search(nums,mid+1,end);\\n        }\\n        return search(nums,start ,mid);\\n    }\\n\\n\\n    int findPeakElement(vector<int>&nums)\\n    {\\n        int start =0;\\n        int end = nums.size()-1;\\n\\n\\n        return search(nums, start,end);\\n    }\\n\\n    \\n};"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "try to use MAX function "
                    },
                    {
                        "username": "rana_19",
                        "content": "For those who think how to apply Binary Search when the array is not sorted.\\n- Find mid element and check whether it is greater than its neighbors.\\n- If not, reduce search space (same as in binary search) and try recursively search in left side of mid.\\n- Then similarly perform above step right side of mid.\\n- Think about base cases.\\nSo finally this runs in O(logn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1807318,
                "content": [
                    {
                        "username": "sannyranjan",
                        "content": "class Solution {\\n    public int findPeakElement(int[] arr) {\\n        int start =0;\\n\\t\\tint end=arr.length-1;\\n\\t\\twhile (start<end) {\\n\\t\\tint mid =start +(end-start)/2;\\n\\t\\t\\t\\n\\t\\t\\tif(arr[mid]>arr[mid+1]) {\\n\\t\\t\\t\\tend = mid;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t   start=mid+1;\\n\\t\\t\\t}\\n\\n    }\\n\\t\\treturn start;\\n    }\\n}"
                    },
                    {
                        "username": "_aka5h",
                        "content": " `nums[i] != nums[i + 1] for all valid i`\\nWhy the most important observation for this problem given in constraint and not in problem statement itself?"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "so frustrating, I have done this question on dev C++ but same code is not working for leetcode. I tried the same test case on dev c++ and its working but on leetcode its showing runtime error.\\n\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000190 overflowed to 0x60200000018c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nCODE:\\nclass Solution {\\npublic:\\n    int findPeakElementHelper( vector<int> &nums ){\\n\\n        int n = nums.size();\\n        int low = 0;\\n        int high = n - 1;\\n\\n        while(low<=high){\\n\\n            int mid = (low + high)/2;\\n\\n            if( (nums[mid-1]<= nums[mid] || mid==0) && (nums[mid]>=nums[mid+1] || mid==n-1 ) )\\n                return mid;\\n\\n            else if( nums[mid-1] >= nums[mid] && mid!=0 )\\n                high = mid - 1;\\n            \\n            else if( nums[mid]<= nums[mid+1] && mid!= n-1 )\\n                low = mid + 1;\\n        }\\n\\n        return -1;\\n\\n    }\\n\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n\\n        return findPeakElementHelper(nums);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "infantsanthosh1995",
                        "content": "Will this come under o(logn) time complexity ??? Please anyone confirm\n\nclass Solution:\n    def findPeakElement(self, nums) :\n        for i in range(1,len(nums)-1):\n            if nums[i]>nums[i-1] and nums[i]>nums[i+1]:\n                return i\n        if len(nums)==1:\n            return 0\n        return nums.index(max(nums))\n"
                    },
                    {
                        "username": "pawanChandra999999",
                        "content": "I think at the worst case it is O(N) T.C in  case of the peak element is last one. :)\\nso your code T.C is O(N).iterating linearly and not reducing the search space. :)"
                    },
                    {
                        "username": "PentaMa",
                        "content": "This question is very badly written, as it allows you to just simply search for the max number of the array using binary search without actually breaking its rule, and the runtime is still O(log(n)) :)"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "For any given point the array, we can have below conditions:\\n1. If element at point is greater that neighbours, then return the element.\\n2. If element at point is greater than next element, then peak can occur on the left of this element.\\n3. If element at point is lesser than next element, then peak can occur on the right of this element.\\n4. If element at point is smaller than neighbours, then peak can occur on the right of this element."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n       int search(vector<int>nums,int start,int end)\\n    {\\n        if (start == end) return start;\\n\\n        int mid = (start+end)/2;\\n\\n        if(nums[mid] <nums[mid+1])\\n        {\\n            return search(nums,mid+1,end);\\n        }\\n        return search(nums,start ,mid);\\n    }\\n\\n\\n    int findPeakElement(vector<int>&nums)\\n    {\\n        int start =0;\\n        int end = nums.size()-1;\\n\\n\\n        return search(nums, start,end);\\n    }\\n\\n    \\n};"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "try to use MAX function "
                    },
                    {
                        "username": "rana_19",
                        "content": "For those who think how to apply Binary Search when the array is not sorted.\\n- Find mid element and check whether it is greater than its neighbors.\\n- If not, reduce search space (same as in binary search) and try recursively search in left side of mid.\\n- Then similarly perform above step right side of mid.\\n- Think about base cases.\\nSo finally this runs in O(logn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1806943,
                "content": [
                    {
                        "username": "sannyranjan",
                        "content": "class Solution {\\n    public int findPeakElement(int[] arr) {\\n        int start =0;\\n\\t\\tint end=arr.length-1;\\n\\t\\twhile (start<end) {\\n\\t\\tint mid =start +(end-start)/2;\\n\\t\\t\\t\\n\\t\\t\\tif(arr[mid]>arr[mid+1]) {\\n\\t\\t\\t\\tend = mid;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t   start=mid+1;\\n\\t\\t\\t}\\n\\n    }\\n\\t\\treturn start;\\n    }\\n}"
                    },
                    {
                        "username": "_aka5h",
                        "content": " `nums[i] != nums[i + 1] for all valid i`\\nWhy the most important observation for this problem given in constraint and not in problem statement itself?"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "so frustrating, I have done this question on dev C++ but same code is not working for leetcode. I tried the same test case on dev c++ and its working but on leetcode its showing runtime error.\\n\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000190 overflowed to 0x60200000018c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nCODE:\\nclass Solution {\\npublic:\\n    int findPeakElementHelper( vector<int> &nums ){\\n\\n        int n = nums.size();\\n        int low = 0;\\n        int high = n - 1;\\n\\n        while(low<=high){\\n\\n            int mid = (low + high)/2;\\n\\n            if( (nums[mid-1]<= nums[mid] || mid==0) && (nums[mid]>=nums[mid+1] || mid==n-1 ) )\\n                return mid;\\n\\n            else if( nums[mid-1] >= nums[mid] && mid!=0 )\\n                high = mid - 1;\\n            \\n            else if( nums[mid]<= nums[mid+1] && mid!= n-1 )\\n                low = mid + 1;\\n        }\\n\\n        return -1;\\n\\n    }\\n\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n\\n        return findPeakElementHelper(nums);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "infantsanthosh1995",
                        "content": "Will this come under o(logn) time complexity ??? Please anyone confirm\n\nclass Solution:\n    def findPeakElement(self, nums) :\n        for i in range(1,len(nums)-1):\n            if nums[i]>nums[i-1] and nums[i]>nums[i+1]:\n                return i\n        if len(nums)==1:\n            return 0\n        return nums.index(max(nums))\n"
                    },
                    {
                        "username": "pawanChandra999999",
                        "content": "I think at the worst case it is O(N) T.C in  case of the peak element is last one. :)\\nso your code T.C is O(N).iterating linearly and not reducing the search space. :)"
                    },
                    {
                        "username": "PentaMa",
                        "content": "This question is very badly written, as it allows you to just simply search for the max number of the array using binary search without actually breaking its rule, and the runtime is still O(log(n)) :)"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "For any given point the array, we can have below conditions:\\n1. If element at point is greater that neighbours, then return the element.\\n2. If element at point is greater than next element, then peak can occur on the left of this element.\\n3. If element at point is lesser than next element, then peak can occur on the right of this element.\\n4. If element at point is smaller than neighbours, then peak can occur on the right of this element."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n       int search(vector<int>nums,int start,int end)\\n    {\\n        if (start == end) return start;\\n\\n        int mid = (start+end)/2;\\n\\n        if(nums[mid] <nums[mid+1])\\n        {\\n            return search(nums,mid+1,end);\\n        }\\n        return search(nums,start ,mid);\\n    }\\n\\n\\n    int findPeakElement(vector<int>&nums)\\n    {\\n        int start =0;\\n        int end = nums.size()-1;\\n\\n\\n        return search(nums, start,end);\\n    }\\n\\n    \\n};"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "try to use MAX function "
                    },
                    {
                        "username": "rana_19",
                        "content": "For those who think how to apply Binary Search when the array is not sorted.\\n- Find mid element and check whether it is greater than its neighbors.\\n- If not, reduce search space (same as in binary search) and try recursively search in left side of mid.\\n- Then similarly perform above step right side of mid.\\n- Think about base cases.\\nSo finally this runs in O(logn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1803725,
                "content": [
                    {
                        "username": "sannyranjan",
                        "content": "class Solution {\\n    public int findPeakElement(int[] arr) {\\n        int start =0;\\n\\t\\tint end=arr.length-1;\\n\\t\\twhile (start<end) {\\n\\t\\tint mid =start +(end-start)/2;\\n\\t\\t\\t\\n\\t\\t\\tif(arr[mid]>arr[mid+1]) {\\n\\t\\t\\t\\tend = mid;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t   start=mid+1;\\n\\t\\t\\t}\\n\\n    }\\n\\t\\treturn start;\\n    }\\n}"
                    },
                    {
                        "username": "_aka5h",
                        "content": " `nums[i] != nums[i + 1] for all valid i`\\nWhy the most important observation for this problem given in constraint and not in problem statement itself?"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "so frustrating, I have done this question on dev C++ but same code is not working for leetcode. I tried the same test case on dev c++ and its working but on leetcode its showing runtime error.\\n\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000190 overflowed to 0x60200000018c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nCODE:\\nclass Solution {\\npublic:\\n    int findPeakElementHelper( vector<int> &nums ){\\n\\n        int n = nums.size();\\n        int low = 0;\\n        int high = n - 1;\\n\\n        while(low<=high){\\n\\n            int mid = (low + high)/2;\\n\\n            if( (nums[mid-1]<= nums[mid] || mid==0) && (nums[mid]>=nums[mid+1] || mid==n-1 ) )\\n                return mid;\\n\\n            else if( nums[mid-1] >= nums[mid] && mid!=0 )\\n                high = mid - 1;\\n            \\n            else if( nums[mid]<= nums[mid+1] && mid!= n-1 )\\n                low = mid + 1;\\n        }\\n\\n        return -1;\\n\\n    }\\n\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n\\n        return findPeakElementHelper(nums);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "infantsanthosh1995",
                        "content": "Will this come under o(logn) time complexity ??? Please anyone confirm\n\nclass Solution:\n    def findPeakElement(self, nums) :\n        for i in range(1,len(nums)-1):\n            if nums[i]>nums[i-1] and nums[i]>nums[i+1]:\n                return i\n        if len(nums)==1:\n            return 0\n        return nums.index(max(nums))\n"
                    },
                    {
                        "username": "pawanChandra999999",
                        "content": "I think at the worst case it is O(N) T.C in  case of the peak element is last one. :)\\nso your code T.C is O(N).iterating linearly and not reducing the search space. :)"
                    },
                    {
                        "username": "PentaMa",
                        "content": "This question is very badly written, as it allows you to just simply search for the max number of the array using binary search without actually breaking its rule, and the runtime is still O(log(n)) :)"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "For any given point the array, we can have below conditions:\\n1. If element at point is greater that neighbours, then return the element.\\n2. If element at point is greater than next element, then peak can occur on the left of this element.\\n3. If element at point is lesser than next element, then peak can occur on the right of this element.\\n4. If element at point is smaller than neighbours, then peak can occur on the right of this element."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n       int search(vector<int>nums,int start,int end)\\n    {\\n        if (start == end) return start;\\n\\n        int mid = (start+end)/2;\\n\\n        if(nums[mid] <nums[mid+1])\\n        {\\n            return search(nums,mid+1,end);\\n        }\\n        return search(nums,start ,mid);\\n    }\\n\\n\\n    int findPeakElement(vector<int>&nums)\\n    {\\n        int start =0;\\n        int end = nums.size()-1;\\n\\n\\n        return search(nums, start,end);\\n    }\\n\\n    \\n};"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "try to use MAX function "
                    },
                    {
                        "username": "rana_19",
                        "content": "For those who think how to apply Binary Search when the array is not sorted.\\n- Find mid element and check whether it is greater than its neighbors.\\n- If not, reduce search space (same as in binary search) and try recursively search in left side of mid.\\n- Then similarly perform above step right side of mid.\\n- Think about base cases.\\nSo finally this runs in O(logn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1798014,
                "content": [
                    {
                        "username": "sannyranjan",
                        "content": "class Solution {\\n    public int findPeakElement(int[] arr) {\\n        int start =0;\\n\\t\\tint end=arr.length-1;\\n\\t\\twhile (start<end) {\\n\\t\\tint mid =start +(end-start)/2;\\n\\t\\t\\t\\n\\t\\t\\tif(arr[mid]>arr[mid+1]) {\\n\\t\\t\\t\\tend = mid;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t   start=mid+1;\\n\\t\\t\\t}\\n\\n    }\\n\\t\\treturn start;\\n    }\\n}"
                    },
                    {
                        "username": "_aka5h",
                        "content": " `nums[i] != nums[i + 1] for all valid i`\\nWhy the most important observation for this problem given in constraint and not in problem statement itself?"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "so frustrating, I have done this question on dev C++ but same code is not working for leetcode. I tried the same test case on dev c++ and its working but on leetcode its showing runtime error.\\n\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000190 overflowed to 0x60200000018c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nCODE:\\nclass Solution {\\npublic:\\n    int findPeakElementHelper( vector<int> &nums ){\\n\\n        int n = nums.size();\\n        int low = 0;\\n        int high = n - 1;\\n\\n        while(low<=high){\\n\\n            int mid = (low + high)/2;\\n\\n            if( (nums[mid-1]<= nums[mid] || mid==0) && (nums[mid]>=nums[mid+1] || mid==n-1 ) )\\n                return mid;\\n\\n            else if( nums[mid-1] >= nums[mid] && mid!=0 )\\n                high = mid - 1;\\n            \\n            else if( nums[mid]<= nums[mid+1] && mid!= n-1 )\\n                low = mid + 1;\\n        }\\n\\n        return -1;\\n\\n    }\\n\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n\\n        return findPeakElementHelper(nums);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "infantsanthosh1995",
                        "content": "Will this come under o(logn) time complexity ??? Please anyone confirm\n\nclass Solution:\n    def findPeakElement(self, nums) :\n        for i in range(1,len(nums)-1):\n            if nums[i]>nums[i-1] and nums[i]>nums[i+1]:\n                return i\n        if len(nums)==1:\n            return 0\n        return nums.index(max(nums))\n"
                    },
                    {
                        "username": "pawanChandra999999",
                        "content": "I think at the worst case it is O(N) T.C in  case of the peak element is last one. :)\\nso your code T.C is O(N).iterating linearly and not reducing the search space. :)"
                    },
                    {
                        "username": "PentaMa",
                        "content": "This question is very badly written, as it allows you to just simply search for the max number of the array using binary search without actually breaking its rule, and the runtime is still O(log(n)) :)"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "For any given point the array, we can have below conditions:\\n1. If element at point is greater that neighbours, then return the element.\\n2. If element at point is greater than next element, then peak can occur on the left of this element.\\n3. If element at point is lesser than next element, then peak can occur on the right of this element.\\n4. If element at point is smaller than neighbours, then peak can occur on the right of this element."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n       int search(vector<int>nums,int start,int end)\\n    {\\n        if (start == end) return start;\\n\\n        int mid = (start+end)/2;\\n\\n        if(nums[mid] <nums[mid+1])\\n        {\\n            return search(nums,mid+1,end);\\n        }\\n        return search(nums,start ,mid);\\n    }\\n\\n\\n    int findPeakElement(vector<int>&nums)\\n    {\\n        int start =0;\\n        int end = nums.size()-1;\\n\\n\\n        return search(nums, start,end);\\n    }\\n\\n    \\n};"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "try to use MAX function "
                    },
                    {
                        "username": "rana_19",
                        "content": "For those who think how to apply Binary Search when the array is not sorted.\\n- Find mid element and check whether it is greater than its neighbors.\\n- If not, reduce search space (same as in binary search) and try recursively search in left side of mid.\\n- Then similarly perform above step right side of mid.\\n- Think about base cases.\\nSo finally this runs in O(logn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1795485,
                "content": [
                    {
                        "username": "sannyranjan",
                        "content": "class Solution {\\n    public int findPeakElement(int[] arr) {\\n        int start =0;\\n\\t\\tint end=arr.length-1;\\n\\t\\twhile (start<end) {\\n\\t\\tint mid =start +(end-start)/2;\\n\\t\\t\\t\\n\\t\\t\\tif(arr[mid]>arr[mid+1]) {\\n\\t\\t\\t\\tend = mid;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t   start=mid+1;\\n\\t\\t\\t}\\n\\n    }\\n\\t\\treturn start;\\n    }\\n}"
                    },
                    {
                        "username": "_aka5h",
                        "content": " `nums[i] != nums[i + 1] for all valid i`\\nWhy the most important observation for this problem given in constraint and not in problem statement itself?"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "so frustrating, I have done this question on dev C++ but same code is not working for leetcode. I tried the same test case on dev c++ and its working but on leetcode its showing runtime error.\\n\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000190 overflowed to 0x60200000018c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nCODE:\\nclass Solution {\\npublic:\\n    int findPeakElementHelper( vector<int> &nums ){\\n\\n        int n = nums.size();\\n        int low = 0;\\n        int high = n - 1;\\n\\n        while(low<=high){\\n\\n            int mid = (low + high)/2;\\n\\n            if( (nums[mid-1]<= nums[mid] || mid==0) && (nums[mid]>=nums[mid+1] || mid==n-1 ) )\\n                return mid;\\n\\n            else if( nums[mid-1] >= nums[mid] && mid!=0 )\\n                high = mid - 1;\\n            \\n            else if( nums[mid]<= nums[mid+1] && mid!= n-1 )\\n                low = mid + 1;\\n        }\\n\\n        return -1;\\n\\n    }\\n\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n\\n        return findPeakElementHelper(nums);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "infantsanthosh1995",
                        "content": "Will this come under o(logn) time complexity ??? Please anyone confirm\n\nclass Solution:\n    def findPeakElement(self, nums) :\n        for i in range(1,len(nums)-1):\n            if nums[i]>nums[i-1] and nums[i]>nums[i+1]:\n                return i\n        if len(nums)==1:\n            return 0\n        return nums.index(max(nums))\n"
                    },
                    {
                        "username": "pawanChandra999999",
                        "content": "I think at the worst case it is O(N) T.C in  case of the peak element is last one. :)\\nso your code T.C is O(N).iterating linearly and not reducing the search space. :)"
                    },
                    {
                        "username": "PentaMa",
                        "content": "This question is very badly written, as it allows you to just simply search for the max number of the array using binary search without actually breaking its rule, and the runtime is still O(log(n)) :)"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "For any given point the array, we can have below conditions:\\n1. If element at point is greater that neighbours, then return the element.\\n2. If element at point is greater than next element, then peak can occur on the left of this element.\\n3. If element at point is lesser than next element, then peak can occur on the right of this element.\\n4. If element at point is smaller than neighbours, then peak can occur on the right of this element."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n       int search(vector<int>nums,int start,int end)\\n    {\\n        if (start == end) return start;\\n\\n        int mid = (start+end)/2;\\n\\n        if(nums[mid] <nums[mid+1])\\n        {\\n            return search(nums,mid+1,end);\\n        }\\n        return search(nums,start ,mid);\\n    }\\n\\n\\n    int findPeakElement(vector<int>&nums)\\n    {\\n        int start =0;\\n        int end = nums.size()-1;\\n\\n\\n        return search(nums, start,end);\\n    }\\n\\n    \\n};"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "try to use MAX function "
                    },
                    {
                        "username": "rana_19",
                        "content": "For those who think how to apply Binary Search when the array is not sorted.\\n- Find mid element and check whether it is greater than its neighbors.\\n- If not, reduce search space (same as in binary search) and try recursively search in left side of mid.\\n- Then similarly perform above step right side of mid.\\n- Think about base cases.\\nSo finally this runs in O(logn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1793008,
                "content": [
                    {
                        "username": "sannyranjan",
                        "content": "class Solution {\\n    public int findPeakElement(int[] arr) {\\n        int start =0;\\n\\t\\tint end=arr.length-1;\\n\\t\\twhile (start<end) {\\n\\t\\tint mid =start +(end-start)/2;\\n\\t\\t\\t\\n\\t\\t\\tif(arr[mid]>arr[mid+1]) {\\n\\t\\t\\t\\tend = mid;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t   start=mid+1;\\n\\t\\t\\t}\\n\\n    }\\n\\t\\treturn start;\\n    }\\n}"
                    },
                    {
                        "username": "_aka5h",
                        "content": " `nums[i] != nums[i + 1] for all valid i`\\nWhy the most important observation for this problem given in constraint and not in problem statement itself?"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "so frustrating, I have done this question on dev C++ but same code is not working for leetcode. I tried the same test case on dev c++ and its working but on leetcode its showing runtime error.\\n\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000190 overflowed to 0x60200000018c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nCODE:\\nclass Solution {\\npublic:\\n    int findPeakElementHelper( vector<int> &nums ){\\n\\n        int n = nums.size();\\n        int low = 0;\\n        int high = n - 1;\\n\\n        while(low<=high){\\n\\n            int mid = (low + high)/2;\\n\\n            if( (nums[mid-1]<= nums[mid] || mid==0) && (nums[mid]>=nums[mid+1] || mid==n-1 ) )\\n                return mid;\\n\\n            else if( nums[mid-1] >= nums[mid] && mid!=0 )\\n                high = mid - 1;\\n            \\n            else if( nums[mid]<= nums[mid+1] && mid!= n-1 )\\n                low = mid + 1;\\n        }\\n\\n        return -1;\\n\\n    }\\n\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n\\n        return findPeakElementHelper(nums);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "infantsanthosh1995",
                        "content": "Will this come under o(logn) time complexity ??? Please anyone confirm\n\nclass Solution:\n    def findPeakElement(self, nums) :\n        for i in range(1,len(nums)-1):\n            if nums[i]>nums[i-1] and nums[i]>nums[i+1]:\n                return i\n        if len(nums)==1:\n            return 0\n        return nums.index(max(nums))\n"
                    },
                    {
                        "username": "pawanChandra999999",
                        "content": "I think at the worst case it is O(N) T.C in  case of the peak element is last one. :)\\nso your code T.C is O(N).iterating linearly and not reducing the search space. :)"
                    },
                    {
                        "username": "PentaMa",
                        "content": "This question is very badly written, as it allows you to just simply search for the max number of the array using binary search without actually breaking its rule, and the runtime is still O(log(n)) :)"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "For any given point the array, we can have below conditions:\\n1. If element at point is greater that neighbours, then return the element.\\n2. If element at point is greater than next element, then peak can occur on the left of this element.\\n3. If element at point is lesser than next element, then peak can occur on the right of this element.\\n4. If element at point is smaller than neighbours, then peak can occur on the right of this element."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n       int search(vector<int>nums,int start,int end)\\n    {\\n        if (start == end) return start;\\n\\n        int mid = (start+end)/2;\\n\\n        if(nums[mid] <nums[mid+1])\\n        {\\n            return search(nums,mid+1,end);\\n        }\\n        return search(nums,start ,mid);\\n    }\\n\\n\\n    int findPeakElement(vector<int>&nums)\\n    {\\n        int start =0;\\n        int end = nums.size()-1;\\n\\n\\n        return search(nums, start,end);\\n    }\\n\\n    \\n};"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "try to use MAX function "
                    },
                    {
                        "username": "rana_19",
                        "content": "For those who think how to apply Binary Search when the array is not sorted.\\n- Find mid element and check whether it is greater than its neighbors.\\n- If not, reduce search space (same as in binary search) and try recursively search in left side of mid.\\n- Then similarly perform above step right side of mid.\\n- Think about base cases.\\nSo finally this runs in O(logn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1784814,
                "content": [
                    {
                        "username": "sannyranjan",
                        "content": "class Solution {\\n    public int findPeakElement(int[] arr) {\\n        int start =0;\\n\\t\\tint end=arr.length-1;\\n\\t\\twhile (start<end) {\\n\\t\\tint mid =start +(end-start)/2;\\n\\t\\t\\t\\n\\t\\t\\tif(arr[mid]>arr[mid+1]) {\\n\\t\\t\\t\\tend = mid;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t   start=mid+1;\\n\\t\\t\\t}\\n\\n    }\\n\\t\\treturn start;\\n    }\\n}"
                    },
                    {
                        "username": "_aka5h",
                        "content": " `nums[i] != nums[i + 1] for all valid i`\\nWhy the most important observation for this problem given in constraint and not in problem statement itself?"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "so frustrating, I have done this question on dev C++ but same code is not working for leetcode. I tried the same test case on dev c++ and its working but on leetcode its showing runtime error.\\n\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000190 overflowed to 0x60200000018c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nCODE:\\nclass Solution {\\npublic:\\n    int findPeakElementHelper( vector<int> &nums ){\\n\\n        int n = nums.size();\\n        int low = 0;\\n        int high = n - 1;\\n\\n        while(low<=high){\\n\\n            int mid = (low + high)/2;\\n\\n            if( (nums[mid-1]<= nums[mid] || mid==0) && (nums[mid]>=nums[mid+1] || mid==n-1 ) )\\n                return mid;\\n\\n            else if( nums[mid-1] >= nums[mid] && mid!=0 )\\n                high = mid - 1;\\n            \\n            else if( nums[mid]<= nums[mid+1] && mid!= n-1 )\\n                low = mid + 1;\\n        }\\n\\n        return -1;\\n\\n    }\\n\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n\\n        return findPeakElementHelper(nums);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "infantsanthosh1995",
                        "content": "Will this come under o(logn) time complexity ??? Please anyone confirm\n\nclass Solution:\n    def findPeakElement(self, nums) :\n        for i in range(1,len(nums)-1):\n            if nums[i]>nums[i-1] and nums[i]>nums[i+1]:\n                return i\n        if len(nums)==1:\n            return 0\n        return nums.index(max(nums))\n"
                    },
                    {
                        "username": "pawanChandra999999",
                        "content": "I think at the worst case it is O(N) T.C in  case of the peak element is last one. :)\\nso your code T.C is O(N).iterating linearly and not reducing the search space. :)"
                    },
                    {
                        "username": "PentaMa",
                        "content": "This question is very badly written, as it allows you to just simply search for the max number of the array using binary search without actually breaking its rule, and the runtime is still O(log(n)) :)"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "For any given point the array, we can have below conditions:\\n1. If element at point is greater that neighbours, then return the element.\\n2. If element at point is greater than next element, then peak can occur on the left of this element.\\n3. If element at point is lesser than next element, then peak can occur on the right of this element.\\n4. If element at point is smaller than neighbours, then peak can occur on the right of this element."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n       int search(vector<int>nums,int start,int end)\\n    {\\n        if (start == end) return start;\\n\\n        int mid = (start+end)/2;\\n\\n        if(nums[mid] <nums[mid+1])\\n        {\\n            return search(nums,mid+1,end);\\n        }\\n        return search(nums,start ,mid);\\n    }\\n\\n\\n    int findPeakElement(vector<int>&nums)\\n    {\\n        int start =0;\\n        int end = nums.size()-1;\\n\\n\\n        return search(nums, start,end);\\n    }\\n\\n    \\n};"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "try to use MAX function "
                    },
                    {
                        "username": "rana_19",
                        "content": "For those who think how to apply Binary Search when the array is not sorted.\\n- Find mid element and check whether it is greater than its neighbors.\\n- If not, reduce search space (same as in binary search) and try recursively search in left side of mid.\\n- Then similarly perform above step right side of mid.\\n- Think about base cases.\\nSo finally this runs in O(logn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1756376,
                "content": [
                    {
                        "username": "sannyranjan",
                        "content": "class Solution {\\n    public int findPeakElement(int[] arr) {\\n        int start =0;\\n\\t\\tint end=arr.length-1;\\n\\t\\twhile (start<end) {\\n\\t\\tint mid =start +(end-start)/2;\\n\\t\\t\\t\\n\\t\\t\\tif(arr[mid]>arr[mid+1]) {\\n\\t\\t\\t\\tend = mid;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t   start=mid+1;\\n\\t\\t\\t}\\n\\n    }\\n\\t\\treturn start;\\n    }\\n}"
                    },
                    {
                        "username": "_aka5h",
                        "content": " `nums[i] != nums[i + 1] for all valid i`\\nWhy the most important observation for this problem given in constraint and not in problem statement itself?"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "so frustrating, I have done this question on dev C++ but same code is not working for leetcode. I tried the same test case on dev c++ and its working but on leetcode its showing runtime error.\\n\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000190 overflowed to 0x60200000018c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nCODE:\\nclass Solution {\\npublic:\\n    int findPeakElementHelper( vector<int> &nums ){\\n\\n        int n = nums.size();\\n        int low = 0;\\n        int high = n - 1;\\n\\n        while(low<=high){\\n\\n            int mid = (low + high)/2;\\n\\n            if( (nums[mid-1]<= nums[mid] || mid==0) && (nums[mid]>=nums[mid+1] || mid==n-1 ) )\\n                return mid;\\n\\n            else if( nums[mid-1] >= nums[mid] && mid!=0 )\\n                high = mid - 1;\\n            \\n            else if( nums[mid]<= nums[mid+1] && mid!= n-1 )\\n                low = mid + 1;\\n        }\\n\\n        return -1;\\n\\n    }\\n\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n\\n        return findPeakElementHelper(nums);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "infantsanthosh1995",
                        "content": "Will this come under o(logn) time complexity ??? Please anyone confirm\n\nclass Solution:\n    def findPeakElement(self, nums) :\n        for i in range(1,len(nums)-1):\n            if nums[i]>nums[i-1] and nums[i]>nums[i+1]:\n                return i\n        if len(nums)==1:\n            return 0\n        return nums.index(max(nums))\n"
                    },
                    {
                        "username": "pawanChandra999999",
                        "content": "I think at the worst case it is O(N) T.C in  case of the peak element is last one. :)\\nso your code T.C is O(N).iterating linearly and not reducing the search space. :)"
                    },
                    {
                        "username": "PentaMa",
                        "content": "This question is very badly written, as it allows you to just simply search for the max number of the array using binary search without actually breaking its rule, and the runtime is still O(log(n)) :)"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "For any given point the array, we can have below conditions:\\n1. If element at point is greater that neighbours, then return the element.\\n2. If element at point is greater than next element, then peak can occur on the left of this element.\\n3. If element at point is lesser than next element, then peak can occur on the right of this element.\\n4. If element at point is smaller than neighbours, then peak can occur on the right of this element."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n       int search(vector<int>nums,int start,int end)\\n    {\\n        if (start == end) return start;\\n\\n        int mid = (start+end)/2;\\n\\n        if(nums[mid] <nums[mid+1])\\n        {\\n            return search(nums,mid+1,end);\\n        }\\n        return search(nums,start ,mid);\\n    }\\n\\n\\n    int findPeakElement(vector<int>&nums)\\n    {\\n        int start =0;\\n        int end = nums.size()-1;\\n\\n\\n        return search(nums, start,end);\\n    }\\n\\n    \\n};"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "try to use MAX function "
                    },
                    {
                        "username": "rana_19",
                        "content": "For those who think how to apply Binary Search when the array is not sorted.\\n- Find mid element and check whether it is greater than its neighbors.\\n- If not, reduce search space (same as in binary search) and try recursively search in left side of mid.\\n- Then similarly perform above step right side of mid.\\n- Think about base cases.\\nSo finally this runs in O(logn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1748641,
                "content": [
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        vector<int> ans;\\n        int size;\\n        size= nums.size();\\n        int p;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans.push_back(nums[i]);\\n        }\\n        sort(ans.begin(),ans.end());\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(ans[size-1]==nums[i])\\n            {\\n                p=i;\\n                return p;\\n            }\\n        }\\n        return p;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "mycodetutorial",
                        "content": "Instead of doing binary search - why not do random probing across the length of the array and check adjacent values? "
                    },
                    {
                        "username": "Matv",
                        "content": "I was struggling with O(logN) solution until I find out the following condition\\n`nums[i] != nums[i + 1] for all valid i.`\\nI think it is crucial for this problem and should be stated in the problem description, rather than at the bottom of the page"
                    },
                    {
                        "username": "yash_gali",
                        "content": "Why are we using BS,because for BS the array has to be sorted?"
                    },
                    {
                        "username": "70pratyush",
                        "content": "int s=0;\\nint e=arr.length;\\nwhile(s<e){\\n     int mid=s/2+e/2;\\n      if(arr[mid]<arr[mid+1]) s=mid+1;\\n      else e=mid;\\n}\\nreturn s;\\n\\nthis code pass all the test cases but at submission it gives Index 1 out of bounds for length 1 runtime error after i fixed that it gave me Index 2 out of bounds for length 2 error can someone help"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "In your solution, you have take, s < e, therefore s = mid + 1 makes s = 1, which is further not changed and index is out of bound "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Shubham_Raina400",
                        "content": "https://github.com/ShubhamRaina371/-Find-Peak-Element/blob/main/New%20Text%20Document.txt"
                    },
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int s=0;\\n        int e=nums.size()-1;\\n        while(s<e)\\n        {\\n            int mid=(s+e)/2;\\n            if(nums[mid]>nums[mid+1])\\n            {\\n                e=mid;\\n            }\\n            else\\n            {\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "CPP Solution(Beats 99%):\\nint findPeakElement(vector<int>& nums) {\\n        int start=0;\\n        int end=nums.size()-1;\\n        int mid=start+(end-start)/2;\\n        if(nums.size()==2)\\n        {\\n            if(nums[0]>nums[1])\\n                     return  0;\\n            else\\n                     return 1;         \\n        }\\n        while(start<end)\\n        {\\n            if(mid==0)\\n            {\\n                if(nums[mid]>nums[mid+1])\\n                          return mid;\\n                else \\n                          return mid+1;          \\n            }\\n            else if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1])\\n                      return mid;\\n            else if(nums[mid]>nums[mid+1])\\n                      end=mid-1;\\n            else if(nums[mid]<nums[mid+1])\\n                      start=mid+1;\\n            mid=start+(end-start)/2;                              \\n        }\\n        return start;\\n    }"
                    },
                    {
                        "username": "utkarsh_morya",
                        "content": "class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int max = nums[0];\\n        for(int i =1; i < nums.length; i++){\\n            if(nums[i] > max){\\n                max = nums[i];\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nHow can I convert my return ans max into its index value ?"
                    }
                ]
            },
            {
                "id": 1741878,
                "content": [
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        vector<int> ans;\\n        int size;\\n        size= nums.size();\\n        int p;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans.push_back(nums[i]);\\n        }\\n        sort(ans.begin(),ans.end());\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(ans[size-1]==nums[i])\\n            {\\n                p=i;\\n                return p;\\n            }\\n        }\\n        return p;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "mycodetutorial",
                        "content": "Instead of doing binary search - why not do random probing across the length of the array and check adjacent values? "
                    },
                    {
                        "username": "Matv",
                        "content": "I was struggling with O(logN) solution until I find out the following condition\\n`nums[i] != nums[i + 1] for all valid i.`\\nI think it is crucial for this problem and should be stated in the problem description, rather than at the bottom of the page"
                    },
                    {
                        "username": "yash_gali",
                        "content": "Why are we using BS,because for BS the array has to be sorted?"
                    },
                    {
                        "username": "70pratyush",
                        "content": "int s=0;\\nint e=arr.length;\\nwhile(s<e){\\n     int mid=s/2+e/2;\\n      if(arr[mid]<arr[mid+1]) s=mid+1;\\n      else e=mid;\\n}\\nreturn s;\\n\\nthis code pass all the test cases but at submission it gives Index 1 out of bounds for length 1 runtime error after i fixed that it gave me Index 2 out of bounds for length 2 error can someone help"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "In your solution, you have take, s < e, therefore s = mid + 1 makes s = 1, which is further not changed and index is out of bound "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Shubham_Raina400",
                        "content": "https://github.com/ShubhamRaina371/-Find-Peak-Element/blob/main/New%20Text%20Document.txt"
                    },
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int s=0;\\n        int e=nums.size()-1;\\n        while(s<e)\\n        {\\n            int mid=(s+e)/2;\\n            if(nums[mid]>nums[mid+1])\\n            {\\n                e=mid;\\n            }\\n            else\\n            {\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "CPP Solution(Beats 99%):\\nint findPeakElement(vector<int>& nums) {\\n        int start=0;\\n        int end=nums.size()-1;\\n        int mid=start+(end-start)/2;\\n        if(nums.size()==2)\\n        {\\n            if(nums[0]>nums[1])\\n                     return  0;\\n            else\\n                     return 1;         \\n        }\\n        while(start<end)\\n        {\\n            if(mid==0)\\n            {\\n                if(nums[mid]>nums[mid+1])\\n                          return mid;\\n                else \\n                          return mid+1;          \\n            }\\n            else if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1])\\n                      return mid;\\n            else if(nums[mid]>nums[mid+1])\\n                      end=mid-1;\\n            else if(nums[mid]<nums[mid+1])\\n                      start=mid+1;\\n            mid=start+(end-start)/2;                              \\n        }\\n        return start;\\n    }"
                    },
                    {
                        "username": "utkarsh_morya",
                        "content": "class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int max = nums[0];\\n        for(int i =1; i < nums.length; i++){\\n            if(nums[i] > max){\\n                max = nums[i];\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nHow can I convert my return ans max into its index value ?"
                    }
                ]
            },
            {
                "id": 1740446,
                "content": [
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        vector<int> ans;\\n        int size;\\n        size= nums.size();\\n        int p;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans.push_back(nums[i]);\\n        }\\n        sort(ans.begin(),ans.end());\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(ans[size-1]==nums[i])\\n            {\\n                p=i;\\n                return p;\\n            }\\n        }\\n        return p;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "mycodetutorial",
                        "content": "Instead of doing binary search - why not do random probing across the length of the array and check adjacent values? "
                    },
                    {
                        "username": "Matv",
                        "content": "I was struggling with O(logN) solution until I find out the following condition\\n`nums[i] != nums[i + 1] for all valid i.`\\nI think it is crucial for this problem and should be stated in the problem description, rather than at the bottom of the page"
                    },
                    {
                        "username": "yash_gali",
                        "content": "Why are we using BS,because for BS the array has to be sorted?"
                    },
                    {
                        "username": "70pratyush",
                        "content": "int s=0;\\nint e=arr.length;\\nwhile(s<e){\\n     int mid=s/2+e/2;\\n      if(arr[mid]<arr[mid+1]) s=mid+1;\\n      else e=mid;\\n}\\nreturn s;\\n\\nthis code pass all the test cases but at submission it gives Index 1 out of bounds for length 1 runtime error after i fixed that it gave me Index 2 out of bounds for length 2 error can someone help"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "In your solution, you have take, s < e, therefore s = mid + 1 makes s = 1, which is further not changed and index is out of bound "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Shubham_Raina400",
                        "content": "https://github.com/ShubhamRaina371/-Find-Peak-Element/blob/main/New%20Text%20Document.txt"
                    },
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int s=0;\\n        int e=nums.size()-1;\\n        while(s<e)\\n        {\\n            int mid=(s+e)/2;\\n            if(nums[mid]>nums[mid+1])\\n            {\\n                e=mid;\\n            }\\n            else\\n            {\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "CPP Solution(Beats 99%):\\nint findPeakElement(vector<int>& nums) {\\n        int start=0;\\n        int end=nums.size()-1;\\n        int mid=start+(end-start)/2;\\n        if(nums.size()==2)\\n        {\\n            if(nums[0]>nums[1])\\n                     return  0;\\n            else\\n                     return 1;         \\n        }\\n        while(start<end)\\n        {\\n            if(mid==0)\\n            {\\n                if(nums[mid]>nums[mid+1])\\n                          return mid;\\n                else \\n                          return mid+1;          \\n            }\\n            else if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1])\\n                      return mid;\\n            else if(nums[mid]>nums[mid+1])\\n                      end=mid-1;\\n            else if(nums[mid]<nums[mid+1])\\n                      start=mid+1;\\n            mid=start+(end-start)/2;                              \\n        }\\n        return start;\\n    }"
                    },
                    {
                        "username": "utkarsh_morya",
                        "content": "class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int max = nums[0];\\n        for(int i =1; i < nums.length; i++){\\n            if(nums[i] > max){\\n                max = nums[i];\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nHow can I convert my return ans max into its index value ?"
                    }
                ]
            },
            {
                "id": 1735078,
                "content": [
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        vector<int> ans;\\n        int size;\\n        size= nums.size();\\n        int p;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans.push_back(nums[i]);\\n        }\\n        sort(ans.begin(),ans.end());\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(ans[size-1]==nums[i])\\n            {\\n                p=i;\\n                return p;\\n            }\\n        }\\n        return p;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "mycodetutorial",
                        "content": "Instead of doing binary search - why not do random probing across the length of the array and check adjacent values? "
                    },
                    {
                        "username": "Matv",
                        "content": "I was struggling with O(logN) solution until I find out the following condition\\n`nums[i] != nums[i + 1] for all valid i.`\\nI think it is crucial for this problem and should be stated in the problem description, rather than at the bottom of the page"
                    },
                    {
                        "username": "yash_gali",
                        "content": "Why are we using BS,because for BS the array has to be sorted?"
                    },
                    {
                        "username": "70pratyush",
                        "content": "int s=0;\\nint e=arr.length;\\nwhile(s<e){\\n     int mid=s/2+e/2;\\n      if(arr[mid]<arr[mid+1]) s=mid+1;\\n      else e=mid;\\n}\\nreturn s;\\n\\nthis code pass all the test cases but at submission it gives Index 1 out of bounds for length 1 runtime error after i fixed that it gave me Index 2 out of bounds for length 2 error can someone help"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "In your solution, you have take, s < e, therefore s = mid + 1 makes s = 1, which is further not changed and index is out of bound "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Shubham_Raina400",
                        "content": "https://github.com/ShubhamRaina371/-Find-Peak-Element/blob/main/New%20Text%20Document.txt"
                    },
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int s=0;\\n        int e=nums.size()-1;\\n        while(s<e)\\n        {\\n            int mid=(s+e)/2;\\n            if(nums[mid]>nums[mid+1])\\n            {\\n                e=mid;\\n            }\\n            else\\n            {\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "CPP Solution(Beats 99%):\\nint findPeakElement(vector<int>& nums) {\\n        int start=0;\\n        int end=nums.size()-1;\\n        int mid=start+(end-start)/2;\\n        if(nums.size()==2)\\n        {\\n            if(nums[0]>nums[1])\\n                     return  0;\\n            else\\n                     return 1;         \\n        }\\n        while(start<end)\\n        {\\n            if(mid==0)\\n            {\\n                if(nums[mid]>nums[mid+1])\\n                          return mid;\\n                else \\n                          return mid+1;          \\n            }\\n            else if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1])\\n                      return mid;\\n            else if(nums[mid]>nums[mid+1])\\n                      end=mid-1;\\n            else if(nums[mid]<nums[mid+1])\\n                      start=mid+1;\\n            mid=start+(end-start)/2;                              \\n        }\\n        return start;\\n    }"
                    },
                    {
                        "username": "utkarsh_morya",
                        "content": "class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int max = nums[0];\\n        for(int i =1; i < nums.length; i++){\\n            if(nums[i] > max){\\n                max = nums[i];\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nHow can I convert my return ans max into its index value ?"
                    }
                ]
            },
            {
                "id": 1734341,
                "content": [
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        vector<int> ans;\\n        int size;\\n        size= nums.size();\\n        int p;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans.push_back(nums[i]);\\n        }\\n        sort(ans.begin(),ans.end());\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(ans[size-1]==nums[i])\\n            {\\n                p=i;\\n                return p;\\n            }\\n        }\\n        return p;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "mycodetutorial",
                        "content": "Instead of doing binary search - why not do random probing across the length of the array and check adjacent values? "
                    },
                    {
                        "username": "Matv",
                        "content": "I was struggling with O(logN) solution until I find out the following condition\\n`nums[i] != nums[i + 1] for all valid i.`\\nI think it is crucial for this problem and should be stated in the problem description, rather than at the bottom of the page"
                    },
                    {
                        "username": "yash_gali",
                        "content": "Why are we using BS,because for BS the array has to be sorted?"
                    },
                    {
                        "username": "70pratyush",
                        "content": "int s=0;\\nint e=arr.length;\\nwhile(s<e){\\n     int mid=s/2+e/2;\\n      if(arr[mid]<arr[mid+1]) s=mid+1;\\n      else e=mid;\\n}\\nreturn s;\\n\\nthis code pass all the test cases but at submission it gives Index 1 out of bounds for length 1 runtime error after i fixed that it gave me Index 2 out of bounds for length 2 error can someone help"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "In your solution, you have take, s < e, therefore s = mid + 1 makes s = 1, which is further not changed and index is out of bound "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Shubham_Raina400",
                        "content": "https://github.com/ShubhamRaina371/-Find-Peak-Element/blob/main/New%20Text%20Document.txt"
                    },
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int s=0;\\n        int e=nums.size()-1;\\n        while(s<e)\\n        {\\n            int mid=(s+e)/2;\\n            if(nums[mid]>nums[mid+1])\\n            {\\n                e=mid;\\n            }\\n            else\\n            {\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "CPP Solution(Beats 99%):\\nint findPeakElement(vector<int>& nums) {\\n        int start=0;\\n        int end=nums.size()-1;\\n        int mid=start+(end-start)/2;\\n        if(nums.size()==2)\\n        {\\n            if(nums[0]>nums[1])\\n                     return  0;\\n            else\\n                     return 1;         \\n        }\\n        while(start<end)\\n        {\\n            if(mid==0)\\n            {\\n                if(nums[mid]>nums[mid+1])\\n                          return mid;\\n                else \\n                          return mid+1;          \\n            }\\n            else if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1])\\n                      return mid;\\n            else if(nums[mid]>nums[mid+1])\\n                      end=mid-1;\\n            else if(nums[mid]<nums[mid+1])\\n                      start=mid+1;\\n            mid=start+(end-start)/2;                              \\n        }\\n        return start;\\n    }"
                    },
                    {
                        "username": "utkarsh_morya",
                        "content": "class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int max = nums[0];\\n        for(int i =1; i < nums.length; i++){\\n            if(nums[i] > max){\\n                max = nums[i];\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nHow can I convert my return ans max into its index value ?"
                    }
                ]
            },
            {
                "id": 1733550,
                "content": [
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        vector<int> ans;\\n        int size;\\n        size= nums.size();\\n        int p;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans.push_back(nums[i]);\\n        }\\n        sort(ans.begin(),ans.end());\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(ans[size-1]==nums[i])\\n            {\\n                p=i;\\n                return p;\\n            }\\n        }\\n        return p;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "mycodetutorial",
                        "content": "Instead of doing binary search - why not do random probing across the length of the array and check adjacent values? "
                    },
                    {
                        "username": "Matv",
                        "content": "I was struggling with O(logN) solution until I find out the following condition\\n`nums[i] != nums[i + 1] for all valid i.`\\nI think it is crucial for this problem and should be stated in the problem description, rather than at the bottom of the page"
                    },
                    {
                        "username": "yash_gali",
                        "content": "Why are we using BS,because for BS the array has to be sorted?"
                    },
                    {
                        "username": "70pratyush",
                        "content": "int s=0;\\nint e=arr.length;\\nwhile(s<e){\\n     int mid=s/2+e/2;\\n      if(arr[mid]<arr[mid+1]) s=mid+1;\\n      else e=mid;\\n}\\nreturn s;\\n\\nthis code pass all the test cases but at submission it gives Index 1 out of bounds for length 1 runtime error after i fixed that it gave me Index 2 out of bounds for length 2 error can someone help"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "In your solution, you have take, s < e, therefore s = mid + 1 makes s = 1, which is further not changed and index is out of bound "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Shubham_Raina400",
                        "content": "https://github.com/ShubhamRaina371/-Find-Peak-Element/blob/main/New%20Text%20Document.txt"
                    },
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int s=0;\\n        int e=nums.size()-1;\\n        while(s<e)\\n        {\\n            int mid=(s+e)/2;\\n            if(nums[mid]>nums[mid+1])\\n            {\\n                e=mid;\\n            }\\n            else\\n            {\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "CPP Solution(Beats 99%):\\nint findPeakElement(vector<int>& nums) {\\n        int start=0;\\n        int end=nums.size()-1;\\n        int mid=start+(end-start)/2;\\n        if(nums.size()==2)\\n        {\\n            if(nums[0]>nums[1])\\n                     return  0;\\n            else\\n                     return 1;         \\n        }\\n        while(start<end)\\n        {\\n            if(mid==0)\\n            {\\n                if(nums[mid]>nums[mid+1])\\n                          return mid;\\n                else \\n                          return mid+1;          \\n            }\\n            else if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1])\\n                      return mid;\\n            else if(nums[mid]>nums[mid+1])\\n                      end=mid-1;\\n            else if(nums[mid]<nums[mid+1])\\n                      start=mid+1;\\n            mid=start+(end-start)/2;                              \\n        }\\n        return start;\\n    }"
                    },
                    {
                        "username": "utkarsh_morya",
                        "content": "class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int max = nums[0];\\n        for(int i =1; i < nums.length; i++){\\n            if(nums[i] > max){\\n                max = nums[i];\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nHow can I convert my return ans max into its index value ?"
                    }
                ]
            },
            {
                "id": 1729256,
                "content": [
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        vector<int> ans;\\n        int size;\\n        size= nums.size();\\n        int p;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans.push_back(nums[i]);\\n        }\\n        sort(ans.begin(),ans.end());\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(ans[size-1]==nums[i])\\n            {\\n                p=i;\\n                return p;\\n            }\\n        }\\n        return p;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "mycodetutorial",
                        "content": "Instead of doing binary search - why not do random probing across the length of the array and check adjacent values? "
                    },
                    {
                        "username": "Matv",
                        "content": "I was struggling with O(logN) solution until I find out the following condition\\n`nums[i] != nums[i + 1] for all valid i.`\\nI think it is crucial for this problem and should be stated in the problem description, rather than at the bottom of the page"
                    },
                    {
                        "username": "yash_gali",
                        "content": "Why are we using BS,because for BS the array has to be sorted?"
                    },
                    {
                        "username": "70pratyush",
                        "content": "int s=0;\\nint e=arr.length;\\nwhile(s<e){\\n     int mid=s/2+e/2;\\n      if(arr[mid]<arr[mid+1]) s=mid+1;\\n      else e=mid;\\n}\\nreturn s;\\n\\nthis code pass all the test cases but at submission it gives Index 1 out of bounds for length 1 runtime error after i fixed that it gave me Index 2 out of bounds for length 2 error can someone help"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "In your solution, you have take, s < e, therefore s = mid + 1 makes s = 1, which is further not changed and index is out of bound "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Shubham_Raina400",
                        "content": "https://github.com/ShubhamRaina371/-Find-Peak-Element/blob/main/New%20Text%20Document.txt"
                    },
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int s=0;\\n        int e=nums.size()-1;\\n        while(s<e)\\n        {\\n            int mid=(s+e)/2;\\n            if(nums[mid]>nums[mid+1])\\n            {\\n                e=mid;\\n            }\\n            else\\n            {\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "CPP Solution(Beats 99%):\\nint findPeakElement(vector<int>& nums) {\\n        int start=0;\\n        int end=nums.size()-1;\\n        int mid=start+(end-start)/2;\\n        if(nums.size()==2)\\n        {\\n            if(nums[0]>nums[1])\\n                     return  0;\\n            else\\n                     return 1;         \\n        }\\n        while(start<end)\\n        {\\n            if(mid==0)\\n            {\\n                if(nums[mid]>nums[mid+1])\\n                          return mid;\\n                else \\n                          return mid+1;          \\n            }\\n            else if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1])\\n                      return mid;\\n            else if(nums[mid]>nums[mid+1])\\n                      end=mid-1;\\n            else if(nums[mid]<nums[mid+1])\\n                      start=mid+1;\\n            mid=start+(end-start)/2;                              \\n        }\\n        return start;\\n    }"
                    },
                    {
                        "username": "utkarsh_morya",
                        "content": "class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int max = nums[0];\\n        for(int i =1; i < nums.length; i++){\\n            if(nums[i] > max){\\n                max = nums[i];\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nHow can I convert my return ans max into its index value ?"
                    }
                ]
            },
            {
                "id": 1726489,
                "content": [
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        vector<int> ans;\\n        int size;\\n        size= nums.size();\\n        int p;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans.push_back(nums[i]);\\n        }\\n        sort(ans.begin(),ans.end());\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(ans[size-1]==nums[i])\\n            {\\n                p=i;\\n                return p;\\n            }\\n        }\\n        return p;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "mycodetutorial",
                        "content": "Instead of doing binary search - why not do random probing across the length of the array and check adjacent values? "
                    },
                    {
                        "username": "Matv",
                        "content": "I was struggling with O(logN) solution until I find out the following condition\\n`nums[i] != nums[i + 1] for all valid i.`\\nI think it is crucial for this problem and should be stated in the problem description, rather than at the bottom of the page"
                    },
                    {
                        "username": "yash_gali",
                        "content": "Why are we using BS,because for BS the array has to be sorted?"
                    },
                    {
                        "username": "70pratyush",
                        "content": "int s=0;\\nint e=arr.length;\\nwhile(s<e){\\n     int mid=s/2+e/2;\\n      if(arr[mid]<arr[mid+1]) s=mid+1;\\n      else e=mid;\\n}\\nreturn s;\\n\\nthis code pass all the test cases but at submission it gives Index 1 out of bounds for length 1 runtime error after i fixed that it gave me Index 2 out of bounds for length 2 error can someone help"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "In your solution, you have take, s < e, therefore s = mid + 1 makes s = 1, which is further not changed and index is out of bound "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Shubham_Raina400",
                        "content": "https://github.com/ShubhamRaina371/-Find-Peak-Element/blob/main/New%20Text%20Document.txt"
                    },
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int s=0;\\n        int e=nums.size()-1;\\n        while(s<e)\\n        {\\n            int mid=(s+e)/2;\\n            if(nums[mid]>nums[mid+1])\\n            {\\n                e=mid;\\n            }\\n            else\\n            {\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "CPP Solution(Beats 99%):\\nint findPeakElement(vector<int>& nums) {\\n        int start=0;\\n        int end=nums.size()-1;\\n        int mid=start+(end-start)/2;\\n        if(nums.size()==2)\\n        {\\n            if(nums[0]>nums[1])\\n                     return  0;\\n            else\\n                     return 1;         \\n        }\\n        while(start<end)\\n        {\\n            if(mid==0)\\n            {\\n                if(nums[mid]>nums[mid+1])\\n                          return mid;\\n                else \\n                          return mid+1;          \\n            }\\n            else if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1])\\n                      return mid;\\n            else if(nums[mid]>nums[mid+1])\\n                      end=mid-1;\\n            else if(nums[mid]<nums[mid+1])\\n                      start=mid+1;\\n            mid=start+(end-start)/2;                              \\n        }\\n        return start;\\n    }"
                    },
                    {
                        "username": "utkarsh_morya",
                        "content": "class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int max = nums[0];\\n        for(int i =1; i < nums.length; i++){\\n            if(nums[i] > max){\\n                max = nums[i];\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nHow can I convert my return ans max into its index value ?"
                    }
                ]
            },
            {
                "id": 1698768,
                "content": [
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        vector<int> ans;\\n        int size;\\n        size= nums.size();\\n        int p;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans.push_back(nums[i]);\\n        }\\n        sort(ans.begin(),ans.end());\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(ans[size-1]==nums[i])\\n            {\\n                p=i;\\n                return p;\\n            }\\n        }\\n        return p;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "mycodetutorial",
                        "content": "Instead of doing binary search - why not do random probing across the length of the array and check adjacent values? "
                    },
                    {
                        "username": "Matv",
                        "content": "I was struggling with O(logN) solution until I find out the following condition\\n`nums[i] != nums[i + 1] for all valid i.`\\nI think it is crucial for this problem and should be stated in the problem description, rather than at the bottom of the page"
                    },
                    {
                        "username": "yash_gali",
                        "content": "Why are we using BS,because for BS the array has to be sorted?"
                    },
                    {
                        "username": "70pratyush",
                        "content": "int s=0;\\nint e=arr.length;\\nwhile(s<e){\\n     int mid=s/2+e/2;\\n      if(arr[mid]<arr[mid+1]) s=mid+1;\\n      else e=mid;\\n}\\nreturn s;\\n\\nthis code pass all the test cases but at submission it gives Index 1 out of bounds for length 1 runtime error after i fixed that it gave me Index 2 out of bounds for length 2 error can someone help"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "In your solution, you have take, s < e, therefore s = mid + 1 makes s = 1, which is further not changed and index is out of bound "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Shubham_Raina400",
                        "content": "https://github.com/ShubhamRaina371/-Find-Peak-Element/blob/main/New%20Text%20Document.txt"
                    },
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int s=0;\\n        int e=nums.size()-1;\\n        while(s<e)\\n        {\\n            int mid=(s+e)/2;\\n            if(nums[mid]>nums[mid+1])\\n            {\\n                e=mid;\\n            }\\n            else\\n            {\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "CPP Solution(Beats 99%):\\nint findPeakElement(vector<int>& nums) {\\n        int start=0;\\n        int end=nums.size()-1;\\n        int mid=start+(end-start)/2;\\n        if(nums.size()==2)\\n        {\\n            if(nums[0]>nums[1])\\n                     return  0;\\n            else\\n                     return 1;         \\n        }\\n        while(start<end)\\n        {\\n            if(mid==0)\\n            {\\n                if(nums[mid]>nums[mid+1])\\n                          return mid;\\n                else \\n                          return mid+1;          \\n            }\\n            else if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1])\\n                      return mid;\\n            else if(nums[mid]>nums[mid+1])\\n                      end=mid-1;\\n            else if(nums[mid]<nums[mid+1])\\n                      start=mid+1;\\n            mid=start+(end-start)/2;                              \\n        }\\n        return start;\\n    }"
                    },
                    {
                        "username": "utkarsh_morya",
                        "content": "class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int max = nums[0];\\n        for(int i =1; i < nums.length; i++){\\n            if(nums[i] > max){\\n                max = nums[i];\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nHow can I convert my return ans max into its index value ?"
                    }
                ]
            },
            {
                "id": 1691728,
                "content": [
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        vector<int> ans;\\n        int size;\\n        size= nums.size();\\n        int p;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans.push_back(nums[i]);\\n        }\\n        sort(ans.begin(),ans.end());\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(ans[size-1]==nums[i])\\n            {\\n                p=i;\\n                return p;\\n            }\\n        }\\n        return p;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "mycodetutorial",
                        "content": "Instead of doing binary search - why not do random probing across the length of the array and check adjacent values? "
                    },
                    {
                        "username": "Matv",
                        "content": "I was struggling with O(logN) solution until I find out the following condition\\n`nums[i] != nums[i + 1] for all valid i.`\\nI think it is crucial for this problem and should be stated in the problem description, rather than at the bottom of the page"
                    },
                    {
                        "username": "yash_gali",
                        "content": "Why are we using BS,because for BS the array has to be sorted?"
                    },
                    {
                        "username": "70pratyush",
                        "content": "int s=0;\\nint e=arr.length;\\nwhile(s<e){\\n     int mid=s/2+e/2;\\n      if(arr[mid]<arr[mid+1]) s=mid+1;\\n      else e=mid;\\n}\\nreturn s;\\n\\nthis code pass all the test cases but at submission it gives Index 1 out of bounds for length 1 runtime error after i fixed that it gave me Index 2 out of bounds for length 2 error can someone help"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "In your solution, you have take, s < e, therefore s = mid + 1 makes s = 1, which is further not changed and index is out of bound "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Shubham_Raina400",
                        "content": "https://github.com/ShubhamRaina371/-Find-Peak-Element/blob/main/New%20Text%20Document.txt"
                    },
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int s=0;\\n        int e=nums.size()-1;\\n        while(s<e)\\n        {\\n            int mid=(s+e)/2;\\n            if(nums[mid]>nums[mid+1])\\n            {\\n                e=mid;\\n            }\\n            else\\n            {\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "CPP Solution(Beats 99%):\\nint findPeakElement(vector<int>& nums) {\\n        int start=0;\\n        int end=nums.size()-1;\\n        int mid=start+(end-start)/2;\\n        if(nums.size()==2)\\n        {\\n            if(nums[0]>nums[1])\\n                     return  0;\\n            else\\n                     return 1;         \\n        }\\n        while(start<end)\\n        {\\n            if(mid==0)\\n            {\\n                if(nums[mid]>nums[mid+1])\\n                          return mid;\\n                else \\n                          return mid+1;          \\n            }\\n            else if(nums[mid]>nums[mid+1] && nums[mid]>nums[mid-1])\\n                      return mid;\\n            else if(nums[mid]>nums[mid+1])\\n                      end=mid-1;\\n            else if(nums[mid]<nums[mid+1])\\n                      start=mid+1;\\n            mid=start+(end-start)/2;                              \\n        }\\n        return start;\\n    }"
                    },
                    {
                        "username": "utkarsh_morya",
                        "content": "class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int max = nums[0];\\n        for(int i =1; i < nums.length; i++){\\n            if(nums[i] > max){\\n                max = nums[i];\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nHow can I convert my return ans max into its index value ?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Trips and Users",
        "question_content": "<p>Table: <code>Trips</code></p>\n\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| id          | int      |\n| client_id   | int      |\n| driver_id   | int      |\n| city_id     | int      |\n| status      | enum     |\n| request_at  | date     |     \n+-------------+----------+\nid is the primary key (column with unique values) for this table.\nThe table holds all taxi trips. Each trip has a unique id, while client_id and driver_id are foreign keys to the users_id at the Users table.\nStatus is an ENUM (category) type of (&#39;completed&#39;, &#39;cancelled_by_driver&#39;, &#39;cancelled_by_client&#39;).\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Users</code></p>\n\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| users_id    | int      |\n| banned      | enum     |\n| role        | enum     |\n+-------------+----------+\nusers_id is the primary key (column with unique values) for this table.\nThe table holds all users. Each user has a unique users_id, and role is an ENUM type of (&#39;client&#39;, &#39;driver&#39;, &#39;partner&#39;).\nbanned is an ENUM (category) type of (&#39;Yes&#39;, &#39;No&#39;).\n</pre>\n\n<p>&nbsp;</p>\n\n<p>The <strong>cancellation rate</strong> is computed by dividing the number of canceled (by client or driver) requests with unbanned users by the total number of requests with unbanned users on that day.</p>\n\n<p>Write a solution to find the <strong>cancellation rate</strong> of requests with unbanned users (<strong>both client and driver must not be banned</strong>) each day between <code>&quot;2013-10-01&quot;</code> and <code>&quot;2013-10-03&quot;</code>. Round <code>Cancellation Rate</code> to <strong>two decimal</strong> points.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nTrips table:\n+----+-----------+-----------+---------+---------------------+------------+\n| id | client_id | driver_id | city_id | status              | request_at |\n+----+-----------+-----------+---------+---------------------+------------+\n| 1  | 1         | 10        | 1       | completed           | 2013-10-01 |\n| 2  | 2         | 11        | 1       | cancelled_by_driver | 2013-10-01 |\n| 3  | 3         | 12        | 6       | completed           | 2013-10-01 |\n| 4  | 4         | 13        | 6       | cancelled_by_client | 2013-10-01 |\n| 5  | 1         | 10        | 1       | completed           | 2013-10-02 |\n| 6  | 2         | 11        | 6       | completed           | 2013-10-02 |\n| 7  | 3         | 12        | 6       | completed           | 2013-10-02 |\n| 8  | 2         | 12        | 12      | completed           | 2013-10-03 |\n| 9  | 3         | 10        | 12      | completed           | 2013-10-03 |\n| 10 | 4         | 13        | 12      | cancelled_by_driver | 2013-10-03 |\n+----+-----------+-----------+---------+---------------------+------------+\nUsers table:\n+----------+--------+--------+\n| users_id | banned | role   |\n+----------+--------+--------+\n| 1        | No     | client |\n| 2        | Yes    | client |\n| 3        | No     | client |\n| 4        | No     | client |\n| 10       | No     | driver |\n| 11       | No     | driver |\n| 12       | No     | driver |\n| 13       | No     | driver |\n+----------+--------+--------+\n<strong>Output:</strong> \n+------------+-------------------+\n| Day        | Cancellation Rate |\n+------------+-------------------+\n| 2013-10-01 | 0.33              |\n| 2013-10-02 | 0.00              |\n| 2013-10-03 | 0.50              |\n+------------+-------------------+\n<strong>Explanation:</strong> \nOn 2013-10-01:\n  - There were 4 requests in total, 2 of which were canceled.\n  - However, the request with Id=2 was made by a banned client (User_Id=2), so it is ignored in the calculation.\n  - Hence there are 3 unbanned requests in total, 1 of which was canceled.\n  - The Cancellation Rate is (1 / 3) = 0.33\nOn 2013-10-02:\n  - There were 3 requests in total, 0 of which were canceled.\n  - The request with Id=6 was made by a banned client, so it is ignored.\n  - Hence there are 2 unbanned requests in total, 0 of which were canceled.\n  - The Cancellation Rate is (0 / 2) = 0.00\nOn 2013-10-03:\n  - There were 3 requests in total, 1 of which was canceled.\n  - The request with Id=8 was made by a banned client, so it is ignored.\n  - Hence there are 2 unbanned request in total, 1 of which were canceled.\n  - The Cancellation Rate is (1 / 2) = 0.50\n</pre>\n",
        "solutions": [
            {
                "id": 69159,
                "title": "solution-without-join",
                "content": "    SELECT Request_at as Day,\\n           ROUND(COUNT(IF(Status != 'completed', TRUE, NULL)) / COUNT(*), 2) AS 'Cancellation Rate'\\n    FROM Trips\\n    WHERE (Request_at BETWEEN '2013-10-01' AND '2013-10-03')\\n          AND Client_id NOT IN (SELECT Users_Id FROM Users WHERE Banned = 'Yes')\\n    GROUP BY Request_at;",
                "solutionTags": [],
                "code": "    SELECT Request_at as Day,\\n           ROUND(COUNT(IF(Status != 'completed', TRUE, NULL)) / COUNT(*), 2) AS 'Cancellation Rate'\\n    FROM Trips\\n    WHERE (Request_at BETWEEN '2013-10-01' AND '2013-10-03')\\n          AND Client_id NOT IN (SELECT Users_Id FROM Users WHERE Banned = 'Yes')\\n    GROUP BY Request_at;",
                "codeTag": "Unknown"
            },
            {
                "id": 69151,
                "title": "sharing-my-solution",
                "content": "    select \\n    t.Request_at Day, \\n    round(sum(case when t.Status like 'cancelled_%' then 1 else 0 end)/count(*),2) Rate\\n    from Trips t \\n    inner join Users u \\n    on t.Client_Id = u.Users_Id and u.Banned='No'\\n    where t.Request_at between '2013-10-01' and '2013-10-03'\\n    group by t.Request_at",
                "solutionTags": [],
                "code": "    select \\n    t.Request_at Day, \\n    round(sum(case when t.Status like 'cancelled_%' then 1 else 0 end)/count(*),2) Rate\\n    from Trips t \\n    inner join Users u \\n    on t.Client_Id = u.Users_Id and u.Banned='No'\\n    where t.Request_at between '2013-10-01' and '2013-10-03'\\n    group by t.Request_at",
                "codeTag": "Unknown"
            },
            {
                "id": 144519,
                "title": "mysql-updated-solutions-both-explained-easy-and-simple",
                "content": "### Solution for the updated question\\n\\n```\\n-- Updated query when both \\'Client\\' and \\'Driver\\' should be unbanned\\n\\nSELECT  t.request_at AS \"Day\",\\n        ROUND(\\n            COUNT(CASE\\n                    WHEN t.status != \\'completed\\' THEN 1     -- numerator is total cancelled trips\\n                    ELSE NULL\\n                 END) / COUNT(id)                           -- denominator is all trips for that day\\n        , 2) AS \"Cancellation Rate\"\\nFROM    trips AS t\\nJOIN    users AS client                                     -- users table role-playing as client\\nON      t.client_id = client.users_id\\nAND     client.banned = \\'No\\'                                -- unbanned client\\nJOIN    users AS driver                                     -- users table role-playing as driver\\nON      driver.users_id = t.driver_id\\nAND     driver.banned = \\'No\\'                                -- unbanned driver\\nAND     t.request_at BETWEEN \\'2013-10-01\\' \\n                         AND \\'2013-10-03\\'\\nGROUP BY t.request_at;                                      -- per date calculation\\n```\\n\\n----\\n\\n### solution for the old question\\n----\\n\\nThe where condition checks for two things.\\n1. The current client is not \\'Banned\\'\\n2. Date is between the range\\n\\nThe second cluase (column) of SELECT statement is tricky. Let\\'s understand what each function is used for\\n* LOWER(column) to change the values to lowercase. This is because MySQL doesn\\'t have ILIKE function to have case-insensitive comparision\\n* LIKE for partial text matches\\n* CASE for counting only cancelled rides instead of all non-null values\\n* 1.000 to account for decimals after divisions\\n* COUNT(id) to get total trips for that day\\n* ROUND(value, 2) to round off the result to 2 decimal places **Do not confuse with TRUNCATE function**\\n* Rename the processed column to the expected one\\n\\n\\n```\\nSELECT      request_at AS \"Day\", \\n            ROUND(((SUM(CASE WHEN LOWER(Status) LIKE \"cancelled%\" THEN 1.000 ELSE 0 END)) / COUNT(id)), 2) AS \"Cancellation Rate\" \\nFROM        trips\\nWHERE       client_id NOT IN (SELECT users_id FROM users WHERE banned = \\'Yes\\')\\nAND         request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY    request_at;\\n```\\n\\n***This solution is faster than the above one***\\nWe are joining and hence each record doesn\\'t need to run an inner query to check for the banned status. If it did, it takes a lot of time repeating the same task over and over.\\n\\n```\\nSELECT      request_at AS \"Day\", \\n            ROUND(((SUM(CASE WHEN LOWER(Status) LIKE \"cancelled%\" THEN 1.000 ELSE 0 END)) / COUNT(id)), 2) AS \"Cancellation Rate\" \\nFROM        trips AS t\\nJOIN        users AS u\\nON          t.client_id = u.users_id\\nAND         u.banned =\\'No\\'\\nWHERE       request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY    request_at;\\n```",
                "solutionTags": [],
                "code": "```\\n-- Updated query when both \\'Client\\' and \\'Driver\\' should be unbanned\\n\\nSELECT  t.request_at AS \"Day\",\\n        ROUND(\\n            COUNT(CASE\\n                    WHEN t.status != \\'completed\\' THEN 1     -- numerator is total cancelled trips\\n                    ELSE NULL\\n                 END) / COUNT(id)                           -- denominator is all trips for that day\\n        , 2) AS \"Cancellation Rate\"\\nFROM    trips AS t\\nJOIN    users AS client                                     -- users table role-playing as client\\nON      t.client_id = client.users_id\\nAND     client.banned = \\'No\\'                                -- unbanned client\\nJOIN    users AS driver                                     -- users table role-playing as driver\\nON      driver.users_id = t.driver_id\\nAND     driver.banned = \\'No\\'                                -- unbanned driver\\nAND     t.request_at BETWEEN \\'2013-10-01\\' \\n                         AND \\'2013-10-03\\'\\nGROUP BY t.request_at;                                      -- per date calculation\\n```\n```\\nSELECT      request_at AS \"Day\", \\n            ROUND(((SUM(CASE WHEN LOWER(Status) LIKE \"cancelled%\" THEN 1.000 ELSE 0 END)) / COUNT(id)), 2) AS \"Cancellation Rate\" \\nFROM        trips\\nWHERE       client_id NOT IN (SELECT users_id FROM users WHERE banned = \\'Yes\\')\\nAND         request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY    request_at;\\n```\n```\\nSELECT      request_at AS \"Day\", \\n            ROUND(((SUM(CASE WHEN LOWER(Status) LIKE \"cancelled%\" THEN 1.000 ELSE 0 END)) / COUNT(id)), 2) AS \"Cancellation Rate\" \\nFROM        trips AS t\\nJOIN        users AS u\\nON          t.client_id = u.users_id\\nAND         u.banned =\\'No\\'\\nWHERE       request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY    request_at;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 180215,
                "title": "shortest-solution",
                "content": "```\\nSELECT Request_at as Day, ROUND(SUM(t.Status != \"completed\") / COUNT(*), 2) as \"Cancellation Rate\"\\n    FROM Trips t \\n    JOIN Users c ON t.Client_ID = c.Users_ID AND c.Banned = \"No\"\\n    JOIN Users d ON t.Driver_ID = d.Users_ID AND d.Banned = \"No\"\\n    WHERE Request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\n    GROUP BY Request_at;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Request_at as Day, ROUND(SUM(t.Status != \"completed\") / COUNT(*), 2) as \"Cancellation Rate\"\\n    FROM Trips t \\n    JOIN Users c ON t.Client_ID = c.Users_ID AND c.Banned = \"No\"\\n    JOIN Users d ON t.Driver_ID = d.Users_ID AND d.Banned = \"No\"\\n    WHERE Request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\n    GROUP BY Request_at;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2447598,
                "title": "easy-understandable-solution-in-sql",
                "content": "![image](https://assets.leetcode.com/users/images/9297bb97-9fe2-434a-b0f3-0dae9337a08a_1660889362.187591.png)\\n\\n```\\nselect \\n    request_at as \"Day\",\\n    round(\\n        (sum(case when status = \"cancelled_by_driver\" or status = \"cancelled_by_client\" then 1 else 0 end) / count(status)), 2\\n    ) as \"Cancellation Rate\"\\nfrom\\n    Trips\\nwhere \\n    client_id not in (select users_id from Users where role = \\'client\\' and banned =\\'Yes\\') \\nand \\n    driver_id not in (select users_id from Users where role = \\'driver\\' and banned =\\'Yes\\') \\nand \\n    request_at >= \"2013-10-01\" and request_at <= \"2013-10-03\"\\ngroup by \\n    request_at\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\n    request_at as \"Day\",\\n    round(\\n        (sum(case when status = \"cancelled_by_driver\" or status = \"cancelled_by_client\" then 1 else 0 end) / count(status)), 2\\n    ) as \"Cancellation Rate\"\\nfrom\\n    Trips\\nwhere \\n    client_id not in (select users_id from Users where role = \\'client\\' and banned =\\'Yes\\') \\nand \\n    driver_id not in (select users_id from Users where role = \\'driver\\' and banned =\\'Yes\\') \\nand \\n    request_at >= \"2013-10-01\" and request_at <= \"2013-10-03\"\\ngroup by \\n    request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2607018,
                "title": "simple-solution-no-cte-no-join",
                "content": "SELECT request_at Day, \\n    ROUND(SUM(IF(status = \\'cancelled_by_driver\\' OR status = \\'cancelled_by_client\\', 1,0)) / COUNT(*),2) AS \"Cancellation Rate\"\\nFROM Trips \\nWHERE client_id  NOT IN (SELECT users_id FROM Users WHERE banned = \"Yes\") AND \\n    driver_id NOT IN (SELECT users_id FROM Users WHERE banned = \"Yes\") AND\\n    request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nGROUP BY request_at",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "SELECT request_at Day, \\n    ROUND(SUM(IF(status = \\'cancelled_by_driver\\' OR status = \\'cancelled_by_client\\', 1,0)) / COUNT(*),2) AS \"Cancellation Rate\"\\nFROM Trips \\nWHERE client_id  NOT IN (SELECT users_id FROM Users WHERE banned = \"Yes\") AND \\n    driver_id NOT IN (SELECT users_id FROM Users WHERE banned = \"Yes\") AND\\n    request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nGROUP BY request_at",
                "codeTag": "Unknown"
            },
            {
                "id": 566813,
                "title": "mysql-97-71",
                "content": "```\\nSELECT Request_at AS Day, ROUND(SUM(IF(Status = \\'completed\\', 0, 1))/COUNT(Status),2) as \\'Cancellation Rate\\' \\nFROM Trips \\nWHERE Client_Id NOT IN (SELECT Users_Id FROM Users WHERE Banned = \\'Yes\\') \\n    AND Driver_Id NOT IN (SELECT Users_Id FROM Users WHERE Banned = \\'Yes\\')\\n    AND Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY Trips.Request_at\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Request_at AS Day, ROUND(SUM(IF(Status = \\'completed\\', 0, 1))/COUNT(Status),2) as \\'Cancellation Rate\\' \\nFROM Trips \\nWHERE Client_Id NOT IN (SELECT Users_Id FROM Users WHERE Banned = \\'Yes\\') \\n    AND Driver_Id NOT IN (SELECT Users_Id FROM Users WHERE Banned = \\'Yes\\')\\n    AND Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY Trips.Request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1033774,
                "title": "super-elegant-solution-mysql-sqlite-also-works-using-cte",
                "content": "```sql\\nwith stats as (\\n  select \\n    Request_at, \\n    T.Status <> \\'completed\\' as IsCancelled\\n  from Trips T \\n  join Users C on (Client_Id = C.Users_Id and C.Banned = \\'No\\') \\n  join Users D on (Driver_Id = D.Users_Id and D.Banned = \\'No\\') \\n  where\\n    Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\n)\\nselect \\n  Request_at as Day,\\n  Round(\\n    cast(sum(IsCancelled) as real) / cast(count(*) as real),\\n    2\\n  ) as \\'Cancellation Rate\\'\\nfrom stats\\ngroup by Request_at\\n;\\n```\\nPlease, comment and upvote the solution if you like it :-)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nwith stats as (\\n  select \\n    Request_at, \\n    T.Status <> \\'completed\\' as IsCancelled\\n  from Trips T \\n  join Users C on (Client_Id = C.Users_Id and C.Banned = \\'No\\') \\n  join Users D on (Driver_Id = D.Users_Id and D.Banned = \\'No\\') \\n  where\\n    Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\n)\\nselect \\n  Request_at as Day,\\n  Round(\\n    cast(sum(IsCancelled) as real) / cast(count(*) as real),\\n    2\\n  ) as \\'Cancellation Rate\\'\\nfrom stats\\ngroup by Request_at\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2387831,
                "title": "mysql-cte-only-no-joins-detailed-explanation",
                "content": "## Using CTE \\n\\n```\\n# Write your MySQL query statement below\\nWITH cte\\nAS (\\n    SELECT \\n        id,\\n        request_at AS Day,\\n        IF(status!=\\'completed\\', 1, 0) AS Cancelled\\n    FROM Trips \\n    WHERE client_id IN (SELECT users_id FROM Users WHERE banned=\\'No\\')\\n        AND driver_id IN (SELECT users_id FROM Users WHERE banned=\\'No\\')\\n        AND request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n)\\n\\nSELECT \\n    Day, \\n    ROUND(SUM(Cancelled) / COUNT(id), 2) AS \\'Cancellation Rate\\'\\nFROM cte\\nGROUP BY Day\\n```\\n\\n### 1. What\\'s happening in CTE??\\nWithout doing any counting of cancelled status, lets first filter what is asked:\\n* Request date should be between `2013-10-01` and `2013-10-03` \\n\\tThis is achieved using `WHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'`\\n* Not including both drivers and clients that are banned, aka we only consider drivers and clients who aren\\'t banned or has Banned=\\'No\\' in Users table\\n\\t\\t\\tThis is achieved using `WHERE client_id IN (SELECT users_id FROM Users WHERE banned=\\'No\\') AND driver_id IN (SELECT users_id FROM Users WHERE banned=\\'No\\')`\\nSince both of these conditions need to be true, we use `AND` to use them together.\\n\\nTaking the example provided by Leetcode, then\\n#### The cte table will now look like this if I select request_at (Day), status, id\\n![image](https://assets.leetcode.com/users/images/a3131e65-2da4-49c1-9fe5-534680e58294_1659797558.7360885.jpeg)\\n\\nHere, the red bracket represents (client_id, driver_id)\\n\\n### 2. How to calculate the cancellation rate\\nNow for the calculation of cancellation rate, we HAVE to know the total no of cancelled trips both by drivers and clients each day. To do that, we simply represent the entry with cancellation status as `1` and we assign the other status i.e., \\'completed\\' as `0`, so while summing over a day, these `0\\'s` won\\'t impact the total no of cancelled trips.\\nThis is done by using `IF` clause, we can also use `CASE` clause here instead of `IF`\\n`IF(status!=\\'completed\\', 1, 0) AS Cancelled`\\n\\n#### Now, the cte table look like this, if we add the above column\\n![image](https://assets.leetcode.com/users/images/b73fa641-baf7-4d5d-83b3-080bff854fd7_1659797381.8994489.jpeg)\\nNow the cte table is ready, all we have to do is take a sum of \\'Cancelled\\' column over each day i.e., `GROUP BY Day` and divide by the  count of \\'id\\' column to get the cancellation rate, then we round the rate using `ROUND` clause.\\nThis is the code of it: \\n```\\nSELECT \\n    Day, \\n    ROUND(SUM(Cancelled) / COUNT(id), 2) AS \\'Cancellation Rate\\'\\nFROM cte\\nGROUP BY Day\\n```\\n**Why are we dividing by `COUNT(id)`?**\\n\\tWhen we perform a `COUNT` function over a day using `GROUP BY`, we get the total no of unbanned trips that occured in that day. We do not have to calculated Completed trips here, because we already have `id` column to use.\\n##### Something like this\\n![image](https://assets.leetcode.com/users/images/f9f3c1a7-aa39-4915-a043-7571745e9f66_1659797628.0287173.jpeg)\\nWe select just the required columns.\\n\\nFurther Readings:\\n1. [MySQL 8.0 Reference Manual: 13.2.15 WITH (Common Table Expressions)](https://dev.mysql.com/doc/refman/8.0/en/with.html)\\n2. [An Introduction to MySQL CTE](https://www.mysqltutorial.org/mysql-cte/)\\n\\nThanks for reading! \\nIf there\\'s any error or doubt, do comment. Feedbacks are always appreciated!! Hopefully my handwriting is understandable.\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH cte\\nAS (\\n    SELECT \\n        id,\\n        request_at AS Day,\\n        IF(status!=\\'completed\\', 1, 0) AS Cancelled\\n    FROM Trips \\n    WHERE client_id IN (SELECT users_id FROM Users WHERE banned=\\'No\\')\\n        AND driver_id IN (SELECT users_id FROM Users WHERE banned=\\'No\\')\\n        AND request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n)\\n\\nSELECT \\n    Day, \\n    ROUND(SUM(Cancelled) / COUNT(id), 2) AS \\'Cancellation Rate\\'\\nFROM cte\\nGROUP BY Day\\n```\n```\\nSELECT \\n    Day, \\n    ROUND(SUM(Cancelled) / COUNT(id), 2) AS \\'Cancellation Rate\\'\\nFROM cte\\nGROUP BY Day\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1039883,
                "title": "no-matter-you-submitted-it-always-shows-wrong-answer",
                "content": "is there anyone who meets the same problem? i tried to sumbit my answer, it shows wrong answer. And i tried others\\' accepted solution, it still showed wrong answer. BUG??????",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3235161,
                "title": "262-solution-with-step-by-step-explanation",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\nThe query selects the Request_at date from the Trips table and calculates the cancellation rate for each day between October 1-3, 2013. The ROUND function is used to round the result to two decimal places.\\r\\n\\r\\nTo get information about the clients and drivers, the Trips table is joined with the Users table twice using the Client_Id and Driver_Id fields, respectively. The Banned field is used to filter out banned clients and drivers.\\r\\n\\r\\nThe WHERE clause is used to filter the results for trips requested between October 1-3, 2013.\\r\\n\\r\\nThe GROUP BY clause is used to group the results by the Request_at date, and the ORDER BY clause is used to order the results by Request_at date.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n-- Select the Request_at date from the Trips table and calculate the cancellation rate\\r\\nSELECT \\r\\n    tb1.Request_at as Day, \\r\\n    ROUND(\\r\\n        SUM(\\r\\n            CASE \\r\\n                WHEN tb1.Status = \"completed\" THEN 0\\r\\n                ELSE 1\\r\\n            END\\r\\n        ) / count(*), -- Count the total number of trips\\r\\n        2 -- Round the result to two decimal places\\r\\n    ) as \"Cancellation Rate\"\\r\\n    \\r\\n-- Join the Trips table with the Users table twice to get information about the clients and drivers\\r\\nFROM Trips as tb1\\r\\nINNER JOIN Users as tb2\\r\\nON tb1.Client_Id = tb2.Users_Id AND tb2.Banned=\"No\" -- Join with the Users table where Banned=\"No\" for clients\\r\\nINNER JOIN Users as tb3\\r\\nON tb1.Driver_Id = tb3.Users_Id AND tb3.Banned=\"No\" -- Join with the Users table where Banned=\"No\" for drivers\\r\\n\\r\\n-- Filter the results for trips requested between October 1-3, 2013\\r\\nWHERE tb1.Request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\r\\n\\r\\n-- Group the results by Request_at date\\r\\nGROUP BY tb1.Request_at\\r\\n\\r\\n-- Order the results by Request_at date\\r\\nORDER BY Day\\r\\n\\r\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\r\\n-- Select the Request_at date from the Trips table and calculate the cancellation rate\\r\\nSELECT \\r\\n    tb1.Request_at as Day, \\r\\n    ROUND(\\r\\n        SUM(\\r\\n            CASE \\r\\n                WHEN tb1.Status = \"completed\" THEN 0\\r\\n                ELSE 1\\r\\n            END\\r\\n        ) / count(*), -- Count the total number of trips\\r\\n        2 -- Round the result to two decimal places\\r\\n    ) as \"Cancellation Rate\"\\r\\n    \\r\\n-- Join the Trips table with the Users table twice to get information about the clients and drivers\\r\\nFROM Trips as tb1\\r\\nINNER JOIN Users as tb2\\r\\nON tb1.Client_Id = tb2.Users_Id AND tb2.Banned=\"No\" -- Join with the Users table where Banned=\"No\" for clients\\r\\nINNER JOIN Users as tb3\\r\\nON tb1.Driver_Id = tb3.Users_Id AND tb3.Banned=\"No\" -- Join with the Users table where Banned=\"No\" for drivers\\r\\n\\r\\n-- Filter the results for trips requested between October 1-3, 2013\\r\\nWHERE tb1.Request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\r\\n\\r\\n-- Group the results by Request_at date\\r\\nGROUP BY tb1.Request_at\\r\\n\\r\\n-- Order the results by Request_at date\\r\\nORDER BY Day\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 69204,
                "title": "sharing-my-solution",
                "content": "    SELECT Trips.Request_at Day,\\n           round(sum(if(status != 'completed', 1, 0)) / sum(1), 2) 'Cancellation Rate'\\n    FROM Trips\\n    JOIN Users\\n      ON Trips.Client_Id = Users.Users_Id\\n    WHERE Users.Banned = 'No' \\n      AND Trips.Request_at between '2013-10-01' AND '2013-10-03'   \\n    GROUP BY Trips.Request_at",
                "solutionTags": [],
                "code": "    SELECT Trips.Request_at Day,\\n           round(sum(if(status != 'completed', 1, 0)) / sum(1), 2) 'Cancellation Rate'\\n    FROM Trips\\n    JOIN Users\\n      ON Trips.Client_Id = Users.Users_Id\\n    WHERE Users.Banned = 'No' \\n      AND Trips.Request_at between '2013-10-01' AND '2013-10-03'   \\n    GROUP BY Trips.Request_at",
                "codeTag": "Unknown"
            },
            {
                "id": 3556333,
                "title": "easy-solution-for-beginner-without-any-explicit-joins",
                "content": "# Code\\n```\\nSELECT Request_at AS Day, ROUND(SUM(IF(Status = \\'completed\\', 0, 1))/COUNT(Status), 2) AS \\'Cancellation Rate\\' \\nFROM Trips \\nWHERE Client_Id NOT IN (SELECT Users_Id FROM Users WHERE Banned = \\'Yes\\') \\n    AND Driver_Id NOT IN (SELECT Users_Id FROM Users WHERE Banned = \\'Yes\\')\\n    AND Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY Request_at;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT Request_at AS Day, ROUND(SUM(IF(Status = \\'completed\\', 0, 1))/COUNT(Status), 2) AS \\'Cancellation Rate\\' \\nFROM Trips \\nWHERE Client_Id NOT IN (SELECT Users_Id FROM Users WHERE Banned = \\'Yes\\') \\n    AND Driver_Id NOT IN (SELECT Users_Id FROM Users WHERE Banned = \\'Yes\\')\\n    AND Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY Request_at;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3031295,
                "title": "simple-and-efficient-85-nested-aggregate-function",
                "content": "# Using Group By and Nested Case \\r\\nVery Simple Solution : [ faster than 85% ]\\r\\n\\r\\n\\r\\n# Code\\r\\n```\\r\\nselect request_at as \\'Day\\',\\r\\n    Round(\\r\\n        sum(\\r\\n            case \\r\\n                when t1.client_id not in (select users_id from Users where banned = \\'Yes\\') \\r\\n                    and t1.driver_id not in (select users_id from Users where banned = \\'Yes\\')\\r\\n                    and t1.status != \\'completed\\'\\r\\n                then 1\\r\\n                else 0\\r\\n            end\\r\\n        )/\\r\\n        sum(\\r\\n            case \\r\\n                when t1.client_id not in (select users_id from Users where banned = \\'Yes\\') \\r\\n                    and t1.driver_id not in (select users_id from Users where banned = \\'Yes\\')\\r\\n                then 1\\r\\n                else 0\\r\\n            end\\r\\n        ),\\r\\n        2\\r\\n    ) as \\'Cancellation Rate\\'\\r\\nfrom trips t1\\r\\nwhere t1.client_id not in (select users_id from Users where banned = \\'Yes\\') \\r\\n    and t1.driver_id not in (select users_id from Users where banned = \\'Yes\\')\\r\\n    and request_at between \"2013-10-01\" and \"2013-10-03\"\\r\\ngroup by request_at\\r\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\r\\nselect request_at as \\'Day\\',\\r\\n    Round(\\r\\n        sum(\\r\\n            case \\r\\n                when t1.client_id not in (select users_id from Users where banned = \\'Yes\\') \\r\\n                    and t1.driver_id not in (select users_id from Users where banned = \\'Yes\\')\\r\\n                    and t1.status != \\'completed\\'\\r\\n                then 1\\r\\n                else 0\\r\\n            end\\r\\n        )/\\r\\n        sum(\\r\\n            case \\r\\n                when t1.client_id not in (select users_id from Users where banned = \\'Yes\\') \\r\\n                    and t1.driver_id not in (select users_id from Users where banned = \\'Yes\\')\\r\\n                then 1\\r\\n                else 0\\r\\n            end\\r\\n        ),\\r\\n        2\\r\\n    ) as \\'Cancellation Rate\\'\\r\\nfrom trips t1\\r\\nwhere t1.client_id not in (select users_id from Users where banned = \\'Yes\\') \\r\\n    and t1.driver_id not in (select users_id from Users where banned = \\'Yes\\')\\r\\n    and request_at between \"2013-10-01\" and \"2013-10-03\"\\r\\ngroup by request_at\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 589340,
                "title": "no-subqueries-only-joins-faster-than-83",
                "content": "```\\nselect request_at as day, cast(sum(case when status <> \\'completed\\' then 1.0 else 0.0 end)/count(*) as decimal(10,2)) as \\'cancellation rate\\' \\nfrom trips t join users rider on t.client_id = rider.users_id \\njoin users driver on t.driver_id = driver.users_id\\nwhere t.request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nand rider.banned = \\'No\\'\\nand driver.banned = \\'No\\'\\ngroup by request_at",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect request_at as day, cast(sum(case when status <> \\'completed\\' then 1.0 else 0.0 end)/count(*) as decimal(10,2)) as \\'cancellation rate\\' \\nfrom trips t join users rider on t.client_id = rider.users_id \\njoin users driver on t.driver_id = driver.users_id\\nwhere t.request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nand rider.banned = \\'No\\'\\nand driver.banned = \\'No\\'\\ngroup by request_at",
                "codeTag": "Unknown"
            },
            {
                "id": 3171252,
                "title": "easy-mysql-solution",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n# Write your MySQL query statement below\\r\\nSELECT\\r\\n    request_at AS Day,\\r\\n    ROUND((SUM(CASE WHEN status != \\'completed\\' THEN 1 ELSE 0 END)/COUNT(DISTINCT id)),2) AS \\'Cancellation Rate\\'\\r\\nFROM Trips\\r\\nWHERE request_at BETWEEN \\'2013-10-01\\'\\r\\nAND \\'2013-10-03\\'\\r\\nAND client_id NOT IN (\\r\\n    SELECT\\r\\n        users_id\\r\\n    FROM Users\\r\\n    WHERE banned = \\'Yes\\'\\r\\n)\\r\\nAND driver_id NOT IN (\\r\\n    SELECT\\r\\n        users_id\\r\\n    FROM Users\\r\\n    WHERE banned = \\'Yes\\'\\r\\n)\\r\\nGROUP BY request_at;\\r\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\r\\n# Write your MySQL query statement below\\r\\nSELECT\\r\\n    request_at AS Day,\\r\\n    ROUND((SUM(CASE WHEN status != \\'completed\\' THEN 1 ELSE 0 END)/COUNT(DISTINCT id)),2) AS \\'Cancellation Rate\\'\\r\\nFROM Trips\\r\\nWHERE request_at BETWEEN \\'2013-10-01\\'\\r\\nAND \\'2013-10-03\\'\\r\\nAND client_id NOT IN (\\r\\n    SELECT\\r\\n        users_id\\r\\n    FROM Users\\r\\n    WHERE banned = \\'Yes\\'\\r\\n)\\r\\nAND driver_id NOT IN (\\r\\n    SELECT\\r\\n        users_id\\r\\n    FROM Users\\r\\n    WHERE banned = \\'Yes\\'\\r\\n)\\r\\nGROUP BY request_at;\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 751200,
                "title": "faster-than-97-05-of-mysql",
                "content": "Runtime: 351 ms, faster than 97.05% of MySQL online submissions for Trips and Users.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Trips and Users.\\n```\\nSELECT t.Request_at AS \\'Day\\', round(\\n    sum(case t.Status when \\'cancelled_by_driver\\' then 1 \\n                      when \\'cancelled_by_client\\' then 1 \\n        else 0 end) / count(*), 2) AS \\'Cancellation Rate\\'\\nFROM Trips t\\nWHERE \\'2013-10-01\\' <= t.Request_at and t.Request_at <= \\'2013-10-03\\' \\nand t.Client_Id in (SELECT Users_Id FROM Users u WHERE Banned = \\'No\\') \\nand t.Driver_Id in (SELECT Users_Id FROM Users u WHERE Banned = \\'No\\') \\nGROUP BY T.Request_at\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT t.Request_at AS \\'Day\\', round(\\n    sum(case t.Status when \\'cancelled_by_driver\\' then 1 \\n                      when \\'cancelled_by_client\\' then 1 \\n        else 0 end) / count(*), 2) AS \\'Cancellation Rate\\'\\nFROM Trips t\\nWHERE \\'2013-10-01\\' <= t.Request_at and t.Request_at <= \\'2013-10-03\\' \\nand t.Client_Id in (SELECT Users_Id FROM Users u WHERE Banned = \\'No\\') \\nand t.Driver_Id in (SELECT Users_Id FROM Users u WHERE Banned = \\'No\\') \\nGROUP BY T.Request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2552662,
                "title": "the-simple-approach-should-work-everywhere-mysql-ms-sql-etc",
                "content": "```\\nSELECT t.request_at AS Day, ROUND(SUM(IF(t.status != \\'completed\\', 1,0))/COUNT(*), 2) AS \"Cancellation Rate\"\\n\\tFROM trips t\\nJOIN users u\\n\\tON t.client_id = u.users_id\\nJOIN users d\\n\\tON t.driver_id = d.users_id\\nWHERE u.banned = \\'No\\' AND d.banned = \\'No\\' AND t.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nGROUP BY  t.request_at\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT t.request_at AS Day, ROUND(SUM(IF(t.status != \\'completed\\', 1,0))/COUNT(*), 2) AS \"Cancellation Rate\"\\n\\tFROM trips t\\nJOIN users u\\n\\tON t.client_id = u.users_id\\nJOIN users d\\n\\tON t.driver_id = d.users_id\\nWHERE u.banned = \\'No\\' AND d.banned = \\'No\\' AND t.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nGROUP BY  t.request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1980552,
                "title": "mysql-solution-fast-and-easy",
                "content": "# Solution\\n**With join:**\\n```\\nSELECT request_at as Day, \\n       ROUND(COUNT(CASE \\n             WHEN status != \\'completed\\' \\n             THEN 1 \\n             ELSE NULL \\n             END) / COUNT(*),2) AS \"Cancellation Rate\"\\nFROM Trips\\nINNER JOIN Users client ON client.users_id = Trips.client_id\\nINNER JOIN Users driver ON driver.users_id = Trips.driver_id\\nWHERE client.banned = \\'No\\' AND driver.banned = \\'No\\' AND request_at >= \"2013-10-01\" AND request_at <= \"2013-10-03\"\\nGROUP BY request_at\\n```\\n**Without join:**\\n```\\nwith unbaned_users as\\n(\\n    SELECT users_id FROM Users WHERE banned = \\'No\\'\\n)\\nSELECT request_at as Day, \\n       ROUND(COUNT(CASE \\n             WHEN status != \\'completed\\' \\n             THEN 1 \\n             ELSE NULL \\n             END) / COUNT(*),2) AS \"Cancellation Rate\"\\nFROM Trips\\nWHERE request_at >= \"2013-10-01\" AND request_at <= \"2013-10-03\"\\nAND client_id IN (SELECT * FROM unbaned_users)\\nAND driver_id IN (SELECT * FROM unbaned_users)\\nGROUP BY request_at\\n```\\nIf you find this **solution** and **explanation** helpful, please **upvote** it for others people.\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT request_at as Day, \\n       ROUND(COUNT(CASE \\n             WHEN status != \\'completed\\' \\n             THEN 1 \\n             ELSE NULL \\n             END) / COUNT(*),2) AS \"Cancellation Rate\"\\nFROM Trips\\nINNER JOIN Users client ON client.users_id = Trips.client_id\\nINNER JOIN Users driver ON driver.users_id = Trips.driver_id\\nWHERE client.banned = \\'No\\' AND driver.banned = \\'No\\' AND request_at >= \"2013-10-01\" AND request_at <= \"2013-10-03\"\\nGROUP BY request_at\\n```\n```\\nwith unbaned_users as\\n(\\n    SELECT users_id FROM Users WHERE banned = \\'No\\'\\n)\\nSELECT request_at as Day, \\n       ROUND(COUNT(CASE \\n             WHEN status != \\'completed\\' \\n             THEN 1 \\n             ELSE NULL \\n             END) / COUNT(*),2) AS \"Cancellation Rate\"\\nFROM Trips\\nWHERE request_at >= \"2013-10-01\" AND request_at <= \"2013-10-03\"\\nAND client_id IN (SELECT * FROM unbaned_users)\\nAND driver_id IN (SELECT * FROM unbaned_users)\\nGROUP BY request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1829448,
                "title": "simple-efficient-solution-no-join-no-cte",
                "content": "```\\nselect request_at as day, \\nround(sum(case when status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\' then 1 else 0 end)/count(id),2) as \"cancellation rate\"\\nfrom trips\\nwhere request_at between \"2013-01-01\" and \"2013-10-03\" \\nand client_id not in (select users_id from users where banned = \"Yes\") \\nand driver_id not in (select users_id from users where banned = \"Yes\")\\ngroup by day\\n```",
                "solutionTags": [],
                "code": "```\\nselect request_at as day, \\nround(sum(case when status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\' then 1 else 0 end)/count(id),2) as \"cancellation rate\"\\nfrom trips\\nwhere request_at between \"2013-01-01\" and \"2013-10-03\" \\nand client_id not in (select users_id from users where banned = \"Yes\") \\nand driver_id not in (select users_id from users where banned = \"Yes\")\\ngroup by day\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 947705,
                "title": "simple",
                "content": "```\\nselect Request_at Day, round(sum(case when Status != \\'completed\\' then 1 else 0 end)/count(*),2) `Cancellation Rate`\\nfrom Trips t \\nwhere Client_Id in (select Users_Id from Users where Banned = \\'No\\')\\nand Driver_Id in (select Users_Id from Users where Banned = \\'No\\')\\nand Request_at >= \\'2013-10-01\\' and Request_at <= \\'2013-10-03\\'\\ngroup by 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect Request_at Day, round(sum(case when Status != \\'completed\\' then 1 else 0 end)/count(*),2) `Cancellation Rate`\\nfrom Trips t \\nwhere Client_Id in (select Users_Id from Users where Banned = \\'No\\')\\nand Driver_Id in (select Users_Id from Users where Banned = \\'No\\')\\nand Request_at >= \\'2013-10-01\\' and Request_at <= \\'2013-10-03\\'\\ngroup by 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 430447,
                "title": "oracle-solution-without-using-join",
                "content": "```\\nSelect Request_at as \"Day\",\\nROUND(sum(case when status=\\'cancelled_by_driver\\' or status=\\'cancelled_by_client\\' then 1 else 0 end)/count(*),2) as \"Cancellation Rate\" \\nFROM Trips \\nWHERE Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nAND Client_id NOT IN (Select Users_Id from Users where Banned=\\'Yes\\')\\nAND Driver_Id NOT IN (Select Users_Id from Users where Banned=\\'Yes\\')\\ngroup by Request_at \\norder by Request_at;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSelect Request_at as \"Day\",\\nROUND(sum(case when status=\\'cancelled_by_driver\\' or status=\\'cancelled_by_client\\' then 1 else 0 end)/count(*),2) as \"Cancellation Rate\" \\nFROM Trips \\nWHERE Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nAND Client_id NOT IN (Select Users_Id from Users where Banned=\\'Yes\\')\\nAND Driver_Id NOT IN (Select Users_Id from Users where Banned=\\'Yes\\')\\ngroup by Request_at \\norder by Request_at;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2425016,
                "title": "mysql-2-different-approach-beginner-level-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**.*\\n______________________\\n\\u2705 **MySQL Code :**\\n***Approach 1:***\\n```\\nSELECT t.Request_at Day,\\n       ROUND((count(IF(t.status!=\\'completed\\',TRUE,null))/count(*)),2) as \\'Cancellation Rate\\'\\nFROM Trips t WHERE \\nt.Client_Id in (SELECT Users_Id from Users where Banned=\\'No\\') \\nAND t.Driver_Id in (SELECT Users_Id from Users where Banned=\\'No\\')\\nAND t.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY t.Request_at;\\n```\\n**Runtime:** 1380 ms\\n**Memory Usage:**  0B\\n__________________________________\\n***Approach 2***:\\n**Runtime:** 459 ms, faster than 86.41% of MySQL online submissions for Trips and Users.\\n```\\nSELECT\\n    request_at AS Day,\\n    ROUND((SUM(CASE WHEN status != \\'completed\\' THEN 1 ELSE 0 END)/COUNT(DISTINCT id)),2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nWHERE request_at BETWEEN \\'2013-10-01\\'\\nAND \\'2013-10-03\\'\\nAND client_id NOT IN (\\n    SELECT\\n        users_id\\n    FROM Users\\n    WHERE banned = \\'Yes\\'\\n)\\nAND driver_id NOT IN (\\n    SELECT\\n        users_id\\n    FROM Users\\n    WHERE banned = \\'Yes\\'\\n)\\nGROUP BY request_at\\n```\\t  \\n**Runtime:** 459 ms\\n**Memory Usage:**  0B\\n_________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT t.Request_at Day,\\n       ROUND((count(IF(t.status!=\\'completed\\',TRUE,null))/count(*)),2) as \\'Cancellation Rate\\'\\nFROM Trips t WHERE \\nt.Client_Id in (SELECT Users_Id from Users where Banned=\\'No\\') \\nAND t.Driver_Id in (SELECT Users_Id from Users where Banned=\\'No\\')\\nAND t.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY t.Request_at;\\n```\n```\\nSELECT\\n    request_at AS Day,\\n    ROUND((SUM(CASE WHEN status != \\'completed\\' THEN 1 ELSE 0 END)/COUNT(DISTINCT id)),2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nWHERE request_at BETWEEN \\'2013-10-01\\'\\nAND \\'2013-10-03\\'\\nAND client_id NOT IN (\\n    SELECT\\n        users_id\\n    FROM Users\\n    WHERE banned = \\'Yes\\'\\n)\\nAND driver_id NOT IN (\\n    SELECT\\n        users_id\\n    FROM Users\\n    WHERE banned = \\'Yes\\'\\n)\\nGROUP BY request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2068063,
                "title": "simple-solution-with-breakdown-of-explanations",
                "content": "```\\nSELECT request_at Day, ROUND(COUNT(IF(status LIKE \\'cancelled%\\', 1, NULL))/ COUNT(request_at),2) \"Cancellation Rate\"\\nFROM \\nTrips\\nWHERE \\n    client_id NOT IN \\n    (SELECT users_id FROM Users WHERE banned = \\'Yes\\' AND role = \\'client\\')\\n    AND\\n    driver_id  NOT IN \\n    (SELECT users_id  FROM Users WHERE banned = \\'Yes\\' AND role = \\'driver\\')\\n    AND\\n    request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nGROUP BY request_at;\\n```\\n\\n1st)\\n```\\nROUND(COUNT(IF(status LIKE \\'cancelled%\\', 1, NULL))/ COUNT(request_at),2) \"Cancellation Rate\"\\n```\\nThis part is checking of column status is starting with cancelled then count it and divide it total number of cancelled or completed trips with count(*) at both place count. and giving the column name as \"Cancellation Rate\" after rounding it two decimal values.\\n\\n2nd Part\\n\\n```\\nWHERE \\n    client_id NOT IN \\n    (SELECT users_id FROM Users WHERE banned = \\'Yes\\' AND role = \\'client\\')\\n    AND\\n    driver_id  NOT IN \\n    (SELECT users_id  FROM Users WHERE banned = \\'Yes\\' AND role = \\'driver\\')\\n    AND\\n    request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\n```\\n\\nHere we are checking with both client id and driver id should not exist with ban status in other table so using IN operator.\\n\\nKindly comment for any questions.",
                "solutionTags": [],
                "code": "```\\nSELECT request_at Day, ROUND(COUNT(IF(status LIKE \\'cancelled%\\', 1, NULL))/ COUNT(request_at),2) \"Cancellation Rate\"\\nFROM \\nTrips\\nWHERE \\n    client_id NOT IN \\n    (SELECT users_id FROM Users WHERE banned = \\'Yes\\' AND role = \\'client\\')\\n    AND\\n    driver_id  NOT IN \\n    (SELECT users_id  FROM Users WHERE banned = \\'Yes\\' AND role = \\'driver\\')\\n    AND\\n    request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nGROUP BY request_at;\\n```\n```\\nROUND(COUNT(IF(status LIKE \\'cancelled%\\', 1, NULL))/ COUNT(request_at),2) \"Cancellation Rate\"\\n```\n```\\nWHERE \\n    client_id NOT IN \\n    (SELECT users_id FROM Users WHERE banned = \\'Yes\\' AND role = \\'client\\')\\n    AND\\n    driver_id  NOT IN \\n    (SELECT users_id  FROM Users WHERE banned = \\'Yes\\' AND role = \\'driver\\')\\n    AND\\n    request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1051623,
                "title": "the-wrong-test-case-has-been-removed-thanks-admin",
                "content": "According to LC admin, this wrong test case has been removed. Thank you everyone! \\n\\n=====================================================================\\n\\nThe newly added test case made a little progress to cover the corner case, such as \"2013-10-02\" has no \"not banned users\" but we still need show \"2013-10-02\" in the output, and the cancellation rate is 0.00. However, the admin only add the test case without changing the answer in the meantime, so we will not pass this question if we use the right code. \\n\\n  [\"1\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-01\"],             \\n  [\"2\", \"2\", \"11\", \"1\", \"cancelled_by_driver\", \"2013-10-01\"], \\n  [\"3\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-01\"], \\n  [\"4\", \"4\", \"13\", \"6\", \"cancelled_by_client\", \"2013-10-01\"], \\n  [\"5\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-02\"], \\n  [\"6\", \"2\", \"11\", \"6\", \"completed\", \"2013-10-02\"], \\n  [\"7\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-02\"], \\n  [\"8\", \"2\", \"12\", \"12\", \"completed\", \"2013-10-03\"], \\n  [\"9\", \"3\", \"10\", \"12\", \"completed\", \"2013-10-03\"], \\n  [\"10\", \"4\", \"13\", \"12\", \"cancelled_by_driver\", \"2013-10-03\"]\\n\\n    [\"1\", \"No\", \"client\"], \\n    [\"2\", \"Yes\", \"client\"], \\n    [\"3\", \"No\", \"client\"], \\n    [\"4\", \"No\", \"client\"], \\n    [\"10\", \"Yes\", \"driver\"], \\n    [\"11\", \"Yes\", \"driver\"], \\n    [\"12\", \"Yes\", \"driver\"], \\n    [\"13\", \"No\", \"driver\"]\\n\\nLEETCODE EXPECTED:\\n\\n{\"headers\":[\"Day\",\"Cancellation Rate\"],\"values\":[[\"2013-10-01\",0.33000],[\"2013-10-02\",0.00000],[\"2013-10-03\",0.50000]]}\\n\\nHOWEVER, THE CORRECT ANSWER SHOULD BE:\\n\\n{\"headers\": [\"Day\", \"Cancellation Rate\"], \"values\": [[\"2013-10-01\", 1.00], [\"2013-10-02\", 0.00], [\"2013-10-03\", 1.00]]}\\n\\nSolution is as below:\\n\\nSolution I: using 2 joins to get the status for both driver and customer\\n\\n```\\nWITH CTE AS (\\n SELECT \\n  Client_Id,\\n  Driver_Id,\\n  Status,\\n  Request_at\\n FROM Trips \\n LEFT JOIN Users U1 ON Trips.Client_Id = U1.Users_Id\\n LEFT JOIN Users U2 ON Trips.Driver_Id = U2.Users_Id  \\n WHERE U1.Banned <> \\'Yes\\' AND U2.Banned <> \\'Yes\\'\\n        )\\nSELECT\\n  Trips.Request_at AS Day,\\n  ROUND(AVG(CASE WHEN CTE.Status LIKE \\'cancelled%\\' THEN 1 ELSE 0 END),2) AS \\'Cancellation Rate\\'\\nFROM Trips LEFT JOIN CTE ON Trips.Request_at = CTE.Request_at\\nWHERE Trips.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY Trips.Request_at\\n```\\n\\nSolution II: one is using the join and the other is using where id not in ()\\n\\n```\\nWITH CTE AS \\n(\\n SELECT \\n  Client_Id,\\n  Driver_Id,\\n  Status,\\n  Request_at\\n FROM Trips LEFT JOIN Users ON Trips.Client_Id = Users.Users_Id\\n WHERE Banned <> \\'Yes\\' \\n       AND Driver_Id NOT IN\\n              (\\n                SELECT Driver_Id\\n                FROM Trips LEFT JOIN Users ON Trips.Driver_Id = Users.Users_Id\\n                WHERE Banned = \\'Yes\\'\\n                    )\\n)\\n\\nSELECT\\n  Trips.Request_at AS Day,\\n  CAST(SUM(CASE WHEN CTE.Status LIKE \\'cancelled%\\' THEN 1 ELSE 0 END)*1.00/COUNT(*) AS NUMERIC(10,2)) AS \\'Cancellation Rate\\'\\nFROM Trips LEFT JOIN CTE ON Trips.Request_at = CTE.Request_at\\nWHERE Trips.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY Trips.Request_at\\n\\n```",
                "solutionTags": [],
                "code": "```\\nWITH CTE AS (\\n SELECT \\n  Client_Id,\\n  Driver_Id,\\n  Status,\\n  Request_at\\n FROM Trips \\n LEFT JOIN Users U1 ON Trips.Client_Id = U1.Users_Id\\n LEFT JOIN Users U2 ON Trips.Driver_Id = U2.Users_Id  \\n WHERE U1.Banned <> \\'Yes\\' AND U2.Banned <> \\'Yes\\'\\n        )\\nSELECT\\n  Trips.Request_at AS Day,\\n  ROUND(AVG(CASE WHEN CTE.Status LIKE \\'cancelled%\\' THEN 1 ELSE 0 END),2) AS \\'Cancellation Rate\\'\\nFROM Trips LEFT JOIN CTE ON Trips.Request_at = CTE.Request_at\\nWHERE Trips.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY Trips.Request_at\\n```\n```\\nWITH CTE AS \\n(\\n SELECT \\n  Client_Id,\\n  Driver_Id,\\n  Status,\\n  Request_at\\n FROM Trips LEFT JOIN Users ON Trips.Client_Id = Users.Users_Id\\n WHERE Banned <> \\'Yes\\' \\n       AND Driver_Id NOT IN\\n              (\\n                SELECT Driver_Id\\n                FROM Trips LEFT JOIN Users ON Trips.Driver_Id = Users.Users_Id\\n                WHERE Banned = \\'Yes\\'\\n                    )\\n)\\n\\nSELECT\\n  Trips.Request_at AS Day,\\n  CAST(SUM(CASE WHEN CTE.Status LIKE \\'cancelled%\\' THEN 1 ELSE 0 END)*1.00/COUNT(*) AS NUMERIC(10,2)) AS \\'Cancellation Rate\\'\\nFROM Trips LEFT JOIN CTE ON Trips.Request_at = CTE.Request_at\\nWHERE Trips.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY Trips.Request_at\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 202046,
                "title": "fast-mysql-solution-with-straightforward-inner-join",
                "content": "```\\n# Write your MySQL query statement below\\n\\n\\n# count the number of cancalled trips by unbanned clients \\n\\nSELECT t.request_at AS Day, ROUND(SUM(CASE WHEN t.status = \\'completed\\' THEN 0 ELSE 1 END) / (SELECT COUNT(t.status)), 2) AS \\'Cancellation Rate\\' FROM \\n(SELECT *\\nFROM trips\\nINNER JOIN users \\nON trips.client_id = users.users_id \\nWHERE users.banned = \\'No\\') AS t \\nGROUP BY t.request_at\\nHAVING t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\';\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\n# count the number of cancalled trips by unbanned clients \\n\\nSELECT t.request_at AS Day, ROUND(SUM(CASE WHEN t.status = \\'completed\\' THEN 0 ELSE 1 END) / (SELECT COUNT(t.status)), 2) AS \\'Cancellation Rate\\' FROM \\n(SELECT *\\nFROM trips\\nINNER JOIN users \\nON trips.client_id = users.users_id \\nWHERE users.banned = \\'No\\') AS t \\nGROUP BY t.request_at\\nHAVING t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\';\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3906363,
                "title": "pandas-two-simple-solutions-with-inline-explanation",
                "content": "The first approach is more general but more wordy. \\n# Code\\n```\\nimport pandas as pd\\n\\ndef trips_and_users(trips: pd.DataFrame, users: pd.DataFrame) -> pd.DataFrame:\\n\\n    # 1) temporal filtering\\n    trips = trips[trips[\\'request_at\\'].between(\"2013-10-01\",\"2013-10-03\")].rename(columns={\\'request_at\\':\\'Day\\'})\\n\\n    #2) filtering based not banned\\n    # 2.1) mappning the column \\'banned\\' to `client_id` and `driver_id`\\n    df_client = pd.merge(trips, users, left_on=\\'client_id\\', right_on=\\'users_id\\', how=\\'left\\').drop([\\'users_id\\', \\'role\\'], axis=1).rename(columns={\\'banned\\':\\'banned_client\\'})\\n    df_driver = pd.merge(trips, users, left_on=\\'driver_id\\', right_on=\\'users_id\\', how=\\'left\\').drop([\\'users_id\\', \\'role\\'], axis=1).rename(columns={\\'banned\\':\\'banned_driver\\'})\\n    df = pd.merge(df_client, df_driver, left_on=[\\'id\\', \\'driver_id\\',\\'client_id\\', \\'city_id\\', \\'status\\', \\'Day\\'], \\n                                        right_on=[\\'id\\', \\'driver_id\\',\\'client_id\\', \\'city_id\\', \\'status\\', \\'Day\\'], how=\\'left\\')\\n    # 2.2) filtering based on not banned\\n    df = df[(df[\\'banned_client\\']==\\'No\\') & (df[\\'banned_driver\\']==\\'No\\')]\\n\\n    # 3) counting the cancelled and total trips per day\\n    df[\\'status_cancelled\\'] = df[\\'status\\'].str.contains(\\'cancelled\\')\\n    df = df[[\\'Day\\', \\'status_cancelled\\']]\\n    df = df.groupby(\\'Day\\').agg({\\'status_cancelled\\': [(\\'total_cancelled\\', \\'sum\\'), (\\'total\\', \\'count\\')]})\\n    df.columns = df.columns.droplevel()\\n    df = df.reset_index()\\n\\n    # 4) calculating the ratio\\n    df[\\'Cancellation Rate\\'] = (df[\\'total_cancelled\\']/df[\\'total\\']).round(2)\\n    return df[[\\'Day\\', \\'Cancellation Rate\\']]\\n```\\n\\nThis solution is shorter but provides teh exact same results. \\n```\\nimport pandas as pd\\n\\ndef trips_and_users(trips: pd.DataFrame, users: pd.DataFrame) -> pd.DataFrame:\\n\\n    # 1) temporal filtering\\n    df = trips[trips[\\'request_at\\'].between(\"2013-10-01\",\"2013-10-03\")].rename(columns={\\'request_at\\':\\'Day\\'})\\n\\n    #2) filtering based not banned\\n    banned_set =  set(users[users[\\'banned\\']==\\'Yes\\'][\\'users_id\\'].tolist())\\n    df = df[(~df[\\'client_id\\'].isin(banned_set)) & (~df[\\'driver_id\\'].isin(banned_set))]\\n\\n    # 3) counting the cancelled and total trips per day\\n    df[\\'status_cancelled\\'] = df[\\'status\\'].str.contains(\\'cancelled\\')\\n    \\n    # 3) calculating the ratio\\n    df = df.groupby(\\'Day\\', as_index=False).agg({\\'status_cancelled\\': \\'mean\\'}).rename(columns={\\'status_cancelled\\': \\'Cancellation Rate\\'})\\n    df[\\'Cancellation Rate\\'] = (df[\\'Cancellation Rate\\']).round(2)\\n    return df\\n```\\n\\n\\nPlease consider upvote if you found this solution useful or creative.",
                "solutionTags": [
                    "Database",
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef trips_and_users(trips: pd.DataFrame, users: pd.DataFrame) -> pd.DataFrame:\\n\\n    # 1) temporal filtering\\n    trips = trips[trips[\\'request_at\\'].between(\"2013-10-01\",\"2013-10-03\")].rename(columns={\\'request_at\\':\\'Day\\'})\\n\\n    #2) filtering based not banned\\n    # 2.1) mappning the column \\'banned\\' to `client_id` and `driver_id`\\n    df_client = pd.merge(trips, users, left_on=\\'client_id\\', right_on=\\'users_id\\', how=\\'left\\').drop([\\'users_id\\', \\'role\\'], axis=1).rename(columns={\\'banned\\':\\'banned_client\\'})\\n    df_driver = pd.merge(trips, users, left_on=\\'driver_id\\', right_on=\\'users_id\\', how=\\'left\\').drop([\\'users_id\\', \\'role\\'], axis=1).rename(columns={\\'banned\\':\\'banned_driver\\'})\\n    df = pd.merge(df_client, df_driver, left_on=[\\'id\\', \\'driver_id\\',\\'client_id\\', \\'city_id\\', \\'status\\', \\'Day\\'], \\n                                        right_on=[\\'id\\', \\'driver_id\\',\\'client_id\\', \\'city_id\\', \\'status\\', \\'Day\\'], how=\\'left\\')\\n    # 2.2) filtering based on not banned\\n    df = df[(df[\\'banned_client\\']==\\'No\\') & (df[\\'banned_driver\\']==\\'No\\')]\\n\\n    # 3) counting the cancelled and total trips per day\\n    df[\\'status_cancelled\\'] = df[\\'status\\'].str.contains(\\'cancelled\\')\\n    df = df[[\\'Day\\', \\'status_cancelled\\']]\\n    df = df.groupby(\\'Day\\').agg({\\'status_cancelled\\': [(\\'total_cancelled\\', \\'sum\\'), (\\'total\\', \\'count\\')]})\\n    df.columns = df.columns.droplevel()\\n    df = df.reset_index()\\n\\n    # 4) calculating the ratio\\n    df[\\'Cancellation Rate\\'] = (df[\\'total_cancelled\\']/df[\\'total\\']).round(2)\\n    return df[[\\'Day\\', \\'Cancellation Rate\\']]\\n```\n```\\nimport pandas as pd\\n\\ndef trips_and_users(trips: pd.DataFrame, users: pd.DataFrame) -> pd.DataFrame:\\n\\n    # 1) temporal filtering\\n    df = trips[trips[\\'request_at\\'].between(\"2013-10-01\",\"2013-10-03\")].rename(columns={\\'request_at\\':\\'Day\\'})\\n\\n    #2) filtering based not banned\\n    banned_set =  set(users[users[\\'banned\\']==\\'Yes\\'][\\'users_id\\'].tolist())\\n    df = df[(~df[\\'client_id\\'].isin(banned_set)) & (~df[\\'driver_id\\'].isin(banned_set))]\\n\\n    # 3) counting the cancelled and total trips per day\\n    df[\\'status_cancelled\\'] = df[\\'status\\'].str.contains(\\'cancelled\\')\\n    \\n    # 3) calculating the ratio\\n    df = df.groupby(\\'Day\\', as_index=False).agg({\\'status_cancelled\\': \\'mean\\'}).rename(columns={\\'status_cancelled\\': \\'Cancellation Rate\\'})\\n    df[\\'Cancellation Rate\\'] = (df[\\'Cancellation Rate\\']).round(2)\\n    return df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2786234,
                "title": "mysql-solution",
                "content": "# Intuition\\n* filter out unbanned users during those 3 days  \\n* calculate number of \\'cancelled\\' / number of requests \\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\nselect request_at as Day, round(sum(if(status = \"cancelled_by_driver\" or status = \"cancelled_by_client\", 1,0 )) / count(id) ,2) as \"Cancellation Rate\"\\nfrom Trips \\nwhere client_id  not in (select users_id from Users  where banned = \"Yes\") \\nand driver_id   not in (select users_id from Users  where banned = \"Yes\")\\nand request_at between \"2013-10-01\" and \"2013-10-03\"\\ngroup by request_at \\norder by 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\nselect request_at as Day, round(sum(if(status = \"cancelled_by_driver\" or status = \"cancelled_by_client\", 1,0 )) / count(id) ,2) as \"Cancellation Rate\"\\nfrom Trips \\nwhere client_id  not in (select users_id from Users  where banned = \"Yes\") \\nand driver_id   not in (select users_id from Users  where banned = \"Yes\")\\nand request_at between \"2013-10-01\" and \"2013-10-03\"\\ngroup by request_at \\norder by 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2402690,
                "title": "accepted-solution-for-ms-sql-sql-server-t-sql",
                "content": "```\\nwith banned_users as\\n(\\n    select users_id from Users where banned = \\'Yes\\'\\n)\\nselect \\n    request_at as \\'Day\\', \\n    round(sum(IIF(status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\'), 1, 0)) / cast(count(*) as float), 2) as \\'Cancellation Rate\\'\\nfrom Trips t\\nwhere\\n    client_id not in (select * from banned_users) and\\n    driver_id not in (select * from banned_users) and\\n    request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at;\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nwith banned_users as\\n(\\n    select users_id from Users where banned = \\'Yes\\'\\n)\\nselect \\n    request_at as \\'Day\\', \\n    round(sum(IIF(status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\'), 1, 0)) / cast(count(*) as float), 2) as \\'Cancellation Rate\\'\\nfrom Trips t\\nwhere\\n    client_id not in (select * from banned_users) and\\n    driver_id not in (select * from banned_users) and\\n    request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1586761,
                "title": "best-solution-with-no-joins-and-simple-logic",
                "content": "SELECT request_at AS DAY,\\nROUND(SUM(case when status != \\'completed\\' then  1 else 0 end)*1.0 / [COUNT(*),](http://) 2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nAND client_id NOT IN (SELECT users_id FROM Users WHERE banned = \\'Yes\\')\\nAND driver_id NOT IN (SELECT users_id FROM Users WHERE banned = \\'Yes\\')\\nGROUP BY request_at;",
                "solutionTags": [],
                "code": "SELECT request_at AS DAY,\\nROUND(SUM(case when status != \\'completed\\' then  1 else 0 end)*1.0 / [COUNT(*),](http://) 2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nAND client_id NOT IN (SELECT users_id FROM Users WHERE banned = \\'Yes\\')\\nAND driver_id NOT IN (SELECT users_id FROM Users WHERE banned = \\'Yes\\')\\nGROUP BY request_at;",
                "codeTag": "Unknown"
            },
            {
                "id": 1146156,
                "title": "clear-solution-mysql",
                "content": "```\\nSELECT \\n    Request_at AS Day,\\n    ROUND(AVG(CASE WHEN Status != \\'completed\\' THEN 1 ElSE 0 END), 2) AS \\'Cancellation Rate\\'\\nFROM \\n    Trips\\nWHERE\\n    Client_Id NOT IN (SELECT Users_ID FROM Users WHERE Banned = \"Yes\")\\n    AND\\n    Driver_Id NOT IN (SELECT Users_ID FROM Users WHERE Banned = \"Yes\")\\n    AND\\n    Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY\\n    Request_at;",
                "solutionTags": [],
                "code": "```\\nSELECT \\n    Request_at AS Day,\\n    ROUND(AVG(CASE WHEN Status != \\'completed\\' THEN 1 ElSE 0 END), 2) AS \\'Cancellation Rate\\'\\nFROM \\n    Trips\\nWHERE\\n    Client_Id NOT IN (SELECT Users_ID FROM Users WHERE Banned = \"Yes\")\\n    AND\\n    Driver_Id NOT IN (SELECT Users_ID FROM Users WHERE Banned = \"Yes\")\\n    AND\\n    Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY\\n    Request_at;",
                "codeTag": "Unknown"
            },
            {
                "id": 69195,
                "title": "my-solution-share",
                "content": "195ms~240ms\\n\\n\\n    SELECT\\n    \\tRequest_at,\\n    \\tround(\\n    \\t\\tcount(\\n    \\n    \\t\\t\\tIF (STATUS != 'completed', TRUE, NULL)\\n    \\t\\t) / count(*),\\n    \\t\\t2\\n    \\t) AS 'Cancellation Rate'\\n    FROM\\n    \\t(\\n    \\t\\tSELECT\\n    \\t\\t\\tRequest_at,\\n    \\t\\t\\tSTATUS\\n    \\t\\tFROM\\n    \\t\\t\\tUsers\\n    \\t\\tJOIN (\\n    \\t\\t\\tSELECT\\n    \\t\\t\\t\\tClient_Id,\\n    \\t\\t\\t\\tRequest_at,\\n    \\t\\t\\t\\tStatus\\n    \\t\\t\\tFROM\\n    \\t\\t\\t\\tTrips\\n    \\t\\t\\tWHERE\\n    \\t\\t\\t\\tRequest_at >= '2013-10-01'\\n    \\t\\t\\tAND Request_at <= '2013-10-03'\\n    \\t\\t) AS a ON Users.Users_Id = a.Client_Id\\n    \\t\\tWHERE\\n    \\t\\t\\tRole = 'client'\\n    \\t\\tAND Banned = 'No'\\n    \\t) b\\n    GROUP BY\\n    \\tRequest_at",
                "solutionTags": [],
                "code": "195ms~240ms\\n\\n\\n    SELECT\\n    \\tRequest_at,\\n    \\tround(\\n    \\t\\tcount(\\n    \\n    \\t\\t\\tIF (STATUS != 'completed', TRUE, NULL)\\n    \\t\\t) / count(*),\\n    \\t\\t2\\n    \\t) AS 'Cancellation Rate'\\n    FROM\\n    \\t(\\n    \\t\\tSELECT\\n    \\t\\t\\tRequest_at,\\n    \\t\\t\\tSTATUS\\n    \\t\\tFROM\\n    \\t\\t\\tUsers\\n    \\t\\tJOIN (\\n    \\t\\t\\tSELECT\\n    \\t\\t\\t\\tClient_Id,\\n    \\t\\t\\t\\tRequest_at,\\n    \\t\\t\\t\\tStatus\\n    \\t\\t\\tFROM\\n    \\t\\t\\t\\tTrips\\n    \\t\\t\\tWHERE\\n    \\t\\t\\t\\tRequest_at >= '2013-10-01'\\n    \\t\\t\\tAND Request_at <= '2013-10-03'\\n    \\t\\t) AS a ON Users.Users_Id = a.Client_Id\\n    \\t\\tWHERE\\n    \\t\\t\\tRole = 'client'\\n    \\t\\tAND Banned = 'No'\\n    \\t) b\\n    GROUP BY\\n    \\tRequest_at",
                "codeTag": "Unknown"
            },
            {
                "id": 69185,
                "title": "simple-join-sum-function-solution",
                "content": "    select t.Request_at as Day,\\n           round(sum(if(t.Status <> 'completed', 1, 0))/sum(1), 2) as 'Cancellation Rate'\\n    from Trips as t\\n    inner join Users as u on t.Client_id = u.Users_id and u.Banned <> 'Yes'\\n    where t.Request_at >= '2013-10-01' and t.Request_at <='2013-10-03'\\n    group by t.Request_at;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "    select t.Request_at as Day,\\n           round(sum(if(t.Status <> 'completed', 1, 0))/sum(1), 2) as 'Cancellation Rate'\\n    from Trips as t\\n    inner join Users as u on t.Client_id = u.Users_id and u.Banned <> 'Yes'\\n    where t.Request_at >= '2013-10-01' and t.Request_at <='2013-10-03'\\n    group by t.Request_at;",
                "codeTag": "Unknown"
            },
            {
                "id": 3710805,
                "title": "mysql-solution-for-trips-and-users-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution involves joining the Trips table with the Users table to filter out trips with banned users. We then calculate the cancellation rate for each day by counting the canceled trips and dividing it by the total number of trips with unbanned users.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Use the JOIN keyword to combine the Trips table with the Users table twice, once for the client and once for the driver, ensuring that both users are not banned.\\n- Apply a filter using the WHERE clause to include only the trips between the given date range.\\n- Use the CASE statement and COUNT function to count the number of canceled trips.\\n- Use the COUNT(*) function to count the total number of trips with unbanned users.\\n- Calculate the cancellation rate by dividing the count of canceled trips by the total count of trips.\\n- Use the ROUND function to round the cancellation rate to two decimal places.\\n- Group the result by the request_at column to get the cancellation rate for each day.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the query depends on the size of the Trips table and the efficiency of the indexing on the join columns (client_id and driver_id). Assuming the join and filtering operations are performed efficiently, the time complexity can be considered as O(n), where n is the number of rows in the Trips table.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the query depends on the size of the result set, which is determined by the number of distinct days between the given date range. If there are m distinct days, the space complexity can be considered as O(m), where m is the number of distinct days between \"2013-10-01\" and \"2013-10-03\".\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT t.request_at AS Day, ROUND(COUNT(CASE WHEN t.status LIKE \\'cancelled%\\' THEN 1 END) / COUNT(*) , 2) \\nAS `Cancellation Rate`\\nFROM Trips t\\nJOIN Users u1 ON t.client_id = u1.users_id AND u1.banned = \\'No\\'\\nJOIN Users u2 ON t.driver_id = u2.users_id AND u2.banned = \\'No\\'\\nWHERE t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY t.request_at;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT t.request_at AS Day, ROUND(COUNT(CASE WHEN t.status LIKE \\'cancelled%\\' THEN 1 END) / COUNT(*) , 2) \\nAS `Cancellation Rate`\\nFROM Trips t\\nJOIN Users u1 ON t.client_id = u1.users_id AND u1.banned = \\'No\\'\\nJOIN Users u2 ON t.driver_id = u2.users_id AND u2.banned = \\'No\\'\\nWHERE t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY t.request_at;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2910477,
                "title": "using-two-join-like-group-by-sum-case",
                "content": "# Query\\n```\\nSELECT t.request_at AS \\'Day\\', ROUND(SUM(CASE\\n    WHEN t.status LIKE \\'ca%\\' THEN\\n    1\\n    ELSE 0 END)/COUNT(*),2) AS \"Cancellation Rate\"\\nFROM Trips t\\nJOIN Users clients\\n    ON t.client_id = clients.users_id\\n        AND clients.banned = \\'No\\'\\nJOIN Users drivers\\n    ON t.driver_id = drivers.users_id\\n        AND drivers.banned = \\'No\\'\\nWHERE t.request_at\\n    BETWEEN \\'2013-10-01\\'\\n        AND \\'2013-10-03\\'\\nGROUP BY  t.request_at;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT t.request_at AS \\'Day\\', ROUND(SUM(CASE\\n    WHEN t.status LIKE \\'ca%\\' THEN\\n    1\\n    ELSE 0 END)/COUNT(*),2) AS \"Cancellation Rate\"\\nFROM Trips t\\nJOIN Users clients\\n    ON t.client_id = clients.users_id\\n        AND clients.banned = \\'No\\'\\nJOIN Users drivers\\n    ON t.driver_id = drivers.users_id\\n        AND drivers.banned = \\'No\\'\\nWHERE t.request_at\\n    BETWEEN \\'2013-10-01\\'\\n        AND \\'2013-10-03\\'\\nGROUP BY  t.request_at;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2095394,
                "title": "simple-to-understand",
                "content": "```\\nselect request_at as Day, \\nround(sum(case when t.status in (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') then 1 else 0 end)/count(*),2) as \\'Cancellation Rate\\' \\nfrom trips t left join users u1 on t.client_id = u1.users_id left join users u2 on t.driver_id = u2.users_id \\nwhere u1.banned = \\'No\\' and u2.banned = \\'No\\' and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n```",
                "solutionTags": [],
                "code": "```\\nselect request_at as Day, \\nround(sum(case when t.status in (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') then 1 else 0 end)/count(*),2) as \\'Cancellation Rate\\' \\nfrom trips t left join users u1 on t.client_id = u1.users_id left join users u2 on t.driver_id = u2.users_id \\nwhere u1.banned = \\'No\\' and u2.banned = \\'No\\' and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2009694,
                "title": "a-simple-and-correct-solution",
                "content": "```\\nSELECT request_at AS Day, Round(sum(status like \\'cancelled%\\')/count(status), 2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nWHERE request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nAND client_id IN (SELECT users_id FROM Users WHERE banned = \\'No\\' AND role = \\'client\\')\\nAND driver_id IN (SELECT users_id FROM Users WHERE banned = \\'No\\' AND role = \\'driver\\')\\nGROUP BY 1;",
                "solutionTags": [],
                "code": "```\\nSELECT request_at AS Day, Round(sum(status like \\'cancelled%\\')/count(status), 2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nWHERE request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nAND client_id IN (SELECT users_id FROM Users WHERE banned = \\'No\\' AND role = \\'client\\')\\nAND driver_id IN (SELECT users_id FROM Users WHERE banned = \\'No\\' AND role = \\'driver\\')\\nGROUP BY 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 1681744,
                "title": "mysql",
                "content": "with cte as ( select users_id from Users where banned =\\'Yes\\'),\\ncte2 as( select * from trips where driver_id NOT IN(select * from cte) and client_id NOT IN(select * from cte) and request_at between \\'2013-10-01\\' and \\'2013-10-03\\')\\n    \\nselect request_at as \"Day\" , round(sum(case when status IN( \\'cancelled_by_client\\',\\'cancelled_by_driver\\')  then 1 else 0 end  )/count(*),2) as \"Cancellation Rate\" from cte2 group by request_at;",
                "solutionTags": [],
                "code": "with cte as ( select users_id from Users where banned =\\'Yes\\'),\\ncte2 as( select * from trips where driver_id NOT IN(select * from cte) and client_id NOT IN(select * from cte) and request_at between \\'2013-10-01\\' and \\'2013-10-03\\')\\n    \\nselect request_at as \"Day\" , round(sum(case when status IN( \\'cancelled_by_client\\',\\'cancelled_by_driver\\')  then 1 else 0 end  )/count(*),2) as \"Cancellation Rate\" from cte2 group by request_at;",
                "codeTag": "Unknown"
            },
            {
                "id": 1649592,
                "title": "simple-mysql-7lines",
                "content": "```\\nSELECT request_at AS Day, ROUND(SUM(status != \\'completed\\') / COUNT(*), 2) AS \"Cancellation Rate\"\\nFROM Trips\\n    JOIN Users u1 ON u1.users_id = Trips.client_id\\n    JOIN Users u2 ON u2.users_id = Trips.driver_id\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nAND u1.banned = \\'No\\' AND u2.banned = \\'No\\'\\nGROUP BY request_at\\n```\\n\\nDon\\'t really need to filter on the roles in Users table since the users_id is a common unique identifier for both client and drivers",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT request_at AS Day, ROUND(SUM(status != \\'completed\\') / COUNT(*), 2) AS \"Cancellation Rate\"\\nFROM Trips\\n    JOIN Users u1 ON u1.users_id = Trips.client_id\\n    JOIN Users u2 ON u2.users_id = Trips.driver_id\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nAND u1.banned = \\'No\\' AND u2.banned = \\'No\\'\\nGROUP BY request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1129937,
                "title": "one-step-cte-and-group-by",
                "content": "\\n\\t# In t1 we basically find everything in the Trip table associated with unbanned clients and drivers, and between 2013-10-01 and 2013-10-03.\\n\\t\\n\\twith t1 as (select trips.*\\n           from trips\\n           where client_id not in (select users_id\\n                                  from users \\n                                  where banned = \"Yes\")\\n           and driver_id not in (select users_id\\n                                  from users \\n                                  where banned = \"Yes\")\\n           and request_at between \"2013-10-01\" and \"2013-10-03\")\\n     \\n\\t \\n\\t # use sum and case when we can find how many are cancelled each day. \\n\\t # use count(*) we have the total number of trips each day. Then their division rounded to 2 decimal is the answer.\\n     select request_at as \\'Day\\', \\n            round(sum(case when status = \"completed\" then 0 else 1 end)/count(*), 2) as \\'Cancellation Rate\\'\\n            from t1\\n            group by 1;",
                "solutionTags": [],
                "code": "\\n\\t# In t1 we basically find everything in the Trip table associated with unbanned clients and drivers, and between 2013-10-01 and 2013-10-03.\\n\\t\\n\\twith t1 as (select trips.*\\n           from trips\\n           where client_id not in (select users_id\\n                                  from users \\n                                  where banned = \"Yes\")\\n           and driver_id not in (select users_id\\n                                  from users \\n                                  where banned = \"Yes\")\\n           and request_at between \"2013-10-01\" and \"2013-10-03\")\\n     \\n\\t \\n\\t # use sum and case when we can find how many are cancelled each day. \\n\\t # use count(*) we have the total number of trips each day. Then their division rounded to 2 decimal is the answer.\\n     select request_at as \\'Day\\', \\n            round(sum(case when status = \"completed\" then 0 else 1 end)/count(*), 2) as \\'Cancellation Rate\\'\\n            from t1\\n            group by 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 1104507,
                "title": "short-and-performant-solution-using-filtered-count",
                "content": "```\\nselect \\n    t.Request_at as Day,\\n    round(count(case when t.status!=\\'completed\\' then t.id end) / count(*), 2) as \"Cancellation Rate\"\\nfrom Trips t \\njoin Users c on t.Client_Id = c.Users_Id\\njoin Users d on t.Driver_Id = d.Users_Id\\nwhere \\n    c.Banned = \\'No\\' and \\n    d.Banned = \\'No\\' and\\n    t.Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by t.Request_at;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "```\\nselect \\n    t.Request_at as Day,\\n    round(count(case when t.status!=\\'completed\\' then t.id end) / count(*), 2) as \"Cancellation Rate\"\\nfrom Trips t \\njoin Users c on t.Client_Id = c.Users_Id\\njoin Users d on t.Driver_Id = d.Users_Id\\nwhere \\n    c.Banned = \\'No\\' and \\n    d.Banned = \\'No\\' and\\n    t.Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by t.Request_at;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1068382,
                "title": "is-there-a-wrong-testcase-test-case-analysis",
                "content": "Here is my query:\\n```\\nwith  unbanned_driver as (select users_id from users where role=\\'driver\\' and banned=\\'No\\' ),\\nunbanned_client as (select users_id from users where role=\\'client\\' and banned=\\'No\\' )\\n\\nSELECT Request_at AS Day, ROUND(SUM(IF(Status = \\'completed\\', 0, 1))/COUNT(Status),2) as \\'Cancellation Rate\\' \\nFROM Trips  where driver_id in (select users_id from unbanned_driver)\\nand client_id in (select users_id from unbanned_client)\\nand Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY Trips.Request_at\\n```\\nThis query fails for testcase #10 shown below:\\n\\nInput:\\n![image](https://assets.leetcode.com/users/images/f2973d75-d5ac-4289-b566-dec2c41ac503_1613483324.2746696.png)\\n\\nExpected output:\\n{\"headers\": [\"Day\", \"Cancellation Rate\"], \"values\": [[\"2013-10-01\", 0.33], [\"2013-10-02\", 0.00], [\"2013-10-03\", 0.50]]}\\n\\nQuery result:\\n{\"headers\": [\"Day\", \"Cancellation Rate\"], \"values\": [[\"2013-10-01\", 1.00], [\"2013-10-03\", 1.00]]}\\n\\n\\nHere is my analysis on the result:\\n\\n1. Unbanned drivers [13]\\n2. Unbanned clients [1,3,4]\\n3. Rides taken by driver # 13( The only unbanned driver): \\n\\t1. One ride on 2013-10-03\\n\\t2. One ride on 2013-10-01\\n\\t3. Both the rides are cancelled\\n4.Total number of rides for consideration= 2\\n5.Total number of cancelled rides = 2\\n6.Cancellation rate should be 1.00 on both the days\\n\\nLet me know your thoughts\\n\\n",
                "solutionTags": [],
                "code": "```\\nwith  unbanned_driver as (select users_id from users where role=\\'driver\\' and banned=\\'No\\' ),\\nunbanned_client as (select users_id from users where role=\\'client\\' and banned=\\'No\\' )\\n\\nSELECT Request_at AS Day, ROUND(SUM(IF(Status = \\'completed\\', 0, 1))/COUNT(Status),2) as \\'Cancellation Rate\\' \\nFROM Trips  where driver_id in (select users_id from unbanned_driver)\\nand client_id in (select users_id from unbanned_client)\\nand Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY Trips.Request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 838183,
                "title": "easy-solution",
                "content": "```\\nselect Request_at day,  round(sum(case when a.status !=  \\'completed\\' then 1 else 0 end)*1.0 /count(Status),2) \\'Cancellation Rate\\' \\nfrom trips a join users b on a.Client_Id = b.users_id\\njoin users c on a.Driver_Id = c.users_id\\nwhere b.Banned != \\'Yes\\' and c.Banned != \\'Yes\\'  and Request_at between \\'2013-10-01\\' AND \\'2013-10-03\\' \\ngroup by Request_at order by 1\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect Request_at day,  round(sum(case when a.status !=  \\'completed\\' then 1 else 0 end)*1.0 /count(Status),2) \\'Cancellation Rate\\' \\nfrom trips a join users b on a.Client_Id = b.users_id\\njoin users c on a.Driver_Id = c.users_id\\nwhere b.Banned != \\'Yes\\' and c.Banned != \\'Yes\\'  and Request_at between \\'2013-10-01\\' AND \\'2013-10-03\\' \\ngroup by Request_at order by 1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 361799,
                "title": "ms-sql-easy-soln-faster-than-89-of-submissions",
                "content": "```\\nselect \\n    request_at as Day,\\n    round((1.00* sum(iif(status!=\\'completed\\',1,0))) /count(status),2) AS [Cancellation Rate]\\nfrom trips a\\n    inner join users b\\n        on a.client_id = b.users_id and b.banned=\\'No\\'\\n    inner join users c\\n        on a.driver_id = c.users_id and c.banned=\\'No\\'\\nwhere request_at between convert(datetime,\\'2013-10-01\\') and convert(datetime,\\'2013-10-03\\')\\ngroup by request_at\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\n    request_at as Day,\\n    round((1.00* sum(iif(status!=\\'completed\\',1,0))) /count(status),2) AS [Cancellation Rate]\\nfrom trips a\\n    inner join users b\\n        on a.client_id = b.users_id and b.banned=\\'No\\'\\n    inner join users c\\n        on a.driver_id = c.users_id and c.banned=\\'No\\'\\nwhere request_at between convert(datetime,\\'2013-10-01\\') and convert(datetime,\\'2013-10-03\\')\\ngroup by request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350157,
                "title": "mysql-178ms-faster-than-97-77-of-submissions-easy-and-clear",
                "content": "Select tb.Request_at Day, \\nround(sum(case when tb.status = \\'completed\\' then 0 else 1 end) / count(*),2) as \\'Cancellation Rate\\'\\nfrom\\n    (Select * from Users u inner join Trips t \\n        on u.Users_Id  = t.Client_Id \\n        where u.Banned = \\'No\\'\\n    )tb\\nwhere tb.Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by tb.Request_at\\n\\n# i did only one inner join between both tables since there is no need to differentiate client or driver, as long as both are not banned. \\n",
                "solutionTags": [],
                "code": "Select tb.Request_at Day, \\nround(sum(case when tb.status = \\'completed\\' then 0 else 1 end) / count(*),2) as \\'Cancellation Rate\\'\\nfrom\\n    (Select * from Users u inner join Trips t \\n        on u.Users_Id  = t.Client_Id \\n        where u.Banned = \\'No\\'\\n    )tb\\nwhere tb.Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by tb.Request_at\\n\\n# i did only one inner join between both tables since there is no need to differentiate client or driver, as long as both are not banned. \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4020362,
                "title": "simple-solution",
                "content": "# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect request_at day\\n        ,round(sum(case when status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\' then 1 else 0 end)\\n         / (count(id) * 1.00),2) \\'Cancellation Rate\\'\\n  from Trips t \\n where request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\n   and client_id in (select users_id from Users where banned = \\'No\\')\\n   and driver_id in  (select users_id  from Users where banned = \\'No\\')\\ngroup by request_at\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect request_at day\\n        ,round(sum(case when status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\' then 1 else 0 end)\\n         / (count(id) * 1.00),2) \\'Cancellation Rate\\'\\n  from Trips t \\n where request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\n   and client_id in (select users_id from Users where banned = \\'No\\')\\n   and driver_id in  (select users_id  from Users where banned = \\'No\\')\\ngroup by request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2664630,
                "title": "mysql-faster-than-75-and-clear-solution",
                "content": "```\\nwith \\nactive_users as (\\n    select users_id as id\\n    from Users\\n    where banned = \\'no\\'\\n),\\nlegal_trips as (\\n    select\\n        id,\\n        status,\\n        request_at\\n    from Trips\\n    where \\n        client_id in (select id from active_users) and \\n        driver_id in (select id from active_users) and \\n        request_at between \"2013-10-01\" and \"2013-10-03\"\\n),\\ncount_canceled_trips_by_date as (\\n    select \\n        request_at as day,\\n        count(1) as num\\n    from legal_trips\\n    where status != \\'completed\\'\\n    group by request_at\\n),\\ncount_all_trips_by_date as (\\n    select \\n        request_at as day, \\n        count(1) as num\\n    from legal_trips\\n    group by request_at\\n)\\nselect\\n    total.day as Day,\\n    round(coalesce(canceled.num, 0) / total.num, 2) as \\'Cancellation Rate\\'\\nfrom \\n    count_all_trips_by_date as total\\nleft outer join count_canceled_trips_by_date as canceled\\n    on total.day = canceled.day\\n;\\n",
                "solutionTags": [],
                "code": "```\\nwith \\nactive_users as (\\n    select users_id as id\\n    from Users\\n    where banned = \\'no\\'\\n),\\nlegal_trips as (\\n    select\\n        id,\\n        status,\\n        request_at\\n    from Trips\\n    where \\n        client_id in (select id from active_users) and \\n        driver_id in (select id from active_users) and \\n        request_at between \"2013-10-01\" and \"2013-10-03\"\\n),\\ncount_canceled_trips_by_date as (\\n    select \\n        request_at as day,\\n        count(1) as num\\n    from legal_trips\\n    where status != \\'completed\\'\\n    group by request_at\\n),\\ncount_all_trips_by_date as (\\n    select \\n        request_at as day, \\n        count(1) as num\\n    from legal_trips\\n    group by request_at\\n)\\nselect\\n    total.day as Day,\\n    round(coalesce(canceled.num, 0) / total.num, 2) as \\'Cancellation Rate\\'\\nfrom \\n    count_all_trips_by_date as total\\nleft outer join count_canceled_trips_by_date as canceled\\n    on total.day = canceled.day\\n;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2265113,
                "title": "it-s-about-logic-not-speed-my-friend",
                "content": "```\\nWITH unbanned_user AS(\\n    SELECT users_id\\n    FROM Users\\n    WHERE banned = \"No\"\\n)\\n\\nSELECT \\n    request_at Day,\\n    ROUND(COUNT(status LIKE \"cancelled%\" OR NULL)/COUNT(*), 2) \"Cancellation Rate\"\\nFROM Trips\\nWHERE \\n    (request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\") \\n    AND client_id IN (SELECT users_id FROM unbanned_user)\\n    AND driver_id IN (SELECT users_id FROM unbanned_user)\\nGROUP BY 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH unbanned_user AS(\\n    SELECT users_id\\n    FROM Users\\n    WHERE banned = \"No\"\\n)\\n\\nSELECT \\n    request_at Day,\\n    ROUND(COUNT(status LIKE \"cancelled%\" OR NULL)/COUNT(*), 2) \"Cancellation Rate\"\\nFROM Trips\\nWHERE \\n    (request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\") \\n    AND client_id IN (SELECT users_id FROM unbanned_user)\\n    AND driver_id IN (SELECT users_id FROM unbanned_user)\\nGROUP BY 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2146041,
                "title": "simple-and-straightforward-no-join-very-easy",
                "content": "SELECT request_at AS \"Day\",\\nROUND(SUM(IF(status !=\"completed\",1,0))/COUNT(status),2) AS \"Cancellation Rate\"\\nFROM Trips\\nWHERE request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nAND client_id NOT IN (SELECT users_id from Users where banned = \"Yes\")\\nAND driver_id NOT IN (SELECT users_id from Users where banned = \"Yes\")\\nGROUP BY request_at;",
                "solutionTags": [],
                "code": "SELECT request_at AS \"Day\",\\nROUND(SUM(IF(status !=\"completed\",1,0))/COUNT(status),2) AS \"Cancellation Rate\"\\nFROM Trips\\nWHERE request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nAND client_id NOT IN (SELECT users_id from Users where banned = \"Yes\")\\nAND driver_id NOT IN (SELECT users_id from Users where banned = \"Yes\")\\nGROUP BY request_at;",
                "codeTag": "Unknown"
            },
            {
                "id": 2011830,
                "title": "easy-to-understand-solution-with-join-and-case",
                "content": "```sql\\nSELECT t.request_at as \\'Day\\', \\nROUND(\\nSUM(CASE\\n        WHEN t.status = \\'completed\\' THEN 0\\n        ELSE 1\\n    END) \\n    / \\n    COUNT(*),\\n    2) as \\'Cancellation Rate\\'\\nFROM trips t \\nJOIN users d ON t.driver_id = d.users_id\\nJOIN users c ON t.client_id = c.users_id\\nWHERE d.banned = \\'No\\' \\nAND c.banned = \\'No\\'\\nAND t.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nGROUP BY t.request_at;\\n```",
                "solutionTags": [],
                "code": "```sql\\nSELECT t.request_at as \\'Day\\', \\nROUND(\\nSUM(CASE\\n        WHEN t.status = \\'completed\\' THEN 0\\n        ELSE 1\\n    END) \\n    / \\n    COUNT(*),\\n    2) as \\'Cancellation Rate\\'\\nFROM trips t \\nJOIN users d ON t.driver_id = d.users_id\\nJOIN users c ON t.client_id = c.users_id\\nWHERE d.banned = \\'No\\' \\nAND c.banned = \\'No\\'\\nAND t.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nGROUP BY t.request_at;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1827053,
                "title": "mysql-solution",
                "content": "```\\nSELECT \\n    request_at AS \\'Day\\',\\n    ROUND(\\n        SUM(CASE WHEN t.status IN (\\'cancelled_by_driver\\', \\'cancelled_by_client\\') THEN 1 ELSE 0 END) /\\n        COUNT(id)\\n    ,2) AS \\'Cancellation Rate\\'\\nFROM Trips t\\nJOIN Users d\\n    ON t.driver_id = d.users_id\\n    AND d.banned = \\'No\\'\\nJOIN Users c\\n    ON t.client_id = c.users_id\\n    AND c.banned = \\'No\\'\\nWHERE \\n    request_at BETWEEN DATE(\\'2013-10-01\\') AND DATE(\\'2013-10-03\\')\\nGROUP BY request_at\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    request_at AS \\'Day\\',\\n    ROUND(\\n        SUM(CASE WHEN t.status IN (\\'cancelled_by_driver\\', \\'cancelled_by_client\\') THEN 1 ELSE 0 END) /\\n        COUNT(id)\\n    ,2) AS \\'Cancellation Rate\\'\\nFROM Trips t\\nJOIN Users d\\n    ON t.driver_id = d.users_id\\n    AND d.banned = \\'No\\'\\nJOIN Users c\\n    ON t.client_id = c.users_id\\n    AND c.banned = \\'No\\'\\nWHERE \\n    request_at BETWEEN DATE(\\'2013-10-01\\') AND DATE(\\'2013-10-03\\')\\nGROUP BY request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1734237,
                "title": "solution-runtime-484-ms",
                "content": "```\\nSELECT \\n    t.request_at as \"Day\",\\n    ROUND(\\n        SUM(case when t.status = \"cancelled_by_driver\" or t.status = \"cancelled_by_client\" then 1 else 0 end)\\n        /COUNT(*), 2) as \"Cancellation Rate\"\\nFROM \\n    Trips as t\\nJOIN \\n    Users as u ON t.client_id = u.users_id\\nJOIN \\n    Users as d ON t.driver_id = d.users_id\\nWHERE \\n    u.banned = \"No\" AND d.banned = \"No\" AND t.request_at >= \"2013-10-01\" AND t.request_at <= \"2013-10-03\"\\nGROUP BY \\n    t.request_at\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\n    t.request_at as \"Day\",\\n    ROUND(\\n        SUM(case when t.status = \"cancelled_by_driver\" or t.status = \"cancelled_by_client\" then 1 else 0 end)\\n        /COUNT(*), 2) as \"Cancellation Rate\"\\nFROM \\n    Trips as t\\nJOIN \\n    Users as u ON t.client_id = u.users_id\\nJOIN \\n    Users as d ON t.driver_id = d.users_id\\nWHERE \\n    u.banned = \"No\" AND d.banned = \"No\" AND t.request_at >= \"2013-10-01\" AND t.request_at <= \"2013-10-03\"\\nGROUP BY \\n    t.request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1490354,
                "title": "mysql-runtime-comparison-96-6-cte-vs-subquery-count-vs-sum",
                "content": "Runtime varies by submission time, server, platform, etc, but nonetheless, it does indicate relative code efficiency.\\nIn a nutshell, runtime-wise:\\n1. CTE is better than subquery (because the clause was run twice)\\n2. SUM() is better than COUNT()\\n3. COUNT() ignores `NULL` but SUM() is prone to `NULL`.\\n\\n**Approach 1, CTE + SUM()**\\n389 ms (96.6%)\\n```\\nwith cte as (\\n    select Users_Id from Users where Banned = \\'No\\'\\n)\\n\\nselect\\n  Request_at as Day,\\n  round(sum(case when Status != \\'completed\\' then 1 else 0 end) / count(Id), 2) as `Cancellation Rate`\\nfrom Trips t\\nwhere (Request_at between date \\'2013-10-01\\' and date \\'2013-10-03\\')\\n  and Client_Id in (select Users_Id from cte)\\n  and Driver_Id in (select Users_Id from cte)\\ngroup by Request_at\\n```\\n\\n**Approach 2, CTE + COUNT()**\\n452 ms (64%)\\n```\\nwith cte as (\\n    select Users_Id from Users where Banned = \\'No\\'\\n)\\n\\nselect\\n  Request_at as Day,\\n  round(count(case when Status != \\'completed\\' then 1 end) / count(Id), 2) as `Cancellation Rate`\\nfrom Trips t\\nwhere (Request_at between date \\'2013-10-01\\' and date \\'2013-10-03\\')\\n  and Client_Id in (select Users_Id from cte)\\n  and Driver_Id in (select Users_Id from cte)\\ngroup by Request_at\\n```\\n\\n**Approach 3, subquery + COUNT()**\\n519 ms (36%)\\n```\\nselect\\n  Request_at as Day,\\n  round(count(case when Status != \\'completed\\' then 1 end) / count(Id), 2) as `Cancellation Rate`\\nfrom Trips t\\nwhere (Request_at between date \\'2013-10-01\\' and date \\'2013-10-03\\')\\n  and Client_Id in (select Users_Id from Users where Banned = \\'No\\')\\n  and Driver_Id in (select Users_Id from Users where Banned = \\'No\\')\\ngroup by Request_at\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith cte as (\\n    select Users_Id from Users where Banned = \\'No\\'\\n)\\n\\nselect\\n  Request_at as Day,\\n  round(sum(case when Status != \\'completed\\' then 1 else 0 end) / count(Id), 2) as `Cancellation Rate`\\nfrom Trips t\\nwhere (Request_at between date \\'2013-10-01\\' and date \\'2013-10-03\\')\\n  and Client_Id in (select Users_Id from cte)\\n  and Driver_Id in (select Users_Id from cte)\\ngroup by Request_at\\n```\n```\\nwith cte as (\\n    select Users_Id from Users where Banned = \\'No\\'\\n)\\n\\nselect\\n  Request_at as Day,\\n  round(count(case when Status != \\'completed\\' then 1 end) / count(Id), 2) as `Cancellation Rate`\\nfrom Trips t\\nwhere (Request_at between date \\'2013-10-01\\' and date \\'2013-10-03\\')\\n  and Client_Id in (select Users_Id from cte)\\n  and Driver_Id in (select Users_Id from cte)\\ngroup by Request_at\\n```\n```\\nselect\\n  Request_at as Day,\\n  round(count(case when Status != \\'completed\\' then 1 end) / count(Id), 2) as `Cancellation Rate`\\nfrom Trips t\\nwhere (Request_at between date \\'2013-10-01\\' and date \\'2013-10-03\\')\\n  and Client_Id in (select Users_Id from Users where Banned = \\'No\\')\\n  and Driver_Id in (select Users_Id from Users where Banned = \\'No\\')\\ngroup by Request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1439398,
                "title": "mysql-solution-with-walkthrough",
                "content": "> First find the Unbanned Users (dRIVER, cLIENT) from the users table\\n\\n> Filter the result from above to the trips table using the ```users_id```  for both the ```client_id``` and ```driver_id```; then filter that result between ```1st and 3rd``` of ```october```; \\n\\n> the output for the quiz requests just the ```request_at``` and ```cancellation_Rate```; to find ```cancellation_Rate``` group by ```request_at``` and find sum of status that are cancelled and divide by total count on table\\n\\n```\\nWITH tbl1 AS ( \\n       SELECT users_id \\n       FROM   users \\n       WHERE  banned=\\'No\\'\\n)\\n      \\nSELECT   Request_at as Day,\\n\\t\\t round(sum(status != \\'completed\\')/COUNT(*),2) as \\'Cancellation Rate\\'\\nFROM     trips \\nWHERE    client_id IN \\n         ( \\n                SELECT * \\n                FROM   tbl1) \\nAND      driver_id IN \\n         ( \\n                SELECT * \\n                FROM   tbl1) \\nAND      request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\' \\nGROUP BY 1\\n\\n```",
                "solutionTags": [],
                "code": "```users_id```\n```client_id```\n```driver_id```\n```1st and 3rd```\n```october```\n```request_at```\n```cancellation_Rate```\n```cancellation_Rate```\n```request_at```\n```\\nWITH tbl1 AS ( \\n       SELECT users_id \\n       FROM   users \\n       WHERE  banned=\\'No\\'\\n)\\n      \\nSELECT   Request_at as Day,\\n\\t\\t round(sum(status != \\'completed\\')/COUNT(*),2) as \\'Cancellation Rate\\'\\nFROM     trips \\nWHERE    client_id IN \\n         ( \\n                SELECT * \\n                FROM   tbl1) \\nAND      driver_id IN \\n         ( \\n                SELECT * \\n                FROM   tbl1) \\nAND      request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\' \\nGROUP BY 1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1412832,
                "title": "easy-solution-broken-in-two-steps",
                "content": "**My thought process**\\n* We only need to perform aggregation on trips tables!\\n* Eliminate banned users from the equation.\\n* Inner join for valid drivers and valid clients to gather all the trips that count as valid.\\n* I added a case when to determine if the trip is cancelled to avoid a filter at the final stop it should be possible to optimize this case when.\\n* Finally we group by date and find the rate `sum(is_cancelled) / count(1)`\\n\\n\\n```\\n# step 1 - get all valid users\\nwith valid_users as\\n(\\n    select\\n        *\\n    from\\n        users\\n    where\\n        banned <> \"Yes\"\\n),\\n# step 2 - get all the valid(non-banned) trips\\nvalid_trips as\\n(\\n    select\\n        t.*,\\n        case \\n            when t.status like \"cancelled%\" then 1\\n            else 0\\n        end as is_cancelled\\n    from\\n        trips t\\n        inner join valid_users v1\\n        on (t.driver_id = v1.users_id )\\n        inner join valid_users v2\\n        on (t.client_id = v2.users_id )\\n    \\n)\\n# step 3 - final operation\\nselect\\n    request_at as Day,\\n    round(sum(is_cancelled) / count(1), 2) as \"Cancellation Rate\"\\nfrom\\n    valid_trips\\nwhere\\n    request_at between \"2013-10-01\" and \"2013-10-03\"\\ngroup by \\n    request_at\\norder by 1\\n```",
                "solutionTags": [],
                "code": "```\\n# step 1 - get all valid users\\nwith valid_users as\\n(\\n    select\\n        *\\n    from\\n        users\\n    where\\n        banned <> \"Yes\"\\n),\\n# step 2 - get all the valid(non-banned) trips\\nvalid_trips as\\n(\\n    select\\n        t.*,\\n        case \\n            when t.status like \"cancelled%\" then 1\\n            else 0\\n        end as is_cancelled\\n    from\\n        trips t\\n        inner join valid_users v1\\n        on (t.driver_id = v1.users_id )\\n        inner join valid_users v2\\n        on (t.client_id = v2.users_id )\\n    \\n)\\n# step 3 - final operation\\nselect\\n    request_at as Day,\\n    round(sum(is_cancelled) / count(1), 2) as \"Cancellation Rate\"\\nfrom\\n    valid_trips\\nwhere\\n    request_at between \"2013-10-01\" and \"2013-10-03\"\\ngroup by \\n    request_at\\norder by 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1288615,
                "title": "2-simple-solutions",
                "content": "```\\nselect \\n    Request_at as Day, \\n    round(1-avg(case when Status = \\'Completed\\' then 1 else 0 end), 2) as \\'Cancellation Rate\\'\\nfrom \\n    Trips join Users as c on Client_Id = c.Users_Id join Users as d on Driver_Id = d.Users_Id\\nwhere \\n    c.Banned = \\'No\\' and \\n    d.Banned = \\'No\\' and\\n    Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by \\n\\tRequest_at\\n```\\n\\n\\n```\\nselect \\n\\tRequest_at as Day, \\n    round(1-avg(case when Status = \\'Completed\\' then 1 else 0 end), 2) as \\'Cancellation Rate\\'\\nfrom \\n\\tTrips\\nwhere \\n\\tClient_Id not in (select Users_Id from Users where Banned = \\'Yes\\') and\\n    Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\') and\\n    Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by \\n\\tRequest_at\\n```\\n",
                "solutionTags": [],
                "code": "```\\nselect \\n    Request_at as Day, \\n    round(1-avg(case when Status = \\'Completed\\' then 1 else 0 end), 2) as \\'Cancellation Rate\\'\\nfrom \\n    Trips join Users as c on Client_Id = c.Users_Id join Users as d on Driver_Id = d.Users_Id\\nwhere \\n    c.Banned = \\'No\\' and \\n    d.Banned = \\'No\\' and\\n    Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by \\n\\tRequest_at\\n```\n```\\nselect \\n\\tRequest_at as Day, \\n    round(1-avg(case when Status = \\'Completed\\' then 1 else 0 end), 2) as \\'Cancellation Rate\\'\\nfrom \\n\\tTrips\\nwhere \\n\\tClient_Id not in (select Users_Id from Users where Banned = \\'Yes\\') and\\n    Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\') and\\n    Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by \\n\\tRequest_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1003499,
                "title": "mysql-two-cases-solution",
                "content": "SELECT  \\n        request_at Day,\\n\\n        round(SUM(CASE \\n                WHEN c.banned = \\'No\\' AND d.banned = \\'No\\' AND status LIKE(\\'%cancelled%\\') THEN 1\\n                ELSE 0\\n            END)/SUM(CASE\\n                        WHEN c.banned = \\'No\\' THEN 1 ELSE 0 END),2) \\'Cancellation Rate\\'\\n\\nFROM trips t\\ninner join Users c ON t.client_id = c.users_id and c.role = \\'client\\'\\ninner join Users d ON t.driver_id = d.users_id and d.role = \\'driver\\'\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY request_at\\nORDER BY request_at\\n;\\n",
                "solutionTags": [],
                "code": "SELECT  \\n        request_at Day,\\n\\n        round(SUM(CASE \\n                WHEN c.banned = \\'No\\' AND d.banned = \\'No\\' AND status LIKE(\\'%cancelled%\\') THEN 1\\n                ELSE 0\\n            END)/SUM(CASE\\n                        WHEN c.banned = \\'No\\' THEN 1 ELSE 0 END),2) \\'Cancellation Rate\\'\\n\\nFROM trips t\\ninner join Users c ON t.client_id = c.users_id and c.role = \\'client\\'\\ninner join Users d ON t.driver_id = d.users_id and d.role = \\'driver\\'\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY request_at\\nORDER BY request_at\\n;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 496345,
                "title": "mysql-simple-solution-faster-than-94-08",
                "content": "```\\nselect Request_at as Day,\\nround(sum(Status != \"completed\")/count(*),2) as \"Cancellation Rate\"\\nfrom Trips\\nwhere \\nClient_Id not in (select Users_Id from Users where Banned=\"Yes\")\\nand\\nDriver_Id not in (select Users_Id from Users where Banned=\"Yes\")\\nand\\nRequest_at >= \"2013-10-01\"\\nand\\nRequest_at <= \"2013-10-03\"\\ngroup by Request_at;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect Request_at as Day,\\nround(sum(Status != \"completed\")/count(*),2) as \"Cancellation Rate\"\\nfrom Trips\\nwhere \\nClient_Id not in (select Users_Id from Users where Banned=\"Yes\")\\nand\\nDriver_Id not in (select Users_Id from Users where Banned=\"Yes\")\\nand\\nRequest_at >= \"2013-10-01\"\\nand\\nRequest_at <= \"2013-10-03\"\\ngroup by Request_at;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 472550,
                "title": "mysql-without-join-using-avg",
                "content": "```\\nSELECT Request_at AS Day,\\n       ROUND(AVG(Status != \\'completed\\'), 2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nWHERE Client_Id IN (SELECT Users_Id FROM Users WHERE Banned = \\'NO\\') \\n      AND Driver_Id IN (SELECT Users_Id FROM Users WHERE Banned = \\'NO\\')\\n      AND Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY Request_at\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Request_at AS Day,\\n       ROUND(AVG(Status != \\'completed\\'), 2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nWHERE Client_Id IN (SELECT Users_Id FROM Users WHERE Banned = \\'NO\\') \\n      AND Driver_Id IN (SELECT Users_Id FROM Users WHERE Banned = \\'NO\\')\\n      AND Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY Request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 413026,
                "title": "beat-99-6-zero-memory",
                "content": "Probably could\\'ve done this better but it\\'s still decent I guess\\n```\\nSELECT a.Day as Day, cast(round(cast(ISNULL(b.COUNT, 0) as Float) / cast(a.COUNT as Float), 2) as decimal(10,2)) as \\'Cancellation Rate\\'\\nFROM\\n(Select COUNT(*) as COUNT, t.Request_at as Day\\nFROM Trips t, Users c, Users d\\nWHERE t.Client_Id = c.Users_Id AND t.Driver_Id = d.Users_Id AND (t.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\') AND c.Banned = \\'No\\' AND d.Banned = \\'No\\'\\nGROUP BY t.Request_at) a\\nLEFT JOIN\\n(Select COUNT(*) as COUNT, t.Request_at as Day\\nFROM Trips t, Users c, Users d\\nWHERE t.Client_Id = c.Users_Id AND t.Driver_Id = d.Users_Id AND (t.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\') AND c.Banned = \\'No\\' AND d.Banned = \\'No\\' AND t.Status LIKE \\'cancelled%\\' \\nGROUP BY t.Request_at) b\\nON a.Day = b.Day```",
                "solutionTags": [],
                "code": "```\\nSELECT a.Day as Day, cast(round(cast(ISNULL(b.COUNT, 0) as Float) / cast(a.COUNT as Float), 2) as decimal(10,2)) as \\'Cancellation Rate\\'\\nFROM\\n(Select COUNT(*) as COUNT, t.Request_at as Day\\nFROM Trips t, Users c, Users d\\nWHERE t.Client_Id = c.Users_Id AND t.Driver_Id = d.Users_Id AND (t.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\') AND c.Banned = \\'No\\' AND d.Banned = \\'No\\'\\nGROUP BY t.Request_at) a\\nLEFT JOIN\\n(Select COUNT(*) as COUNT, t.Request_at as Day\\nFROM Trips t, Users c, Users d\\nWHERE t.Client_Id = c.Users_Id AND t.Driver_Id = d.Users_Id AND (t.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\') AND c.Banned = \\'No\\' AND d.Banned = \\'No\\' AND t.Status LIKE \\'cancelled%\\' \\nGROUP BY t.Request_at) b\\nON a.Day = b.Day```",
                "codeTag": "Unknown"
            },
            {
                "id": 324042,
                "title": "trips-and-users",
                "content": "I denormalized tables by adding, client_banned and driver_banned columns to my temp (denormalized temp storage). Used temp to compute cancellation rate. \\nPlease feel free to comment on this if you find/found better solution in terms of execution time or if there is still scope in my solution to further optimize it.\\n```\\nSELECT \\n    Request_at AS `Day`,\\n    round(SUM(IF(`Status` LIKE \\'%cancelled%\\' AND client_banned = 0 AND driver_banned = 0,1, 0)) / SUM(IF(client_banned = 0 AND driver_banned = 0, 1, 0)), 2) AS `Cancellation Rate`\\nFROM \\n(\\n    SELECT \\n        `Id`,\\n        `Trips`.`Status`,\\n        `Request_at`,\\n        IF(`Client`.Users_id is NULL, 1, 0) AS `client_banned`,\\n        IF(`Driver`.Users_id is NULL, 1, 0) AS `driver_banned`\\n    FROM Trips\\n    LEFT JOIN \\n    (\\n        SELECT \\n            Users_Id \\n        FROM Users \\n        WHERE \\n        Banned = \\'No\\' and\\n        Role = \\'client\\'\\n    ) `Client` ON `Client`.users_id = `Trips`.Client_id\\n    LEFT JOIN \\n    (\\n        SELECT \\n            Users_Id \\n        FROM Users \\n        WHERE \\n        Banned = \\'No\\' and\\n        Role = \\'driver\\'\\n    ) `Driver` ON `Driver`.users_id = `Trips`.driver_id\\n) temp\\nGROUP BY Request_at\\nHAVING Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\n    Request_at AS `Day`,\\n    round(SUM(IF(`Status` LIKE \\'%cancelled%\\' AND client_banned = 0 AND driver_banned = 0,1, 0)) / SUM(IF(client_banned = 0 AND driver_banned = 0, 1, 0)), 2) AS `Cancellation Rate`\\nFROM \\n(\\n    SELECT \\n        `Id`,\\n        `Trips`.`Status`,\\n        `Request_at`,\\n        IF(`Client`.Users_id is NULL, 1, 0) AS `client_banned`,\\n        IF(`Driver`.Users_id is NULL, 1, 0) AS `driver_banned`\\n    FROM Trips\\n    LEFT JOIN \\n    (\\n        SELECT \\n            Users_Id \\n        FROM Users \\n        WHERE \\n        Banned = \\'No\\' and\\n        Role = \\'client\\'\\n    ) `Client` ON `Client`.users_id = `Trips`.Client_id\\n    LEFT JOIN \\n    (\\n        SELECT \\n            Users_Id \\n        FROM Users \\n        WHERE \\n        Banned = \\'No\\' and\\n        Role = \\'driver\\'\\n    ) `Driver` ON `Driver`.users_id = `Trips`.driver_id\\n) temp\\nGROUP BY Request_at\\nHAVING Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 295819,
                "title": "mysql-faster-than-95-24",
                "content": "```\\nSELECT\\n\\tTrips.Request_at AS Day,\\n\\tCONVERT (\\n\\t\\tSUM( CASE WHEN Trips.STATUS LIKE \\'cancelled_by_%\\' THEN 1 ELSE 0 END ) / COUNT( * ),\\n\\t\\tDECIMAL ( 10, 2 ) \\n\\t) AS `Cancellation Rate`\\nFROM\\n\\tTrips \\nWHERE\\n\\tTrips.Client_Id NOT IN ( SELECT Users_Id FROM Users WHERE Banned = \\'Yes\\' AND Role = \\'client\\' ) \\n\\tAND Trips.Driver_Id NOT IN ( SELECT Users_Id FROM Users WHERE Banned = \\'Yes\\' AND Role = \\'driver\\' )\\n    AND Trips.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY\\n\\tRequest_at\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n\\tTrips.Request_at AS Day,\\n\\tCONVERT (\\n\\t\\tSUM( CASE WHEN Trips.STATUS LIKE \\'cancelled_by_%\\' THEN 1 ELSE 0 END ) / COUNT( * ),\\n\\t\\tDECIMAL ( 10, 2 ) \\n\\t) AS `Cancellation Rate`\\nFROM\\n\\tTrips \\nWHERE\\n\\tTrips.Client_Id NOT IN ( SELECT Users_Id FROM Users WHERE Banned = \\'Yes\\' AND Role = \\'client\\' ) \\n\\tAND Trips.Driver_Id NOT IN ( SELECT Users_Id FROM Users WHERE Banned = \\'Yes\\' AND Role = \\'driver\\' )\\n    AND Trips.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY\\n\\tRequest_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 229226,
                "title": "sum-if-count-solution",
                "content": "```\\nSELECT Request_at Day,  \\n    ROUND(\\n        SUM(IF(Status=\"completed\",0,1))/COUNT(Id)\\n        ,2)\\n    AS \"Cancellation Rate\"\\nFROM Trips t\\nWHERE t.Client_Id NOT IN \\n    (SELECT Users_Id FROM Users\\n    WHERE Banned = \"Yes\")\\n    AND t.Driver_Id NOT IN\\n    (SELECT Users_Id FROM Users\\n    WHERE Banned = \"Yes\")\\n    AND DATE(Request_at) >= DATE(\\'2013-10-01\\')\\n    AND DATE(Request_at) <= DATE(\\'2013-10-03\\')\\nGROUP BY 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Request_at Day,  \\n    ROUND(\\n        SUM(IF(Status=\"completed\",0,1))/COUNT(Id)\\n        ,2)\\n    AS \"Cancellation Rate\"\\nFROM Trips t\\nWHERE t.Client_Id NOT IN \\n    (SELECT Users_Id FROM Users\\n    WHERE Banned = \"Yes\")\\n    AND t.Driver_Id NOT IN\\n    (SELECT Users_Id FROM Users\\n    WHERE Banned = \"Yes\")\\n    AND DATE(Request_at) >= DATE(\\'2013-10-01\\')\\n    AND DATE(Request_at) <= DATE(\\'2013-10-03\\')\\nGROUP BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 69174,
                "title": "129-ms-solution",
                "content": "```\\n# Write your MySQL query statement below\\nselect Day, round(avg(cnt), 2) as \"Cancellation Rate\"\\nfrom \\n(   select a.request_at as Day, \\n    @cnt := IF(a.Status = 'completed', 0, 1) as cnt\\n    from Trips a, Users b\\n    where a.Client_Id = b.Users_Id and b.Banned = 'No'\\n) c\\nwhere Day BETWEEN '2013-10-01' AND '2013-10-03'\\ngroup by Day\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect Day, round(avg(cnt), 2) as \"Cancellation Rate\"\\nfrom \\n(   select a.request_at as Day, \\n    @cnt := IF(a.Status = 'completed', 0, 1) as cnt\\n    from Trips a, Users b\\n    where a.Client_Id = b.Users_Id and b.Banned = 'No'\\n) c\\nwhere Day BETWEEN '2013-10-01' AND '2013-10-03'\\ngroup by Day\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3221015,
                "title": "solution-with-window-function-sql-server-or-simple-group-by-with-no-join-mysql",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to so```\\r\\nCode block\\r\\n```lve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n;WITH CTE AS (SELECT\\r\\n\\t*,\\r\\n\\tCOUNT(Request_at) OVER(PARTITION BY Request_at) AS COUNTOPERA,\\r\\n\\tCOUNT(IIF(/*status IN (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') AND */client_id IN (\\r\\n\\tSELECT\\r\\n\\t\\tusers_id \\r\\n\\tFROM\\r\\n\\t\\tUsers\\r\\n\\tWHERE\\t\\r\\n\\t\\tBanned  = \\'YES\\'\\r\\n\\t) OR driver_id IN (\\r\\n\\tSELECT\\r\\n\\t\\tusers_id \\r\\n\\tFROM\\r\\n\\t\\tUsers\\r\\n\\tWHERE\\t\\r\\n\\t\\tBanned  = \\'YES\\'\\r\\n\\t), status,null )) OVER (PARTITION BY Request_at) COUNTCANCELBANNED,\\r\\n\\tCOUNT(IIF(status IN (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') AND (client_id IN (\\r\\n\\tSELECT\\r\\n\\t\\tusers_id \\r\\n\\tFROM\\r\\n\\t\\tUsers\\r\\n\\tWHERE\\t\\r\\n\\t\\tBanned  = \\'No\\'\\r\\n\\t) ), status,null )) OVER (PARTITION BY Request_at) COUNTCANCEL\\r\\nFROM\\r\\n\\tTrips\\r\\nWHERE\\r\\n    Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\r\\n)\\r\\nSELECT DISTINCT\\r\\n\\tRequest_at Day,\\r\\n\\tROUND( COUNTCANCEL / CAST((COUNTOPERA - COUNTCANCELBANNED) AS FLOAT),2) [Cancellation Rate]\\r\\nFROM\\r\\n\\tCTE\\r\\nWHERE\\r\\n    COUNTOPERA - COUNTCANCELBANNED > 0\\r\\n\\t\\r\\n```\\r\\n```\\r\\n# Write your MySQL query statement below\\r\\n\\r\\n\\r\\nSELECT\\r\\n\\trequest_at AS \\'DAY\\',\\r\\n    ROUND(COUNT(IF(status IN(\\'cancelled_by_driver\\',\\'cancelled_by_client\\') , status , NULL)) / COUNT(status) , 2) AS \\'Cancellation Rate\\'\\r\\nFROM\\r\\n\\tTrips T\\r\\nWHERE\\r\\n\\tclient_id  NOT IN ( SELECT users_id FROM Users WHERE banned = \\'YES\\')\\r\\nAND\\r\\n\\tdriver_id NOT IN ( SELECT users_id FROM Users WHERE banned = \\'YES\\')\\r\\nAND \\r\\n\\t( request_at > \\'2013-09-30\\' AND request_at < \\'2013-10-04\\' )\\r\\nGROUP BY\\r\\n\\trequest_at;\\r\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\r\\nCode block\\r\\n```\n```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n;WITH CTE AS (SELECT\\r\\n\\t*,\\r\\n\\tCOUNT(Request_at) OVER(PARTITION BY Request_at) AS COUNTOPERA,\\r\\n\\tCOUNT(IIF(/*status IN (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') AND */client_id IN (\\r\\n\\tSELECT\\r\\n\\t\\tusers_id \\r\\n\\tFROM\\r\\n\\t\\tUsers\\r\\n\\tWHERE\\t\\r\\n\\t\\tBanned  = \\'YES\\'\\r\\n\\t) OR driver_id IN (\\r\\n\\tSELECT\\r\\n\\t\\tusers_id \\r\\n\\tFROM\\r\\n\\t\\tUsers\\r\\n\\tWHERE\\t\\r\\n\\t\\tBanned  = \\'YES\\'\\r\\n\\t), status,null )) OVER (PARTITION BY Request_at) COUNTCANCELBANNED,\\r\\n\\tCOUNT(IIF(status IN (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') AND (client_id IN (\\r\\n\\tSELECT\\r\\n\\t\\tusers_id \\r\\n\\tFROM\\r\\n\\t\\tUsers\\r\\n\\tWHERE\\t\\r\\n\\t\\tBanned  = \\'No\\'\\r\\n\\t) ), status,null )) OVER (PARTITION BY Request_at) COUNTCANCEL\\r\\nFROM\\r\\n\\tTrips\\r\\nWHERE\\r\\n    Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\r\\n)\\r\\nSELECT DISTINCT\\r\\n\\tRequest_at Day,\\r\\n\\tROUND( COUNTCANCEL / CAST((COUNTOPERA - COUNTCANCELBANNED) AS FLOAT),2) [Cancellation Rate]\\r\\nFROM\\r\\n\\tCTE\\r\\nWHERE\\r\\n    COUNTOPERA - COUNTCANCELBANNED > 0\\r\\n\\t\\r\\n```\n```\\r\\n# Write your MySQL query statement below\\r\\n\\r\\n\\r\\nSELECT\\r\\n\\trequest_at AS \\'DAY\\',\\r\\n    ROUND(COUNT(IF(status IN(\\'cancelled_by_driver\\',\\'cancelled_by_client\\') , status , NULL)) / COUNT(status) , 2) AS \\'Cancellation Rate\\'\\r\\nFROM\\r\\n\\tTrips T\\r\\nWHERE\\r\\n\\tclient_id  NOT IN ( SELECT users_id FROM Users WHERE banned = \\'YES\\')\\r\\nAND\\r\\n\\tdriver_id NOT IN ( SELECT users_id FROM Users WHERE banned = \\'YES\\')\\r\\nAND \\r\\n\\t( request_at > \\'2013-09-30\\' AND request_at < \\'2013-10-04\\' )\\r\\nGROUP BY\\r\\n\\trequest_at;\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2910496,
                "title": "using-if-instead-of-case",
                "content": "# Query\\n```\\nSELECT t.request_at AS \\'Day\\', ROUND(SUM(\\n    IF(t.status LIKE \\'ca%\\', 1, 0)\\n    )/COUNT(*),2) AS \"Cancellation Rate\"\\nFROM Trips t\\nJOIN Users clients\\n    ON t.client_id = clients.users_id\\n        AND clients.banned = \\'No\\'\\nJOIN Users drivers\\n    ON t.driver_id = drivers.users_id\\n        AND drivers.banned = \\'No\\'\\nWHERE t.request_at\\n    BETWEEN \\'2013-10-01\\'\\n        AND \\'2013-10-03\\'\\nGROUP BY  t.request_at;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT t.request_at AS \\'Day\\', ROUND(SUM(\\n    IF(t.status LIKE \\'ca%\\', 1, 0)\\n    )/COUNT(*),2) AS \"Cancellation Rate\"\\nFROM Trips t\\nJOIN Users clients\\n    ON t.client_id = clients.users_id\\n        AND clients.banned = \\'No\\'\\nJOIN Users drivers\\n    ON t.driver_id = drivers.users_id\\n        AND drivers.banned = \\'No\\'\\nWHERE t.request_at\\n    BETWEEN \\'2013-10-01\\'\\n        AND \\'2013-10-03\\'\\nGROUP BY  t.request_at;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2904353,
                "title": "extremely-simplified-easy-understand-mysql",
                "content": "The key is left join and set the condition with only show not banned so that we can check clearly\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect t.request_at as Day, \\nround((sum(case when t.status like \\'cancelled%\\' then 1 else 0 end)/sum(case when u1.banned = \\'yes\\' then 0 else 1 end)), 2) \\'Cancellation Rate\\'\\nfrom trips t \\nleft join users u1 on t.client_id = u1.users_id\\nleft join users u2 on t.driver_id = u2.users_id\\nwhere t.request_at >= \\'2013-10-01\\' and t.request_at <= \\'2013-10-03\\'\\nand u1.banned = \\'no\\'\\nand u2.banned = \\'no\\'\\ngroup by 1\\norder by 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect t.request_at as Day, \\nround((sum(case when t.status like \\'cancelled%\\' then 1 else 0 end)/sum(case when u1.banned = \\'yes\\' then 0 else 1 end)), 2) \\'Cancellation Rate\\'\\nfrom trips t \\nleft join users u1 on t.client_id = u1.users_id\\nleft join users u2 on t.driver_id = u2.users_id\\nwhere t.request_at >= \\'2013-10-01\\' and t.request_at <= \\'2013-10-03\\'\\nand u1.banned = \\'no\\'\\nand u2.banned = \\'no\\'\\ngroup by 1\\norder by 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2741450,
                "title": "mysql-no-join-easy-explanation-faster-than-80-simple-solution",
                "content": "```\\nwith not_banned as (Select users_id as id from Users where banned = \\'Yes\\')\\n\\nSelect distinct request_at as Day, round(sum(if(status != \\'completed\\',1,0))/count(*),2) as \"Cancellation Rate\"\\nfrom Trips where (client_id not in (select id from not_banned)) AND (driver_id not in (select id from not_banned)) AND (request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\ngroup by request_at;\\n```\\n\\n**EXPLANATION:**\\n1. with not_banned as (Select users_id as id from Users where banned = \\'Yes\\')\\n\\nThis line takes the list of user and drivers who are not banned.\\n\\n2. group by request_at\\nNow we will group by on the basis of date because we have to find the cancellation rate on that basis.\\n\\n\\n3. where (client_id not in (select id from not_banned)) AND (driver_id not in (select id from not_banned)) AND (request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\n\\nThen we will select all the ROWS which are in the range of date 2013-10-01 and 2013-10-03 and the driver and users are not banned.\\n\\n\\n4. Then we will select all the rows which satisfies our point 3 condition and we will count those rows as 1 else 0 whose status is not \\'completed\\' means they are cancelled. After counting we will find the sum and will divide by the count means all the trips done on the day because we have already done group by request_at date. \\n\\n\\n5. round(sum(if(status != \\'completed\\',1,0))/count(*),2)\\nThen we will divide them and round to 2 decimal using round().\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith not_banned as (Select users_id as id from Users where banned = \\'Yes\\')\\n\\nSelect distinct request_at as Day, round(sum(if(status != \\'completed\\',1,0))/count(*),2) as \"Cancellation Rate\"\\nfrom Trips where (client_id not in (select id from not_banned)) AND (driver_id not in (select id from not_banned)) AND (request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\ngroup by request_at;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2624383,
                "title": "1-cte-2-joins",
                "content": "2 joins to make sure driver or client is not banned\\n```\\nwith\\ncte1 as (\\n    select\\n    t.id,\\n    t.client_id   ,\\n    t.driver_id   ,\\n    t.status      ,\\n    case when t.status <> \\'completed\\' then 1 end cancelled,\\n    t.request_at  \\n    from\\n    Trips t\\n    join Users c\\n    on (t.client_id = c.users_id and c.role = \\'client\\' )\\n    join Users d\\n    on (t.driver_id = d.users_id and d.role = \\'driver\\' )\\n    where\\n    t.request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\n    and d.banned = \\'No\\' and c.banned = \\'No\\'\\n\\n)\\nselect\\nrequest_at Day,\\n(round(count(cancelled) / count(id),2) ) \"Cancellation Rate\"\\nfrom cte1\\ngroup by request_at\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nwith\\ncte1 as (\\n    select\\n    t.id,\\n    t.client_id   ,\\n    t.driver_id   ,\\n    t.status      ,\\n    case when t.status <> \\'completed\\' then 1 end cancelled,\\n    t.request_at  \\n    from\\n    Trips t\\n    join Users c\\n    on (t.client_id = c.users_id and c.role = \\'client\\' )\\n    join Users d\\n    on (t.driver_id = d.users_id and d.role = \\'driver\\' )\\n    where\\n    t.request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\n    and d.banned = \\'No\\' and c.banned = \\'No\\'\\n\\n)\\nselect\\nrequest_at Day,\\n(round(count(cancelled) / count(id),2) ) \"Cancellation Rate\"\\nfrom cte1\\ngroup by request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2531039,
                "title": "cte-no-join-clause-faster-than-70",
                "content": "```\\nwith a as (select client_id, driver_id, request_at from Trips where status in (\"cancelled_by_driver\",           \"cancelled_by_client\")\\n    and client_id in (select users_id from Users where banned = \"No\")\\n    and driver_id in (select users_id from Users where banned = \"No\")),\\n    \\nb as (select count(client_id) as total_users, request_at from Trips where\\n      client_id in (select users_id from Users where banned = \"No\")\\n      and driver_id in (select users_id from Users where banned = \"No\")\\n     group by request_at)\\n     \\nselect b.request_at as \"Day\", round((select count(a.client_id) from a where a.request_at = b.request_at)/b.total_users, 2) as \"Cancellation Rate\"\\nfrom b\\nwhere b.request_at between \"2013-10-01\" and \"2013-10-03\"\\ngroup by b.request_at\\n```",
                "solutionTags": [],
                "code": "```\\nwith a as (select client_id, driver_id, request_at from Trips where status in (\"cancelled_by_driver\",           \"cancelled_by_client\")\\n    and client_id in (select users_id from Users where banned = \"No\")\\n    and driver_id in (select users_id from Users where banned = \"No\")),\\n    \\nb as (select count(client_id) as total_users, request_at from Trips where\\n      client_id in (select users_id from Users where banned = \"No\")\\n      and driver_id in (select users_id from Users where banned = \"No\")\\n     group by request_at)\\n     \\nselect b.request_at as \"Day\", round((select count(a.client_id) from a where a.request_at = b.request_at)/b.total_users, 2) as \"Cancellation Rate\"\\nfrom b\\nwhere b.request_at between \"2013-10-01\" and \"2013-10-03\"\\ngroup by b.request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2322856,
                "title": "mysql-easiest-solution",
                "content": "```\\nSelect request_at as Day, \\nround (sum(case when status like \\'cancelled%\\' then 1 else 0 end)/count(status),2) as \"Cancellation Rate\"\\nfrom trips\\nwhere  request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nand driver_id not in (select users_id from users where banned=\\'Yes\\')\\nand client_id not in (select users_id from users where banned=\\'Yes\\')\\ngroup by 1\\n```",
                "solutionTags": [],
                "code": "```\\nSelect request_at as Day, \\nround (sum(case when status like \\'cancelled%\\' then 1 else 0 end)/count(status),2) as \"Cancellation Rate\"\\nfrom trips\\nwhere  request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nand driver_id not in (select users_id from users where banned=\\'Yes\\')\\nand client_id not in (select users_id from users where banned=\\'Yes\\')\\ngroup by 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2282651,
                "title": "solution-using-sum-case-when",
                "content": "CODE:\\n```\\nSELECT\\n    request_at AS Day,\\n    ROUND((SUM(CASE WHEN status != \\'completed\\' THEN 1 ELSE 0 END)/COUNT(DISTINCT id)),2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nWHERE request_at BETWEEN \\'2013-10-01\\'\\nAND \\'2013-10-03\\'\\nAND client_id NOT IN (\\n    SELECT\\n        users_id\\n    FROM Users\\n    WHERE banned = \\'Yes\\'\\n)\\nAND driver_id NOT IN (\\n    SELECT\\n        users_id\\n    FROM Users\\n    WHERE banned = \\'Yes\\'\\n)\\nGROUP BY request_at\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    request_at AS Day,\\n    ROUND((SUM(CASE WHEN status != \\'completed\\' THEN 1 ELSE 0 END)/COUNT(DISTINCT id)),2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nWHERE request_at BETWEEN \\'2013-10-01\\'\\nAND \\'2013-10-03\\'\\nAND client_id NOT IN (\\n    SELECT\\n        users_id\\n    FROM Users\\n    WHERE banned = \\'Yes\\'\\n)\\nAND driver_id NOT IN (\\n    SELECT\\n        users_id\\n    FROM Users\\n    WHERE banned = \\'Yes\\'\\n)\\nGROUP BY request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2211782,
                "title": "simple-solution",
                "content": "```\\nSELECT  \\n    request_at as Day, \\n    round(sum(case when a.status = \\'completed\\' then 0 else 1 end)/count(*),2) as \"Cancellation Rate\"\\nFROM\\n    trips a \\n    join users b on a.client_id=b.users_id\\n    join users c on a.driver_id=c.users_id\\n    WHERE b.banned=\\'No\\' and c.banned=\\'No\\' and a.request_at between \"2013-10-01\" and \"2013-10-03\"\\nGROUP BY request_at\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT  \\n    request_at as Day, \\n    round(sum(case when a.status = \\'completed\\' then 0 else 1 end)/count(*),2) as \"Cancellation Rate\"\\nFROM\\n    trips a \\n    join users b on a.client_id=b.users_id\\n    join users c on a.driver_id=c.users_id\\n    WHERE b.banned=\\'No\\' and c.banned=\\'No\\' and a.request_at between \"2013-10-01\" and \"2013-10-03\"\\nGROUP BY request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2177529,
                "title": "easy-mssql-partition-by",
                "content": "```\\nselect distinct request_at as Day,\\ncast(avg(case when status like \\'cancelled%\\' then 1.00 else 0 end) over (partition by request_at) as decimal(10,2)) as \\'Cancellation Rate\\'\\nfrom (\\n    select * from Trips \\n    where client_id not in (select users_id from Users where banned = \\'Yes\\')\\n    and driver_id not in (select users_id from Users where banned = \\'Yes\\')\\n    and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\n    )sub\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct request_at as Day,\\ncast(avg(case when status like \\'cancelled%\\' then 1.00 else 0 end) over (partition by request_at) as decimal(10,2)) as \\'Cancellation Rate\\'\\nfrom (\\n    select * from Trips \\n    where client_id not in (select users_id from Users where banned = \\'Yes\\')\\n    and driver_id not in (select users_id from Users where banned = \\'Yes\\')\\n    and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\n    )sub\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1979764,
                "title": "tsql-short-and-sweet-solution",
                "content": "MS SQL/tSQL based solution\\n\\nI was able to remove the subquery I had to pre-aggregate the counts of canceled and requested trips (to perform calc.). The trick was dealing with datatypes. I feel that I could make some small, further efficiency gains with datatype work, but this works well -- short, sweet, and effective.\\n\\nSELECT\\n    T.request_at AS [Day]\\n    ,CAST(CAST(COUNT(CASE WHEN T.status IN (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') THEN 1 ELSE NULL END) AS float)/CAST(COUNT(T.id) AS float) AS decimal(4,2)) AS [Cancellation Rate]\\n    FROM Trips T\\n    INNER JOIN Users U ON U.users_id = T.client_id AND U.banned = \\'No\\'\\n    INNER JOIN Users U2 ON U2.users_id = T.driver_id AND U2.banned = \\'No\\'\\n    WHERE T.request_at   BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    GROUP BY T.request_at",
                "solutionTags": [],
                "code": "MS SQL/tSQL based solution\\n\\nI was able to remove the subquery I had to pre-aggregate the counts of canceled and requested trips (to perform calc.). The trick was dealing with datatypes. I feel that I could make some small, further efficiency gains with datatype work, but this works well -- short, sweet, and effective.\\n\\nSELECT\\n    T.request_at AS [Day]\\n    ,CAST(CAST(COUNT(CASE WHEN T.status IN (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') THEN 1 ELSE NULL END) AS float)/CAST(COUNT(T.id) AS float) AS decimal(4,2)) AS [Cancellation Rate]\\n    FROM Trips T\\n    INNER JOIN Users U ON U.users_id = T.client_id AND U.banned = \\'No\\'\\n    INNER JOIN Users U2 ON U2.users_id = T.driver_id AND U2.banned = \\'No\\'\\n    WHERE T.request_at   BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    GROUP BY T.request_at",
                "codeTag": "Unknown"
            },
            {
                "id": 1948275,
                "title": "solution-with-explanation-and-breakdown",
                "content": "**Step 1:** we need trips only `BETWEEN` two dates: \\n```\\nSELECT * FROM `Trips`  WHERE `request_at` BETWEEN \"2013-10-01\" AND \"2013-10-03\";\\n```\\n\\n**Step 2:** We need to filter out those records which has banner client or banned driver. Here I am using inner join\\n\\n```\\nSELECT * FROM `Trips` A \\nINNER JOIN `Users` B ON A.client_id = B.users_id\\nINNER JOIN `Users` C ON A.driver_id = C.users_id\\nWHERE \\nB.banned = \"No\" AND \\nC.banned = \"No\" AND\\nA.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\";\\n```\\n\\n**Step 3:** Now we need to group them by requested date \\n\\n\\n```\\nSELECT * FROM `Trips` A \\nINNER JOIN `Users` B ON A.client_id = B.users_id\\nINNER JOIN `Users` C ON A.driver_id = C.users_id\\nWHERE \\nB.banned = \"No\" AND \\nC.banned = \"No\" AND\\nA.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nGROUP BY A.request_at;\\n```\\n\\n**Step 4:** Last step, we need to alias the date and calculate the cancellation rate. To do that I am using `CASE WHEN` . Logic is that couting id of not completed trips and similarly counting id of all grouped and filtered records. We should not count *. \\n```\\nSELECT A.request_at AS Day,\\nROUND(\\n    COUNT(CASE WHEN A.status != \"completed\" THEN A.id ELSE NULL END)/\\n    COUNT(`id`)\\n, 2) AS `Cancellation Rate`\\nFROM `Trips` A\\nINNER JOIN `Users` B ON A.client_id = B.users_id\\nINNER JOIN `Users` C ON A.driver_id = C.users_id\\nWHERE \\nB.banned = \"No\" AND \\nC.banned = \"No\" AND\\nA.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nGROUP BY A.request_at;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT * FROM `Trips`  WHERE `request_at` BETWEEN \"2013-10-01\" AND \"2013-10-03\";\\n```\n```\\nSELECT * FROM `Trips` A \\nINNER JOIN `Users` B ON A.client_id = B.users_id\\nINNER JOIN `Users` C ON A.driver_id = C.users_id\\nWHERE \\nB.banned = \"No\" AND \\nC.banned = \"No\" AND\\nA.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\";\\n```\n```\\nSELECT * FROM `Trips` A \\nINNER JOIN `Users` B ON A.client_id = B.users_id\\nINNER JOIN `Users` C ON A.driver_id = C.users_id\\nWHERE \\nB.banned = \"No\" AND \\nC.banned = \"No\" AND\\nA.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nGROUP BY A.request_at;\\n```\n```\\nSELECT A.request_at AS Day,\\nROUND(\\n    COUNT(CASE WHEN A.status != \"completed\" THEN A.id ELSE NULL END)/\\n    COUNT(`id`)\\n, 2) AS `Cancellation Rate`\\nFROM `Trips` A\\nINNER JOIN `Users` B ON A.client_id = B.users_id\\nINNER JOIN `Users` C ON A.driver_id = C.users_id\\nWHERE \\nB.banned = \"No\" AND \\nC.banned = \"No\" AND\\nA.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nGROUP BY A.request_at;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1914334,
                "title": "cte-used",
                "content": "```\\n# Write your MySQL query statement below\\nwith t1 as\\n(\\n    select client_id,driver_id,status,request_at\\n    from trips as t\\n    where client_id not in (select users_id from users where banned = \\'Yes\\')\\n    and driver_id not in (select users_id from users where banned = \\'Yes\\')\\n    and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\n    order by request_at asc\\n)\\n\\nselect request_at as Day, round(sum(if(status!=\\'completed\\',1,0))/sum(1),2) as \\'Cancellation Rate\\'\\nfrom t1\\ngroup by request_at\\n```\\n",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nwith t1 as\\n(\\n    select client_id,driver_id,status,request_at\\n    from trips as t\\n    where client_id not in (select users_id from users where banned = \\'Yes\\')\\n    and driver_id not in (select users_id from users where banned = \\'Yes\\')\\n    and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\n    order by request_at asc\\n)\\n\\nselect request_at as Day, round(sum(if(status!=\\'completed\\',1,0))/sum(1),2) as \\'Cancellation Rate\\'\\nfrom t1\\ngroup by request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1766145,
                "title": "easy-solution-everyday-sql-solution",
                "content": "```\\nselect request_at as Day, round(sum(if (cancel_ind = 1, 1, 0))/count(distinct id) , 2) as \\'Cancellation Rate\\'\\nfrom (\\nselect distinct id, request_at, \\ncase when status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\') then 1 else 0 end as cancel_ind\\nfrom Trips \\nwhere client_id not in (select distinct users_id from Users where banned = \\'Yes\\' and role = \\'client\\')\\nand driver_id not in (select distinct users_id from Users where banned = \\'Yes\\' and role = \\'driver\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\') as tbl\\ngroup by 1 \\norder by 1\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect request_at as Day, round(sum(if (cancel_ind = 1, 1, 0))/count(distinct id) , 2) as \\'Cancellation Rate\\'\\nfrom (\\nselect distinct id, request_at, \\ncase when status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\') then 1 else 0 end as cancel_ind\\nfrom Trips \\nwhere client_id not in (select distinct users_id from Users where banned = \\'Yes\\' and role = \\'client\\')\\nand driver_id not in (select distinct users_id from Users where banned = \\'Yes\\' and role = \\'driver\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\') as tbl\\ngroup by 1 \\norder by 1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1738550,
                "title": "easy-to-understand-mysql-no-cte",
                "content": "```\\nselect \\n    request_at as Day, \\n    round(sum(case when status like \\'cancelled%\\' then 1 else 0 end) / count(status) *1.0, 2) as \"Cancellation Rate\"\\nfrom Trips\\nwhere (client_id not in (select users_id from Users where banned = \\'Yes\\')) and\\n      (driver_id not in (select users_id from Users where banned = \\'Yes\\')) and\\n      request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\n    request_at as Day, \\n    round(sum(case when status like \\'cancelled%\\' then 1 else 0 end) / count(status) *1.0, 2) as \"Cancellation Rate\"\\nfrom Trips\\nwhere (client_id not in (select users_id from Users where banned = \\'Yes\\')) and\\n      (driver_id not in (select users_id from Users where banned = \\'Yes\\')) and\\n      request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1697996,
                "title": "solution-without-joins",
                "content": "Same outcome just another way without joins\\n\\n```\\nSELECT \\nt1.Day\\n,ROUND(SUM(t1.not_completed)/COUNT(*),2) AS \"Cancellation Rate\"\\nFROM\\n(SELECT \\n    t.request_at AS Day\\n    ,(CASE\\n        WHEN status<>\\'completed\\' THEN 1\\n        ELSE 0 END) AS not_completed\\n    \\n \\nFROM\\n Trips t\\nWHERE client_id IN (SELECT users_id FROM Users WHERE banned=\\'No\\' AND role=\\'client\\')\\n      AND driver_id IN (SELECT users_id FROM Users WHERE banned=\\'No\\' AND role=\\'driver\\')\\n        ) t1\\nWHERE (t1.Day BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\n\\nGROUP BY t1.Day\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\nt1.Day\\n,ROUND(SUM(t1.not_completed)/COUNT(*),2) AS \"Cancellation Rate\"\\nFROM\\n(SELECT \\n    t.request_at AS Day\\n    ,(CASE\\n        WHEN status<>\\'completed\\' THEN 1\\n        ELSE 0 END) AS not_completed\\n    \\n \\nFROM\\n Trips t\\nWHERE client_id IN (SELECT users_id FROM Users WHERE banned=\\'No\\' AND role=\\'client\\')\\n      AND driver_id IN (SELECT users_id FROM Users WHERE banned=\\'No\\' AND role=\\'driver\\')\\n        ) t1\\nWHERE (t1.Day BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\n\\nGROUP BY t1.Day\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1686531,
                "title": "mysql-easy-beginner-friendly-solution",
                "content": "First of all, try not to include our pre-assumptions about taxi system into the problem.\\n\\nHere,\\n1. Even the driver may be banned as suggested.\\n2. Cancellation rate is determined by day and not by the driver/user.\\n\\nSo, how do we get cancellation rate for each day?\\n\\ncount not completed trips for that day/ count total trips for that day\\n```\\nSELECT t.request_at as Day,\\nCOUNT(IF(status!=\\'completed\\', true, null))  /  COUNT(request_at) AS \"Cancellation Rate\"\\nFROM Trips t\\nGROUP BY t.request_at\\n```\\n\\nAs per question, we don\\'t have to include trips where either driver or client was banned. So, \\n\\nSELECT t.request_at as Day,\\nCOUNT(IF(status!=\\'completed\\', true, null))  /  COUNT(request_at) AS \"Cancellation Rate\"\\nFROM Trips t\\n```\\nJOIN Users driver ON driver.users_id = driver_id\\nJOIN Users client ON client.users_id = client_id\\nWHERE client.banned=\\'No\\'\\nAND driver.banned=\\'No\\'\\n```\\nGROUP BY t.request_at\\nORDER BY t.request_at\\n\\n\\n\\n\\nNow, as per quesition, we have to look only for  each day between \"2013-10-01\" and \"2013-10-03\". And Round Cancellation Rate to two decimal points.\\n\\nSELECT t.request_at as Day,\\n```ROUND(COUNT(IF(status!=\\'completed\\', true, null))  /  COUNT(*), 2) AS \"Cancellation Rate\"```\\nFROM Trips t\\n\\nJOIN Users driver ON driver.users_id = driver_id\\nJOIN Users client ON client.users_id = client_id\\n\\nWHERE client.banned=\\'No\\'\\nAND driver.banned=\\'No\\'\\n```AND t.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"```\\n\\nGROUP BY t.request_at\\nORDER BY t.request_at  \\t\\n\\nPlease do give a like, if you understood the solution and problem more clearly.\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT t.request_at as Day,\\nCOUNT(IF(status!=\\'completed\\', true, null))  /  COUNT(request_at) AS \"Cancellation Rate\"\\nFROM Trips t\\nGROUP BY t.request_at\\n```\n```\\nJOIN Users driver ON driver.users_id = driver_id\\nJOIN Users client ON client.users_id = client_id\\nWHERE client.banned=\\'No\\'\\nAND driver.banned=\\'No\\'\\n```\n```ROUND(COUNT(IF(status!=\\'completed\\', true, null))  /  COUNT(*), 2) AS \"Cancellation Rate\"```\n```AND t.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"```",
                "codeTag": "Unknown"
            },
            {
                "id": 1594318,
                "title": "fast-and-easy-mysql-solution",
                "content": "```\\nselect request_at as \"Day\", ROUND(SUM(CASE when t.status!= \\'completed\\' then 1 ELSE 0 END)/count(*), 2) as \"Cancellation Rate\"\\nfrom Trips t\\ninner join Users a on (a.users_id = t.client_id) and  (a.banned=\"No\")\\ninner join Users b on (b.users_id = t.driver_id) and  (b.banned=\"No\")\\nwhere request_at between \"2013-10-01\" AND \"2013-10-03\"\\ngroup by request_at;",
                "solutionTags": [],
                "code": "```\\nselect request_at as \"Day\", ROUND(SUM(CASE when t.status!= \\'completed\\' then 1 ELSE 0 END)/count(*), 2) as \"Cancellation Rate\"\\nfrom Trips t\\ninner join Users a on (a.users_id = t.client_id) and  (a.banned=\"No\")\\ninner join Users b on (b.users_id = t.driver_id) and  (b.banned=\"No\")\\nwhere request_at between \"2013-10-01\" AND \"2013-10-03\"\\ngroup by request_at;",
                "codeTag": "Unknown"
            },
            {
                "id": 1570279,
                "title": "old-solution-but-for-new-update-d",
                "content": "SELECT request_at AS DAY,\\nROUND(SUM(IF(status != \\'completed\\', 1, 0)) / COUNT(*), 2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nWHERE request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nAND client_id NOT IN (SELECT users_id FROM Users WHERE banned = \\'Yes\\')\\nAND driver_id NOT IN (SELECT users_id FROM Users WHERE banned = \\'Yes\\')\\nGROUP BY request_at;\\n",
                "solutionTags": [],
                "code": "SELECT request_at AS DAY,\\nROUND(SUM(IF(status != \\'completed\\', 1, 0)) / COUNT(*), 2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nWHERE request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nAND client_id NOT IN (SELECT users_id FROM Users WHERE banned = \\'Yes\\')\\nAND driver_id NOT IN (SELECT users_id FROM Users WHERE banned = \\'Yes\\')\\nGROUP BY request_at;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1539537,
                "title": "mssql-fast-solution-without-join",
                "content": "```\\nSELECT Request_at as Day,\\n       ROUND(COUNT(case when Status <> \\'completed\\' then 1 end) *1.00/ nullif(COUNT(*),0), 2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nWHERE (Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\n      AND Client_id NOT IN (SELECT Users_Id FROM Users WHERE Banned = \\'Yes\\')\\n      and Driver_Id Not IN (Select Users_Id from Users where Banned=\\'Yes\\')\\nGROUP BY Request_at;",
                "solutionTags": [],
                "code": "```\\nSELECT Request_at as Day,\\n       ROUND(COUNT(case when Status <> \\'completed\\' then 1 end) *1.00/ nullif(COUNT(*),0), 2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nWHERE (Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\n      AND Client_id NOT IN (SELECT Users_Id FROM Users WHERE Banned = \\'Yes\\')\\n      and Driver_Id Not IN (Select Users_Id from Users where Banned=\\'Yes\\')\\nGROUP BY Request_at;",
                "codeTag": "Unknown"
            },
            {
                "id": 1469886,
                "title": "mysql-code",
                "content": "Select T.Request_at as Day,\\nRound(sum(case when T.Status <> \\'completed\\' then 1 else 0 end)/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips T join Users U1 on t.Client_id = U1.Users_id \\njoin Users U2 on t.Driver_id = U2.Users_id\\nwhere t.Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nand U1.Banned = \\'No\\' and U2.Banned = \\'No\\'\\ngroup by 1;",
                "solutionTags": [],
                "code": "Select T.Request_at as Day,\\nRound(sum(case when T.Status <> \\'completed\\' then 1 else 0 end)/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips T join Users U1 on t.Client_id = U1.Users_id \\njoin Users U2 on t.Driver_id = U2.Users_id\\nwhere t.Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nand U1.Banned = \\'No\\' and U2.Banned = \\'No\\'\\ngroup by 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 1446977,
                "title": "simple",
                "content": "```\\nselect request_at day\\n    ,round(sum(case when status like \\'cancelled%\\' then 1 else 0 end)/NULLIF(count(id),0),2) as \"Cancellation Rate\"\\nfrom trips\\n-- unbanned users\\nwhere client_id not in (select users_id from users where banned = \\'Yes\\' and role = \\'client\\')\\n   and driver_id not in (select users_id from users where banned = \\'Yes\\' and role = \\'driver\\')\\n   and request_at between \\'2013-10-01\\' and \\'2013-10-03\\' -- between \"2013-10-01\" and \"2013-10-03\"\\ngroup by request_at\\norder by 1;\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect request_at day\\n    ,round(sum(case when status like \\'cancelled%\\' then 1 else 0 end)/NULLIF(count(id),0),2) as \"Cancellation Rate\"\\nfrom trips\\n-- unbanned users\\nwhere client_id not in (select users_id from users where banned = \\'Yes\\' and role = \\'client\\')\\n   and driver_id not in (select users_id from users where banned = \\'Yes\\' and role = \\'driver\\')\\n   and request_at between \\'2013-10-01\\' and \\'2013-10-03\\' -- between \"2013-10-01\" and \"2013-10-03\"\\ngroup by request_at\\norder by 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1353494,
                "title": "it-s-not-a-hard-one",
                "content": "```\\nWITH cte AS (\\nSELECT Client_Id, Driver_Id, Status, Request_at, \\n       CASE WHEN Status!=\\'completed\\' THEN 1 ELSE 0 END AS flag\\nFROM Trips\\nWHERE Request_at >= \\'2013-10-01\\' AND Request_at <= \\'2013-10-03\\'\\nAND Client_Id NOT IN (SELECT Users_Id FROM Users WHERE Banned=\\'Yes\\')\\nAND Driver_Id NOT IN (SELECT Users_Id FROM Users WHERE Banned=\\'Yes\\')\\n)\\n\\nSELECT Request_at AS Day, ROUND(SUM(flag) / COUNT(*), 2) AS \\'Cancellation Rate\\'\\nFROM cte\\nGROUP BY Request_at\\n```",
                "solutionTags": [],
                "code": "```\\nWITH cte AS (\\nSELECT Client_Id, Driver_Id, Status, Request_at, \\n       CASE WHEN Status!=\\'completed\\' THEN 1 ELSE 0 END AS flag\\nFROM Trips\\nWHERE Request_at >= \\'2013-10-01\\' AND Request_at <= \\'2013-10-03\\'\\nAND Client_Id NOT IN (SELECT Users_Id FROM Users WHERE Banned=\\'Yes\\')\\nAND Driver_Id NOT IN (SELECT Users_Id FROM Users WHERE Banned=\\'Yes\\')\\n)\\n\\nSELECT Request_at AS Day, ROUND(SUM(flag) / COUNT(*), 2) AS \\'Cancellation Rate\\'\\nFROM cte\\nGROUP BY Request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1320809,
                "title": "simple-mysql-no-joins",
                "content": "```\\nselect \\n    Request_at as Day, \\n    round(avg(case when Status=\\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\'\\nfrom Trips \\nwhere Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nand Client_Id in (select Users_Id from Users where Banned=\\'No\\')\\nand Driver_Id in (select Users_Id from Users where Banned=\\'No\\')\\ngroup by 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\n    Request_at as Day, \\n    round(avg(case when Status=\\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\'\\nfrom Trips \\nwhere Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nand Client_Id in (select Users_Id from Users where Banned=\\'No\\')\\nand Driver_Id in (select Users_Id from Users where Banned=\\'No\\')\\ngroup by 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1303969,
                "title": "solution-with-step-wise-ctes",
                "content": "```\\n# Write your MySQL query statement below\\nwith driver_data as(\\n    select  t.id,driver_id,t.status,t.request_at,\\n            u.Banned\\n    from trips t\\n    left join users u\\n    on t.driver_id = u.users_id\\n    where u.Banned = \\'No\\'\\n), -- selecting unbanned drivers\\n    \\nclient_data as(\\n    select  t.id,client_id,t.status,t.request_at,\\n            u.Banned\\n    from trips t\\n    left join users u\\n    on t.client_id = u.users_id\\n    where u.Banned = \\'No\\'\\n), -- selecting unbanned clients\\n\\nall_data as(\\n    select d.id,driver_id,client_id, d.status, d.request_at\\n           from client_data \\n           inner join driver_data d\\n            on d.id = client_data.id\\n),\\n\\ncanceled as(\\n    select \\n          request_at,\\n          sum(case when `status` like \\'cancelled%\\' then 1 else 0 end) canceled_trips \\n    from all_data\\n    group by request_at\\n    ),\\n    \\ntotal_req as(\\n    select  count(request_at) as requested_trips,\\n            request_at\\n    from all_data\\n    group by request_at\\n)\\n\\nselect\\n\\n    c.request_at as Day, round(canceled_trips/requested_trips,2) as `Cancellation Rate`\\n    from canceled c\\n    left join total_req t\\n    on c.request_at = t.request_at\\n    where c.request_at between \"2013-10-01\" and \"2013-10-03\"\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nwith driver_data as(\\n    select  t.id,driver_id,t.status,t.request_at,\\n            u.Banned\\n    from trips t\\n    left join users u\\n    on t.driver_id = u.users_id\\n    where u.Banned = \\'No\\'\\n), -- selecting unbanned drivers\\n    \\nclient_data as(\\n    select  t.id,client_id,t.status,t.request_at,\\n            u.Banned\\n    from trips t\\n    left join users u\\n    on t.client_id = u.users_id\\n    where u.Banned = \\'No\\'\\n), -- selecting unbanned clients\\n\\nall_data as(\\n    select d.id,driver_id,client_id, d.status, d.request_at\\n           from client_data \\n           inner join driver_data d\\n            on d.id = client_data.id\\n),\\n\\ncanceled as(\\n    select \\n          request_at,\\n          sum(case when `status` like \\'cancelled%\\' then 1 else 0 end) canceled_trips \\n    from all_data\\n    group by request_at\\n    ),\\n    \\ntotal_req as(\\n    select  count(request_at) as requested_trips,\\n            request_at\\n    from all_data\\n    group by request_at\\n)\\n\\nselect\\n\\n    c.request_at as Day, round(canceled_trips/requested_trips,2) as `Cancellation Rate`\\n    from canceled c\\n    left join total_req t\\n    on c.request_at = t.request_at\\n    where c.request_at between \"2013-10-01\" and \"2013-10-03\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1261488,
                "title": "mysql",
                "content": "with cte as(\\nselect Request_at,Status,count(Id) as c1 from Trips \\n    where Client_Id not in\\n    (select Users_Id from Users where Banned = \\'Yes\\' and Role = \\'client\\')\\n    and Driver_Id not in \\n    (select Users_Id from Users where Banned=\\'Yes\\' and Role = \\'driver\\')\\n    and Request_at between \"2013-10-01\" and \"2013-10-03\" \\n    group by Request_at,Status)\\n\\nselect Request_at as Day,\\nround(\\n(sum(case when Status like \\'cancelled%\\' then c1 else 0 end)/\\nsum(case when Request_at then c1 else 0 end)),2) as \\'Cancellation Rate\\'\\nfrom cte group by Request_at",
                "solutionTags": [],
                "code": "with cte as(\\nselect Request_at,Status,count(Id) as c1 from Trips \\n    where Client_Id not in\\n    (select Users_Id from Users where Banned = \\'Yes\\' and Role = \\'client\\')\\n    and Driver_Id not in \\n    (select Users_Id from Users where Banned=\\'Yes\\' and Role = \\'driver\\')\\n    and Request_at between \"2013-10-01\" and \"2013-10-03\" \\n    group by Request_at,Status)\\n\\nselect Request_at as Day,\\nround(\\n(sum(case when Status like \\'cancelled%\\' then c1 else 0 end)/\\nsum(case when Request_at then c1 else 0 end)),2) as \\'Cancellation Rate\\'\\nfrom cte group by Request_at",
                "codeTag": "Unknown"
            },
            {
                "id": 1244093,
                "title": "simple",
                "content": "```\\nselect T.request_at as Day, \\nround(sum(case when T.status != \"completed\" then 1 else 0 end)/ count(T.Id),2) as \"Cancellation Rate\"\\nfrom Trips T\\nwhere T.request_at between \"2013-10-01\" and \"2013-10-03\"\\n        and T.Client_id in (Select Users_Id from Users where banned = \\'No\\' )     \\n        and T.Driver_Id in (Select Users_Id from Users where banned = \\'No\\' )  \\ngroup by T.request_at",
                "solutionTags": [],
                "code": "```\\nselect T.request_at as Day, \\nround(sum(case when T.status != \"completed\" then 1 else 0 end)/ count(T.Id),2) as \"Cancellation Rate\"\\nfrom Trips T\\nwhere T.request_at between \"2013-10-01\" and \"2013-10-03\"\\n        and T.Client_id in (Select Users_Id from Users where banned = \\'No\\' )     \\n        and T.Driver_Id in (Select Users_Id from Users where banned = \\'No\\' )  \\ngroup by T.request_at",
                "codeTag": "Unknown"
            },
            {
                "id": 1241181,
                "title": "sql-server-simple",
                "content": "MS SQL Server three options:\\n\\n1. Simple but will get slow with huge dataset:\\n```\\n/* Write your T-SQL query statement below */\\nselect \\n    Request_at Day,\\n    cast( \\n        sum(case when Status like \\'cancelled%\\' then 1.0 else 0.0 end)/count(1)\\n    AS DECIMAL(10,2)) \\'Cancellation Rate\\'\\nfrom Trips t\\nwhere Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    and Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\n    and Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\ngroup by Request_at\\norder by Request_at\\n```\\n2. My Favourite:\\n```\\nWITH CTE AS(\\n    select Users_Id from Users where Banned = \\'Yes\\'\\n)\\nselect \\n    Request_at Day,\\n    cast( \\n        sum(case when Status like \\'cancelled%\\' then 1.0 else 0.0 end)/count(1)\\n    AS DECIMAL(10,2)) \\'Cancellation Rate\\'\\nfrom Trips t\\nwhere Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    and Client_Id not in (select Users_Id from CTE)\\n    and Driver_Id not in (select Users_Id from CTE)\\ngroup by Request_at\\norder by Request_at\\n```\\n3. With Joins:\\n```\\nselect \\n    Request_at Day,\\n    cast( \\n       sum(case when Status like \\'cancelled%\\' then 1.0 else 0.0 end)/count(1)\\n    AS DECIMAL(10,2)) \\'Cancellation Rate\\'\\nfrom Trips t\\njoin Users uu\\n    on t.Client_Id = uu.Users_Id and uu.Banned = \\'No\\'\\njoin Users ud\\n    on t.Driver_Id = ud.Users_Id and ud.Banned = \\'No\\'\\nwhere t.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\ngroup by Request_at\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect \\n    Request_at Day,\\n    cast( \\n        sum(case when Status like \\'cancelled%\\' then 1.0 else 0.0 end)/count(1)\\n    AS DECIMAL(10,2)) \\'Cancellation Rate\\'\\nfrom Trips t\\nwhere Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    and Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\n    and Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\ngroup by Request_at\\norder by Request_at\\n```\n```\\nWITH CTE AS(\\n    select Users_Id from Users where Banned = \\'Yes\\'\\n)\\nselect \\n    Request_at Day,\\n    cast( \\n        sum(case when Status like \\'cancelled%\\' then 1.0 else 0.0 end)/count(1)\\n    AS DECIMAL(10,2)) \\'Cancellation Rate\\'\\nfrom Trips t\\nwhere Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    and Client_Id not in (select Users_Id from CTE)\\n    and Driver_Id not in (select Users_Id from CTE)\\ngroup by Request_at\\norder by Request_at\\n```\n```\\nselect \\n    Request_at Day,\\n    cast( \\n       sum(case when Status like \\'cancelled%\\' then 1.0 else 0.0 end)/count(1)\\n    AS DECIMAL(10,2)) \\'Cancellation Rate\\'\\nfrom Trips t\\njoin Users uu\\n    on t.Client_Id = uu.Users_Id and uu.Banned = \\'No\\'\\njoin Users ud\\n    on t.Driver_Id = ud.Users_Id and ud.Banned = \\'No\\'\\nwhere t.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\ngroup by Request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1239722,
                "title": "intuitive-mysql-solution-using-cte",
                "content": "```\\nWITH cte as (\\n    SELECT DISTINCT Users_Id\\n    FROM Users\\n    WHERE Banned = \\'No\\'\\n)\\n\\nSELECT \\n    Request_at as Day,\\n    ROUND(SUM(CASE WHEN t.Status = \\'cancelled_by_driver\\' OR t.Status = \\'cancelled_by_client\\' THEN 1 ELSE 0 END) / COUNT(*), 2) as \\'Cancellation Rate\\'\\nFROM Trips t\\nWHERE t.Client_Id IN (SELECT Users_Id FROM cte)\\n    AND t.Driver_Id IN (SELECT Users_Id FROM cte)\\nGROUP BY t.Request_at\\nHAVING t.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n```",
                "solutionTags": [],
                "code": "```\\nWITH cte as (\\n    SELECT DISTINCT Users_Id\\n    FROM Users\\n    WHERE Banned = \\'No\\'\\n)\\n\\nSELECT \\n    Request_at as Day,\\n    ROUND(SUM(CASE WHEN t.Status = \\'cancelled_by_driver\\' OR t.Status = \\'cancelled_by_client\\' THEN 1 ELSE 0 END) / COUNT(*), 2) as \\'Cancellation Rate\\'\\nFROM Trips t\\nWHERE t.Client_Id IN (SELECT Users_Id FROM cte)\\n    AND t.Driver_Id IN (SELECT Users_Id FROM cte)\\nGROUP BY t.Request_at\\nHAVING t.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1163358,
                "title": "simple-mysql-solution-using-sum-and-count",
                "content": "```\\nselect Request_at as Day, round(sum(Status <> \\'completed\\')/count(Id),2) as `Cancellation Rate`\\nfrom Trips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\n    and Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\n    and Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Day\\norder by Day\\n```",
                "solutionTags": [],
                "code": "```\\nselect Request_at as Day, round(sum(Status <> \\'completed\\')/count(Id),2) as `Cancellation Rate`\\nfrom Trips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\n    and Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\n    and Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Day\\norder by Day\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1157446,
                "title": "mysql-intuitive-cte-solution",
                "content": "```\\nWITH Sub AS (\\n    SELECT *\\n    FROM\\n        Trips\\n    WHERE\\n        Client_id IN (SELECT Users_id FROM Users WHERE Banned = \\'No\\')\\n        AND\\n        Driver_id IN (SELECT Users_id FROM Users WHERE Banned = \\'No\\')\\n        AND\\n        Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n)\\n\\nSELECT\\n    Sub.Request_at AS \\'Day\\',\\n    ROUND(SUM(CASE WHEN Sub.Status = \\'cancelled_by_driver\\' OR Sub.Status = \\'cancelled_by_client\\' THEN 1 ELSE 0 END) / COUNT(*), 2) AS \\'Cancellation Rate\\'\\nFROM\\n    Sub\\nGROUP BY\\n    Sub.Request_at\\n;\\n```",
                "solutionTags": [],
                "code": "```\\nWITH Sub AS (\\n    SELECT *\\n    FROM\\n        Trips\\n    WHERE\\n        Client_id IN (SELECT Users_id FROM Users WHERE Banned = \\'No\\')\\n        AND\\n        Driver_id IN (SELECT Users_id FROM Users WHERE Banned = \\'No\\')\\n        AND\\n        Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n)\\n\\nSELECT\\n    Sub.Request_at AS \\'Day\\',\\n    ROUND(SUM(CASE WHEN Sub.Status = \\'cancelled_by_driver\\' OR Sub.Status = \\'cancelled_by_client\\' THEN 1 ELSE 0 END) / COUNT(*), 2) AS \\'Cancellation Rate\\'\\nFROM\\n    Sub\\nGROUP BY\\n    Sub.Request_at\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1150796,
                "title": "mysql-solution-using-joins",
                "content": "```\\nSELECT t.request_at as Day, \\nROUND(SUM(CASE WHEN t.status LIKE \"cancelled%\" THEN 1 ELSE 0 END)/COUNT(t.status),2) as \\'Cancellation Rate\\'\\nFROM Trips t\\nJOIN Users u1\\nON t.Client_Id = u1.Users_Id AND u1.Banned=\\'No\\'\\nJOIN Users u2\\nON t.Driver_Id = u2.Users_Id AND u2.Banned=\\'No\\'\\nWHERE Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY t.request_at\\nORDER BY Request_at",
                "solutionTags": [],
                "code": "```\\nSELECT t.request_at as Day, \\nROUND(SUM(CASE WHEN t.status LIKE \"cancelled%\" THEN 1 ELSE 0 END)/COUNT(t.status),2) as \\'Cancellation Rate\\'\\nFROM Trips t\\nJOIN Users u1\\nON t.Client_Id = u1.Users_Id AND u1.Banned=\\'No\\'\\nJOIN Users u2\\nON t.Driver_Id = u2.Users_Id AND u2.Banned=\\'No\\'\\nWHERE Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY t.request_at\\nORDER BY Request_at",
                "codeTag": "Unknown"
            },
            {
                "id": 1137706,
                "title": "with-temporary-table-to-make-queries-from",
                "content": "Not the most effective code, but works =) \\n1. creating temporary table with no banned users.\\n2. making queries to the table to count completed and not completed trips \\n```\\nwith tmp as (\\nselect t.Status, t.request_at, count(*) as cn\\nfrom trips t\\nleft join users u1 on t.client_id = u1.users_id\\nleft join users u2 on t.driver_id = u2.users_id\\nwhere u1.Banned in (\\'No\\') and u2.Banned in (\\'No\\')\\nand t.request_at between \"2013-10-01\" and \"2013-10-03\"\\ngroup by t.Status, t.request_at)\\n\\n\\nselect t1.request_at as day,\\nround(ifnull(t2.c2 / sum(t1.cn), 0), 2) as \\'Cancellation Rate\\'\\nfrom tmp t1\\nleft join \\n    (select request_at, sum(cn) as c2 \\n     from tmp\\n     where tmp.status != \"completed\"\\n     group by request_at \\n) as t2 on t1.request_at = t2.request_at\\ngroup by t1.request_at\\n```",
                "solutionTags": [],
                "code": "```\\nwith tmp as (\\nselect t.Status, t.request_at, count(*) as cn\\nfrom trips t\\nleft join users u1 on t.client_id = u1.users_id\\nleft join users u2 on t.driver_id = u2.users_id\\nwhere u1.Banned in (\\'No\\') and u2.Banned in (\\'No\\')\\nand t.request_at between \"2013-10-01\" and \"2013-10-03\"\\ngroup by t.Status, t.request_at)\\n\\n\\nselect t1.request_at as day,\\nround(ifnull(t2.c2 / sum(t1.cn), 0), 2) as \\'Cancellation Rate\\'\\nfrom tmp t1\\nleft join \\n    (select request_at, sum(cn) as c2 \\n     from tmp\\n     where tmp.status != \"completed\"\\n     group by request_at \\n) as t2 on t1.request_at = t2.request_at\\ngroup by t1.request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1120277,
                "title": "easy-and-straight-forward",
                "content": "The only difference between window request and cancel is the requirement for status in WHERE.\\nThis answer is easy and straight forward, nothing fancy or too complicated involved. \\n```\\nWITH request AS\\n(\\n    SELECT Request_at Day, COUNT(*) ttl_req \\n    FROM Trips t\\n    JOIN Users u1 ON (t.Client_Id = u1.Users_Id)\\n    JOIN Users u2 ON (t.Driver_Id = u2.Users_Id)\\n    WHERE u1.Banned = \\'No\\' AND u2.Banned = \\'No\\' \\n          AND Request_at >= \\'2013-10-01\\' AND Request_at <= \\'2013-10-03\\'\\n    GROUP BY 1\\n),\\ncancel AS\\n(\\n    SELECT Request_at Day, COUNT(*) ttl_cal \\n    FROM Trips t\\n    JOIN Users u1 ON (t.Client_Id = u1.Users_Id)\\n    JOIN Users u2 ON (t.Driver_Id = u2.Users_Id)\\n    WHERE u1.Banned = \\'No\\' AND u2.Banned = \\'No\\' \\n          AND Request_at >= \\'2013-10-01\\' AND Request_at <= \\'2013-10-03\\'\\n          AND (Status = \\'cancelled_by_driver\\' OR Status = \\'cancelled_by_client\\')\\n    GROUP BY 1\\n)\\nSELECT r.Day, COALESCE(ROUND(ttl_cal/ttl_req, 2), 0.00) AS \"Cancellation Rate\"\\nFROM request r\\nLEFT JOIN cancel c ON r.Day = c.Day\\n```",
                "solutionTags": [],
                "code": "```\\nWITH request AS\\n(\\n    SELECT Request_at Day, COUNT(*) ttl_req \\n    FROM Trips t\\n    JOIN Users u1 ON (t.Client_Id = u1.Users_Id)\\n    JOIN Users u2 ON (t.Driver_Id = u2.Users_Id)\\n    WHERE u1.Banned = \\'No\\' AND u2.Banned = \\'No\\' \\n          AND Request_at >= \\'2013-10-01\\' AND Request_at <= \\'2013-10-03\\'\\n    GROUP BY 1\\n),\\ncancel AS\\n(\\n    SELECT Request_at Day, COUNT(*) ttl_cal \\n    FROM Trips t\\n    JOIN Users u1 ON (t.Client_Id = u1.Users_Id)\\n    JOIN Users u2 ON (t.Driver_Id = u2.Users_Id)\\n    WHERE u1.Banned = \\'No\\' AND u2.Banned = \\'No\\' \\n          AND Request_at >= \\'2013-10-01\\' AND Request_at <= \\'2013-10-03\\'\\n          AND (Status = \\'cancelled_by_driver\\' OR Status = \\'cancelled_by_client\\')\\n    GROUP BY 1\\n)\\nSELECT r.Day, COALESCE(ROUND(ttl_cal/ttl_req, 2), 0.00) AS \"Cancellation Rate\"\\nFROM request r\\nLEFT JOIN cancel c ON r.Day = c.Day\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1020993,
                "title": "simple-and-easy-to-understand",
                "content": "```\\nSELECT\\n    T.REQUEST_AT AS DAY,\\n    ROUND(SUM(CASE WHEN STATUS LIKE \\'cancelled%\\' THEN 1 ELSE 0 END) / COUNT(*), 2) AS \"CANCELLATION RATE\"\\nFROM\\n    TRIPS T \\n    JOIN USERS C ON (T.CLIENT_ID = C.USERS_ID)\\n    JOIN USERS D ON (T.CLIENT_ID = D.USERS_ID)\\nWHERE\\n    C.BANNED = \\'No\\' AND\\n    D.BANNED = \\'No\\' AND\\n    T.REQUEST_AT BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY\\n    T.REQUEST_AT\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    T.REQUEST_AT AS DAY,\\n    ROUND(SUM(CASE WHEN STATUS LIKE \\'cancelled%\\' THEN 1 ELSE 0 END) / COUNT(*), 2) AS \"CANCELLATION RATE\"\\nFROM\\n    TRIPS T \\n    JOIN USERS C ON (T.CLIENT_ID = C.USERS_ID)\\n    JOIN USERS D ON (T.CLIENT_ID = D.USERS_ID)\\nWHERE\\n    C.BANNED = \\'No\\' AND\\n    D.BANNED = \\'No\\' AND\\n    T.REQUEST_AT BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY\\n    T.REQUEST_AT\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 955395,
                "title": "really-long-but-easy-mysql",
                "content": "```\\nWITH NOT_BANNED AS\\n(\\n    SELECT t.*\\n    FROM Trips t LEFT JOIN Users u1\\n    ON t.Client_Id = u1.Users_Id\\n    JOIN USers u2\\n    ON t.Driver_Id = u2.Users_Id\\n    WHERE u1.Banned NOT IN (\\'Yes\\')\\n    AND Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ORDER BY Request_at ASC\\n) , TOTAL_TRIP_PER_DAY AS\\n(\\n    SELECT Request_at, COUNT(*) as total_trips\\n    FROM Trips \\n    WHERE Id IN (SELECT Id FROM NOT_BANNED)\\n    GROUP BY 1\\n\\n) , UNBANNED_TRIP AS\\n(\\n    SELECT Request_at, COUNT(*) as unbanned_trips\\n    FROM NOT_BANNED\\n    WHERE Status IN (\\'cancelled_by_driver\\',\\'cancelled_by_client\\')\\n    GROUP BY 1\\n), FINAL_TABLE AS \\n(\\n    SELECT a.Request_at, b.unbanned_trips as UT, a.total_trips as TT\\n    FROM TOTAL_TRIP_PER_DAY a LEFT JOIN UNBANNED_TRIP b\\n    ON a.Request_at = b.Request_at\\n)\\nSELECT Request_at as Day, ROUND(COALESCE(UT / TT,0),2) as `Cancellation Rate`\\nFROM FINAL_TABLE\\n\\n```",
                "solutionTags": [],
                "code": "```\\nWITH NOT_BANNED AS\\n(\\n    SELECT t.*\\n    FROM Trips t LEFT JOIN Users u1\\n    ON t.Client_Id = u1.Users_Id\\n    JOIN USers u2\\n    ON t.Driver_Id = u2.Users_Id\\n    WHERE u1.Banned NOT IN (\\'Yes\\')\\n    AND Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ORDER BY Request_at ASC\\n) , TOTAL_TRIP_PER_DAY AS\\n(\\n    SELECT Request_at, COUNT(*) as total_trips\\n    FROM Trips \\n    WHERE Id IN (SELECT Id FROM NOT_BANNED)\\n    GROUP BY 1\\n\\n) , UNBANNED_TRIP AS\\n(\\n    SELECT Request_at, COUNT(*) as unbanned_trips\\n    FROM NOT_BANNED\\n    WHERE Status IN (\\'cancelled_by_driver\\',\\'cancelled_by_client\\')\\n    GROUP BY 1\\n), FINAL_TABLE AS \\n(\\n    SELECT a.Request_at, b.unbanned_trips as UT, a.total_trips as TT\\n    FROM TOTAL_TRIP_PER_DAY a LEFT JOIN UNBANNED_TRIP b\\n    ON a.Request_at = b.Request_at\\n)\\nSELECT Request_at as Day, ROUND(COALESCE(UT / TT,0),2) as `Cancellation Rate`\\nFROM FINAL_TABLE\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 881074,
                "title": "easy-to-understand-single-where-clause",
                "content": "Easy to understand single where clause.\\n```\\nSELECT request_at \\'Day\\', \\n       Round(( Sum(status LIKE \"%cancelled%\") / Count(*) ), 2)  \\'Cancellation Rate\\' \\nFROM   trips \\nWHERE  ( client_id IN (SELECT users_id \\n                       FROM   users \\n                       WHERE  banned = \\'No\\') \\n         AND driver_id IN (SELECT users_id \\n                           FROM   users \\n                           WHERE  banned = \\'No\\') ) \\n       AND request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\' \\nGROUP  BY request_at \\nORDER  BY request_at \\n\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT request_at \\'Day\\', \\n       Round(( Sum(status LIKE \"%cancelled%\") / Count(*) ), 2)  \\'Cancellation Rate\\' \\nFROM   trips \\nWHERE  ( client_id IN (SELECT users_id \\n                       FROM   users \\n                       WHERE  banned = \\'No\\') \\n         AND driver_id IN (SELECT users_id \\n                           FROM   users \\n                           WHERE  banned = \\'No\\') ) \\n       AND request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\' \\nGROUP  BY request_at \\nORDER  BY request_at \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 874248,
                "title": "mysql-solution",
                "content": "```\\nSELECT Request_at AS \\'Day\\', ROUND(SUM(CASE WHEN Status LIKE \\'cancelled%\\' THEN 1 ELSE 0 END) / COUNT(*), 2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nWHERE Client_Id IN (SELECT Users_Id FROM Users WHERE Banned = \\'No\\') \\nAND Driver_Id IN (SELECT Users_Id FROM Users WHERE Banned = \\'No\\') \\nAND Request_at BETWEEN CAST(\\'2013-10-01\\' AS DATE) AND CAST(\\'2013-10-03\\' AS DATE)\\nGROUP BY Request_at;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Request_at AS \\'Day\\', ROUND(SUM(CASE WHEN Status LIKE \\'cancelled%\\' THEN 1 ELSE 0 END) / COUNT(*), 2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nWHERE Client_Id IN (SELECT Users_Id FROM Users WHERE Banned = \\'No\\') \\nAND Driver_Id IN (SELECT Users_Id FROM Users WHERE Banned = \\'No\\') \\nAND Request_at BETWEEN CAST(\\'2013-10-01\\' AS DATE) AND CAST(\\'2013-10-03\\' AS DATE)\\nGROUP BY Request_at;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 851250,
                "title": "easy-solution",
                "content": "select request_at as Day,\\nround((sum(t.status = \\'cancelled_by_driver\\')+sum(t.status = \\'cancelled_by_client\\'))/count(status), 2) as \\'Cancellation Rate\\'\\nfrom trips t \\njoin users u1 on t.client_id = u1.users_id\\njoin users u2 on t.driver_id = u2.users_id\\nwhere u1.banned = \\'No\\' and u2.banned = \\'No\\'\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at;",
                "solutionTags": [],
                "code": "select request_at as Day,\\nround((sum(t.status = \\'cancelled_by_driver\\')+sum(t.status = \\'cancelled_by_client\\'))/count(status), 2) as \\'Cancellation Rate\\'\\nfrom trips t \\njoin users u1 on t.client_id = u1.users_id\\njoin users u2 on t.driver_id = u2.users_id\\nwhere u1.banned = \\'No\\' and u2.banned = \\'No\\'\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at;",
                "codeTag": "Unknown"
            },
            {
                "id": 811448,
                "title": "mysql-solution-no-subqueries",
                "content": "```\\nSELECT t.request_at as Day, ROUND(AVG(case when t.status=\\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\'\\nFROM trips as t\\nJOIN users as u1 ON t.client_id=u1.users_id\\nJOIN users as u2 ON t.driver_id=u2.users_id\\nWHERE u1.banned=\\'No\\' and u2.banned=\\'No\\' and t.request_at BETWEEN \\'2013-10-01\\' and \\'2013-10-03\\'\\nGROUP BY t.request_at\\nORDER BY t.request_at\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT t.request_at as Day, ROUND(AVG(case when t.status=\\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\'\\nFROM trips as t\\nJOIN users as u1 ON t.client_id=u1.users_id\\nJOIN users as u2 ON t.driver_id=u2.users_id\\nWHERE u1.banned=\\'No\\' and u2.banned=\\'No\\' and t.request_at BETWEEN \\'2013-10-01\\' and \\'2013-10-03\\'\\nGROUP BY t.request_at\\nORDER BY t.request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 797625,
                "title": "two-methods-join-and-subquery",
                "content": "Method 1 JOIN\\n```\\nSELECT t.Request_at AS Day, ROUND(SUM(IF(t.Status != \"completed\",1,0))/COUNT(t.Id),2) AS \\'Cancellation Rate\\'\\nFROM Trips t\\nJOIN Users u1 ON u1.Users_ID = t.Client_Id\\nJOIN Users u2 ON u2.Users_ID = t.Driver_Id\\nWHERE u1.Banned != \"Yes\" AND u2.Banned != \"Yes\"\\nGROUP BY t.Request_at\\nHAVING Day >= \\'2013-10-01\\' AND Day <= \\'2013-10-03\\'\\n#HAVING Day BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nORDER BY Day\\n```\\n\\nMethod 2 Subquery\\n```\\nSELECT t.Request_at AS Day, ROUND(SUM(IF(t.Status != \"completed\",1,0))/COUNT(t.Id),2) AS \\'Cancellation Rate\\'\\nFROM Trips t\\nWHERE t.Client_Id NOT IN (SELECT Users_ID FROM Users WHERE Banned = \"Yes\") AND\\n      t.Driver_Id NOT IN (SELECT Users_ID FROM Users WHERE Banned = \"Yes\")\\nGROUP BY t.Request_at\\nHAVING Day >= \\'2013-10-01\\' AND Day <= \\'2013-10-03\\';\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT t.Request_at AS Day, ROUND(SUM(IF(t.Status != \"completed\",1,0))/COUNT(t.Id),2) AS \\'Cancellation Rate\\'\\nFROM Trips t\\nJOIN Users u1 ON u1.Users_ID = t.Client_Id\\nJOIN Users u2 ON u2.Users_ID = t.Driver_Id\\nWHERE u1.Banned != \"Yes\" AND u2.Banned != \"Yes\"\\nGROUP BY t.Request_at\\nHAVING Day >= \\'2013-10-01\\' AND Day <= \\'2013-10-03\\'\\n#HAVING Day BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nORDER BY Day\\n```\n```\\nSELECT t.Request_at AS Day, ROUND(SUM(IF(t.Status != \"completed\",1,0))/COUNT(t.Id),2) AS \\'Cancellation Rate\\'\\nFROM Trips t\\nWHERE t.Client_Id NOT IN (SELECT Users_ID FROM Users WHERE Banned = \"Yes\") AND\\n      t.Driver_Id NOT IN (SELECT Users_ID FROM Users WHERE Banned = \"Yes\")\\nGROUP BY t.Request_at\\nHAVING Day >= \\'2013-10-01\\' AND Day <= \\'2013-10-03\\';\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 770190,
                "title": "simple-solution-0-no-join-runs-fast",
                "content": "Curious any ways to make this faster but feeling chuffed with this one\\n```\\nSELECT request_at as Day, round(SUM(case when Status = \"completed\" then 0 else 1 end)/COUNT(*), 2) as \"Cancellation Rate\"\\nFROM trips\\nWHERE \\n  client_id not in (SELECT users_id from users where banned=\"Yes\") AND \\n  driver_id not in (SELECT users_id from users where banned=\"Yes\") AND \\n  request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nGroup by 1\\norder by 1",
                "solutionTags": [],
                "code": "Curious any ways to make this faster but feeling chuffed with this one\\n```\\nSELECT request_at as Day, round(SUM(case when Status = \"completed\" then 0 else 1 end)/COUNT(*), 2) as \"Cancellation Rate\"\\nFROM trips\\nWHERE \\n  client_id not in (SELECT users_id from users where banned=\"Yes\") AND \\n  driver_id not in (SELECT users_id from users where banned=\"Yes\") AND \\n  request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nGroup by 1\\norder by 1",
                "codeTag": "Unknown"
            },
            {
                "id": 766289,
                "title": "ms-sql-server-solution",
                "content": "```\\nselect\\n    t1.Request_at Day,\\n    cast(sum(case \\n        when\\n            t1.Status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\') \\n        then \\n            1.0 \\n        else\\n            0.0\\n       end) / count(*) as decimal(10, 2)) [Cancellation Rate]\\n    \\nfrom\\n    Trips t1\\n\\njoin Users t2 on t1.Client_Id = t2.Users_Id and t2.Banned = \\'No\\'\\njoin Users t3 on t1.Driver_Id = t3.Users_Id and t3.Banned = \\'No\\'\\n\\nwhere \\n    t1.Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\n\\ngroup by\\n    Request_at\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\n    t1.Request_at Day,\\n    cast(sum(case \\n        when\\n            t1.Status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\') \\n        then \\n            1.0 \\n        else\\n            0.0\\n       end) / count(*) as decimal(10, 2)) [Cancellation Rate]\\n    \\nfrom\\n    Trips t1\\n\\njoin Users t2 on t1.Client_Id = t2.Users_Id and t2.Banned = \\'No\\'\\njoin Users t3 on t1.Driver_Id = t3.Users_Id and t3.Banned = \\'No\\'\\n\\nwhere \\n    t1.Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\n\\ngroup by\\n    Request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 739539,
                "title": "just-three-statement-and-beats-100-users-d",
                "content": "```\\nselect request_at Day, ROUND(AVG(status like \\'cancelled%\\'), 2) \\'Cancellation Rate\\'\\nfrom Trips \\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\' \\nand \\'no\\' = all(select Banned from Users where Users_id in (client_id, driver_id))\\ngroup by 1\\norder by 1;",
                "solutionTags": [],
                "code": "```\\nselect request_at Day, ROUND(AVG(status like \\'cancelled%\\'), 2) \\'Cancellation Rate\\'\\nfrom Trips \\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\' \\nand \\'no\\' = all(select Banned from Users where Users_id in (client_id, driver_id))\\ngroup by 1\\norder by 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 529636,
                "title": "no-joins-98-35-runtime-100-memory-9-lines",
                "content": "```\\nSELECT U.Request_at as Day, ROUND((sum(U.Is_Canceled) / count(U.Id)),2) as \\'Cancellation Rate\\'\\nFROM (\\n    SELECT\\n        Id, Status, Request_at,\\n        (CASE WHEN Status = \\'completed\\' THEN 0 ELSE 1 END) Is_Canceled\\n    FROM\\n        Trips\\n    WHERE\\n        Client_Id IN (SELECT Users_Id from Users WHERE Banned = \\'No\\')\\n    AND\\n        Driver_Id IN (SELECT Users_Id from Users WHERE Banned = \\'No\\')\\n    AND\\n        Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) U\\nGROUP BY U.Request_at\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT U.Request_at as Day, ROUND((sum(U.Is_Canceled) / count(U.Id)),2) as \\'Cancellation Rate\\'\\nFROM (\\n    SELECT\\n        Id, Status, Request_at,\\n        (CASE WHEN Status = \\'completed\\' THEN 0 ELSE 1 END) Is_Canceled\\n    FROM\\n        Trips\\n    WHERE\\n        Client_Id IN (SELECT Users_Id from Users WHERE Banned = \\'No\\')\\n    AND\\n        Driver_Id IN (SELECT Users_Id from Users WHERE Banned = \\'No\\')\\n    AND\\n        Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) U\\nGROUP BY U.Request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 524496,
                "title": "readable-soln-using-sum-and-cast-to-identify-cancelled",
                "content": "first i used a `with` clause to define the aggregation table, where i count the total trips and the number of cancelled trips. \\n\\ni explicitly identified cancelled trips using `cast`, which i think is better than using `!= \\'completed\\'` (could have also used \\'substring()\\')\\n\\nfinally, i used an `inner join` instead of a `left join` because that\\'s how to enforce the filtering of the banned users.\\n\\n```\\nwith trip_agg as (\\n\\tselect \\n\\t\\tcount(t.Id) as total_trips,\\n\\t\\tt.Request_at as day,\\n\\t\\tsum(\\n\\t\\t\\tcase when cast(t.Status as char(9)) = \\'cancelled\\' then 1\\n\\t\\t\\telse 0 end) as num_cancelled\\n\\tfrom Trips t\\n\\tinner join Users u1\\n\\t  on u1.Users_Id = t.Client_id\\n\\t and u1.Banned <> \\'Yes\\'\\n\\tinner join Users u2\\n\\t  on u2.Users_Id = t.Driver_id\\n\\t and u2.Banned <> \\'Yes\\'\\n\\tgroup by t.Request_at\\n)\\n\\nselect day as \"Day\",\\n\\t   round( num_cancelled*1.0 / total_trips, 2 ) as \"Cancellation Rate\"\\nfrom trip_agg a\\nwhere day between \\'2013-10-01\\' and \\'2013-10-03\\'\\norder by day\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nwith trip_agg as (\\n\\tselect \\n\\t\\tcount(t.Id) as total_trips,\\n\\t\\tt.Request_at as day,\\n\\t\\tsum(\\n\\t\\t\\tcase when cast(t.Status as char(9)) = \\'cancelled\\' then 1\\n\\t\\t\\telse 0 end) as num_cancelled\\n\\tfrom Trips t\\n\\tinner join Users u1\\n\\t  on u1.Users_Id = t.Client_id\\n\\t and u1.Banned <> \\'Yes\\'\\n\\tinner join Users u2\\n\\t  on u2.Users_Id = t.Driver_id\\n\\t and u2.Banned <> \\'Yes\\'\\n\\tgroup by t.Request_at\\n)\\n\\nselect day as \"Day\",\\n\\t   round( num_cancelled*1.0 / total_trips, 2 ) as \"Cancellation Rate\"\\nfrom trip_agg a\\nwhere day between \\'2013-10-01\\' and \\'2013-10-03\\'\\norder by day\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 509954,
                "title": "extremely-readable-solution-faster-than-93-of-users-using-case",
                "content": "```\\nSELECT \\n    Request_at as Day,\\n    ROUND(Cancelled / Total, 2) as \"Cancellation Rate\"\\nFROM\\n    (SELECT \\n        Request_at,\\n        SUM(CASE \\n            WHEN Status = \"completed\" THEN 0\\n            ELSE 1\\n            END) AS Cancelled,\\n        COUNT(*) AS TOTAL\\n     FROM\\n        Trips\\n            LEFT JOIN\\n        Users c ON Trips.Client_Id = c.Users_Id\\n            LEFT JOIN\\n        Users d ON Trips.Driver_Id = d.Users_Id\\n     WHERE\\n        c.Banned = \"No\"\\n     GROUP BY Request_at) as t\\nWHERE\\n    t.Request_at BETWEEN \\'2013-10-01\\'AND \\'2013-10-03\\'\\t\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\n    Request_at as Day,\\n    ROUND(Cancelled / Total, 2) as \"Cancellation Rate\"\\nFROM\\n    (SELECT \\n        Request_at,\\n        SUM(CASE \\n            WHEN Status = \"completed\" THEN 0\\n            ELSE 1\\n            END) AS Cancelled,\\n        COUNT(*) AS TOTAL\\n     FROM\\n        Trips\\n            LEFT JOIN\\n        Users c ON Trips.Client_Id = c.Users_Id\\n            LEFT JOIN\\n        Users d ON Trips.Driver_Id = d.Users_Id\\n     WHERE\\n        c.Banned = \"No\"\\n     GROUP BY Request_at) as t\\nWHERE\\n    t.Request_at BETWEEN \\'2013-10-01\\'AND \\'2013-10-03\\'\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 508789,
                "title": "mssql-solution-simililar-to-mysql",
                "content": "```\\n/* Write your T-SQL query statement below */\\nSELECT\\n    Request_at as \\'Day\\',\\n    ROUND(CAST(SUM(CASE WHEN Status != \\'completed\\' THEN 1 ELSE 0 END) AS FLOAT)/CAST(COUNT(*) AS FLOAT), 2) AS \\'Cancellation Rate\\'\\n    \\nFROM \\n    Trips\\nWHERE\\n    Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    AND Client_Id NOT IN (SELECT Users_Id FROM Users WHERE Banned = \\'Yes\\')\\nGROUP BY \\n    Request_at\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT\\n    Request_at as \\'Day\\',\\n    ROUND(CAST(SUM(CASE WHEN Status != \\'completed\\' THEN 1 ELSE 0 END) AS FLOAT)/CAST(COUNT(*) AS FLOAT), 2) AS \\'Cancellation Rate\\'\\n    \\nFROM \\n    Trips\\nWHERE\\n    Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    AND Client_Id NOT IN (SELECT Users_Id FROM Users WHERE Banned = \\'Yes\\')\\nGROUP BY \\n    Request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 503312,
                "title": "faster-than-99-34-solution",
                "content": "```SELECT \\n     tm.Request_at as Day\\n    ,round(cancelled_trips/total_requests,2) as \"Cancellation Rate\"\\n    FROM\\n    (\\n    SELECT \\n        t.Request_at\\n        ,sum(case when Status = \\'cancelled_by_driver\\' then 1 when Status = \\'cancelled_by_client\\' then 1 else 0 END) as cancelled_trips\\n        ,count(t.Id) as total_requests\\n    FROM \\n        Trips t\\n    JOIN \\n        Users u1 \\n    ON \\n        t.Client_Id = u1.Users_Id\\n        AND u1.Banned = \\'No\\'\\n    JOIN \\n        Users u2 \\n    ON  \\n        t.Driver_Id = u2.Users_Id \\n        AND u2.Banned = \\'No\\'\\n    WHERE t.Request_at between \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    GROUP BY \\n        t.Request_at ) as tm```",
                "solutionTags": [],
                "code": "```SELECT \\n     tm.Request_at as Day\\n    ,round(cancelled_trips/total_requests,2) as \"Cancellation Rate\"\\n    FROM\\n    (\\n    SELECT \\n        t.Request_at\\n        ,sum(case when Status = \\'cancelled_by_driver\\' then 1 when Status = \\'cancelled_by_client\\' then 1 else 0 END) as cancelled_trips\\n        ,count(t.Id) as total_requests\\n    FROM \\n        Trips t\\n    JOIN \\n        Users u1 \\n    ON \\n        t.Client_Id = u1.Users_Id\\n        AND u1.Banned = \\'No\\'\\n    JOIN \\n        Users u2 \\n    ON  \\n        t.Driver_Id = u2.Users_Id \\n        AND u2.Banned = \\'No\\'\\n    WHERE t.Request_at between \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    GROUP BY \\n        t.Request_at ) as tm```",
                "codeTag": "Unknown"
            },
            {
                "id": 479267,
                "title": "mssql-answer",
                "content": "```\\n/* Write your T-SQL query statement below */\\n\\n\\nWITH total_number_of_requests AS (\\n \\n     SELECT request_at, COUNT(Id) AS \\'Requests\\'\\n     FROM(\\n        SELECT DISTINCT Id,Request_at\\n        FROM        Trips  AS A\\n        INNER JOIN  Users  AS B ON A.Client_Id = B.Users_Id\\n        INNER JOIN  Users  AS C ON A.Driver_Id = C.Users_Id \\n        WHERE B.Banned = \\'No\\' AND C.Banned = \\'No\\'\\n        AND   A.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    )Z\\n    GROUP BY Request_at\\n\\n\\n), total_number_of_cancels AS (\\n\\n     SELECT  request_at, COUNT(Cancels) AS \\'Cancels\\'\\n     FROM(\\n            SELECT  request_at,Id AS \\'Cancels\\'\\n            FROM        Trips   AS A \\n            INNER JOIN  Users   AS B ON A.Client_Id = B.Users_Id \\n            INNER JOIN  Users   AS C ON A.Driver_Id = C.Users_Id\\n            WHERE B.Banned = \\'No\\' AND C.Banned = \\'No\\'\\n            AND   A.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n            AND   A.Status IN (\\'cancelled_by_driver\\',\\'cancelled_by_client\\')\\n    )Z\\n    GROUP BY request_at\\n)\\n\\n\\n\\nSELECT  A.request_at AS Day, \\n        ROUND(CAST(ISNULL(B.Cancels,0.0) AS FLOAT)/A.Requests,2) AS \\'Cancellation Rate\\'\\nFROM      total_number_of_requests AS A \\nLEFT JOIN total_number_of_cancels  AS B ON A.request_at=B.request_at\\n\\n\\n\\n    \\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\n\\nWITH total_number_of_requests AS (\\n \\n     SELECT request_at, COUNT(Id) AS \\'Requests\\'\\n     FROM(\\n        SELECT DISTINCT Id,Request_at\\n        FROM        Trips  AS A\\n        INNER JOIN  Users  AS B ON A.Client_Id = B.Users_Id\\n        INNER JOIN  Users  AS C ON A.Driver_Id = C.Users_Id \\n        WHERE B.Banned = \\'No\\' AND C.Banned = \\'No\\'\\n        AND   A.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    )Z\\n    GROUP BY Request_at\\n\\n\\n), total_number_of_cancels AS (\\n\\n     SELECT  request_at, COUNT(Cancels) AS \\'Cancels\\'\\n     FROM(\\n            SELECT  request_at,Id AS \\'Cancels\\'\\n            FROM        Trips   AS A \\n            INNER JOIN  Users   AS B ON A.Client_Id = B.Users_Id \\n            INNER JOIN  Users   AS C ON A.Driver_Id = C.Users_Id\\n            WHERE B.Banned = \\'No\\' AND C.Banned = \\'No\\'\\n            AND   A.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n            AND   A.Status IN (\\'cancelled_by_driver\\',\\'cancelled_by_client\\')\\n    )Z\\n    GROUP BY request_at\\n)\\n\\n\\n\\nSELECT  A.request_at AS Day, \\n        ROUND(CAST(ISNULL(B.Cancels,0.0) AS FLOAT)/A.Requests,2) AS \\'Cancellation Rate\\'\\nFROM      total_number_of_requests AS A \\nLEFT JOIN total_number_of_cancels  AS B ON A.request_at=B.request_at\\n\\n\\n\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 469381,
                "title": "easy-and-clear-solution",
                "content": "```\\nselect T.Request_at as Day, \\n\\nround(sum(case when t.Status = \\'cancelled_by_driver\\' or t.Status = \\'cancelled_by_client\\' then 1.0 else 0.0 end) / \\ncount (t.id) ,2)\\n      \\nas  \"Cancellation Rate\"\\nfrom Trips t\\njoin Users uC on uC.Users_Id  = t.Client_Id and uC.Banned = \\'No\\'\\njoin Users uD on uD.Users_Id  = t.Driver_Id and uD.Banned = \\'No\\'\\nwhere Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n```",
                "solutionTags": [],
                "code": "```\\nselect T.Request_at as Day, \\n\\nround(sum(case when t.Status = \\'cancelled_by_driver\\' or t.Status = \\'cancelled_by_client\\' then 1.0 else 0.0 end) / \\ncount (t.id) ,2)\\n      \\nas  \"Cancellation Rate\"\\nfrom Trips t\\njoin Users uC on uC.Users_Id  = t.Client_Id and uC.Banned = \\'No\\'\\njoin Users uD on uD.Users_Id  = t.Driver_Id and uD.Banned = \\'No\\'\\nwhere Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419547,
                "title": "simple-mysql-solution-without-join-using-group-by-and-in",
                "content": "```\\n# Write your MySQL query statement below\\n\\nSELECT Request_at as Day, ROUND(SUM(CASE WHEN Status!=\"completed\" THEN 1 ELSE 0 END)/COUNT(*),2) as \"Cancellation Rate\" FROM Trips\\nWHERE Client_Id NOT IN\\n(\\n    SELECT Users_Id FROM Users\\n    WHERE Banned=\"Yes\"\\n)\\nAND Request_at>=\"2013-10-01\" AND Request_at<=\"2013-10-03\"\\nGROUP BY Request_at;\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT Request_at as Day, ROUND(SUM(CASE WHEN Status!=\"completed\" THEN 1 ELSE 0 END)/COUNT(*),2) as \"Cancellation Rate\" FROM Trips\\nWHERE Client_Id NOT IN\\n(\\n    SELECT Users_Id FROM Users\\n    WHERE Banned=\"Yes\"\\n)\\nAND Request_at>=\"2013-10-01\" AND Request_at<=\"2013-10-03\"\\nGROUP BY Request_at;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 294636,
                "title": "ms-sql-solution",
                "content": "```\\nselect Request_at as [Day], \\nRound(SUM(case when a.Status = \\'cancelled_by_driver\\' or a.Status = \\'cancelled_by_client\\' then 1 else 0 end)/(SUM(case when a.Id is not null then 1 else 0 end)+.0), 2) as [Cancellation Rate]\\nfrom Trips a\\ninner join Users b1 on a.Client_Id = b1.Users_Id and b1.Role = \\'client\\' and b1.Banned = \\'No\\'\\ninner join Users b2 on a.Driver_Id = b2.Users_Id and b2.Role = \\'driver\\' and b2.Banned = \\'No\\'\\nwhere Request_at >= \\'2013-10-01\\' and Request_at <= \\'2013-10-03\\'\\ngroup by Request_at\\n```",
                "solutionTags": [],
                "code": "```\\nselect Request_at as [Day], \\nRound(SUM(case when a.Status = \\'cancelled_by_driver\\' or a.Status = \\'cancelled_by_client\\' then 1 else 0 end)/(SUM(case when a.Id is not null then 1 else 0 end)+.0), 2) as [Cancellation Rate]\\nfrom Trips a\\ninner join Users b1 on a.Client_Id = b1.Users_Id and b1.Role = \\'client\\' and b1.Banned = \\'No\\'\\ninner join Users b2 on a.Driver_Id = b2.Users_Id and b2.Role = \\'driver\\' and b2.Banned = \\'No\\'\\nwhere Request_at >= \\'2013-10-01\\' and Request_at <= \\'2013-10-03\\'\\ngroup by Request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 285491,
                "title": "mssql-faster-than-96-19",
                "content": "```\\n/* Write your T-SQL query statement below */\\nWITH CTE AS (\\nSELECT \\n    Client_ID, \\n    Driver_ID,  \\n    Request_at,\\n    CASE WHEN Patindex(\\'%cancelled%\\', Status) >= 1\\n        THEN 1\\n        ELSE 0\\n    END AS Cancelled \\nFROM Trips\\n)\\n\\nSELECT CTE.Request_at AS Day, \\nCAST(SUM(CTE.Cancelled*1.00)/Count(CTE.Client_ID*1.00) AS DECIMAL(5,2)) AS [Cancellation Rate]\\nFROM CTE\\nLEFT JOIN Users AS Clients\\n    ON Clients.Users_ID = CTE.Client_ID\\nLEFT JOIN Users AS Drivers\\n    ON Drivers.Users_ID = CTE.Driver_ID\\nWHERE \\nClients.Banned = \\'No\\' AND\\nDrivers.Banned = \\'No\\' AND\\nRequest_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY CTE.Request_at\\n",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\nWITH CTE AS (\\nSELECT \\n    Client_ID, \\n    Driver_ID,  \\n    Request_at,\\n    CASE WHEN Patindex(\\'%cancelled%\\', Status) >= 1\\n        THEN 1\\n        ELSE 0\\n    END AS Cancelled \\nFROM Trips\\n)\\n\\nSELECT CTE.Request_at AS Day, \\nCAST(SUM(CTE.Cancelled*1.00)/Count(CTE.Client_ID*1.00) AS DECIMAL(5,2)) AS [Cancellation Rate]\\nFROM CTE\\nLEFT JOIN Users AS Clients\\n    ON Clients.Users_ID = CTE.Client_ID\\nLEFT JOIN Users AS Drivers\\n    ON Drivers.Users_ID = CTE.Driver_ID\\nWHERE \\nClients.Banned = \\'No\\' AND\\nDrivers.Banned = \\'No\\' AND\\nRequest_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY CTE.Request_at\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 272978,
                "title": "solution-without-join",
                "content": "SQL:\\n```\\nselect\\n    Request_at as Day,\\n    round(count(distinct case when Status != \\'completed\\' then Id else null end)/count(distinct Id),2) as \\'Cancellation Rate\\'\\nfrom `Trips`\\nwhere Client_Id in (\\n    select\\n        Users_Id as Client_Id\\n    from `Users`\\n    where Banned = \\'No\\'\\n)\\nand (Request_at>=\\'2013-10-01\\' and Request_at<=\\'2013-10-03\\')\\nGROUP BY 1\\nORDER BY 1 ASC\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\n    Request_at as Day,\\n    round(count(distinct case when Status != \\'completed\\' then Id else null end)/count(distinct Id),2) as \\'Cancellation Rate\\'\\nfrom `Trips`\\nwhere Client_Id in (\\n    select\\n        Users_Id as Client_Id\\n    from `Users`\\n    where Banned = \\'No\\'\\n)\\nand (Request_at>=\\'2013-10-01\\' and Request_at<=\\'2013-10-03\\')\\nGROUP BY 1\\nORDER BY 1 ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 256870,
                "title": "mysql-solution-faster-than-82-submissions",
                "content": "```\\nselect a.Request_at as Day, \\nround(count(case when status like \\'cancelled_by%\\' then 1 end)/count(a.status),2) as \\'Cancellation Rate\\'\\nfrom trips a\\n\\nleft join\\n(select * from users where Role = \\'client\\') b \\non a.client_id = b.Users_Id\\n\\nleft join (select * from users where Role = \\'driver\\') c\\non a.Driver_Id = c.Users_Id\\n\\nwhere Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nand b.banned = \\'No\\' and c.banned=\\'No\\'\\ngroup by Day;\\n```",
                "solutionTags": [],
                "code": "```\\nselect a.Request_at as Day, \\nround(count(case when status like \\'cancelled_by%\\' then 1 end)/count(a.status),2) as \\'Cancellation Rate\\'\\nfrom trips a\\n\\nleft join\\n(select * from users where Role = \\'client\\') b \\non a.client_id = b.Users_Id\\n\\nleft join (select * from users where Role = \\'driver\\') c\\non a.Driver_Id = c.Users_Id\\n\\nwhere Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nand b.banned = \\'No\\' and c.banned=\\'No\\'\\ngroup by Day;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189703,
                "title": "accepted-solution",
                "content": "select c.Request_at as Day, ROUND(c.Cancelled_Trips/c.TotalTrips,2) as 'Cancellation Rate' from (select a.Request_at , SUM(Case when b.Banned like 'No' then 1 else 0 END) as TotalTrips, SUM(Case when b.Banned like 'No'and a.Status like '%cancelled%' then 1 else 0 END) Cancelled_Trips from Trips a, Users b where a.Client_Id = b.Users_Id group by a.Request_at) c where c.Request_at BETWEEN'2013-10-01' and '2013-10-03'",
                "solutionTags": [],
                "code": "select c.Request_at as Day, ROUND(c.Cancelled_Trips/c.TotalTrips,2) as 'Cancellation Rate' from (select a.Request_at , SUM(Case when b.Banned like 'No' then 1 else 0 END) as TotalTrips, SUM(Case when b.Banned like 'No'and a.Status like '%cancelled%' then 1 else 0 END) Cancelled_Trips from Trips a, Users b where a.Client_Id = b.Users_Id group by a.Request_at) c where c.Request_at BETWEEN'2013-10-01' and '2013-10-03'",
                "codeTag": "Unknown"
            },
            {
                "id": 189575,
                "title": "solution-and-explanation",
                "content": "Tried to use the .... to give the solution some structure\\n\\nTake the total count on each day and cancellations on each day and **LEFT JOIN**. **LEFT JOIN** required because we may have days with no cancellations. This also leads to the need to **COALESCE** the cancelled value with 0.\\n\\nNo need to join the *Users* table using *Driver_Id* as well as *Client_Id* the table is actually a mapping between which drivers picked up which clients so joining again would be double counting.\\n\\nThe rest is self explanatory:\\n\\nSELECT a.day as Day, COALESCE(ROUND(b.cancelled/a.total,2),0) AS \\'Cancellation Rate\\'\\nFROM\\n(\\n\\t\\t....SELECT t.Request_at AS day, COUNT(t.Status) AS total\\n    ....FROM Users u\\n    ....JOIN Trips t\\n   .... ON u.users_id = t.client_id\\n   ....WHERE u.Banned = \\'No\\' AND t.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n   ....GROUP BY t.Request_at\\n) a\\nLEFT JOIN\\n(\\n    ....SELECT t.Request_at AS day, COUNT(t.Status) AS cancelled\\n    ....FROM Users u\\n    ....JOIN Trips t\\n    ....ON u.users_id = t.client_id\\n    ....WHERE u.Banned = \\'No\\' AND t.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ....AND t.Status IN (\\'cancelled_by_driver\\', \\'cancelled_by_client\\')\\n    ....GROUP BY t.Request_at\\n) b\\nON a.day = b.day\\nGROUP BY a.day\\nORDER BY a.day",
                "solutionTags": [],
                "code": "Tried to use the .... to give the solution some structure\\n\\nTake the total count on each day and cancellations on each day and **LEFT JOIN**. **LEFT JOIN** required because we may have days with no cancellations. This also leads to the need to **COALESCE** the cancelled value with 0.\\n\\nNo need to join the *Users* table using *Driver_Id* as well as *Client_Id* the table is actually a mapping between which drivers picked up which clients so joining again would be double counting.\\n\\nThe rest is self explanatory:\\n\\nSELECT a.day as Day, COALESCE(ROUND(b.cancelled/a.total,2),0) AS \\'Cancellation Rate\\'\\nFROM\\n(\\n\\t\\t....SELECT t.Request_at AS day, COUNT(t.Status) AS total\\n    ....FROM Users u\\n    ....JOIN Trips t\\n   .... ON u.users_id = t.client_id\\n   ....WHERE u.Banned = \\'No\\' AND t.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n   ....GROUP BY t.Request_at\\n) a\\nLEFT JOIN\\n(\\n    ....SELECT t.Request_at AS day, COUNT(t.Status) AS cancelled\\n    ....FROM Users u\\n    ....JOIN Trips t\\n    ....ON u.users_id = t.client_id\\n    ....WHERE u.Banned = \\'No\\' AND t.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ....AND t.Status IN (\\'cancelled_by_driver\\', \\'cancelled_by_client\\')\\n    ....GROUP BY t.Request_at\\n) b\\nON a.day = b.day\\nGROUP BY a.day\\nORDER BY a.day",
                "codeTag": "Unknown"
            },
            {
                "id": 122922,
                "title": "a-clear-submission-with-sum-and-count",
                "content": "```\\nSELECT \\n    Request_at AS Day,\\n    Round(sum(Status != \"completed\")/ COUNT(*), 2) AS \\'Cancellation Rate\\'\\nFROM \\n    Trips\\nJOIN\\n    Users\\nOn Trips.ClientId = Users.UsersId\\nWHERE Request_at between \\'2013-10-01\\' and \\'2013-10-03\\' AND Users.Banned = \\'No\\'\\nGROUP BY Trips.Request_at;\\n```\\n\\n\"Sum()\" is a better choice than \"Count()\" when using a Boolean Expression inside the parethesis, Since \"Count()\" increments by 1 when the expression returns anything that is not \"NULL\", while boolean expressions return only \"1\" and \"0\". So when using \"count\", we use \"Count(boolean expression OR NULL)\", in that \"0 OR NULL\" returns \"NULL\".",
                "solutionTags": [],
                "code": "```\\nSELECT \\n    Request_at AS Day,\\n    Round(sum(Status != \"completed\")/ COUNT(*), 2) AS \\'Cancellation Rate\\'\\nFROM \\n    Trips\\nJOIN\\n    Users\\nOn Trips.ClientId = Users.UsersId\\nWHERE Request_at between \\'2013-10-01\\' and \\'2013-10-03\\' AND Users.Banned = \\'No\\'\\nGROUP BY Trips.Request_at;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 69152,
                "title": "share-my-simple-solution",
                "content": "```\\nselect t.request_at as Day, \\n       round(avg(if(t.status <>'completed',1,0)), 2) as \"Cancellation Rate\"\\nfrom Trips as t join users as u \\non t.client_id=u.users_id and u.banned='No' \\nwhere t.request_at between '2013-10-01' and '2013-10-03'\\ngroup by t.request_at\\n```",
                "solutionTags": [],
                "code": "```\\nselect t.request_at as Day, \\n       round(avg(if(t.status <>'completed',1,0)), 2) as \"Cancellation Rate\"\\nfrom Trips as t join users as u \\non t.client_id=u.users_id and u.banned='No' \\nwhere t.request_at between '2013-10-01' and '2013-10-03'\\ngroup by t.request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 69153,
                "title": "my-ac-solution-using-inner-join-and-no-sub-queries-with-explanation",
                "content": "This was a tricky problem.\\n\\nNotes:\\n\\n* We need only to consider unbanned clients (no mention of what to do with banned drivers or partners)\\n\\n* Watch out for superfluous details (e.g. user has role \"partner\"); because, the Trips table does not join with \"partner\"s, but, only, drivers and clients. \\n\\n* Given the points above, an INNER JOIN can be used on Trips and Users without creating duplicate entries\\n\\n* Notice that SUM is used. This can reduce the number of casts going on internally in code.\\n\\n* For MySql, the CAST is not needed, but, I left it in there so that it would work with other Sql servers as well.\\n\\nSQL query follows:\\n***\\n    SELECT T.Request_at as Day, CAST(ROUND(\\n      SUM(CASE \\n              WHEN T.Status<>'completed' THEN 1.000 \\n              ELSE 0.000 \\n          END) / \\n      SUM(1.000), 2) AS DECIMAL(3,2)) AS 'Cancellation Rate' \\n    FROM Trips T\\n    INNER JOIN Users U\\n      ON U.Users_Id = T.Client_Id AND U.Banned='No'\\n    WHERE\\n\\t  T.Request_at >= '2013-10-01' AND T.Request_at <= '2013-10-03'\\n    GROUP BY T.Request_at\\n***",
                "solutionTags": [],
                "code": "This was a tricky problem.\\n\\nNotes:\\n\\n* We need only to consider unbanned clients (no mention of what to do with banned drivers or partners)\\n\\n* Watch out for superfluous details (e.g. user has role \"partner\"); because, the Trips table does not join with \"partner\"s, but, only, drivers and clients. \\n\\n* Given the points above, an INNER JOIN can be used on Trips and Users without creating duplicate entries\\n\\n* Notice that SUM is used. This can reduce the number of casts going on internally in code.\\n\\n* For MySql, the CAST is not needed, but, I left it in there so that it would work with other Sql servers as well.\\n\\nSQL query follows:\\n***\\n    SELECT T.Request_at as Day, CAST(ROUND(\\n      SUM(CASE \\n              WHEN T.Status<>'completed' THEN 1.000 \\n              ELSE 0.000 \\n          END) / \\n      SUM(1.000), 2) AS DECIMAL(3,2)) AS 'Cancellation Rate' \\n    FROM Trips T\\n    INNER JOIN Users U\\n      ON U.Users_Id = T.Client_Id AND U.Banned='No'\\n    WHERE\\n\\t  T.Request_at >= '2013-10-01' AND T.Request_at <= '2013-10-03'\\n    GROUP BY T.Request_at\\n***",
                "codeTag": "Unknown"
            },
            {
                "id": 69191,
                "title": "share-my-answer",
                "content": "    select  t.`Request_at` as  Day ,\\n    round(\\n    sum(case when t.Status = 'completed' then 0 else 1 end) / count(1) ) \\n    ,2) as  'Cancellation Rate'\\n    from Trips t \\n    where (select Banned from Users u where t.Client_id = u.Users_id) = 'No' \\n    and (select Banned from Users u where t.Driver_id = u.Users_id) = 'No' \\n    and t.Request_at >= '2013-10-01' and t.Request_at <= '2013-10-03'\\n    group by t.`Request_at`",
                "solutionTags": [],
                "code": "    select  t.`Request_at` as  Day ,\\n    round(\\n    sum(case when t.Status = 'completed' then 0 else 1 end) / count(1) ) \\n    ,2) as  'Cancellation Rate'\\n    from Trips t \\n    where (select Banned from Users u where t.Client_id = u.Users_id) = 'No' \\n    and (select Banned from Users u where t.Driver_id = u.Users_id) = 'No' \\n    and t.Request_at >= '2013-10-01' and t.Request_at <= '2013-10-03'\\n    group by t.`Request_at`",
                "codeTag": "Unknown"
            },
            {
                "id": 3951676,
                "title": "simplest-solution",
                "content": "\\r\\n```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n\\r\\nSELECT\\r\\n    request_at Day,\\r\\n    ROUND(CAST(COUNT(CASE WHEN t.status like \\'cancelled%\\' THEN t.status ELSE NULL END) AS FLOAT)/CAST(COUNT(id) AS FLOAT),2)  AS [Cancellation Rate]\\r\\nFROM\\r\\n    trips t\\r\\nINNER JOIN\\r\\n    users u_client\\r\\nON\\r\\n    t.client_id=u_client.users_id\\r\\nINNER JOIN\\r\\n    users u_driver\\r\\nON\\r\\n    t.driver_id=u_driver.users_id\\r\\nWHERE\\r\\n    u_client.banned=\\'No\\'\\r\\nAND\\r\\n    u_driver.banned=\\'No\\'\\r\\nAND\\r\\n    request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\r\\nGROUP BY\\r\\n    request_at\\r\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n\\r\\nSELECT\\r\\n    request_at Day,\\r\\n    ROUND(CAST(COUNT(CASE WHEN t.status like \\'cancelled%\\' THEN t.status ELSE NULL END) AS FLOAT)/CAST(COUNT(id) AS FLOAT),2)  AS [Cancellation Rate]\\r\\nFROM\\r\\n    trips t\\r\\nINNER JOIN\\r\\n    users u_client\\r\\nON\\r\\n    t.client_id=u_client.users_id\\r\\nINNER JOIN\\r\\n    users u_driver\\r\\nON\\r\\n    t.driver_id=u_driver.users_id\\r\\nWHERE\\r\\n    u_client.banned=\\'No\\'\\r\\nAND\\r\\n    u_driver.banned=\\'No\\'\\r\\nAND\\r\\n    request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\r\\nGROUP BY\\r\\n    request_at\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3245617,
                "title": "trips-and-users-solution",
                "content": "# Code\\n```\\nSELECT \\n    t.request_at AS Day,\\n    ROUND(\\n        SUM(\\n            CASE\\n                WHEN status = \\'completed\\' THEN 0\\n                ELSE 1\\n            END \\n        ) / count(*), 2\\n    ) AS \"Cancellation Rate\"\\nFROM Trips t\\nWHERE t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\' \\nAND NOT EXISTS\\n(\\n    SELECT * \\n    FROM users \\n    WHERE users_id in (t.client_id, t.driver_id)\\n    AND banned = \\'Yes\\'\\n)\\nGROUP BY t.request_at;\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# Code\\n```\\nSELECT \\n    t.request_at AS Day,\\n    ROUND(\\n        SUM(\\n            CASE\\n                WHEN status = \\'completed\\' THEN 0\\n                ELSE 1\\n            END \\n        ) / count(*), 2\\n    ) AS \"Cancellation Rate\"\\nFROM Trips t\\nWHERE t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\' \\nAND NOT EXISTS\\n(\\n    SELECT * \\n    FROM users \\n    WHERE users_id in (t.client_id, t.driver_id)\\n    AND banned = \\'Yes\\'\\n)\\nGROUP BY t.request_at;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2581109,
                "title": "mysql-faster-than-82-solution",
                "content": "```sql\\nSELECT request_at Day, ROUND(cancelled / total, 2) \"Cancellation Rate\"\\nFROM (\\n    SELECT request_at ,count(*) total, COALESCE(sq.cancelled, 0.0) cancelled\\n    FROM trips t \\n    INNER JOIN users u ON client_id = u.users_id \\n    INNER JOIN users u2 ON driver_id = u2.users_id \\n    LEFT JOIN (\\n        SELECT request_at request_at2, count(*) cancelled\\n        FROM  trips t\\n        INNER JOIN users u ON client_id = u.users_id \\n        INNER JOIN users u2 ON driver_id = u2.users_id \\n        WHERE u.banned <> \\'Yes\\' AND u2.banned <> \\'Yes\\' AND (status = \\'cancelled_by_driver\\' OR status = \\'cancelled_by_client\\')\\n        GROUP BY request_at\\n    ) sq ON sq.request_at2 = request_at\\n    WHERE u.banned <> \\'Yes\\' AND u2.banned <> \\'Yes\\' \\n    GROUP BY request_at, sq.cancelled\\n) sq WHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\' ORDER BY request_at;\\n```\\n\\n>**Runtime: 481 ms, faster than 82.55% of MySQL online submissions for Trips and Users.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Trips and User**s.\\n\\n",
                "solutionTags": [],
                "code": "```sql\\nSELECT request_at Day, ROUND(cancelled / total, 2) \"Cancellation Rate\"\\nFROM (\\n    SELECT request_at ,count(*) total, COALESCE(sq.cancelled, 0.0) cancelled\\n    FROM trips t \\n    INNER JOIN users u ON client_id = u.users_id \\n    INNER JOIN users u2 ON driver_id = u2.users_id \\n    LEFT JOIN (\\n        SELECT request_at request_at2, count(*) cancelled\\n        FROM  trips t\\n        INNER JOIN users u ON client_id = u.users_id \\n        INNER JOIN users u2 ON driver_id = u2.users_id \\n        WHERE u.banned <> \\'Yes\\' AND u2.banned <> \\'Yes\\' AND (status = \\'cancelled_by_driver\\' OR status = \\'cancelled_by_client\\')\\n        GROUP BY request_at\\n    ) sq ON sq.request_at2 = request_at\\n    WHERE u.banned <> \\'Yes\\' AND u2.banned <> \\'Yes\\' \\n    GROUP BY request_at, sq.cancelled\\n) sq WHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\' ORDER BY request_at;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2511481,
                "title": "one-cte-and-no-joins",
                "content": "```\\nWITH banned AS (\\nSELECT\\n    DISTINCT users_id\\nFROM Users\\nWHERE banned = \\'Yes\\'\\n)\\n\\nSELECT\\n    request_at AS \"Day\",\\n    round(sum(CASE WHEN status LIKE \\'%cancel%\\' THEN 1 ELSE 0 END) / count(*), 2) AS \"Cancellation Rate\"\\nFROM Trips\\nWHERE\\n    client_id NOT IN (SELECT users_id FROM banned)\\n    AND driver_id NOT IN (SELECT users_id FROM banned)\\n    AND request_at BETWEEN date(\\'2013-10-01\\') AND date(\\'2013-10-03\\')\\nGROUP BY 1\\n```",
                "solutionTags": [],
                "code": "```\\nWITH banned AS (\\nSELECT\\n    DISTINCT users_id\\nFROM Users\\nWHERE banned = \\'Yes\\'\\n)\\n\\nSELECT\\n    request_at AS \"Day\",\\n    round(sum(CASE WHEN status LIKE \\'%cancel%\\' THEN 1 ELSE 0 END) / count(*), 2) AS \"Cancellation Rate\"\\nFROM Trips\\nWHERE\\n    client_id NOT IN (SELECT users_id FROM banned)\\n    AND driver_id NOT IN (SELECT users_id FROM banned)\\n    AND request_at BETWEEN date(\\'2013-10-01\\') AND date(\\'2013-10-03\\')\\nGROUP BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2489107,
                "title": "solution-with-detail-explanation-without-using-join-and-99-93-fast-easy-to-understand",
                "content": "**Upvote if U like it**\\n![image](https://assets.leetcode.com/users/images/8e944b40-7449-4c7b-87f1-a86861791035_1661584195.8383856.png)\\n\\nIt is simple\\nwe are using pure logic here\\n\\nSELECT request_at AS Day ,\\nROUND( # it is use get two demical point\\nSUM(IF(status<>\"completed\",1,0))/COUNT(status),2)       #condition for given Question\\nAS \"Cancellation Rate\"\\nFROM Trips\\nWHERE request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"   # Date Condition\\nAND client_id NOT IN (SELECT users_id FROM Users WHERE banned=\"Yes\" )  # Not a Banned Client\\nAND driver_id NOT IN (SELECT users_id FROM Users WHERE banned=\"Yes\" )  # Not a Banned Driver\\nGROUP BY request_at\\n\\n**IF any Doubt please Comment below**\\n\\n**Code**\\n\\n```\\nSELECT request_at AS Day ,\\nROUND(SUM(IF(status<>\"completed\",1,0))/COUNT(status),2) AS \"Cancellation Rate\"\\nFROM Trips\\nWHERE request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nAND client_id NOT IN (SELECT users_id FROM Users WHERE banned=\"Yes\" ) \\nAND driver_id NOT IN (SELECT users_id FROM Users WHERE banned=\"Yes\" )\\nGROUP BY request_at\\n```\\n",
                "solutionTags": [],
                "code": "```\\nSELECT request_at AS Day ,\\nROUND(SUM(IF(status<>\"completed\",1,0))/COUNT(status),2) AS \"Cancellation Rate\"\\nFROM Trips\\nWHERE request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nAND client_id NOT IN (SELECT users_id FROM Users WHERE banned=\"Yes\" ) \\nAND driver_id NOT IN (SELECT users_id FROM Users WHERE banned=\"Yes\" )\\nGROUP BY request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2478355,
                "title": "mysql-solution-no-join",
                "content": "```\\nSELECT \\n    request_at AS Day,\\n    ROUND(\\n        COUNT(IF(status IN (\\'cancelled_by_driver\\', \\'cancelled_by_client\\'), 1, null))\\n        / COUNT(*)\\n    , 2) AS \\'Cancellation Rate\\'\\nFROM Trips \\nWHERE client_id\\n      IN (SELECT users_id FROM Users WHERE banned = \\'No\\')    \\n      AND  driver_id\\n      IN (SELECT users_id FROM Users WHERE banned = \\'No\\')    \\nGROUP BY request_at\\nHAVING request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    request_at AS Day,\\n    ROUND(\\n        COUNT(IF(status IN (\\'cancelled_by_driver\\', \\'cancelled_by_client\\'), 1, null))\\n        / COUNT(*)\\n    , 2) AS \\'Cancellation Rate\\'\\nFROM Trips \\nWHERE client_id\\n      IN (SELECT users_id FROM Users WHERE banned = \\'No\\')    \\n      AND  driver_id\\n      IN (SELECT users_id FROM Users WHERE banned = \\'No\\')    \\nGROUP BY request_at\\nHAVING request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2447144,
                "title": "mssql-simple-fast-and-explained",
                "content": "/* Write your T-SQL query statement below */\\n/* Thought Process */\\n-- (a) cancellation rate = cancelled requests / total requests  --- (b) MADE by unbanned users or drivers\\n-- (c) Using Aggregation (not window function) because output requires collapsed rows \\n-- (d) main table is Trips; (e) User table is for supporting info\\n-- (f) request_at filters\\n\\nSELECT \\n [Day] = request_at\\n,[Cancellation Rate] =  ROUND(CONVERT(FLOAT,SUM(CASE WHEN t.status LIKE \\'cancelled%\\' THEN 1 ELSE 0 END )) / COUNT(id), 2)\\n -- without transformations: SUM(CASE WHEN t.status LIKE \\'cancelled%\\' THEN 1 ELSE 0 END) / COUNT(id)\\nFROM Trips t\\nLEFT JOIN Users d on t.driver_id = d.users_id\\nLEFT JOIN Users c on t.client_id = c.users_id\\nWHERE request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nand d.banned = \\'No\\' and c.banned = \\'No\\'\\ngroup by request_at\\n\\n/* Corrections or Issues */\\n-- banned = \\'No\\' is filtered with WHERE and not used as a JOIN condition because we need to filter out unnecessary rows\\n-- Careful with dividing integers 10/100 = 0",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "/* Write your T-SQL query statement below */\\n/* Thought Process */\\n-- (a) cancellation rate = cancelled requests / total requests  --- (b) MADE by unbanned users or drivers\\n-- (c) Using Aggregation (not window function) because output requires collapsed rows \\n-- (d) main table is Trips; (e) User table is for supporting info\\n-- (f) request_at filters\\n\\nSELECT \\n [Day] = request_at\\n,[Cancellation Rate] =  ROUND(CONVERT(FLOAT,SUM(CASE WHEN t.status LIKE \\'cancelled%\\' THEN 1 ELSE 0 END )) / COUNT(id), 2)\\n -- without transformations: SUM(CASE WHEN t.status LIKE \\'cancelled%\\' THEN 1 ELSE 0 END) / COUNT(id)\\nFROM Trips t\\nLEFT JOIN Users d on t.driver_id = d.users_id\\nLEFT JOIN Users c on t.client_id = c.users_id\\nWHERE request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nand d.banned = \\'No\\' and c.banned = \\'No\\'\\ngroup by request_at\\n\\n/* Corrections or Issues */\\n-- banned = \\'No\\' is filtered with WHERE and not used as a JOIN condition because we need to filter out unnecessary rows\\n-- Careful with dividing integers 10/100 = 0",
                "codeTag": "Unknown"
            },
            {
                "id": 2417285,
                "title": "compute-the-average-of-indicators",
                "content": "```\\nSELECT\\n    t.request_at as Day,\\n    ROUND(AVG(IF(t.status LIKE \\'cancelled%\\', 1, 0)), 2) AS \\'Cancellation Rate\\'\\nFROM trips t\\nJOIN users cb ON cb.users_id = t.client_id AND cb.banned = \\'no\\'\\nJOIN users db ON db.users_id = t.driver_id AND db.banned = \\'no\\'\\nWHERE 1=1\\n    AND t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY t.request_at\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    t.request_at as Day,\\n    ROUND(AVG(IF(t.status LIKE \\'cancelled%\\', 1, 0)), 2) AS \\'Cancellation Rate\\'\\nFROM trips t\\nJOIN users cb ON cb.users_id = t.client_id AND cb.banned = \\'no\\'\\nJOIN users db ON db.users_id = t.driver_id AND db.banned = \\'no\\'\\nWHERE 1=1\\n    AND t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY t.request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2399839,
                "title": "easy-explanation-with-ctes",
                "content": "```\\n-- CANCELLATION RATE: NUMBER OF CANCELED REQUESTS BY UNBANNED USERS / TOTAL NUMBER OF UNBANNED REQUESTS BY DAY\\n-- BOTH CLIENT AND DRIVER ID MUST NOT BE BANNED\\n-- BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n\\n-- DAILY CANCELED UNBANNED REQUESTS BY DAY\\nWITH CTE_DAILY_CANCELED_REQUESTS AS \\n(SELECT REQUEST_AT AS DAY, COUNT(CLIENT_ID) AS CANCELED_COUNT\\n FROM TRIPS\\n WHERE STATUS LIKE \\'CANCELLED_%\\' AND\\n CLIENT_ID NOT IN (SELECT USERS_ID FROM USERS WHERE BANNED = \\'YES\\') AND\\n DRIVER_ID NOT IN (SELECT USERS_ID FROM USERS WHERE BANNED = \\'YES\\') AND\\n REQUEST_AT BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n GROUP BY REQUEST_AT),\\n-- TOTAL UNBANNED REQUESTS BY DAY\\nCTE_TOTAL_REQUESTS AS \\n(SELECT REQUEST_AT AS DAY, COUNT(CLIENT_ID) AS TOTAL_REQUESTS\\n FROM TRIPS\\n WHERE CLIENT_ID NOT IN (SELECT USERS_ID FROM USERS WHERE BANNED = \\'YES\\') AND\\n DRIVER_ID NOT IN (SELECT USERS_ID FROM USERS WHERE BANNED = \\'YES\\') AND\\n REQUEST_AT BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n GROUP BY REQUEST_AT)\\n-- CANCELLATION RATE BY DAY\\n SELECT CTE2.DAY, ISNULL(ROUND((CTE1.CANCELED_COUNT * 1.0) / CTE2.TOTAL_REQUESTS, 2),0) AS [CANCELLATION RATE]\\n FROM CTE_DAILY_CANCELED_REQUESTS CTE1\\n FULL JOIN CTE_TOTAL_REQUESTS CTE2\\n ON CTE1.DAY = CTE2.DAY\\n```\\nPlease let me know if you have a better approach for this problem. Thanks!",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n-- CANCELLATION RATE: NUMBER OF CANCELED REQUESTS BY UNBANNED USERS / TOTAL NUMBER OF UNBANNED REQUESTS BY DAY\\n-- BOTH CLIENT AND DRIVER ID MUST NOT BE BANNED\\n-- BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n\\n-- DAILY CANCELED UNBANNED REQUESTS BY DAY\\nWITH CTE_DAILY_CANCELED_REQUESTS AS \\n(SELECT REQUEST_AT AS DAY, COUNT(CLIENT_ID) AS CANCELED_COUNT\\n FROM TRIPS\\n WHERE STATUS LIKE \\'CANCELLED_%\\' AND\\n CLIENT_ID NOT IN (SELECT USERS_ID FROM USERS WHERE BANNED = \\'YES\\') AND\\n DRIVER_ID NOT IN (SELECT USERS_ID FROM USERS WHERE BANNED = \\'YES\\') AND\\n REQUEST_AT BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n GROUP BY REQUEST_AT),\\n-- TOTAL UNBANNED REQUESTS BY DAY\\nCTE_TOTAL_REQUESTS AS \\n(SELECT REQUEST_AT AS DAY, COUNT(CLIENT_ID) AS TOTAL_REQUESTS\\n FROM TRIPS\\n WHERE CLIENT_ID NOT IN (SELECT USERS_ID FROM USERS WHERE BANNED = \\'YES\\') AND\\n DRIVER_ID NOT IN (SELECT USERS_ID FROM USERS WHERE BANNED = \\'YES\\') AND\\n REQUEST_AT BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n GROUP BY REQUEST_AT)\\n-- CANCELLATION RATE BY DAY\\n SELECT CTE2.DAY, ISNULL(ROUND((CTE1.CANCELED_COUNT * 1.0) / CTE2.TOTAL_REQUESTS, 2),0) AS [CANCELLATION RATE]\\n FROM CTE_DAILY_CANCELED_REQUESTS CTE1\\n FULL JOIN CTE_TOTAL_REQUESTS CTE2\\n ON CTE1.DAY = CTE2.DAY\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2386232,
                "title": "faster-than-95-without-join",
                "content": "```\\n  \\nwith cte as(\\nselect * from Trips where client_id  in (select users_id from Users where banned =\\'No\\')\\n                    AND driver_id in (select users_id from Users where banned =\\'No\\')\\n    ),\\ncte2 as(\\nselect request_at, count(*) as Total,  sum(case when status <> \\'completed\\' then 1 else 0 end) as cancelled       \\n    from cte  group by request_at)\\n     \\n      \\n    select request_at as Day, round( cancelled/Total,2) as \\'Cancellation Rate\\'\\n    from cte2 \\n    group by request_at\\n    having request_at between \"2013-10-01\" AND \"2013-10-03\";\\n    \\n```",
                "solutionTags": [],
                "code": "```\\n  \\nwith cte as(\\nselect * from Trips where client_id  in (select users_id from Users where banned =\\'No\\')\\n                    AND driver_id in (select users_id from Users where banned =\\'No\\')\\n    ),\\ncte2 as(\\nselect request_at, count(*) as Total,  sum(case when status <> \\'completed\\' then 1 else 0 end) as cancelled       \\n    from cte  group by request_at)\\n     \\n      \\n    select request_at as Day, round( cancelled/Total,2) as \\'Cancellation Rate\\'\\n    from cte2 \\n    group by request_at\\n    having request_at between \"2013-10-01\" AND \"2013-10-03\";\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2385324,
                "title": "solution-with-join-easy-and-simple",
                "content": "```\\nSELECT t.request_at AS \\'Day\\',\\n       ROUND(SUM(CASE WHEN status LIKE \\'cancelled%\\' \\n                      THEN 1 ELSE 0 END)/COUNT(*),2) AS \\'Cancellation Rate\\'\\nFROM Trips t\\nJOIN Users c ON t.client_id = c.users_id AND c.banned = \\'No\\'\\nJOIN Users d ON t.driver_id = d.users_id AND d.banned = \\'No\\'\\nWHERE t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY t.request_at\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT t.request_at AS \\'Day\\',\\n       ROUND(SUM(CASE WHEN status LIKE \\'cancelled%\\' \\n                      THEN 1 ELSE 0 END)/COUNT(*),2) AS \\'Cancellation Rate\\'\\nFROM Trips t\\nJOIN Users c ON t.client_id = c.users_id AND c.banned = \\'No\\'\\nJOIN Users d ON t.driver_id = d.users_id AND d.banned = \\'No\\'\\nWHERE t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY t.request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2380793,
                "title": "mysql-faster-than-75",
                "content": "```\\nselect request_at as day,\\n       round((sum(case when status = \\'completed\\' then 0 else 1 end) / count(*)), 2) as \"Cancellation Rate\"\\nfrom trips\\nwhere client_id in (select users_id from users where banned = \\'No\\') \\nand driver_id in (select users_id from users where banned = \\'No\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect request_at as day,\\n       round((sum(case when status = \\'completed\\' then 0 else 1 end) / count(*)), 2) as \"Cancellation Rate\"\\nfrom trips\\nwhere client_id in (select users_id from users where banned = \\'No\\') \\nand driver_id in (select users_id from users where banned = \\'No\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2355409,
                "title": "ms-sql-simple-solution",
                "content": "SELECT\\n    t.request_at AS Day\\n    ,ROUND(1.0 * SUM(CASE WHEN status IN (\\'cancelled_by_driver\\', \\'cancelled_by_client\\') THEN 1 ELSE 0 END) / COUNT(*), 2) As [Cancellation Rate]\\nFROM Trips t\\nJOIN Users uC on uC.users_id = t.client_id and uC.banned = \\'No\\' and uC.role = \\'client\\'\\nJOIN Users uD on uD.users_id = t.driver_id and uD.banned = \\'No\\' and uD.role = \\'driver\\'     \\nWHERE t.request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nGROUP BY t.request_at",
                "solutionTags": [],
                "code": "SELECT\\n    t.request_at AS Day\\n    ,ROUND(1.0 * SUM(CASE WHEN status IN (\\'cancelled_by_driver\\', \\'cancelled_by_client\\') THEN 1 ELSE 0 END) / COUNT(*), 2) As [Cancellation Rate]\\nFROM Trips t\\nJOIN Users uC on uC.users_id = t.client_id and uC.banned = \\'No\\' and uC.role = \\'client\\'\\nJOIN Users uD on uD.users_id = t.driver_id and uD.banned = \\'No\\' and uD.role = \\'driver\\'     \\nWHERE t.request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nGROUP BY t.request_at",
                "codeTag": "Unknown"
            },
            {
                "id": 2345300,
                "title": "oracle-sub-query-inner-join",
                "content": "**Multiple row subquery approach**\\n```sql\\nSELECT \\n t.request_at \"Day\", \\n ROUND(COUNT(CASE t.status\\n              WHEN \\'completed\\' THEN NULL\\n              ELSE 0\\n             END)/COUNT(*), 2) \"Cancellation Rate\"\\n FROM TRIPS t\\nWHERE t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n AND \\'No\\' = ALL(SELECT banned \\n                 FROM USERS u\\n                WHERE u.users_id IN (t.client_id, t.driver_id))\\nGROUP BY request_at;\\n```\\n\\n**Inner join approach**\\n```sql\\nSELECT \\n t.request_at \"Day\", \\n ROUND(COUNT(CASE t.status\\n              WHEN \\'completed\\' THEN NULL\\n              ELSE 0\\n             END)/COUNT(*), 2) \"Cancellation Rate\"\\n FROM TRIPS t \\n INNER JOIN USERS c \\n  ON t.client_id = c.users_id AND c.banned = \\'No\\' AND (t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\n INNER JOIN USERS d \\n  ON t.driver_id = d.users_id AND d.banned = \\'No\\'\\n GROUP BY t.request_at;\\n ```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```sql\\nSELECT \\n t.request_at \"Day\", \\n ROUND(COUNT(CASE t.status\\n              WHEN \\'completed\\' THEN NULL\\n              ELSE 0\\n             END)/COUNT(*), 2) \"Cancellation Rate\"\\n FROM TRIPS t\\nWHERE t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n AND \\'No\\' = ALL(SELECT banned \\n                 FROM USERS u\\n                WHERE u.users_id IN (t.client_id, t.driver_id))\\nGROUP BY request_at;\\n```\n```sql\\nSELECT \\n t.request_at \"Day\", \\n ROUND(COUNT(CASE t.status\\n              WHEN \\'completed\\' THEN NULL\\n              ELSE 0\\n             END)/COUNT(*), 2) \"Cancellation Rate\"\\n FROM TRIPS t \\n INNER JOIN USERS c \\n  ON t.client_id = c.users_id AND c.banned = \\'No\\' AND (t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\n INNER JOIN USERS d \\n  ON t.driver_id = d.users_id AND d.banned = \\'No\\'\\n GROUP BY t.request_at;\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2338589,
                "title": "ms-sql-server-t-sql",
                "content": "SELECT \\nrequest_at as Day,\\nCAST(AVG(CASE WHEN status = \\'completed\\' then 0.0 ELSE 1.0 END) as DECIMAL(10,2)) as \\'Cancellation Rate\\'\\nFROM Trips   \\nWHERE \\nclient_id NOT IN (SELECT users_id FROM Users where banned = \\'Yes\\' and role = \\'client\\' )\\nand driver_id NOT IN (SELECT users_id FROM Users where banned = \\'Yes\\' and role = \\'driver\\') and \\nrequest_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nGROUP BY request_at",
                "solutionTags": [],
                "code": "SELECT \\nrequest_at as Day,\\nCAST(AVG(CASE WHEN status = \\'completed\\' then 0.0 ELSE 1.0 END) as DECIMAL(10,2)) as \\'Cancellation Rate\\'\\nFROM Trips   \\nWHERE \\nclient_id NOT IN (SELECT users_id FROM Users where banned = \\'Yes\\' and role = \\'client\\' )\\nand driver_id NOT IN (SELECT users_id FROM Users where banned = \\'Yes\\' and role = \\'driver\\') and \\nrequest_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nGROUP BY request_at",
                "codeTag": "Unknown"
            },
            {
                "id": 2329367,
                "title": "faster-than-86-mysql-solution-easy-to-understand",
                "content": "```\\nWITH t1 AS (\\n    SELECT\\n        t.id,\\n        t.client_id,\\n        u1.banned AS is_client_banned,\\n        t.driver_id,\\n        u2.banned AS is_driver_banned,\\n        t.city_id,\\n        t.status,\\n        t.request_at\\n    FROM\\n        Trips t\\n        INNER JOIN Users u1 ON t.client_id = u1.users_id\\n        INNER JOIN Users u2 ON t.driver_id = u2.users_id\\n)\\nSELECT\\n    request_at AS DAY,\\n    ROUND(\\n        (\\n            SUM(IF(STATUS = \"cancelled_by_client\", 1, 0)) + SUM(IF(STATUS = \"cancelled_by_driver\", 1, 0))\\n        ) / COUNT(id),\\n        2\\n    ) AS \\'Cancellation Rate\\'\\nFROM\\n    t1\\nWHERE\\n    request_at BETWEEN \"2013-10-01\"\\n    AND \"2013-10-03\"\\n    AND is_client_banned = \\'No\\'\\n    AND is_driver_banned = \\'No\\'\\nGROUP BY\\n    request_at\\nORDER BY\\n    request_at ASC\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH t1 AS (\\n    SELECT\\n        t.id,\\n        t.client_id,\\n        u1.banned AS is_client_banned,\\n        t.driver_id,\\n        u2.banned AS is_driver_banned,\\n        t.city_id,\\n        t.status,\\n        t.request_at\\n    FROM\\n        Trips t\\n        INNER JOIN Users u1 ON t.client_id = u1.users_id\\n        INNER JOIN Users u2 ON t.driver_id = u2.users_id\\n)\\nSELECT\\n    request_at AS DAY,\\n    ROUND(\\n        (\\n            SUM(IF(STATUS = \"cancelled_by_client\", 1, 0)) + SUM(IF(STATUS = \"cancelled_by_driver\", 1, 0))\\n        ) / COUNT(id),\\n        2\\n    ) AS \\'Cancellation Rate\\'\\nFROM\\n    t1\\nWHERE\\n    request_at BETWEEN \"2013-10-01\"\\n    AND \"2013-10-03\"\\n    AND is_client_banned = \\'No\\'\\n    AND is_driver_banned = \\'No\\'\\nGROUP BY\\n    request_at\\nORDER BY\\n    request_at ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2318963,
                "title": "mysql-3-solutions-using-joins-cte-and-subqueries",
                "content": "1. Using `JOIN` (fastest):\\n```\\nSELECT request_at AS Day, \\n       ROUND(SUM(status != \\'completed\\') / COUNT(*),2) AS \\'Cancellation Rate\\'\\nFROM Trips \\nLEFT JOIN Users AS Clients \\n  ON Trips.client_id = Clients.users_id\\nLEFT JOIN Users AS Drivers\\n  ON Trips.driver_id = Drivers.users_id \\nWHERE Clients.banned = \\'No\\' AND Drivers.banned = \\'No\\' \\n  AND request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY Day\\n```\\n \\n2. Using subqueries:\\n```\\nSELECT request_at AS Day, \\n       ROUND(SUM(status != \\'completed\\') / COUNT(status), 2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n  AND driver_id NOT IN (SELECT users_id FROM Users WHERE banned = \\'Yes\\')\\n  AND client_id NOT IN (SELECT users_id FROM Users WHERE banned = \\'Yes\\')\\nGROUP BY Day\\n```\\n\\n3. Using Common Table Expression (CTE):\\n```\\nWITH TripStatus AS (\\n  SELECT Request_at AS Day, \\n\\t     T.status != \\'completed\\' AS cancelled\\n  FROM Trips T \\n  JOIN Users C \\n    ON Client_Id = C.Users_Id AND C.Banned = \\'No\\' \\n  JOIN Users D \\n    ON Driver_Id = D.Users_Id AND D.Banned = \\'No\\' \\n  WHERE Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n)\\n\\nSELECT Day, ROUND(SUM(cancelled) / COUNT(cancelled), 2) AS \\'Cancellation Rate\\'\\nFROM TripStatus\\nGROUP BY Day;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT request_at AS Day, \\n       ROUND(SUM(status != \\'completed\\') / COUNT(*),2) AS \\'Cancellation Rate\\'\\nFROM Trips \\nLEFT JOIN Users AS Clients \\n  ON Trips.client_id = Clients.users_id\\nLEFT JOIN Users AS Drivers\\n  ON Trips.driver_id = Drivers.users_id \\nWHERE Clients.banned = \\'No\\' AND Drivers.banned = \\'No\\' \\n  AND request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY Day\\n```\n```\\nSELECT request_at AS Day, \\n       ROUND(SUM(status != \\'completed\\') / COUNT(status), 2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n  AND driver_id NOT IN (SELECT users_id FROM Users WHERE banned = \\'Yes\\')\\n  AND client_id NOT IN (SELECT users_id FROM Users WHERE banned = \\'Yes\\')\\nGROUP BY Day\\n```\n```\\nWITH TripStatus AS (\\n  SELECT Request_at AS Day, \\n\\t     T.status != \\'completed\\' AS cancelled\\n  FROM Trips T \\n  JOIN Users C \\n    ON Client_Id = C.Users_Id AND C.Banned = \\'No\\' \\n  JOIN Users D \\n    ON Driver_Id = D.Users_Id AND D.Banned = \\'No\\' \\n  WHERE Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n)\\n\\nSELECT Day, ROUND(SUM(cancelled) / COUNT(cancelled), 2) AS \\'Cancellation Rate\\'\\nFROM TripStatus\\nGROUP BY Day;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2287816,
                "title": "sum-and-count-window-function",
                "content": "select distinct\\nt.request_at as \\'Day\\',\\nCAST(sum(case when t.status in (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') then \\'1\\' else \\'0\\' end) over(partition by t.request_at) /count(*) over(partition by t.request_at) as decimal(10,2)) as \\'Cancellation Rate\\'\\nfrom Trips t join Users u1\\non t.client_id = u1.users_id\\njoin Users u2\\non t.driver_id = u2.users_id\\nwhere \\nu1.banned <> \\'Yes\\'\\nand u2.banned <> \\'Yes\\'",
                "solutionTags": [],
                "code": "select distinct\\nt.request_at as \\'Day\\',\\nCAST(sum(case when t.status in (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') then \\'1\\' else \\'0\\' end) over(partition by t.request_at) /count(*) over(partition by t.request_at) as decimal(10,2)) as \\'Cancellation Rate\\'\\nfrom Trips t join Users u1\\non t.client_id = u1.users_id\\njoin Users u2\\non t.driver_id = u2.users_id\\nwhere \\nu1.banned <> \\'Yes\\'\\nand u2.banned <> \\'Yes\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2285918,
                "title": "this-seemed-pretty-straight-foward-says-98-05-faster-and-zero-memory",
                "content": "debating how can someone get a perfect score haha\\n\\n\\n```\\nSELECT request_at as Day, ROUND((SELECT COUNT(*) FROM trips WHERE (status LIKE \\'cancelled_by%\\' AND request_at = Day) AND client_id NOT IN (SELECT users_id FROM Users WHERE banned = \\'Yes\\' AND Role = \\'client\\') AND client_id NOT IN (SELECT users_id FROM Users WHERE banned = \\'Yes\\' AND Role = \\'driver\\')) / COUNT(request_at),2) as \"Cancellation Rate\" FROM trips WHERE request_at BETWEEN CAST(\\'2013-10-01\\' AS DATE) AND CAST(\\'2013-10-03\\' AS DATE) AND (client_id NOT IN (SELECT DISTINCT users_id FROM Users WHERE banned = \"Yes\" AND role = \"client\" )\\nAND\\ndriver_id NOT IN (SELECT DISTINCT users_id FROM Users WHERE banned = \"Yes\" AND role = \"driver\" )) GROUP BY request_at \\n```",
                "solutionTags": [],
                "code": "```\\nSELECT request_at as Day, ROUND((SELECT COUNT(*) FROM trips WHERE (status LIKE \\'cancelled_by%\\' AND request_at = Day) AND client_id NOT IN (SELECT users_id FROM Users WHERE banned = \\'Yes\\' AND Role = \\'client\\') AND client_id NOT IN (SELECT users_id FROM Users WHERE banned = \\'Yes\\' AND Role = \\'driver\\')) / COUNT(request_at),2) as \"Cancellation Rate\" FROM trips WHERE request_at BETWEEN CAST(\\'2013-10-01\\' AS DATE) AND CAST(\\'2013-10-03\\' AS DATE) AND (client_id NOT IN (SELECT DISTINCT users_id FROM Users WHERE banned = \"Yes\" AND role = \"client\" )\\nAND\\ndriver_id NOT IN (SELECT DISTINCT users_id FROM Users WHERE banned = \"Yes\" AND role = \"driver\" )) GROUP BY request_at \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2274594,
                "title": "cte-mysql-simple-solution",
                "content": "```\\nWITH t1 AS (\\n    SELECT\\n        t.id,\\n        t.client_id,\\n        u1.banned AS is_client_banned,\\n        t.driver_id,\\n        u2.banned AS is_driver_banned,\\n        t.city_id,\\n        t.status,\\n        t.request_at\\n    FROM\\n        Trips t\\n        INNER JOIN Users u1 ON t.client_id = u1.users_id\\n        INNER JOIN Users u2 ON t.driver_id = u2.users_id\\n)\\nSELECT\\n    request_at AS DAY,\\n    ROUND(\\n        (\\n            SUM(IF(STATUS = \"cancelled_by_client\", 1, 0)) + SUM(IF(STATUS = \"cancelled_by_driver\", 1, 0))\\n        ) / COUNT(id),\\n        2\\n    ) AS \\'Cancellation Rate\\'\\nFROM\\n    t1\\nWHERE\\n    request_at BETWEEN \"2013-10-01\"\\n    AND \"2013-10-03\"\\n    AND is_client_banned = \\'No\\'\\n    AND is_driver_banned = \\'No\\'\\nGROUP BY\\n    request_at\\nORDER BY\\n    request_at ASC\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH t1 AS (\\n    SELECT\\n        t.id,\\n        t.client_id,\\n        u1.banned AS is_client_banned,\\n        t.driver_id,\\n        u2.banned AS is_driver_banned,\\n        t.city_id,\\n        t.status,\\n        t.request_at\\n    FROM\\n        Trips t\\n        INNER JOIN Users u1 ON t.client_id = u1.users_id\\n        INNER JOIN Users u2 ON t.driver_id = u2.users_id\\n)\\nSELECT\\n    request_at AS DAY,\\n    ROUND(\\n        (\\n            SUM(IF(STATUS = \"cancelled_by_client\", 1, 0)) + SUM(IF(STATUS = \"cancelled_by_driver\", 1, 0))\\n        ) / COUNT(id),\\n        2\\n    ) AS \\'Cancellation Rate\\'\\nFROM\\n    t1\\nWHERE\\n    request_at BETWEEN \"2013-10-01\"\\n    AND \"2013-10-03\"\\n    AND is_client_banned = \\'No\\'\\n    AND is_driver_banned = \\'No\\'\\nGROUP BY\\n    request_at\\nORDER BY\\n    request_at ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2269285,
                "title": "mysql-simple-solution",
                "content": "```\\n# Write your MySQL query statement below\\nwith t1 \\nas (select T.client_id ,T.status ,T.request_at,U.banned from Trips T \\nleft join Users U on T.client_id=U.users_id\\nwhere U.banned<>\"Yes\")\\n\\nselect request_at as Day,\\nround(sum(if(status<>\"completed\",1,0))/count(status),2) AS \"Cancellation Rate\" from t1 \\nwhere (request_at between \"2013-10-01\" and \"2013-10-03\")\\ngroup by request_at\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith t1 \\nas (select T.client_id ,T.status ,T.request_at,U.banned from Trips T \\nleft join Users U on T.client_id=U.users_id\\nwhere U.banned<>\"Yes\")\\n\\nselect request_at as Day,\\nround(sum(if(status<>\"completed\",1,0))/count(status),2) AS \"Cancellation Rate\" from t1 \\nwhere (request_at between \"2013-10-01\" and \"2013-10-03\")\\ngroup by request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2265031,
                "title": "t-sql-using-subquery-and-inner-join",
                "content": "This solution addressed cases when driver is also banned. The idea is you first create a temporary table `Data` which contains trips taken by Unabanned Driver and Unbanned Clients between the specified Dates. Then you can apply group by to count the number of trips cancelled by either driver or client for each date.\\nDetails on concept of COUNT() and CASE statement are covered in good way [here](https://learnsql.com/blog/difference-between-count-distinct/). (Not sponsored)\\nCAST to DECIMAL to create floating point or else the result will be 0. Also ROUND to 2 decimal places. \\nNote: Although the Output has many trailing zeros, the platform is accepting is as valid.\\n\\n```\\nselect \\nrequest_at as Day, \\nROUND(CAST(count(CASE WHEN status != \\'completed\\' THEN 1 end) as DECIMAL(5, 2)) / count(1), 2)\\nas \\'Cancellation Rate\\'\\nfrom \\n(\\n    select Trips.request_at, Trips.status from Trips join Users as Driver\\n    on Trips.driver_id = Driver.users_id\\n    join Users as Client\\n    on Trips.client_id = Client.users_id\\n    where \\n    Client.banned = \\'No\\' and \\n    Driver.banned = \\'No\\' and \\n    Trips.request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\n) as Data\\ngroup by request_at\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect \\nrequest_at as Day, \\nROUND(CAST(count(CASE WHEN status != \\'completed\\' THEN 1 end) as DECIMAL(5, 2)) / count(1), 2)\\nas \\'Cancellation Rate\\'\\nfrom \\n(\\n    select Trips.request_at, Trips.status from Trips join Users as Driver\\n    on Trips.driver_id = Driver.users_id\\n    join Users as Client\\n    on Trips.client_id = Client.users_id\\n    where \\n    Client.banned = \\'No\\' and \\n    Driver.banned = \\'No\\' and \\n    Trips.request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\n) as Data\\ngroup by request_at\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2223301,
                "title": "simple-solution-runtime-faster-than-96-82-memory-usage-0b-less-than-100-00",
                "content": "select request_at as Day, round(sum(if(status=\\'completed\\', 0, 1))/ count(*) , 2) as `Cancellation Rate`\\nfrom trips\\nwhere client_id not in (select users_id from users where banned = \\'Yes\\')\\nand driver_id not in (select users_id from users where banned = \\'Yes\\')\\nand request_at between \"2013-10-01\" and \"2013-10-03\"\\ngroup by request_at",
                "solutionTags": [],
                "code": "select request_at as Day, round(sum(if(status=\\'completed\\', 0, 1))/ count(*) , 2) as `Cancellation Rate`\\nfrom trips\\nwhere client_id not in (select users_id from users where banned = \\'Yes\\')\\nand driver_id not in (select users_id from users where banned = \\'Yes\\')\\nand request_at between \"2013-10-01\" and \"2013-10-03\"\\ngroup by request_at",
                "codeTag": "Unknown"
            },
            {
                "id": 2205776,
                "title": "oracle-3-solutions-in-exists-join-with-explanation",
                "content": "1. Using IN clause\\n```\\nselect request_at, round(sum(decode(status, \\'completed\\', 0, 1)) / count(status),2) as rate  -- cancelled / total trips   \\nfrom trips\\nwhere request_at BETWEEN \\'2013-10-01\\' and \\'2013-10-03\\'\\nand client_id NOT IN (select users_id from users where banned = \\'Yes\\') and\\ndriver_id NOT IN (select users_id from users where banned = \\'Yes\\')\\ngroup by request_at \\norder by 1;\\n```\\n2. Using EXISTS clause\\n```\\nselect  t.request_at as \"Day\",round(sum(decode(t.status, \\'completed\\',0,1)) / count(t.status),2) as \"Cancellation Rate\"\\nfrom trips t\\nwhere  \\n        exists (select 1 from users u where u.banned = \\'No\\' and u.users_id = t.client_id) and \\n        exists(select 1 from users u where u.banned = \\'No\\' and u.users_id = t.driver_id) and \\n        t.request_at BETWEEN \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by t.request_at\\n```\\n3. Using INNER join\\n```\\nselect \\nt.request_at as Day, round(sum(decode(t.status, \\'completed\\',0,1)) / count(status),2) as \"Cancellation Rate\"\\nfrom trips t, users u, users uu\\nwhere t.client_id = u.users_id and t.driver_id = uu.users_id \\nand u.banned != \\'Yes\\' and uu.banned != \\'Yes\\' and t.request_at BETWEEN \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by t.request_at\\norder by 1\\n```\\n\\n**EXPLAINATION**\\n* First we try to find the number of times the trip was cancelled per day. We can do this using SUM and DECODE functions. Using DECODE, if the trip status is \\'Completed\\' we assign value as 0 and for everything else assign value as 1. And then take the SUM, group by the request date\\n\\n```\\nselect t.request_at,sum(decode(t.status, \\'completed\\',0,1)) as cancellation_count_per_day\\nfrom trips t\\ngroup by t.request_at\\n```\\n* Next we find the *cancellation rate* by diving the number of cancellations per day by total number of trips that day. Round the value to 2 decimal places.\\n```\\nselect t.request_at,round( sum(decode(t.status, \\'completed\\',0,1) ) / count(t.status) , 2) as cancellation_rate\\nfrom trips t\\ngroup by t.request_at\\n```\\n* Next we can filter the result set accordingly, we can use the ***IN*** clause, which is the least complicated. We can also use ***INNER JOIN*** or ***EXISTS*** clause.",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect request_at, round(sum(decode(status, \\'completed\\', 0, 1)) / count(status),2) as rate  -- cancelled / total trips   \\nfrom trips\\nwhere request_at BETWEEN \\'2013-10-01\\' and \\'2013-10-03\\'\\nand client_id NOT IN (select users_id from users where banned = \\'Yes\\') and\\ndriver_id NOT IN (select users_id from users where banned = \\'Yes\\')\\ngroup by request_at \\norder by 1;\\n```\n```\\nselect  t.request_at as \"Day\",round(sum(decode(t.status, \\'completed\\',0,1)) / count(t.status),2) as \"Cancellation Rate\"\\nfrom trips t\\nwhere  \\n        exists (select 1 from users u where u.banned = \\'No\\' and u.users_id = t.client_id) and \\n        exists(select 1 from users u where u.banned = \\'No\\' and u.users_id = t.driver_id) and \\n        t.request_at BETWEEN \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by t.request_at\\n```\n```\\nselect \\nt.request_at as Day, round(sum(decode(t.status, \\'completed\\',0,1)) / count(status),2) as \"Cancellation Rate\"\\nfrom trips t, users u, users uu\\nwhere t.client_id = u.users_id and t.driver_id = uu.users_id \\nand u.banned != \\'Yes\\' and uu.banned != \\'Yes\\' and t.request_at BETWEEN \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by t.request_at\\norder by 1\\n```\n```\\nselect t.request_at,sum(decode(t.status, \\'completed\\',0,1)) as cancellation_count_per_day\\nfrom trips t\\ngroup by t.request_at\\n```\n```\\nselect t.request_at,round( sum(decode(t.status, \\'completed\\',0,1) ) / count(t.status) , 2) as cancellation_rate\\nfrom trips t\\ngroup by t.request_at\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1634434,
                "content": [
                    {
                        "username": "olivershih",
                        "content": "A test case seems wrong:\\n\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\n\\nBoth the client and driver are not banned:\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nSo the output should be one row which has a 100% cancellation rate:\\n\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-04 | 1                 |\\n\\nInstead this is the expected result:\\n\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nAm I missing something?\\n"
                    },
                    {
                        "username": "gjs190201",
                        "content": "[@chaosxlive](/chaosxlive) yaa exactly so you need one more condition as\\n```request_at BETWEEN DATE(\"2013-10-01\") AND DATE(\"2013-10-03\")```"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@chaosxlive](/chaosxlive)  You must check the day like [@Z.B. Weng](/chaosxlive) said, you can do like this:\\n# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "friedkale",
                        "content": "[@chaosxlive](/chaosxlive) wow."
                    },
                    {
                        "username": "bigGheorghe",
                        "content": "[@chaosxlive](/chaosxlive) omg, that\\'s an aggrevating criteria to fail a test on."
                    },
                    {
                        "username": "chaosxlive",
                        "content": "The days picked should be between \\'2013-10-01\\' and \\'2013-10-03\\'. \\'2013-10-04\\' is out of range."
                    },
                    {
                        "username": "roshaniitd88",
                        "content": "Is anyone facing any issue in executing MySQL using WITH CTE clause"
                    },
                    {
                        "username": "shwetashahuc",
                        "content": "no."
                    },
                    {
                        "username": "autodino",
                        "content": "The \"Expected Answer\" is Wrong!!! It doesn\\'t consider banned drivers!!!"
                    },
                    {
                        "username": "coderange",
                        "content": "The answer is right, I forgot to constraint the date."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect \\nRequest_at as Day, \\nround(sum(Status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\'))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips\\nwhere \\nClient_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'client\\') and\\nDriver_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'driver\\') and\\nRequest_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n;"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "select \\nRequest_at as Day,\\nround(sum(status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\' ))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips \\n      where client_id  in (select users_id from Users where banned =\\'No\\')\\n      and driver_id  in (select users_id from Users where banned =\\'No\\')\\n      and Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n\\nwe don\\'t need to specify role = \"client\" or \"driver\" if banned is \"no\""
                    },
                    {
                        "username": "user8565WN",
                        "content": "Based on this test case, my code should pass, but it showing incorrect. \\nNone of the Users are banned, so it should be 100% cancellation.\\n\\nAm i missing something?\\nThank you for your help.\\n\\n![image](https://assets.leetcode.com/users/images/cbfefaa4-9128-4218-a7cc-bb23ec37cee1_1643601252.5488906.png)\\n"
                    },
                    {
                        "username": "anujkn05",
                        "content": " request_at should be between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "mkutarna",
                        "content": "I have the same issue - if there is only 1 request, and it is cancelled, the rate should be 1."
                    },
                    {
                        "username": "kevingao1136",
                        "content": "with a as\\n(select * from Trips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\nand Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\'))\\n\\nselect Request_at as Day,\\n        round(avg(case when Status = \\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\'\\nfrom a\\ngroup by Day\\nhaving Day between \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "prakharbarole2405",
                        "content": "facing problem in naming column with space in mysql"
                    },
                    {
                        "username": "terence1219",
                        "content": "use `column` ( ` symbol)"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "me too, it\\'s so stupid wtf"
                    },
                    {
                        "username": "Sangeetha1695",
                        "content": "I first tried to join and use row_number function to pick only distinct values but sometimes a simple select with where clause is about right to do the job. \\n\\nselect request_at as Day,round((sum(case when status like \\'cancelled%\\' then 1 else 0 end)/count(id)),2) as `Cancellation Rate` \\nfrom trips \\nwhere client_id in (select distinct users_id from users where banned=\\'No\\') \\nand driver_id in (select distinct users_id from users where banned=\\'No\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at"
                    },
                    {
                        "username": "malpus",
                        "content": "# Write your MySQL query statement below\\nselect request_at as \"Day\", \\nround(sum(if(status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\',1,0))/count(*), 2) as \"Cancellation Rate\"\\nfrom trips as t\\njoin users as u1\\non t.client_id = u1.users_id\\njoin users as u2\\non t.driver_id = u2.users_id\\nwhere \\nrequest_at >= \\'2013-10-01\\' and request_at<= \\'2013-10-03\\'\\nand u1.banned = \\'No\\'\\nand u2.banned = \\'No\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "panzihang",
                        "content": "One of the testcases is wrong. Here is how:\\nInput:\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-01\"], [\"2\", \"2\", \"11\", \"1\", \"cancelled_by_driver\", \"2013-10-01\"], [\"3\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-01\"], [\"4\", \"4\", \"13\", \"6\", \"cancelled_by_client\", \"2013-10-01\"], [\"5\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-02\"], [\"6\", \"2\", \"11\", \"6\", \"completed\", \"2013-10-02\"], [\"7\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-02\"], [\"8\", \"2\", \"12\", \"12\", \"completed\", \"2013-10-03\"], [\"9\", \"3\", \"10\", \"12\", \"completed\", \"2013-10-03\"], [\"10\", \"4\", \"13\", \"12\", \"cancelled_by_driver\", \"2013-10-03\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"2\", \"Yes\", \"client\"], [\"3\", \"No\", \"client\"], [\"4\", \"No\", \"client\"], [\"10\", \"Yes\", \"driver\"], [\"11\", \"Yes\", \"driver\"], [\"12\", \"Yes\", \"driver\"], [\"13\", \"No\", \"driver\"]]}}\\nThe input is just replacing the \\'banned\\' status for Driver 10,11,12 from the example input, as they are now banned.\\n**So only Driver 13 is not banned.**\\nThis makes 2013-10-01 and 2013-10-03 both having only 1 valid trip (both are cancelled), and 2013-10-02 having no valid trip.\\nThen **the cancel rate should be 1, null, 1.**\\nBut the expected output is the same as the example: 0.33, 0, 5.\\nHere is a visualization of this testcase\\'s input.\\n![image](https://assets.leetcode.com/users/images/222fde1a-80fc-4ce0-a77c-9ea9ed91a262_1612488816.5813634.png)\\nHere is the submission detail:\\n![image](https://assets.leetcode.com/users/images/56ff7e0a-edd2-4fbc-b348-ed4d226727aa_1612489131.203634.png)\\nIf you find that you passed 9/10 and only this one failed, I think it should be fine."
                    }
                ]
            },
            {
                "id": 1567349,
                "content": [
                    {
                        "username": "olivershih",
                        "content": "A test case seems wrong:\\n\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\n\\nBoth the client and driver are not banned:\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nSo the output should be one row which has a 100% cancellation rate:\\n\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-04 | 1                 |\\n\\nInstead this is the expected result:\\n\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nAm I missing something?\\n"
                    },
                    {
                        "username": "gjs190201",
                        "content": "[@chaosxlive](/chaosxlive) yaa exactly so you need one more condition as\\n```request_at BETWEEN DATE(\"2013-10-01\") AND DATE(\"2013-10-03\")```"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@chaosxlive](/chaosxlive)  You must check the day like [@Z.B. Weng](/chaosxlive) said, you can do like this:\\n# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "friedkale",
                        "content": "[@chaosxlive](/chaosxlive) wow."
                    },
                    {
                        "username": "bigGheorghe",
                        "content": "[@chaosxlive](/chaosxlive) omg, that\\'s an aggrevating criteria to fail a test on."
                    },
                    {
                        "username": "chaosxlive",
                        "content": "The days picked should be between \\'2013-10-01\\' and \\'2013-10-03\\'. \\'2013-10-04\\' is out of range."
                    },
                    {
                        "username": "roshaniitd88",
                        "content": "Is anyone facing any issue in executing MySQL using WITH CTE clause"
                    },
                    {
                        "username": "shwetashahuc",
                        "content": "no."
                    },
                    {
                        "username": "autodino",
                        "content": "The \"Expected Answer\" is Wrong!!! It doesn\\'t consider banned drivers!!!"
                    },
                    {
                        "username": "coderange",
                        "content": "The answer is right, I forgot to constraint the date."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect \\nRequest_at as Day, \\nround(sum(Status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\'))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips\\nwhere \\nClient_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'client\\') and\\nDriver_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'driver\\') and\\nRequest_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n;"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "select \\nRequest_at as Day,\\nround(sum(status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\' ))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips \\n      where client_id  in (select users_id from Users where banned =\\'No\\')\\n      and driver_id  in (select users_id from Users where banned =\\'No\\')\\n      and Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n\\nwe don\\'t need to specify role = \"client\" or \"driver\" if banned is \"no\""
                    },
                    {
                        "username": "user8565WN",
                        "content": "Based on this test case, my code should pass, but it showing incorrect. \\nNone of the Users are banned, so it should be 100% cancellation.\\n\\nAm i missing something?\\nThank you for your help.\\n\\n![image](https://assets.leetcode.com/users/images/cbfefaa4-9128-4218-a7cc-bb23ec37cee1_1643601252.5488906.png)\\n"
                    },
                    {
                        "username": "anujkn05",
                        "content": " request_at should be between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "mkutarna",
                        "content": "I have the same issue - if there is only 1 request, and it is cancelled, the rate should be 1."
                    },
                    {
                        "username": "kevingao1136",
                        "content": "with a as\\n(select * from Trips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\nand Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\'))\\n\\nselect Request_at as Day,\\n        round(avg(case when Status = \\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\'\\nfrom a\\ngroup by Day\\nhaving Day between \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "prakharbarole2405",
                        "content": "facing problem in naming column with space in mysql"
                    },
                    {
                        "username": "terence1219",
                        "content": "use `column` ( ` symbol)"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "me too, it\\'s so stupid wtf"
                    },
                    {
                        "username": "Sangeetha1695",
                        "content": "I first tried to join and use row_number function to pick only distinct values but sometimes a simple select with where clause is about right to do the job. \\n\\nselect request_at as Day,round((sum(case when status like \\'cancelled%\\' then 1 else 0 end)/count(id)),2) as `Cancellation Rate` \\nfrom trips \\nwhere client_id in (select distinct users_id from users where banned=\\'No\\') \\nand driver_id in (select distinct users_id from users where banned=\\'No\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at"
                    },
                    {
                        "username": "malpus",
                        "content": "# Write your MySQL query statement below\\nselect request_at as \"Day\", \\nround(sum(if(status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\',1,0))/count(*), 2) as \"Cancellation Rate\"\\nfrom trips as t\\njoin users as u1\\non t.client_id = u1.users_id\\njoin users as u2\\non t.driver_id = u2.users_id\\nwhere \\nrequest_at >= \\'2013-10-01\\' and request_at<= \\'2013-10-03\\'\\nand u1.banned = \\'No\\'\\nand u2.banned = \\'No\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "panzihang",
                        "content": "One of the testcases is wrong. Here is how:\\nInput:\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-01\"], [\"2\", \"2\", \"11\", \"1\", \"cancelled_by_driver\", \"2013-10-01\"], [\"3\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-01\"], [\"4\", \"4\", \"13\", \"6\", \"cancelled_by_client\", \"2013-10-01\"], [\"5\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-02\"], [\"6\", \"2\", \"11\", \"6\", \"completed\", \"2013-10-02\"], [\"7\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-02\"], [\"8\", \"2\", \"12\", \"12\", \"completed\", \"2013-10-03\"], [\"9\", \"3\", \"10\", \"12\", \"completed\", \"2013-10-03\"], [\"10\", \"4\", \"13\", \"12\", \"cancelled_by_driver\", \"2013-10-03\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"2\", \"Yes\", \"client\"], [\"3\", \"No\", \"client\"], [\"4\", \"No\", \"client\"], [\"10\", \"Yes\", \"driver\"], [\"11\", \"Yes\", \"driver\"], [\"12\", \"Yes\", \"driver\"], [\"13\", \"No\", \"driver\"]]}}\\nThe input is just replacing the \\'banned\\' status for Driver 10,11,12 from the example input, as they are now banned.\\n**So only Driver 13 is not banned.**\\nThis makes 2013-10-01 and 2013-10-03 both having only 1 valid trip (both are cancelled), and 2013-10-02 having no valid trip.\\nThen **the cancel rate should be 1, null, 1.**\\nBut the expected output is the same as the example: 0.33, 0, 5.\\nHere is a visualization of this testcase\\'s input.\\n![image](https://assets.leetcode.com/users/images/222fde1a-80fc-4ce0-a77c-9ea9ed91a262_1612488816.5813634.png)\\nHere is the submission detail:\\n![image](https://assets.leetcode.com/users/images/56ff7e0a-edd2-4fbc-b348-ed4d226727aa_1612489131.203634.png)\\nIf you find that you passed 9/10 and only this one failed, I think it should be fine."
                    }
                ]
            },
            {
                "id": 1569310,
                "content": [
                    {
                        "username": "olivershih",
                        "content": "A test case seems wrong:\\n\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\n\\nBoth the client and driver are not banned:\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nSo the output should be one row which has a 100% cancellation rate:\\n\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-04 | 1                 |\\n\\nInstead this is the expected result:\\n\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nAm I missing something?\\n"
                    },
                    {
                        "username": "gjs190201",
                        "content": "[@chaosxlive](/chaosxlive) yaa exactly so you need one more condition as\\n```request_at BETWEEN DATE(\"2013-10-01\") AND DATE(\"2013-10-03\")```"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@chaosxlive](/chaosxlive)  You must check the day like [@Z.B. Weng](/chaosxlive) said, you can do like this:\\n# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "friedkale",
                        "content": "[@chaosxlive](/chaosxlive) wow."
                    },
                    {
                        "username": "bigGheorghe",
                        "content": "[@chaosxlive](/chaosxlive) omg, that\\'s an aggrevating criteria to fail a test on."
                    },
                    {
                        "username": "chaosxlive",
                        "content": "The days picked should be between \\'2013-10-01\\' and \\'2013-10-03\\'. \\'2013-10-04\\' is out of range."
                    },
                    {
                        "username": "roshaniitd88",
                        "content": "Is anyone facing any issue in executing MySQL using WITH CTE clause"
                    },
                    {
                        "username": "shwetashahuc",
                        "content": "no."
                    },
                    {
                        "username": "autodino",
                        "content": "The \"Expected Answer\" is Wrong!!! It doesn\\'t consider banned drivers!!!"
                    },
                    {
                        "username": "coderange",
                        "content": "The answer is right, I forgot to constraint the date."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect \\nRequest_at as Day, \\nround(sum(Status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\'))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips\\nwhere \\nClient_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'client\\') and\\nDriver_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'driver\\') and\\nRequest_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n;"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "select \\nRequest_at as Day,\\nround(sum(status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\' ))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips \\n      where client_id  in (select users_id from Users where banned =\\'No\\')\\n      and driver_id  in (select users_id from Users where banned =\\'No\\')\\n      and Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n\\nwe don\\'t need to specify role = \"client\" or \"driver\" if banned is \"no\""
                    },
                    {
                        "username": "user8565WN",
                        "content": "Based on this test case, my code should pass, but it showing incorrect. \\nNone of the Users are banned, so it should be 100% cancellation.\\n\\nAm i missing something?\\nThank you for your help.\\n\\n![image](https://assets.leetcode.com/users/images/cbfefaa4-9128-4218-a7cc-bb23ec37cee1_1643601252.5488906.png)\\n"
                    },
                    {
                        "username": "anujkn05",
                        "content": " request_at should be between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "mkutarna",
                        "content": "I have the same issue - if there is only 1 request, and it is cancelled, the rate should be 1."
                    },
                    {
                        "username": "kevingao1136",
                        "content": "with a as\\n(select * from Trips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\nand Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\'))\\n\\nselect Request_at as Day,\\n        round(avg(case when Status = \\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\'\\nfrom a\\ngroup by Day\\nhaving Day between \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "prakharbarole2405",
                        "content": "facing problem in naming column with space in mysql"
                    },
                    {
                        "username": "terence1219",
                        "content": "use `column` ( ` symbol)"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "me too, it\\'s so stupid wtf"
                    },
                    {
                        "username": "Sangeetha1695",
                        "content": "I first tried to join and use row_number function to pick only distinct values but sometimes a simple select with where clause is about right to do the job. \\n\\nselect request_at as Day,round((sum(case when status like \\'cancelled%\\' then 1 else 0 end)/count(id)),2) as `Cancellation Rate` \\nfrom trips \\nwhere client_id in (select distinct users_id from users where banned=\\'No\\') \\nand driver_id in (select distinct users_id from users where banned=\\'No\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at"
                    },
                    {
                        "username": "malpus",
                        "content": "# Write your MySQL query statement below\\nselect request_at as \"Day\", \\nround(sum(if(status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\',1,0))/count(*), 2) as \"Cancellation Rate\"\\nfrom trips as t\\njoin users as u1\\non t.client_id = u1.users_id\\njoin users as u2\\non t.driver_id = u2.users_id\\nwhere \\nrequest_at >= \\'2013-10-01\\' and request_at<= \\'2013-10-03\\'\\nand u1.banned = \\'No\\'\\nand u2.banned = \\'No\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "panzihang",
                        "content": "One of the testcases is wrong. Here is how:\\nInput:\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-01\"], [\"2\", \"2\", \"11\", \"1\", \"cancelled_by_driver\", \"2013-10-01\"], [\"3\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-01\"], [\"4\", \"4\", \"13\", \"6\", \"cancelled_by_client\", \"2013-10-01\"], [\"5\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-02\"], [\"6\", \"2\", \"11\", \"6\", \"completed\", \"2013-10-02\"], [\"7\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-02\"], [\"8\", \"2\", \"12\", \"12\", \"completed\", \"2013-10-03\"], [\"9\", \"3\", \"10\", \"12\", \"completed\", \"2013-10-03\"], [\"10\", \"4\", \"13\", \"12\", \"cancelled_by_driver\", \"2013-10-03\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"2\", \"Yes\", \"client\"], [\"3\", \"No\", \"client\"], [\"4\", \"No\", \"client\"], [\"10\", \"Yes\", \"driver\"], [\"11\", \"Yes\", \"driver\"], [\"12\", \"Yes\", \"driver\"], [\"13\", \"No\", \"driver\"]]}}\\nThe input is just replacing the \\'banned\\' status for Driver 10,11,12 from the example input, as they are now banned.\\n**So only Driver 13 is not banned.**\\nThis makes 2013-10-01 and 2013-10-03 both having only 1 valid trip (both are cancelled), and 2013-10-02 having no valid trip.\\nThen **the cancel rate should be 1, null, 1.**\\nBut the expected output is the same as the example: 0.33, 0, 5.\\nHere is a visualization of this testcase\\'s input.\\n![image](https://assets.leetcode.com/users/images/222fde1a-80fc-4ce0-a77c-9ea9ed91a262_1612488816.5813634.png)\\nHere is the submission detail:\\n![image](https://assets.leetcode.com/users/images/56ff7e0a-edd2-4fbc-b348-ed4d226727aa_1612489131.203634.png)\\nIf you find that you passed 9/10 and only this one failed, I think it should be fine."
                    }
                ]
            },
            {
                "id": 1566871,
                "content": [
                    {
                        "username": "olivershih",
                        "content": "A test case seems wrong:\\n\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\n\\nBoth the client and driver are not banned:\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nSo the output should be one row which has a 100% cancellation rate:\\n\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-04 | 1                 |\\n\\nInstead this is the expected result:\\n\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nAm I missing something?\\n"
                    },
                    {
                        "username": "gjs190201",
                        "content": "[@chaosxlive](/chaosxlive) yaa exactly so you need one more condition as\\n```request_at BETWEEN DATE(\"2013-10-01\") AND DATE(\"2013-10-03\")```"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@chaosxlive](/chaosxlive)  You must check the day like [@Z.B. Weng](/chaosxlive) said, you can do like this:\\n# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "friedkale",
                        "content": "[@chaosxlive](/chaosxlive) wow."
                    },
                    {
                        "username": "bigGheorghe",
                        "content": "[@chaosxlive](/chaosxlive) omg, that\\'s an aggrevating criteria to fail a test on."
                    },
                    {
                        "username": "chaosxlive",
                        "content": "The days picked should be between \\'2013-10-01\\' and \\'2013-10-03\\'. \\'2013-10-04\\' is out of range."
                    },
                    {
                        "username": "roshaniitd88",
                        "content": "Is anyone facing any issue in executing MySQL using WITH CTE clause"
                    },
                    {
                        "username": "shwetashahuc",
                        "content": "no."
                    },
                    {
                        "username": "autodino",
                        "content": "The \"Expected Answer\" is Wrong!!! It doesn\\'t consider banned drivers!!!"
                    },
                    {
                        "username": "coderange",
                        "content": "The answer is right, I forgot to constraint the date."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect \\nRequest_at as Day, \\nround(sum(Status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\'))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips\\nwhere \\nClient_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'client\\') and\\nDriver_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'driver\\') and\\nRequest_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n;"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "select \\nRequest_at as Day,\\nround(sum(status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\' ))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips \\n      where client_id  in (select users_id from Users where banned =\\'No\\')\\n      and driver_id  in (select users_id from Users where banned =\\'No\\')\\n      and Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n\\nwe don\\'t need to specify role = \"client\" or \"driver\" if banned is \"no\""
                    },
                    {
                        "username": "user8565WN",
                        "content": "Based on this test case, my code should pass, but it showing incorrect. \\nNone of the Users are banned, so it should be 100% cancellation.\\n\\nAm i missing something?\\nThank you for your help.\\n\\n![image](https://assets.leetcode.com/users/images/cbfefaa4-9128-4218-a7cc-bb23ec37cee1_1643601252.5488906.png)\\n"
                    },
                    {
                        "username": "anujkn05",
                        "content": " request_at should be between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "mkutarna",
                        "content": "I have the same issue - if there is only 1 request, and it is cancelled, the rate should be 1."
                    },
                    {
                        "username": "kevingao1136",
                        "content": "with a as\\n(select * from Trips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\nand Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\'))\\n\\nselect Request_at as Day,\\n        round(avg(case when Status = \\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\'\\nfrom a\\ngroup by Day\\nhaving Day between \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "prakharbarole2405",
                        "content": "facing problem in naming column with space in mysql"
                    },
                    {
                        "username": "terence1219",
                        "content": "use `column` ( ` symbol)"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "me too, it\\'s so stupid wtf"
                    },
                    {
                        "username": "Sangeetha1695",
                        "content": "I first tried to join and use row_number function to pick only distinct values but sometimes a simple select with where clause is about right to do the job. \\n\\nselect request_at as Day,round((sum(case when status like \\'cancelled%\\' then 1 else 0 end)/count(id)),2) as `Cancellation Rate` \\nfrom trips \\nwhere client_id in (select distinct users_id from users where banned=\\'No\\') \\nand driver_id in (select distinct users_id from users where banned=\\'No\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at"
                    },
                    {
                        "username": "malpus",
                        "content": "# Write your MySQL query statement below\\nselect request_at as \"Day\", \\nround(sum(if(status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\',1,0))/count(*), 2) as \"Cancellation Rate\"\\nfrom trips as t\\njoin users as u1\\non t.client_id = u1.users_id\\njoin users as u2\\non t.driver_id = u2.users_id\\nwhere \\nrequest_at >= \\'2013-10-01\\' and request_at<= \\'2013-10-03\\'\\nand u1.banned = \\'No\\'\\nand u2.banned = \\'No\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "panzihang",
                        "content": "One of the testcases is wrong. Here is how:\\nInput:\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-01\"], [\"2\", \"2\", \"11\", \"1\", \"cancelled_by_driver\", \"2013-10-01\"], [\"3\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-01\"], [\"4\", \"4\", \"13\", \"6\", \"cancelled_by_client\", \"2013-10-01\"], [\"5\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-02\"], [\"6\", \"2\", \"11\", \"6\", \"completed\", \"2013-10-02\"], [\"7\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-02\"], [\"8\", \"2\", \"12\", \"12\", \"completed\", \"2013-10-03\"], [\"9\", \"3\", \"10\", \"12\", \"completed\", \"2013-10-03\"], [\"10\", \"4\", \"13\", \"12\", \"cancelled_by_driver\", \"2013-10-03\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"2\", \"Yes\", \"client\"], [\"3\", \"No\", \"client\"], [\"4\", \"No\", \"client\"], [\"10\", \"Yes\", \"driver\"], [\"11\", \"Yes\", \"driver\"], [\"12\", \"Yes\", \"driver\"], [\"13\", \"No\", \"driver\"]]}}\\nThe input is just replacing the \\'banned\\' status for Driver 10,11,12 from the example input, as they are now banned.\\n**So only Driver 13 is not banned.**\\nThis makes 2013-10-01 and 2013-10-03 both having only 1 valid trip (both are cancelled), and 2013-10-02 having no valid trip.\\nThen **the cancel rate should be 1, null, 1.**\\nBut the expected output is the same as the example: 0.33, 0, 5.\\nHere is a visualization of this testcase\\'s input.\\n![image](https://assets.leetcode.com/users/images/222fde1a-80fc-4ce0-a77c-9ea9ed91a262_1612488816.5813634.png)\\nHere is the submission detail:\\n![image](https://assets.leetcode.com/users/images/56ff7e0a-edd2-4fbc-b348-ed4d226727aa_1612489131.203634.png)\\nIf you find that you passed 9/10 and only this one failed, I think it should be fine."
                    }
                ]
            },
            {
                "id": 1576313,
                "content": [
                    {
                        "username": "olivershih",
                        "content": "A test case seems wrong:\\n\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\n\\nBoth the client and driver are not banned:\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nSo the output should be one row which has a 100% cancellation rate:\\n\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-04 | 1                 |\\n\\nInstead this is the expected result:\\n\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nAm I missing something?\\n"
                    },
                    {
                        "username": "gjs190201",
                        "content": "[@chaosxlive](/chaosxlive) yaa exactly so you need one more condition as\\n```request_at BETWEEN DATE(\"2013-10-01\") AND DATE(\"2013-10-03\")```"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@chaosxlive](/chaosxlive)  You must check the day like [@Z.B. Weng](/chaosxlive) said, you can do like this:\\n# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "friedkale",
                        "content": "[@chaosxlive](/chaosxlive) wow."
                    },
                    {
                        "username": "bigGheorghe",
                        "content": "[@chaosxlive](/chaosxlive) omg, that\\'s an aggrevating criteria to fail a test on."
                    },
                    {
                        "username": "chaosxlive",
                        "content": "The days picked should be between \\'2013-10-01\\' and \\'2013-10-03\\'. \\'2013-10-04\\' is out of range."
                    },
                    {
                        "username": "roshaniitd88",
                        "content": "Is anyone facing any issue in executing MySQL using WITH CTE clause"
                    },
                    {
                        "username": "shwetashahuc",
                        "content": "no."
                    },
                    {
                        "username": "autodino",
                        "content": "The \"Expected Answer\" is Wrong!!! It doesn\\'t consider banned drivers!!!"
                    },
                    {
                        "username": "coderange",
                        "content": "The answer is right, I forgot to constraint the date."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect \\nRequest_at as Day, \\nround(sum(Status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\'))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips\\nwhere \\nClient_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'client\\') and\\nDriver_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'driver\\') and\\nRequest_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n;"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "select \\nRequest_at as Day,\\nround(sum(status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\' ))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips \\n      where client_id  in (select users_id from Users where banned =\\'No\\')\\n      and driver_id  in (select users_id from Users where banned =\\'No\\')\\n      and Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n\\nwe don\\'t need to specify role = \"client\" or \"driver\" if banned is \"no\""
                    },
                    {
                        "username": "user8565WN",
                        "content": "Based on this test case, my code should pass, but it showing incorrect. \\nNone of the Users are banned, so it should be 100% cancellation.\\n\\nAm i missing something?\\nThank you for your help.\\n\\n![image](https://assets.leetcode.com/users/images/cbfefaa4-9128-4218-a7cc-bb23ec37cee1_1643601252.5488906.png)\\n"
                    },
                    {
                        "username": "anujkn05",
                        "content": " request_at should be between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "mkutarna",
                        "content": "I have the same issue - if there is only 1 request, and it is cancelled, the rate should be 1."
                    },
                    {
                        "username": "kevingao1136",
                        "content": "with a as\\n(select * from Trips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\nand Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\'))\\n\\nselect Request_at as Day,\\n        round(avg(case when Status = \\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\'\\nfrom a\\ngroup by Day\\nhaving Day between \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "prakharbarole2405",
                        "content": "facing problem in naming column with space in mysql"
                    },
                    {
                        "username": "terence1219",
                        "content": "use `column` ( ` symbol)"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "me too, it\\'s so stupid wtf"
                    },
                    {
                        "username": "Sangeetha1695",
                        "content": "I first tried to join and use row_number function to pick only distinct values but sometimes a simple select with where clause is about right to do the job. \\n\\nselect request_at as Day,round((sum(case when status like \\'cancelled%\\' then 1 else 0 end)/count(id)),2) as `Cancellation Rate` \\nfrom trips \\nwhere client_id in (select distinct users_id from users where banned=\\'No\\') \\nand driver_id in (select distinct users_id from users where banned=\\'No\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at"
                    },
                    {
                        "username": "malpus",
                        "content": "# Write your MySQL query statement below\\nselect request_at as \"Day\", \\nround(sum(if(status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\',1,0))/count(*), 2) as \"Cancellation Rate\"\\nfrom trips as t\\njoin users as u1\\non t.client_id = u1.users_id\\njoin users as u2\\non t.driver_id = u2.users_id\\nwhere \\nrequest_at >= \\'2013-10-01\\' and request_at<= \\'2013-10-03\\'\\nand u1.banned = \\'No\\'\\nand u2.banned = \\'No\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "panzihang",
                        "content": "One of the testcases is wrong. Here is how:\\nInput:\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-01\"], [\"2\", \"2\", \"11\", \"1\", \"cancelled_by_driver\", \"2013-10-01\"], [\"3\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-01\"], [\"4\", \"4\", \"13\", \"6\", \"cancelled_by_client\", \"2013-10-01\"], [\"5\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-02\"], [\"6\", \"2\", \"11\", \"6\", \"completed\", \"2013-10-02\"], [\"7\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-02\"], [\"8\", \"2\", \"12\", \"12\", \"completed\", \"2013-10-03\"], [\"9\", \"3\", \"10\", \"12\", \"completed\", \"2013-10-03\"], [\"10\", \"4\", \"13\", \"12\", \"cancelled_by_driver\", \"2013-10-03\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"2\", \"Yes\", \"client\"], [\"3\", \"No\", \"client\"], [\"4\", \"No\", \"client\"], [\"10\", \"Yes\", \"driver\"], [\"11\", \"Yes\", \"driver\"], [\"12\", \"Yes\", \"driver\"], [\"13\", \"No\", \"driver\"]]}}\\nThe input is just replacing the \\'banned\\' status for Driver 10,11,12 from the example input, as they are now banned.\\n**So only Driver 13 is not banned.**\\nThis makes 2013-10-01 and 2013-10-03 both having only 1 valid trip (both are cancelled), and 2013-10-02 having no valid trip.\\nThen **the cancel rate should be 1, null, 1.**\\nBut the expected output is the same as the example: 0.33, 0, 5.\\nHere is a visualization of this testcase\\'s input.\\n![image](https://assets.leetcode.com/users/images/222fde1a-80fc-4ce0-a77c-9ea9ed91a262_1612488816.5813634.png)\\nHere is the submission detail:\\n![image](https://assets.leetcode.com/users/images/56ff7e0a-edd2-4fbc-b348-ed4d226727aa_1612489131.203634.png)\\nIf you find that you passed 9/10 and only this one failed, I think it should be fine."
                    }
                ]
            },
            {
                "id": 1570121,
                "content": [
                    {
                        "username": "olivershih",
                        "content": "A test case seems wrong:\\n\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\n\\nBoth the client and driver are not banned:\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nSo the output should be one row which has a 100% cancellation rate:\\n\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-04 | 1                 |\\n\\nInstead this is the expected result:\\n\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nAm I missing something?\\n"
                    },
                    {
                        "username": "gjs190201",
                        "content": "[@chaosxlive](/chaosxlive) yaa exactly so you need one more condition as\\n```request_at BETWEEN DATE(\"2013-10-01\") AND DATE(\"2013-10-03\")```"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@chaosxlive](/chaosxlive)  You must check the day like [@Z.B. Weng](/chaosxlive) said, you can do like this:\\n# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "friedkale",
                        "content": "[@chaosxlive](/chaosxlive) wow."
                    },
                    {
                        "username": "bigGheorghe",
                        "content": "[@chaosxlive](/chaosxlive) omg, that\\'s an aggrevating criteria to fail a test on."
                    },
                    {
                        "username": "chaosxlive",
                        "content": "The days picked should be between \\'2013-10-01\\' and \\'2013-10-03\\'. \\'2013-10-04\\' is out of range."
                    },
                    {
                        "username": "roshaniitd88",
                        "content": "Is anyone facing any issue in executing MySQL using WITH CTE clause"
                    },
                    {
                        "username": "shwetashahuc",
                        "content": "no."
                    },
                    {
                        "username": "autodino",
                        "content": "The \"Expected Answer\" is Wrong!!! It doesn\\'t consider banned drivers!!!"
                    },
                    {
                        "username": "coderange",
                        "content": "The answer is right, I forgot to constraint the date."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect \\nRequest_at as Day, \\nround(sum(Status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\'))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips\\nwhere \\nClient_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'client\\') and\\nDriver_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'driver\\') and\\nRequest_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n;"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "select \\nRequest_at as Day,\\nround(sum(status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\' ))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips \\n      where client_id  in (select users_id from Users where banned =\\'No\\')\\n      and driver_id  in (select users_id from Users where banned =\\'No\\')\\n      and Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n\\nwe don\\'t need to specify role = \"client\" or \"driver\" if banned is \"no\""
                    },
                    {
                        "username": "user8565WN",
                        "content": "Based on this test case, my code should pass, but it showing incorrect. \\nNone of the Users are banned, so it should be 100% cancellation.\\n\\nAm i missing something?\\nThank you for your help.\\n\\n![image](https://assets.leetcode.com/users/images/cbfefaa4-9128-4218-a7cc-bb23ec37cee1_1643601252.5488906.png)\\n"
                    },
                    {
                        "username": "anujkn05",
                        "content": " request_at should be between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "mkutarna",
                        "content": "I have the same issue - if there is only 1 request, and it is cancelled, the rate should be 1."
                    },
                    {
                        "username": "kevingao1136",
                        "content": "with a as\\n(select * from Trips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\nand Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\'))\\n\\nselect Request_at as Day,\\n        round(avg(case when Status = \\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\'\\nfrom a\\ngroup by Day\\nhaving Day between \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "prakharbarole2405",
                        "content": "facing problem in naming column with space in mysql"
                    },
                    {
                        "username": "terence1219",
                        "content": "use `column` ( ` symbol)"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "me too, it\\'s so stupid wtf"
                    },
                    {
                        "username": "Sangeetha1695",
                        "content": "I first tried to join and use row_number function to pick only distinct values but sometimes a simple select with where clause is about right to do the job. \\n\\nselect request_at as Day,round((sum(case when status like \\'cancelled%\\' then 1 else 0 end)/count(id)),2) as `Cancellation Rate` \\nfrom trips \\nwhere client_id in (select distinct users_id from users where banned=\\'No\\') \\nand driver_id in (select distinct users_id from users where banned=\\'No\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at"
                    },
                    {
                        "username": "malpus",
                        "content": "# Write your MySQL query statement below\\nselect request_at as \"Day\", \\nround(sum(if(status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\',1,0))/count(*), 2) as \"Cancellation Rate\"\\nfrom trips as t\\njoin users as u1\\non t.client_id = u1.users_id\\njoin users as u2\\non t.driver_id = u2.users_id\\nwhere \\nrequest_at >= \\'2013-10-01\\' and request_at<= \\'2013-10-03\\'\\nand u1.banned = \\'No\\'\\nand u2.banned = \\'No\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "panzihang",
                        "content": "One of the testcases is wrong. Here is how:\\nInput:\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-01\"], [\"2\", \"2\", \"11\", \"1\", \"cancelled_by_driver\", \"2013-10-01\"], [\"3\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-01\"], [\"4\", \"4\", \"13\", \"6\", \"cancelled_by_client\", \"2013-10-01\"], [\"5\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-02\"], [\"6\", \"2\", \"11\", \"6\", \"completed\", \"2013-10-02\"], [\"7\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-02\"], [\"8\", \"2\", \"12\", \"12\", \"completed\", \"2013-10-03\"], [\"9\", \"3\", \"10\", \"12\", \"completed\", \"2013-10-03\"], [\"10\", \"4\", \"13\", \"12\", \"cancelled_by_driver\", \"2013-10-03\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"2\", \"Yes\", \"client\"], [\"3\", \"No\", \"client\"], [\"4\", \"No\", \"client\"], [\"10\", \"Yes\", \"driver\"], [\"11\", \"Yes\", \"driver\"], [\"12\", \"Yes\", \"driver\"], [\"13\", \"No\", \"driver\"]]}}\\nThe input is just replacing the \\'banned\\' status for Driver 10,11,12 from the example input, as they are now banned.\\n**So only Driver 13 is not banned.**\\nThis makes 2013-10-01 and 2013-10-03 both having only 1 valid trip (both are cancelled), and 2013-10-02 having no valid trip.\\nThen **the cancel rate should be 1, null, 1.**\\nBut the expected output is the same as the example: 0.33, 0, 5.\\nHere is a visualization of this testcase\\'s input.\\n![image](https://assets.leetcode.com/users/images/222fde1a-80fc-4ce0-a77c-9ea9ed91a262_1612488816.5813634.png)\\nHere is the submission detail:\\n![image](https://assets.leetcode.com/users/images/56ff7e0a-edd2-4fbc-b348-ed4d226727aa_1612489131.203634.png)\\nIf you find that you passed 9/10 and only this one failed, I think it should be fine."
                    }
                ]
            },
            {
                "id": 1705017,
                "content": [
                    {
                        "username": "olivershih",
                        "content": "A test case seems wrong:\\n\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\n\\nBoth the client and driver are not banned:\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nSo the output should be one row which has a 100% cancellation rate:\\n\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-04 | 1                 |\\n\\nInstead this is the expected result:\\n\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nAm I missing something?\\n"
                    },
                    {
                        "username": "gjs190201",
                        "content": "[@chaosxlive](/chaosxlive) yaa exactly so you need one more condition as\\n```request_at BETWEEN DATE(\"2013-10-01\") AND DATE(\"2013-10-03\")```"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@chaosxlive](/chaosxlive)  You must check the day like [@Z.B. Weng](/chaosxlive) said, you can do like this:\\n# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "friedkale",
                        "content": "[@chaosxlive](/chaosxlive) wow."
                    },
                    {
                        "username": "bigGheorghe",
                        "content": "[@chaosxlive](/chaosxlive) omg, that\\'s an aggrevating criteria to fail a test on."
                    },
                    {
                        "username": "chaosxlive",
                        "content": "The days picked should be between \\'2013-10-01\\' and \\'2013-10-03\\'. \\'2013-10-04\\' is out of range."
                    },
                    {
                        "username": "roshaniitd88",
                        "content": "Is anyone facing any issue in executing MySQL using WITH CTE clause"
                    },
                    {
                        "username": "shwetashahuc",
                        "content": "no."
                    },
                    {
                        "username": "autodino",
                        "content": "The \"Expected Answer\" is Wrong!!! It doesn\\'t consider banned drivers!!!"
                    },
                    {
                        "username": "coderange",
                        "content": "The answer is right, I forgot to constraint the date."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect \\nRequest_at as Day, \\nround(sum(Status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\'))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips\\nwhere \\nClient_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'client\\') and\\nDriver_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'driver\\') and\\nRequest_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n;"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "select \\nRequest_at as Day,\\nround(sum(status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\' ))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips \\n      where client_id  in (select users_id from Users where banned =\\'No\\')\\n      and driver_id  in (select users_id from Users where banned =\\'No\\')\\n      and Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n\\nwe don\\'t need to specify role = \"client\" or \"driver\" if banned is \"no\""
                    },
                    {
                        "username": "user8565WN",
                        "content": "Based on this test case, my code should pass, but it showing incorrect. \\nNone of the Users are banned, so it should be 100% cancellation.\\n\\nAm i missing something?\\nThank you for your help.\\n\\n![image](https://assets.leetcode.com/users/images/cbfefaa4-9128-4218-a7cc-bb23ec37cee1_1643601252.5488906.png)\\n"
                    },
                    {
                        "username": "anujkn05",
                        "content": " request_at should be between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "mkutarna",
                        "content": "I have the same issue - if there is only 1 request, and it is cancelled, the rate should be 1."
                    },
                    {
                        "username": "kevingao1136",
                        "content": "with a as\\n(select * from Trips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\nand Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\'))\\n\\nselect Request_at as Day,\\n        round(avg(case when Status = \\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\'\\nfrom a\\ngroup by Day\\nhaving Day between \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "prakharbarole2405",
                        "content": "facing problem in naming column with space in mysql"
                    },
                    {
                        "username": "terence1219",
                        "content": "use `column` ( ` symbol)"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "me too, it\\'s so stupid wtf"
                    },
                    {
                        "username": "Sangeetha1695",
                        "content": "I first tried to join and use row_number function to pick only distinct values but sometimes a simple select with where clause is about right to do the job. \\n\\nselect request_at as Day,round((sum(case when status like \\'cancelled%\\' then 1 else 0 end)/count(id)),2) as `Cancellation Rate` \\nfrom trips \\nwhere client_id in (select distinct users_id from users where banned=\\'No\\') \\nand driver_id in (select distinct users_id from users where banned=\\'No\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at"
                    },
                    {
                        "username": "malpus",
                        "content": "# Write your MySQL query statement below\\nselect request_at as \"Day\", \\nround(sum(if(status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\',1,0))/count(*), 2) as \"Cancellation Rate\"\\nfrom trips as t\\njoin users as u1\\non t.client_id = u1.users_id\\njoin users as u2\\non t.driver_id = u2.users_id\\nwhere \\nrequest_at >= \\'2013-10-01\\' and request_at<= \\'2013-10-03\\'\\nand u1.banned = \\'No\\'\\nand u2.banned = \\'No\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "panzihang",
                        "content": "One of the testcases is wrong. Here is how:\\nInput:\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-01\"], [\"2\", \"2\", \"11\", \"1\", \"cancelled_by_driver\", \"2013-10-01\"], [\"3\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-01\"], [\"4\", \"4\", \"13\", \"6\", \"cancelled_by_client\", \"2013-10-01\"], [\"5\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-02\"], [\"6\", \"2\", \"11\", \"6\", \"completed\", \"2013-10-02\"], [\"7\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-02\"], [\"8\", \"2\", \"12\", \"12\", \"completed\", \"2013-10-03\"], [\"9\", \"3\", \"10\", \"12\", \"completed\", \"2013-10-03\"], [\"10\", \"4\", \"13\", \"12\", \"cancelled_by_driver\", \"2013-10-03\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"2\", \"Yes\", \"client\"], [\"3\", \"No\", \"client\"], [\"4\", \"No\", \"client\"], [\"10\", \"Yes\", \"driver\"], [\"11\", \"Yes\", \"driver\"], [\"12\", \"Yes\", \"driver\"], [\"13\", \"No\", \"driver\"]]}}\\nThe input is just replacing the \\'banned\\' status for Driver 10,11,12 from the example input, as they are now banned.\\n**So only Driver 13 is not banned.**\\nThis makes 2013-10-01 and 2013-10-03 both having only 1 valid trip (both are cancelled), and 2013-10-02 having no valid trip.\\nThen **the cancel rate should be 1, null, 1.**\\nBut the expected output is the same as the example: 0.33, 0, 5.\\nHere is a visualization of this testcase\\'s input.\\n![image](https://assets.leetcode.com/users/images/222fde1a-80fc-4ce0-a77c-9ea9ed91a262_1612488816.5813634.png)\\nHere is the submission detail:\\n![image](https://assets.leetcode.com/users/images/56ff7e0a-edd2-4fbc-b348-ed4d226727aa_1612489131.203634.png)\\nIf you find that you passed 9/10 and only this one failed, I think it should be fine."
                    }
                ]
            },
            {
                "id": 1576842,
                "content": [
                    {
                        "username": "olivershih",
                        "content": "A test case seems wrong:\\n\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\n\\nBoth the client and driver are not banned:\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nSo the output should be one row which has a 100% cancellation rate:\\n\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-04 | 1                 |\\n\\nInstead this is the expected result:\\n\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nAm I missing something?\\n"
                    },
                    {
                        "username": "gjs190201",
                        "content": "[@chaosxlive](/chaosxlive) yaa exactly so you need one more condition as\\n```request_at BETWEEN DATE(\"2013-10-01\") AND DATE(\"2013-10-03\")```"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@chaosxlive](/chaosxlive)  You must check the day like [@Z.B. Weng](/chaosxlive) said, you can do like this:\\n# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "friedkale",
                        "content": "[@chaosxlive](/chaosxlive) wow."
                    },
                    {
                        "username": "bigGheorghe",
                        "content": "[@chaosxlive](/chaosxlive) omg, that\\'s an aggrevating criteria to fail a test on."
                    },
                    {
                        "username": "chaosxlive",
                        "content": "The days picked should be between \\'2013-10-01\\' and \\'2013-10-03\\'. \\'2013-10-04\\' is out of range."
                    },
                    {
                        "username": "roshaniitd88",
                        "content": "Is anyone facing any issue in executing MySQL using WITH CTE clause"
                    },
                    {
                        "username": "shwetashahuc",
                        "content": "no."
                    },
                    {
                        "username": "autodino",
                        "content": "The \"Expected Answer\" is Wrong!!! It doesn\\'t consider banned drivers!!!"
                    },
                    {
                        "username": "coderange",
                        "content": "The answer is right, I forgot to constraint the date."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect \\nRequest_at as Day, \\nround(sum(Status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\'))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips\\nwhere \\nClient_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'client\\') and\\nDriver_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'driver\\') and\\nRequest_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n;"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "select \\nRequest_at as Day,\\nround(sum(status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\' ))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips \\n      where client_id  in (select users_id from Users where banned =\\'No\\')\\n      and driver_id  in (select users_id from Users where banned =\\'No\\')\\n      and Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n\\nwe don\\'t need to specify role = \"client\" or \"driver\" if banned is \"no\""
                    },
                    {
                        "username": "user8565WN",
                        "content": "Based on this test case, my code should pass, but it showing incorrect. \\nNone of the Users are banned, so it should be 100% cancellation.\\n\\nAm i missing something?\\nThank you for your help.\\n\\n![image](https://assets.leetcode.com/users/images/cbfefaa4-9128-4218-a7cc-bb23ec37cee1_1643601252.5488906.png)\\n"
                    },
                    {
                        "username": "anujkn05",
                        "content": " request_at should be between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "mkutarna",
                        "content": "I have the same issue - if there is only 1 request, and it is cancelled, the rate should be 1."
                    },
                    {
                        "username": "kevingao1136",
                        "content": "with a as\\n(select * from Trips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\nand Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\'))\\n\\nselect Request_at as Day,\\n        round(avg(case when Status = \\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\'\\nfrom a\\ngroup by Day\\nhaving Day between \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "prakharbarole2405",
                        "content": "facing problem in naming column with space in mysql"
                    },
                    {
                        "username": "terence1219",
                        "content": "use `column` ( ` symbol)"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "me too, it\\'s so stupid wtf"
                    },
                    {
                        "username": "Sangeetha1695",
                        "content": "I first tried to join and use row_number function to pick only distinct values but sometimes a simple select with where clause is about right to do the job. \\n\\nselect request_at as Day,round((sum(case when status like \\'cancelled%\\' then 1 else 0 end)/count(id)),2) as `Cancellation Rate` \\nfrom trips \\nwhere client_id in (select distinct users_id from users where banned=\\'No\\') \\nand driver_id in (select distinct users_id from users where banned=\\'No\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at"
                    },
                    {
                        "username": "malpus",
                        "content": "# Write your MySQL query statement below\\nselect request_at as \"Day\", \\nround(sum(if(status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\',1,0))/count(*), 2) as \"Cancellation Rate\"\\nfrom trips as t\\njoin users as u1\\non t.client_id = u1.users_id\\njoin users as u2\\non t.driver_id = u2.users_id\\nwhere \\nrequest_at >= \\'2013-10-01\\' and request_at<= \\'2013-10-03\\'\\nand u1.banned = \\'No\\'\\nand u2.banned = \\'No\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "panzihang",
                        "content": "One of the testcases is wrong. Here is how:\\nInput:\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-01\"], [\"2\", \"2\", \"11\", \"1\", \"cancelled_by_driver\", \"2013-10-01\"], [\"3\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-01\"], [\"4\", \"4\", \"13\", \"6\", \"cancelled_by_client\", \"2013-10-01\"], [\"5\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-02\"], [\"6\", \"2\", \"11\", \"6\", \"completed\", \"2013-10-02\"], [\"7\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-02\"], [\"8\", \"2\", \"12\", \"12\", \"completed\", \"2013-10-03\"], [\"9\", \"3\", \"10\", \"12\", \"completed\", \"2013-10-03\"], [\"10\", \"4\", \"13\", \"12\", \"cancelled_by_driver\", \"2013-10-03\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"2\", \"Yes\", \"client\"], [\"3\", \"No\", \"client\"], [\"4\", \"No\", \"client\"], [\"10\", \"Yes\", \"driver\"], [\"11\", \"Yes\", \"driver\"], [\"12\", \"Yes\", \"driver\"], [\"13\", \"No\", \"driver\"]]}}\\nThe input is just replacing the \\'banned\\' status for Driver 10,11,12 from the example input, as they are now banned.\\n**So only Driver 13 is not banned.**\\nThis makes 2013-10-01 and 2013-10-03 both having only 1 valid trip (both are cancelled), and 2013-10-02 having no valid trip.\\nThen **the cancel rate should be 1, null, 1.**\\nBut the expected output is the same as the example: 0.33, 0, 5.\\nHere is a visualization of this testcase\\'s input.\\n![image](https://assets.leetcode.com/users/images/222fde1a-80fc-4ce0-a77c-9ea9ed91a262_1612488816.5813634.png)\\nHere is the submission detail:\\n![image](https://assets.leetcode.com/users/images/56ff7e0a-edd2-4fbc-b348-ed4d226727aa_1612489131.203634.png)\\nIf you find that you passed 9/10 and only this one failed, I think it should be fine."
                    }
                ]
            },
            {
                "id": 1576696,
                "content": [
                    {
                        "username": "olivershih",
                        "content": "A test case seems wrong:\\n\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\n\\nBoth the client and driver are not banned:\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nSo the output should be one row which has a 100% cancellation rate:\\n\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-04 | 1                 |\\n\\nInstead this is the expected result:\\n\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nAm I missing something?\\n"
                    },
                    {
                        "username": "gjs190201",
                        "content": "[@chaosxlive](/chaosxlive) yaa exactly so you need one more condition as\\n```request_at BETWEEN DATE(\"2013-10-01\") AND DATE(\"2013-10-03\")```"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@chaosxlive](/chaosxlive)  You must check the day like [@Z.B. Weng](/chaosxlive) said, you can do like this:\\n# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "friedkale",
                        "content": "[@chaosxlive](/chaosxlive) wow."
                    },
                    {
                        "username": "bigGheorghe",
                        "content": "[@chaosxlive](/chaosxlive) omg, that\\'s an aggrevating criteria to fail a test on."
                    },
                    {
                        "username": "chaosxlive",
                        "content": "The days picked should be between \\'2013-10-01\\' and \\'2013-10-03\\'. \\'2013-10-04\\' is out of range."
                    },
                    {
                        "username": "roshaniitd88",
                        "content": "Is anyone facing any issue in executing MySQL using WITH CTE clause"
                    },
                    {
                        "username": "shwetashahuc",
                        "content": "no."
                    },
                    {
                        "username": "autodino",
                        "content": "The \"Expected Answer\" is Wrong!!! It doesn\\'t consider banned drivers!!!"
                    },
                    {
                        "username": "coderange",
                        "content": "The answer is right, I forgot to constraint the date."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect \\nRequest_at as Day, \\nround(sum(Status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\'))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips\\nwhere \\nClient_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'client\\') and\\nDriver_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'driver\\') and\\nRequest_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n;"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "select \\nRequest_at as Day,\\nround(sum(status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\' ))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips \\n      where client_id  in (select users_id from Users where banned =\\'No\\')\\n      and driver_id  in (select users_id from Users where banned =\\'No\\')\\n      and Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n\\nwe don\\'t need to specify role = \"client\" or \"driver\" if banned is \"no\""
                    },
                    {
                        "username": "user8565WN",
                        "content": "Based on this test case, my code should pass, but it showing incorrect. \\nNone of the Users are banned, so it should be 100% cancellation.\\n\\nAm i missing something?\\nThank you for your help.\\n\\n![image](https://assets.leetcode.com/users/images/cbfefaa4-9128-4218-a7cc-bb23ec37cee1_1643601252.5488906.png)\\n"
                    },
                    {
                        "username": "anujkn05",
                        "content": " request_at should be between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "mkutarna",
                        "content": "I have the same issue - if there is only 1 request, and it is cancelled, the rate should be 1."
                    },
                    {
                        "username": "kevingao1136",
                        "content": "with a as\\n(select * from Trips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\nand Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\'))\\n\\nselect Request_at as Day,\\n        round(avg(case when Status = \\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\'\\nfrom a\\ngroup by Day\\nhaving Day between \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "prakharbarole2405",
                        "content": "facing problem in naming column with space in mysql"
                    },
                    {
                        "username": "terence1219",
                        "content": "use `column` ( ` symbol)"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "me too, it\\'s so stupid wtf"
                    },
                    {
                        "username": "Sangeetha1695",
                        "content": "I first tried to join and use row_number function to pick only distinct values but sometimes a simple select with where clause is about right to do the job. \\n\\nselect request_at as Day,round((sum(case when status like \\'cancelled%\\' then 1 else 0 end)/count(id)),2) as `Cancellation Rate` \\nfrom trips \\nwhere client_id in (select distinct users_id from users where banned=\\'No\\') \\nand driver_id in (select distinct users_id from users where banned=\\'No\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at"
                    },
                    {
                        "username": "malpus",
                        "content": "# Write your MySQL query statement below\\nselect request_at as \"Day\", \\nround(sum(if(status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\',1,0))/count(*), 2) as \"Cancellation Rate\"\\nfrom trips as t\\njoin users as u1\\non t.client_id = u1.users_id\\njoin users as u2\\non t.driver_id = u2.users_id\\nwhere \\nrequest_at >= \\'2013-10-01\\' and request_at<= \\'2013-10-03\\'\\nand u1.banned = \\'No\\'\\nand u2.banned = \\'No\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "panzihang",
                        "content": "One of the testcases is wrong. Here is how:\\nInput:\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-01\"], [\"2\", \"2\", \"11\", \"1\", \"cancelled_by_driver\", \"2013-10-01\"], [\"3\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-01\"], [\"4\", \"4\", \"13\", \"6\", \"cancelled_by_client\", \"2013-10-01\"], [\"5\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-02\"], [\"6\", \"2\", \"11\", \"6\", \"completed\", \"2013-10-02\"], [\"7\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-02\"], [\"8\", \"2\", \"12\", \"12\", \"completed\", \"2013-10-03\"], [\"9\", \"3\", \"10\", \"12\", \"completed\", \"2013-10-03\"], [\"10\", \"4\", \"13\", \"12\", \"cancelled_by_driver\", \"2013-10-03\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"2\", \"Yes\", \"client\"], [\"3\", \"No\", \"client\"], [\"4\", \"No\", \"client\"], [\"10\", \"Yes\", \"driver\"], [\"11\", \"Yes\", \"driver\"], [\"12\", \"Yes\", \"driver\"], [\"13\", \"No\", \"driver\"]]}}\\nThe input is just replacing the \\'banned\\' status for Driver 10,11,12 from the example input, as they are now banned.\\n**So only Driver 13 is not banned.**\\nThis makes 2013-10-01 and 2013-10-03 both having only 1 valid trip (both are cancelled), and 2013-10-02 having no valid trip.\\nThen **the cancel rate should be 1, null, 1.**\\nBut the expected output is the same as the example: 0.33, 0, 5.\\nHere is a visualization of this testcase\\'s input.\\n![image](https://assets.leetcode.com/users/images/222fde1a-80fc-4ce0-a77c-9ea9ed91a262_1612488816.5813634.png)\\nHere is the submission detail:\\n![image](https://assets.leetcode.com/users/images/56ff7e0a-edd2-4fbc-b348-ed4d226727aa_1612489131.203634.png)\\nIf you find that you passed 9/10 and only this one failed, I think it should be fine."
                    }
                ]
            },
            {
                "id": 1568522,
                "content": [
                    {
                        "username": "olivershih",
                        "content": "A test case seems wrong:\\n\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\n\\nBoth the client and driver are not banned:\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nSo the output should be one row which has a 100% cancellation rate:\\n\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-04 | 1                 |\\n\\nInstead this is the expected result:\\n\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nAm I missing something?\\n"
                    },
                    {
                        "username": "gjs190201",
                        "content": "[@chaosxlive](/chaosxlive) yaa exactly so you need one more condition as\\n```request_at BETWEEN DATE(\"2013-10-01\") AND DATE(\"2013-10-03\")```"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@chaosxlive](/chaosxlive)  You must check the day like [@Z.B. Weng](/chaosxlive) said, you can do like this:\\n# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "friedkale",
                        "content": "[@chaosxlive](/chaosxlive) wow."
                    },
                    {
                        "username": "bigGheorghe",
                        "content": "[@chaosxlive](/chaosxlive) omg, that\\'s an aggrevating criteria to fail a test on."
                    },
                    {
                        "username": "chaosxlive",
                        "content": "The days picked should be between \\'2013-10-01\\' and \\'2013-10-03\\'. \\'2013-10-04\\' is out of range."
                    },
                    {
                        "username": "roshaniitd88",
                        "content": "Is anyone facing any issue in executing MySQL using WITH CTE clause"
                    },
                    {
                        "username": "shwetashahuc",
                        "content": "no."
                    },
                    {
                        "username": "autodino",
                        "content": "The \"Expected Answer\" is Wrong!!! It doesn\\'t consider banned drivers!!!"
                    },
                    {
                        "username": "coderange",
                        "content": "The answer is right, I forgot to constraint the date."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect \\nRequest_at as Day, \\nround(sum(Status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\'))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips\\nwhere \\nClient_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'client\\') and\\nDriver_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'driver\\') and\\nRequest_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n;"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "select \\nRequest_at as Day,\\nround(sum(status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\' ))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips \\n      where client_id  in (select users_id from Users where banned =\\'No\\')\\n      and driver_id  in (select users_id from Users where banned =\\'No\\')\\n      and Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n\\nwe don\\'t need to specify role = \"client\" or \"driver\" if banned is \"no\""
                    },
                    {
                        "username": "user8565WN",
                        "content": "Based on this test case, my code should pass, but it showing incorrect. \\nNone of the Users are banned, so it should be 100% cancellation.\\n\\nAm i missing something?\\nThank you for your help.\\n\\n![image](https://assets.leetcode.com/users/images/cbfefaa4-9128-4218-a7cc-bb23ec37cee1_1643601252.5488906.png)\\n"
                    },
                    {
                        "username": "anujkn05",
                        "content": " request_at should be between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "mkutarna",
                        "content": "I have the same issue - if there is only 1 request, and it is cancelled, the rate should be 1."
                    },
                    {
                        "username": "kevingao1136",
                        "content": "with a as\\n(select * from Trips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\nand Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\'))\\n\\nselect Request_at as Day,\\n        round(avg(case when Status = \\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\'\\nfrom a\\ngroup by Day\\nhaving Day between \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "prakharbarole2405",
                        "content": "facing problem in naming column with space in mysql"
                    },
                    {
                        "username": "terence1219",
                        "content": "use `column` ( ` symbol)"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "me too, it\\'s so stupid wtf"
                    },
                    {
                        "username": "Sangeetha1695",
                        "content": "I first tried to join and use row_number function to pick only distinct values but sometimes a simple select with where clause is about right to do the job. \\n\\nselect request_at as Day,round((sum(case when status like \\'cancelled%\\' then 1 else 0 end)/count(id)),2) as `Cancellation Rate` \\nfrom trips \\nwhere client_id in (select distinct users_id from users where banned=\\'No\\') \\nand driver_id in (select distinct users_id from users where banned=\\'No\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at"
                    },
                    {
                        "username": "malpus",
                        "content": "# Write your MySQL query statement below\\nselect request_at as \"Day\", \\nround(sum(if(status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\',1,0))/count(*), 2) as \"Cancellation Rate\"\\nfrom trips as t\\njoin users as u1\\non t.client_id = u1.users_id\\njoin users as u2\\non t.driver_id = u2.users_id\\nwhere \\nrequest_at >= \\'2013-10-01\\' and request_at<= \\'2013-10-03\\'\\nand u1.banned = \\'No\\'\\nand u2.banned = \\'No\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "panzihang",
                        "content": "One of the testcases is wrong. Here is how:\\nInput:\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-01\"], [\"2\", \"2\", \"11\", \"1\", \"cancelled_by_driver\", \"2013-10-01\"], [\"3\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-01\"], [\"4\", \"4\", \"13\", \"6\", \"cancelled_by_client\", \"2013-10-01\"], [\"5\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-02\"], [\"6\", \"2\", \"11\", \"6\", \"completed\", \"2013-10-02\"], [\"7\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-02\"], [\"8\", \"2\", \"12\", \"12\", \"completed\", \"2013-10-03\"], [\"9\", \"3\", \"10\", \"12\", \"completed\", \"2013-10-03\"], [\"10\", \"4\", \"13\", \"12\", \"cancelled_by_driver\", \"2013-10-03\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"2\", \"Yes\", \"client\"], [\"3\", \"No\", \"client\"], [\"4\", \"No\", \"client\"], [\"10\", \"Yes\", \"driver\"], [\"11\", \"Yes\", \"driver\"], [\"12\", \"Yes\", \"driver\"], [\"13\", \"No\", \"driver\"]]}}\\nThe input is just replacing the \\'banned\\' status for Driver 10,11,12 from the example input, as they are now banned.\\n**So only Driver 13 is not banned.**\\nThis makes 2013-10-01 and 2013-10-03 both having only 1 valid trip (both are cancelled), and 2013-10-02 having no valid trip.\\nThen **the cancel rate should be 1, null, 1.**\\nBut the expected output is the same as the example: 0.33, 0, 5.\\nHere is a visualization of this testcase\\'s input.\\n![image](https://assets.leetcode.com/users/images/222fde1a-80fc-4ce0-a77c-9ea9ed91a262_1612488816.5813634.png)\\nHere is the submission detail:\\n![image](https://assets.leetcode.com/users/images/56ff7e0a-edd2-4fbc-b348-ed4d226727aa_1612489131.203634.png)\\nIf you find that you passed 9/10 and only this one failed, I think it should be fine."
                    }
                ]
            },
            {
                "id": 1634434,
                "content": [
                    {
                        "username": "olivershih",
                        "content": "A test case seems wrong:\\n\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\n\\nBoth the client and driver are not banned:\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nSo the output should be one row which has a 100% cancellation rate:\\n\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-04 | 1                 |\\n\\nInstead this is the expected result:\\n\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nAm I missing something?\\n"
                    },
                    {
                        "username": "gjs190201",
                        "content": "[@chaosxlive](/chaosxlive) yaa exactly so you need one more condition as\\n```request_at BETWEEN DATE(\"2013-10-01\") AND DATE(\"2013-10-03\")```"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@chaosxlive](/chaosxlive)  You must check the day like [@Z.B. Weng](/chaosxlive) said, you can do like this:\\n# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "friedkale",
                        "content": "[@chaosxlive](/chaosxlive) wow."
                    },
                    {
                        "username": "bigGheorghe",
                        "content": "[@chaosxlive](/chaosxlive) omg, that\\'s an aggrevating criteria to fail a test on."
                    },
                    {
                        "username": "chaosxlive",
                        "content": "The days picked should be between \\'2013-10-01\\' and \\'2013-10-03\\'. \\'2013-10-04\\' is out of range."
                    },
                    {
                        "username": "roshaniitd88",
                        "content": "Is anyone facing any issue in executing MySQL using WITH CTE clause"
                    },
                    {
                        "username": "shwetashahuc",
                        "content": "no."
                    },
                    {
                        "username": "autodino",
                        "content": "The \"Expected Answer\" is Wrong!!! It doesn\\'t consider banned drivers!!!"
                    },
                    {
                        "username": "coderange",
                        "content": "The answer is right, I forgot to constraint the date."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect \\nRequest_at as Day, \\nround(sum(Status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\'))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips\\nwhere \\nClient_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'client\\') and\\nDriver_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'driver\\') and\\nRequest_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n;"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "select \\nRequest_at as Day,\\nround(sum(status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\' ))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips \\n      where client_id  in (select users_id from Users where banned =\\'No\\')\\n      and driver_id  in (select users_id from Users where banned =\\'No\\')\\n      and Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n\\nwe don\\'t need to specify role = \"client\" or \"driver\" if banned is \"no\""
                    },
                    {
                        "username": "user8565WN",
                        "content": "Based on this test case, my code should pass, but it showing incorrect. \\nNone of the Users are banned, so it should be 100% cancellation.\\n\\nAm i missing something?\\nThank you for your help.\\n\\n![image](https://assets.leetcode.com/users/images/cbfefaa4-9128-4218-a7cc-bb23ec37cee1_1643601252.5488906.png)\\n"
                    },
                    {
                        "username": "anujkn05",
                        "content": " request_at should be between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "mkutarna",
                        "content": "I have the same issue - if there is only 1 request, and it is cancelled, the rate should be 1."
                    },
                    {
                        "username": "kevingao1136",
                        "content": "with a as\\n(select * from Trips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\nand Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\'))\\n\\nselect Request_at as Day,\\n        round(avg(case when Status = \\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\'\\nfrom a\\ngroup by Day\\nhaving Day between \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "prakharbarole2405",
                        "content": "facing problem in naming column with space in mysql"
                    },
                    {
                        "username": "terence1219",
                        "content": "use `column` ( ` symbol)"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "me too, it\\'s so stupid wtf"
                    },
                    {
                        "username": "Sangeetha1695",
                        "content": "I first tried to join and use row_number function to pick only distinct values but sometimes a simple select with where clause is about right to do the job. \\n\\nselect request_at as Day,round((sum(case when status like \\'cancelled%\\' then 1 else 0 end)/count(id)),2) as `Cancellation Rate` \\nfrom trips \\nwhere client_id in (select distinct users_id from users where banned=\\'No\\') \\nand driver_id in (select distinct users_id from users where banned=\\'No\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at"
                    },
                    {
                        "username": "malpus",
                        "content": "# Write your MySQL query statement below\\nselect request_at as \"Day\", \\nround(sum(if(status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\',1,0))/count(*), 2) as \"Cancellation Rate\"\\nfrom trips as t\\njoin users as u1\\non t.client_id = u1.users_id\\njoin users as u2\\non t.driver_id = u2.users_id\\nwhere \\nrequest_at >= \\'2013-10-01\\' and request_at<= \\'2013-10-03\\'\\nand u1.banned = \\'No\\'\\nand u2.banned = \\'No\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "panzihang",
                        "content": "One of the testcases is wrong. Here is how:\\nInput:\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-01\"], [\"2\", \"2\", \"11\", \"1\", \"cancelled_by_driver\", \"2013-10-01\"], [\"3\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-01\"], [\"4\", \"4\", \"13\", \"6\", \"cancelled_by_client\", \"2013-10-01\"], [\"5\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-02\"], [\"6\", \"2\", \"11\", \"6\", \"completed\", \"2013-10-02\"], [\"7\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-02\"], [\"8\", \"2\", \"12\", \"12\", \"completed\", \"2013-10-03\"], [\"9\", \"3\", \"10\", \"12\", \"completed\", \"2013-10-03\"], [\"10\", \"4\", \"13\", \"12\", \"cancelled_by_driver\", \"2013-10-03\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"2\", \"Yes\", \"client\"], [\"3\", \"No\", \"client\"], [\"4\", \"No\", \"client\"], [\"10\", \"Yes\", \"driver\"], [\"11\", \"Yes\", \"driver\"], [\"12\", \"Yes\", \"driver\"], [\"13\", \"No\", \"driver\"]]}}\\nThe input is just replacing the \\'banned\\' status for Driver 10,11,12 from the example input, as they are now banned.\\n**So only Driver 13 is not banned.**\\nThis makes 2013-10-01 and 2013-10-03 both having only 1 valid trip (both are cancelled), and 2013-10-02 having no valid trip.\\nThen **the cancel rate should be 1, null, 1.**\\nBut the expected output is the same as the example: 0.33, 0, 5.\\nHere is a visualization of this testcase\\'s input.\\n![image](https://assets.leetcode.com/users/images/222fde1a-80fc-4ce0-a77c-9ea9ed91a262_1612488816.5813634.png)\\nHere is the submission detail:\\n![image](https://assets.leetcode.com/users/images/56ff7e0a-edd2-4fbc-b348-ed4d226727aa_1612489131.203634.png)\\nIf you find that you passed 9/10 and only this one failed, I think it should be fine."
                    }
                ]
            },
            {
                "id": 1567349,
                "content": [
                    {
                        "username": "olivershih",
                        "content": "A test case seems wrong:\\n\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\n\\nBoth the client and driver are not banned:\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nSo the output should be one row which has a 100% cancellation rate:\\n\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-04 | 1                 |\\n\\nInstead this is the expected result:\\n\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nAm I missing something?\\n"
                    },
                    {
                        "username": "gjs190201",
                        "content": "[@chaosxlive](/chaosxlive) yaa exactly so you need one more condition as\\n```request_at BETWEEN DATE(\"2013-10-01\") AND DATE(\"2013-10-03\")```"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@chaosxlive](/chaosxlive)  You must check the day like [@Z.B. Weng](/chaosxlive) said, you can do like this:\\n# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "friedkale",
                        "content": "[@chaosxlive](/chaosxlive) wow."
                    },
                    {
                        "username": "bigGheorghe",
                        "content": "[@chaosxlive](/chaosxlive) omg, that\\'s an aggrevating criteria to fail a test on."
                    },
                    {
                        "username": "chaosxlive",
                        "content": "The days picked should be between \\'2013-10-01\\' and \\'2013-10-03\\'. \\'2013-10-04\\' is out of range."
                    },
                    {
                        "username": "roshaniitd88",
                        "content": "Is anyone facing any issue in executing MySQL using WITH CTE clause"
                    },
                    {
                        "username": "shwetashahuc",
                        "content": "no."
                    },
                    {
                        "username": "autodino",
                        "content": "The \"Expected Answer\" is Wrong!!! It doesn\\'t consider banned drivers!!!"
                    },
                    {
                        "username": "coderange",
                        "content": "The answer is right, I forgot to constraint the date."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect \\nRequest_at as Day, \\nround(sum(Status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\'))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips\\nwhere \\nClient_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'client\\') and\\nDriver_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'driver\\') and\\nRequest_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n;"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "select \\nRequest_at as Day,\\nround(sum(status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\' ))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips \\n      where client_id  in (select users_id from Users where banned =\\'No\\')\\n      and driver_id  in (select users_id from Users where banned =\\'No\\')\\n      and Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n\\nwe don\\'t need to specify role = \"client\" or \"driver\" if banned is \"no\""
                    },
                    {
                        "username": "user8565WN",
                        "content": "Based on this test case, my code should pass, but it showing incorrect. \\nNone of the Users are banned, so it should be 100% cancellation.\\n\\nAm i missing something?\\nThank you for your help.\\n\\n![image](https://assets.leetcode.com/users/images/cbfefaa4-9128-4218-a7cc-bb23ec37cee1_1643601252.5488906.png)\\n"
                    },
                    {
                        "username": "anujkn05",
                        "content": " request_at should be between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "mkutarna",
                        "content": "I have the same issue - if there is only 1 request, and it is cancelled, the rate should be 1."
                    },
                    {
                        "username": "kevingao1136",
                        "content": "with a as\\n(select * from Trips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\nand Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\'))\\n\\nselect Request_at as Day,\\n        round(avg(case when Status = \\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\'\\nfrom a\\ngroup by Day\\nhaving Day between \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "prakharbarole2405",
                        "content": "facing problem in naming column with space in mysql"
                    },
                    {
                        "username": "terence1219",
                        "content": "use `column` ( ` symbol)"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "me too, it\\'s so stupid wtf"
                    },
                    {
                        "username": "Sangeetha1695",
                        "content": "I first tried to join and use row_number function to pick only distinct values but sometimes a simple select with where clause is about right to do the job. \\n\\nselect request_at as Day,round((sum(case when status like \\'cancelled%\\' then 1 else 0 end)/count(id)),2) as `Cancellation Rate` \\nfrom trips \\nwhere client_id in (select distinct users_id from users where banned=\\'No\\') \\nand driver_id in (select distinct users_id from users where banned=\\'No\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at"
                    },
                    {
                        "username": "malpus",
                        "content": "# Write your MySQL query statement below\\nselect request_at as \"Day\", \\nround(sum(if(status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\',1,0))/count(*), 2) as \"Cancellation Rate\"\\nfrom trips as t\\njoin users as u1\\non t.client_id = u1.users_id\\njoin users as u2\\non t.driver_id = u2.users_id\\nwhere \\nrequest_at >= \\'2013-10-01\\' and request_at<= \\'2013-10-03\\'\\nand u1.banned = \\'No\\'\\nand u2.banned = \\'No\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "panzihang",
                        "content": "One of the testcases is wrong. Here is how:\\nInput:\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-01\"], [\"2\", \"2\", \"11\", \"1\", \"cancelled_by_driver\", \"2013-10-01\"], [\"3\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-01\"], [\"4\", \"4\", \"13\", \"6\", \"cancelled_by_client\", \"2013-10-01\"], [\"5\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-02\"], [\"6\", \"2\", \"11\", \"6\", \"completed\", \"2013-10-02\"], [\"7\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-02\"], [\"8\", \"2\", \"12\", \"12\", \"completed\", \"2013-10-03\"], [\"9\", \"3\", \"10\", \"12\", \"completed\", \"2013-10-03\"], [\"10\", \"4\", \"13\", \"12\", \"cancelled_by_driver\", \"2013-10-03\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"2\", \"Yes\", \"client\"], [\"3\", \"No\", \"client\"], [\"4\", \"No\", \"client\"], [\"10\", \"Yes\", \"driver\"], [\"11\", \"Yes\", \"driver\"], [\"12\", \"Yes\", \"driver\"], [\"13\", \"No\", \"driver\"]]}}\\nThe input is just replacing the \\'banned\\' status for Driver 10,11,12 from the example input, as they are now banned.\\n**So only Driver 13 is not banned.**\\nThis makes 2013-10-01 and 2013-10-03 both having only 1 valid trip (both are cancelled), and 2013-10-02 having no valid trip.\\nThen **the cancel rate should be 1, null, 1.**\\nBut the expected output is the same as the example: 0.33, 0, 5.\\nHere is a visualization of this testcase\\'s input.\\n![image](https://assets.leetcode.com/users/images/222fde1a-80fc-4ce0-a77c-9ea9ed91a262_1612488816.5813634.png)\\nHere is the submission detail:\\n![image](https://assets.leetcode.com/users/images/56ff7e0a-edd2-4fbc-b348-ed4d226727aa_1612489131.203634.png)\\nIf you find that you passed 9/10 and only this one failed, I think it should be fine."
                    }
                ]
            },
            {
                "id": 1569310,
                "content": [
                    {
                        "username": "olivershih",
                        "content": "A test case seems wrong:\\n\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\n\\nBoth the client and driver are not banned:\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nSo the output should be one row which has a 100% cancellation rate:\\n\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-04 | 1                 |\\n\\nInstead this is the expected result:\\n\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nAm I missing something?\\n"
                    },
                    {
                        "username": "gjs190201",
                        "content": "[@chaosxlive](/chaosxlive) yaa exactly so you need one more condition as\\n```request_at BETWEEN DATE(\"2013-10-01\") AND DATE(\"2013-10-03\")```"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@chaosxlive](/chaosxlive)  You must check the day like [@Z.B. Weng](/chaosxlive) said, you can do like this:\\n# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "friedkale",
                        "content": "[@chaosxlive](/chaosxlive) wow."
                    },
                    {
                        "username": "bigGheorghe",
                        "content": "[@chaosxlive](/chaosxlive) omg, that\\'s an aggrevating criteria to fail a test on."
                    },
                    {
                        "username": "chaosxlive",
                        "content": "The days picked should be between \\'2013-10-01\\' and \\'2013-10-03\\'. \\'2013-10-04\\' is out of range."
                    },
                    {
                        "username": "roshaniitd88",
                        "content": "Is anyone facing any issue in executing MySQL using WITH CTE clause"
                    },
                    {
                        "username": "shwetashahuc",
                        "content": "no."
                    },
                    {
                        "username": "autodino",
                        "content": "The \"Expected Answer\" is Wrong!!! It doesn\\'t consider banned drivers!!!"
                    },
                    {
                        "username": "coderange",
                        "content": "The answer is right, I forgot to constraint the date."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect \\nRequest_at as Day, \\nround(sum(Status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\'))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips\\nwhere \\nClient_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'client\\') and\\nDriver_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'driver\\') and\\nRequest_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n;"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "select \\nRequest_at as Day,\\nround(sum(status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\' ))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips \\n      where client_id  in (select users_id from Users where banned =\\'No\\')\\n      and driver_id  in (select users_id from Users where banned =\\'No\\')\\n      and Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n\\nwe don\\'t need to specify role = \"client\" or \"driver\" if banned is \"no\""
                    },
                    {
                        "username": "user8565WN",
                        "content": "Based on this test case, my code should pass, but it showing incorrect. \\nNone of the Users are banned, so it should be 100% cancellation.\\n\\nAm i missing something?\\nThank you for your help.\\n\\n![image](https://assets.leetcode.com/users/images/cbfefaa4-9128-4218-a7cc-bb23ec37cee1_1643601252.5488906.png)\\n"
                    },
                    {
                        "username": "anujkn05",
                        "content": " request_at should be between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "mkutarna",
                        "content": "I have the same issue - if there is only 1 request, and it is cancelled, the rate should be 1."
                    },
                    {
                        "username": "kevingao1136",
                        "content": "with a as\\n(select * from Trips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\nand Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\'))\\n\\nselect Request_at as Day,\\n        round(avg(case when Status = \\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\'\\nfrom a\\ngroup by Day\\nhaving Day between \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "prakharbarole2405",
                        "content": "facing problem in naming column with space in mysql"
                    },
                    {
                        "username": "terence1219",
                        "content": "use `column` ( ` symbol)"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "me too, it\\'s so stupid wtf"
                    },
                    {
                        "username": "Sangeetha1695",
                        "content": "I first tried to join and use row_number function to pick only distinct values but sometimes a simple select with where clause is about right to do the job. \\n\\nselect request_at as Day,round((sum(case when status like \\'cancelled%\\' then 1 else 0 end)/count(id)),2) as `Cancellation Rate` \\nfrom trips \\nwhere client_id in (select distinct users_id from users where banned=\\'No\\') \\nand driver_id in (select distinct users_id from users where banned=\\'No\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at"
                    },
                    {
                        "username": "malpus",
                        "content": "# Write your MySQL query statement below\\nselect request_at as \"Day\", \\nround(sum(if(status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\',1,0))/count(*), 2) as \"Cancellation Rate\"\\nfrom trips as t\\njoin users as u1\\non t.client_id = u1.users_id\\njoin users as u2\\non t.driver_id = u2.users_id\\nwhere \\nrequest_at >= \\'2013-10-01\\' and request_at<= \\'2013-10-03\\'\\nand u1.banned = \\'No\\'\\nand u2.banned = \\'No\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "panzihang",
                        "content": "One of the testcases is wrong. Here is how:\\nInput:\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-01\"], [\"2\", \"2\", \"11\", \"1\", \"cancelled_by_driver\", \"2013-10-01\"], [\"3\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-01\"], [\"4\", \"4\", \"13\", \"6\", \"cancelled_by_client\", \"2013-10-01\"], [\"5\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-02\"], [\"6\", \"2\", \"11\", \"6\", \"completed\", \"2013-10-02\"], [\"7\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-02\"], [\"8\", \"2\", \"12\", \"12\", \"completed\", \"2013-10-03\"], [\"9\", \"3\", \"10\", \"12\", \"completed\", \"2013-10-03\"], [\"10\", \"4\", \"13\", \"12\", \"cancelled_by_driver\", \"2013-10-03\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"2\", \"Yes\", \"client\"], [\"3\", \"No\", \"client\"], [\"4\", \"No\", \"client\"], [\"10\", \"Yes\", \"driver\"], [\"11\", \"Yes\", \"driver\"], [\"12\", \"Yes\", \"driver\"], [\"13\", \"No\", \"driver\"]]}}\\nThe input is just replacing the \\'banned\\' status for Driver 10,11,12 from the example input, as they are now banned.\\n**So only Driver 13 is not banned.**\\nThis makes 2013-10-01 and 2013-10-03 both having only 1 valid trip (both are cancelled), and 2013-10-02 having no valid trip.\\nThen **the cancel rate should be 1, null, 1.**\\nBut the expected output is the same as the example: 0.33, 0, 5.\\nHere is a visualization of this testcase\\'s input.\\n![image](https://assets.leetcode.com/users/images/222fde1a-80fc-4ce0-a77c-9ea9ed91a262_1612488816.5813634.png)\\nHere is the submission detail:\\n![image](https://assets.leetcode.com/users/images/56ff7e0a-edd2-4fbc-b348-ed4d226727aa_1612489131.203634.png)\\nIf you find that you passed 9/10 and only this one failed, I think it should be fine."
                    }
                ]
            },
            {
                "id": 1566871,
                "content": [
                    {
                        "username": "olivershih",
                        "content": "A test case seems wrong:\\n\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\n\\nBoth the client and driver are not banned:\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nSo the output should be one row which has a 100% cancellation rate:\\n\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-04 | 1                 |\\n\\nInstead this is the expected result:\\n\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nAm I missing something?\\n"
                    },
                    {
                        "username": "gjs190201",
                        "content": "[@chaosxlive](/chaosxlive) yaa exactly so you need one more condition as\\n```request_at BETWEEN DATE(\"2013-10-01\") AND DATE(\"2013-10-03\")```"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@chaosxlive](/chaosxlive)  You must check the day like [@Z.B. Weng](/chaosxlive) said, you can do like this:\\n# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "friedkale",
                        "content": "[@chaosxlive](/chaosxlive) wow."
                    },
                    {
                        "username": "bigGheorghe",
                        "content": "[@chaosxlive](/chaosxlive) omg, that\\'s an aggrevating criteria to fail a test on."
                    },
                    {
                        "username": "chaosxlive",
                        "content": "The days picked should be between \\'2013-10-01\\' and \\'2013-10-03\\'. \\'2013-10-04\\' is out of range."
                    },
                    {
                        "username": "roshaniitd88",
                        "content": "Is anyone facing any issue in executing MySQL using WITH CTE clause"
                    },
                    {
                        "username": "shwetashahuc",
                        "content": "no."
                    },
                    {
                        "username": "autodino",
                        "content": "The \"Expected Answer\" is Wrong!!! It doesn\\'t consider banned drivers!!!"
                    },
                    {
                        "username": "coderange",
                        "content": "The answer is right, I forgot to constraint the date."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect \\nRequest_at as Day, \\nround(sum(Status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\'))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips\\nwhere \\nClient_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'client\\') and\\nDriver_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'driver\\') and\\nRequest_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n;"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "select \\nRequest_at as Day,\\nround(sum(status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\' ))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips \\n      where client_id  in (select users_id from Users where banned =\\'No\\')\\n      and driver_id  in (select users_id from Users where banned =\\'No\\')\\n      and Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n\\nwe don\\'t need to specify role = \"client\" or \"driver\" if banned is \"no\""
                    },
                    {
                        "username": "user8565WN",
                        "content": "Based on this test case, my code should pass, but it showing incorrect. \\nNone of the Users are banned, so it should be 100% cancellation.\\n\\nAm i missing something?\\nThank you for your help.\\n\\n![image](https://assets.leetcode.com/users/images/cbfefaa4-9128-4218-a7cc-bb23ec37cee1_1643601252.5488906.png)\\n"
                    },
                    {
                        "username": "anujkn05",
                        "content": " request_at should be between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "mkutarna",
                        "content": "I have the same issue - if there is only 1 request, and it is cancelled, the rate should be 1."
                    },
                    {
                        "username": "kevingao1136",
                        "content": "with a as\\n(select * from Trips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\nand Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\'))\\n\\nselect Request_at as Day,\\n        round(avg(case when Status = \\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\'\\nfrom a\\ngroup by Day\\nhaving Day between \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "prakharbarole2405",
                        "content": "facing problem in naming column with space in mysql"
                    },
                    {
                        "username": "terence1219",
                        "content": "use `column` ( ` symbol)"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "me too, it\\'s so stupid wtf"
                    },
                    {
                        "username": "Sangeetha1695",
                        "content": "I first tried to join and use row_number function to pick only distinct values but sometimes a simple select with where clause is about right to do the job. \\n\\nselect request_at as Day,round((sum(case when status like \\'cancelled%\\' then 1 else 0 end)/count(id)),2) as `Cancellation Rate` \\nfrom trips \\nwhere client_id in (select distinct users_id from users where banned=\\'No\\') \\nand driver_id in (select distinct users_id from users where banned=\\'No\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at"
                    },
                    {
                        "username": "malpus",
                        "content": "# Write your MySQL query statement below\\nselect request_at as \"Day\", \\nround(sum(if(status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\',1,0))/count(*), 2) as \"Cancellation Rate\"\\nfrom trips as t\\njoin users as u1\\non t.client_id = u1.users_id\\njoin users as u2\\non t.driver_id = u2.users_id\\nwhere \\nrequest_at >= \\'2013-10-01\\' and request_at<= \\'2013-10-03\\'\\nand u1.banned = \\'No\\'\\nand u2.banned = \\'No\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "panzihang",
                        "content": "One of the testcases is wrong. Here is how:\\nInput:\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-01\"], [\"2\", \"2\", \"11\", \"1\", \"cancelled_by_driver\", \"2013-10-01\"], [\"3\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-01\"], [\"4\", \"4\", \"13\", \"6\", \"cancelled_by_client\", \"2013-10-01\"], [\"5\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-02\"], [\"6\", \"2\", \"11\", \"6\", \"completed\", \"2013-10-02\"], [\"7\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-02\"], [\"8\", \"2\", \"12\", \"12\", \"completed\", \"2013-10-03\"], [\"9\", \"3\", \"10\", \"12\", \"completed\", \"2013-10-03\"], [\"10\", \"4\", \"13\", \"12\", \"cancelled_by_driver\", \"2013-10-03\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"2\", \"Yes\", \"client\"], [\"3\", \"No\", \"client\"], [\"4\", \"No\", \"client\"], [\"10\", \"Yes\", \"driver\"], [\"11\", \"Yes\", \"driver\"], [\"12\", \"Yes\", \"driver\"], [\"13\", \"No\", \"driver\"]]}}\\nThe input is just replacing the \\'banned\\' status for Driver 10,11,12 from the example input, as they are now banned.\\n**So only Driver 13 is not banned.**\\nThis makes 2013-10-01 and 2013-10-03 both having only 1 valid trip (both are cancelled), and 2013-10-02 having no valid trip.\\nThen **the cancel rate should be 1, null, 1.**\\nBut the expected output is the same as the example: 0.33, 0, 5.\\nHere is a visualization of this testcase\\'s input.\\n![image](https://assets.leetcode.com/users/images/222fde1a-80fc-4ce0-a77c-9ea9ed91a262_1612488816.5813634.png)\\nHere is the submission detail:\\n![image](https://assets.leetcode.com/users/images/56ff7e0a-edd2-4fbc-b348-ed4d226727aa_1612489131.203634.png)\\nIf you find that you passed 9/10 and only this one failed, I think it should be fine."
                    }
                ]
            },
            {
                "id": 1576313,
                "content": [
                    {
                        "username": "olivershih",
                        "content": "A test case seems wrong:\\n\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\n\\nBoth the client and driver are not banned:\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nSo the output should be one row which has a 100% cancellation rate:\\n\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-04 | 1                 |\\n\\nInstead this is the expected result:\\n\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nAm I missing something?\\n"
                    },
                    {
                        "username": "gjs190201",
                        "content": "[@chaosxlive](/chaosxlive) yaa exactly so you need one more condition as\\n```request_at BETWEEN DATE(\"2013-10-01\") AND DATE(\"2013-10-03\")```"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@chaosxlive](/chaosxlive)  You must check the day like [@Z.B. Weng](/chaosxlive) said, you can do like this:\\n# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "friedkale",
                        "content": "[@chaosxlive](/chaosxlive) wow."
                    },
                    {
                        "username": "bigGheorghe",
                        "content": "[@chaosxlive](/chaosxlive) omg, that\\'s an aggrevating criteria to fail a test on."
                    },
                    {
                        "username": "chaosxlive",
                        "content": "The days picked should be between \\'2013-10-01\\' and \\'2013-10-03\\'. \\'2013-10-04\\' is out of range."
                    },
                    {
                        "username": "roshaniitd88",
                        "content": "Is anyone facing any issue in executing MySQL using WITH CTE clause"
                    },
                    {
                        "username": "shwetashahuc",
                        "content": "no."
                    },
                    {
                        "username": "autodino",
                        "content": "The \"Expected Answer\" is Wrong!!! It doesn\\'t consider banned drivers!!!"
                    },
                    {
                        "username": "coderange",
                        "content": "The answer is right, I forgot to constraint the date."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect \\nRequest_at as Day, \\nround(sum(Status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\'))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips\\nwhere \\nClient_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'client\\') and\\nDriver_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'driver\\') and\\nRequest_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n;"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "select \\nRequest_at as Day,\\nround(sum(status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\' ))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips \\n      where client_id  in (select users_id from Users where banned =\\'No\\')\\n      and driver_id  in (select users_id from Users where banned =\\'No\\')\\n      and Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n\\nwe don\\'t need to specify role = \"client\" or \"driver\" if banned is \"no\""
                    },
                    {
                        "username": "user8565WN",
                        "content": "Based on this test case, my code should pass, but it showing incorrect. \\nNone of the Users are banned, so it should be 100% cancellation.\\n\\nAm i missing something?\\nThank you for your help.\\n\\n![image](https://assets.leetcode.com/users/images/cbfefaa4-9128-4218-a7cc-bb23ec37cee1_1643601252.5488906.png)\\n"
                    },
                    {
                        "username": "anujkn05",
                        "content": " request_at should be between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "mkutarna",
                        "content": "I have the same issue - if there is only 1 request, and it is cancelled, the rate should be 1."
                    },
                    {
                        "username": "kevingao1136",
                        "content": "with a as\\n(select * from Trips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\nand Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\'))\\n\\nselect Request_at as Day,\\n        round(avg(case when Status = \\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\'\\nfrom a\\ngroup by Day\\nhaving Day between \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "prakharbarole2405",
                        "content": "facing problem in naming column with space in mysql"
                    },
                    {
                        "username": "terence1219",
                        "content": "use `column` ( ` symbol)"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "me too, it\\'s so stupid wtf"
                    },
                    {
                        "username": "Sangeetha1695",
                        "content": "I first tried to join and use row_number function to pick only distinct values but sometimes a simple select with where clause is about right to do the job. \\n\\nselect request_at as Day,round((sum(case when status like \\'cancelled%\\' then 1 else 0 end)/count(id)),2) as `Cancellation Rate` \\nfrom trips \\nwhere client_id in (select distinct users_id from users where banned=\\'No\\') \\nand driver_id in (select distinct users_id from users where banned=\\'No\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at"
                    },
                    {
                        "username": "malpus",
                        "content": "# Write your MySQL query statement below\\nselect request_at as \"Day\", \\nround(sum(if(status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\',1,0))/count(*), 2) as \"Cancellation Rate\"\\nfrom trips as t\\njoin users as u1\\non t.client_id = u1.users_id\\njoin users as u2\\non t.driver_id = u2.users_id\\nwhere \\nrequest_at >= \\'2013-10-01\\' and request_at<= \\'2013-10-03\\'\\nand u1.banned = \\'No\\'\\nand u2.banned = \\'No\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "panzihang",
                        "content": "One of the testcases is wrong. Here is how:\\nInput:\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-01\"], [\"2\", \"2\", \"11\", \"1\", \"cancelled_by_driver\", \"2013-10-01\"], [\"3\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-01\"], [\"4\", \"4\", \"13\", \"6\", \"cancelled_by_client\", \"2013-10-01\"], [\"5\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-02\"], [\"6\", \"2\", \"11\", \"6\", \"completed\", \"2013-10-02\"], [\"7\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-02\"], [\"8\", \"2\", \"12\", \"12\", \"completed\", \"2013-10-03\"], [\"9\", \"3\", \"10\", \"12\", \"completed\", \"2013-10-03\"], [\"10\", \"4\", \"13\", \"12\", \"cancelled_by_driver\", \"2013-10-03\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"2\", \"Yes\", \"client\"], [\"3\", \"No\", \"client\"], [\"4\", \"No\", \"client\"], [\"10\", \"Yes\", \"driver\"], [\"11\", \"Yes\", \"driver\"], [\"12\", \"Yes\", \"driver\"], [\"13\", \"No\", \"driver\"]]}}\\nThe input is just replacing the \\'banned\\' status for Driver 10,11,12 from the example input, as they are now banned.\\n**So only Driver 13 is not banned.**\\nThis makes 2013-10-01 and 2013-10-03 both having only 1 valid trip (both are cancelled), and 2013-10-02 having no valid trip.\\nThen **the cancel rate should be 1, null, 1.**\\nBut the expected output is the same as the example: 0.33, 0, 5.\\nHere is a visualization of this testcase\\'s input.\\n![image](https://assets.leetcode.com/users/images/222fde1a-80fc-4ce0-a77c-9ea9ed91a262_1612488816.5813634.png)\\nHere is the submission detail:\\n![image](https://assets.leetcode.com/users/images/56ff7e0a-edd2-4fbc-b348-ed4d226727aa_1612489131.203634.png)\\nIf you find that you passed 9/10 and only this one failed, I think it should be fine."
                    }
                ]
            },
            {
                "id": 1570121,
                "content": [
                    {
                        "username": "olivershih",
                        "content": "A test case seems wrong:\\n\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\n\\nBoth the client and driver are not banned:\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nSo the output should be one row which has a 100% cancellation rate:\\n\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-04 | 1                 |\\n\\nInstead this is the expected result:\\n\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nAm I missing something?\\n"
                    },
                    {
                        "username": "gjs190201",
                        "content": "[@chaosxlive](/chaosxlive) yaa exactly so you need one more condition as\\n```request_at BETWEEN DATE(\"2013-10-01\") AND DATE(\"2013-10-03\")```"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@chaosxlive](/chaosxlive)  You must check the day like [@Z.B. Weng](/chaosxlive) said, you can do like this:\\n# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "friedkale",
                        "content": "[@chaosxlive](/chaosxlive) wow."
                    },
                    {
                        "username": "bigGheorghe",
                        "content": "[@chaosxlive](/chaosxlive) omg, that\\'s an aggrevating criteria to fail a test on."
                    },
                    {
                        "username": "chaosxlive",
                        "content": "The days picked should be between \\'2013-10-01\\' and \\'2013-10-03\\'. \\'2013-10-04\\' is out of range."
                    },
                    {
                        "username": "roshaniitd88",
                        "content": "Is anyone facing any issue in executing MySQL using WITH CTE clause"
                    },
                    {
                        "username": "shwetashahuc",
                        "content": "no."
                    },
                    {
                        "username": "autodino",
                        "content": "The \"Expected Answer\" is Wrong!!! It doesn\\'t consider banned drivers!!!"
                    },
                    {
                        "username": "coderange",
                        "content": "The answer is right, I forgot to constraint the date."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect \\nRequest_at as Day, \\nround(sum(Status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\'))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips\\nwhere \\nClient_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'client\\') and\\nDriver_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'driver\\') and\\nRequest_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n;"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "select \\nRequest_at as Day,\\nround(sum(status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\' ))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips \\n      where client_id  in (select users_id from Users where banned =\\'No\\')\\n      and driver_id  in (select users_id from Users where banned =\\'No\\')\\n      and Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n\\nwe don\\'t need to specify role = \"client\" or \"driver\" if banned is \"no\""
                    },
                    {
                        "username": "user8565WN",
                        "content": "Based on this test case, my code should pass, but it showing incorrect. \\nNone of the Users are banned, so it should be 100% cancellation.\\n\\nAm i missing something?\\nThank you for your help.\\n\\n![image](https://assets.leetcode.com/users/images/cbfefaa4-9128-4218-a7cc-bb23ec37cee1_1643601252.5488906.png)\\n"
                    },
                    {
                        "username": "anujkn05",
                        "content": " request_at should be between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "mkutarna",
                        "content": "I have the same issue - if there is only 1 request, and it is cancelled, the rate should be 1."
                    },
                    {
                        "username": "kevingao1136",
                        "content": "with a as\\n(select * from Trips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\nand Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\'))\\n\\nselect Request_at as Day,\\n        round(avg(case when Status = \\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\'\\nfrom a\\ngroup by Day\\nhaving Day between \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "prakharbarole2405",
                        "content": "facing problem in naming column with space in mysql"
                    },
                    {
                        "username": "terence1219",
                        "content": "use `column` ( ` symbol)"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "me too, it\\'s so stupid wtf"
                    },
                    {
                        "username": "Sangeetha1695",
                        "content": "I first tried to join and use row_number function to pick only distinct values but sometimes a simple select with where clause is about right to do the job. \\n\\nselect request_at as Day,round((sum(case when status like \\'cancelled%\\' then 1 else 0 end)/count(id)),2) as `Cancellation Rate` \\nfrom trips \\nwhere client_id in (select distinct users_id from users where banned=\\'No\\') \\nand driver_id in (select distinct users_id from users where banned=\\'No\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at"
                    },
                    {
                        "username": "malpus",
                        "content": "# Write your MySQL query statement below\\nselect request_at as \"Day\", \\nround(sum(if(status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\',1,0))/count(*), 2) as \"Cancellation Rate\"\\nfrom trips as t\\njoin users as u1\\non t.client_id = u1.users_id\\njoin users as u2\\non t.driver_id = u2.users_id\\nwhere \\nrequest_at >= \\'2013-10-01\\' and request_at<= \\'2013-10-03\\'\\nand u1.banned = \\'No\\'\\nand u2.banned = \\'No\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "panzihang",
                        "content": "One of the testcases is wrong. Here is how:\\nInput:\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-01\"], [\"2\", \"2\", \"11\", \"1\", \"cancelled_by_driver\", \"2013-10-01\"], [\"3\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-01\"], [\"4\", \"4\", \"13\", \"6\", \"cancelled_by_client\", \"2013-10-01\"], [\"5\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-02\"], [\"6\", \"2\", \"11\", \"6\", \"completed\", \"2013-10-02\"], [\"7\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-02\"], [\"8\", \"2\", \"12\", \"12\", \"completed\", \"2013-10-03\"], [\"9\", \"3\", \"10\", \"12\", \"completed\", \"2013-10-03\"], [\"10\", \"4\", \"13\", \"12\", \"cancelled_by_driver\", \"2013-10-03\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"2\", \"Yes\", \"client\"], [\"3\", \"No\", \"client\"], [\"4\", \"No\", \"client\"], [\"10\", \"Yes\", \"driver\"], [\"11\", \"Yes\", \"driver\"], [\"12\", \"Yes\", \"driver\"], [\"13\", \"No\", \"driver\"]]}}\\nThe input is just replacing the \\'banned\\' status for Driver 10,11,12 from the example input, as they are now banned.\\n**So only Driver 13 is not banned.**\\nThis makes 2013-10-01 and 2013-10-03 both having only 1 valid trip (both are cancelled), and 2013-10-02 having no valid trip.\\nThen **the cancel rate should be 1, null, 1.**\\nBut the expected output is the same as the example: 0.33, 0, 5.\\nHere is a visualization of this testcase\\'s input.\\n![image](https://assets.leetcode.com/users/images/222fde1a-80fc-4ce0-a77c-9ea9ed91a262_1612488816.5813634.png)\\nHere is the submission detail:\\n![image](https://assets.leetcode.com/users/images/56ff7e0a-edd2-4fbc-b348-ed4d226727aa_1612489131.203634.png)\\nIf you find that you passed 9/10 and only this one failed, I think it should be fine."
                    }
                ]
            },
            {
                "id": 1705017,
                "content": [
                    {
                        "username": "olivershih",
                        "content": "A test case seems wrong:\\n\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\n\\nBoth the client and driver are not banned:\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nSo the output should be one row which has a 100% cancellation rate:\\n\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-04 | 1                 |\\n\\nInstead this is the expected result:\\n\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nAm I missing something?\\n"
                    },
                    {
                        "username": "gjs190201",
                        "content": "[@chaosxlive](/chaosxlive) yaa exactly so you need one more condition as\\n```request_at BETWEEN DATE(\"2013-10-01\") AND DATE(\"2013-10-03\")```"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@chaosxlive](/chaosxlive)  You must check the day like [@Z.B. Weng](/chaosxlive) said, you can do like this:\\n# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "friedkale",
                        "content": "[@chaosxlive](/chaosxlive) wow."
                    },
                    {
                        "username": "bigGheorghe",
                        "content": "[@chaosxlive](/chaosxlive) omg, that\\'s an aggrevating criteria to fail a test on."
                    },
                    {
                        "username": "chaosxlive",
                        "content": "The days picked should be between \\'2013-10-01\\' and \\'2013-10-03\\'. \\'2013-10-04\\' is out of range."
                    },
                    {
                        "username": "roshaniitd88",
                        "content": "Is anyone facing any issue in executing MySQL using WITH CTE clause"
                    },
                    {
                        "username": "shwetashahuc",
                        "content": "no."
                    },
                    {
                        "username": "autodino",
                        "content": "The \"Expected Answer\" is Wrong!!! It doesn\\'t consider banned drivers!!!"
                    },
                    {
                        "username": "coderange",
                        "content": "The answer is right, I forgot to constraint the date."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect \\nRequest_at as Day, \\nround(sum(Status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\'))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips\\nwhere \\nClient_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'client\\') and\\nDriver_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'driver\\') and\\nRequest_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n;"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "select \\nRequest_at as Day,\\nround(sum(status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\' ))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips \\n      where client_id  in (select users_id from Users where banned =\\'No\\')\\n      and driver_id  in (select users_id from Users where banned =\\'No\\')\\n      and Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n\\nwe don\\'t need to specify role = \"client\" or \"driver\" if banned is \"no\""
                    },
                    {
                        "username": "user8565WN",
                        "content": "Based on this test case, my code should pass, but it showing incorrect. \\nNone of the Users are banned, so it should be 100% cancellation.\\n\\nAm i missing something?\\nThank you for your help.\\n\\n![image](https://assets.leetcode.com/users/images/cbfefaa4-9128-4218-a7cc-bb23ec37cee1_1643601252.5488906.png)\\n"
                    },
                    {
                        "username": "anujkn05",
                        "content": " request_at should be between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "mkutarna",
                        "content": "I have the same issue - if there is only 1 request, and it is cancelled, the rate should be 1."
                    },
                    {
                        "username": "kevingao1136",
                        "content": "with a as\\n(select * from Trips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\nand Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\'))\\n\\nselect Request_at as Day,\\n        round(avg(case when Status = \\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\'\\nfrom a\\ngroup by Day\\nhaving Day between \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "prakharbarole2405",
                        "content": "facing problem in naming column with space in mysql"
                    },
                    {
                        "username": "terence1219",
                        "content": "use `column` ( ` symbol)"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "me too, it\\'s so stupid wtf"
                    },
                    {
                        "username": "Sangeetha1695",
                        "content": "I first tried to join and use row_number function to pick only distinct values but sometimes a simple select with where clause is about right to do the job. \\n\\nselect request_at as Day,round((sum(case when status like \\'cancelled%\\' then 1 else 0 end)/count(id)),2) as `Cancellation Rate` \\nfrom trips \\nwhere client_id in (select distinct users_id from users where banned=\\'No\\') \\nand driver_id in (select distinct users_id from users where banned=\\'No\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at"
                    },
                    {
                        "username": "malpus",
                        "content": "# Write your MySQL query statement below\\nselect request_at as \"Day\", \\nround(sum(if(status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\',1,0))/count(*), 2) as \"Cancellation Rate\"\\nfrom trips as t\\njoin users as u1\\non t.client_id = u1.users_id\\njoin users as u2\\non t.driver_id = u2.users_id\\nwhere \\nrequest_at >= \\'2013-10-01\\' and request_at<= \\'2013-10-03\\'\\nand u1.banned = \\'No\\'\\nand u2.banned = \\'No\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "panzihang",
                        "content": "One of the testcases is wrong. Here is how:\\nInput:\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-01\"], [\"2\", \"2\", \"11\", \"1\", \"cancelled_by_driver\", \"2013-10-01\"], [\"3\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-01\"], [\"4\", \"4\", \"13\", \"6\", \"cancelled_by_client\", \"2013-10-01\"], [\"5\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-02\"], [\"6\", \"2\", \"11\", \"6\", \"completed\", \"2013-10-02\"], [\"7\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-02\"], [\"8\", \"2\", \"12\", \"12\", \"completed\", \"2013-10-03\"], [\"9\", \"3\", \"10\", \"12\", \"completed\", \"2013-10-03\"], [\"10\", \"4\", \"13\", \"12\", \"cancelled_by_driver\", \"2013-10-03\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"2\", \"Yes\", \"client\"], [\"3\", \"No\", \"client\"], [\"4\", \"No\", \"client\"], [\"10\", \"Yes\", \"driver\"], [\"11\", \"Yes\", \"driver\"], [\"12\", \"Yes\", \"driver\"], [\"13\", \"No\", \"driver\"]]}}\\nThe input is just replacing the \\'banned\\' status for Driver 10,11,12 from the example input, as they are now banned.\\n**So only Driver 13 is not banned.**\\nThis makes 2013-10-01 and 2013-10-03 both having only 1 valid trip (both are cancelled), and 2013-10-02 having no valid trip.\\nThen **the cancel rate should be 1, null, 1.**\\nBut the expected output is the same as the example: 0.33, 0, 5.\\nHere is a visualization of this testcase\\'s input.\\n![image](https://assets.leetcode.com/users/images/222fde1a-80fc-4ce0-a77c-9ea9ed91a262_1612488816.5813634.png)\\nHere is the submission detail:\\n![image](https://assets.leetcode.com/users/images/56ff7e0a-edd2-4fbc-b348-ed4d226727aa_1612489131.203634.png)\\nIf you find that you passed 9/10 and only this one failed, I think it should be fine."
                    }
                ]
            },
            {
                "id": 1576842,
                "content": [
                    {
                        "username": "olivershih",
                        "content": "A test case seems wrong:\\n\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\n\\nBoth the client and driver are not banned:\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nSo the output should be one row which has a 100% cancellation rate:\\n\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-04 | 1                 |\\n\\nInstead this is the expected result:\\n\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nAm I missing something?\\n"
                    },
                    {
                        "username": "gjs190201",
                        "content": "[@chaosxlive](/chaosxlive) yaa exactly so you need one more condition as\\n```request_at BETWEEN DATE(\"2013-10-01\") AND DATE(\"2013-10-03\")```"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@chaosxlive](/chaosxlive)  You must check the day like [@Z.B. Weng](/chaosxlive) said, you can do like this:\\n# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "friedkale",
                        "content": "[@chaosxlive](/chaosxlive) wow."
                    },
                    {
                        "username": "bigGheorghe",
                        "content": "[@chaosxlive](/chaosxlive) omg, that\\'s an aggrevating criteria to fail a test on."
                    },
                    {
                        "username": "chaosxlive",
                        "content": "The days picked should be between \\'2013-10-01\\' and \\'2013-10-03\\'. \\'2013-10-04\\' is out of range."
                    },
                    {
                        "username": "roshaniitd88",
                        "content": "Is anyone facing any issue in executing MySQL using WITH CTE clause"
                    },
                    {
                        "username": "shwetashahuc",
                        "content": "no."
                    },
                    {
                        "username": "autodino",
                        "content": "The \"Expected Answer\" is Wrong!!! It doesn\\'t consider banned drivers!!!"
                    },
                    {
                        "username": "coderange",
                        "content": "The answer is right, I forgot to constraint the date."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect \\nRequest_at as Day, \\nround(sum(Status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\'))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips\\nwhere \\nClient_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'client\\') and\\nDriver_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'driver\\') and\\nRequest_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n;"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "select \\nRequest_at as Day,\\nround(sum(status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\' ))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips \\n      where client_id  in (select users_id from Users where banned =\\'No\\')\\n      and driver_id  in (select users_id from Users where banned =\\'No\\')\\n      and Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n\\nwe don\\'t need to specify role = \"client\" or \"driver\" if banned is \"no\""
                    },
                    {
                        "username": "user8565WN",
                        "content": "Based on this test case, my code should pass, but it showing incorrect. \\nNone of the Users are banned, so it should be 100% cancellation.\\n\\nAm i missing something?\\nThank you for your help.\\n\\n![image](https://assets.leetcode.com/users/images/cbfefaa4-9128-4218-a7cc-bb23ec37cee1_1643601252.5488906.png)\\n"
                    },
                    {
                        "username": "anujkn05",
                        "content": " request_at should be between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "mkutarna",
                        "content": "I have the same issue - if there is only 1 request, and it is cancelled, the rate should be 1."
                    },
                    {
                        "username": "kevingao1136",
                        "content": "with a as\\n(select * from Trips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\nand Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\'))\\n\\nselect Request_at as Day,\\n        round(avg(case when Status = \\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\'\\nfrom a\\ngroup by Day\\nhaving Day between \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "prakharbarole2405",
                        "content": "facing problem in naming column with space in mysql"
                    },
                    {
                        "username": "terence1219",
                        "content": "use `column` ( ` symbol)"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "me too, it\\'s so stupid wtf"
                    },
                    {
                        "username": "Sangeetha1695",
                        "content": "I first tried to join and use row_number function to pick only distinct values but sometimes a simple select with where clause is about right to do the job. \\n\\nselect request_at as Day,round((sum(case when status like \\'cancelled%\\' then 1 else 0 end)/count(id)),2) as `Cancellation Rate` \\nfrom trips \\nwhere client_id in (select distinct users_id from users where banned=\\'No\\') \\nand driver_id in (select distinct users_id from users where banned=\\'No\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at"
                    },
                    {
                        "username": "malpus",
                        "content": "# Write your MySQL query statement below\\nselect request_at as \"Day\", \\nround(sum(if(status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\',1,0))/count(*), 2) as \"Cancellation Rate\"\\nfrom trips as t\\njoin users as u1\\non t.client_id = u1.users_id\\njoin users as u2\\non t.driver_id = u2.users_id\\nwhere \\nrequest_at >= \\'2013-10-01\\' and request_at<= \\'2013-10-03\\'\\nand u1.banned = \\'No\\'\\nand u2.banned = \\'No\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "panzihang",
                        "content": "One of the testcases is wrong. Here is how:\\nInput:\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-01\"], [\"2\", \"2\", \"11\", \"1\", \"cancelled_by_driver\", \"2013-10-01\"], [\"3\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-01\"], [\"4\", \"4\", \"13\", \"6\", \"cancelled_by_client\", \"2013-10-01\"], [\"5\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-02\"], [\"6\", \"2\", \"11\", \"6\", \"completed\", \"2013-10-02\"], [\"7\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-02\"], [\"8\", \"2\", \"12\", \"12\", \"completed\", \"2013-10-03\"], [\"9\", \"3\", \"10\", \"12\", \"completed\", \"2013-10-03\"], [\"10\", \"4\", \"13\", \"12\", \"cancelled_by_driver\", \"2013-10-03\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"2\", \"Yes\", \"client\"], [\"3\", \"No\", \"client\"], [\"4\", \"No\", \"client\"], [\"10\", \"Yes\", \"driver\"], [\"11\", \"Yes\", \"driver\"], [\"12\", \"Yes\", \"driver\"], [\"13\", \"No\", \"driver\"]]}}\\nThe input is just replacing the \\'banned\\' status for Driver 10,11,12 from the example input, as they are now banned.\\n**So only Driver 13 is not banned.**\\nThis makes 2013-10-01 and 2013-10-03 both having only 1 valid trip (both are cancelled), and 2013-10-02 having no valid trip.\\nThen **the cancel rate should be 1, null, 1.**\\nBut the expected output is the same as the example: 0.33, 0, 5.\\nHere is a visualization of this testcase\\'s input.\\n![image](https://assets.leetcode.com/users/images/222fde1a-80fc-4ce0-a77c-9ea9ed91a262_1612488816.5813634.png)\\nHere is the submission detail:\\n![image](https://assets.leetcode.com/users/images/56ff7e0a-edd2-4fbc-b348-ed4d226727aa_1612489131.203634.png)\\nIf you find that you passed 9/10 and only this one failed, I think it should be fine."
                    }
                ]
            },
            {
                "id": 1576696,
                "content": [
                    {
                        "username": "olivershih",
                        "content": "A test case seems wrong:\\n\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\n\\nBoth the client and driver are not banned:\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nSo the output should be one row which has a 100% cancellation rate:\\n\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-04 | 1                 |\\n\\nInstead this is the expected result:\\n\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nAm I missing something?\\n"
                    },
                    {
                        "username": "gjs190201",
                        "content": "[@chaosxlive](/chaosxlive) yaa exactly so you need one more condition as\\n```request_at BETWEEN DATE(\"2013-10-01\") AND DATE(\"2013-10-03\")```"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@chaosxlive](/chaosxlive)  You must check the day like [@Z.B. Weng](/chaosxlive) said, you can do like this:\\n# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "friedkale",
                        "content": "[@chaosxlive](/chaosxlive) wow."
                    },
                    {
                        "username": "bigGheorghe",
                        "content": "[@chaosxlive](/chaosxlive) omg, that\\'s an aggrevating criteria to fail a test on."
                    },
                    {
                        "username": "chaosxlive",
                        "content": "The days picked should be between \\'2013-10-01\\' and \\'2013-10-03\\'. \\'2013-10-04\\' is out of range."
                    },
                    {
                        "username": "roshaniitd88",
                        "content": "Is anyone facing any issue in executing MySQL using WITH CTE clause"
                    },
                    {
                        "username": "shwetashahuc",
                        "content": "no."
                    },
                    {
                        "username": "autodino",
                        "content": "The \"Expected Answer\" is Wrong!!! It doesn\\'t consider banned drivers!!!"
                    },
                    {
                        "username": "coderange",
                        "content": "The answer is right, I forgot to constraint the date."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect \\nRequest_at as Day, \\nround(sum(Status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\'))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips\\nwhere \\nClient_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'client\\') and\\nDriver_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'driver\\') and\\nRequest_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n;"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "select \\nRequest_at as Day,\\nround(sum(status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\' ))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips \\n      where client_id  in (select users_id from Users where banned =\\'No\\')\\n      and driver_id  in (select users_id from Users where banned =\\'No\\')\\n      and Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n\\nwe don\\'t need to specify role = \"client\" or \"driver\" if banned is \"no\""
                    },
                    {
                        "username": "user8565WN",
                        "content": "Based on this test case, my code should pass, but it showing incorrect. \\nNone of the Users are banned, so it should be 100% cancellation.\\n\\nAm i missing something?\\nThank you for your help.\\n\\n![image](https://assets.leetcode.com/users/images/cbfefaa4-9128-4218-a7cc-bb23ec37cee1_1643601252.5488906.png)\\n"
                    },
                    {
                        "username": "anujkn05",
                        "content": " request_at should be between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "mkutarna",
                        "content": "I have the same issue - if there is only 1 request, and it is cancelled, the rate should be 1."
                    },
                    {
                        "username": "kevingao1136",
                        "content": "with a as\\n(select * from Trips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\nand Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\'))\\n\\nselect Request_at as Day,\\n        round(avg(case when Status = \\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\'\\nfrom a\\ngroup by Day\\nhaving Day between \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "prakharbarole2405",
                        "content": "facing problem in naming column with space in mysql"
                    },
                    {
                        "username": "terence1219",
                        "content": "use `column` ( ` symbol)"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "me too, it\\'s so stupid wtf"
                    },
                    {
                        "username": "Sangeetha1695",
                        "content": "I first tried to join and use row_number function to pick only distinct values but sometimes a simple select with where clause is about right to do the job. \\n\\nselect request_at as Day,round((sum(case when status like \\'cancelled%\\' then 1 else 0 end)/count(id)),2) as `Cancellation Rate` \\nfrom trips \\nwhere client_id in (select distinct users_id from users where banned=\\'No\\') \\nand driver_id in (select distinct users_id from users where banned=\\'No\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at"
                    },
                    {
                        "username": "malpus",
                        "content": "# Write your MySQL query statement below\\nselect request_at as \"Day\", \\nround(sum(if(status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\',1,0))/count(*), 2) as \"Cancellation Rate\"\\nfrom trips as t\\njoin users as u1\\non t.client_id = u1.users_id\\njoin users as u2\\non t.driver_id = u2.users_id\\nwhere \\nrequest_at >= \\'2013-10-01\\' and request_at<= \\'2013-10-03\\'\\nand u1.banned = \\'No\\'\\nand u2.banned = \\'No\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "panzihang",
                        "content": "One of the testcases is wrong. Here is how:\\nInput:\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-01\"], [\"2\", \"2\", \"11\", \"1\", \"cancelled_by_driver\", \"2013-10-01\"], [\"3\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-01\"], [\"4\", \"4\", \"13\", \"6\", \"cancelled_by_client\", \"2013-10-01\"], [\"5\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-02\"], [\"6\", \"2\", \"11\", \"6\", \"completed\", \"2013-10-02\"], [\"7\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-02\"], [\"8\", \"2\", \"12\", \"12\", \"completed\", \"2013-10-03\"], [\"9\", \"3\", \"10\", \"12\", \"completed\", \"2013-10-03\"], [\"10\", \"4\", \"13\", \"12\", \"cancelled_by_driver\", \"2013-10-03\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"2\", \"Yes\", \"client\"], [\"3\", \"No\", \"client\"], [\"4\", \"No\", \"client\"], [\"10\", \"Yes\", \"driver\"], [\"11\", \"Yes\", \"driver\"], [\"12\", \"Yes\", \"driver\"], [\"13\", \"No\", \"driver\"]]}}\\nThe input is just replacing the \\'banned\\' status for Driver 10,11,12 from the example input, as they are now banned.\\n**So only Driver 13 is not banned.**\\nThis makes 2013-10-01 and 2013-10-03 both having only 1 valid trip (both are cancelled), and 2013-10-02 having no valid trip.\\nThen **the cancel rate should be 1, null, 1.**\\nBut the expected output is the same as the example: 0.33, 0, 5.\\nHere is a visualization of this testcase\\'s input.\\n![image](https://assets.leetcode.com/users/images/222fde1a-80fc-4ce0-a77c-9ea9ed91a262_1612488816.5813634.png)\\nHere is the submission detail:\\n![image](https://assets.leetcode.com/users/images/56ff7e0a-edd2-4fbc-b348-ed4d226727aa_1612489131.203634.png)\\nIf you find that you passed 9/10 and only this one failed, I think it should be fine."
                    }
                ]
            },
            {
                "id": 1568522,
                "content": [
                    {
                        "username": "olivershih",
                        "content": "A test case seems wrong:\\n\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\n\\nBoth the client and driver are not banned:\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nSo the output should be one row which has a 100% cancellation rate:\\n\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-04 | 1                 |\\n\\nInstead this is the expected result:\\n\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nAm I missing something?\\n"
                    },
                    {
                        "username": "gjs190201",
                        "content": "[@chaosxlive](/chaosxlive) yaa exactly so you need one more condition as\\n```request_at BETWEEN DATE(\"2013-10-01\") AND DATE(\"2013-10-03\")```"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@chaosxlive](/chaosxlive)  You must check the day like [@Z.B. Weng](/chaosxlive) said, you can do like this:\\n# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "friedkale",
                        "content": "[@chaosxlive](/chaosxlive) wow."
                    },
                    {
                        "username": "bigGheorghe",
                        "content": "[@chaosxlive](/chaosxlive) omg, that\\'s an aggrevating criteria to fail a test on."
                    },
                    {
                        "username": "chaosxlive",
                        "content": "The days picked should be between \\'2013-10-01\\' and \\'2013-10-03\\'. \\'2013-10-04\\' is out of range."
                    },
                    {
                        "username": "roshaniitd88",
                        "content": "Is anyone facing any issue in executing MySQL using WITH CTE clause"
                    },
                    {
                        "username": "shwetashahuc",
                        "content": "no."
                    },
                    {
                        "username": "autodino",
                        "content": "The \"Expected Answer\" is Wrong!!! It doesn\\'t consider banned drivers!!!"
                    },
                    {
                        "username": "coderange",
                        "content": "The answer is right, I forgot to constraint the date."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect \\nRequest_at as Day, \\nround(sum(Status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\'))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips\\nwhere \\nClient_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'client\\') and\\nDriver_Id not in (select Users_Id from Users where Banned =\\'Yes\\' and Role = \\'driver\\') and\\nRequest_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n;"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "select \\nRequest_at as Day,\\nround(sum(status in (\\'cancelled_by_driver\\', \\'cancelled_by_client\\' ))/count(*),2) as \\'Cancellation Rate\\'\\nfrom Trips \\n      where client_id  in (select users_id from Users where banned =\\'No\\')\\n      and driver_id  in (select users_id from Users where banned =\\'No\\')\\n      and Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by Request_at\\n\\nwe don\\'t need to specify role = \"client\" or \"driver\" if banned is \"no\""
                    },
                    {
                        "username": "user8565WN",
                        "content": "Based on this test case, my code should pass, but it showing incorrect. \\nNone of the Users are banned, so it should be 100% cancellation.\\n\\nAm i missing something?\\nThank you for your help.\\n\\n![image](https://assets.leetcode.com/users/images/cbfefaa4-9128-4218-a7cc-bb23ec37cee1_1643601252.5488906.png)\\n"
                    },
                    {
                        "username": "anujkn05",
                        "content": " request_at should be between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "mkutarna",
                        "content": "I have the same issue - if there is only 1 request, and it is cancelled, the rate should be 1."
                    },
                    {
                        "username": "kevingao1136",
                        "content": "with a as\\n(select * from Trips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\')\\nand Driver_Id not in (select Users_Id from Users where Banned = \\'Yes\\'))\\n\\nselect Request_at as Day,\\n        round(avg(case when Status = \\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\'\\nfrom a\\ngroup by Day\\nhaving Day between \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "prakharbarole2405",
                        "content": "facing problem in naming column with space in mysql"
                    },
                    {
                        "username": "terence1219",
                        "content": "use `column` ( ` symbol)"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "me too, it\\'s so stupid wtf"
                    },
                    {
                        "username": "Sangeetha1695",
                        "content": "I first tried to join and use row_number function to pick only distinct values but sometimes a simple select with where clause is about right to do the job. \\n\\nselect request_at as Day,round((sum(case when status like \\'cancelled%\\' then 1 else 0 end)/count(id)),2) as `Cancellation Rate` \\nfrom trips \\nwhere client_id in (select distinct users_id from users where banned=\\'No\\') \\nand driver_id in (select distinct users_id from users where banned=\\'No\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at"
                    },
                    {
                        "username": "malpus",
                        "content": "# Write your MySQL query statement below\\nselect request_at as \"Day\", \\nround(sum(if(status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\',1,0))/count(*), 2) as \"Cancellation Rate\"\\nfrom trips as t\\njoin users as u1\\non t.client_id = u1.users_id\\njoin users as u2\\non t.driver_id = u2.users_id\\nwhere \\nrequest_at >= \\'2013-10-01\\' and request_at<= \\'2013-10-03\\'\\nand u1.banned = \\'No\\'\\nand u2.banned = \\'No\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "panzihang",
                        "content": "One of the testcases is wrong. Here is how:\\nInput:\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-01\"], [\"2\", \"2\", \"11\", \"1\", \"cancelled_by_driver\", \"2013-10-01\"], [\"3\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-01\"], [\"4\", \"4\", \"13\", \"6\", \"cancelled_by_client\", \"2013-10-01\"], [\"5\", \"1\", \"10\", \"1\", \"completed\", \"2013-10-02\"], [\"6\", \"2\", \"11\", \"6\", \"completed\", \"2013-10-02\"], [\"7\", \"3\", \"12\", \"6\", \"completed\", \"2013-10-02\"], [\"8\", \"2\", \"12\", \"12\", \"completed\", \"2013-10-03\"], [\"9\", \"3\", \"10\", \"12\", \"completed\", \"2013-10-03\"], [\"10\", \"4\", \"13\", \"12\", \"cancelled_by_driver\", \"2013-10-03\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"2\", \"Yes\", \"client\"], [\"3\", \"No\", \"client\"], [\"4\", \"No\", \"client\"], [\"10\", \"Yes\", \"driver\"], [\"11\", \"Yes\", \"driver\"], [\"12\", \"Yes\", \"driver\"], [\"13\", \"No\", \"driver\"]]}}\\nThe input is just replacing the \\'banned\\' status for Driver 10,11,12 from the example input, as they are now banned.\\n**So only Driver 13 is not banned.**\\nThis makes 2013-10-01 and 2013-10-03 both having only 1 valid trip (both are cancelled), and 2013-10-02 having no valid trip.\\nThen **the cancel rate should be 1, null, 1.**\\nBut the expected output is the same as the example: 0.33, 0, 5.\\nHere is a visualization of this testcase\\'s input.\\n![image](https://assets.leetcode.com/users/images/222fde1a-80fc-4ce0-a77c-9ea9ed91a262_1612488816.5813634.png)\\nHere is the submission detail:\\n![image](https://assets.leetcode.com/users/images/56ff7e0a-edd2-4fbc-b348-ed4d226727aa_1612489131.203634.png)\\nIf you find that you passed 9/10 and only this one failed, I think it should be fine."
                    }
                ]
            },
            {
                "id": 1572216,
                "content": [
                    {
                        "username": "rdoddaia",
                        "content": "I am having a hard time trying to understand the meaning of the question. \\nCancellation Rate (of a particular day) = (no. of cancelled trips / total no. of trips on that day)??\\n\\nIf so, on the 1st of the month, out of 4 trips, 2 were cancelled by unbanned users (client or driver). So isn\\'t it 2/4 = 0.5?"
                    },
                    {
                        "username": "Turgay1975",
                        "content": "The client which has an user_id of \\'2\\' is a banned client. So we have to exclude this client from the calculation. "
                    },
                    {
                        "username": "ajaygartia",
                        "content": "Why the test case is failing for below solution/\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | Yes    | driver |\\n\\nExpected output\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\n\\nWITH CTE  as(\\nselect t.request_at request_day,count(status) as total ,sum(case when status like \\'cancelled%\\' then 1 else 0 end) cancelled  from trips t join users u\\non t.client_id=u.users_id \\nwhere u.banned in (\\'No\\')  group by t.request_at)\\nselect cte.request_day \"Day\", ROUND((cte.cancelled *1.0 / cte.total),2,1)  as  \"Cancellation Rate\"  from cte\\nwhere cte.request_day BETWEEN \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "feelingfine",
                        "content": "stuck on same test case i.e. 11/12 \\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\n\\nhow to return empty record in group by clause if record is 0?"
                    },
                    {
                        "username": "azeemj",
                        "content": "Mysql:\nI appreciate to review from u guys ,because Mysql does not support a filed name with space eg: Cancellation Rate\n\nselect CAST(coalesce(b.uncompleted_total/a.total,0) AS DECIMAL(6,2)) As Cancellation_Rate,\n a.request_at\n\nfrom(\n                select count(t.id) as total, t.request_at\n                from Trips t\n                inner join Users u on t.driver_id = u.users_id\n                where u.banned = 'No'\n                group by t.request_at\n\n) a\n\nleft join\n (\n                select  count(t.id) as uncompleted_total, t.request_at\n\n                from Trips t\n                inner join Users u on t.driver_id = u.users_id\n                where u.banned = 'No' and status !='completed'\n                group by t.request_at\n )b\n  on a.request_at = b.request_at\n\n\n\n"
                    },
                    {
                        "username": "Darn1t",
                        "content": "You can do: As \\'Cancellation Rate\\'"
                    },
                    {
                        "username": "jrggerz",
                        "content": "Test cases are WRONG \\nTEST CASE 9 : \\nTrips =\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nTEST CASE 11: \\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\n!SAME FUCKING TEST CASE AND DIFERENT SOLUTION! CANT BELIEVE THAT!"
                    },
                    {
                        "username": "pasha063",
                        "content": "Look closely on dates"
                    },
                    {
                        "username": "jsdeluca",
                        "content": "why does this not work (Oracle) - I am getting runtime error:\\n\\nwith request_data\\nas\\n(\\nselect t.request_at as \"day\", \\n    count(case when t.status != \\'completed\\' then t.status else null end) as cancels,\\n    count(*) as tot\\nfrom    trips t,\\n        users ud,\\n        users uc\\nwhere t.client_id = uc.users_id\\n    and t.driver_id = ud.users_id\\n    and ud.banned = \\'No\\'\\n    and uc.banned = \\'No\\'\\n    and t.request_at between \\n            to_date(\\'2013-10-01\\', \\'yyyy-mm-dd\\')  \\n            and to_date(\\'2013-10-03\\', \\'yyyy-mm-dd\\')\\ngroup by t.request_at\\n)\\nselect day, round(cancels/tot, 2) as \"Cancellation Rate\"\\nfrom request_data"
                    },
                    {
                        "username": "summiyakhalid",
                        "content": "\\nSELECT \\nREQUEST_AT AS Day, \\nROUND(AVG(CASE WHEN status IN (\\'cancelled_by_driver\\', \\'cancelled_by_client\\') THEN 1 ELSE 0 END),2) AS \"Cancellation Rate\"\\nFROM Trips k1\\nINNER JOIN Users k2\\non k1.driver_id = k2.users_id\\nAND k2.banned <> \\'Yes\\'\\nINNER JOIN Users k3\\non k1.client_id = k3.users_id\\nAND k3.banned <> \\'Yes\\'\\nWHERE \\nK1.REQUEST_AT >= \\'2013-10-01\\' and K1.REQUEST_AT<=\\'2013-10-03\\'\\nGROUP BY 1"
                    },
                    {
                        "username": "rickyjnathan",
                        "content": "\\'\\'\\'WITH Users_new AS (\\nSELECT * FROM Users\\nWHERE banned=\\'No\\'),\\nTrips_new AS (\\nSELECT * FROM Trips\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\nSELECT t.request_at as \\'Day\\',\\nROUND(SUM(CASE WHEN (status=\\'cancelled_by_driver\\' OR status=\\'cancelled_by_client\\') THEN 1 ELSE 0 END) / COUNT(*),2) as \\'Cancellation Rate\\'\\nFROM Trips_new t JOIN Users_new u1 ON t.client_id =u1.users_id\\nJOIN Users_new u2 ON t.driver_id = u2.users_id\\nGROUP BY 1\\nORDER BY 1 ASC\\n\\'\\'\\'"
                    },
                    {
                        "username": "bbwxnl",
                        "content": "WITH c AS (SELECT status,a.request_at\\nFROM Trips AS a\\nJOIN Users AS b1\\nON a.client_id= b1.users_id AND b1.role=\\'client\\'\\nJOIN Users AS b2\\nON a.driver_id=b2.users_id AND b2.role=\\'driver\\'\\nWHERE (a.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\') AND (b1.banned=\\'No\\' AND b2.banned=\\'No\\')),\\n\\nd AS (SELECT request_at, COUNT(*) AS num\\nFROM c\\nGROUP BY c.request_at),\\n\\ne AS (SELECT request_at, Sum(case when status  like \\'can%\\' then 1 else 0 end )AS cancel\\nFROM c\\n\\nGROUP BY c.request_at)\\n\\nSELECT d.request_at AS Day,ROUND(e.cancel/d.num,2) AS \\'Cancellation Rate\\'\\nFROM d\\njoin e\\nON d.request_at=e.request_at\\nGROUP BY d.request_at\\nORDER BY d.request_at"
                    },
                    {
                        "username": "vinerdekel",
                        "content": "the input : {\"headers\": {\"Trips\": [\"id\", \"client_id\", \"driver_id\", \"city_id\", \"status\", \"request_at\"], \"Users\": [\"users_id\", \"banned\", \"role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"cancelled_by_client\", \"2013-10-04\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"10\", \"No\", \"driver\"]]}}\\n\\nthe expected output: {\"headers\":[\"Day\",\"Cancellation Rate\"],\"values\":[]}\\n\\nthere was 1 trip, the client id is 1, the driver id is 10 both are not banned. the trips contain 1 order which was cancelled so the cancellation rate should be 1.00 right?"
                    },
                    {
                        "username": "hwynn52",
                        "content": "WITH unbanned as(\\nSELECT users_id\\nFROM Users\\nWHERE banned = \\'No\\'),\\ncancelled as(\\nSELECT t.request_at, COUNT(t.id) as cancelled\\nFROM Trips t\\nWHERE t.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nand t.client_id IN (SELECT * FROM unbanned)\\nand t.driver_id IN (SELECT * FROM unbanned)\\nand (t.status = \\'cancelled_by_driver\\' or t.status = \\'cancelled_by_client\\')\\nGROUP BY t.request_at)\\n\\nSELECT sub1.request_at as \"Day\",  ROUND(IFNULL(c.cancelled,0)/sub1.total,2) as \"Cancellation Rate\"\\nFROM\\n(SELECT t1.request_at, COUNT(t1.id) as total\\nFROM Trips t1\\nWHERE t1.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nand t1.client_id IN (SELECT * FROM unbanned)\\nand t1.driver_id IN (SELECT * FROM unbanned)\\nGROUP BY t1.request_at) sub1\\nLEFT JOIN cancelled c \\nON sub1.request_at = c.request_at"
                    }
                ]
            },
            {
                "id": 1938398,
                "content": [
                    {
                        "username": "rdoddaia",
                        "content": "I am having a hard time trying to understand the meaning of the question. \\nCancellation Rate (of a particular day) = (no. of cancelled trips / total no. of trips on that day)??\\n\\nIf so, on the 1st of the month, out of 4 trips, 2 were cancelled by unbanned users (client or driver). So isn\\'t it 2/4 = 0.5?"
                    },
                    {
                        "username": "Turgay1975",
                        "content": "The client which has an user_id of \\'2\\' is a banned client. So we have to exclude this client from the calculation. "
                    },
                    {
                        "username": "ajaygartia",
                        "content": "Why the test case is failing for below solution/\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | Yes    | driver |\\n\\nExpected output\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\n\\nWITH CTE  as(\\nselect t.request_at request_day,count(status) as total ,sum(case when status like \\'cancelled%\\' then 1 else 0 end) cancelled  from trips t join users u\\non t.client_id=u.users_id \\nwhere u.banned in (\\'No\\')  group by t.request_at)\\nselect cte.request_day \"Day\", ROUND((cte.cancelled *1.0 / cte.total),2,1)  as  \"Cancellation Rate\"  from cte\\nwhere cte.request_day BETWEEN \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "feelingfine",
                        "content": "stuck on same test case i.e. 11/12 \\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\n\\nhow to return empty record in group by clause if record is 0?"
                    },
                    {
                        "username": "azeemj",
                        "content": "Mysql:\nI appreciate to review from u guys ,because Mysql does not support a filed name with space eg: Cancellation Rate\n\nselect CAST(coalesce(b.uncompleted_total/a.total,0) AS DECIMAL(6,2)) As Cancellation_Rate,\n a.request_at\n\nfrom(\n                select count(t.id) as total, t.request_at\n                from Trips t\n                inner join Users u on t.driver_id = u.users_id\n                where u.banned = 'No'\n                group by t.request_at\n\n) a\n\nleft join\n (\n                select  count(t.id) as uncompleted_total, t.request_at\n\n                from Trips t\n                inner join Users u on t.driver_id = u.users_id\n                where u.banned = 'No' and status !='completed'\n                group by t.request_at\n )b\n  on a.request_at = b.request_at\n\n\n\n"
                    },
                    {
                        "username": "Darn1t",
                        "content": "You can do: As \\'Cancellation Rate\\'"
                    },
                    {
                        "username": "jrggerz",
                        "content": "Test cases are WRONG \\nTEST CASE 9 : \\nTrips =\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nTEST CASE 11: \\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\n!SAME FUCKING TEST CASE AND DIFERENT SOLUTION! CANT BELIEVE THAT!"
                    },
                    {
                        "username": "pasha063",
                        "content": "Look closely on dates"
                    },
                    {
                        "username": "jsdeluca",
                        "content": "why does this not work (Oracle) - I am getting runtime error:\\n\\nwith request_data\\nas\\n(\\nselect t.request_at as \"day\", \\n    count(case when t.status != \\'completed\\' then t.status else null end) as cancels,\\n    count(*) as tot\\nfrom    trips t,\\n        users ud,\\n        users uc\\nwhere t.client_id = uc.users_id\\n    and t.driver_id = ud.users_id\\n    and ud.banned = \\'No\\'\\n    and uc.banned = \\'No\\'\\n    and t.request_at between \\n            to_date(\\'2013-10-01\\', \\'yyyy-mm-dd\\')  \\n            and to_date(\\'2013-10-03\\', \\'yyyy-mm-dd\\')\\ngroup by t.request_at\\n)\\nselect day, round(cancels/tot, 2) as \"Cancellation Rate\"\\nfrom request_data"
                    },
                    {
                        "username": "summiyakhalid",
                        "content": "\\nSELECT \\nREQUEST_AT AS Day, \\nROUND(AVG(CASE WHEN status IN (\\'cancelled_by_driver\\', \\'cancelled_by_client\\') THEN 1 ELSE 0 END),2) AS \"Cancellation Rate\"\\nFROM Trips k1\\nINNER JOIN Users k2\\non k1.driver_id = k2.users_id\\nAND k2.banned <> \\'Yes\\'\\nINNER JOIN Users k3\\non k1.client_id = k3.users_id\\nAND k3.banned <> \\'Yes\\'\\nWHERE \\nK1.REQUEST_AT >= \\'2013-10-01\\' and K1.REQUEST_AT<=\\'2013-10-03\\'\\nGROUP BY 1"
                    },
                    {
                        "username": "rickyjnathan",
                        "content": "\\'\\'\\'WITH Users_new AS (\\nSELECT * FROM Users\\nWHERE banned=\\'No\\'),\\nTrips_new AS (\\nSELECT * FROM Trips\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\nSELECT t.request_at as \\'Day\\',\\nROUND(SUM(CASE WHEN (status=\\'cancelled_by_driver\\' OR status=\\'cancelled_by_client\\') THEN 1 ELSE 0 END) / COUNT(*),2) as \\'Cancellation Rate\\'\\nFROM Trips_new t JOIN Users_new u1 ON t.client_id =u1.users_id\\nJOIN Users_new u2 ON t.driver_id = u2.users_id\\nGROUP BY 1\\nORDER BY 1 ASC\\n\\'\\'\\'"
                    },
                    {
                        "username": "bbwxnl",
                        "content": "WITH c AS (SELECT status,a.request_at\\nFROM Trips AS a\\nJOIN Users AS b1\\nON a.client_id= b1.users_id AND b1.role=\\'client\\'\\nJOIN Users AS b2\\nON a.driver_id=b2.users_id AND b2.role=\\'driver\\'\\nWHERE (a.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\') AND (b1.banned=\\'No\\' AND b2.banned=\\'No\\')),\\n\\nd AS (SELECT request_at, COUNT(*) AS num\\nFROM c\\nGROUP BY c.request_at),\\n\\ne AS (SELECT request_at, Sum(case when status  like \\'can%\\' then 1 else 0 end )AS cancel\\nFROM c\\n\\nGROUP BY c.request_at)\\n\\nSELECT d.request_at AS Day,ROUND(e.cancel/d.num,2) AS \\'Cancellation Rate\\'\\nFROM d\\njoin e\\nON d.request_at=e.request_at\\nGROUP BY d.request_at\\nORDER BY d.request_at"
                    },
                    {
                        "username": "vinerdekel",
                        "content": "the input : {\"headers\": {\"Trips\": [\"id\", \"client_id\", \"driver_id\", \"city_id\", \"status\", \"request_at\"], \"Users\": [\"users_id\", \"banned\", \"role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"cancelled_by_client\", \"2013-10-04\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"10\", \"No\", \"driver\"]]}}\\n\\nthe expected output: {\"headers\":[\"Day\",\"Cancellation Rate\"],\"values\":[]}\\n\\nthere was 1 trip, the client id is 1, the driver id is 10 both are not banned. the trips contain 1 order which was cancelled so the cancellation rate should be 1.00 right?"
                    },
                    {
                        "username": "hwynn52",
                        "content": "WITH unbanned as(\\nSELECT users_id\\nFROM Users\\nWHERE banned = \\'No\\'),\\ncancelled as(\\nSELECT t.request_at, COUNT(t.id) as cancelled\\nFROM Trips t\\nWHERE t.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nand t.client_id IN (SELECT * FROM unbanned)\\nand t.driver_id IN (SELECT * FROM unbanned)\\nand (t.status = \\'cancelled_by_driver\\' or t.status = \\'cancelled_by_client\\')\\nGROUP BY t.request_at)\\n\\nSELECT sub1.request_at as \"Day\",  ROUND(IFNULL(c.cancelled,0)/sub1.total,2) as \"Cancellation Rate\"\\nFROM\\n(SELECT t1.request_at, COUNT(t1.id) as total\\nFROM Trips t1\\nWHERE t1.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nand t1.client_id IN (SELECT * FROM unbanned)\\nand t1.driver_id IN (SELECT * FROM unbanned)\\nGROUP BY t1.request_at) sub1\\nLEFT JOIN cancelled c \\nON sub1.request_at = c.request_at"
                    }
                ]
            },
            {
                "id": 1967405,
                "content": [
                    {
                        "username": "rdoddaia",
                        "content": "I am having a hard time trying to understand the meaning of the question. \\nCancellation Rate (of a particular day) = (no. of cancelled trips / total no. of trips on that day)??\\n\\nIf so, on the 1st of the month, out of 4 trips, 2 were cancelled by unbanned users (client or driver). So isn\\'t it 2/4 = 0.5?"
                    },
                    {
                        "username": "Turgay1975",
                        "content": "The client which has an user_id of \\'2\\' is a banned client. So we have to exclude this client from the calculation. "
                    },
                    {
                        "username": "ajaygartia",
                        "content": "Why the test case is failing for below solution/\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | Yes    | driver |\\n\\nExpected output\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\n\\nWITH CTE  as(\\nselect t.request_at request_day,count(status) as total ,sum(case when status like \\'cancelled%\\' then 1 else 0 end) cancelled  from trips t join users u\\non t.client_id=u.users_id \\nwhere u.banned in (\\'No\\')  group by t.request_at)\\nselect cte.request_day \"Day\", ROUND((cte.cancelled *1.0 / cte.total),2,1)  as  \"Cancellation Rate\"  from cte\\nwhere cte.request_day BETWEEN \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "feelingfine",
                        "content": "stuck on same test case i.e. 11/12 \\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\n\\nhow to return empty record in group by clause if record is 0?"
                    },
                    {
                        "username": "azeemj",
                        "content": "Mysql:\nI appreciate to review from u guys ,because Mysql does not support a filed name with space eg: Cancellation Rate\n\nselect CAST(coalesce(b.uncompleted_total/a.total,0) AS DECIMAL(6,2)) As Cancellation_Rate,\n a.request_at\n\nfrom(\n                select count(t.id) as total, t.request_at\n                from Trips t\n                inner join Users u on t.driver_id = u.users_id\n                where u.banned = 'No'\n                group by t.request_at\n\n) a\n\nleft join\n (\n                select  count(t.id) as uncompleted_total, t.request_at\n\n                from Trips t\n                inner join Users u on t.driver_id = u.users_id\n                where u.banned = 'No' and status !='completed'\n                group by t.request_at\n )b\n  on a.request_at = b.request_at\n\n\n\n"
                    },
                    {
                        "username": "Darn1t",
                        "content": "You can do: As \\'Cancellation Rate\\'"
                    },
                    {
                        "username": "jrggerz",
                        "content": "Test cases are WRONG \\nTEST CASE 9 : \\nTrips =\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nTEST CASE 11: \\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\n!SAME FUCKING TEST CASE AND DIFERENT SOLUTION! CANT BELIEVE THAT!"
                    },
                    {
                        "username": "pasha063",
                        "content": "Look closely on dates"
                    },
                    {
                        "username": "jsdeluca",
                        "content": "why does this not work (Oracle) - I am getting runtime error:\\n\\nwith request_data\\nas\\n(\\nselect t.request_at as \"day\", \\n    count(case when t.status != \\'completed\\' then t.status else null end) as cancels,\\n    count(*) as tot\\nfrom    trips t,\\n        users ud,\\n        users uc\\nwhere t.client_id = uc.users_id\\n    and t.driver_id = ud.users_id\\n    and ud.banned = \\'No\\'\\n    and uc.banned = \\'No\\'\\n    and t.request_at between \\n            to_date(\\'2013-10-01\\', \\'yyyy-mm-dd\\')  \\n            and to_date(\\'2013-10-03\\', \\'yyyy-mm-dd\\')\\ngroup by t.request_at\\n)\\nselect day, round(cancels/tot, 2) as \"Cancellation Rate\"\\nfrom request_data"
                    },
                    {
                        "username": "summiyakhalid",
                        "content": "\\nSELECT \\nREQUEST_AT AS Day, \\nROUND(AVG(CASE WHEN status IN (\\'cancelled_by_driver\\', \\'cancelled_by_client\\') THEN 1 ELSE 0 END),2) AS \"Cancellation Rate\"\\nFROM Trips k1\\nINNER JOIN Users k2\\non k1.driver_id = k2.users_id\\nAND k2.banned <> \\'Yes\\'\\nINNER JOIN Users k3\\non k1.client_id = k3.users_id\\nAND k3.banned <> \\'Yes\\'\\nWHERE \\nK1.REQUEST_AT >= \\'2013-10-01\\' and K1.REQUEST_AT<=\\'2013-10-03\\'\\nGROUP BY 1"
                    },
                    {
                        "username": "rickyjnathan",
                        "content": "\\'\\'\\'WITH Users_new AS (\\nSELECT * FROM Users\\nWHERE banned=\\'No\\'),\\nTrips_new AS (\\nSELECT * FROM Trips\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\nSELECT t.request_at as \\'Day\\',\\nROUND(SUM(CASE WHEN (status=\\'cancelled_by_driver\\' OR status=\\'cancelled_by_client\\') THEN 1 ELSE 0 END) / COUNT(*),2) as \\'Cancellation Rate\\'\\nFROM Trips_new t JOIN Users_new u1 ON t.client_id =u1.users_id\\nJOIN Users_new u2 ON t.driver_id = u2.users_id\\nGROUP BY 1\\nORDER BY 1 ASC\\n\\'\\'\\'"
                    },
                    {
                        "username": "bbwxnl",
                        "content": "WITH c AS (SELECT status,a.request_at\\nFROM Trips AS a\\nJOIN Users AS b1\\nON a.client_id= b1.users_id AND b1.role=\\'client\\'\\nJOIN Users AS b2\\nON a.driver_id=b2.users_id AND b2.role=\\'driver\\'\\nWHERE (a.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\') AND (b1.banned=\\'No\\' AND b2.banned=\\'No\\')),\\n\\nd AS (SELECT request_at, COUNT(*) AS num\\nFROM c\\nGROUP BY c.request_at),\\n\\ne AS (SELECT request_at, Sum(case when status  like \\'can%\\' then 1 else 0 end )AS cancel\\nFROM c\\n\\nGROUP BY c.request_at)\\n\\nSELECT d.request_at AS Day,ROUND(e.cancel/d.num,2) AS \\'Cancellation Rate\\'\\nFROM d\\njoin e\\nON d.request_at=e.request_at\\nGROUP BY d.request_at\\nORDER BY d.request_at"
                    },
                    {
                        "username": "vinerdekel",
                        "content": "the input : {\"headers\": {\"Trips\": [\"id\", \"client_id\", \"driver_id\", \"city_id\", \"status\", \"request_at\"], \"Users\": [\"users_id\", \"banned\", \"role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"cancelled_by_client\", \"2013-10-04\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"10\", \"No\", \"driver\"]]}}\\n\\nthe expected output: {\"headers\":[\"Day\",\"Cancellation Rate\"],\"values\":[]}\\n\\nthere was 1 trip, the client id is 1, the driver id is 10 both are not banned. the trips contain 1 order which was cancelled so the cancellation rate should be 1.00 right?"
                    },
                    {
                        "username": "hwynn52",
                        "content": "WITH unbanned as(\\nSELECT users_id\\nFROM Users\\nWHERE banned = \\'No\\'),\\ncancelled as(\\nSELECT t.request_at, COUNT(t.id) as cancelled\\nFROM Trips t\\nWHERE t.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nand t.client_id IN (SELECT * FROM unbanned)\\nand t.driver_id IN (SELECT * FROM unbanned)\\nand (t.status = \\'cancelled_by_driver\\' or t.status = \\'cancelled_by_client\\')\\nGROUP BY t.request_at)\\n\\nSELECT sub1.request_at as \"Day\",  ROUND(IFNULL(c.cancelled,0)/sub1.total,2) as \"Cancellation Rate\"\\nFROM\\n(SELECT t1.request_at, COUNT(t1.id) as total\\nFROM Trips t1\\nWHERE t1.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nand t1.client_id IN (SELECT * FROM unbanned)\\nand t1.driver_id IN (SELECT * FROM unbanned)\\nGROUP BY t1.request_at) sub1\\nLEFT JOIN cancelled c \\nON sub1.request_at = c.request_at"
                    }
                ]
            },
            {
                "id": 1792804,
                "content": [
                    {
                        "username": "rdoddaia",
                        "content": "I am having a hard time trying to understand the meaning of the question. \\nCancellation Rate (of a particular day) = (no. of cancelled trips / total no. of trips on that day)??\\n\\nIf so, on the 1st of the month, out of 4 trips, 2 were cancelled by unbanned users (client or driver). So isn\\'t it 2/4 = 0.5?"
                    },
                    {
                        "username": "Turgay1975",
                        "content": "The client which has an user_id of \\'2\\' is a banned client. So we have to exclude this client from the calculation. "
                    },
                    {
                        "username": "ajaygartia",
                        "content": "Why the test case is failing for below solution/\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | Yes    | driver |\\n\\nExpected output\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\n\\nWITH CTE  as(\\nselect t.request_at request_day,count(status) as total ,sum(case when status like \\'cancelled%\\' then 1 else 0 end) cancelled  from trips t join users u\\non t.client_id=u.users_id \\nwhere u.banned in (\\'No\\')  group by t.request_at)\\nselect cte.request_day \"Day\", ROUND((cte.cancelled *1.0 / cte.total),2,1)  as  \"Cancellation Rate\"  from cte\\nwhere cte.request_day BETWEEN \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "feelingfine",
                        "content": "stuck on same test case i.e. 11/12 \\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\n\\nhow to return empty record in group by clause if record is 0?"
                    },
                    {
                        "username": "azeemj",
                        "content": "Mysql:\nI appreciate to review from u guys ,because Mysql does not support a filed name with space eg: Cancellation Rate\n\nselect CAST(coalesce(b.uncompleted_total/a.total,0) AS DECIMAL(6,2)) As Cancellation_Rate,\n a.request_at\n\nfrom(\n                select count(t.id) as total, t.request_at\n                from Trips t\n                inner join Users u on t.driver_id = u.users_id\n                where u.banned = 'No'\n                group by t.request_at\n\n) a\n\nleft join\n (\n                select  count(t.id) as uncompleted_total, t.request_at\n\n                from Trips t\n                inner join Users u on t.driver_id = u.users_id\n                where u.banned = 'No' and status !='completed'\n                group by t.request_at\n )b\n  on a.request_at = b.request_at\n\n\n\n"
                    },
                    {
                        "username": "Darn1t",
                        "content": "You can do: As \\'Cancellation Rate\\'"
                    },
                    {
                        "username": "jrggerz",
                        "content": "Test cases are WRONG \\nTEST CASE 9 : \\nTrips =\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nTEST CASE 11: \\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\n!SAME FUCKING TEST CASE AND DIFERENT SOLUTION! CANT BELIEVE THAT!"
                    },
                    {
                        "username": "pasha063",
                        "content": "Look closely on dates"
                    },
                    {
                        "username": "jsdeluca",
                        "content": "why does this not work (Oracle) - I am getting runtime error:\\n\\nwith request_data\\nas\\n(\\nselect t.request_at as \"day\", \\n    count(case when t.status != \\'completed\\' then t.status else null end) as cancels,\\n    count(*) as tot\\nfrom    trips t,\\n        users ud,\\n        users uc\\nwhere t.client_id = uc.users_id\\n    and t.driver_id = ud.users_id\\n    and ud.banned = \\'No\\'\\n    and uc.banned = \\'No\\'\\n    and t.request_at between \\n            to_date(\\'2013-10-01\\', \\'yyyy-mm-dd\\')  \\n            and to_date(\\'2013-10-03\\', \\'yyyy-mm-dd\\')\\ngroup by t.request_at\\n)\\nselect day, round(cancels/tot, 2) as \"Cancellation Rate\"\\nfrom request_data"
                    },
                    {
                        "username": "summiyakhalid",
                        "content": "\\nSELECT \\nREQUEST_AT AS Day, \\nROUND(AVG(CASE WHEN status IN (\\'cancelled_by_driver\\', \\'cancelled_by_client\\') THEN 1 ELSE 0 END),2) AS \"Cancellation Rate\"\\nFROM Trips k1\\nINNER JOIN Users k2\\non k1.driver_id = k2.users_id\\nAND k2.banned <> \\'Yes\\'\\nINNER JOIN Users k3\\non k1.client_id = k3.users_id\\nAND k3.banned <> \\'Yes\\'\\nWHERE \\nK1.REQUEST_AT >= \\'2013-10-01\\' and K1.REQUEST_AT<=\\'2013-10-03\\'\\nGROUP BY 1"
                    },
                    {
                        "username": "rickyjnathan",
                        "content": "\\'\\'\\'WITH Users_new AS (\\nSELECT * FROM Users\\nWHERE banned=\\'No\\'),\\nTrips_new AS (\\nSELECT * FROM Trips\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\nSELECT t.request_at as \\'Day\\',\\nROUND(SUM(CASE WHEN (status=\\'cancelled_by_driver\\' OR status=\\'cancelled_by_client\\') THEN 1 ELSE 0 END) / COUNT(*),2) as \\'Cancellation Rate\\'\\nFROM Trips_new t JOIN Users_new u1 ON t.client_id =u1.users_id\\nJOIN Users_new u2 ON t.driver_id = u2.users_id\\nGROUP BY 1\\nORDER BY 1 ASC\\n\\'\\'\\'"
                    },
                    {
                        "username": "bbwxnl",
                        "content": "WITH c AS (SELECT status,a.request_at\\nFROM Trips AS a\\nJOIN Users AS b1\\nON a.client_id= b1.users_id AND b1.role=\\'client\\'\\nJOIN Users AS b2\\nON a.driver_id=b2.users_id AND b2.role=\\'driver\\'\\nWHERE (a.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\') AND (b1.banned=\\'No\\' AND b2.banned=\\'No\\')),\\n\\nd AS (SELECT request_at, COUNT(*) AS num\\nFROM c\\nGROUP BY c.request_at),\\n\\ne AS (SELECT request_at, Sum(case when status  like \\'can%\\' then 1 else 0 end )AS cancel\\nFROM c\\n\\nGROUP BY c.request_at)\\n\\nSELECT d.request_at AS Day,ROUND(e.cancel/d.num,2) AS \\'Cancellation Rate\\'\\nFROM d\\njoin e\\nON d.request_at=e.request_at\\nGROUP BY d.request_at\\nORDER BY d.request_at"
                    },
                    {
                        "username": "vinerdekel",
                        "content": "the input : {\"headers\": {\"Trips\": [\"id\", \"client_id\", \"driver_id\", \"city_id\", \"status\", \"request_at\"], \"Users\": [\"users_id\", \"banned\", \"role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"cancelled_by_client\", \"2013-10-04\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"10\", \"No\", \"driver\"]]}}\\n\\nthe expected output: {\"headers\":[\"Day\",\"Cancellation Rate\"],\"values\":[]}\\n\\nthere was 1 trip, the client id is 1, the driver id is 10 both are not banned. the trips contain 1 order which was cancelled so the cancellation rate should be 1.00 right?"
                    },
                    {
                        "username": "hwynn52",
                        "content": "WITH unbanned as(\\nSELECT users_id\\nFROM Users\\nWHERE banned = \\'No\\'),\\ncancelled as(\\nSELECT t.request_at, COUNT(t.id) as cancelled\\nFROM Trips t\\nWHERE t.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nand t.client_id IN (SELECT * FROM unbanned)\\nand t.driver_id IN (SELECT * FROM unbanned)\\nand (t.status = \\'cancelled_by_driver\\' or t.status = \\'cancelled_by_client\\')\\nGROUP BY t.request_at)\\n\\nSELECT sub1.request_at as \"Day\",  ROUND(IFNULL(c.cancelled,0)/sub1.total,2) as \"Cancellation Rate\"\\nFROM\\n(SELECT t1.request_at, COUNT(t1.id) as total\\nFROM Trips t1\\nWHERE t1.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nand t1.client_id IN (SELECT * FROM unbanned)\\nand t1.driver_id IN (SELECT * FROM unbanned)\\nGROUP BY t1.request_at) sub1\\nLEFT JOIN cancelled c \\nON sub1.request_at = c.request_at"
                    }
                ]
            },
            {
                "id": 1650614,
                "content": [
                    {
                        "username": "rdoddaia",
                        "content": "I am having a hard time trying to understand the meaning of the question. \\nCancellation Rate (of a particular day) = (no. of cancelled trips / total no. of trips on that day)??\\n\\nIf so, on the 1st of the month, out of 4 trips, 2 were cancelled by unbanned users (client or driver). So isn\\'t it 2/4 = 0.5?"
                    },
                    {
                        "username": "Turgay1975",
                        "content": "The client which has an user_id of \\'2\\' is a banned client. So we have to exclude this client from the calculation. "
                    },
                    {
                        "username": "ajaygartia",
                        "content": "Why the test case is failing for below solution/\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | Yes    | driver |\\n\\nExpected output\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\n\\nWITH CTE  as(\\nselect t.request_at request_day,count(status) as total ,sum(case when status like \\'cancelled%\\' then 1 else 0 end) cancelled  from trips t join users u\\non t.client_id=u.users_id \\nwhere u.banned in (\\'No\\')  group by t.request_at)\\nselect cte.request_day \"Day\", ROUND((cte.cancelled *1.0 / cte.total),2,1)  as  \"Cancellation Rate\"  from cte\\nwhere cte.request_day BETWEEN \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "feelingfine",
                        "content": "stuck on same test case i.e. 11/12 \\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\n\\nhow to return empty record in group by clause if record is 0?"
                    },
                    {
                        "username": "azeemj",
                        "content": "Mysql:\nI appreciate to review from u guys ,because Mysql does not support a filed name with space eg: Cancellation Rate\n\nselect CAST(coalesce(b.uncompleted_total/a.total,0) AS DECIMAL(6,2)) As Cancellation_Rate,\n a.request_at\n\nfrom(\n                select count(t.id) as total, t.request_at\n                from Trips t\n                inner join Users u on t.driver_id = u.users_id\n                where u.banned = 'No'\n                group by t.request_at\n\n) a\n\nleft join\n (\n                select  count(t.id) as uncompleted_total, t.request_at\n\n                from Trips t\n                inner join Users u on t.driver_id = u.users_id\n                where u.banned = 'No' and status !='completed'\n                group by t.request_at\n )b\n  on a.request_at = b.request_at\n\n\n\n"
                    },
                    {
                        "username": "Darn1t",
                        "content": "You can do: As \\'Cancellation Rate\\'"
                    },
                    {
                        "username": "jrggerz",
                        "content": "Test cases are WRONG \\nTEST CASE 9 : \\nTrips =\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nTEST CASE 11: \\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\n!SAME FUCKING TEST CASE AND DIFERENT SOLUTION! CANT BELIEVE THAT!"
                    },
                    {
                        "username": "pasha063",
                        "content": "Look closely on dates"
                    },
                    {
                        "username": "jsdeluca",
                        "content": "why does this not work (Oracle) - I am getting runtime error:\\n\\nwith request_data\\nas\\n(\\nselect t.request_at as \"day\", \\n    count(case when t.status != \\'completed\\' then t.status else null end) as cancels,\\n    count(*) as tot\\nfrom    trips t,\\n        users ud,\\n        users uc\\nwhere t.client_id = uc.users_id\\n    and t.driver_id = ud.users_id\\n    and ud.banned = \\'No\\'\\n    and uc.banned = \\'No\\'\\n    and t.request_at between \\n            to_date(\\'2013-10-01\\', \\'yyyy-mm-dd\\')  \\n            and to_date(\\'2013-10-03\\', \\'yyyy-mm-dd\\')\\ngroup by t.request_at\\n)\\nselect day, round(cancels/tot, 2) as \"Cancellation Rate\"\\nfrom request_data"
                    },
                    {
                        "username": "summiyakhalid",
                        "content": "\\nSELECT \\nREQUEST_AT AS Day, \\nROUND(AVG(CASE WHEN status IN (\\'cancelled_by_driver\\', \\'cancelled_by_client\\') THEN 1 ELSE 0 END),2) AS \"Cancellation Rate\"\\nFROM Trips k1\\nINNER JOIN Users k2\\non k1.driver_id = k2.users_id\\nAND k2.banned <> \\'Yes\\'\\nINNER JOIN Users k3\\non k1.client_id = k3.users_id\\nAND k3.banned <> \\'Yes\\'\\nWHERE \\nK1.REQUEST_AT >= \\'2013-10-01\\' and K1.REQUEST_AT<=\\'2013-10-03\\'\\nGROUP BY 1"
                    },
                    {
                        "username": "rickyjnathan",
                        "content": "\\'\\'\\'WITH Users_new AS (\\nSELECT * FROM Users\\nWHERE banned=\\'No\\'),\\nTrips_new AS (\\nSELECT * FROM Trips\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\nSELECT t.request_at as \\'Day\\',\\nROUND(SUM(CASE WHEN (status=\\'cancelled_by_driver\\' OR status=\\'cancelled_by_client\\') THEN 1 ELSE 0 END) / COUNT(*),2) as \\'Cancellation Rate\\'\\nFROM Trips_new t JOIN Users_new u1 ON t.client_id =u1.users_id\\nJOIN Users_new u2 ON t.driver_id = u2.users_id\\nGROUP BY 1\\nORDER BY 1 ASC\\n\\'\\'\\'"
                    },
                    {
                        "username": "bbwxnl",
                        "content": "WITH c AS (SELECT status,a.request_at\\nFROM Trips AS a\\nJOIN Users AS b1\\nON a.client_id= b1.users_id AND b1.role=\\'client\\'\\nJOIN Users AS b2\\nON a.driver_id=b2.users_id AND b2.role=\\'driver\\'\\nWHERE (a.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\') AND (b1.banned=\\'No\\' AND b2.banned=\\'No\\')),\\n\\nd AS (SELECT request_at, COUNT(*) AS num\\nFROM c\\nGROUP BY c.request_at),\\n\\ne AS (SELECT request_at, Sum(case when status  like \\'can%\\' then 1 else 0 end )AS cancel\\nFROM c\\n\\nGROUP BY c.request_at)\\n\\nSELECT d.request_at AS Day,ROUND(e.cancel/d.num,2) AS \\'Cancellation Rate\\'\\nFROM d\\njoin e\\nON d.request_at=e.request_at\\nGROUP BY d.request_at\\nORDER BY d.request_at"
                    },
                    {
                        "username": "vinerdekel",
                        "content": "the input : {\"headers\": {\"Trips\": [\"id\", \"client_id\", \"driver_id\", \"city_id\", \"status\", \"request_at\"], \"Users\": [\"users_id\", \"banned\", \"role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"cancelled_by_client\", \"2013-10-04\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"10\", \"No\", \"driver\"]]}}\\n\\nthe expected output: {\"headers\":[\"Day\",\"Cancellation Rate\"],\"values\":[]}\\n\\nthere was 1 trip, the client id is 1, the driver id is 10 both are not banned. the trips contain 1 order which was cancelled so the cancellation rate should be 1.00 right?"
                    },
                    {
                        "username": "hwynn52",
                        "content": "WITH unbanned as(\\nSELECT users_id\\nFROM Users\\nWHERE banned = \\'No\\'),\\ncancelled as(\\nSELECT t.request_at, COUNT(t.id) as cancelled\\nFROM Trips t\\nWHERE t.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nand t.client_id IN (SELECT * FROM unbanned)\\nand t.driver_id IN (SELECT * FROM unbanned)\\nand (t.status = \\'cancelled_by_driver\\' or t.status = \\'cancelled_by_client\\')\\nGROUP BY t.request_at)\\n\\nSELECT sub1.request_at as \"Day\",  ROUND(IFNULL(c.cancelled,0)/sub1.total,2) as \"Cancellation Rate\"\\nFROM\\n(SELECT t1.request_at, COUNT(t1.id) as total\\nFROM Trips t1\\nWHERE t1.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nand t1.client_id IN (SELECT * FROM unbanned)\\nand t1.driver_id IN (SELECT * FROM unbanned)\\nGROUP BY t1.request_at) sub1\\nLEFT JOIN cancelled c \\nON sub1.request_at = c.request_at"
                    }
                ]
            },
            {
                "id": 1576640,
                "content": [
                    {
                        "username": "rdoddaia",
                        "content": "I am having a hard time trying to understand the meaning of the question. \\nCancellation Rate (of a particular day) = (no. of cancelled trips / total no. of trips on that day)??\\n\\nIf so, on the 1st of the month, out of 4 trips, 2 were cancelled by unbanned users (client or driver). So isn\\'t it 2/4 = 0.5?"
                    },
                    {
                        "username": "Turgay1975",
                        "content": "The client which has an user_id of \\'2\\' is a banned client. So we have to exclude this client from the calculation. "
                    },
                    {
                        "username": "ajaygartia",
                        "content": "Why the test case is failing for below solution/\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | Yes    | driver |\\n\\nExpected output\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\n\\nWITH CTE  as(\\nselect t.request_at request_day,count(status) as total ,sum(case when status like \\'cancelled%\\' then 1 else 0 end) cancelled  from trips t join users u\\non t.client_id=u.users_id \\nwhere u.banned in (\\'No\\')  group by t.request_at)\\nselect cte.request_day \"Day\", ROUND((cte.cancelled *1.0 / cte.total),2,1)  as  \"Cancellation Rate\"  from cte\\nwhere cte.request_day BETWEEN \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "feelingfine",
                        "content": "stuck on same test case i.e. 11/12 \\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\n\\nhow to return empty record in group by clause if record is 0?"
                    },
                    {
                        "username": "azeemj",
                        "content": "Mysql:\nI appreciate to review from u guys ,because Mysql does not support a filed name with space eg: Cancellation Rate\n\nselect CAST(coalesce(b.uncompleted_total/a.total,0) AS DECIMAL(6,2)) As Cancellation_Rate,\n a.request_at\n\nfrom(\n                select count(t.id) as total, t.request_at\n                from Trips t\n                inner join Users u on t.driver_id = u.users_id\n                where u.banned = 'No'\n                group by t.request_at\n\n) a\n\nleft join\n (\n                select  count(t.id) as uncompleted_total, t.request_at\n\n                from Trips t\n                inner join Users u on t.driver_id = u.users_id\n                where u.banned = 'No' and status !='completed'\n                group by t.request_at\n )b\n  on a.request_at = b.request_at\n\n\n\n"
                    },
                    {
                        "username": "Darn1t",
                        "content": "You can do: As \\'Cancellation Rate\\'"
                    },
                    {
                        "username": "jrggerz",
                        "content": "Test cases are WRONG \\nTEST CASE 9 : \\nTrips =\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nTEST CASE 11: \\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\n!SAME FUCKING TEST CASE AND DIFERENT SOLUTION! CANT BELIEVE THAT!"
                    },
                    {
                        "username": "pasha063",
                        "content": "Look closely on dates"
                    },
                    {
                        "username": "jsdeluca",
                        "content": "why does this not work (Oracle) - I am getting runtime error:\\n\\nwith request_data\\nas\\n(\\nselect t.request_at as \"day\", \\n    count(case when t.status != \\'completed\\' then t.status else null end) as cancels,\\n    count(*) as tot\\nfrom    trips t,\\n        users ud,\\n        users uc\\nwhere t.client_id = uc.users_id\\n    and t.driver_id = ud.users_id\\n    and ud.banned = \\'No\\'\\n    and uc.banned = \\'No\\'\\n    and t.request_at between \\n            to_date(\\'2013-10-01\\', \\'yyyy-mm-dd\\')  \\n            and to_date(\\'2013-10-03\\', \\'yyyy-mm-dd\\')\\ngroup by t.request_at\\n)\\nselect day, round(cancels/tot, 2) as \"Cancellation Rate\"\\nfrom request_data"
                    },
                    {
                        "username": "summiyakhalid",
                        "content": "\\nSELECT \\nREQUEST_AT AS Day, \\nROUND(AVG(CASE WHEN status IN (\\'cancelled_by_driver\\', \\'cancelled_by_client\\') THEN 1 ELSE 0 END),2) AS \"Cancellation Rate\"\\nFROM Trips k1\\nINNER JOIN Users k2\\non k1.driver_id = k2.users_id\\nAND k2.banned <> \\'Yes\\'\\nINNER JOIN Users k3\\non k1.client_id = k3.users_id\\nAND k3.banned <> \\'Yes\\'\\nWHERE \\nK1.REQUEST_AT >= \\'2013-10-01\\' and K1.REQUEST_AT<=\\'2013-10-03\\'\\nGROUP BY 1"
                    },
                    {
                        "username": "rickyjnathan",
                        "content": "\\'\\'\\'WITH Users_new AS (\\nSELECT * FROM Users\\nWHERE banned=\\'No\\'),\\nTrips_new AS (\\nSELECT * FROM Trips\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\nSELECT t.request_at as \\'Day\\',\\nROUND(SUM(CASE WHEN (status=\\'cancelled_by_driver\\' OR status=\\'cancelled_by_client\\') THEN 1 ELSE 0 END) / COUNT(*),2) as \\'Cancellation Rate\\'\\nFROM Trips_new t JOIN Users_new u1 ON t.client_id =u1.users_id\\nJOIN Users_new u2 ON t.driver_id = u2.users_id\\nGROUP BY 1\\nORDER BY 1 ASC\\n\\'\\'\\'"
                    },
                    {
                        "username": "bbwxnl",
                        "content": "WITH c AS (SELECT status,a.request_at\\nFROM Trips AS a\\nJOIN Users AS b1\\nON a.client_id= b1.users_id AND b1.role=\\'client\\'\\nJOIN Users AS b2\\nON a.driver_id=b2.users_id AND b2.role=\\'driver\\'\\nWHERE (a.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\') AND (b1.banned=\\'No\\' AND b2.banned=\\'No\\')),\\n\\nd AS (SELECT request_at, COUNT(*) AS num\\nFROM c\\nGROUP BY c.request_at),\\n\\ne AS (SELECT request_at, Sum(case when status  like \\'can%\\' then 1 else 0 end )AS cancel\\nFROM c\\n\\nGROUP BY c.request_at)\\n\\nSELECT d.request_at AS Day,ROUND(e.cancel/d.num,2) AS \\'Cancellation Rate\\'\\nFROM d\\njoin e\\nON d.request_at=e.request_at\\nGROUP BY d.request_at\\nORDER BY d.request_at"
                    },
                    {
                        "username": "vinerdekel",
                        "content": "the input : {\"headers\": {\"Trips\": [\"id\", \"client_id\", \"driver_id\", \"city_id\", \"status\", \"request_at\"], \"Users\": [\"users_id\", \"banned\", \"role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"cancelled_by_client\", \"2013-10-04\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"10\", \"No\", \"driver\"]]}}\\n\\nthe expected output: {\"headers\":[\"Day\",\"Cancellation Rate\"],\"values\":[]}\\n\\nthere was 1 trip, the client id is 1, the driver id is 10 both are not banned. the trips contain 1 order which was cancelled so the cancellation rate should be 1.00 right?"
                    },
                    {
                        "username": "hwynn52",
                        "content": "WITH unbanned as(\\nSELECT users_id\\nFROM Users\\nWHERE banned = \\'No\\'),\\ncancelled as(\\nSELECT t.request_at, COUNT(t.id) as cancelled\\nFROM Trips t\\nWHERE t.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nand t.client_id IN (SELECT * FROM unbanned)\\nand t.driver_id IN (SELECT * FROM unbanned)\\nand (t.status = \\'cancelled_by_driver\\' or t.status = \\'cancelled_by_client\\')\\nGROUP BY t.request_at)\\n\\nSELECT sub1.request_at as \"Day\",  ROUND(IFNULL(c.cancelled,0)/sub1.total,2) as \"Cancellation Rate\"\\nFROM\\n(SELECT t1.request_at, COUNT(t1.id) as total\\nFROM Trips t1\\nWHERE t1.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nand t1.client_id IN (SELECT * FROM unbanned)\\nand t1.driver_id IN (SELECT * FROM unbanned)\\nGROUP BY t1.request_at) sub1\\nLEFT JOIN cancelled c \\nON sub1.request_at = c.request_at"
                    }
                ]
            },
            {
                "id": 1576304,
                "content": [
                    {
                        "username": "rdoddaia",
                        "content": "I am having a hard time trying to understand the meaning of the question. \\nCancellation Rate (of a particular day) = (no. of cancelled trips / total no. of trips on that day)??\\n\\nIf so, on the 1st of the month, out of 4 trips, 2 were cancelled by unbanned users (client or driver). So isn\\'t it 2/4 = 0.5?"
                    },
                    {
                        "username": "Turgay1975",
                        "content": "The client which has an user_id of \\'2\\' is a banned client. So we have to exclude this client from the calculation. "
                    },
                    {
                        "username": "ajaygartia",
                        "content": "Why the test case is failing for below solution/\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | Yes    | driver |\\n\\nExpected output\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\n\\nWITH CTE  as(\\nselect t.request_at request_day,count(status) as total ,sum(case when status like \\'cancelled%\\' then 1 else 0 end) cancelled  from trips t join users u\\non t.client_id=u.users_id \\nwhere u.banned in (\\'No\\')  group by t.request_at)\\nselect cte.request_day \"Day\", ROUND((cte.cancelled *1.0 / cte.total),2,1)  as  \"Cancellation Rate\"  from cte\\nwhere cte.request_day BETWEEN \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "feelingfine",
                        "content": "stuck on same test case i.e. 11/12 \\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\n\\nhow to return empty record in group by clause if record is 0?"
                    },
                    {
                        "username": "azeemj",
                        "content": "Mysql:\nI appreciate to review from u guys ,because Mysql does not support a filed name with space eg: Cancellation Rate\n\nselect CAST(coalesce(b.uncompleted_total/a.total,0) AS DECIMAL(6,2)) As Cancellation_Rate,\n a.request_at\n\nfrom(\n                select count(t.id) as total, t.request_at\n                from Trips t\n                inner join Users u on t.driver_id = u.users_id\n                where u.banned = 'No'\n                group by t.request_at\n\n) a\n\nleft join\n (\n                select  count(t.id) as uncompleted_total, t.request_at\n\n                from Trips t\n                inner join Users u on t.driver_id = u.users_id\n                where u.banned = 'No' and status !='completed'\n                group by t.request_at\n )b\n  on a.request_at = b.request_at\n\n\n\n"
                    },
                    {
                        "username": "Darn1t",
                        "content": "You can do: As \\'Cancellation Rate\\'"
                    },
                    {
                        "username": "jrggerz",
                        "content": "Test cases are WRONG \\nTEST CASE 9 : \\nTrips =\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nTEST CASE 11: \\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\n!SAME FUCKING TEST CASE AND DIFERENT SOLUTION! CANT BELIEVE THAT!"
                    },
                    {
                        "username": "pasha063",
                        "content": "Look closely on dates"
                    },
                    {
                        "username": "jsdeluca",
                        "content": "why does this not work (Oracle) - I am getting runtime error:\\n\\nwith request_data\\nas\\n(\\nselect t.request_at as \"day\", \\n    count(case when t.status != \\'completed\\' then t.status else null end) as cancels,\\n    count(*) as tot\\nfrom    trips t,\\n        users ud,\\n        users uc\\nwhere t.client_id = uc.users_id\\n    and t.driver_id = ud.users_id\\n    and ud.banned = \\'No\\'\\n    and uc.banned = \\'No\\'\\n    and t.request_at between \\n            to_date(\\'2013-10-01\\', \\'yyyy-mm-dd\\')  \\n            and to_date(\\'2013-10-03\\', \\'yyyy-mm-dd\\')\\ngroup by t.request_at\\n)\\nselect day, round(cancels/tot, 2) as \"Cancellation Rate\"\\nfrom request_data"
                    },
                    {
                        "username": "summiyakhalid",
                        "content": "\\nSELECT \\nREQUEST_AT AS Day, \\nROUND(AVG(CASE WHEN status IN (\\'cancelled_by_driver\\', \\'cancelled_by_client\\') THEN 1 ELSE 0 END),2) AS \"Cancellation Rate\"\\nFROM Trips k1\\nINNER JOIN Users k2\\non k1.driver_id = k2.users_id\\nAND k2.banned <> \\'Yes\\'\\nINNER JOIN Users k3\\non k1.client_id = k3.users_id\\nAND k3.banned <> \\'Yes\\'\\nWHERE \\nK1.REQUEST_AT >= \\'2013-10-01\\' and K1.REQUEST_AT<=\\'2013-10-03\\'\\nGROUP BY 1"
                    },
                    {
                        "username": "rickyjnathan",
                        "content": "\\'\\'\\'WITH Users_new AS (\\nSELECT * FROM Users\\nWHERE banned=\\'No\\'),\\nTrips_new AS (\\nSELECT * FROM Trips\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\nSELECT t.request_at as \\'Day\\',\\nROUND(SUM(CASE WHEN (status=\\'cancelled_by_driver\\' OR status=\\'cancelled_by_client\\') THEN 1 ELSE 0 END) / COUNT(*),2) as \\'Cancellation Rate\\'\\nFROM Trips_new t JOIN Users_new u1 ON t.client_id =u1.users_id\\nJOIN Users_new u2 ON t.driver_id = u2.users_id\\nGROUP BY 1\\nORDER BY 1 ASC\\n\\'\\'\\'"
                    },
                    {
                        "username": "bbwxnl",
                        "content": "WITH c AS (SELECT status,a.request_at\\nFROM Trips AS a\\nJOIN Users AS b1\\nON a.client_id= b1.users_id AND b1.role=\\'client\\'\\nJOIN Users AS b2\\nON a.driver_id=b2.users_id AND b2.role=\\'driver\\'\\nWHERE (a.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\') AND (b1.banned=\\'No\\' AND b2.banned=\\'No\\')),\\n\\nd AS (SELECT request_at, COUNT(*) AS num\\nFROM c\\nGROUP BY c.request_at),\\n\\ne AS (SELECT request_at, Sum(case when status  like \\'can%\\' then 1 else 0 end )AS cancel\\nFROM c\\n\\nGROUP BY c.request_at)\\n\\nSELECT d.request_at AS Day,ROUND(e.cancel/d.num,2) AS \\'Cancellation Rate\\'\\nFROM d\\njoin e\\nON d.request_at=e.request_at\\nGROUP BY d.request_at\\nORDER BY d.request_at"
                    },
                    {
                        "username": "vinerdekel",
                        "content": "the input : {\"headers\": {\"Trips\": [\"id\", \"client_id\", \"driver_id\", \"city_id\", \"status\", \"request_at\"], \"Users\": [\"users_id\", \"banned\", \"role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"cancelled_by_client\", \"2013-10-04\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"10\", \"No\", \"driver\"]]}}\\n\\nthe expected output: {\"headers\":[\"Day\",\"Cancellation Rate\"],\"values\":[]}\\n\\nthere was 1 trip, the client id is 1, the driver id is 10 both are not banned. the trips contain 1 order which was cancelled so the cancellation rate should be 1.00 right?"
                    },
                    {
                        "username": "hwynn52",
                        "content": "WITH unbanned as(\\nSELECT users_id\\nFROM Users\\nWHERE banned = \\'No\\'),\\ncancelled as(\\nSELECT t.request_at, COUNT(t.id) as cancelled\\nFROM Trips t\\nWHERE t.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nand t.client_id IN (SELECT * FROM unbanned)\\nand t.driver_id IN (SELECT * FROM unbanned)\\nand (t.status = \\'cancelled_by_driver\\' or t.status = \\'cancelled_by_client\\')\\nGROUP BY t.request_at)\\n\\nSELECT sub1.request_at as \"Day\",  ROUND(IFNULL(c.cancelled,0)/sub1.total,2) as \"Cancellation Rate\"\\nFROM\\n(SELECT t1.request_at, COUNT(t1.id) as total\\nFROM Trips t1\\nWHERE t1.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nand t1.client_id IN (SELECT * FROM unbanned)\\nand t1.driver_id IN (SELECT * FROM unbanned)\\nGROUP BY t1.request_at) sub1\\nLEFT JOIN cancelled c \\nON sub1.request_at = c.request_at"
                    }
                ]
            },
            {
                "id": 1576175,
                "content": [
                    {
                        "username": "rdoddaia",
                        "content": "I am having a hard time trying to understand the meaning of the question. \\nCancellation Rate (of a particular day) = (no. of cancelled trips / total no. of trips on that day)??\\n\\nIf so, on the 1st of the month, out of 4 trips, 2 were cancelled by unbanned users (client or driver). So isn\\'t it 2/4 = 0.5?"
                    },
                    {
                        "username": "Turgay1975",
                        "content": "The client which has an user_id of \\'2\\' is a banned client. So we have to exclude this client from the calculation. "
                    },
                    {
                        "username": "ajaygartia",
                        "content": "Why the test case is failing for below solution/\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | Yes    | driver |\\n\\nExpected output\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\n\\nWITH CTE  as(\\nselect t.request_at request_day,count(status) as total ,sum(case when status like \\'cancelled%\\' then 1 else 0 end) cancelled  from trips t join users u\\non t.client_id=u.users_id \\nwhere u.banned in (\\'No\\')  group by t.request_at)\\nselect cte.request_day \"Day\", ROUND((cte.cancelled *1.0 / cte.total),2,1)  as  \"Cancellation Rate\"  from cte\\nwhere cte.request_day BETWEEN \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "feelingfine",
                        "content": "stuck on same test case i.e. 11/12 \\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\n\\nhow to return empty record in group by clause if record is 0?"
                    },
                    {
                        "username": "azeemj",
                        "content": "Mysql:\nI appreciate to review from u guys ,because Mysql does not support a filed name with space eg: Cancellation Rate\n\nselect CAST(coalesce(b.uncompleted_total/a.total,0) AS DECIMAL(6,2)) As Cancellation_Rate,\n a.request_at\n\nfrom(\n                select count(t.id) as total, t.request_at\n                from Trips t\n                inner join Users u on t.driver_id = u.users_id\n                where u.banned = 'No'\n                group by t.request_at\n\n) a\n\nleft join\n (\n                select  count(t.id) as uncompleted_total, t.request_at\n\n                from Trips t\n                inner join Users u on t.driver_id = u.users_id\n                where u.banned = 'No' and status !='completed'\n                group by t.request_at\n )b\n  on a.request_at = b.request_at\n\n\n\n"
                    },
                    {
                        "username": "Darn1t",
                        "content": "You can do: As \\'Cancellation Rate\\'"
                    },
                    {
                        "username": "jrggerz",
                        "content": "Test cases are WRONG \\nTEST CASE 9 : \\nTrips =\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nTEST CASE 11: \\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\n!SAME FUCKING TEST CASE AND DIFERENT SOLUTION! CANT BELIEVE THAT!"
                    },
                    {
                        "username": "pasha063",
                        "content": "Look closely on dates"
                    },
                    {
                        "username": "jsdeluca",
                        "content": "why does this not work (Oracle) - I am getting runtime error:\\n\\nwith request_data\\nas\\n(\\nselect t.request_at as \"day\", \\n    count(case when t.status != \\'completed\\' then t.status else null end) as cancels,\\n    count(*) as tot\\nfrom    trips t,\\n        users ud,\\n        users uc\\nwhere t.client_id = uc.users_id\\n    and t.driver_id = ud.users_id\\n    and ud.banned = \\'No\\'\\n    and uc.banned = \\'No\\'\\n    and t.request_at between \\n            to_date(\\'2013-10-01\\', \\'yyyy-mm-dd\\')  \\n            and to_date(\\'2013-10-03\\', \\'yyyy-mm-dd\\')\\ngroup by t.request_at\\n)\\nselect day, round(cancels/tot, 2) as \"Cancellation Rate\"\\nfrom request_data"
                    },
                    {
                        "username": "summiyakhalid",
                        "content": "\\nSELECT \\nREQUEST_AT AS Day, \\nROUND(AVG(CASE WHEN status IN (\\'cancelled_by_driver\\', \\'cancelled_by_client\\') THEN 1 ELSE 0 END),2) AS \"Cancellation Rate\"\\nFROM Trips k1\\nINNER JOIN Users k2\\non k1.driver_id = k2.users_id\\nAND k2.banned <> \\'Yes\\'\\nINNER JOIN Users k3\\non k1.client_id = k3.users_id\\nAND k3.banned <> \\'Yes\\'\\nWHERE \\nK1.REQUEST_AT >= \\'2013-10-01\\' and K1.REQUEST_AT<=\\'2013-10-03\\'\\nGROUP BY 1"
                    },
                    {
                        "username": "rickyjnathan",
                        "content": "\\'\\'\\'WITH Users_new AS (\\nSELECT * FROM Users\\nWHERE banned=\\'No\\'),\\nTrips_new AS (\\nSELECT * FROM Trips\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\nSELECT t.request_at as \\'Day\\',\\nROUND(SUM(CASE WHEN (status=\\'cancelled_by_driver\\' OR status=\\'cancelled_by_client\\') THEN 1 ELSE 0 END) / COUNT(*),2) as \\'Cancellation Rate\\'\\nFROM Trips_new t JOIN Users_new u1 ON t.client_id =u1.users_id\\nJOIN Users_new u2 ON t.driver_id = u2.users_id\\nGROUP BY 1\\nORDER BY 1 ASC\\n\\'\\'\\'"
                    },
                    {
                        "username": "bbwxnl",
                        "content": "WITH c AS (SELECT status,a.request_at\\nFROM Trips AS a\\nJOIN Users AS b1\\nON a.client_id= b1.users_id AND b1.role=\\'client\\'\\nJOIN Users AS b2\\nON a.driver_id=b2.users_id AND b2.role=\\'driver\\'\\nWHERE (a.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\') AND (b1.banned=\\'No\\' AND b2.banned=\\'No\\')),\\n\\nd AS (SELECT request_at, COUNT(*) AS num\\nFROM c\\nGROUP BY c.request_at),\\n\\ne AS (SELECT request_at, Sum(case when status  like \\'can%\\' then 1 else 0 end )AS cancel\\nFROM c\\n\\nGROUP BY c.request_at)\\n\\nSELECT d.request_at AS Day,ROUND(e.cancel/d.num,2) AS \\'Cancellation Rate\\'\\nFROM d\\njoin e\\nON d.request_at=e.request_at\\nGROUP BY d.request_at\\nORDER BY d.request_at"
                    },
                    {
                        "username": "vinerdekel",
                        "content": "the input : {\"headers\": {\"Trips\": [\"id\", \"client_id\", \"driver_id\", \"city_id\", \"status\", \"request_at\"], \"Users\": [\"users_id\", \"banned\", \"role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"cancelled_by_client\", \"2013-10-04\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"10\", \"No\", \"driver\"]]}}\\n\\nthe expected output: {\"headers\":[\"Day\",\"Cancellation Rate\"],\"values\":[]}\\n\\nthere was 1 trip, the client id is 1, the driver id is 10 both are not banned. the trips contain 1 order which was cancelled so the cancellation rate should be 1.00 right?"
                    },
                    {
                        "username": "hwynn52",
                        "content": "WITH unbanned as(\\nSELECT users_id\\nFROM Users\\nWHERE banned = \\'No\\'),\\ncancelled as(\\nSELECT t.request_at, COUNT(t.id) as cancelled\\nFROM Trips t\\nWHERE t.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nand t.client_id IN (SELECT * FROM unbanned)\\nand t.driver_id IN (SELECT * FROM unbanned)\\nand (t.status = \\'cancelled_by_driver\\' or t.status = \\'cancelled_by_client\\')\\nGROUP BY t.request_at)\\n\\nSELECT sub1.request_at as \"Day\",  ROUND(IFNULL(c.cancelled,0)/sub1.total,2) as \"Cancellation Rate\"\\nFROM\\n(SELECT t1.request_at, COUNT(t1.id) as total\\nFROM Trips t1\\nWHERE t1.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nand t1.client_id IN (SELECT * FROM unbanned)\\nand t1.driver_id IN (SELECT * FROM unbanned)\\nGROUP BY t1.request_at) sub1\\nLEFT JOIN cancelled c \\nON sub1.request_at = c.request_at"
                    }
                ]
            },
            {
                "id": 1576069,
                "content": [
                    {
                        "username": "rdoddaia",
                        "content": "I am having a hard time trying to understand the meaning of the question. \\nCancellation Rate (of a particular day) = (no. of cancelled trips / total no. of trips on that day)??\\n\\nIf so, on the 1st of the month, out of 4 trips, 2 were cancelled by unbanned users (client or driver). So isn\\'t it 2/4 = 0.5?"
                    },
                    {
                        "username": "Turgay1975",
                        "content": "The client which has an user_id of \\'2\\' is a banned client. So we have to exclude this client from the calculation. "
                    },
                    {
                        "username": "ajaygartia",
                        "content": "Why the test case is failing for below solution/\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | Yes    | driver |\\n\\nExpected output\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\n\\nWITH CTE  as(\\nselect t.request_at request_day,count(status) as total ,sum(case when status like \\'cancelled%\\' then 1 else 0 end) cancelled  from trips t join users u\\non t.client_id=u.users_id \\nwhere u.banned in (\\'No\\')  group by t.request_at)\\nselect cte.request_day \"Day\", ROUND((cte.cancelled *1.0 / cte.total),2,1)  as  \"Cancellation Rate\"  from cte\\nwhere cte.request_day BETWEEN \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "feelingfine",
                        "content": "stuck on same test case i.e. 11/12 \\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\n\\nhow to return empty record in group by clause if record is 0?"
                    },
                    {
                        "username": "azeemj",
                        "content": "Mysql:\nI appreciate to review from u guys ,because Mysql does not support a filed name with space eg: Cancellation Rate\n\nselect CAST(coalesce(b.uncompleted_total/a.total,0) AS DECIMAL(6,2)) As Cancellation_Rate,\n a.request_at\n\nfrom(\n                select count(t.id) as total, t.request_at\n                from Trips t\n                inner join Users u on t.driver_id = u.users_id\n                where u.banned = 'No'\n                group by t.request_at\n\n) a\n\nleft join\n (\n                select  count(t.id) as uncompleted_total, t.request_at\n\n                from Trips t\n                inner join Users u on t.driver_id = u.users_id\n                where u.banned = 'No' and status !='completed'\n                group by t.request_at\n )b\n  on a.request_at = b.request_at\n\n\n\n"
                    },
                    {
                        "username": "Darn1t",
                        "content": "You can do: As \\'Cancellation Rate\\'"
                    },
                    {
                        "username": "jrggerz",
                        "content": "Test cases are WRONG \\nTEST CASE 9 : \\nTrips =\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nTEST CASE 11: \\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\n!SAME FUCKING TEST CASE AND DIFERENT SOLUTION! CANT BELIEVE THAT!"
                    },
                    {
                        "username": "pasha063",
                        "content": "Look closely on dates"
                    },
                    {
                        "username": "jsdeluca",
                        "content": "why does this not work (Oracle) - I am getting runtime error:\\n\\nwith request_data\\nas\\n(\\nselect t.request_at as \"day\", \\n    count(case when t.status != \\'completed\\' then t.status else null end) as cancels,\\n    count(*) as tot\\nfrom    trips t,\\n        users ud,\\n        users uc\\nwhere t.client_id = uc.users_id\\n    and t.driver_id = ud.users_id\\n    and ud.banned = \\'No\\'\\n    and uc.banned = \\'No\\'\\n    and t.request_at between \\n            to_date(\\'2013-10-01\\', \\'yyyy-mm-dd\\')  \\n            and to_date(\\'2013-10-03\\', \\'yyyy-mm-dd\\')\\ngroup by t.request_at\\n)\\nselect day, round(cancels/tot, 2) as \"Cancellation Rate\"\\nfrom request_data"
                    },
                    {
                        "username": "summiyakhalid",
                        "content": "\\nSELECT \\nREQUEST_AT AS Day, \\nROUND(AVG(CASE WHEN status IN (\\'cancelled_by_driver\\', \\'cancelled_by_client\\') THEN 1 ELSE 0 END),2) AS \"Cancellation Rate\"\\nFROM Trips k1\\nINNER JOIN Users k2\\non k1.driver_id = k2.users_id\\nAND k2.banned <> \\'Yes\\'\\nINNER JOIN Users k3\\non k1.client_id = k3.users_id\\nAND k3.banned <> \\'Yes\\'\\nWHERE \\nK1.REQUEST_AT >= \\'2013-10-01\\' and K1.REQUEST_AT<=\\'2013-10-03\\'\\nGROUP BY 1"
                    },
                    {
                        "username": "rickyjnathan",
                        "content": "\\'\\'\\'WITH Users_new AS (\\nSELECT * FROM Users\\nWHERE banned=\\'No\\'),\\nTrips_new AS (\\nSELECT * FROM Trips\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\nSELECT t.request_at as \\'Day\\',\\nROUND(SUM(CASE WHEN (status=\\'cancelled_by_driver\\' OR status=\\'cancelled_by_client\\') THEN 1 ELSE 0 END) / COUNT(*),2) as \\'Cancellation Rate\\'\\nFROM Trips_new t JOIN Users_new u1 ON t.client_id =u1.users_id\\nJOIN Users_new u2 ON t.driver_id = u2.users_id\\nGROUP BY 1\\nORDER BY 1 ASC\\n\\'\\'\\'"
                    },
                    {
                        "username": "bbwxnl",
                        "content": "WITH c AS (SELECT status,a.request_at\\nFROM Trips AS a\\nJOIN Users AS b1\\nON a.client_id= b1.users_id AND b1.role=\\'client\\'\\nJOIN Users AS b2\\nON a.driver_id=b2.users_id AND b2.role=\\'driver\\'\\nWHERE (a.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\') AND (b1.banned=\\'No\\' AND b2.banned=\\'No\\')),\\n\\nd AS (SELECT request_at, COUNT(*) AS num\\nFROM c\\nGROUP BY c.request_at),\\n\\ne AS (SELECT request_at, Sum(case when status  like \\'can%\\' then 1 else 0 end )AS cancel\\nFROM c\\n\\nGROUP BY c.request_at)\\n\\nSELECT d.request_at AS Day,ROUND(e.cancel/d.num,2) AS \\'Cancellation Rate\\'\\nFROM d\\njoin e\\nON d.request_at=e.request_at\\nGROUP BY d.request_at\\nORDER BY d.request_at"
                    },
                    {
                        "username": "vinerdekel",
                        "content": "the input : {\"headers\": {\"Trips\": [\"id\", \"client_id\", \"driver_id\", \"city_id\", \"status\", \"request_at\"], \"Users\": [\"users_id\", \"banned\", \"role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"cancelled_by_client\", \"2013-10-04\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"10\", \"No\", \"driver\"]]}}\\n\\nthe expected output: {\"headers\":[\"Day\",\"Cancellation Rate\"],\"values\":[]}\\n\\nthere was 1 trip, the client id is 1, the driver id is 10 both are not banned. the trips contain 1 order which was cancelled so the cancellation rate should be 1.00 right?"
                    },
                    {
                        "username": "hwynn52",
                        "content": "WITH unbanned as(\\nSELECT users_id\\nFROM Users\\nWHERE banned = \\'No\\'),\\ncancelled as(\\nSELECT t.request_at, COUNT(t.id) as cancelled\\nFROM Trips t\\nWHERE t.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nand t.client_id IN (SELECT * FROM unbanned)\\nand t.driver_id IN (SELECT * FROM unbanned)\\nand (t.status = \\'cancelled_by_driver\\' or t.status = \\'cancelled_by_client\\')\\nGROUP BY t.request_at)\\n\\nSELECT sub1.request_at as \"Day\",  ROUND(IFNULL(c.cancelled,0)/sub1.total,2) as \"Cancellation Rate\"\\nFROM\\n(SELECT t1.request_at, COUNT(t1.id) as total\\nFROM Trips t1\\nWHERE t1.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nand t1.client_id IN (SELECT * FROM unbanned)\\nand t1.driver_id IN (SELECT * FROM unbanned)\\nGROUP BY t1.request_at) sub1\\nLEFT JOIN cancelled c \\nON sub1.request_at = c.request_at"
                    }
                ]
            },
            {
                "id": 1576057,
                "content": [
                    {
                        "username": "rdoddaia",
                        "content": "I am having a hard time trying to understand the meaning of the question. \\nCancellation Rate (of a particular day) = (no. of cancelled trips / total no. of trips on that day)??\\n\\nIf so, on the 1st of the month, out of 4 trips, 2 were cancelled by unbanned users (client or driver). So isn\\'t it 2/4 = 0.5?"
                    },
                    {
                        "username": "Turgay1975",
                        "content": "The client which has an user_id of \\'2\\' is a banned client. So we have to exclude this client from the calculation. "
                    },
                    {
                        "username": "ajaygartia",
                        "content": "Why the test case is failing for below solution/\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\n\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | Yes    | driver |\\n\\nExpected output\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\n\\nWITH CTE  as(\\nselect t.request_at request_day,count(status) as total ,sum(case when status like \\'cancelled%\\' then 1 else 0 end) cancelled  from trips t join users u\\non t.client_id=u.users_id \\nwhere u.banned in (\\'No\\')  group by t.request_at)\\nselect cte.request_day \"Day\", ROUND((cte.cancelled *1.0 / cte.total),2,1)  as  \"Cancellation Rate\"  from cte\\nwhere cte.request_day BETWEEN \\'2013-10-01\\' and \\'2013-10-03\\'"
                    },
                    {
                        "username": "feelingfine",
                        "content": "stuck on same test case i.e. 11/12 \\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\n\\nhow to return empty record in group by clause if record is 0?"
                    },
                    {
                        "username": "azeemj",
                        "content": "Mysql:\nI appreciate to review from u guys ,because Mysql does not support a filed name with space eg: Cancellation Rate\n\nselect CAST(coalesce(b.uncompleted_total/a.total,0) AS DECIMAL(6,2)) As Cancellation_Rate,\n a.request_at\n\nfrom(\n                select count(t.id) as total, t.request_at\n                from Trips t\n                inner join Users u on t.driver_id = u.users_id\n                where u.banned = 'No'\n                group by t.request_at\n\n) a\n\nleft join\n (\n                select  count(t.id) as uncompleted_total, t.request_at\n\n                from Trips t\n                inner join Users u on t.driver_id = u.users_id\n                where u.banned = 'No' and status !='completed'\n                group by t.request_at\n )b\n  on a.request_at = b.request_at\n\n\n\n"
                    },
                    {
                        "username": "Darn1t",
                        "content": "You can do: As \\'Cancellation Rate\\'"
                    },
                    {
                        "username": "jrggerz",
                        "content": "Test cases are WRONG \\nTEST CASE 9 : \\nTrips =\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\nTEST CASE 11: \\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | No     | driver |\\n\\n!SAME FUCKING TEST CASE AND DIFERENT SOLUTION! CANT BELIEVE THAT!"
                    },
                    {
                        "username": "pasha063",
                        "content": "Look closely on dates"
                    },
                    {
                        "username": "jsdeluca",
                        "content": "why does this not work (Oracle) - I am getting runtime error:\\n\\nwith request_data\\nas\\n(\\nselect t.request_at as \"day\", \\n    count(case when t.status != \\'completed\\' then t.status else null end) as cancels,\\n    count(*) as tot\\nfrom    trips t,\\n        users ud,\\n        users uc\\nwhere t.client_id = uc.users_id\\n    and t.driver_id = ud.users_id\\n    and ud.banned = \\'No\\'\\n    and uc.banned = \\'No\\'\\n    and t.request_at between \\n            to_date(\\'2013-10-01\\', \\'yyyy-mm-dd\\')  \\n            and to_date(\\'2013-10-03\\', \\'yyyy-mm-dd\\')\\ngroup by t.request_at\\n)\\nselect day, round(cancels/tot, 2) as \"Cancellation Rate\"\\nfrom request_data"
                    },
                    {
                        "username": "summiyakhalid",
                        "content": "\\nSELECT \\nREQUEST_AT AS Day, \\nROUND(AVG(CASE WHEN status IN (\\'cancelled_by_driver\\', \\'cancelled_by_client\\') THEN 1 ELSE 0 END),2) AS \"Cancellation Rate\"\\nFROM Trips k1\\nINNER JOIN Users k2\\non k1.driver_id = k2.users_id\\nAND k2.banned <> \\'Yes\\'\\nINNER JOIN Users k3\\non k1.client_id = k3.users_id\\nAND k3.banned <> \\'Yes\\'\\nWHERE \\nK1.REQUEST_AT >= \\'2013-10-01\\' and K1.REQUEST_AT<=\\'2013-10-03\\'\\nGROUP BY 1"
                    },
                    {
                        "username": "rickyjnathan",
                        "content": "\\'\\'\\'WITH Users_new AS (\\nSELECT * FROM Users\\nWHERE banned=\\'No\\'),\\nTrips_new AS (\\nSELECT * FROM Trips\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\nSELECT t.request_at as \\'Day\\',\\nROUND(SUM(CASE WHEN (status=\\'cancelled_by_driver\\' OR status=\\'cancelled_by_client\\') THEN 1 ELSE 0 END) / COUNT(*),2) as \\'Cancellation Rate\\'\\nFROM Trips_new t JOIN Users_new u1 ON t.client_id =u1.users_id\\nJOIN Users_new u2 ON t.driver_id = u2.users_id\\nGROUP BY 1\\nORDER BY 1 ASC\\n\\'\\'\\'"
                    },
                    {
                        "username": "bbwxnl",
                        "content": "WITH c AS (SELECT status,a.request_at\\nFROM Trips AS a\\nJOIN Users AS b1\\nON a.client_id= b1.users_id AND b1.role=\\'client\\'\\nJOIN Users AS b2\\nON a.driver_id=b2.users_id AND b2.role=\\'driver\\'\\nWHERE (a.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\') AND (b1.banned=\\'No\\' AND b2.banned=\\'No\\')),\\n\\nd AS (SELECT request_at, COUNT(*) AS num\\nFROM c\\nGROUP BY c.request_at),\\n\\ne AS (SELECT request_at, Sum(case when status  like \\'can%\\' then 1 else 0 end )AS cancel\\nFROM c\\n\\nGROUP BY c.request_at)\\n\\nSELECT d.request_at AS Day,ROUND(e.cancel/d.num,2) AS \\'Cancellation Rate\\'\\nFROM d\\njoin e\\nON d.request_at=e.request_at\\nGROUP BY d.request_at\\nORDER BY d.request_at"
                    },
                    {
                        "username": "vinerdekel",
                        "content": "the input : {\"headers\": {\"Trips\": [\"id\", \"client_id\", \"driver_id\", \"city_id\", \"status\", \"request_at\"], \"Users\": [\"users_id\", \"banned\", \"role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"cancelled_by_client\", \"2013-10-04\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"10\", \"No\", \"driver\"]]}}\\n\\nthe expected output: {\"headers\":[\"Day\",\"Cancellation Rate\"],\"values\":[]}\\n\\nthere was 1 trip, the client id is 1, the driver id is 10 both are not banned. the trips contain 1 order which was cancelled so the cancellation rate should be 1.00 right?"
                    },
                    {
                        "username": "hwynn52",
                        "content": "WITH unbanned as(\\nSELECT users_id\\nFROM Users\\nWHERE banned = \\'No\\'),\\ncancelled as(\\nSELECT t.request_at, COUNT(t.id) as cancelled\\nFROM Trips t\\nWHERE t.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nand t.client_id IN (SELECT * FROM unbanned)\\nand t.driver_id IN (SELECT * FROM unbanned)\\nand (t.status = \\'cancelled_by_driver\\' or t.status = \\'cancelled_by_client\\')\\nGROUP BY t.request_at)\\n\\nSELECT sub1.request_at as \"Day\",  ROUND(IFNULL(c.cancelled,0)/sub1.total,2) as \"Cancellation Rate\"\\nFROM\\n(SELECT t1.request_at, COUNT(t1.id) as total\\nFROM Trips t1\\nWHERE t1.request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\\nand t1.client_id IN (SELECT * FROM unbanned)\\nand t1.driver_id IN (SELECT * FROM unbanned)\\nGROUP BY t1.request_at) sub1\\nLEFT JOIN cancelled c \\nON sub1.request_at = c.request_at"
                    }
                ]
            },
            {
                "id": 1576020,
                "content": [
                    {
                        "username": "saini5259",
                        "content": "with main as\\n(\\nselect request_at, count(1) tot_req, \\nsum(case when status like \\'cancelled%\\' then 1 else 0 end) can_req \\nfrom trips\\nwhere client_id not in ( select users_id from users where banned = \\'Yes\\' and role = \\'client\\')\\nand driver_id not in ( select users_id from users where banned = \\'Yes\\' and role = \\'driver\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n)\\nselect request_at day, coalesce(round(can_req/tot_req,2),0) \"Cancellation Rate\"\\nfrom main"
                    },
                    {
                        "username": "mudit_sriv",
                        "content": "\\nWITH temp AS\\n(\\nSELECT request_at, status\\nFROM\\nTrips\\nJOIN\\nUsers AS client_users\\nON Trips.client_id = client_users.users_id\\nJOIN\\nUsers AS driver_users\\nON Trips.driver_id = driver_users.users_id\\nWHERE client_users.banned = \\'No\\'\\nAND driver_users.banned = \\'No\\'\\nAND Trips.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    )\\n\\nSELECT Total.request_at AS Day, ROUND(IFNULL(cancel.c1,0)/IFNULL(Total.c2,1),2) AS \\'Cancellation Rate\\'\\nFROM\\n(SELECT request_at,count(*) AS c1\\nFROM temp\\nWHERE status IN (\"cancelled_by_driver\",\"cancelled_by_client\")\\nGROUP BY request_at) AS cancel\\nRIGHT JOIN\\n(SELECT request_at,count(*) AS c2\\nFROM temp\\nGROUP BY request_at) AS Total\\nUSING (request_at);"
                    },
                    {
                        "username": "chinmay7430",
                        "content": "![image](https://assets.leetcode.com/users/images/1786a0cc-291c-4882-aa19-ef14c22bc880_1626253111.9529912.png)\\n\\nThe expected values have five digits after the decimal, which is not correct according to the question.\\nCan someone please confirm this?\\nAm I missing something?"
                    },
                    {
                        "username": "user1864O",
                        "content": ";with temp as(\\nSELECT request_At,\\nsum(case when status like \\'cancelled%\\' then 1 else 0 end) cancelled_cnt,count(id) as total_cnt\\nFROM Trips1 t\\nwhere Client_Id NOT IN (SELECT Users_Id from Users1 where Banned = \\'Yes\\')\\nAND Driver_Id NOT IN (SELECT Users_Id from Users1 where Banned = \\'Yes\\')\\nAND Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n)\\nselect request_at as [Day],\\nCAST(CAST(cancelled_cnt as float)/cast(total_cnt as float) AS DECIMAL(10,2)) as [Cancellation Rate]\\nfrom temp"
                    },
                    {
                        "username": "sowei",
                        "content": "with unbanned as (select users_id from users where banned=\\'no\\')\\n\\nselect request_at as day,round(avg(case when status=\\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\' from trips t \\nwhere t.client_id in (select * from unbanned) and t.driver_id in (select * from unbanned)\\nand request_at>=\\'2013-10-01\\' and request_at<=\\'2013-10-03\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "geyungjen",
                        "content": "\\'\\'\\'\\nwith x as (select request_at as Day, case when Status like \\'cancelled%\\' then 1 else 0 end cancelled \\nfrom trips where client_id in (select users_id from users where banned = \\'No\\') \\nand driver_id in (select users_id from users where banned = \\'No\\'))\\nselect Day, round(sum(cancelled)/count(*),2) \"Cancellation Rate\" from x\\nwhere Day between \\'2013-10-01\\' and \\'2013-10-03\\' group by 1;\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "510939517",
                        "content": "\\'\\'\\'\\nwith clientstep as\\n(select Id, Client_id, Driver_id, status, request_at, Banned as clientstatus from Trips left join Users on Client_id=users_id where banned=\\'No\\')\\n, bothstep as\\n(select Id, Client_id, Driver_id, status, request_at, clientstatus, banned as driverstatus from clientstep left join Users on driver_id=users_id where banned=\\'No\\')\\nselect request_at as Day, round(count((case when status=\\'cancelled_by_driver\\' or status=\\'cancelled_by_client \\' then 1 else null end) )/count(status),2) as \\'Cancellation Rate\\' from bothstep\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n\\'\\'\\'"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT tb1.Request_at AS Day, ROUND(SUM(CASE WHEN tb1.Status = \\'completed\\' THEN 0\\n                                     ELSE 1\\n                                     END) / COUNT(*), 2) AS \\'Cancellation Rate\\'\\nFROM Trips AS tb1\\nINNER JOIN Users AS tb2\\nON tb1.Client_Id = tb2.Users_Id AND tb2.Banned =\\'No\\'\\nINNER JOIN Users As tb3\\nON tb1.Driver_Id = tb3.Users_Id AND tb3.Banned = \\'No\\'\\nWHERE tb1.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY tb1.Request_at\\nORDER BY Day;\\n\\n\\n\\n\\n#Cancel trips/ total  # of trips\\n\\n#ROUND(SUM(CASE WHEN tb1.Status = \\'completed\\' THEN 0\\n#ELSE 1\\n#END) / COUNT(*), 2)\\n"
                    },
                    {
                        "username": "wangqi688",
                        "content": "# Write your MySQL query statement below\\nselect request_at as Day,\\nround(sum(case when status = \\'cancelled_by_driver\\' then 1 \\n    when status=\\'cancelled_by_client\\' then 1 else 0 end)/count(*),2) as  \\'Cancellation Rate\\'\\nfrom trips\\nwhere request_at between \"2013-10-01\" and \"2013-10-03\" and\\nclient_id not in (select users_id from users where banned = \\'Yes\\') and\\ndriver_id not in (select users_id from users where banned = \\'Yes\\') \\ngroup by request_at"
                    },
                    {
                        "username": "aotian0398",
                        "content": "input :\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"cancelled_by_client\", \"2013-10-04\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"10\", \"No\", \"driver\"]]}}\\n\\ncanceled number=1\\n,total number=1 \\ncanceRate=1/1=1, \\nbut the test case is empty....................\\n\\n"
                    }
                ]
            },
            {
                "id": 1575930,
                "content": [
                    {
                        "username": "saini5259",
                        "content": "with main as\\n(\\nselect request_at, count(1) tot_req, \\nsum(case when status like \\'cancelled%\\' then 1 else 0 end) can_req \\nfrom trips\\nwhere client_id not in ( select users_id from users where banned = \\'Yes\\' and role = \\'client\\')\\nand driver_id not in ( select users_id from users where banned = \\'Yes\\' and role = \\'driver\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n)\\nselect request_at day, coalesce(round(can_req/tot_req,2),0) \"Cancellation Rate\"\\nfrom main"
                    },
                    {
                        "username": "mudit_sriv",
                        "content": "\\nWITH temp AS\\n(\\nSELECT request_at, status\\nFROM\\nTrips\\nJOIN\\nUsers AS client_users\\nON Trips.client_id = client_users.users_id\\nJOIN\\nUsers AS driver_users\\nON Trips.driver_id = driver_users.users_id\\nWHERE client_users.banned = \\'No\\'\\nAND driver_users.banned = \\'No\\'\\nAND Trips.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    )\\n\\nSELECT Total.request_at AS Day, ROUND(IFNULL(cancel.c1,0)/IFNULL(Total.c2,1),2) AS \\'Cancellation Rate\\'\\nFROM\\n(SELECT request_at,count(*) AS c1\\nFROM temp\\nWHERE status IN (\"cancelled_by_driver\",\"cancelled_by_client\")\\nGROUP BY request_at) AS cancel\\nRIGHT JOIN\\n(SELECT request_at,count(*) AS c2\\nFROM temp\\nGROUP BY request_at) AS Total\\nUSING (request_at);"
                    },
                    {
                        "username": "chinmay7430",
                        "content": "![image](https://assets.leetcode.com/users/images/1786a0cc-291c-4882-aa19-ef14c22bc880_1626253111.9529912.png)\\n\\nThe expected values have five digits after the decimal, which is not correct according to the question.\\nCan someone please confirm this?\\nAm I missing something?"
                    },
                    {
                        "username": "user1864O",
                        "content": ";with temp as(\\nSELECT request_At,\\nsum(case when status like \\'cancelled%\\' then 1 else 0 end) cancelled_cnt,count(id) as total_cnt\\nFROM Trips1 t\\nwhere Client_Id NOT IN (SELECT Users_Id from Users1 where Banned = \\'Yes\\')\\nAND Driver_Id NOT IN (SELECT Users_Id from Users1 where Banned = \\'Yes\\')\\nAND Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n)\\nselect request_at as [Day],\\nCAST(CAST(cancelled_cnt as float)/cast(total_cnt as float) AS DECIMAL(10,2)) as [Cancellation Rate]\\nfrom temp"
                    },
                    {
                        "username": "sowei",
                        "content": "with unbanned as (select users_id from users where banned=\\'no\\')\\n\\nselect request_at as day,round(avg(case when status=\\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\' from trips t \\nwhere t.client_id in (select * from unbanned) and t.driver_id in (select * from unbanned)\\nand request_at>=\\'2013-10-01\\' and request_at<=\\'2013-10-03\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "geyungjen",
                        "content": "\\'\\'\\'\\nwith x as (select request_at as Day, case when Status like \\'cancelled%\\' then 1 else 0 end cancelled \\nfrom trips where client_id in (select users_id from users where banned = \\'No\\') \\nand driver_id in (select users_id from users where banned = \\'No\\'))\\nselect Day, round(sum(cancelled)/count(*),2) \"Cancellation Rate\" from x\\nwhere Day between \\'2013-10-01\\' and \\'2013-10-03\\' group by 1;\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "510939517",
                        "content": "\\'\\'\\'\\nwith clientstep as\\n(select Id, Client_id, Driver_id, status, request_at, Banned as clientstatus from Trips left join Users on Client_id=users_id where banned=\\'No\\')\\n, bothstep as\\n(select Id, Client_id, Driver_id, status, request_at, clientstatus, banned as driverstatus from clientstep left join Users on driver_id=users_id where banned=\\'No\\')\\nselect request_at as Day, round(count((case when status=\\'cancelled_by_driver\\' or status=\\'cancelled_by_client \\' then 1 else null end) )/count(status),2) as \\'Cancellation Rate\\' from bothstep\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n\\'\\'\\'"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT tb1.Request_at AS Day, ROUND(SUM(CASE WHEN tb1.Status = \\'completed\\' THEN 0\\n                                     ELSE 1\\n                                     END) / COUNT(*), 2) AS \\'Cancellation Rate\\'\\nFROM Trips AS tb1\\nINNER JOIN Users AS tb2\\nON tb1.Client_Id = tb2.Users_Id AND tb2.Banned =\\'No\\'\\nINNER JOIN Users As tb3\\nON tb1.Driver_Id = tb3.Users_Id AND tb3.Banned = \\'No\\'\\nWHERE tb1.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY tb1.Request_at\\nORDER BY Day;\\n\\n\\n\\n\\n#Cancel trips/ total  # of trips\\n\\n#ROUND(SUM(CASE WHEN tb1.Status = \\'completed\\' THEN 0\\n#ELSE 1\\n#END) / COUNT(*), 2)\\n"
                    },
                    {
                        "username": "wangqi688",
                        "content": "# Write your MySQL query statement below\\nselect request_at as Day,\\nround(sum(case when status = \\'cancelled_by_driver\\' then 1 \\n    when status=\\'cancelled_by_client\\' then 1 else 0 end)/count(*),2) as  \\'Cancellation Rate\\'\\nfrom trips\\nwhere request_at between \"2013-10-01\" and \"2013-10-03\" and\\nclient_id not in (select users_id from users where banned = \\'Yes\\') and\\ndriver_id not in (select users_id from users where banned = \\'Yes\\') \\ngroup by request_at"
                    },
                    {
                        "username": "aotian0398",
                        "content": "input :\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"cancelled_by_client\", \"2013-10-04\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"10\", \"No\", \"driver\"]]}}\\n\\ncanceled number=1\\n,total number=1 \\ncanceRate=1/1=1, \\nbut the test case is empty....................\\n\\n"
                    }
                ]
            },
            {
                "id": 1575534,
                "content": [
                    {
                        "username": "saini5259",
                        "content": "with main as\\n(\\nselect request_at, count(1) tot_req, \\nsum(case when status like \\'cancelled%\\' then 1 else 0 end) can_req \\nfrom trips\\nwhere client_id not in ( select users_id from users where banned = \\'Yes\\' and role = \\'client\\')\\nand driver_id not in ( select users_id from users where banned = \\'Yes\\' and role = \\'driver\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n)\\nselect request_at day, coalesce(round(can_req/tot_req,2),0) \"Cancellation Rate\"\\nfrom main"
                    },
                    {
                        "username": "mudit_sriv",
                        "content": "\\nWITH temp AS\\n(\\nSELECT request_at, status\\nFROM\\nTrips\\nJOIN\\nUsers AS client_users\\nON Trips.client_id = client_users.users_id\\nJOIN\\nUsers AS driver_users\\nON Trips.driver_id = driver_users.users_id\\nWHERE client_users.banned = \\'No\\'\\nAND driver_users.banned = \\'No\\'\\nAND Trips.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    )\\n\\nSELECT Total.request_at AS Day, ROUND(IFNULL(cancel.c1,0)/IFNULL(Total.c2,1),2) AS \\'Cancellation Rate\\'\\nFROM\\n(SELECT request_at,count(*) AS c1\\nFROM temp\\nWHERE status IN (\"cancelled_by_driver\",\"cancelled_by_client\")\\nGROUP BY request_at) AS cancel\\nRIGHT JOIN\\n(SELECT request_at,count(*) AS c2\\nFROM temp\\nGROUP BY request_at) AS Total\\nUSING (request_at);"
                    },
                    {
                        "username": "chinmay7430",
                        "content": "![image](https://assets.leetcode.com/users/images/1786a0cc-291c-4882-aa19-ef14c22bc880_1626253111.9529912.png)\\n\\nThe expected values have five digits after the decimal, which is not correct according to the question.\\nCan someone please confirm this?\\nAm I missing something?"
                    },
                    {
                        "username": "user1864O",
                        "content": ";with temp as(\\nSELECT request_At,\\nsum(case when status like \\'cancelled%\\' then 1 else 0 end) cancelled_cnt,count(id) as total_cnt\\nFROM Trips1 t\\nwhere Client_Id NOT IN (SELECT Users_Id from Users1 where Banned = \\'Yes\\')\\nAND Driver_Id NOT IN (SELECT Users_Id from Users1 where Banned = \\'Yes\\')\\nAND Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n)\\nselect request_at as [Day],\\nCAST(CAST(cancelled_cnt as float)/cast(total_cnt as float) AS DECIMAL(10,2)) as [Cancellation Rate]\\nfrom temp"
                    },
                    {
                        "username": "sowei",
                        "content": "with unbanned as (select users_id from users where banned=\\'no\\')\\n\\nselect request_at as day,round(avg(case when status=\\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\' from trips t \\nwhere t.client_id in (select * from unbanned) and t.driver_id in (select * from unbanned)\\nand request_at>=\\'2013-10-01\\' and request_at<=\\'2013-10-03\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "geyungjen",
                        "content": "\\'\\'\\'\\nwith x as (select request_at as Day, case when Status like \\'cancelled%\\' then 1 else 0 end cancelled \\nfrom trips where client_id in (select users_id from users where banned = \\'No\\') \\nand driver_id in (select users_id from users where banned = \\'No\\'))\\nselect Day, round(sum(cancelled)/count(*),2) \"Cancellation Rate\" from x\\nwhere Day between \\'2013-10-01\\' and \\'2013-10-03\\' group by 1;\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "510939517",
                        "content": "\\'\\'\\'\\nwith clientstep as\\n(select Id, Client_id, Driver_id, status, request_at, Banned as clientstatus from Trips left join Users on Client_id=users_id where banned=\\'No\\')\\n, bothstep as\\n(select Id, Client_id, Driver_id, status, request_at, clientstatus, banned as driverstatus from clientstep left join Users on driver_id=users_id where banned=\\'No\\')\\nselect request_at as Day, round(count((case when status=\\'cancelled_by_driver\\' or status=\\'cancelled_by_client \\' then 1 else null end) )/count(status),2) as \\'Cancellation Rate\\' from bothstep\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n\\'\\'\\'"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT tb1.Request_at AS Day, ROUND(SUM(CASE WHEN tb1.Status = \\'completed\\' THEN 0\\n                                     ELSE 1\\n                                     END) / COUNT(*), 2) AS \\'Cancellation Rate\\'\\nFROM Trips AS tb1\\nINNER JOIN Users AS tb2\\nON tb1.Client_Id = tb2.Users_Id AND tb2.Banned =\\'No\\'\\nINNER JOIN Users As tb3\\nON tb1.Driver_Id = tb3.Users_Id AND tb3.Banned = \\'No\\'\\nWHERE tb1.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY tb1.Request_at\\nORDER BY Day;\\n\\n\\n\\n\\n#Cancel trips/ total  # of trips\\n\\n#ROUND(SUM(CASE WHEN tb1.Status = \\'completed\\' THEN 0\\n#ELSE 1\\n#END) / COUNT(*), 2)\\n"
                    },
                    {
                        "username": "wangqi688",
                        "content": "# Write your MySQL query statement below\\nselect request_at as Day,\\nround(sum(case when status = \\'cancelled_by_driver\\' then 1 \\n    when status=\\'cancelled_by_client\\' then 1 else 0 end)/count(*),2) as  \\'Cancellation Rate\\'\\nfrom trips\\nwhere request_at between \"2013-10-01\" and \"2013-10-03\" and\\nclient_id not in (select users_id from users where banned = \\'Yes\\') and\\ndriver_id not in (select users_id from users where banned = \\'Yes\\') \\ngroup by request_at"
                    },
                    {
                        "username": "aotian0398",
                        "content": "input :\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"cancelled_by_client\", \"2013-10-04\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"10\", \"No\", \"driver\"]]}}\\n\\ncanceled number=1\\n,total number=1 \\ncanceRate=1/1=1, \\nbut the test case is empty....................\\n\\n"
                    }
                ]
            },
            {
                "id": 1575408,
                "content": [
                    {
                        "username": "saini5259",
                        "content": "with main as\\n(\\nselect request_at, count(1) tot_req, \\nsum(case when status like \\'cancelled%\\' then 1 else 0 end) can_req \\nfrom trips\\nwhere client_id not in ( select users_id from users where banned = \\'Yes\\' and role = \\'client\\')\\nand driver_id not in ( select users_id from users where banned = \\'Yes\\' and role = \\'driver\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n)\\nselect request_at day, coalesce(round(can_req/tot_req,2),0) \"Cancellation Rate\"\\nfrom main"
                    },
                    {
                        "username": "mudit_sriv",
                        "content": "\\nWITH temp AS\\n(\\nSELECT request_at, status\\nFROM\\nTrips\\nJOIN\\nUsers AS client_users\\nON Trips.client_id = client_users.users_id\\nJOIN\\nUsers AS driver_users\\nON Trips.driver_id = driver_users.users_id\\nWHERE client_users.banned = \\'No\\'\\nAND driver_users.banned = \\'No\\'\\nAND Trips.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    )\\n\\nSELECT Total.request_at AS Day, ROUND(IFNULL(cancel.c1,0)/IFNULL(Total.c2,1),2) AS \\'Cancellation Rate\\'\\nFROM\\n(SELECT request_at,count(*) AS c1\\nFROM temp\\nWHERE status IN (\"cancelled_by_driver\",\"cancelled_by_client\")\\nGROUP BY request_at) AS cancel\\nRIGHT JOIN\\n(SELECT request_at,count(*) AS c2\\nFROM temp\\nGROUP BY request_at) AS Total\\nUSING (request_at);"
                    },
                    {
                        "username": "chinmay7430",
                        "content": "![image](https://assets.leetcode.com/users/images/1786a0cc-291c-4882-aa19-ef14c22bc880_1626253111.9529912.png)\\n\\nThe expected values have five digits after the decimal, which is not correct according to the question.\\nCan someone please confirm this?\\nAm I missing something?"
                    },
                    {
                        "username": "user1864O",
                        "content": ";with temp as(\\nSELECT request_At,\\nsum(case when status like \\'cancelled%\\' then 1 else 0 end) cancelled_cnt,count(id) as total_cnt\\nFROM Trips1 t\\nwhere Client_Id NOT IN (SELECT Users_Id from Users1 where Banned = \\'Yes\\')\\nAND Driver_Id NOT IN (SELECT Users_Id from Users1 where Banned = \\'Yes\\')\\nAND Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n)\\nselect request_at as [Day],\\nCAST(CAST(cancelled_cnt as float)/cast(total_cnt as float) AS DECIMAL(10,2)) as [Cancellation Rate]\\nfrom temp"
                    },
                    {
                        "username": "sowei",
                        "content": "with unbanned as (select users_id from users where banned=\\'no\\')\\n\\nselect request_at as day,round(avg(case when status=\\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\' from trips t \\nwhere t.client_id in (select * from unbanned) and t.driver_id in (select * from unbanned)\\nand request_at>=\\'2013-10-01\\' and request_at<=\\'2013-10-03\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "geyungjen",
                        "content": "\\'\\'\\'\\nwith x as (select request_at as Day, case when Status like \\'cancelled%\\' then 1 else 0 end cancelled \\nfrom trips where client_id in (select users_id from users where banned = \\'No\\') \\nand driver_id in (select users_id from users where banned = \\'No\\'))\\nselect Day, round(sum(cancelled)/count(*),2) \"Cancellation Rate\" from x\\nwhere Day between \\'2013-10-01\\' and \\'2013-10-03\\' group by 1;\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "510939517",
                        "content": "\\'\\'\\'\\nwith clientstep as\\n(select Id, Client_id, Driver_id, status, request_at, Banned as clientstatus from Trips left join Users on Client_id=users_id where banned=\\'No\\')\\n, bothstep as\\n(select Id, Client_id, Driver_id, status, request_at, clientstatus, banned as driverstatus from clientstep left join Users on driver_id=users_id where banned=\\'No\\')\\nselect request_at as Day, round(count((case when status=\\'cancelled_by_driver\\' or status=\\'cancelled_by_client \\' then 1 else null end) )/count(status),2) as \\'Cancellation Rate\\' from bothstep\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n\\'\\'\\'"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT tb1.Request_at AS Day, ROUND(SUM(CASE WHEN tb1.Status = \\'completed\\' THEN 0\\n                                     ELSE 1\\n                                     END) / COUNT(*), 2) AS \\'Cancellation Rate\\'\\nFROM Trips AS tb1\\nINNER JOIN Users AS tb2\\nON tb1.Client_Id = tb2.Users_Id AND tb2.Banned =\\'No\\'\\nINNER JOIN Users As tb3\\nON tb1.Driver_Id = tb3.Users_Id AND tb3.Banned = \\'No\\'\\nWHERE tb1.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY tb1.Request_at\\nORDER BY Day;\\n\\n\\n\\n\\n#Cancel trips/ total  # of trips\\n\\n#ROUND(SUM(CASE WHEN tb1.Status = \\'completed\\' THEN 0\\n#ELSE 1\\n#END) / COUNT(*), 2)\\n"
                    },
                    {
                        "username": "wangqi688",
                        "content": "# Write your MySQL query statement below\\nselect request_at as Day,\\nround(sum(case when status = \\'cancelled_by_driver\\' then 1 \\n    when status=\\'cancelled_by_client\\' then 1 else 0 end)/count(*),2) as  \\'Cancellation Rate\\'\\nfrom trips\\nwhere request_at between \"2013-10-01\" and \"2013-10-03\" and\\nclient_id not in (select users_id from users where banned = \\'Yes\\') and\\ndriver_id not in (select users_id from users where banned = \\'Yes\\') \\ngroup by request_at"
                    },
                    {
                        "username": "aotian0398",
                        "content": "input :\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"cancelled_by_client\", \"2013-10-04\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"10\", \"No\", \"driver\"]]}}\\n\\ncanceled number=1\\n,total number=1 \\ncanceRate=1/1=1, \\nbut the test case is empty....................\\n\\n"
                    }
                ]
            },
            {
                "id": 1574710,
                "content": [
                    {
                        "username": "saini5259",
                        "content": "with main as\\n(\\nselect request_at, count(1) tot_req, \\nsum(case when status like \\'cancelled%\\' then 1 else 0 end) can_req \\nfrom trips\\nwhere client_id not in ( select users_id from users where banned = \\'Yes\\' and role = \\'client\\')\\nand driver_id not in ( select users_id from users where banned = \\'Yes\\' and role = \\'driver\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n)\\nselect request_at day, coalesce(round(can_req/tot_req,2),0) \"Cancellation Rate\"\\nfrom main"
                    },
                    {
                        "username": "mudit_sriv",
                        "content": "\\nWITH temp AS\\n(\\nSELECT request_at, status\\nFROM\\nTrips\\nJOIN\\nUsers AS client_users\\nON Trips.client_id = client_users.users_id\\nJOIN\\nUsers AS driver_users\\nON Trips.driver_id = driver_users.users_id\\nWHERE client_users.banned = \\'No\\'\\nAND driver_users.banned = \\'No\\'\\nAND Trips.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    )\\n\\nSELECT Total.request_at AS Day, ROUND(IFNULL(cancel.c1,0)/IFNULL(Total.c2,1),2) AS \\'Cancellation Rate\\'\\nFROM\\n(SELECT request_at,count(*) AS c1\\nFROM temp\\nWHERE status IN (\"cancelled_by_driver\",\"cancelled_by_client\")\\nGROUP BY request_at) AS cancel\\nRIGHT JOIN\\n(SELECT request_at,count(*) AS c2\\nFROM temp\\nGROUP BY request_at) AS Total\\nUSING (request_at);"
                    },
                    {
                        "username": "chinmay7430",
                        "content": "![image](https://assets.leetcode.com/users/images/1786a0cc-291c-4882-aa19-ef14c22bc880_1626253111.9529912.png)\\n\\nThe expected values have five digits after the decimal, which is not correct according to the question.\\nCan someone please confirm this?\\nAm I missing something?"
                    },
                    {
                        "username": "user1864O",
                        "content": ";with temp as(\\nSELECT request_At,\\nsum(case when status like \\'cancelled%\\' then 1 else 0 end) cancelled_cnt,count(id) as total_cnt\\nFROM Trips1 t\\nwhere Client_Id NOT IN (SELECT Users_Id from Users1 where Banned = \\'Yes\\')\\nAND Driver_Id NOT IN (SELECT Users_Id from Users1 where Banned = \\'Yes\\')\\nAND Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n)\\nselect request_at as [Day],\\nCAST(CAST(cancelled_cnt as float)/cast(total_cnt as float) AS DECIMAL(10,2)) as [Cancellation Rate]\\nfrom temp"
                    },
                    {
                        "username": "sowei",
                        "content": "with unbanned as (select users_id from users where banned=\\'no\\')\\n\\nselect request_at as day,round(avg(case when status=\\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\' from trips t \\nwhere t.client_id in (select * from unbanned) and t.driver_id in (select * from unbanned)\\nand request_at>=\\'2013-10-01\\' and request_at<=\\'2013-10-03\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "geyungjen",
                        "content": "\\'\\'\\'\\nwith x as (select request_at as Day, case when Status like \\'cancelled%\\' then 1 else 0 end cancelled \\nfrom trips where client_id in (select users_id from users where banned = \\'No\\') \\nand driver_id in (select users_id from users where banned = \\'No\\'))\\nselect Day, round(sum(cancelled)/count(*),2) \"Cancellation Rate\" from x\\nwhere Day between \\'2013-10-01\\' and \\'2013-10-03\\' group by 1;\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "510939517",
                        "content": "\\'\\'\\'\\nwith clientstep as\\n(select Id, Client_id, Driver_id, status, request_at, Banned as clientstatus from Trips left join Users on Client_id=users_id where banned=\\'No\\')\\n, bothstep as\\n(select Id, Client_id, Driver_id, status, request_at, clientstatus, banned as driverstatus from clientstep left join Users on driver_id=users_id where banned=\\'No\\')\\nselect request_at as Day, round(count((case when status=\\'cancelled_by_driver\\' or status=\\'cancelled_by_client \\' then 1 else null end) )/count(status),2) as \\'Cancellation Rate\\' from bothstep\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n\\'\\'\\'"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT tb1.Request_at AS Day, ROUND(SUM(CASE WHEN tb1.Status = \\'completed\\' THEN 0\\n                                     ELSE 1\\n                                     END) / COUNT(*), 2) AS \\'Cancellation Rate\\'\\nFROM Trips AS tb1\\nINNER JOIN Users AS tb2\\nON tb1.Client_Id = tb2.Users_Id AND tb2.Banned =\\'No\\'\\nINNER JOIN Users As tb3\\nON tb1.Driver_Id = tb3.Users_Id AND tb3.Banned = \\'No\\'\\nWHERE tb1.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY tb1.Request_at\\nORDER BY Day;\\n\\n\\n\\n\\n#Cancel trips/ total  # of trips\\n\\n#ROUND(SUM(CASE WHEN tb1.Status = \\'completed\\' THEN 0\\n#ELSE 1\\n#END) / COUNT(*), 2)\\n"
                    },
                    {
                        "username": "wangqi688",
                        "content": "# Write your MySQL query statement below\\nselect request_at as Day,\\nround(sum(case when status = \\'cancelled_by_driver\\' then 1 \\n    when status=\\'cancelled_by_client\\' then 1 else 0 end)/count(*),2) as  \\'Cancellation Rate\\'\\nfrom trips\\nwhere request_at between \"2013-10-01\" and \"2013-10-03\" and\\nclient_id not in (select users_id from users where banned = \\'Yes\\') and\\ndriver_id not in (select users_id from users where banned = \\'Yes\\') \\ngroup by request_at"
                    },
                    {
                        "username": "aotian0398",
                        "content": "input :\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"cancelled_by_client\", \"2013-10-04\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"10\", \"No\", \"driver\"]]}}\\n\\ncanceled number=1\\n,total number=1 \\ncanceRate=1/1=1, \\nbut the test case is empty....................\\n\\n"
                    }
                ]
            },
            {
                "id": 1574612,
                "content": [
                    {
                        "username": "saini5259",
                        "content": "with main as\\n(\\nselect request_at, count(1) tot_req, \\nsum(case when status like \\'cancelled%\\' then 1 else 0 end) can_req \\nfrom trips\\nwhere client_id not in ( select users_id from users where banned = \\'Yes\\' and role = \\'client\\')\\nand driver_id not in ( select users_id from users where banned = \\'Yes\\' and role = \\'driver\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n)\\nselect request_at day, coalesce(round(can_req/tot_req,2),0) \"Cancellation Rate\"\\nfrom main"
                    },
                    {
                        "username": "mudit_sriv",
                        "content": "\\nWITH temp AS\\n(\\nSELECT request_at, status\\nFROM\\nTrips\\nJOIN\\nUsers AS client_users\\nON Trips.client_id = client_users.users_id\\nJOIN\\nUsers AS driver_users\\nON Trips.driver_id = driver_users.users_id\\nWHERE client_users.banned = \\'No\\'\\nAND driver_users.banned = \\'No\\'\\nAND Trips.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    )\\n\\nSELECT Total.request_at AS Day, ROUND(IFNULL(cancel.c1,0)/IFNULL(Total.c2,1),2) AS \\'Cancellation Rate\\'\\nFROM\\n(SELECT request_at,count(*) AS c1\\nFROM temp\\nWHERE status IN (\"cancelled_by_driver\",\"cancelled_by_client\")\\nGROUP BY request_at) AS cancel\\nRIGHT JOIN\\n(SELECT request_at,count(*) AS c2\\nFROM temp\\nGROUP BY request_at) AS Total\\nUSING (request_at);"
                    },
                    {
                        "username": "chinmay7430",
                        "content": "![image](https://assets.leetcode.com/users/images/1786a0cc-291c-4882-aa19-ef14c22bc880_1626253111.9529912.png)\\n\\nThe expected values have five digits after the decimal, which is not correct according to the question.\\nCan someone please confirm this?\\nAm I missing something?"
                    },
                    {
                        "username": "user1864O",
                        "content": ";with temp as(\\nSELECT request_At,\\nsum(case when status like \\'cancelled%\\' then 1 else 0 end) cancelled_cnt,count(id) as total_cnt\\nFROM Trips1 t\\nwhere Client_Id NOT IN (SELECT Users_Id from Users1 where Banned = \\'Yes\\')\\nAND Driver_Id NOT IN (SELECT Users_Id from Users1 where Banned = \\'Yes\\')\\nAND Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n)\\nselect request_at as [Day],\\nCAST(CAST(cancelled_cnt as float)/cast(total_cnt as float) AS DECIMAL(10,2)) as [Cancellation Rate]\\nfrom temp"
                    },
                    {
                        "username": "sowei",
                        "content": "with unbanned as (select users_id from users where banned=\\'no\\')\\n\\nselect request_at as day,round(avg(case when status=\\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\' from trips t \\nwhere t.client_id in (select * from unbanned) and t.driver_id in (select * from unbanned)\\nand request_at>=\\'2013-10-01\\' and request_at<=\\'2013-10-03\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "geyungjen",
                        "content": "\\'\\'\\'\\nwith x as (select request_at as Day, case when Status like \\'cancelled%\\' then 1 else 0 end cancelled \\nfrom trips where client_id in (select users_id from users where banned = \\'No\\') \\nand driver_id in (select users_id from users where banned = \\'No\\'))\\nselect Day, round(sum(cancelled)/count(*),2) \"Cancellation Rate\" from x\\nwhere Day between \\'2013-10-01\\' and \\'2013-10-03\\' group by 1;\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "510939517",
                        "content": "\\'\\'\\'\\nwith clientstep as\\n(select Id, Client_id, Driver_id, status, request_at, Banned as clientstatus from Trips left join Users on Client_id=users_id where banned=\\'No\\')\\n, bothstep as\\n(select Id, Client_id, Driver_id, status, request_at, clientstatus, banned as driverstatus from clientstep left join Users on driver_id=users_id where banned=\\'No\\')\\nselect request_at as Day, round(count((case when status=\\'cancelled_by_driver\\' or status=\\'cancelled_by_client \\' then 1 else null end) )/count(status),2) as \\'Cancellation Rate\\' from bothstep\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n\\'\\'\\'"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT tb1.Request_at AS Day, ROUND(SUM(CASE WHEN tb1.Status = \\'completed\\' THEN 0\\n                                     ELSE 1\\n                                     END) / COUNT(*), 2) AS \\'Cancellation Rate\\'\\nFROM Trips AS tb1\\nINNER JOIN Users AS tb2\\nON tb1.Client_Id = tb2.Users_Id AND tb2.Banned =\\'No\\'\\nINNER JOIN Users As tb3\\nON tb1.Driver_Id = tb3.Users_Id AND tb3.Banned = \\'No\\'\\nWHERE tb1.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY tb1.Request_at\\nORDER BY Day;\\n\\n\\n\\n\\n#Cancel trips/ total  # of trips\\n\\n#ROUND(SUM(CASE WHEN tb1.Status = \\'completed\\' THEN 0\\n#ELSE 1\\n#END) / COUNT(*), 2)\\n"
                    },
                    {
                        "username": "wangqi688",
                        "content": "# Write your MySQL query statement below\\nselect request_at as Day,\\nround(sum(case when status = \\'cancelled_by_driver\\' then 1 \\n    when status=\\'cancelled_by_client\\' then 1 else 0 end)/count(*),2) as  \\'Cancellation Rate\\'\\nfrom trips\\nwhere request_at between \"2013-10-01\" and \"2013-10-03\" and\\nclient_id not in (select users_id from users where banned = \\'Yes\\') and\\ndriver_id not in (select users_id from users where banned = \\'Yes\\') \\ngroup by request_at"
                    },
                    {
                        "username": "aotian0398",
                        "content": "input :\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"cancelled_by_client\", \"2013-10-04\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"10\", \"No\", \"driver\"]]}}\\n\\ncanceled number=1\\n,total number=1 \\ncanceRate=1/1=1, \\nbut the test case is empty....................\\n\\n"
                    }
                ]
            },
            {
                "id": 1574480,
                "content": [
                    {
                        "username": "saini5259",
                        "content": "with main as\\n(\\nselect request_at, count(1) tot_req, \\nsum(case when status like \\'cancelled%\\' then 1 else 0 end) can_req \\nfrom trips\\nwhere client_id not in ( select users_id from users where banned = \\'Yes\\' and role = \\'client\\')\\nand driver_id not in ( select users_id from users where banned = \\'Yes\\' and role = \\'driver\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n)\\nselect request_at day, coalesce(round(can_req/tot_req,2),0) \"Cancellation Rate\"\\nfrom main"
                    },
                    {
                        "username": "mudit_sriv",
                        "content": "\\nWITH temp AS\\n(\\nSELECT request_at, status\\nFROM\\nTrips\\nJOIN\\nUsers AS client_users\\nON Trips.client_id = client_users.users_id\\nJOIN\\nUsers AS driver_users\\nON Trips.driver_id = driver_users.users_id\\nWHERE client_users.banned = \\'No\\'\\nAND driver_users.banned = \\'No\\'\\nAND Trips.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    )\\n\\nSELECT Total.request_at AS Day, ROUND(IFNULL(cancel.c1,0)/IFNULL(Total.c2,1),2) AS \\'Cancellation Rate\\'\\nFROM\\n(SELECT request_at,count(*) AS c1\\nFROM temp\\nWHERE status IN (\"cancelled_by_driver\",\"cancelled_by_client\")\\nGROUP BY request_at) AS cancel\\nRIGHT JOIN\\n(SELECT request_at,count(*) AS c2\\nFROM temp\\nGROUP BY request_at) AS Total\\nUSING (request_at);"
                    },
                    {
                        "username": "chinmay7430",
                        "content": "![image](https://assets.leetcode.com/users/images/1786a0cc-291c-4882-aa19-ef14c22bc880_1626253111.9529912.png)\\n\\nThe expected values have five digits after the decimal, which is not correct according to the question.\\nCan someone please confirm this?\\nAm I missing something?"
                    },
                    {
                        "username": "user1864O",
                        "content": ";with temp as(\\nSELECT request_At,\\nsum(case when status like \\'cancelled%\\' then 1 else 0 end) cancelled_cnt,count(id) as total_cnt\\nFROM Trips1 t\\nwhere Client_Id NOT IN (SELECT Users_Id from Users1 where Banned = \\'Yes\\')\\nAND Driver_Id NOT IN (SELECT Users_Id from Users1 where Banned = \\'Yes\\')\\nAND Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n)\\nselect request_at as [Day],\\nCAST(CAST(cancelled_cnt as float)/cast(total_cnt as float) AS DECIMAL(10,2)) as [Cancellation Rate]\\nfrom temp"
                    },
                    {
                        "username": "sowei",
                        "content": "with unbanned as (select users_id from users where banned=\\'no\\')\\n\\nselect request_at as day,round(avg(case when status=\\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\' from trips t \\nwhere t.client_id in (select * from unbanned) and t.driver_id in (select * from unbanned)\\nand request_at>=\\'2013-10-01\\' and request_at<=\\'2013-10-03\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "geyungjen",
                        "content": "\\'\\'\\'\\nwith x as (select request_at as Day, case when Status like \\'cancelled%\\' then 1 else 0 end cancelled \\nfrom trips where client_id in (select users_id from users where banned = \\'No\\') \\nand driver_id in (select users_id from users where banned = \\'No\\'))\\nselect Day, round(sum(cancelled)/count(*),2) \"Cancellation Rate\" from x\\nwhere Day between \\'2013-10-01\\' and \\'2013-10-03\\' group by 1;\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "510939517",
                        "content": "\\'\\'\\'\\nwith clientstep as\\n(select Id, Client_id, Driver_id, status, request_at, Banned as clientstatus from Trips left join Users on Client_id=users_id where banned=\\'No\\')\\n, bothstep as\\n(select Id, Client_id, Driver_id, status, request_at, clientstatus, banned as driverstatus from clientstep left join Users on driver_id=users_id where banned=\\'No\\')\\nselect request_at as Day, round(count((case when status=\\'cancelled_by_driver\\' or status=\\'cancelled_by_client \\' then 1 else null end) )/count(status),2) as \\'Cancellation Rate\\' from bothstep\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n\\'\\'\\'"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT tb1.Request_at AS Day, ROUND(SUM(CASE WHEN tb1.Status = \\'completed\\' THEN 0\\n                                     ELSE 1\\n                                     END) / COUNT(*), 2) AS \\'Cancellation Rate\\'\\nFROM Trips AS tb1\\nINNER JOIN Users AS tb2\\nON tb1.Client_Id = tb2.Users_Id AND tb2.Banned =\\'No\\'\\nINNER JOIN Users As tb3\\nON tb1.Driver_Id = tb3.Users_Id AND tb3.Banned = \\'No\\'\\nWHERE tb1.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY tb1.Request_at\\nORDER BY Day;\\n\\n\\n\\n\\n#Cancel trips/ total  # of trips\\n\\n#ROUND(SUM(CASE WHEN tb1.Status = \\'completed\\' THEN 0\\n#ELSE 1\\n#END) / COUNT(*), 2)\\n"
                    },
                    {
                        "username": "wangqi688",
                        "content": "# Write your MySQL query statement below\\nselect request_at as Day,\\nround(sum(case when status = \\'cancelled_by_driver\\' then 1 \\n    when status=\\'cancelled_by_client\\' then 1 else 0 end)/count(*),2) as  \\'Cancellation Rate\\'\\nfrom trips\\nwhere request_at between \"2013-10-01\" and \"2013-10-03\" and\\nclient_id not in (select users_id from users where banned = \\'Yes\\') and\\ndriver_id not in (select users_id from users where banned = \\'Yes\\') \\ngroup by request_at"
                    },
                    {
                        "username": "aotian0398",
                        "content": "input :\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"cancelled_by_client\", \"2013-10-04\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"10\", \"No\", \"driver\"]]}}\\n\\ncanceled number=1\\n,total number=1 \\ncanceRate=1/1=1, \\nbut the test case is empty....................\\n\\n"
                    }
                ]
            },
            {
                "id": 1574376,
                "content": [
                    {
                        "username": "saini5259",
                        "content": "with main as\\n(\\nselect request_at, count(1) tot_req, \\nsum(case when status like \\'cancelled%\\' then 1 else 0 end) can_req \\nfrom trips\\nwhere client_id not in ( select users_id from users where banned = \\'Yes\\' and role = \\'client\\')\\nand driver_id not in ( select users_id from users where banned = \\'Yes\\' and role = \\'driver\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n)\\nselect request_at day, coalesce(round(can_req/tot_req,2),0) \"Cancellation Rate\"\\nfrom main"
                    },
                    {
                        "username": "mudit_sriv",
                        "content": "\\nWITH temp AS\\n(\\nSELECT request_at, status\\nFROM\\nTrips\\nJOIN\\nUsers AS client_users\\nON Trips.client_id = client_users.users_id\\nJOIN\\nUsers AS driver_users\\nON Trips.driver_id = driver_users.users_id\\nWHERE client_users.banned = \\'No\\'\\nAND driver_users.banned = \\'No\\'\\nAND Trips.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    )\\n\\nSELECT Total.request_at AS Day, ROUND(IFNULL(cancel.c1,0)/IFNULL(Total.c2,1),2) AS \\'Cancellation Rate\\'\\nFROM\\n(SELECT request_at,count(*) AS c1\\nFROM temp\\nWHERE status IN (\"cancelled_by_driver\",\"cancelled_by_client\")\\nGROUP BY request_at) AS cancel\\nRIGHT JOIN\\n(SELECT request_at,count(*) AS c2\\nFROM temp\\nGROUP BY request_at) AS Total\\nUSING (request_at);"
                    },
                    {
                        "username": "chinmay7430",
                        "content": "![image](https://assets.leetcode.com/users/images/1786a0cc-291c-4882-aa19-ef14c22bc880_1626253111.9529912.png)\\n\\nThe expected values have five digits after the decimal, which is not correct according to the question.\\nCan someone please confirm this?\\nAm I missing something?"
                    },
                    {
                        "username": "user1864O",
                        "content": ";with temp as(\\nSELECT request_At,\\nsum(case when status like \\'cancelled%\\' then 1 else 0 end) cancelled_cnt,count(id) as total_cnt\\nFROM Trips1 t\\nwhere Client_Id NOT IN (SELECT Users_Id from Users1 where Banned = \\'Yes\\')\\nAND Driver_Id NOT IN (SELECT Users_Id from Users1 where Banned = \\'Yes\\')\\nAND Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n)\\nselect request_at as [Day],\\nCAST(CAST(cancelled_cnt as float)/cast(total_cnt as float) AS DECIMAL(10,2)) as [Cancellation Rate]\\nfrom temp"
                    },
                    {
                        "username": "sowei",
                        "content": "with unbanned as (select users_id from users where banned=\\'no\\')\\n\\nselect request_at as day,round(avg(case when status=\\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\' from trips t \\nwhere t.client_id in (select * from unbanned) and t.driver_id in (select * from unbanned)\\nand request_at>=\\'2013-10-01\\' and request_at<=\\'2013-10-03\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "geyungjen",
                        "content": "\\'\\'\\'\\nwith x as (select request_at as Day, case when Status like \\'cancelled%\\' then 1 else 0 end cancelled \\nfrom trips where client_id in (select users_id from users where banned = \\'No\\') \\nand driver_id in (select users_id from users where banned = \\'No\\'))\\nselect Day, round(sum(cancelled)/count(*),2) \"Cancellation Rate\" from x\\nwhere Day between \\'2013-10-01\\' and \\'2013-10-03\\' group by 1;\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "510939517",
                        "content": "\\'\\'\\'\\nwith clientstep as\\n(select Id, Client_id, Driver_id, status, request_at, Banned as clientstatus from Trips left join Users on Client_id=users_id where banned=\\'No\\')\\n, bothstep as\\n(select Id, Client_id, Driver_id, status, request_at, clientstatus, banned as driverstatus from clientstep left join Users on driver_id=users_id where banned=\\'No\\')\\nselect request_at as Day, round(count((case when status=\\'cancelled_by_driver\\' or status=\\'cancelled_by_client \\' then 1 else null end) )/count(status),2) as \\'Cancellation Rate\\' from bothstep\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n\\'\\'\\'"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT tb1.Request_at AS Day, ROUND(SUM(CASE WHEN tb1.Status = \\'completed\\' THEN 0\\n                                     ELSE 1\\n                                     END) / COUNT(*), 2) AS \\'Cancellation Rate\\'\\nFROM Trips AS tb1\\nINNER JOIN Users AS tb2\\nON tb1.Client_Id = tb2.Users_Id AND tb2.Banned =\\'No\\'\\nINNER JOIN Users As tb3\\nON tb1.Driver_Id = tb3.Users_Id AND tb3.Banned = \\'No\\'\\nWHERE tb1.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY tb1.Request_at\\nORDER BY Day;\\n\\n\\n\\n\\n#Cancel trips/ total  # of trips\\n\\n#ROUND(SUM(CASE WHEN tb1.Status = \\'completed\\' THEN 0\\n#ELSE 1\\n#END) / COUNT(*), 2)\\n"
                    },
                    {
                        "username": "wangqi688",
                        "content": "# Write your MySQL query statement below\\nselect request_at as Day,\\nround(sum(case when status = \\'cancelled_by_driver\\' then 1 \\n    when status=\\'cancelled_by_client\\' then 1 else 0 end)/count(*),2) as  \\'Cancellation Rate\\'\\nfrom trips\\nwhere request_at between \"2013-10-01\" and \"2013-10-03\" and\\nclient_id not in (select users_id from users where banned = \\'Yes\\') and\\ndriver_id not in (select users_id from users where banned = \\'Yes\\') \\ngroup by request_at"
                    },
                    {
                        "username": "aotian0398",
                        "content": "input :\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"cancelled_by_client\", \"2013-10-04\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"10\", \"No\", \"driver\"]]}}\\n\\ncanceled number=1\\n,total number=1 \\ncanceRate=1/1=1, \\nbut the test case is empty....................\\n\\n"
                    }
                ]
            },
            {
                "id": 1574318,
                "content": [
                    {
                        "username": "saini5259",
                        "content": "with main as\\n(\\nselect request_at, count(1) tot_req, \\nsum(case when status like \\'cancelled%\\' then 1 else 0 end) can_req \\nfrom trips\\nwhere client_id not in ( select users_id from users where banned = \\'Yes\\' and role = \\'client\\')\\nand driver_id not in ( select users_id from users where banned = \\'Yes\\' and role = \\'driver\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n)\\nselect request_at day, coalesce(round(can_req/tot_req,2),0) \"Cancellation Rate\"\\nfrom main"
                    },
                    {
                        "username": "mudit_sriv",
                        "content": "\\nWITH temp AS\\n(\\nSELECT request_at, status\\nFROM\\nTrips\\nJOIN\\nUsers AS client_users\\nON Trips.client_id = client_users.users_id\\nJOIN\\nUsers AS driver_users\\nON Trips.driver_id = driver_users.users_id\\nWHERE client_users.banned = \\'No\\'\\nAND driver_users.banned = \\'No\\'\\nAND Trips.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    )\\n\\nSELECT Total.request_at AS Day, ROUND(IFNULL(cancel.c1,0)/IFNULL(Total.c2,1),2) AS \\'Cancellation Rate\\'\\nFROM\\n(SELECT request_at,count(*) AS c1\\nFROM temp\\nWHERE status IN (\"cancelled_by_driver\",\"cancelled_by_client\")\\nGROUP BY request_at) AS cancel\\nRIGHT JOIN\\n(SELECT request_at,count(*) AS c2\\nFROM temp\\nGROUP BY request_at) AS Total\\nUSING (request_at);"
                    },
                    {
                        "username": "chinmay7430",
                        "content": "![image](https://assets.leetcode.com/users/images/1786a0cc-291c-4882-aa19-ef14c22bc880_1626253111.9529912.png)\\n\\nThe expected values have five digits after the decimal, which is not correct according to the question.\\nCan someone please confirm this?\\nAm I missing something?"
                    },
                    {
                        "username": "user1864O",
                        "content": ";with temp as(\\nSELECT request_At,\\nsum(case when status like \\'cancelled%\\' then 1 else 0 end) cancelled_cnt,count(id) as total_cnt\\nFROM Trips1 t\\nwhere Client_Id NOT IN (SELECT Users_Id from Users1 where Banned = \\'Yes\\')\\nAND Driver_Id NOT IN (SELECT Users_Id from Users1 where Banned = \\'Yes\\')\\nAND Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n)\\nselect request_at as [Day],\\nCAST(CAST(cancelled_cnt as float)/cast(total_cnt as float) AS DECIMAL(10,2)) as [Cancellation Rate]\\nfrom temp"
                    },
                    {
                        "username": "sowei",
                        "content": "with unbanned as (select users_id from users where banned=\\'no\\')\\n\\nselect request_at as day,round(avg(case when status=\\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\' from trips t \\nwhere t.client_id in (select * from unbanned) and t.driver_id in (select * from unbanned)\\nand request_at>=\\'2013-10-01\\' and request_at<=\\'2013-10-03\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "geyungjen",
                        "content": "\\'\\'\\'\\nwith x as (select request_at as Day, case when Status like \\'cancelled%\\' then 1 else 0 end cancelled \\nfrom trips where client_id in (select users_id from users where banned = \\'No\\') \\nand driver_id in (select users_id from users where banned = \\'No\\'))\\nselect Day, round(sum(cancelled)/count(*),2) \"Cancellation Rate\" from x\\nwhere Day between \\'2013-10-01\\' and \\'2013-10-03\\' group by 1;\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "510939517",
                        "content": "\\'\\'\\'\\nwith clientstep as\\n(select Id, Client_id, Driver_id, status, request_at, Banned as clientstatus from Trips left join Users on Client_id=users_id where banned=\\'No\\')\\n, bothstep as\\n(select Id, Client_id, Driver_id, status, request_at, clientstatus, banned as driverstatus from clientstep left join Users on driver_id=users_id where banned=\\'No\\')\\nselect request_at as Day, round(count((case when status=\\'cancelled_by_driver\\' or status=\\'cancelled_by_client \\' then 1 else null end) )/count(status),2) as \\'Cancellation Rate\\' from bothstep\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n\\'\\'\\'"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT tb1.Request_at AS Day, ROUND(SUM(CASE WHEN tb1.Status = \\'completed\\' THEN 0\\n                                     ELSE 1\\n                                     END) / COUNT(*), 2) AS \\'Cancellation Rate\\'\\nFROM Trips AS tb1\\nINNER JOIN Users AS tb2\\nON tb1.Client_Id = tb2.Users_Id AND tb2.Banned =\\'No\\'\\nINNER JOIN Users As tb3\\nON tb1.Driver_Id = tb3.Users_Id AND tb3.Banned = \\'No\\'\\nWHERE tb1.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY tb1.Request_at\\nORDER BY Day;\\n\\n\\n\\n\\n#Cancel trips/ total  # of trips\\n\\n#ROUND(SUM(CASE WHEN tb1.Status = \\'completed\\' THEN 0\\n#ELSE 1\\n#END) / COUNT(*), 2)\\n"
                    },
                    {
                        "username": "wangqi688",
                        "content": "# Write your MySQL query statement below\\nselect request_at as Day,\\nround(sum(case when status = \\'cancelled_by_driver\\' then 1 \\n    when status=\\'cancelled_by_client\\' then 1 else 0 end)/count(*),2) as  \\'Cancellation Rate\\'\\nfrom trips\\nwhere request_at between \"2013-10-01\" and \"2013-10-03\" and\\nclient_id not in (select users_id from users where banned = \\'Yes\\') and\\ndriver_id not in (select users_id from users where banned = \\'Yes\\') \\ngroup by request_at"
                    },
                    {
                        "username": "aotian0398",
                        "content": "input :\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"cancelled_by_client\", \"2013-10-04\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"10\", \"No\", \"driver\"]]}}\\n\\ncanceled number=1\\n,total number=1 \\ncanceRate=1/1=1, \\nbut the test case is empty....................\\n\\n"
                    }
                ]
            },
            {
                "id": 1573519,
                "content": [
                    {
                        "username": "saini5259",
                        "content": "with main as\\n(\\nselect request_at, count(1) tot_req, \\nsum(case when status like \\'cancelled%\\' then 1 else 0 end) can_req \\nfrom trips\\nwhere client_id not in ( select users_id from users where banned = \\'Yes\\' and role = \\'client\\')\\nand driver_id not in ( select users_id from users where banned = \\'Yes\\' and role = \\'driver\\')\\nand request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n)\\nselect request_at day, coalesce(round(can_req/tot_req,2),0) \"Cancellation Rate\"\\nfrom main"
                    },
                    {
                        "username": "mudit_sriv",
                        "content": "\\nWITH temp AS\\n(\\nSELECT request_at, status\\nFROM\\nTrips\\nJOIN\\nUsers AS client_users\\nON Trips.client_id = client_users.users_id\\nJOIN\\nUsers AS driver_users\\nON Trips.driver_id = driver_users.users_id\\nWHERE client_users.banned = \\'No\\'\\nAND driver_users.banned = \\'No\\'\\nAND Trips.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    )\\n\\nSELECT Total.request_at AS Day, ROUND(IFNULL(cancel.c1,0)/IFNULL(Total.c2,1),2) AS \\'Cancellation Rate\\'\\nFROM\\n(SELECT request_at,count(*) AS c1\\nFROM temp\\nWHERE status IN (\"cancelled_by_driver\",\"cancelled_by_client\")\\nGROUP BY request_at) AS cancel\\nRIGHT JOIN\\n(SELECT request_at,count(*) AS c2\\nFROM temp\\nGROUP BY request_at) AS Total\\nUSING (request_at);"
                    },
                    {
                        "username": "chinmay7430",
                        "content": "![image](https://assets.leetcode.com/users/images/1786a0cc-291c-4882-aa19-ef14c22bc880_1626253111.9529912.png)\\n\\nThe expected values have five digits after the decimal, which is not correct according to the question.\\nCan someone please confirm this?\\nAm I missing something?"
                    },
                    {
                        "username": "user1864O",
                        "content": ";with temp as(\\nSELECT request_At,\\nsum(case when status like \\'cancelled%\\' then 1 else 0 end) cancelled_cnt,count(id) as total_cnt\\nFROM Trips1 t\\nwhere Client_Id NOT IN (SELECT Users_Id from Users1 where Banned = \\'Yes\\')\\nAND Driver_Id NOT IN (SELECT Users_Id from Users1 where Banned = \\'Yes\\')\\nAND Request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n)\\nselect request_at as [Day],\\nCAST(CAST(cancelled_cnt as float)/cast(total_cnt as float) AS DECIMAL(10,2)) as [Cancellation Rate]\\nfrom temp"
                    },
                    {
                        "username": "sowei",
                        "content": "with unbanned as (select users_id from users where banned=\\'no\\')\\n\\nselect request_at as day,round(avg(case when status=\\'completed\\' then 0 else 1 end),2) as \\'Cancellation Rate\\' from trips t \\nwhere t.client_id in (select * from unbanned) and t.driver_id in (select * from unbanned)\\nand request_at>=\\'2013-10-01\\' and request_at<=\\'2013-10-03\\'\\ngroup by request_at\\n"
                    },
                    {
                        "username": "geyungjen",
                        "content": "\\'\\'\\'\\nwith x as (select request_at as Day, case when Status like \\'cancelled%\\' then 1 else 0 end cancelled \\nfrom trips where client_id in (select users_id from users where banned = \\'No\\') \\nand driver_id in (select users_id from users where banned = \\'No\\'))\\nselect Day, round(sum(cancelled)/count(*),2) \"Cancellation Rate\" from x\\nwhere Day between \\'2013-10-01\\' and \\'2013-10-03\\' group by 1;\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "510939517",
                        "content": "\\'\\'\\'\\nwith clientstep as\\n(select Id, Client_id, Driver_id, status, request_at, Banned as clientstatus from Trips left join Users on Client_id=users_id where banned=\\'No\\')\\n, bothstep as\\n(select Id, Client_id, Driver_id, status, request_at, clientstatus, banned as driverstatus from clientstep left join Users on driver_id=users_id where banned=\\'No\\')\\nselect request_at as Day, round(count((case when status=\\'cancelled_by_driver\\' or status=\\'cancelled_by_client \\' then 1 else null end) )/count(status),2) as \\'Cancellation Rate\\' from bothstep\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by request_at\\n\\'\\'\\'"
                    },
                    {
                        "username": "Jennie11",
                        "content": "\\nSELECT tb1.Request_at AS Day, ROUND(SUM(CASE WHEN tb1.Status = \\'completed\\' THEN 0\\n                                     ELSE 1\\n                                     END) / COUNT(*), 2) AS \\'Cancellation Rate\\'\\nFROM Trips AS tb1\\nINNER JOIN Users AS tb2\\nON tb1.Client_Id = tb2.Users_Id AND tb2.Banned =\\'No\\'\\nINNER JOIN Users As tb3\\nON tb1.Driver_Id = tb3.Users_Id AND tb3.Banned = \\'No\\'\\nWHERE tb1.Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY tb1.Request_at\\nORDER BY Day;\\n\\n\\n\\n\\n#Cancel trips/ total  # of trips\\n\\n#ROUND(SUM(CASE WHEN tb1.Status = \\'completed\\' THEN 0\\n#ELSE 1\\n#END) / COUNT(*), 2)\\n"
                    },
                    {
                        "username": "wangqi688",
                        "content": "# Write your MySQL query statement below\\nselect request_at as Day,\\nround(sum(case when status = \\'cancelled_by_driver\\' then 1 \\n    when status=\\'cancelled_by_client\\' then 1 else 0 end)/count(*),2) as  \\'Cancellation Rate\\'\\nfrom trips\\nwhere request_at between \"2013-10-01\" and \"2013-10-03\" and\\nclient_id not in (select users_id from users where banned = \\'Yes\\') and\\ndriver_id not in (select users_id from users where banned = \\'Yes\\') \\ngroup by request_at"
                    },
                    {
                        "username": "aotian0398",
                        "content": "input :\\n{\"headers\": {\"Trips\": [\"Id\", \"Client_Id\", \"Driver_Id\", \"City_Id\", \"Status\", \"Request_at\"], \"Users\": [\"Users_Id\", \"Banned\", \"Role\"]}, \"rows\": {\"Trips\": [[\"1\", \"1\", \"10\", \"1\", \"cancelled_by_client\", \"2013-10-04\"]], \"Users\": [[\"1\", \"No\", \"client\"], [\"10\", \"No\", \"driver\"]]}}\\n\\ncanceled number=1\\n,total number=1 \\ncanceRate=1/1=1, \\nbut the test case is empty....................\\n\\n"
                    }
                ]
            },
            {
                "id": 1573463,
                "content": [
                    {
                        "username": "AneeshGoel",
                        "content": "\\'\\'\\'select request_at as day, round(sum(Status!=\\'completed\\')/count(*),2) as \\'Cancellation rate\\'\\nfrom  trips t left join users u\\non t.Client_id=u.users_id\\nwhere t.request_at between \\'2013-10-01\\' and \\'2013-10-03\\' and banned=\\'NO\\'\\ngroup by request_at\\'\\'\\'"
                    },
                    {
                        "username": "malambic",
                        "content": "The description gives the following cancellation rates for the example:\\n2013-10-01 |       0.33        \\n| 2013-10-02 |       0.00        \\n| 2013-10-03 |       0.50 \\n\\nHowever if you look at the Trips table, the cancellation rate looks to be 0.5 for 10-01 and 0.33 for 10-03, so they are switched.   Does anyone else see this or am I missing something?\\n\\n"
                    },
                    {
                        "username": "zausnerd",
                        "content": "\\nselect Request_at as Day,\\nround(sum(case when Status != \\'completed\\' then 1 else 0 end)/count(*),2) as \\'Cancellation Rate\\' from \\nTrips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\') \\nand Driver_Id not in (select Users_id from Users where Banned = \\'Yes\\')\\nand Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\ngroup by Request_at"
                    },
                    {
                        "username": "jiangziqithinking",
                        "content": "Counld anyone give any clue about how the cancellation rate is calculated? Thanks a lot!!!\\nThe problem is to find the cancellation rate of requests **made by unbanned users** between Oct 1, 2013 and Oct 3, 2013.\\nWhich means, if:\\nthe data is between Oct 1, 2013 and Oct 3, 2013\\nAND(\\ncancelled_by_**client**=> whether the **client** is banned =>if banned = \"No\" => count\\nOR\\ncancelled_by_**driver**=> whether the **driver** is banned =>if banned = \"No\" => count)\\n\\nIn the sample\\nOct 1, 2013\\ntrip2 cancelled by driver11 who is unbanned ==>**1** (Although client2 is banned, client2 is not the user who made the request and this should count still)\\ntrip4 cancelled by client4 who is unbanned ==>**1**\\n**so, (1+1)/4 = 0.5.WHY the sample answer is 0.33???????\\n\\nOct 3, 2013\\ntrip10 cancelled by driver13 who is unbanned ==>**1\\nso, 1/3 = 0.33333. WHY the sample answer is 0.5???????"
                    },
                    {
                        "username": "FeistyPost",
                        "content": "This solution claims that on the 1st of October there was a 33% cancellation rate, yet there were two cancellations out of four total trips. 1 cancellation from a driver (id 11) who was not banned, and another from a client (id 4) who was not banned. That should be a 50% cancellation rate, shouldn\\u2019t it? "
                    },
                    {
                        "username": "nice_dev",
                        "content": "Can Someone please explain how cancellation rates are calculated ? \\n\\nFor '2013-10-02' , the rate is 0.00 since the status is completed for all, but how come 0.33 for '2013-10-01' and 0.50 for '2013-10-03' ?"
                    },
                    {
                        "username": "awesomert",
                        "content": "\\'\\'\\'\\nSELECT t.Request_at AS Day, ROUND(COUNT(DISTINCT CASE WHEN (t.Status = \\'cancelled_by_client\\' OR t.Status = \\'cancelled_by_driver\\') THEN t.Id END)  / COUNT(DISTINCT t.Id),2) AS \\'Cancellation Rate\\'\\nFROM Trips t\\nJOIN Users u ON u.Banned = \\'No\\' AND u.Role = \\'client\\' AND u.Users_id = t.Client_id\\nJOIN Users u2 ON u2.Banned = \\'No\\' AND u2.Role = \\'driver\\' AND u2.Users_id = t.Driver_id\\nWHERE Request_at >= \\'2013-10-01\\' AND Request_at <= \\'2013-10-03\\'\\nGROUP BY 1\\n\\'\\'\\'"
                    },
                    {
                        "username": "yajingleo",
                        "content": "1. What does it mean by 'rate'? There are four trip on 2013-10-01. How come the rate is 0.33?\\n2. What does it mean by 'unbanned clients'? Does 'driver' count as 'client'?\\nWhy the rate on '2013-10-03' is 0.50?"
                    },
                    {
                        "username": "srjefers",
                        "content": "-- ORACLE\\n```\\n/* Write your PL/SQL query statement below */\\nwith users_tmp as (\\n    select *\\n    from Users\\n    where banned = \\'No\\'\\n),\\ntrips_tmp as (\\n    select \\n        t.request_at as day,\\n        count(*) over (partition by t.request_at) as cnt,\\n        case \\n            when t.status in (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') then 1\\n            else 0\\n        end as t_status\\n    from Trips t\\n    inner join users_tmp u_client\\n        on t.client_id = u_client.users_id\\n    inner join users_tmp u_driver\\n        on t.driver_id = u_driver.users_id\\n    where to_date(t.request_at,\\'YYYY-MM-DD\\') \\n        between to_date(\\'2013-10-01\\',\\'YYYY-MM-DD\\') and to_date(\\'2013-10-03\\',\\'YYYY-MM-DD\\')\\n),\\nfinal as (\\n    select \\n        day,\\n        round(sum(t_status)/cnt, 2) as \"Cancellation Rate\"\\n    from trips_tmp\\n    group by day, cnt\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "user4507PE",
                        "content": "/* Write your PL/SQL query statement below */\\nSELECT\\nT.REQUEST_AT AS \"Day\",\\nROUND((COUNT(CASE WHEN T.STATUS LIKE \\'%cancelled%\\' THEN 1 END)/COUNT(*)),2) AS \"Cancellation Rate\"\\nFROM TRIPS T\\nINNER JOIN USERS U ON\\nT.CLIENT_ID=U.USERS_ID\\nINNER JOIN USERS U1 ON T.DRIVER_ID=U1.USERS_ID\\nWHERE U.BANNED=\\'No\\' AND U1.BANNED=\\'No\\'\\nAND T.REQUEST_AT BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY T.REQUEST_AT;"
                    }
                ]
            },
            {
                "id": 1573432,
                "content": [
                    {
                        "username": "AneeshGoel",
                        "content": "\\'\\'\\'select request_at as day, round(sum(Status!=\\'completed\\')/count(*),2) as \\'Cancellation rate\\'\\nfrom  trips t left join users u\\non t.Client_id=u.users_id\\nwhere t.request_at between \\'2013-10-01\\' and \\'2013-10-03\\' and banned=\\'NO\\'\\ngroup by request_at\\'\\'\\'"
                    },
                    {
                        "username": "malambic",
                        "content": "The description gives the following cancellation rates for the example:\\n2013-10-01 |       0.33        \\n| 2013-10-02 |       0.00        \\n| 2013-10-03 |       0.50 \\n\\nHowever if you look at the Trips table, the cancellation rate looks to be 0.5 for 10-01 and 0.33 for 10-03, so they are switched.   Does anyone else see this or am I missing something?\\n\\n"
                    },
                    {
                        "username": "zausnerd",
                        "content": "\\nselect Request_at as Day,\\nround(sum(case when Status != \\'completed\\' then 1 else 0 end)/count(*),2) as \\'Cancellation Rate\\' from \\nTrips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\') \\nand Driver_Id not in (select Users_id from Users where Banned = \\'Yes\\')\\nand Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\ngroup by Request_at"
                    },
                    {
                        "username": "jiangziqithinking",
                        "content": "Counld anyone give any clue about how the cancellation rate is calculated? Thanks a lot!!!\\nThe problem is to find the cancellation rate of requests **made by unbanned users** between Oct 1, 2013 and Oct 3, 2013.\\nWhich means, if:\\nthe data is between Oct 1, 2013 and Oct 3, 2013\\nAND(\\ncancelled_by_**client**=> whether the **client** is banned =>if banned = \"No\" => count\\nOR\\ncancelled_by_**driver**=> whether the **driver** is banned =>if banned = \"No\" => count)\\n\\nIn the sample\\nOct 1, 2013\\ntrip2 cancelled by driver11 who is unbanned ==>**1** (Although client2 is banned, client2 is not the user who made the request and this should count still)\\ntrip4 cancelled by client4 who is unbanned ==>**1**\\n**so, (1+1)/4 = 0.5.WHY the sample answer is 0.33???????\\n\\nOct 3, 2013\\ntrip10 cancelled by driver13 who is unbanned ==>**1\\nso, 1/3 = 0.33333. WHY the sample answer is 0.5???????"
                    },
                    {
                        "username": "FeistyPost",
                        "content": "This solution claims that on the 1st of October there was a 33% cancellation rate, yet there were two cancellations out of four total trips. 1 cancellation from a driver (id 11) who was not banned, and another from a client (id 4) who was not banned. That should be a 50% cancellation rate, shouldn\\u2019t it? "
                    },
                    {
                        "username": "nice_dev",
                        "content": "Can Someone please explain how cancellation rates are calculated ? \\n\\nFor '2013-10-02' , the rate is 0.00 since the status is completed for all, but how come 0.33 for '2013-10-01' and 0.50 for '2013-10-03' ?"
                    },
                    {
                        "username": "awesomert",
                        "content": "\\'\\'\\'\\nSELECT t.Request_at AS Day, ROUND(COUNT(DISTINCT CASE WHEN (t.Status = \\'cancelled_by_client\\' OR t.Status = \\'cancelled_by_driver\\') THEN t.Id END)  / COUNT(DISTINCT t.Id),2) AS \\'Cancellation Rate\\'\\nFROM Trips t\\nJOIN Users u ON u.Banned = \\'No\\' AND u.Role = \\'client\\' AND u.Users_id = t.Client_id\\nJOIN Users u2 ON u2.Banned = \\'No\\' AND u2.Role = \\'driver\\' AND u2.Users_id = t.Driver_id\\nWHERE Request_at >= \\'2013-10-01\\' AND Request_at <= \\'2013-10-03\\'\\nGROUP BY 1\\n\\'\\'\\'"
                    },
                    {
                        "username": "yajingleo",
                        "content": "1. What does it mean by 'rate'? There are four trip on 2013-10-01. How come the rate is 0.33?\\n2. What does it mean by 'unbanned clients'? Does 'driver' count as 'client'?\\nWhy the rate on '2013-10-03' is 0.50?"
                    },
                    {
                        "username": "srjefers",
                        "content": "-- ORACLE\\n```\\n/* Write your PL/SQL query statement below */\\nwith users_tmp as (\\n    select *\\n    from Users\\n    where banned = \\'No\\'\\n),\\ntrips_tmp as (\\n    select \\n        t.request_at as day,\\n        count(*) over (partition by t.request_at) as cnt,\\n        case \\n            when t.status in (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') then 1\\n            else 0\\n        end as t_status\\n    from Trips t\\n    inner join users_tmp u_client\\n        on t.client_id = u_client.users_id\\n    inner join users_tmp u_driver\\n        on t.driver_id = u_driver.users_id\\n    where to_date(t.request_at,\\'YYYY-MM-DD\\') \\n        between to_date(\\'2013-10-01\\',\\'YYYY-MM-DD\\') and to_date(\\'2013-10-03\\',\\'YYYY-MM-DD\\')\\n),\\nfinal as (\\n    select \\n        day,\\n        round(sum(t_status)/cnt, 2) as \"Cancellation Rate\"\\n    from trips_tmp\\n    group by day, cnt\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "user4507PE",
                        "content": "/* Write your PL/SQL query statement below */\\nSELECT\\nT.REQUEST_AT AS \"Day\",\\nROUND((COUNT(CASE WHEN T.STATUS LIKE \\'%cancelled%\\' THEN 1 END)/COUNT(*)),2) AS \"Cancellation Rate\"\\nFROM TRIPS T\\nINNER JOIN USERS U ON\\nT.CLIENT_ID=U.USERS_ID\\nINNER JOIN USERS U1 ON T.DRIVER_ID=U1.USERS_ID\\nWHERE U.BANNED=\\'No\\' AND U1.BANNED=\\'No\\'\\nAND T.REQUEST_AT BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY T.REQUEST_AT;"
                    }
                ]
            },
            {
                "id": 1573103,
                "content": [
                    {
                        "username": "AneeshGoel",
                        "content": "\\'\\'\\'select request_at as day, round(sum(Status!=\\'completed\\')/count(*),2) as \\'Cancellation rate\\'\\nfrom  trips t left join users u\\non t.Client_id=u.users_id\\nwhere t.request_at between \\'2013-10-01\\' and \\'2013-10-03\\' and banned=\\'NO\\'\\ngroup by request_at\\'\\'\\'"
                    },
                    {
                        "username": "malambic",
                        "content": "The description gives the following cancellation rates for the example:\\n2013-10-01 |       0.33        \\n| 2013-10-02 |       0.00        \\n| 2013-10-03 |       0.50 \\n\\nHowever if you look at the Trips table, the cancellation rate looks to be 0.5 for 10-01 and 0.33 for 10-03, so they are switched.   Does anyone else see this or am I missing something?\\n\\n"
                    },
                    {
                        "username": "zausnerd",
                        "content": "\\nselect Request_at as Day,\\nround(sum(case when Status != \\'completed\\' then 1 else 0 end)/count(*),2) as \\'Cancellation Rate\\' from \\nTrips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\') \\nand Driver_Id not in (select Users_id from Users where Banned = \\'Yes\\')\\nand Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\ngroup by Request_at"
                    },
                    {
                        "username": "jiangziqithinking",
                        "content": "Counld anyone give any clue about how the cancellation rate is calculated? Thanks a lot!!!\\nThe problem is to find the cancellation rate of requests **made by unbanned users** between Oct 1, 2013 and Oct 3, 2013.\\nWhich means, if:\\nthe data is between Oct 1, 2013 and Oct 3, 2013\\nAND(\\ncancelled_by_**client**=> whether the **client** is banned =>if banned = \"No\" => count\\nOR\\ncancelled_by_**driver**=> whether the **driver** is banned =>if banned = \"No\" => count)\\n\\nIn the sample\\nOct 1, 2013\\ntrip2 cancelled by driver11 who is unbanned ==>**1** (Although client2 is banned, client2 is not the user who made the request and this should count still)\\ntrip4 cancelled by client4 who is unbanned ==>**1**\\n**so, (1+1)/4 = 0.5.WHY the sample answer is 0.33???????\\n\\nOct 3, 2013\\ntrip10 cancelled by driver13 who is unbanned ==>**1\\nso, 1/3 = 0.33333. WHY the sample answer is 0.5???????"
                    },
                    {
                        "username": "FeistyPost",
                        "content": "This solution claims that on the 1st of October there was a 33% cancellation rate, yet there were two cancellations out of four total trips. 1 cancellation from a driver (id 11) who was not banned, and another from a client (id 4) who was not banned. That should be a 50% cancellation rate, shouldn\\u2019t it? "
                    },
                    {
                        "username": "nice_dev",
                        "content": "Can Someone please explain how cancellation rates are calculated ? \\n\\nFor '2013-10-02' , the rate is 0.00 since the status is completed for all, but how come 0.33 for '2013-10-01' and 0.50 for '2013-10-03' ?"
                    },
                    {
                        "username": "awesomert",
                        "content": "\\'\\'\\'\\nSELECT t.Request_at AS Day, ROUND(COUNT(DISTINCT CASE WHEN (t.Status = \\'cancelled_by_client\\' OR t.Status = \\'cancelled_by_driver\\') THEN t.Id END)  / COUNT(DISTINCT t.Id),2) AS \\'Cancellation Rate\\'\\nFROM Trips t\\nJOIN Users u ON u.Banned = \\'No\\' AND u.Role = \\'client\\' AND u.Users_id = t.Client_id\\nJOIN Users u2 ON u2.Banned = \\'No\\' AND u2.Role = \\'driver\\' AND u2.Users_id = t.Driver_id\\nWHERE Request_at >= \\'2013-10-01\\' AND Request_at <= \\'2013-10-03\\'\\nGROUP BY 1\\n\\'\\'\\'"
                    },
                    {
                        "username": "yajingleo",
                        "content": "1. What does it mean by 'rate'? There are four trip on 2013-10-01. How come the rate is 0.33?\\n2. What does it mean by 'unbanned clients'? Does 'driver' count as 'client'?\\nWhy the rate on '2013-10-03' is 0.50?"
                    },
                    {
                        "username": "srjefers",
                        "content": "-- ORACLE\\n```\\n/* Write your PL/SQL query statement below */\\nwith users_tmp as (\\n    select *\\n    from Users\\n    where banned = \\'No\\'\\n),\\ntrips_tmp as (\\n    select \\n        t.request_at as day,\\n        count(*) over (partition by t.request_at) as cnt,\\n        case \\n            when t.status in (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') then 1\\n            else 0\\n        end as t_status\\n    from Trips t\\n    inner join users_tmp u_client\\n        on t.client_id = u_client.users_id\\n    inner join users_tmp u_driver\\n        on t.driver_id = u_driver.users_id\\n    where to_date(t.request_at,\\'YYYY-MM-DD\\') \\n        between to_date(\\'2013-10-01\\',\\'YYYY-MM-DD\\') and to_date(\\'2013-10-03\\',\\'YYYY-MM-DD\\')\\n),\\nfinal as (\\n    select \\n        day,\\n        round(sum(t_status)/cnt, 2) as \"Cancellation Rate\"\\n    from trips_tmp\\n    group by day, cnt\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "user4507PE",
                        "content": "/* Write your PL/SQL query statement below */\\nSELECT\\nT.REQUEST_AT AS \"Day\",\\nROUND((COUNT(CASE WHEN T.STATUS LIKE \\'%cancelled%\\' THEN 1 END)/COUNT(*)),2) AS \"Cancellation Rate\"\\nFROM TRIPS T\\nINNER JOIN USERS U ON\\nT.CLIENT_ID=U.USERS_ID\\nINNER JOIN USERS U1 ON T.DRIVER_ID=U1.USERS_ID\\nWHERE U.BANNED=\\'No\\' AND U1.BANNED=\\'No\\'\\nAND T.REQUEST_AT BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY T.REQUEST_AT;"
                    }
                ]
            },
            {
                "id": 1572696,
                "content": [
                    {
                        "username": "AneeshGoel",
                        "content": "\\'\\'\\'select request_at as day, round(sum(Status!=\\'completed\\')/count(*),2) as \\'Cancellation rate\\'\\nfrom  trips t left join users u\\non t.Client_id=u.users_id\\nwhere t.request_at between \\'2013-10-01\\' and \\'2013-10-03\\' and banned=\\'NO\\'\\ngroup by request_at\\'\\'\\'"
                    },
                    {
                        "username": "malambic",
                        "content": "The description gives the following cancellation rates for the example:\\n2013-10-01 |       0.33        \\n| 2013-10-02 |       0.00        \\n| 2013-10-03 |       0.50 \\n\\nHowever if you look at the Trips table, the cancellation rate looks to be 0.5 for 10-01 and 0.33 for 10-03, so they are switched.   Does anyone else see this or am I missing something?\\n\\n"
                    },
                    {
                        "username": "zausnerd",
                        "content": "\\nselect Request_at as Day,\\nround(sum(case when Status != \\'completed\\' then 1 else 0 end)/count(*),2) as \\'Cancellation Rate\\' from \\nTrips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\') \\nand Driver_Id not in (select Users_id from Users where Banned = \\'Yes\\')\\nand Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\ngroup by Request_at"
                    },
                    {
                        "username": "jiangziqithinking",
                        "content": "Counld anyone give any clue about how the cancellation rate is calculated? Thanks a lot!!!\\nThe problem is to find the cancellation rate of requests **made by unbanned users** between Oct 1, 2013 and Oct 3, 2013.\\nWhich means, if:\\nthe data is between Oct 1, 2013 and Oct 3, 2013\\nAND(\\ncancelled_by_**client**=> whether the **client** is banned =>if banned = \"No\" => count\\nOR\\ncancelled_by_**driver**=> whether the **driver** is banned =>if banned = \"No\" => count)\\n\\nIn the sample\\nOct 1, 2013\\ntrip2 cancelled by driver11 who is unbanned ==>**1** (Although client2 is banned, client2 is not the user who made the request and this should count still)\\ntrip4 cancelled by client4 who is unbanned ==>**1**\\n**so, (1+1)/4 = 0.5.WHY the sample answer is 0.33???????\\n\\nOct 3, 2013\\ntrip10 cancelled by driver13 who is unbanned ==>**1\\nso, 1/3 = 0.33333. WHY the sample answer is 0.5???????"
                    },
                    {
                        "username": "FeistyPost",
                        "content": "This solution claims that on the 1st of October there was a 33% cancellation rate, yet there were two cancellations out of four total trips. 1 cancellation from a driver (id 11) who was not banned, and another from a client (id 4) who was not banned. That should be a 50% cancellation rate, shouldn\\u2019t it? "
                    },
                    {
                        "username": "nice_dev",
                        "content": "Can Someone please explain how cancellation rates are calculated ? \\n\\nFor '2013-10-02' , the rate is 0.00 since the status is completed for all, but how come 0.33 for '2013-10-01' and 0.50 for '2013-10-03' ?"
                    },
                    {
                        "username": "awesomert",
                        "content": "\\'\\'\\'\\nSELECT t.Request_at AS Day, ROUND(COUNT(DISTINCT CASE WHEN (t.Status = \\'cancelled_by_client\\' OR t.Status = \\'cancelled_by_driver\\') THEN t.Id END)  / COUNT(DISTINCT t.Id),2) AS \\'Cancellation Rate\\'\\nFROM Trips t\\nJOIN Users u ON u.Banned = \\'No\\' AND u.Role = \\'client\\' AND u.Users_id = t.Client_id\\nJOIN Users u2 ON u2.Banned = \\'No\\' AND u2.Role = \\'driver\\' AND u2.Users_id = t.Driver_id\\nWHERE Request_at >= \\'2013-10-01\\' AND Request_at <= \\'2013-10-03\\'\\nGROUP BY 1\\n\\'\\'\\'"
                    },
                    {
                        "username": "yajingleo",
                        "content": "1. What does it mean by 'rate'? There are four trip on 2013-10-01. How come the rate is 0.33?\\n2. What does it mean by 'unbanned clients'? Does 'driver' count as 'client'?\\nWhy the rate on '2013-10-03' is 0.50?"
                    },
                    {
                        "username": "srjefers",
                        "content": "-- ORACLE\\n```\\n/* Write your PL/SQL query statement below */\\nwith users_tmp as (\\n    select *\\n    from Users\\n    where banned = \\'No\\'\\n),\\ntrips_tmp as (\\n    select \\n        t.request_at as day,\\n        count(*) over (partition by t.request_at) as cnt,\\n        case \\n            when t.status in (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') then 1\\n            else 0\\n        end as t_status\\n    from Trips t\\n    inner join users_tmp u_client\\n        on t.client_id = u_client.users_id\\n    inner join users_tmp u_driver\\n        on t.driver_id = u_driver.users_id\\n    where to_date(t.request_at,\\'YYYY-MM-DD\\') \\n        between to_date(\\'2013-10-01\\',\\'YYYY-MM-DD\\') and to_date(\\'2013-10-03\\',\\'YYYY-MM-DD\\')\\n),\\nfinal as (\\n    select \\n        day,\\n        round(sum(t_status)/cnt, 2) as \"Cancellation Rate\"\\n    from trips_tmp\\n    group by day, cnt\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "user4507PE",
                        "content": "/* Write your PL/SQL query statement below */\\nSELECT\\nT.REQUEST_AT AS \"Day\",\\nROUND((COUNT(CASE WHEN T.STATUS LIKE \\'%cancelled%\\' THEN 1 END)/COUNT(*)),2) AS \"Cancellation Rate\"\\nFROM TRIPS T\\nINNER JOIN USERS U ON\\nT.CLIENT_ID=U.USERS_ID\\nINNER JOIN USERS U1 ON T.DRIVER_ID=U1.USERS_ID\\nWHERE U.BANNED=\\'No\\' AND U1.BANNED=\\'No\\'\\nAND T.REQUEST_AT BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY T.REQUEST_AT;"
                    }
                ]
            },
            {
                "id": 1572057,
                "content": [
                    {
                        "username": "AneeshGoel",
                        "content": "\\'\\'\\'select request_at as day, round(sum(Status!=\\'completed\\')/count(*),2) as \\'Cancellation rate\\'\\nfrom  trips t left join users u\\non t.Client_id=u.users_id\\nwhere t.request_at between \\'2013-10-01\\' and \\'2013-10-03\\' and banned=\\'NO\\'\\ngroup by request_at\\'\\'\\'"
                    },
                    {
                        "username": "malambic",
                        "content": "The description gives the following cancellation rates for the example:\\n2013-10-01 |       0.33        \\n| 2013-10-02 |       0.00        \\n| 2013-10-03 |       0.50 \\n\\nHowever if you look at the Trips table, the cancellation rate looks to be 0.5 for 10-01 and 0.33 for 10-03, so they are switched.   Does anyone else see this or am I missing something?\\n\\n"
                    },
                    {
                        "username": "zausnerd",
                        "content": "\\nselect Request_at as Day,\\nround(sum(case when Status != \\'completed\\' then 1 else 0 end)/count(*),2) as \\'Cancellation Rate\\' from \\nTrips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\') \\nand Driver_Id not in (select Users_id from Users where Banned = \\'Yes\\')\\nand Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\ngroup by Request_at"
                    },
                    {
                        "username": "jiangziqithinking",
                        "content": "Counld anyone give any clue about how the cancellation rate is calculated? Thanks a lot!!!\\nThe problem is to find the cancellation rate of requests **made by unbanned users** between Oct 1, 2013 and Oct 3, 2013.\\nWhich means, if:\\nthe data is between Oct 1, 2013 and Oct 3, 2013\\nAND(\\ncancelled_by_**client**=> whether the **client** is banned =>if banned = \"No\" => count\\nOR\\ncancelled_by_**driver**=> whether the **driver** is banned =>if banned = \"No\" => count)\\n\\nIn the sample\\nOct 1, 2013\\ntrip2 cancelled by driver11 who is unbanned ==>**1** (Although client2 is banned, client2 is not the user who made the request and this should count still)\\ntrip4 cancelled by client4 who is unbanned ==>**1**\\n**so, (1+1)/4 = 0.5.WHY the sample answer is 0.33???????\\n\\nOct 3, 2013\\ntrip10 cancelled by driver13 who is unbanned ==>**1\\nso, 1/3 = 0.33333. WHY the sample answer is 0.5???????"
                    },
                    {
                        "username": "FeistyPost",
                        "content": "This solution claims that on the 1st of October there was a 33% cancellation rate, yet there were two cancellations out of four total trips. 1 cancellation from a driver (id 11) who was not banned, and another from a client (id 4) who was not banned. That should be a 50% cancellation rate, shouldn\\u2019t it? "
                    },
                    {
                        "username": "nice_dev",
                        "content": "Can Someone please explain how cancellation rates are calculated ? \\n\\nFor '2013-10-02' , the rate is 0.00 since the status is completed for all, but how come 0.33 for '2013-10-01' and 0.50 for '2013-10-03' ?"
                    },
                    {
                        "username": "awesomert",
                        "content": "\\'\\'\\'\\nSELECT t.Request_at AS Day, ROUND(COUNT(DISTINCT CASE WHEN (t.Status = \\'cancelled_by_client\\' OR t.Status = \\'cancelled_by_driver\\') THEN t.Id END)  / COUNT(DISTINCT t.Id),2) AS \\'Cancellation Rate\\'\\nFROM Trips t\\nJOIN Users u ON u.Banned = \\'No\\' AND u.Role = \\'client\\' AND u.Users_id = t.Client_id\\nJOIN Users u2 ON u2.Banned = \\'No\\' AND u2.Role = \\'driver\\' AND u2.Users_id = t.Driver_id\\nWHERE Request_at >= \\'2013-10-01\\' AND Request_at <= \\'2013-10-03\\'\\nGROUP BY 1\\n\\'\\'\\'"
                    },
                    {
                        "username": "yajingleo",
                        "content": "1. What does it mean by 'rate'? There are four trip on 2013-10-01. How come the rate is 0.33?\\n2. What does it mean by 'unbanned clients'? Does 'driver' count as 'client'?\\nWhy the rate on '2013-10-03' is 0.50?"
                    },
                    {
                        "username": "srjefers",
                        "content": "-- ORACLE\\n```\\n/* Write your PL/SQL query statement below */\\nwith users_tmp as (\\n    select *\\n    from Users\\n    where banned = \\'No\\'\\n),\\ntrips_tmp as (\\n    select \\n        t.request_at as day,\\n        count(*) over (partition by t.request_at) as cnt,\\n        case \\n            when t.status in (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') then 1\\n            else 0\\n        end as t_status\\n    from Trips t\\n    inner join users_tmp u_client\\n        on t.client_id = u_client.users_id\\n    inner join users_tmp u_driver\\n        on t.driver_id = u_driver.users_id\\n    where to_date(t.request_at,\\'YYYY-MM-DD\\') \\n        between to_date(\\'2013-10-01\\',\\'YYYY-MM-DD\\') and to_date(\\'2013-10-03\\',\\'YYYY-MM-DD\\')\\n),\\nfinal as (\\n    select \\n        day,\\n        round(sum(t_status)/cnt, 2) as \"Cancellation Rate\"\\n    from trips_tmp\\n    group by day, cnt\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "user4507PE",
                        "content": "/* Write your PL/SQL query statement below */\\nSELECT\\nT.REQUEST_AT AS \"Day\",\\nROUND((COUNT(CASE WHEN T.STATUS LIKE \\'%cancelled%\\' THEN 1 END)/COUNT(*)),2) AS \"Cancellation Rate\"\\nFROM TRIPS T\\nINNER JOIN USERS U ON\\nT.CLIENT_ID=U.USERS_ID\\nINNER JOIN USERS U1 ON T.DRIVER_ID=U1.USERS_ID\\nWHERE U.BANNED=\\'No\\' AND U1.BANNED=\\'No\\'\\nAND T.REQUEST_AT BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY T.REQUEST_AT;"
                    }
                ]
            },
            {
                "id": 1571501,
                "content": [
                    {
                        "username": "AneeshGoel",
                        "content": "\\'\\'\\'select request_at as day, round(sum(Status!=\\'completed\\')/count(*),2) as \\'Cancellation rate\\'\\nfrom  trips t left join users u\\non t.Client_id=u.users_id\\nwhere t.request_at between \\'2013-10-01\\' and \\'2013-10-03\\' and banned=\\'NO\\'\\ngroup by request_at\\'\\'\\'"
                    },
                    {
                        "username": "malambic",
                        "content": "The description gives the following cancellation rates for the example:\\n2013-10-01 |       0.33        \\n| 2013-10-02 |       0.00        \\n| 2013-10-03 |       0.50 \\n\\nHowever if you look at the Trips table, the cancellation rate looks to be 0.5 for 10-01 and 0.33 for 10-03, so they are switched.   Does anyone else see this or am I missing something?\\n\\n"
                    },
                    {
                        "username": "zausnerd",
                        "content": "\\nselect Request_at as Day,\\nround(sum(case when Status != \\'completed\\' then 1 else 0 end)/count(*),2) as \\'Cancellation Rate\\' from \\nTrips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\') \\nand Driver_Id not in (select Users_id from Users where Banned = \\'Yes\\')\\nand Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\ngroup by Request_at"
                    },
                    {
                        "username": "jiangziqithinking",
                        "content": "Counld anyone give any clue about how the cancellation rate is calculated? Thanks a lot!!!\\nThe problem is to find the cancellation rate of requests **made by unbanned users** between Oct 1, 2013 and Oct 3, 2013.\\nWhich means, if:\\nthe data is between Oct 1, 2013 and Oct 3, 2013\\nAND(\\ncancelled_by_**client**=> whether the **client** is banned =>if banned = \"No\" => count\\nOR\\ncancelled_by_**driver**=> whether the **driver** is banned =>if banned = \"No\" => count)\\n\\nIn the sample\\nOct 1, 2013\\ntrip2 cancelled by driver11 who is unbanned ==>**1** (Although client2 is banned, client2 is not the user who made the request and this should count still)\\ntrip4 cancelled by client4 who is unbanned ==>**1**\\n**so, (1+1)/4 = 0.5.WHY the sample answer is 0.33???????\\n\\nOct 3, 2013\\ntrip10 cancelled by driver13 who is unbanned ==>**1\\nso, 1/3 = 0.33333. WHY the sample answer is 0.5???????"
                    },
                    {
                        "username": "FeistyPost",
                        "content": "This solution claims that on the 1st of October there was a 33% cancellation rate, yet there were two cancellations out of four total trips. 1 cancellation from a driver (id 11) who was not banned, and another from a client (id 4) who was not banned. That should be a 50% cancellation rate, shouldn\\u2019t it? "
                    },
                    {
                        "username": "nice_dev",
                        "content": "Can Someone please explain how cancellation rates are calculated ? \\n\\nFor '2013-10-02' , the rate is 0.00 since the status is completed for all, but how come 0.33 for '2013-10-01' and 0.50 for '2013-10-03' ?"
                    },
                    {
                        "username": "awesomert",
                        "content": "\\'\\'\\'\\nSELECT t.Request_at AS Day, ROUND(COUNT(DISTINCT CASE WHEN (t.Status = \\'cancelled_by_client\\' OR t.Status = \\'cancelled_by_driver\\') THEN t.Id END)  / COUNT(DISTINCT t.Id),2) AS \\'Cancellation Rate\\'\\nFROM Trips t\\nJOIN Users u ON u.Banned = \\'No\\' AND u.Role = \\'client\\' AND u.Users_id = t.Client_id\\nJOIN Users u2 ON u2.Banned = \\'No\\' AND u2.Role = \\'driver\\' AND u2.Users_id = t.Driver_id\\nWHERE Request_at >= \\'2013-10-01\\' AND Request_at <= \\'2013-10-03\\'\\nGROUP BY 1\\n\\'\\'\\'"
                    },
                    {
                        "username": "yajingleo",
                        "content": "1. What does it mean by 'rate'? There are four trip on 2013-10-01. How come the rate is 0.33?\\n2. What does it mean by 'unbanned clients'? Does 'driver' count as 'client'?\\nWhy the rate on '2013-10-03' is 0.50?"
                    },
                    {
                        "username": "srjefers",
                        "content": "-- ORACLE\\n```\\n/* Write your PL/SQL query statement below */\\nwith users_tmp as (\\n    select *\\n    from Users\\n    where banned = \\'No\\'\\n),\\ntrips_tmp as (\\n    select \\n        t.request_at as day,\\n        count(*) over (partition by t.request_at) as cnt,\\n        case \\n            when t.status in (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') then 1\\n            else 0\\n        end as t_status\\n    from Trips t\\n    inner join users_tmp u_client\\n        on t.client_id = u_client.users_id\\n    inner join users_tmp u_driver\\n        on t.driver_id = u_driver.users_id\\n    where to_date(t.request_at,\\'YYYY-MM-DD\\') \\n        between to_date(\\'2013-10-01\\',\\'YYYY-MM-DD\\') and to_date(\\'2013-10-03\\',\\'YYYY-MM-DD\\')\\n),\\nfinal as (\\n    select \\n        day,\\n        round(sum(t_status)/cnt, 2) as \"Cancellation Rate\"\\n    from trips_tmp\\n    group by day, cnt\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "user4507PE",
                        "content": "/* Write your PL/SQL query statement below */\\nSELECT\\nT.REQUEST_AT AS \"Day\",\\nROUND((COUNT(CASE WHEN T.STATUS LIKE \\'%cancelled%\\' THEN 1 END)/COUNT(*)),2) AS \"Cancellation Rate\"\\nFROM TRIPS T\\nINNER JOIN USERS U ON\\nT.CLIENT_ID=U.USERS_ID\\nINNER JOIN USERS U1 ON T.DRIVER_ID=U1.USERS_ID\\nWHERE U.BANNED=\\'No\\' AND U1.BANNED=\\'No\\'\\nAND T.REQUEST_AT BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY T.REQUEST_AT;"
                    }
                ]
            },
            {
                "id": 1574687,
                "content": [
                    {
                        "username": "AneeshGoel",
                        "content": "\\'\\'\\'select request_at as day, round(sum(Status!=\\'completed\\')/count(*),2) as \\'Cancellation rate\\'\\nfrom  trips t left join users u\\non t.Client_id=u.users_id\\nwhere t.request_at between \\'2013-10-01\\' and \\'2013-10-03\\' and banned=\\'NO\\'\\ngroup by request_at\\'\\'\\'"
                    },
                    {
                        "username": "malambic",
                        "content": "The description gives the following cancellation rates for the example:\\n2013-10-01 |       0.33        \\n| 2013-10-02 |       0.00        \\n| 2013-10-03 |       0.50 \\n\\nHowever if you look at the Trips table, the cancellation rate looks to be 0.5 for 10-01 and 0.33 for 10-03, so they are switched.   Does anyone else see this or am I missing something?\\n\\n"
                    },
                    {
                        "username": "zausnerd",
                        "content": "\\nselect Request_at as Day,\\nround(sum(case when Status != \\'completed\\' then 1 else 0 end)/count(*),2) as \\'Cancellation Rate\\' from \\nTrips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\') \\nand Driver_Id not in (select Users_id from Users where Banned = \\'Yes\\')\\nand Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\ngroup by Request_at"
                    },
                    {
                        "username": "jiangziqithinking",
                        "content": "Counld anyone give any clue about how the cancellation rate is calculated? Thanks a lot!!!\\nThe problem is to find the cancellation rate of requests **made by unbanned users** between Oct 1, 2013 and Oct 3, 2013.\\nWhich means, if:\\nthe data is between Oct 1, 2013 and Oct 3, 2013\\nAND(\\ncancelled_by_**client**=> whether the **client** is banned =>if banned = \"No\" => count\\nOR\\ncancelled_by_**driver**=> whether the **driver** is banned =>if banned = \"No\" => count)\\n\\nIn the sample\\nOct 1, 2013\\ntrip2 cancelled by driver11 who is unbanned ==>**1** (Although client2 is banned, client2 is not the user who made the request and this should count still)\\ntrip4 cancelled by client4 who is unbanned ==>**1**\\n**so, (1+1)/4 = 0.5.WHY the sample answer is 0.33???????\\n\\nOct 3, 2013\\ntrip10 cancelled by driver13 who is unbanned ==>**1\\nso, 1/3 = 0.33333. WHY the sample answer is 0.5???????"
                    },
                    {
                        "username": "FeistyPost",
                        "content": "This solution claims that on the 1st of October there was a 33% cancellation rate, yet there were two cancellations out of four total trips. 1 cancellation from a driver (id 11) who was not banned, and another from a client (id 4) who was not banned. That should be a 50% cancellation rate, shouldn\\u2019t it? "
                    },
                    {
                        "username": "nice_dev",
                        "content": "Can Someone please explain how cancellation rates are calculated ? \\n\\nFor '2013-10-02' , the rate is 0.00 since the status is completed for all, but how come 0.33 for '2013-10-01' and 0.50 for '2013-10-03' ?"
                    },
                    {
                        "username": "awesomert",
                        "content": "\\'\\'\\'\\nSELECT t.Request_at AS Day, ROUND(COUNT(DISTINCT CASE WHEN (t.Status = \\'cancelled_by_client\\' OR t.Status = \\'cancelled_by_driver\\') THEN t.Id END)  / COUNT(DISTINCT t.Id),2) AS \\'Cancellation Rate\\'\\nFROM Trips t\\nJOIN Users u ON u.Banned = \\'No\\' AND u.Role = \\'client\\' AND u.Users_id = t.Client_id\\nJOIN Users u2 ON u2.Banned = \\'No\\' AND u2.Role = \\'driver\\' AND u2.Users_id = t.Driver_id\\nWHERE Request_at >= \\'2013-10-01\\' AND Request_at <= \\'2013-10-03\\'\\nGROUP BY 1\\n\\'\\'\\'"
                    },
                    {
                        "username": "yajingleo",
                        "content": "1. What does it mean by 'rate'? There are four trip on 2013-10-01. How come the rate is 0.33?\\n2. What does it mean by 'unbanned clients'? Does 'driver' count as 'client'?\\nWhy the rate on '2013-10-03' is 0.50?"
                    },
                    {
                        "username": "srjefers",
                        "content": "-- ORACLE\\n```\\n/* Write your PL/SQL query statement below */\\nwith users_tmp as (\\n    select *\\n    from Users\\n    where banned = \\'No\\'\\n),\\ntrips_tmp as (\\n    select \\n        t.request_at as day,\\n        count(*) over (partition by t.request_at) as cnt,\\n        case \\n            when t.status in (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') then 1\\n            else 0\\n        end as t_status\\n    from Trips t\\n    inner join users_tmp u_client\\n        on t.client_id = u_client.users_id\\n    inner join users_tmp u_driver\\n        on t.driver_id = u_driver.users_id\\n    where to_date(t.request_at,\\'YYYY-MM-DD\\') \\n        between to_date(\\'2013-10-01\\',\\'YYYY-MM-DD\\') and to_date(\\'2013-10-03\\',\\'YYYY-MM-DD\\')\\n),\\nfinal as (\\n    select \\n        day,\\n        round(sum(t_status)/cnt, 2) as \"Cancellation Rate\"\\n    from trips_tmp\\n    group by day, cnt\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "user4507PE",
                        "content": "/* Write your PL/SQL query statement below */\\nSELECT\\nT.REQUEST_AT AS \"Day\",\\nROUND((COUNT(CASE WHEN T.STATUS LIKE \\'%cancelled%\\' THEN 1 END)/COUNT(*)),2) AS \"Cancellation Rate\"\\nFROM TRIPS T\\nINNER JOIN USERS U ON\\nT.CLIENT_ID=U.USERS_ID\\nINNER JOIN USERS U1 ON T.DRIVER_ID=U1.USERS_ID\\nWHERE U.BANNED=\\'No\\' AND U1.BANNED=\\'No\\'\\nAND T.REQUEST_AT BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY T.REQUEST_AT;"
                    }
                ]
            },
            {
                "id": 1571500,
                "content": [
                    {
                        "username": "AneeshGoel",
                        "content": "\\'\\'\\'select request_at as day, round(sum(Status!=\\'completed\\')/count(*),2) as \\'Cancellation rate\\'\\nfrom  trips t left join users u\\non t.Client_id=u.users_id\\nwhere t.request_at between \\'2013-10-01\\' and \\'2013-10-03\\' and banned=\\'NO\\'\\ngroup by request_at\\'\\'\\'"
                    },
                    {
                        "username": "malambic",
                        "content": "The description gives the following cancellation rates for the example:\\n2013-10-01 |       0.33        \\n| 2013-10-02 |       0.00        \\n| 2013-10-03 |       0.50 \\n\\nHowever if you look at the Trips table, the cancellation rate looks to be 0.5 for 10-01 and 0.33 for 10-03, so they are switched.   Does anyone else see this or am I missing something?\\n\\n"
                    },
                    {
                        "username": "zausnerd",
                        "content": "\\nselect Request_at as Day,\\nround(sum(case when Status != \\'completed\\' then 1 else 0 end)/count(*),2) as \\'Cancellation Rate\\' from \\nTrips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\') \\nand Driver_Id not in (select Users_id from Users where Banned = \\'Yes\\')\\nand Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\ngroup by Request_at"
                    },
                    {
                        "username": "jiangziqithinking",
                        "content": "Counld anyone give any clue about how the cancellation rate is calculated? Thanks a lot!!!\\nThe problem is to find the cancellation rate of requests **made by unbanned users** between Oct 1, 2013 and Oct 3, 2013.\\nWhich means, if:\\nthe data is between Oct 1, 2013 and Oct 3, 2013\\nAND(\\ncancelled_by_**client**=> whether the **client** is banned =>if banned = \"No\" => count\\nOR\\ncancelled_by_**driver**=> whether the **driver** is banned =>if banned = \"No\" => count)\\n\\nIn the sample\\nOct 1, 2013\\ntrip2 cancelled by driver11 who is unbanned ==>**1** (Although client2 is banned, client2 is not the user who made the request and this should count still)\\ntrip4 cancelled by client4 who is unbanned ==>**1**\\n**so, (1+1)/4 = 0.5.WHY the sample answer is 0.33???????\\n\\nOct 3, 2013\\ntrip10 cancelled by driver13 who is unbanned ==>**1\\nso, 1/3 = 0.33333. WHY the sample answer is 0.5???????"
                    },
                    {
                        "username": "FeistyPost",
                        "content": "This solution claims that on the 1st of October there was a 33% cancellation rate, yet there were two cancellations out of four total trips. 1 cancellation from a driver (id 11) who was not banned, and another from a client (id 4) who was not banned. That should be a 50% cancellation rate, shouldn\\u2019t it? "
                    },
                    {
                        "username": "nice_dev",
                        "content": "Can Someone please explain how cancellation rates are calculated ? \\n\\nFor '2013-10-02' , the rate is 0.00 since the status is completed for all, but how come 0.33 for '2013-10-01' and 0.50 for '2013-10-03' ?"
                    },
                    {
                        "username": "awesomert",
                        "content": "\\'\\'\\'\\nSELECT t.Request_at AS Day, ROUND(COUNT(DISTINCT CASE WHEN (t.Status = \\'cancelled_by_client\\' OR t.Status = \\'cancelled_by_driver\\') THEN t.Id END)  / COUNT(DISTINCT t.Id),2) AS \\'Cancellation Rate\\'\\nFROM Trips t\\nJOIN Users u ON u.Banned = \\'No\\' AND u.Role = \\'client\\' AND u.Users_id = t.Client_id\\nJOIN Users u2 ON u2.Banned = \\'No\\' AND u2.Role = \\'driver\\' AND u2.Users_id = t.Driver_id\\nWHERE Request_at >= \\'2013-10-01\\' AND Request_at <= \\'2013-10-03\\'\\nGROUP BY 1\\n\\'\\'\\'"
                    },
                    {
                        "username": "yajingleo",
                        "content": "1. What does it mean by 'rate'? There are four trip on 2013-10-01. How come the rate is 0.33?\\n2. What does it mean by 'unbanned clients'? Does 'driver' count as 'client'?\\nWhy the rate on '2013-10-03' is 0.50?"
                    },
                    {
                        "username": "srjefers",
                        "content": "-- ORACLE\\n```\\n/* Write your PL/SQL query statement below */\\nwith users_tmp as (\\n    select *\\n    from Users\\n    where banned = \\'No\\'\\n),\\ntrips_tmp as (\\n    select \\n        t.request_at as day,\\n        count(*) over (partition by t.request_at) as cnt,\\n        case \\n            when t.status in (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') then 1\\n            else 0\\n        end as t_status\\n    from Trips t\\n    inner join users_tmp u_client\\n        on t.client_id = u_client.users_id\\n    inner join users_tmp u_driver\\n        on t.driver_id = u_driver.users_id\\n    where to_date(t.request_at,\\'YYYY-MM-DD\\') \\n        between to_date(\\'2013-10-01\\',\\'YYYY-MM-DD\\') and to_date(\\'2013-10-03\\',\\'YYYY-MM-DD\\')\\n),\\nfinal as (\\n    select \\n        day,\\n        round(sum(t_status)/cnt, 2) as \"Cancellation Rate\"\\n    from trips_tmp\\n    group by day, cnt\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "user4507PE",
                        "content": "/* Write your PL/SQL query statement below */\\nSELECT\\nT.REQUEST_AT AS \"Day\",\\nROUND((COUNT(CASE WHEN T.STATUS LIKE \\'%cancelled%\\' THEN 1 END)/COUNT(*)),2) AS \"Cancellation Rate\"\\nFROM TRIPS T\\nINNER JOIN USERS U ON\\nT.CLIENT_ID=U.USERS_ID\\nINNER JOIN USERS U1 ON T.DRIVER_ID=U1.USERS_ID\\nWHERE U.BANNED=\\'No\\' AND U1.BANNED=\\'No\\'\\nAND T.REQUEST_AT BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY T.REQUEST_AT;"
                    }
                ]
            },
            {
                "id": 2063548,
                "content": [
                    {
                        "username": "AneeshGoel",
                        "content": "\\'\\'\\'select request_at as day, round(sum(Status!=\\'completed\\')/count(*),2) as \\'Cancellation rate\\'\\nfrom  trips t left join users u\\non t.Client_id=u.users_id\\nwhere t.request_at between \\'2013-10-01\\' and \\'2013-10-03\\' and banned=\\'NO\\'\\ngroup by request_at\\'\\'\\'"
                    },
                    {
                        "username": "malambic",
                        "content": "The description gives the following cancellation rates for the example:\\n2013-10-01 |       0.33        \\n| 2013-10-02 |       0.00        \\n| 2013-10-03 |       0.50 \\n\\nHowever if you look at the Trips table, the cancellation rate looks to be 0.5 for 10-01 and 0.33 for 10-03, so they are switched.   Does anyone else see this or am I missing something?\\n\\n"
                    },
                    {
                        "username": "zausnerd",
                        "content": "\\nselect Request_at as Day,\\nround(sum(case when Status != \\'completed\\' then 1 else 0 end)/count(*),2) as \\'Cancellation Rate\\' from \\nTrips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\') \\nand Driver_Id not in (select Users_id from Users where Banned = \\'Yes\\')\\nand Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\ngroup by Request_at"
                    },
                    {
                        "username": "jiangziqithinking",
                        "content": "Counld anyone give any clue about how the cancellation rate is calculated? Thanks a lot!!!\\nThe problem is to find the cancellation rate of requests **made by unbanned users** between Oct 1, 2013 and Oct 3, 2013.\\nWhich means, if:\\nthe data is between Oct 1, 2013 and Oct 3, 2013\\nAND(\\ncancelled_by_**client**=> whether the **client** is banned =>if banned = \"No\" => count\\nOR\\ncancelled_by_**driver**=> whether the **driver** is banned =>if banned = \"No\" => count)\\n\\nIn the sample\\nOct 1, 2013\\ntrip2 cancelled by driver11 who is unbanned ==>**1** (Although client2 is banned, client2 is not the user who made the request and this should count still)\\ntrip4 cancelled by client4 who is unbanned ==>**1**\\n**so, (1+1)/4 = 0.5.WHY the sample answer is 0.33???????\\n\\nOct 3, 2013\\ntrip10 cancelled by driver13 who is unbanned ==>**1\\nso, 1/3 = 0.33333. WHY the sample answer is 0.5???????"
                    },
                    {
                        "username": "FeistyPost",
                        "content": "This solution claims that on the 1st of October there was a 33% cancellation rate, yet there were two cancellations out of four total trips. 1 cancellation from a driver (id 11) who was not banned, and another from a client (id 4) who was not banned. That should be a 50% cancellation rate, shouldn\\u2019t it? "
                    },
                    {
                        "username": "nice_dev",
                        "content": "Can Someone please explain how cancellation rates are calculated ? \\n\\nFor '2013-10-02' , the rate is 0.00 since the status is completed for all, but how come 0.33 for '2013-10-01' and 0.50 for '2013-10-03' ?"
                    },
                    {
                        "username": "awesomert",
                        "content": "\\'\\'\\'\\nSELECT t.Request_at AS Day, ROUND(COUNT(DISTINCT CASE WHEN (t.Status = \\'cancelled_by_client\\' OR t.Status = \\'cancelled_by_driver\\') THEN t.Id END)  / COUNT(DISTINCT t.Id),2) AS \\'Cancellation Rate\\'\\nFROM Trips t\\nJOIN Users u ON u.Banned = \\'No\\' AND u.Role = \\'client\\' AND u.Users_id = t.Client_id\\nJOIN Users u2 ON u2.Banned = \\'No\\' AND u2.Role = \\'driver\\' AND u2.Users_id = t.Driver_id\\nWHERE Request_at >= \\'2013-10-01\\' AND Request_at <= \\'2013-10-03\\'\\nGROUP BY 1\\n\\'\\'\\'"
                    },
                    {
                        "username": "yajingleo",
                        "content": "1. What does it mean by 'rate'? There are four trip on 2013-10-01. How come the rate is 0.33?\\n2. What does it mean by 'unbanned clients'? Does 'driver' count as 'client'?\\nWhy the rate on '2013-10-03' is 0.50?"
                    },
                    {
                        "username": "srjefers",
                        "content": "-- ORACLE\\n```\\n/* Write your PL/SQL query statement below */\\nwith users_tmp as (\\n    select *\\n    from Users\\n    where banned = \\'No\\'\\n),\\ntrips_tmp as (\\n    select \\n        t.request_at as day,\\n        count(*) over (partition by t.request_at) as cnt,\\n        case \\n            when t.status in (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') then 1\\n            else 0\\n        end as t_status\\n    from Trips t\\n    inner join users_tmp u_client\\n        on t.client_id = u_client.users_id\\n    inner join users_tmp u_driver\\n        on t.driver_id = u_driver.users_id\\n    where to_date(t.request_at,\\'YYYY-MM-DD\\') \\n        between to_date(\\'2013-10-01\\',\\'YYYY-MM-DD\\') and to_date(\\'2013-10-03\\',\\'YYYY-MM-DD\\')\\n),\\nfinal as (\\n    select \\n        day,\\n        round(sum(t_status)/cnt, 2) as \"Cancellation Rate\"\\n    from trips_tmp\\n    group by day, cnt\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "user4507PE",
                        "content": "/* Write your PL/SQL query statement below */\\nSELECT\\nT.REQUEST_AT AS \"Day\",\\nROUND((COUNT(CASE WHEN T.STATUS LIKE \\'%cancelled%\\' THEN 1 END)/COUNT(*)),2) AS \"Cancellation Rate\"\\nFROM TRIPS T\\nINNER JOIN USERS U ON\\nT.CLIENT_ID=U.USERS_ID\\nINNER JOIN USERS U1 ON T.DRIVER_ID=U1.USERS_ID\\nWHERE U.BANNED=\\'No\\' AND U1.BANNED=\\'No\\'\\nAND T.REQUEST_AT BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY T.REQUEST_AT;"
                    }
                ]
            },
            {
                "id": 2042279,
                "content": [
                    {
                        "username": "AneeshGoel",
                        "content": "\\'\\'\\'select request_at as day, round(sum(Status!=\\'completed\\')/count(*),2) as \\'Cancellation rate\\'\\nfrom  trips t left join users u\\non t.Client_id=u.users_id\\nwhere t.request_at between \\'2013-10-01\\' and \\'2013-10-03\\' and banned=\\'NO\\'\\ngroup by request_at\\'\\'\\'"
                    },
                    {
                        "username": "malambic",
                        "content": "The description gives the following cancellation rates for the example:\\n2013-10-01 |       0.33        \\n| 2013-10-02 |       0.00        \\n| 2013-10-03 |       0.50 \\n\\nHowever if you look at the Trips table, the cancellation rate looks to be 0.5 for 10-01 and 0.33 for 10-03, so they are switched.   Does anyone else see this or am I missing something?\\n\\n"
                    },
                    {
                        "username": "zausnerd",
                        "content": "\\nselect Request_at as Day,\\nround(sum(case when Status != \\'completed\\' then 1 else 0 end)/count(*),2) as \\'Cancellation Rate\\' from \\nTrips\\nwhere Client_Id not in (select Users_Id from Users where Banned = \\'Yes\\') \\nand Driver_Id not in (select Users_id from Users where Banned = \\'Yes\\')\\nand Request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\ngroup by Request_at"
                    },
                    {
                        "username": "jiangziqithinking",
                        "content": "Counld anyone give any clue about how the cancellation rate is calculated? Thanks a lot!!!\\nThe problem is to find the cancellation rate of requests **made by unbanned users** between Oct 1, 2013 and Oct 3, 2013.\\nWhich means, if:\\nthe data is between Oct 1, 2013 and Oct 3, 2013\\nAND(\\ncancelled_by_**client**=> whether the **client** is banned =>if banned = \"No\" => count\\nOR\\ncancelled_by_**driver**=> whether the **driver** is banned =>if banned = \"No\" => count)\\n\\nIn the sample\\nOct 1, 2013\\ntrip2 cancelled by driver11 who is unbanned ==>**1** (Although client2 is banned, client2 is not the user who made the request and this should count still)\\ntrip4 cancelled by client4 who is unbanned ==>**1**\\n**so, (1+1)/4 = 0.5.WHY the sample answer is 0.33???????\\n\\nOct 3, 2013\\ntrip10 cancelled by driver13 who is unbanned ==>**1\\nso, 1/3 = 0.33333. WHY the sample answer is 0.5???????"
                    },
                    {
                        "username": "FeistyPost",
                        "content": "This solution claims that on the 1st of October there was a 33% cancellation rate, yet there were two cancellations out of four total trips. 1 cancellation from a driver (id 11) who was not banned, and another from a client (id 4) who was not banned. That should be a 50% cancellation rate, shouldn\\u2019t it? "
                    },
                    {
                        "username": "nice_dev",
                        "content": "Can Someone please explain how cancellation rates are calculated ? \\n\\nFor '2013-10-02' , the rate is 0.00 since the status is completed for all, but how come 0.33 for '2013-10-01' and 0.50 for '2013-10-03' ?"
                    },
                    {
                        "username": "awesomert",
                        "content": "\\'\\'\\'\\nSELECT t.Request_at AS Day, ROUND(COUNT(DISTINCT CASE WHEN (t.Status = \\'cancelled_by_client\\' OR t.Status = \\'cancelled_by_driver\\') THEN t.Id END)  / COUNT(DISTINCT t.Id),2) AS \\'Cancellation Rate\\'\\nFROM Trips t\\nJOIN Users u ON u.Banned = \\'No\\' AND u.Role = \\'client\\' AND u.Users_id = t.Client_id\\nJOIN Users u2 ON u2.Banned = \\'No\\' AND u2.Role = \\'driver\\' AND u2.Users_id = t.Driver_id\\nWHERE Request_at >= \\'2013-10-01\\' AND Request_at <= \\'2013-10-03\\'\\nGROUP BY 1\\n\\'\\'\\'"
                    },
                    {
                        "username": "yajingleo",
                        "content": "1. What does it mean by 'rate'? There are four trip on 2013-10-01. How come the rate is 0.33?\\n2. What does it mean by 'unbanned clients'? Does 'driver' count as 'client'?\\nWhy the rate on '2013-10-03' is 0.50?"
                    },
                    {
                        "username": "srjefers",
                        "content": "-- ORACLE\\n```\\n/* Write your PL/SQL query statement below */\\nwith users_tmp as (\\n    select *\\n    from Users\\n    where banned = \\'No\\'\\n),\\ntrips_tmp as (\\n    select \\n        t.request_at as day,\\n        count(*) over (partition by t.request_at) as cnt,\\n        case \\n            when t.status in (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') then 1\\n            else 0\\n        end as t_status\\n    from Trips t\\n    inner join users_tmp u_client\\n        on t.client_id = u_client.users_id\\n    inner join users_tmp u_driver\\n        on t.driver_id = u_driver.users_id\\n    where to_date(t.request_at,\\'YYYY-MM-DD\\') \\n        between to_date(\\'2013-10-01\\',\\'YYYY-MM-DD\\') and to_date(\\'2013-10-03\\',\\'YYYY-MM-DD\\')\\n),\\nfinal as (\\n    select \\n        day,\\n        round(sum(t_status)/cnt, 2) as \"Cancellation Rate\"\\n    from trips_tmp\\n    group by day, cnt\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "user4507PE",
                        "content": "/* Write your PL/SQL query statement below */\\nSELECT\\nT.REQUEST_AT AS \"Day\",\\nROUND((COUNT(CASE WHEN T.STATUS LIKE \\'%cancelled%\\' THEN 1 END)/COUNT(*)),2) AS \"Cancellation Rate\"\\nFROM TRIPS T\\nINNER JOIN USERS U ON\\nT.CLIENT_ID=U.USERS_ID\\nINNER JOIN USERS U1 ON T.DRIVER_ID=U1.USERS_ID\\nWHERE U.BANNED=\\'No\\' AND U1.BANNED=\\'No\\'\\nAND T.REQUEST_AT BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY T.REQUEST_AT;"
                    }
                ]
            },
            {
                "id": 2031698,
                "content": [
                    {
                        "username": "leetciel5577",
                        "content": "Is there any idea what\\'s the issue with my answer? It passes all the other testcase, but the following one. Thanks a lot!\\n\\nInput\\nTrips =\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | Yes    | driver |\\n\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\n\\n-----------------------------------------------------------------------------\\n\\n\\n\\n\\nwith cte as(\\nselect *\\nfrom trips t join users u\\non t.client_id=u.users_id\\nwhere u.banned!=\\'Yes\\'\\n)\\n\\nselect request_at as Day , \\nround(sum(case when status!=\\'completed\\' then 1 else 0 end)/count(status) ,2) as \\'Cancellation Rate\\'\\nfrom cte\\ngroup by request_at \\nhaving request_at between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "johnzaheer",
                        "content": "It\\u2019s broken, my code ran into the same issue so i created a work around then the output changed to the opposite. Depending on which version of my code i ran the output would be different for this exact case as well. "
                    },
                    {
                        "username": "johnzaheer",
                        "content": "Brocken test case exist, where there is just 1 input that is completed the expected changes depending on your output. \\n\\neven created workaround to null if no canceled status exist, but then the expected changed to 0\\nleave as is so my code returns 0\\nthen the expected changes to null"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "It seems there is a misprint in Pandas Schema. I propose to use \\n```\\ndata = [[\\'1\\', \\'1\\', \\'10\\', \\'1\\', \\'completed\\', \\'2013-10-01\\'], [\\'2\\', \\'2\\', \\'11\\', \\'1\\', \\'cancelled_by_driver\\', \\'2013-10-01\\'], [\\'3\\', \\'3\\', \\'2\\', \\'6\\', \\'completed\\', \\'2013-10-01\\'], [\\'4\\', \\'4\\', \\'13\\', \\'6\\', \\'cancelled_by_client\\', \\'2013-10-01\\'], [\\'5\\', \\'1\\', \\'10\\', \\'1\\', \\'completed\\', \\'2013-10-02\\'], [\\'6\\', \\'2\\', \\'11\\', \\'6\\', \\'completed\\', \\'2013-10-02\\'], [\\'7\\', \\'3\\', \\'12\\', \\'6\\', \\'completed\\', \\'2013-10-02\\'], [\\'8\\', \\'2\\', \\'12\\', \\'12\\', \\'completed\\', \\'2013-10-03\\'], [\\'9\\', \\'3\\', \\'10\\', \\'12\\', \\'completed\\', \\'2013-10-03\\'], [\\'10\\', \\'4\\', \\'13\\', \\'12\\', \\'cancelled_by_driver\\', \\'2013-10-03\\']]\\ntrips = pd.DataFrame(data, columns=[\\'id\\', \\'client_id\\', \\'driver_id\\', \\'city_id\\', \\'status\\', \\'request_at\\']).astype({\\'id\\':\\'Int64\\', \\'client_id\\':\\'Int64\\', \\'driver_id\\':\\'Int64\\', \\'city_id\\':\\'Int64\\', \\'status\\':\\'object\\', \\'request_at\\': \\'datetime64[ns]\\'})\\n\\ndata = [[\\'1\\', \\'No\\', \\'client\\'], [\\'2\\', \\'Yes\\', \\'client\\'], [\\'3\\', \\'No\\', \\'client\\'], [\\'4\\', \\'No\\', \\'client\\'], [\\'10\\', \\'No\\', \\'driver\\'], [\\'11\\', \\'No\\', \\'driver\\'], [\\'12\\', \\'No\\', \\'driver\\'], [\\'13\\', \\'No\\', \\'driver\\']]\\nusers = pd.DataFrame(data, columns=[\\'users_id\\', \\'banned\\', \\'role\\']).astype({\\'users_id\\':\\'Int64\\', \\'banned\\':\\'object\\', \\'role\\':\\'object\\'})\\n``` \\ninstead."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "AlexeySumin",
                        "content": "Hello!\nI have a working sql code, it executes well on mysql, but when i execute in on MsSQL(here, not in real one), i face an issue wis dividing values, it returns zeros.\nIve already met such issues on leetcode, am i the only who faced it?\n\nwith cte as (\n    select \n    t.request_at\n    , CASE when t.status = 'completed' then 'ok' else 'cancel' end as status_new\n    , COUNT(1) as cnt\n    from Trips as t\n    inner join Users as c On t.client_id = c.users_id \n    inner join Users as d On t.driver_id = d.users_id \n    where\n        t.request_at between CAST('2013-10-01' as DATE) and CAST('2013-10-03' as DATE) AND c.banned = 'No' AND d.banned = 'No'\n    group by \n        t.request_at, CASE when t.status = 'completed' then 'ok' else 'cancel' end\n)\nSELECT \ncte.request_at as Day\n,  ROUND(SUM(CASE when cte.status_new = 'cancel' then cte.cnt else 0 end) / SUM(cte.cnt), 2) as \"Cancellation Rate\"\nFROM \n    cte\nGROUP BY \n    cte.request_at\n"
                    },
                    {
                        "username": "addy022",
                        "content": "Can someone Fix and Explain what's wrong with the below query?\nI am getting below output\n| Day        | Cancellation_Rate |\n| ---------- | ----------------- |\n| 2013-10-01 | 0                 |\n| 2013-10-02 | 0                 |\n| 2013-10-03 | 0                 |\n\n/* Write your PL/SQL query statement below */\n-- filtered banned user/driver rows, date range\nwith cte as (\nSelect t.id, t.client_id, t.driver_id, t.status, t.request_at\nfrom trips t\ninner join users u on\nt.client_id = u.users_id and u.banned = 'No'\ninner join users u2 on\nt.driver_id = u2.users_id and u2.banned = 'No'\nwhere t.request_at between '2013-10-01' and '2013-10-03'\n)\n,\n-- total trips per day\ncte2 as (\nSelect count(id) as total_trips,  \nrequest_at from cte group by request_at \n)\n,\n-- cancelled trips per day\ncte3 as (\n  Select count(id) as cancelled_trips,  \nrequest_at as trip_date from cte  where status != 'completed' group by request_at\n),\n\ncte4 as\n(Select cte2.*, cte3.*\nfrom cte2 \nleft join cte3 on cte2.request_at = cte3.trip_date\n)\n--Select * from cte4\nSelect request_at as Day, Round(coalesce(cancelled_trips/ total_trips ,0),2) as Cancellation_Rate from cte4\n"
                    },
                    {
                        "username": "learningswithsrijan",
                        "content": "Using a trivial method of writing query, I able to pass all the test cases with the given set of data in SSMS. But here, for below test case, it shows Wrong Answer and fails the submit. Can someone help me identify the issue ?\\n\\nSQL Query\\n\"with cte_totalreq\\nas\\n(select \\ncount(T.status) as [TotalReqsOnADay], T.request_at\\nfrom \\nTrips T\\nwhere \\nclient_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\nand driver_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\ngroup by request_at),\\ncte_cancelledreq as\\n(select \\ncount(T.status) as [CancelledReq], T.request_at\\nfrom \\nTrips T\\nwhere status not in (\\'completed\\')\\nand client_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\nand driver_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\ngroup by request_at)\\n\\nselect request_at as [Day], CONVERT(DECIMAL(3,2),ISNULL((CONVERT(DECIMAL(3,2),(select [CancelledReq] from cte_cancelledreq cancelled where cancelled.request_at = totalreq.request_at)) / CONVERT(DECIMAL(3,2),TotalReqsOnADay)),0)) as [Cancellation Rate]\\nfrom cte_totalreq totalreq\\n\"\\n\\nTest case data and result in SSMS -\\nResult\\nDay\\tCancellation Rate\\n2013-10-04\\t1.00\\n\\nTrips\\nid\\tclient_id\\tdriver_id\\tcity_id\\tstatus\\trequest_at\\n11\\t1\\t10\\t1\\tcancelled_by_client\\t2013-10-04\\n\\nUsers\\nusers_id\\tbanned\\trole\\n1\\tNo\\tclient\\n10\\tNo\\tdriver"
                    },
                    {
                        "username": "yashgada99",
                        "content": "Any idea why Leetcode gives this error while loading the coding environment? \\n(The right half of the page, where coding is to be done, is not getting ready and loading indefinitely)\\nError - `(1054, \"Unknown column \\'problemset_codedefinition.react\\' in \\'field list\\'\")`"
                    },
                    {
                        "username": "azuregcp",
                        "content": "This should be medium. "
                    },
                    {
                        "username": "shailen86",
                        "content": "The output is coming correct as per demo given. But while running the code the output is comparing with some other expected result where there is just decimal places difference.\nE.g. I am getting 0.00 and they showing 0 and same with next one where my output is 0.50 and there is coming 0.5"
                    }
                ]
            },
            {
                "id": 2030164,
                "content": [
                    {
                        "username": "leetciel5577",
                        "content": "Is there any idea what\\'s the issue with my answer? It passes all the other testcase, but the following one. Thanks a lot!\\n\\nInput\\nTrips =\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | Yes    | driver |\\n\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\n\\n-----------------------------------------------------------------------------\\n\\n\\n\\n\\nwith cte as(\\nselect *\\nfrom trips t join users u\\non t.client_id=u.users_id\\nwhere u.banned!=\\'Yes\\'\\n)\\n\\nselect request_at as Day , \\nround(sum(case when status!=\\'completed\\' then 1 else 0 end)/count(status) ,2) as \\'Cancellation Rate\\'\\nfrom cte\\ngroup by request_at \\nhaving request_at between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "johnzaheer",
                        "content": "It\\u2019s broken, my code ran into the same issue so i created a work around then the output changed to the opposite. Depending on which version of my code i ran the output would be different for this exact case as well. "
                    },
                    {
                        "username": "johnzaheer",
                        "content": "Brocken test case exist, where there is just 1 input that is completed the expected changes depending on your output. \\n\\neven created workaround to null if no canceled status exist, but then the expected changed to 0\\nleave as is so my code returns 0\\nthen the expected changes to null"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "It seems there is a misprint in Pandas Schema. I propose to use \\n```\\ndata = [[\\'1\\', \\'1\\', \\'10\\', \\'1\\', \\'completed\\', \\'2013-10-01\\'], [\\'2\\', \\'2\\', \\'11\\', \\'1\\', \\'cancelled_by_driver\\', \\'2013-10-01\\'], [\\'3\\', \\'3\\', \\'2\\', \\'6\\', \\'completed\\', \\'2013-10-01\\'], [\\'4\\', \\'4\\', \\'13\\', \\'6\\', \\'cancelled_by_client\\', \\'2013-10-01\\'], [\\'5\\', \\'1\\', \\'10\\', \\'1\\', \\'completed\\', \\'2013-10-02\\'], [\\'6\\', \\'2\\', \\'11\\', \\'6\\', \\'completed\\', \\'2013-10-02\\'], [\\'7\\', \\'3\\', \\'12\\', \\'6\\', \\'completed\\', \\'2013-10-02\\'], [\\'8\\', \\'2\\', \\'12\\', \\'12\\', \\'completed\\', \\'2013-10-03\\'], [\\'9\\', \\'3\\', \\'10\\', \\'12\\', \\'completed\\', \\'2013-10-03\\'], [\\'10\\', \\'4\\', \\'13\\', \\'12\\', \\'cancelled_by_driver\\', \\'2013-10-03\\']]\\ntrips = pd.DataFrame(data, columns=[\\'id\\', \\'client_id\\', \\'driver_id\\', \\'city_id\\', \\'status\\', \\'request_at\\']).astype({\\'id\\':\\'Int64\\', \\'client_id\\':\\'Int64\\', \\'driver_id\\':\\'Int64\\', \\'city_id\\':\\'Int64\\', \\'status\\':\\'object\\', \\'request_at\\': \\'datetime64[ns]\\'})\\n\\ndata = [[\\'1\\', \\'No\\', \\'client\\'], [\\'2\\', \\'Yes\\', \\'client\\'], [\\'3\\', \\'No\\', \\'client\\'], [\\'4\\', \\'No\\', \\'client\\'], [\\'10\\', \\'No\\', \\'driver\\'], [\\'11\\', \\'No\\', \\'driver\\'], [\\'12\\', \\'No\\', \\'driver\\'], [\\'13\\', \\'No\\', \\'driver\\']]\\nusers = pd.DataFrame(data, columns=[\\'users_id\\', \\'banned\\', \\'role\\']).astype({\\'users_id\\':\\'Int64\\', \\'banned\\':\\'object\\', \\'role\\':\\'object\\'})\\n``` \\ninstead."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "AlexeySumin",
                        "content": "Hello!\nI have a working sql code, it executes well on mysql, but when i execute in on MsSQL(here, not in real one), i face an issue wis dividing values, it returns zeros.\nIve already met such issues on leetcode, am i the only who faced it?\n\nwith cte as (\n    select \n    t.request_at\n    , CASE when t.status = 'completed' then 'ok' else 'cancel' end as status_new\n    , COUNT(1) as cnt\n    from Trips as t\n    inner join Users as c On t.client_id = c.users_id \n    inner join Users as d On t.driver_id = d.users_id \n    where\n        t.request_at between CAST('2013-10-01' as DATE) and CAST('2013-10-03' as DATE) AND c.banned = 'No' AND d.banned = 'No'\n    group by \n        t.request_at, CASE when t.status = 'completed' then 'ok' else 'cancel' end\n)\nSELECT \ncte.request_at as Day\n,  ROUND(SUM(CASE when cte.status_new = 'cancel' then cte.cnt else 0 end) / SUM(cte.cnt), 2) as \"Cancellation Rate\"\nFROM \n    cte\nGROUP BY \n    cte.request_at\n"
                    },
                    {
                        "username": "addy022",
                        "content": "Can someone Fix and Explain what's wrong with the below query?\nI am getting below output\n| Day        | Cancellation_Rate |\n| ---------- | ----------------- |\n| 2013-10-01 | 0                 |\n| 2013-10-02 | 0                 |\n| 2013-10-03 | 0                 |\n\n/* Write your PL/SQL query statement below */\n-- filtered banned user/driver rows, date range\nwith cte as (\nSelect t.id, t.client_id, t.driver_id, t.status, t.request_at\nfrom trips t\ninner join users u on\nt.client_id = u.users_id and u.banned = 'No'\ninner join users u2 on\nt.driver_id = u2.users_id and u2.banned = 'No'\nwhere t.request_at between '2013-10-01' and '2013-10-03'\n)\n,\n-- total trips per day\ncte2 as (\nSelect count(id) as total_trips,  \nrequest_at from cte group by request_at \n)\n,\n-- cancelled trips per day\ncte3 as (\n  Select count(id) as cancelled_trips,  \nrequest_at as trip_date from cte  where status != 'completed' group by request_at\n),\n\ncte4 as\n(Select cte2.*, cte3.*\nfrom cte2 \nleft join cte3 on cte2.request_at = cte3.trip_date\n)\n--Select * from cte4\nSelect request_at as Day, Round(coalesce(cancelled_trips/ total_trips ,0),2) as Cancellation_Rate from cte4\n"
                    },
                    {
                        "username": "learningswithsrijan",
                        "content": "Using a trivial method of writing query, I able to pass all the test cases with the given set of data in SSMS. But here, for below test case, it shows Wrong Answer and fails the submit. Can someone help me identify the issue ?\\n\\nSQL Query\\n\"with cte_totalreq\\nas\\n(select \\ncount(T.status) as [TotalReqsOnADay], T.request_at\\nfrom \\nTrips T\\nwhere \\nclient_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\nand driver_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\ngroup by request_at),\\ncte_cancelledreq as\\n(select \\ncount(T.status) as [CancelledReq], T.request_at\\nfrom \\nTrips T\\nwhere status not in (\\'completed\\')\\nand client_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\nand driver_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\ngroup by request_at)\\n\\nselect request_at as [Day], CONVERT(DECIMAL(3,2),ISNULL((CONVERT(DECIMAL(3,2),(select [CancelledReq] from cte_cancelledreq cancelled where cancelled.request_at = totalreq.request_at)) / CONVERT(DECIMAL(3,2),TotalReqsOnADay)),0)) as [Cancellation Rate]\\nfrom cte_totalreq totalreq\\n\"\\n\\nTest case data and result in SSMS -\\nResult\\nDay\\tCancellation Rate\\n2013-10-04\\t1.00\\n\\nTrips\\nid\\tclient_id\\tdriver_id\\tcity_id\\tstatus\\trequest_at\\n11\\t1\\t10\\t1\\tcancelled_by_client\\t2013-10-04\\n\\nUsers\\nusers_id\\tbanned\\trole\\n1\\tNo\\tclient\\n10\\tNo\\tdriver"
                    },
                    {
                        "username": "yashgada99",
                        "content": "Any idea why Leetcode gives this error while loading the coding environment? \\n(The right half of the page, where coding is to be done, is not getting ready and loading indefinitely)\\nError - `(1054, \"Unknown column \\'problemset_codedefinition.react\\' in \\'field list\\'\")`"
                    },
                    {
                        "username": "azuregcp",
                        "content": "This should be medium. "
                    },
                    {
                        "username": "shailen86",
                        "content": "The output is coming correct as per demo given. But while running the code the output is comparing with some other expected result where there is just decimal places difference.\nE.g. I am getting 0.00 and they showing 0 and same with next one where my output is 0.50 and there is coming 0.5"
                    }
                ]
            },
            {
                "id": 2023942,
                "content": [
                    {
                        "username": "leetciel5577",
                        "content": "Is there any idea what\\'s the issue with my answer? It passes all the other testcase, but the following one. Thanks a lot!\\n\\nInput\\nTrips =\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | Yes    | driver |\\n\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\n\\n-----------------------------------------------------------------------------\\n\\n\\n\\n\\nwith cte as(\\nselect *\\nfrom trips t join users u\\non t.client_id=u.users_id\\nwhere u.banned!=\\'Yes\\'\\n)\\n\\nselect request_at as Day , \\nround(sum(case when status!=\\'completed\\' then 1 else 0 end)/count(status) ,2) as \\'Cancellation Rate\\'\\nfrom cte\\ngroup by request_at \\nhaving request_at between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "johnzaheer",
                        "content": "It\\u2019s broken, my code ran into the same issue so i created a work around then the output changed to the opposite. Depending on which version of my code i ran the output would be different for this exact case as well. "
                    },
                    {
                        "username": "johnzaheer",
                        "content": "Brocken test case exist, where there is just 1 input that is completed the expected changes depending on your output. \\n\\neven created workaround to null if no canceled status exist, but then the expected changed to 0\\nleave as is so my code returns 0\\nthen the expected changes to null"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "It seems there is a misprint in Pandas Schema. I propose to use \\n```\\ndata = [[\\'1\\', \\'1\\', \\'10\\', \\'1\\', \\'completed\\', \\'2013-10-01\\'], [\\'2\\', \\'2\\', \\'11\\', \\'1\\', \\'cancelled_by_driver\\', \\'2013-10-01\\'], [\\'3\\', \\'3\\', \\'2\\', \\'6\\', \\'completed\\', \\'2013-10-01\\'], [\\'4\\', \\'4\\', \\'13\\', \\'6\\', \\'cancelled_by_client\\', \\'2013-10-01\\'], [\\'5\\', \\'1\\', \\'10\\', \\'1\\', \\'completed\\', \\'2013-10-02\\'], [\\'6\\', \\'2\\', \\'11\\', \\'6\\', \\'completed\\', \\'2013-10-02\\'], [\\'7\\', \\'3\\', \\'12\\', \\'6\\', \\'completed\\', \\'2013-10-02\\'], [\\'8\\', \\'2\\', \\'12\\', \\'12\\', \\'completed\\', \\'2013-10-03\\'], [\\'9\\', \\'3\\', \\'10\\', \\'12\\', \\'completed\\', \\'2013-10-03\\'], [\\'10\\', \\'4\\', \\'13\\', \\'12\\', \\'cancelled_by_driver\\', \\'2013-10-03\\']]\\ntrips = pd.DataFrame(data, columns=[\\'id\\', \\'client_id\\', \\'driver_id\\', \\'city_id\\', \\'status\\', \\'request_at\\']).astype({\\'id\\':\\'Int64\\', \\'client_id\\':\\'Int64\\', \\'driver_id\\':\\'Int64\\', \\'city_id\\':\\'Int64\\', \\'status\\':\\'object\\', \\'request_at\\': \\'datetime64[ns]\\'})\\n\\ndata = [[\\'1\\', \\'No\\', \\'client\\'], [\\'2\\', \\'Yes\\', \\'client\\'], [\\'3\\', \\'No\\', \\'client\\'], [\\'4\\', \\'No\\', \\'client\\'], [\\'10\\', \\'No\\', \\'driver\\'], [\\'11\\', \\'No\\', \\'driver\\'], [\\'12\\', \\'No\\', \\'driver\\'], [\\'13\\', \\'No\\', \\'driver\\']]\\nusers = pd.DataFrame(data, columns=[\\'users_id\\', \\'banned\\', \\'role\\']).astype({\\'users_id\\':\\'Int64\\', \\'banned\\':\\'object\\', \\'role\\':\\'object\\'})\\n``` \\ninstead."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "AlexeySumin",
                        "content": "Hello!\nI have a working sql code, it executes well on mysql, but when i execute in on MsSQL(here, not in real one), i face an issue wis dividing values, it returns zeros.\nIve already met such issues on leetcode, am i the only who faced it?\n\nwith cte as (\n    select \n    t.request_at\n    , CASE when t.status = 'completed' then 'ok' else 'cancel' end as status_new\n    , COUNT(1) as cnt\n    from Trips as t\n    inner join Users as c On t.client_id = c.users_id \n    inner join Users as d On t.driver_id = d.users_id \n    where\n        t.request_at between CAST('2013-10-01' as DATE) and CAST('2013-10-03' as DATE) AND c.banned = 'No' AND d.banned = 'No'\n    group by \n        t.request_at, CASE when t.status = 'completed' then 'ok' else 'cancel' end\n)\nSELECT \ncte.request_at as Day\n,  ROUND(SUM(CASE when cte.status_new = 'cancel' then cte.cnt else 0 end) / SUM(cte.cnt), 2) as \"Cancellation Rate\"\nFROM \n    cte\nGROUP BY \n    cte.request_at\n"
                    },
                    {
                        "username": "addy022",
                        "content": "Can someone Fix and Explain what's wrong with the below query?\nI am getting below output\n| Day        | Cancellation_Rate |\n| ---------- | ----------------- |\n| 2013-10-01 | 0                 |\n| 2013-10-02 | 0                 |\n| 2013-10-03 | 0                 |\n\n/* Write your PL/SQL query statement below */\n-- filtered banned user/driver rows, date range\nwith cte as (\nSelect t.id, t.client_id, t.driver_id, t.status, t.request_at\nfrom trips t\ninner join users u on\nt.client_id = u.users_id and u.banned = 'No'\ninner join users u2 on\nt.driver_id = u2.users_id and u2.banned = 'No'\nwhere t.request_at between '2013-10-01' and '2013-10-03'\n)\n,\n-- total trips per day\ncte2 as (\nSelect count(id) as total_trips,  \nrequest_at from cte group by request_at \n)\n,\n-- cancelled trips per day\ncte3 as (\n  Select count(id) as cancelled_trips,  \nrequest_at as trip_date from cte  where status != 'completed' group by request_at\n),\n\ncte4 as\n(Select cte2.*, cte3.*\nfrom cte2 \nleft join cte3 on cte2.request_at = cte3.trip_date\n)\n--Select * from cte4\nSelect request_at as Day, Round(coalesce(cancelled_trips/ total_trips ,0),2) as Cancellation_Rate from cte4\n"
                    },
                    {
                        "username": "learningswithsrijan",
                        "content": "Using a trivial method of writing query, I able to pass all the test cases with the given set of data in SSMS. But here, for below test case, it shows Wrong Answer and fails the submit. Can someone help me identify the issue ?\\n\\nSQL Query\\n\"with cte_totalreq\\nas\\n(select \\ncount(T.status) as [TotalReqsOnADay], T.request_at\\nfrom \\nTrips T\\nwhere \\nclient_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\nand driver_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\ngroup by request_at),\\ncte_cancelledreq as\\n(select \\ncount(T.status) as [CancelledReq], T.request_at\\nfrom \\nTrips T\\nwhere status not in (\\'completed\\')\\nand client_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\nand driver_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\ngroup by request_at)\\n\\nselect request_at as [Day], CONVERT(DECIMAL(3,2),ISNULL((CONVERT(DECIMAL(3,2),(select [CancelledReq] from cte_cancelledreq cancelled where cancelled.request_at = totalreq.request_at)) / CONVERT(DECIMAL(3,2),TotalReqsOnADay)),0)) as [Cancellation Rate]\\nfrom cte_totalreq totalreq\\n\"\\n\\nTest case data and result in SSMS -\\nResult\\nDay\\tCancellation Rate\\n2013-10-04\\t1.00\\n\\nTrips\\nid\\tclient_id\\tdriver_id\\tcity_id\\tstatus\\trequest_at\\n11\\t1\\t10\\t1\\tcancelled_by_client\\t2013-10-04\\n\\nUsers\\nusers_id\\tbanned\\trole\\n1\\tNo\\tclient\\n10\\tNo\\tdriver"
                    },
                    {
                        "username": "yashgada99",
                        "content": "Any idea why Leetcode gives this error while loading the coding environment? \\n(The right half of the page, where coding is to be done, is not getting ready and loading indefinitely)\\nError - `(1054, \"Unknown column \\'problemset_codedefinition.react\\' in \\'field list\\'\")`"
                    },
                    {
                        "username": "azuregcp",
                        "content": "This should be medium. "
                    },
                    {
                        "username": "shailen86",
                        "content": "The output is coming correct as per demo given. But while running the code the output is comparing with some other expected result where there is just decimal places difference.\nE.g. I am getting 0.00 and they showing 0 and same with next one where my output is 0.50 and there is coming 0.5"
                    }
                ]
            },
            {
                "id": 1967980,
                "content": [
                    {
                        "username": "leetciel5577",
                        "content": "Is there any idea what\\'s the issue with my answer? It passes all the other testcase, but the following one. Thanks a lot!\\n\\nInput\\nTrips =\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | Yes    | driver |\\n\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\n\\n-----------------------------------------------------------------------------\\n\\n\\n\\n\\nwith cte as(\\nselect *\\nfrom trips t join users u\\non t.client_id=u.users_id\\nwhere u.banned!=\\'Yes\\'\\n)\\n\\nselect request_at as Day , \\nround(sum(case when status!=\\'completed\\' then 1 else 0 end)/count(status) ,2) as \\'Cancellation Rate\\'\\nfrom cte\\ngroup by request_at \\nhaving request_at between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "johnzaheer",
                        "content": "It\\u2019s broken, my code ran into the same issue so i created a work around then the output changed to the opposite. Depending on which version of my code i ran the output would be different for this exact case as well. "
                    },
                    {
                        "username": "johnzaheer",
                        "content": "Brocken test case exist, where there is just 1 input that is completed the expected changes depending on your output. \\n\\neven created workaround to null if no canceled status exist, but then the expected changed to 0\\nleave as is so my code returns 0\\nthen the expected changes to null"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "It seems there is a misprint in Pandas Schema. I propose to use \\n```\\ndata = [[\\'1\\', \\'1\\', \\'10\\', \\'1\\', \\'completed\\', \\'2013-10-01\\'], [\\'2\\', \\'2\\', \\'11\\', \\'1\\', \\'cancelled_by_driver\\', \\'2013-10-01\\'], [\\'3\\', \\'3\\', \\'2\\', \\'6\\', \\'completed\\', \\'2013-10-01\\'], [\\'4\\', \\'4\\', \\'13\\', \\'6\\', \\'cancelled_by_client\\', \\'2013-10-01\\'], [\\'5\\', \\'1\\', \\'10\\', \\'1\\', \\'completed\\', \\'2013-10-02\\'], [\\'6\\', \\'2\\', \\'11\\', \\'6\\', \\'completed\\', \\'2013-10-02\\'], [\\'7\\', \\'3\\', \\'12\\', \\'6\\', \\'completed\\', \\'2013-10-02\\'], [\\'8\\', \\'2\\', \\'12\\', \\'12\\', \\'completed\\', \\'2013-10-03\\'], [\\'9\\', \\'3\\', \\'10\\', \\'12\\', \\'completed\\', \\'2013-10-03\\'], [\\'10\\', \\'4\\', \\'13\\', \\'12\\', \\'cancelled_by_driver\\', \\'2013-10-03\\']]\\ntrips = pd.DataFrame(data, columns=[\\'id\\', \\'client_id\\', \\'driver_id\\', \\'city_id\\', \\'status\\', \\'request_at\\']).astype({\\'id\\':\\'Int64\\', \\'client_id\\':\\'Int64\\', \\'driver_id\\':\\'Int64\\', \\'city_id\\':\\'Int64\\', \\'status\\':\\'object\\', \\'request_at\\': \\'datetime64[ns]\\'})\\n\\ndata = [[\\'1\\', \\'No\\', \\'client\\'], [\\'2\\', \\'Yes\\', \\'client\\'], [\\'3\\', \\'No\\', \\'client\\'], [\\'4\\', \\'No\\', \\'client\\'], [\\'10\\', \\'No\\', \\'driver\\'], [\\'11\\', \\'No\\', \\'driver\\'], [\\'12\\', \\'No\\', \\'driver\\'], [\\'13\\', \\'No\\', \\'driver\\']]\\nusers = pd.DataFrame(data, columns=[\\'users_id\\', \\'banned\\', \\'role\\']).astype({\\'users_id\\':\\'Int64\\', \\'banned\\':\\'object\\', \\'role\\':\\'object\\'})\\n``` \\ninstead."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "AlexeySumin",
                        "content": "Hello!\nI have a working sql code, it executes well on mysql, but when i execute in on MsSQL(here, not in real one), i face an issue wis dividing values, it returns zeros.\nIve already met such issues on leetcode, am i the only who faced it?\n\nwith cte as (\n    select \n    t.request_at\n    , CASE when t.status = 'completed' then 'ok' else 'cancel' end as status_new\n    , COUNT(1) as cnt\n    from Trips as t\n    inner join Users as c On t.client_id = c.users_id \n    inner join Users as d On t.driver_id = d.users_id \n    where\n        t.request_at between CAST('2013-10-01' as DATE) and CAST('2013-10-03' as DATE) AND c.banned = 'No' AND d.banned = 'No'\n    group by \n        t.request_at, CASE when t.status = 'completed' then 'ok' else 'cancel' end\n)\nSELECT \ncte.request_at as Day\n,  ROUND(SUM(CASE when cte.status_new = 'cancel' then cte.cnt else 0 end) / SUM(cte.cnt), 2) as \"Cancellation Rate\"\nFROM \n    cte\nGROUP BY \n    cte.request_at\n"
                    },
                    {
                        "username": "addy022",
                        "content": "Can someone Fix and Explain what's wrong with the below query?\nI am getting below output\n| Day        | Cancellation_Rate |\n| ---------- | ----------------- |\n| 2013-10-01 | 0                 |\n| 2013-10-02 | 0                 |\n| 2013-10-03 | 0                 |\n\n/* Write your PL/SQL query statement below */\n-- filtered banned user/driver rows, date range\nwith cte as (\nSelect t.id, t.client_id, t.driver_id, t.status, t.request_at\nfrom trips t\ninner join users u on\nt.client_id = u.users_id and u.banned = 'No'\ninner join users u2 on\nt.driver_id = u2.users_id and u2.banned = 'No'\nwhere t.request_at between '2013-10-01' and '2013-10-03'\n)\n,\n-- total trips per day\ncte2 as (\nSelect count(id) as total_trips,  \nrequest_at from cte group by request_at \n)\n,\n-- cancelled trips per day\ncte3 as (\n  Select count(id) as cancelled_trips,  \nrequest_at as trip_date from cte  where status != 'completed' group by request_at\n),\n\ncte4 as\n(Select cte2.*, cte3.*\nfrom cte2 \nleft join cte3 on cte2.request_at = cte3.trip_date\n)\n--Select * from cte4\nSelect request_at as Day, Round(coalesce(cancelled_trips/ total_trips ,0),2) as Cancellation_Rate from cte4\n"
                    },
                    {
                        "username": "learningswithsrijan",
                        "content": "Using a trivial method of writing query, I able to pass all the test cases with the given set of data in SSMS. But here, for below test case, it shows Wrong Answer and fails the submit. Can someone help me identify the issue ?\\n\\nSQL Query\\n\"with cte_totalreq\\nas\\n(select \\ncount(T.status) as [TotalReqsOnADay], T.request_at\\nfrom \\nTrips T\\nwhere \\nclient_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\nand driver_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\ngroup by request_at),\\ncte_cancelledreq as\\n(select \\ncount(T.status) as [CancelledReq], T.request_at\\nfrom \\nTrips T\\nwhere status not in (\\'completed\\')\\nand client_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\nand driver_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\ngroup by request_at)\\n\\nselect request_at as [Day], CONVERT(DECIMAL(3,2),ISNULL((CONVERT(DECIMAL(3,2),(select [CancelledReq] from cte_cancelledreq cancelled where cancelled.request_at = totalreq.request_at)) / CONVERT(DECIMAL(3,2),TotalReqsOnADay)),0)) as [Cancellation Rate]\\nfrom cte_totalreq totalreq\\n\"\\n\\nTest case data and result in SSMS -\\nResult\\nDay\\tCancellation Rate\\n2013-10-04\\t1.00\\n\\nTrips\\nid\\tclient_id\\tdriver_id\\tcity_id\\tstatus\\trequest_at\\n11\\t1\\t10\\t1\\tcancelled_by_client\\t2013-10-04\\n\\nUsers\\nusers_id\\tbanned\\trole\\n1\\tNo\\tclient\\n10\\tNo\\tdriver"
                    },
                    {
                        "username": "yashgada99",
                        "content": "Any idea why Leetcode gives this error while loading the coding environment? \\n(The right half of the page, where coding is to be done, is not getting ready and loading indefinitely)\\nError - `(1054, \"Unknown column \\'problemset_codedefinition.react\\' in \\'field list\\'\")`"
                    },
                    {
                        "username": "azuregcp",
                        "content": "This should be medium. "
                    },
                    {
                        "username": "shailen86",
                        "content": "The output is coming correct as per demo given. But while running the code the output is comparing with some other expected result where there is just decimal places difference.\nE.g. I am getting 0.00 and they showing 0 and same with next one where my output is 0.50 and there is coming 0.5"
                    }
                ]
            },
            {
                "id": 1966229,
                "content": [
                    {
                        "username": "leetciel5577",
                        "content": "Is there any idea what\\'s the issue with my answer? It passes all the other testcase, but the following one. Thanks a lot!\\n\\nInput\\nTrips =\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | Yes    | driver |\\n\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\n\\n-----------------------------------------------------------------------------\\n\\n\\n\\n\\nwith cte as(\\nselect *\\nfrom trips t join users u\\non t.client_id=u.users_id\\nwhere u.banned!=\\'Yes\\'\\n)\\n\\nselect request_at as Day , \\nround(sum(case when status!=\\'completed\\' then 1 else 0 end)/count(status) ,2) as \\'Cancellation Rate\\'\\nfrom cte\\ngroup by request_at \\nhaving request_at between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "johnzaheer",
                        "content": "It\\u2019s broken, my code ran into the same issue so i created a work around then the output changed to the opposite. Depending on which version of my code i ran the output would be different for this exact case as well. "
                    },
                    {
                        "username": "johnzaheer",
                        "content": "Brocken test case exist, where there is just 1 input that is completed the expected changes depending on your output. \\n\\neven created workaround to null if no canceled status exist, but then the expected changed to 0\\nleave as is so my code returns 0\\nthen the expected changes to null"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "It seems there is a misprint in Pandas Schema. I propose to use \\n```\\ndata = [[\\'1\\', \\'1\\', \\'10\\', \\'1\\', \\'completed\\', \\'2013-10-01\\'], [\\'2\\', \\'2\\', \\'11\\', \\'1\\', \\'cancelled_by_driver\\', \\'2013-10-01\\'], [\\'3\\', \\'3\\', \\'2\\', \\'6\\', \\'completed\\', \\'2013-10-01\\'], [\\'4\\', \\'4\\', \\'13\\', \\'6\\', \\'cancelled_by_client\\', \\'2013-10-01\\'], [\\'5\\', \\'1\\', \\'10\\', \\'1\\', \\'completed\\', \\'2013-10-02\\'], [\\'6\\', \\'2\\', \\'11\\', \\'6\\', \\'completed\\', \\'2013-10-02\\'], [\\'7\\', \\'3\\', \\'12\\', \\'6\\', \\'completed\\', \\'2013-10-02\\'], [\\'8\\', \\'2\\', \\'12\\', \\'12\\', \\'completed\\', \\'2013-10-03\\'], [\\'9\\', \\'3\\', \\'10\\', \\'12\\', \\'completed\\', \\'2013-10-03\\'], [\\'10\\', \\'4\\', \\'13\\', \\'12\\', \\'cancelled_by_driver\\', \\'2013-10-03\\']]\\ntrips = pd.DataFrame(data, columns=[\\'id\\', \\'client_id\\', \\'driver_id\\', \\'city_id\\', \\'status\\', \\'request_at\\']).astype({\\'id\\':\\'Int64\\', \\'client_id\\':\\'Int64\\', \\'driver_id\\':\\'Int64\\', \\'city_id\\':\\'Int64\\', \\'status\\':\\'object\\', \\'request_at\\': \\'datetime64[ns]\\'})\\n\\ndata = [[\\'1\\', \\'No\\', \\'client\\'], [\\'2\\', \\'Yes\\', \\'client\\'], [\\'3\\', \\'No\\', \\'client\\'], [\\'4\\', \\'No\\', \\'client\\'], [\\'10\\', \\'No\\', \\'driver\\'], [\\'11\\', \\'No\\', \\'driver\\'], [\\'12\\', \\'No\\', \\'driver\\'], [\\'13\\', \\'No\\', \\'driver\\']]\\nusers = pd.DataFrame(data, columns=[\\'users_id\\', \\'banned\\', \\'role\\']).astype({\\'users_id\\':\\'Int64\\', \\'banned\\':\\'object\\', \\'role\\':\\'object\\'})\\n``` \\ninstead."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "AlexeySumin",
                        "content": "Hello!\nI have a working sql code, it executes well on mysql, but when i execute in on MsSQL(here, not in real one), i face an issue wis dividing values, it returns zeros.\nIve already met such issues on leetcode, am i the only who faced it?\n\nwith cte as (\n    select \n    t.request_at\n    , CASE when t.status = 'completed' then 'ok' else 'cancel' end as status_new\n    , COUNT(1) as cnt\n    from Trips as t\n    inner join Users as c On t.client_id = c.users_id \n    inner join Users as d On t.driver_id = d.users_id \n    where\n        t.request_at between CAST('2013-10-01' as DATE) and CAST('2013-10-03' as DATE) AND c.banned = 'No' AND d.banned = 'No'\n    group by \n        t.request_at, CASE when t.status = 'completed' then 'ok' else 'cancel' end\n)\nSELECT \ncte.request_at as Day\n,  ROUND(SUM(CASE when cte.status_new = 'cancel' then cte.cnt else 0 end) / SUM(cte.cnt), 2) as \"Cancellation Rate\"\nFROM \n    cte\nGROUP BY \n    cte.request_at\n"
                    },
                    {
                        "username": "addy022",
                        "content": "Can someone Fix and Explain what's wrong with the below query?\nI am getting below output\n| Day        | Cancellation_Rate |\n| ---------- | ----------------- |\n| 2013-10-01 | 0                 |\n| 2013-10-02 | 0                 |\n| 2013-10-03 | 0                 |\n\n/* Write your PL/SQL query statement below */\n-- filtered banned user/driver rows, date range\nwith cte as (\nSelect t.id, t.client_id, t.driver_id, t.status, t.request_at\nfrom trips t\ninner join users u on\nt.client_id = u.users_id and u.banned = 'No'\ninner join users u2 on\nt.driver_id = u2.users_id and u2.banned = 'No'\nwhere t.request_at between '2013-10-01' and '2013-10-03'\n)\n,\n-- total trips per day\ncte2 as (\nSelect count(id) as total_trips,  \nrequest_at from cte group by request_at \n)\n,\n-- cancelled trips per day\ncte3 as (\n  Select count(id) as cancelled_trips,  \nrequest_at as trip_date from cte  where status != 'completed' group by request_at\n),\n\ncte4 as\n(Select cte2.*, cte3.*\nfrom cte2 \nleft join cte3 on cte2.request_at = cte3.trip_date\n)\n--Select * from cte4\nSelect request_at as Day, Round(coalesce(cancelled_trips/ total_trips ,0),2) as Cancellation_Rate from cte4\n"
                    },
                    {
                        "username": "learningswithsrijan",
                        "content": "Using a trivial method of writing query, I able to pass all the test cases with the given set of data in SSMS. But here, for below test case, it shows Wrong Answer and fails the submit. Can someone help me identify the issue ?\\n\\nSQL Query\\n\"with cte_totalreq\\nas\\n(select \\ncount(T.status) as [TotalReqsOnADay], T.request_at\\nfrom \\nTrips T\\nwhere \\nclient_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\nand driver_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\ngroup by request_at),\\ncte_cancelledreq as\\n(select \\ncount(T.status) as [CancelledReq], T.request_at\\nfrom \\nTrips T\\nwhere status not in (\\'completed\\')\\nand client_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\nand driver_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\ngroup by request_at)\\n\\nselect request_at as [Day], CONVERT(DECIMAL(3,2),ISNULL((CONVERT(DECIMAL(3,2),(select [CancelledReq] from cte_cancelledreq cancelled where cancelled.request_at = totalreq.request_at)) / CONVERT(DECIMAL(3,2),TotalReqsOnADay)),0)) as [Cancellation Rate]\\nfrom cte_totalreq totalreq\\n\"\\n\\nTest case data and result in SSMS -\\nResult\\nDay\\tCancellation Rate\\n2013-10-04\\t1.00\\n\\nTrips\\nid\\tclient_id\\tdriver_id\\tcity_id\\tstatus\\trequest_at\\n11\\t1\\t10\\t1\\tcancelled_by_client\\t2013-10-04\\n\\nUsers\\nusers_id\\tbanned\\trole\\n1\\tNo\\tclient\\n10\\tNo\\tdriver"
                    },
                    {
                        "username": "yashgada99",
                        "content": "Any idea why Leetcode gives this error while loading the coding environment? \\n(The right half of the page, where coding is to be done, is not getting ready and loading indefinitely)\\nError - `(1054, \"Unknown column \\'problemset_codedefinition.react\\' in \\'field list\\'\")`"
                    },
                    {
                        "username": "azuregcp",
                        "content": "This should be medium. "
                    },
                    {
                        "username": "shailen86",
                        "content": "The output is coming correct as per demo given. But while running the code the output is comparing with some other expected result where there is just decimal places difference.\nE.g. I am getting 0.00 and they showing 0 and same with next one where my output is 0.50 and there is coming 0.5"
                    }
                ]
            },
            {
                "id": 1961011,
                "content": [
                    {
                        "username": "leetciel5577",
                        "content": "Is there any idea what\\'s the issue with my answer? It passes all the other testcase, but the following one. Thanks a lot!\\n\\nInput\\nTrips =\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | Yes    | driver |\\n\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\n\\n-----------------------------------------------------------------------------\\n\\n\\n\\n\\nwith cte as(\\nselect *\\nfrom trips t join users u\\non t.client_id=u.users_id\\nwhere u.banned!=\\'Yes\\'\\n)\\n\\nselect request_at as Day , \\nround(sum(case when status!=\\'completed\\' then 1 else 0 end)/count(status) ,2) as \\'Cancellation Rate\\'\\nfrom cte\\ngroup by request_at \\nhaving request_at between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "johnzaheer",
                        "content": "It\\u2019s broken, my code ran into the same issue so i created a work around then the output changed to the opposite. Depending on which version of my code i ran the output would be different for this exact case as well. "
                    },
                    {
                        "username": "johnzaheer",
                        "content": "Brocken test case exist, where there is just 1 input that is completed the expected changes depending on your output. \\n\\neven created workaround to null if no canceled status exist, but then the expected changed to 0\\nleave as is so my code returns 0\\nthen the expected changes to null"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "It seems there is a misprint in Pandas Schema. I propose to use \\n```\\ndata = [[\\'1\\', \\'1\\', \\'10\\', \\'1\\', \\'completed\\', \\'2013-10-01\\'], [\\'2\\', \\'2\\', \\'11\\', \\'1\\', \\'cancelled_by_driver\\', \\'2013-10-01\\'], [\\'3\\', \\'3\\', \\'2\\', \\'6\\', \\'completed\\', \\'2013-10-01\\'], [\\'4\\', \\'4\\', \\'13\\', \\'6\\', \\'cancelled_by_client\\', \\'2013-10-01\\'], [\\'5\\', \\'1\\', \\'10\\', \\'1\\', \\'completed\\', \\'2013-10-02\\'], [\\'6\\', \\'2\\', \\'11\\', \\'6\\', \\'completed\\', \\'2013-10-02\\'], [\\'7\\', \\'3\\', \\'12\\', \\'6\\', \\'completed\\', \\'2013-10-02\\'], [\\'8\\', \\'2\\', \\'12\\', \\'12\\', \\'completed\\', \\'2013-10-03\\'], [\\'9\\', \\'3\\', \\'10\\', \\'12\\', \\'completed\\', \\'2013-10-03\\'], [\\'10\\', \\'4\\', \\'13\\', \\'12\\', \\'cancelled_by_driver\\', \\'2013-10-03\\']]\\ntrips = pd.DataFrame(data, columns=[\\'id\\', \\'client_id\\', \\'driver_id\\', \\'city_id\\', \\'status\\', \\'request_at\\']).astype({\\'id\\':\\'Int64\\', \\'client_id\\':\\'Int64\\', \\'driver_id\\':\\'Int64\\', \\'city_id\\':\\'Int64\\', \\'status\\':\\'object\\', \\'request_at\\': \\'datetime64[ns]\\'})\\n\\ndata = [[\\'1\\', \\'No\\', \\'client\\'], [\\'2\\', \\'Yes\\', \\'client\\'], [\\'3\\', \\'No\\', \\'client\\'], [\\'4\\', \\'No\\', \\'client\\'], [\\'10\\', \\'No\\', \\'driver\\'], [\\'11\\', \\'No\\', \\'driver\\'], [\\'12\\', \\'No\\', \\'driver\\'], [\\'13\\', \\'No\\', \\'driver\\']]\\nusers = pd.DataFrame(data, columns=[\\'users_id\\', \\'banned\\', \\'role\\']).astype({\\'users_id\\':\\'Int64\\', \\'banned\\':\\'object\\', \\'role\\':\\'object\\'})\\n``` \\ninstead."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "AlexeySumin",
                        "content": "Hello!\nI have a working sql code, it executes well on mysql, but when i execute in on MsSQL(here, not in real one), i face an issue wis dividing values, it returns zeros.\nIve already met such issues on leetcode, am i the only who faced it?\n\nwith cte as (\n    select \n    t.request_at\n    , CASE when t.status = 'completed' then 'ok' else 'cancel' end as status_new\n    , COUNT(1) as cnt\n    from Trips as t\n    inner join Users as c On t.client_id = c.users_id \n    inner join Users as d On t.driver_id = d.users_id \n    where\n        t.request_at between CAST('2013-10-01' as DATE) and CAST('2013-10-03' as DATE) AND c.banned = 'No' AND d.banned = 'No'\n    group by \n        t.request_at, CASE when t.status = 'completed' then 'ok' else 'cancel' end\n)\nSELECT \ncte.request_at as Day\n,  ROUND(SUM(CASE when cte.status_new = 'cancel' then cte.cnt else 0 end) / SUM(cte.cnt), 2) as \"Cancellation Rate\"\nFROM \n    cte\nGROUP BY \n    cte.request_at\n"
                    },
                    {
                        "username": "addy022",
                        "content": "Can someone Fix and Explain what's wrong with the below query?\nI am getting below output\n| Day        | Cancellation_Rate |\n| ---------- | ----------------- |\n| 2013-10-01 | 0                 |\n| 2013-10-02 | 0                 |\n| 2013-10-03 | 0                 |\n\n/* Write your PL/SQL query statement below */\n-- filtered banned user/driver rows, date range\nwith cte as (\nSelect t.id, t.client_id, t.driver_id, t.status, t.request_at\nfrom trips t\ninner join users u on\nt.client_id = u.users_id and u.banned = 'No'\ninner join users u2 on\nt.driver_id = u2.users_id and u2.banned = 'No'\nwhere t.request_at between '2013-10-01' and '2013-10-03'\n)\n,\n-- total trips per day\ncte2 as (\nSelect count(id) as total_trips,  \nrequest_at from cte group by request_at \n)\n,\n-- cancelled trips per day\ncte3 as (\n  Select count(id) as cancelled_trips,  \nrequest_at as trip_date from cte  where status != 'completed' group by request_at\n),\n\ncte4 as\n(Select cte2.*, cte3.*\nfrom cte2 \nleft join cte3 on cte2.request_at = cte3.trip_date\n)\n--Select * from cte4\nSelect request_at as Day, Round(coalesce(cancelled_trips/ total_trips ,0),2) as Cancellation_Rate from cte4\n"
                    },
                    {
                        "username": "learningswithsrijan",
                        "content": "Using a trivial method of writing query, I able to pass all the test cases with the given set of data in SSMS. But here, for below test case, it shows Wrong Answer and fails the submit. Can someone help me identify the issue ?\\n\\nSQL Query\\n\"with cte_totalreq\\nas\\n(select \\ncount(T.status) as [TotalReqsOnADay], T.request_at\\nfrom \\nTrips T\\nwhere \\nclient_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\nand driver_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\ngroup by request_at),\\ncte_cancelledreq as\\n(select \\ncount(T.status) as [CancelledReq], T.request_at\\nfrom \\nTrips T\\nwhere status not in (\\'completed\\')\\nand client_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\nand driver_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\ngroup by request_at)\\n\\nselect request_at as [Day], CONVERT(DECIMAL(3,2),ISNULL((CONVERT(DECIMAL(3,2),(select [CancelledReq] from cte_cancelledreq cancelled where cancelled.request_at = totalreq.request_at)) / CONVERT(DECIMAL(3,2),TotalReqsOnADay)),0)) as [Cancellation Rate]\\nfrom cte_totalreq totalreq\\n\"\\n\\nTest case data and result in SSMS -\\nResult\\nDay\\tCancellation Rate\\n2013-10-04\\t1.00\\n\\nTrips\\nid\\tclient_id\\tdriver_id\\tcity_id\\tstatus\\trequest_at\\n11\\t1\\t10\\t1\\tcancelled_by_client\\t2013-10-04\\n\\nUsers\\nusers_id\\tbanned\\trole\\n1\\tNo\\tclient\\n10\\tNo\\tdriver"
                    },
                    {
                        "username": "yashgada99",
                        "content": "Any idea why Leetcode gives this error while loading the coding environment? \\n(The right half of the page, where coding is to be done, is not getting ready and loading indefinitely)\\nError - `(1054, \"Unknown column \\'problemset_codedefinition.react\\' in \\'field list\\'\")`"
                    },
                    {
                        "username": "azuregcp",
                        "content": "This should be medium. "
                    },
                    {
                        "username": "shailen86",
                        "content": "The output is coming correct as per demo given. But while running the code the output is comparing with some other expected result where there is just decimal places difference.\nE.g. I am getting 0.00 and they showing 0 and same with next one where my output is 0.50 and there is coming 0.5"
                    }
                ]
            },
            {
                "id": 1957415,
                "content": [
                    {
                        "username": "leetciel5577",
                        "content": "Is there any idea what\\'s the issue with my answer? It passes all the other testcase, but the following one. Thanks a lot!\\n\\nInput\\nTrips =\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | Yes    | driver |\\n\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\n\\n-----------------------------------------------------------------------------\\n\\n\\n\\n\\nwith cte as(\\nselect *\\nfrom trips t join users u\\non t.client_id=u.users_id\\nwhere u.banned!=\\'Yes\\'\\n)\\n\\nselect request_at as Day , \\nround(sum(case when status!=\\'completed\\' then 1 else 0 end)/count(status) ,2) as \\'Cancellation Rate\\'\\nfrom cte\\ngroup by request_at \\nhaving request_at between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "johnzaheer",
                        "content": "It\\u2019s broken, my code ran into the same issue so i created a work around then the output changed to the opposite. Depending on which version of my code i ran the output would be different for this exact case as well. "
                    },
                    {
                        "username": "johnzaheer",
                        "content": "Brocken test case exist, where there is just 1 input that is completed the expected changes depending on your output. \\n\\neven created workaround to null if no canceled status exist, but then the expected changed to 0\\nleave as is so my code returns 0\\nthen the expected changes to null"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "It seems there is a misprint in Pandas Schema. I propose to use \\n```\\ndata = [[\\'1\\', \\'1\\', \\'10\\', \\'1\\', \\'completed\\', \\'2013-10-01\\'], [\\'2\\', \\'2\\', \\'11\\', \\'1\\', \\'cancelled_by_driver\\', \\'2013-10-01\\'], [\\'3\\', \\'3\\', \\'2\\', \\'6\\', \\'completed\\', \\'2013-10-01\\'], [\\'4\\', \\'4\\', \\'13\\', \\'6\\', \\'cancelled_by_client\\', \\'2013-10-01\\'], [\\'5\\', \\'1\\', \\'10\\', \\'1\\', \\'completed\\', \\'2013-10-02\\'], [\\'6\\', \\'2\\', \\'11\\', \\'6\\', \\'completed\\', \\'2013-10-02\\'], [\\'7\\', \\'3\\', \\'12\\', \\'6\\', \\'completed\\', \\'2013-10-02\\'], [\\'8\\', \\'2\\', \\'12\\', \\'12\\', \\'completed\\', \\'2013-10-03\\'], [\\'9\\', \\'3\\', \\'10\\', \\'12\\', \\'completed\\', \\'2013-10-03\\'], [\\'10\\', \\'4\\', \\'13\\', \\'12\\', \\'cancelled_by_driver\\', \\'2013-10-03\\']]\\ntrips = pd.DataFrame(data, columns=[\\'id\\', \\'client_id\\', \\'driver_id\\', \\'city_id\\', \\'status\\', \\'request_at\\']).astype({\\'id\\':\\'Int64\\', \\'client_id\\':\\'Int64\\', \\'driver_id\\':\\'Int64\\', \\'city_id\\':\\'Int64\\', \\'status\\':\\'object\\', \\'request_at\\': \\'datetime64[ns]\\'})\\n\\ndata = [[\\'1\\', \\'No\\', \\'client\\'], [\\'2\\', \\'Yes\\', \\'client\\'], [\\'3\\', \\'No\\', \\'client\\'], [\\'4\\', \\'No\\', \\'client\\'], [\\'10\\', \\'No\\', \\'driver\\'], [\\'11\\', \\'No\\', \\'driver\\'], [\\'12\\', \\'No\\', \\'driver\\'], [\\'13\\', \\'No\\', \\'driver\\']]\\nusers = pd.DataFrame(data, columns=[\\'users_id\\', \\'banned\\', \\'role\\']).astype({\\'users_id\\':\\'Int64\\', \\'banned\\':\\'object\\', \\'role\\':\\'object\\'})\\n``` \\ninstead."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "AlexeySumin",
                        "content": "Hello!\nI have a working sql code, it executes well on mysql, but when i execute in on MsSQL(here, not in real one), i face an issue wis dividing values, it returns zeros.\nIve already met such issues on leetcode, am i the only who faced it?\n\nwith cte as (\n    select \n    t.request_at\n    , CASE when t.status = 'completed' then 'ok' else 'cancel' end as status_new\n    , COUNT(1) as cnt\n    from Trips as t\n    inner join Users as c On t.client_id = c.users_id \n    inner join Users as d On t.driver_id = d.users_id \n    where\n        t.request_at between CAST('2013-10-01' as DATE) and CAST('2013-10-03' as DATE) AND c.banned = 'No' AND d.banned = 'No'\n    group by \n        t.request_at, CASE when t.status = 'completed' then 'ok' else 'cancel' end\n)\nSELECT \ncte.request_at as Day\n,  ROUND(SUM(CASE when cte.status_new = 'cancel' then cte.cnt else 0 end) / SUM(cte.cnt), 2) as \"Cancellation Rate\"\nFROM \n    cte\nGROUP BY \n    cte.request_at\n"
                    },
                    {
                        "username": "addy022",
                        "content": "Can someone Fix and Explain what's wrong with the below query?\nI am getting below output\n| Day        | Cancellation_Rate |\n| ---------- | ----------------- |\n| 2013-10-01 | 0                 |\n| 2013-10-02 | 0                 |\n| 2013-10-03 | 0                 |\n\n/* Write your PL/SQL query statement below */\n-- filtered banned user/driver rows, date range\nwith cte as (\nSelect t.id, t.client_id, t.driver_id, t.status, t.request_at\nfrom trips t\ninner join users u on\nt.client_id = u.users_id and u.banned = 'No'\ninner join users u2 on\nt.driver_id = u2.users_id and u2.banned = 'No'\nwhere t.request_at between '2013-10-01' and '2013-10-03'\n)\n,\n-- total trips per day\ncte2 as (\nSelect count(id) as total_trips,  \nrequest_at from cte group by request_at \n)\n,\n-- cancelled trips per day\ncte3 as (\n  Select count(id) as cancelled_trips,  \nrequest_at as trip_date from cte  where status != 'completed' group by request_at\n),\n\ncte4 as\n(Select cte2.*, cte3.*\nfrom cte2 \nleft join cte3 on cte2.request_at = cte3.trip_date\n)\n--Select * from cte4\nSelect request_at as Day, Round(coalesce(cancelled_trips/ total_trips ,0),2) as Cancellation_Rate from cte4\n"
                    },
                    {
                        "username": "learningswithsrijan",
                        "content": "Using a trivial method of writing query, I able to pass all the test cases with the given set of data in SSMS. But here, for below test case, it shows Wrong Answer and fails the submit. Can someone help me identify the issue ?\\n\\nSQL Query\\n\"with cte_totalreq\\nas\\n(select \\ncount(T.status) as [TotalReqsOnADay], T.request_at\\nfrom \\nTrips T\\nwhere \\nclient_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\nand driver_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\ngroup by request_at),\\ncte_cancelledreq as\\n(select \\ncount(T.status) as [CancelledReq], T.request_at\\nfrom \\nTrips T\\nwhere status not in (\\'completed\\')\\nand client_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\nand driver_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\ngroup by request_at)\\n\\nselect request_at as [Day], CONVERT(DECIMAL(3,2),ISNULL((CONVERT(DECIMAL(3,2),(select [CancelledReq] from cte_cancelledreq cancelled where cancelled.request_at = totalreq.request_at)) / CONVERT(DECIMAL(3,2),TotalReqsOnADay)),0)) as [Cancellation Rate]\\nfrom cte_totalreq totalreq\\n\"\\n\\nTest case data and result in SSMS -\\nResult\\nDay\\tCancellation Rate\\n2013-10-04\\t1.00\\n\\nTrips\\nid\\tclient_id\\tdriver_id\\tcity_id\\tstatus\\trequest_at\\n11\\t1\\t10\\t1\\tcancelled_by_client\\t2013-10-04\\n\\nUsers\\nusers_id\\tbanned\\trole\\n1\\tNo\\tclient\\n10\\tNo\\tdriver"
                    },
                    {
                        "username": "yashgada99",
                        "content": "Any idea why Leetcode gives this error while loading the coding environment? \\n(The right half of the page, where coding is to be done, is not getting ready and loading indefinitely)\\nError - `(1054, \"Unknown column \\'problemset_codedefinition.react\\' in \\'field list\\'\")`"
                    },
                    {
                        "username": "azuregcp",
                        "content": "This should be medium. "
                    },
                    {
                        "username": "shailen86",
                        "content": "The output is coming correct as per demo given. But while running the code the output is comparing with some other expected result where there is just decimal places difference.\nE.g. I am getting 0.00 and they showing 0 and same with next one where my output is 0.50 and there is coming 0.5"
                    }
                ]
            },
            {
                "id": 1956087,
                "content": [
                    {
                        "username": "leetciel5577",
                        "content": "Is there any idea what\\'s the issue with my answer? It passes all the other testcase, but the following one. Thanks a lot!\\n\\nInput\\nTrips =\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | Yes    | driver |\\n\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\n\\n-----------------------------------------------------------------------------\\n\\n\\n\\n\\nwith cte as(\\nselect *\\nfrom trips t join users u\\non t.client_id=u.users_id\\nwhere u.banned!=\\'Yes\\'\\n)\\n\\nselect request_at as Day , \\nround(sum(case when status!=\\'completed\\' then 1 else 0 end)/count(status) ,2) as \\'Cancellation Rate\\'\\nfrom cte\\ngroup by request_at \\nhaving request_at between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "johnzaheer",
                        "content": "It\\u2019s broken, my code ran into the same issue so i created a work around then the output changed to the opposite. Depending on which version of my code i ran the output would be different for this exact case as well. "
                    },
                    {
                        "username": "johnzaheer",
                        "content": "Brocken test case exist, where there is just 1 input that is completed the expected changes depending on your output. \\n\\neven created workaround to null if no canceled status exist, but then the expected changed to 0\\nleave as is so my code returns 0\\nthen the expected changes to null"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "It seems there is a misprint in Pandas Schema. I propose to use \\n```\\ndata = [[\\'1\\', \\'1\\', \\'10\\', \\'1\\', \\'completed\\', \\'2013-10-01\\'], [\\'2\\', \\'2\\', \\'11\\', \\'1\\', \\'cancelled_by_driver\\', \\'2013-10-01\\'], [\\'3\\', \\'3\\', \\'2\\', \\'6\\', \\'completed\\', \\'2013-10-01\\'], [\\'4\\', \\'4\\', \\'13\\', \\'6\\', \\'cancelled_by_client\\', \\'2013-10-01\\'], [\\'5\\', \\'1\\', \\'10\\', \\'1\\', \\'completed\\', \\'2013-10-02\\'], [\\'6\\', \\'2\\', \\'11\\', \\'6\\', \\'completed\\', \\'2013-10-02\\'], [\\'7\\', \\'3\\', \\'12\\', \\'6\\', \\'completed\\', \\'2013-10-02\\'], [\\'8\\', \\'2\\', \\'12\\', \\'12\\', \\'completed\\', \\'2013-10-03\\'], [\\'9\\', \\'3\\', \\'10\\', \\'12\\', \\'completed\\', \\'2013-10-03\\'], [\\'10\\', \\'4\\', \\'13\\', \\'12\\', \\'cancelled_by_driver\\', \\'2013-10-03\\']]\\ntrips = pd.DataFrame(data, columns=[\\'id\\', \\'client_id\\', \\'driver_id\\', \\'city_id\\', \\'status\\', \\'request_at\\']).astype({\\'id\\':\\'Int64\\', \\'client_id\\':\\'Int64\\', \\'driver_id\\':\\'Int64\\', \\'city_id\\':\\'Int64\\', \\'status\\':\\'object\\', \\'request_at\\': \\'datetime64[ns]\\'})\\n\\ndata = [[\\'1\\', \\'No\\', \\'client\\'], [\\'2\\', \\'Yes\\', \\'client\\'], [\\'3\\', \\'No\\', \\'client\\'], [\\'4\\', \\'No\\', \\'client\\'], [\\'10\\', \\'No\\', \\'driver\\'], [\\'11\\', \\'No\\', \\'driver\\'], [\\'12\\', \\'No\\', \\'driver\\'], [\\'13\\', \\'No\\', \\'driver\\']]\\nusers = pd.DataFrame(data, columns=[\\'users_id\\', \\'banned\\', \\'role\\']).astype({\\'users_id\\':\\'Int64\\', \\'banned\\':\\'object\\', \\'role\\':\\'object\\'})\\n``` \\ninstead."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "AlexeySumin",
                        "content": "Hello!\nI have a working sql code, it executes well on mysql, but when i execute in on MsSQL(here, not in real one), i face an issue wis dividing values, it returns zeros.\nIve already met such issues on leetcode, am i the only who faced it?\n\nwith cte as (\n    select \n    t.request_at\n    , CASE when t.status = 'completed' then 'ok' else 'cancel' end as status_new\n    , COUNT(1) as cnt\n    from Trips as t\n    inner join Users as c On t.client_id = c.users_id \n    inner join Users as d On t.driver_id = d.users_id \n    where\n        t.request_at between CAST('2013-10-01' as DATE) and CAST('2013-10-03' as DATE) AND c.banned = 'No' AND d.banned = 'No'\n    group by \n        t.request_at, CASE when t.status = 'completed' then 'ok' else 'cancel' end\n)\nSELECT \ncte.request_at as Day\n,  ROUND(SUM(CASE when cte.status_new = 'cancel' then cte.cnt else 0 end) / SUM(cte.cnt), 2) as \"Cancellation Rate\"\nFROM \n    cte\nGROUP BY \n    cte.request_at\n"
                    },
                    {
                        "username": "addy022",
                        "content": "Can someone Fix and Explain what's wrong with the below query?\nI am getting below output\n| Day        | Cancellation_Rate |\n| ---------- | ----------------- |\n| 2013-10-01 | 0                 |\n| 2013-10-02 | 0                 |\n| 2013-10-03 | 0                 |\n\n/* Write your PL/SQL query statement below */\n-- filtered banned user/driver rows, date range\nwith cte as (\nSelect t.id, t.client_id, t.driver_id, t.status, t.request_at\nfrom trips t\ninner join users u on\nt.client_id = u.users_id and u.banned = 'No'\ninner join users u2 on\nt.driver_id = u2.users_id and u2.banned = 'No'\nwhere t.request_at between '2013-10-01' and '2013-10-03'\n)\n,\n-- total trips per day\ncte2 as (\nSelect count(id) as total_trips,  \nrequest_at from cte group by request_at \n)\n,\n-- cancelled trips per day\ncte3 as (\n  Select count(id) as cancelled_trips,  \nrequest_at as trip_date from cte  where status != 'completed' group by request_at\n),\n\ncte4 as\n(Select cte2.*, cte3.*\nfrom cte2 \nleft join cte3 on cte2.request_at = cte3.trip_date\n)\n--Select * from cte4\nSelect request_at as Day, Round(coalesce(cancelled_trips/ total_trips ,0),2) as Cancellation_Rate from cte4\n"
                    },
                    {
                        "username": "learningswithsrijan",
                        "content": "Using a trivial method of writing query, I able to pass all the test cases with the given set of data in SSMS. But here, for below test case, it shows Wrong Answer and fails the submit. Can someone help me identify the issue ?\\n\\nSQL Query\\n\"with cte_totalreq\\nas\\n(select \\ncount(T.status) as [TotalReqsOnADay], T.request_at\\nfrom \\nTrips T\\nwhere \\nclient_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\nand driver_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\ngroup by request_at),\\ncte_cancelledreq as\\n(select \\ncount(T.status) as [CancelledReq], T.request_at\\nfrom \\nTrips T\\nwhere status not in (\\'completed\\')\\nand client_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\nand driver_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\ngroup by request_at)\\n\\nselect request_at as [Day], CONVERT(DECIMAL(3,2),ISNULL((CONVERT(DECIMAL(3,2),(select [CancelledReq] from cte_cancelledreq cancelled where cancelled.request_at = totalreq.request_at)) / CONVERT(DECIMAL(3,2),TotalReqsOnADay)),0)) as [Cancellation Rate]\\nfrom cte_totalreq totalreq\\n\"\\n\\nTest case data and result in SSMS -\\nResult\\nDay\\tCancellation Rate\\n2013-10-04\\t1.00\\n\\nTrips\\nid\\tclient_id\\tdriver_id\\tcity_id\\tstatus\\trequest_at\\n11\\t1\\t10\\t1\\tcancelled_by_client\\t2013-10-04\\n\\nUsers\\nusers_id\\tbanned\\trole\\n1\\tNo\\tclient\\n10\\tNo\\tdriver"
                    },
                    {
                        "username": "yashgada99",
                        "content": "Any idea why Leetcode gives this error while loading the coding environment? \\n(The right half of the page, where coding is to be done, is not getting ready and loading indefinitely)\\nError - `(1054, \"Unknown column \\'problemset_codedefinition.react\\' in \\'field list\\'\")`"
                    },
                    {
                        "username": "azuregcp",
                        "content": "This should be medium. "
                    },
                    {
                        "username": "shailen86",
                        "content": "The output is coming correct as per demo given. But while running the code the output is comparing with some other expected result where there is just decimal places difference.\nE.g. I am getting 0.00 and they showing 0 and same with next one where my output is 0.50 and there is coming 0.5"
                    }
                ]
            },
            {
                "id": 1950141,
                "content": [
                    {
                        "username": "leetciel5577",
                        "content": "Is there any idea what\\'s the issue with my answer? It passes all the other testcase, but the following one. Thanks a lot!\\n\\nInput\\nTrips =\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | Yes    | driver |\\n\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\n\\n-----------------------------------------------------------------------------\\n\\n\\n\\n\\nwith cte as(\\nselect *\\nfrom trips t join users u\\non t.client_id=u.users_id\\nwhere u.banned!=\\'Yes\\'\\n)\\n\\nselect request_at as Day , \\nround(sum(case when status!=\\'completed\\' then 1 else 0 end)/count(status) ,2) as \\'Cancellation Rate\\'\\nfrom cte\\ngroup by request_at \\nhaving request_at between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "johnzaheer",
                        "content": "It\\u2019s broken, my code ran into the same issue so i created a work around then the output changed to the opposite. Depending on which version of my code i ran the output would be different for this exact case as well. "
                    },
                    {
                        "username": "johnzaheer",
                        "content": "Brocken test case exist, where there is just 1 input that is completed the expected changes depending on your output. \\n\\neven created workaround to null if no canceled status exist, but then the expected changed to 0\\nleave as is so my code returns 0\\nthen the expected changes to null"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "It seems there is a misprint in Pandas Schema. I propose to use \\n```\\ndata = [[\\'1\\', \\'1\\', \\'10\\', \\'1\\', \\'completed\\', \\'2013-10-01\\'], [\\'2\\', \\'2\\', \\'11\\', \\'1\\', \\'cancelled_by_driver\\', \\'2013-10-01\\'], [\\'3\\', \\'3\\', \\'2\\', \\'6\\', \\'completed\\', \\'2013-10-01\\'], [\\'4\\', \\'4\\', \\'13\\', \\'6\\', \\'cancelled_by_client\\', \\'2013-10-01\\'], [\\'5\\', \\'1\\', \\'10\\', \\'1\\', \\'completed\\', \\'2013-10-02\\'], [\\'6\\', \\'2\\', \\'11\\', \\'6\\', \\'completed\\', \\'2013-10-02\\'], [\\'7\\', \\'3\\', \\'12\\', \\'6\\', \\'completed\\', \\'2013-10-02\\'], [\\'8\\', \\'2\\', \\'12\\', \\'12\\', \\'completed\\', \\'2013-10-03\\'], [\\'9\\', \\'3\\', \\'10\\', \\'12\\', \\'completed\\', \\'2013-10-03\\'], [\\'10\\', \\'4\\', \\'13\\', \\'12\\', \\'cancelled_by_driver\\', \\'2013-10-03\\']]\\ntrips = pd.DataFrame(data, columns=[\\'id\\', \\'client_id\\', \\'driver_id\\', \\'city_id\\', \\'status\\', \\'request_at\\']).astype({\\'id\\':\\'Int64\\', \\'client_id\\':\\'Int64\\', \\'driver_id\\':\\'Int64\\', \\'city_id\\':\\'Int64\\', \\'status\\':\\'object\\', \\'request_at\\': \\'datetime64[ns]\\'})\\n\\ndata = [[\\'1\\', \\'No\\', \\'client\\'], [\\'2\\', \\'Yes\\', \\'client\\'], [\\'3\\', \\'No\\', \\'client\\'], [\\'4\\', \\'No\\', \\'client\\'], [\\'10\\', \\'No\\', \\'driver\\'], [\\'11\\', \\'No\\', \\'driver\\'], [\\'12\\', \\'No\\', \\'driver\\'], [\\'13\\', \\'No\\', \\'driver\\']]\\nusers = pd.DataFrame(data, columns=[\\'users_id\\', \\'banned\\', \\'role\\']).astype({\\'users_id\\':\\'Int64\\', \\'banned\\':\\'object\\', \\'role\\':\\'object\\'})\\n``` \\ninstead."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "AlexeySumin",
                        "content": "Hello!\nI have a working sql code, it executes well on mysql, but when i execute in on MsSQL(here, not in real one), i face an issue wis dividing values, it returns zeros.\nIve already met such issues on leetcode, am i the only who faced it?\n\nwith cte as (\n    select \n    t.request_at\n    , CASE when t.status = 'completed' then 'ok' else 'cancel' end as status_new\n    , COUNT(1) as cnt\n    from Trips as t\n    inner join Users as c On t.client_id = c.users_id \n    inner join Users as d On t.driver_id = d.users_id \n    where\n        t.request_at between CAST('2013-10-01' as DATE) and CAST('2013-10-03' as DATE) AND c.banned = 'No' AND d.banned = 'No'\n    group by \n        t.request_at, CASE when t.status = 'completed' then 'ok' else 'cancel' end\n)\nSELECT \ncte.request_at as Day\n,  ROUND(SUM(CASE when cte.status_new = 'cancel' then cte.cnt else 0 end) / SUM(cte.cnt), 2) as \"Cancellation Rate\"\nFROM \n    cte\nGROUP BY \n    cte.request_at\n"
                    },
                    {
                        "username": "addy022",
                        "content": "Can someone Fix and Explain what's wrong with the below query?\nI am getting below output\n| Day        | Cancellation_Rate |\n| ---------- | ----------------- |\n| 2013-10-01 | 0                 |\n| 2013-10-02 | 0                 |\n| 2013-10-03 | 0                 |\n\n/* Write your PL/SQL query statement below */\n-- filtered banned user/driver rows, date range\nwith cte as (\nSelect t.id, t.client_id, t.driver_id, t.status, t.request_at\nfrom trips t\ninner join users u on\nt.client_id = u.users_id and u.banned = 'No'\ninner join users u2 on\nt.driver_id = u2.users_id and u2.banned = 'No'\nwhere t.request_at between '2013-10-01' and '2013-10-03'\n)\n,\n-- total trips per day\ncte2 as (\nSelect count(id) as total_trips,  \nrequest_at from cte group by request_at \n)\n,\n-- cancelled trips per day\ncte3 as (\n  Select count(id) as cancelled_trips,  \nrequest_at as trip_date from cte  where status != 'completed' group by request_at\n),\n\ncte4 as\n(Select cte2.*, cte3.*\nfrom cte2 \nleft join cte3 on cte2.request_at = cte3.trip_date\n)\n--Select * from cte4\nSelect request_at as Day, Round(coalesce(cancelled_trips/ total_trips ,0),2) as Cancellation_Rate from cte4\n"
                    },
                    {
                        "username": "learningswithsrijan",
                        "content": "Using a trivial method of writing query, I able to pass all the test cases with the given set of data in SSMS. But here, for below test case, it shows Wrong Answer and fails the submit. Can someone help me identify the issue ?\\n\\nSQL Query\\n\"with cte_totalreq\\nas\\n(select \\ncount(T.status) as [TotalReqsOnADay], T.request_at\\nfrom \\nTrips T\\nwhere \\nclient_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\nand driver_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\ngroup by request_at),\\ncte_cancelledreq as\\n(select \\ncount(T.status) as [CancelledReq], T.request_at\\nfrom \\nTrips T\\nwhere status not in (\\'completed\\')\\nand client_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\nand driver_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\ngroup by request_at)\\n\\nselect request_at as [Day], CONVERT(DECIMAL(3,2),ISNULL((CONVERT(DECIMAL(3,2),(select [CancelledReq] from cte_cancelledreq cancelled where cancelled.request_at = totalreq.request_at)) / CONVERT(DECIMAL(3,2),TotalReqsOnADay)),0)) as [Cancellation Rate]\\nfrom cte_totalreq totalreq\\n\"\\n\\nTest case data and result in SSMS -\\nResult\\nDay\\tCancellation Rate\\n2013-10-04\\t1.00\\n\\nTrips\\nid\\tclient_id\\tdriver_id\\tcity_id\\tstatus\\trequest_at\\n11\\t1\\t10\\t1\\tcancelled_by_client\\t2013-10-04\\n\\nUsers\\nusers_id\\tbanned\\trole\\n1\\tNo\\tclient\\n10\\tNo\\tdriver"
                    },
                    {
                        "username": "yashgada99",
                        "content": "Any idea why Leetcode gives this error while loading the coding environment? \\n(The right half of the page, where coding is to be done, is not getting ready and loading indefinitely)\\nError - `(1054, \"Unknown column \\'problemset_codedefinition.react\\' in \\'field list\\'\")`"
                    },
                    {
                        "username": "azuregcp",
                        "content": "This should be medium. "
                    },
                    {
                        "username": "shailen86",
                        "content": "The output is coming correct as per demo given. But while running the code the output is comparing with some other expected result where there is just decimal places difference.\nE.g. I am getting 0.00 and they showing 0 and same with next one where my output is 0.50 and there is coming 0.5"
                    }
                ]
            },
            {
                "id": 1904811,
                "content": [
                    {
                        "username": "leetciel5577",
                        "content": "Is there any idea what\\'s the issue with my answer? It passes all the other testcase, but the following one. Thanks a lot!\\n\\nInput\\nTrips =\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 10       | Yes    | driver |\\n\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0                 |\\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\n\\n-----------------------------------------------------------------------------\\n\\n\\n\\n\\nwith cte as(\\nselect *\\nfrom trips t join users u\\non t.client_id=u.users_id\\nwhere u.banned!=\\'Yes\\'\\n)\\n\\nselect request_at as Day , \\nround(sum(case when status!=\\'completed\\' then 1 else 0 end)/count(status) ,2) as \\'Cancellation Rate\\'\\nfrom cte\\ngroup by request_at \\nhaving request_at between \"2013-10-01\" and \"2013-10-03\""
                    },
                    {
                        "username": "johnzaheer",
                        "content": "It\\u2019s broken, my code ran into the same issue so i created a work around then the output changed to the opposite. Depending on which version of my code i ran the output would be different for this exact case as well. "
                    },
                    {
                        "username": "johnzaheer",
                        "content": "Brocken test case exist, where there is just 1 input that is completed the expected changes depending on your output. \\n\\neven created workaround to null if no canceled status exist, but then the expected changed to 0\\nleave as is so my code returns 0\\nthen the expected changes to null"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "It seems there is a misprint in Pandas Schema. I propose to use \\n```\\ndata = [[\\'1\\', \\'1\\', \\'10\\', \\'1\\', \\'completed\\', \\'2013-10-01\\'], [\\'2\\', \\'2\\', \\'11\\', \\'1\\', \\'cancelled_by_driver\\', \\'2013-10-01\\'], [\\'3\\', \\'3\\', \\'2\\', \\'6\\', \\'completed\\', \\'2013-10-01\\'], [\\'4\\', \\'4\\', \\'13\\', \\'6\\', \\'cancelled_by_client\\', \\'2013-10-01\\'], [\\'5\\', \\'1\\', \\'10\\', \\'1\\', \\'completed\\', \\'2013-10-02\\'], [\\'6\\', \\'2\\', \\'11\\', \\'6\\', \\'completed\\', \\'2013-10-02\\'], [\\'7\\', \\'3\\', \\'12\\', \\'6\\', \\'completed\\', \\'2013-10-02\\'], [\\'8\\', \\'2\\', \\'12\\', \\'12\\', \\'completed\\', \\'2013-10-03\\'], [\\'9\\', \\'3\\', \\'10\\', \\'12\\', \\'completed\\', \\'2013-10-03\\'], [\\'10\\', \\'4\\', \\'13\\', \\'12\\', \\'cancelled_by_driver\\', \\'2013-10-03\\']]\\ntrips = pd.DataFrame(data, columns=[\\'id\\', \\'client_id\\', \\'driver_id\\', \\'city_id\\', \\'status\\', \\'request_at\\']).astype({\\'id\\':\\'Int64\\', \\'client_id\\':\\'Int64\\', \\'driver_id\\':\\'Int64\\', \\'city_id\\':\\'Int64\\', \\'status\\':\\'object\\', \\'request_at\\': \\'datetime64[ns]\\'})\\n\\ndata = [[\\'1\\', \\'No\\', \\'client\\'], [\\'2\\', \\'Yes\\', \\'client\\'], [\\'3\\', \\'No\\', \\'client\\'], [\\'4\\', \\'No\\', \\'client\\'], [\\'10\\', \\'No\\', \\'driver\\'], [\\'11\\', \\'No\\', \\'driver\\'], [\\'12\\', \\'No\\', \\'driver\\'], [\\'13\\', \\'No\\', \\'driver\\']]\\nusers = pd.DataFrame(data, columns=[\\'users_id\\', \\'banned\\', \\'role\\']).astype({\\'users_id\\':\\'Int64\\', \\'banned\\':\\'object\\', \\'role\\':\\'object\\'})\\n``` \\ninstead."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT\\n    request_date as Day,\\n    ROUND(\\n         SUM(CASE WHEN status <> \\'completed\\' THEN 1 ELSE 0 END) /\\n          COUNT(*),\\n        2\\n    ) AS \"Cancellation Rate\"\\nFROM\\n    (\\n        SELECT\\n            DATE(t.request_at) AS request_date,\\n            t.status\\n        FROM\\n            Trips t\\n        INNER JOIN\\n            Users uc ON t.client_id = uc.users_id\\n        INNER JOIN\\n            Users ud ON t.driver_id = ud.users_id\\n        WHERE\\n            uc.banned = \\'No\\' AND ud.banned = \\'No\\' AND\\n            t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n    ) AS subquery\\nGROUP BY\\n    request_date;"
                    },
                    {
                        "username": "AlexeySumin",
                        "content": "Hello!\nI have a working sql code, it executes well on mysql, but when i execute in on MsSQL(here, not in real one), i face an issue wis dividing values, it returns zeros.\nIve already met such issues on leetcode, am i the only who faced it?\n\nwith cte as (\n    select \n    t.request_at\n    , CASE when t.status = 'completed' then 'ok' else 'cancel' end as status_new\n    , COUNT(1) as cnt\n    from Trips as t\n    inner join Users as c On t.client_id = c.users_id \n    inner join Users as d On t.driver_id = d.users_id \n    where\n        t.request_at between CAST('2013-10-01' as DATE) and CAST('2013-10-03' as DATE) AND c.banned = 'No' AND d.banned = 'No'\n    group by \n        t.request_at, CASE when t.status = 'completed' then 'ok' else 'cancel' end\n)\nSELECT \ncte.request_at as Day\n,  ROUND(SUM(CASE when cte.status_new = 'cancel' then cte.cnt else 0 end) / SUM(cte.cnt), 2) as \"Cancellation Rate\"\nFROM \n    cte\nGROUP BY \n    cte.request_at\n"
                    },
                    {
                        "username": "addy022",
                        "content": "Can someone Fix and Explain what's wrong with the below query?\nI am getting below output\n| Day        | Cancellation_Rate |\n| ---------- | ----------------- |\n| 2013-10-01 | 0                 |\n| 2013-10-02 | 0                 |\n| 2013-10-03 | 0                 |\n\n/* Write your PL/SQL query statement below */\n-- filtered banned user/driver rows, date range\nwith cte as (\nSelect t.id, t.client_id, t.driver_id, t.status, t.request_at\nfrom trips t\ninner join users u on\nt.client_id = u.users_id and u.banned = 'No'\ninner join users u2 on\nt.driver_id = u2.users_id and u2.banned = 'No'\nwhere t.request_at between '2013-10-01' and '2013-10-03'\n)\n,\n-- total trips per day\ncte2 as (\nSelect count(id) as total_trips,  \nrequest_at from cte group by request_at \n)\n,\n-- cancelled trips per day\ncte3 as (\n  Select count(id) as cancelled_trips,  \nrequest_at as trip_date from cte  where status != 'completed' group by request_at\n),\n\ncte4 as\n(Select cte2.*, cte3.*\nfrom cte2 \nleft join cte3 on cte2.request_at = cte3.trip_date\n)\n--Select * from cte4\nSelect request_at as Day, Round(coalesce(cancelled_trips/ total_trips ,0),2) as Cancellation_Rate from cte4\n"
                    },
                    {
                        "username": "learningswithsrijan",
                        "content": "Using a trivial method of writing query, I able to pass all the test cases with the given set of data in SSMS. But here, for below test case, it shows Wrong Answer and fails the submit. Can someone help me identify the issue ?\\n\\nSQL Query\\n\"with cte_totalreq\\nas\\n(select \\ncount(T.status) as [TotalReqsOnADay], T.request_at\\nfrom \\nTrips T\\nwhere \\nclient_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\nand driver_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\ngroup by request_at),\\ncte_cancelledreq as\\n(select \\ncount(T.status) as [CancelledReq], T.request_at\\nfrom \\nTrips T\\nwhere status not in (\\'completed\\')\\nand client_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\nand driver_id in (select users_id from Users [notbanned] where notbanned.banned = \\'No\\') \\ngroup by request_at)\\n\\nselect request_at as [Day], CONVERT(DECIMAL(3,2),ISNULL((CONVERT(DECIMAL(3,2),(select [CancelledReq] from cte_cancelledreq cancelled where cancelled.request_at = totalreq.request_at)) / CONVERT(DECIMAL(3,2),TotalReqsOnADay)),0)) as [Cancellation Rate]\\nfrom cte_totalreq totalreq\\n\"\\n\\nTest case data and result in SSMS -\\nResult\\nDay\\tCancellation Rate\\n2013-10-04\\t1.00\\n\\nTrips\\nid\\tclient_id\\tdriver_id\\tcity_id\\tstatus\\trequest_at\\n11\\t1\\t10\\t1\\tcancelled_by_client\\t2013-10-04\\n\\nUsers\\nusers_id\\tbanned\\trole\\n1\\tNo\\tclient\\n10\\tNo\\tdriver"
                    },
                    {
                        "username": "yashgada99",
                        "content": "Any idea why Leetcode gives this error while loading the coding environment? \\n(The right half of the page, where coding is to be done, is not getting ready and loading indefinitely)\\nError - `(1054, \"Unknown column \\'problemset_codedefinition.react\\' in \\'field list\\'\")`"
                    },
                    {
                        "username": "azuregcp",
                        "content": "This should be medium. "
                    },
                    {
                        "username": "shailen86",
                        "content": "The output is coming correct as per demo given. But while running the code the output is comparing with some other expected result where there is just decimal places difference.\nE.g. I am getting 0.00 and they showing 0 and same with next one where my output is 0.50 and there is coming 0.5"
                    }
                ]
            },
            {
                "id": 1888968,
                "content": [
                    {
                        "username": "arzoop",
                        "content": "My solution fetches the day and null for the days where there are no unbanned transactions. How can I rectify this?\\n```\\nselect \\n(request_at) as Day,\\nround(\\n  (\\n    select count(*) from Trips\\n      inner join Users u1 on trips.client_id=u1.users_id and u1.banned like \"No\" \\n    inner join Users u2 on trips.driver_id=u2.users_id and u2.banned like \"No\"\\n    where\\n    #  u1.banned like \"No\" and u2.banned like \"No\" and\\n   Trips.status like \"cancelled_by%\" and request_at=Day\\n    )\\n  /\\n  (\\n    select count(*) from Trips\\n    inner join Users u1 on trips.client_id=u1.users_id and u1.banned like \"No\"\\n    inner join Users u2 on trips.driver_id=u2.users_id and u2.banned like \"No\"\\n    where \\n    # u1.banned like \"No\" and u2.banned like \"No\" and \\n    request_at=Day\\n  )\\n,2) as `Cancellation Rate`\\nfrom Trips\\ngroup by Day \\nhaving Day between \"2013-10-01\" and \"2013-10-03\" ;\\n```"
                    },
                    {
                        "username": "shailen86",
                        "content": "Don\\'t use round function. Use NVL and to_char(\\'day\\',\\'0.99\\') to get the output"
                    },
                    {
                        "username": "ktramos",
                        "content": "I also found a test case that seems wrong: (9/12)\\nThe test case uses a scenario where an existing users_id = 1, banned value is updated to \\'Yes\\'. \\nThe test case expects the Cancellation Rate output for 10/01 to be NULL, however when I run locally, the Cancellation Rate output for 10/01 is now .50 because there is 1 cancelled row / by are 2 valid rows "
                    },
                    {
                        "username": "MaheshBabuMummalaneni",
                        "content": "with cte1 as (select *,\\n  Case when status = \\'completed\\' then null else 1 end as cancelled_flag\\nfrom trips)\\n\\nselect request_at as Day,cast((count(cancelled_flag)*1.0 /count(status)) as decimal(10,2)) as \\'Cancellation Rate\\' from cte1 c\\nleft join users u\\non c.client_id = u.users_id where banned <> \\'Yes\\' \\ngroup by request_at\\n\\n\\nThe above query is running fine and giving the required output and it is showing as accepted but throwing error while submitting. This is what\\'s happening in many queries. It should let us submit when the answer is correct. Moreover, it is showing answer which is not even related to this question. \\n\\nI never faced this kind of issues with hacker rank. May be, these people have better questions but what\\'s the point when we are not even able to submit correct answers."
                    },
                    {
                        "username": "moeheinag",
                        "content": "I'm trying it to find cancellation_rate for just one date right now. And below is my query:\n\n```\nwith unbanned_trips as\n  (select * from Trips\n  join Users on client_id = users_id\n  or client_id = driver_id\n  where request_at = '2013-10-01'\n  and banned = 'No')\n\nwith unbanned_trip_count as (\n  select count(*) from unbanned_trips\n)\nwith cancelled_trip_count as (\n  select count(*) from unbanned_trips\n  where status = 'cancelled_by_client'\n)\n\nselect unbanned_trip_count / cancelled_trip_count\n```\nHow can I do this?"
                    },
                    {
                        "username": "tooytod",
                        "content": "why I can\\'t get the right result for division?\\nThe number of cancelled and total both correct, but after devision, it shows 0, even I used cast. Anyone knows what should I do to show the correct number? thanks!\\n| request_at | cancelled | total | Cancellation Rate |\\n| ---------- | --------- | ----- | ----------------- |\\n| 2013-10-01 | 1         | 3     | 0                 |\\n| 2013-10-02 | 0         | 2     | 0                 |\\n| 2013-10-03 | 1         | 2     | 0                 |"
                    },
                    {
                        "username": "fsanchez314159",
                        "content": "`\n# Write your MySQL query statement below\n\nwith t as (\n    select *\n    from Trips\n    where\n        client_id not in (\n            select distinct\n                users_id\n            from Users\n            where\n                role = 'client' and banned = 'Yes'\n        )\n        and driver_id not in (\n            select distinct\n                users_id\n            from Users\n            where\n                role = 'driver' and banned = 'Yes'\n        )\n), agg as (\n    select\n        request_at,\n        case when status = 'completed' then status else 'canceled' end as status,\n\n        count(distinct id) as trip_count\n    from t\n    group by request_at, status\n    order by request_at, status\n)\n\n\nselect\n    request_at as Day,\n\n    round(sum(case when status = 'canceled' then trip_count else 0 end) / sum(trip_count), 2) as \"Cancellation Rate\"\nfrom agg\nwhere\n    request_at between '2013-10-01' and '2013-10-03'\ngroup by Day\norder by Day\n`\n\nThis works for me"
                    },
                    {
                        "username": "wasitshafi",
                        "content": "# getting .66 in result while its expected result show to be .67\\nmy query \\n```sql\\nwith cte1 as (\\n  select\\n    request_at,\\n    count(*) as total_requests,\\n    sum(\\n      (\\n        case\\n          when status <> \\'completed\\' then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'total_cancelled_trips\\',\\n    sum(\\n      (\\n        case\\n          when status = \\'completed\\'\\n          and (\\n            client_id in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'client\\'\\n            )\\n            or driver_id in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'driver\\'\\n            )\\n          ) then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'banned_completed_trips\\',\\n    sum(\\n      (\\n        case\\n          when status <> \\'completed\\'\\n          and (\\n            client_id not in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'client\\'\\n            )\\n            and driver_id not in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'driver\\'\\n            )\\n          ) then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'unbanned_cancelled_trips\\'\\n  from\\n    trips\\n  group by\\n    request_at\\n),\\ncte2 as (\\n  select\\n    cte1.request_at as Day,\\n    truncate(\\n      (\\n        (cte1.unbanned_cancelled_trips) /(\\n          cte1.total_requests - (\\n            cte1.total_cancelled_trips - cte1.unbanned_cancelled_trips\\n          ) - banned_completed_trips\\n        )\\n      ),\\n      2\\n    ) as \\'Cancellation Rate\\'\\n  from\\n    cte1\\n  where\\n    (\\n      cte1.request_at between \\'2013-10-01\\'\\n      and \\'2013-10-03\\'\\n    )\\n)\\nselect\\n  *\\nfrom\\n  cte2\\nwhere\\n  `Cancellation Rate` is not null\\n```\\n\\nInput:\\n```\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | completed           | 2013-10-01 |\\n| 2  | 2         | 11        | 1       | cancelled_by_driver | 2013-10-01 |\\n| 3  | 3         | 12        | 6       | completed           | 2013-10-01 |\\n| 4  | 4         | 13        | 6       | cancelled_by_client | 2013-10-01 |\\n| 5  | 1         | 10        | 1       | completed           | 2013-10-02 |\\n| 6  | 2         | 11        | 6       | completed           | 2013-10-02 |\\n| 7  | 3         | 12        | 6       | completed           | 2013-10-02 |\\n| 8  | 2         | 12        | 12      | completed           | 2013-10-03 |\\n| 9  | 3         | 10        | 12      | completed           | 2013-10-03 |\\n| 10 | 4         | 13        | 12      | cancelled_by_driver | 2013-10-03 |\\n| 11 | 3         | 10        | 6       | cancelled_by_driver | 2013-10-02 |\\n| 12 | 5         | 12        | 12      | cancelled_by_client | 2013-10-01 |\\n| 13 | 4         | 13        | 1       | cancelled_by_driver | 2013-10-03 |\\n```\\n```\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 2        | Yes    | client |\\n| 3        | No     | client |\\n| 4        | No     | client |\\n| 5        | Yes    | client |\\n| 10       | No     | driver |\\n| 11       | No     | driver |\\n| 12       | No     | driver |\\n| 13       | No     | driver |\\n```\\n\\nResult :\\n```\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-02 | 0.33              |\\n| 2013-10-03 | 0.66              |\\n```\\n\\nExpected:\\n```\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-02 | 0.33              |\\n| 2013-10-03 | 0.67              |\\n```\\n\\n# all of 11 out of 12 test cases passed, i only got wrong ans due to the last cancellation rate, any ony who sees whats wrong with my query...?\\n\\n\\n"
                    },
                    {
                        "username": "jaluthriarohit",
                        "content": "select request_at as Day,\\nround((1.0 * count(case when status in (\\'cancelled_by_driver \\' , \\'cancelled_by_client \\') then 1 else null end)/\\ncount(1)  ),2) as \"Cancellation_Rate\"\\nfrom trips t \\njoin users u on t.client_id=u.users_id\\njoin users u1 on t.client_id=u1.users_id\\nwhere u.banned=\"no\" and u1.banned=\\'No\\'  \\ngroup by request_at\\n\\ncan anybody tell why this is wrong ?\\n"
                    },
                    {
                        "username": "rishavm",
                        "content": "can someone expain why this input has \n\n| id | client_id | driver_id | city_id | status              | request_at |\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\n\n| users_id | banned | role   |\n| -------- | ------ | ------ |\n| 1        | No     | client |\n| 10       | No     | driver |\n\nhas this output\n| Day | Cancellation Rate |\n| --- | ----------------- |\n\nbecause the according to the description cancelled_request/total_request;\n\nEither the test case is wrong or some description is missing"
                    },
                    {
                        "username": "i_only_do_this_for_fun",
                        "content": "Out of range.  Always read the instructions before submitting:\\nWrite a SQL query to find the cancellation rate of requests with unbanned users (both client and driver must not be banned) each day between \"2013-10-01\" and \"2013-10-03\". Round Cancellation Rate to two decimal points."
                    },
                    {
                        "username": "salikhussaini49",
                        "content": "Great Question... "
                    }
                ]
            },
            {
                "id": 1888592,
                "content": [
                    {
                        "username": "arzoop",
                        "content": "My solution fetches the day and null for the days where there are no unbanned transactions. How can I rectify this?\\n```\\nselect \\n(request_at) as Day,\\nround(\\n  (\\n    select count(*) from Trips\\n      inner join Users u1 on trips.client_id=u1.users_id and u1.banned like \"No\" \\n    inner join Users u2 on trips.driver_id=u2.users_id and u2.banned like \"No\"\\n    where\\n    #  u1.banned like \"No\" and u2.banned like \"No\" and\\n   Trips.status like \"cancelled_by%\" and request_at=Day\\n    )\\n  /\\n  (\\n    select count(*) from Trips\\n    inner join Users u1 on trips.client_id=u1.users_id and u1.banned like \"No\"\\n    inner join Users u2 on trips.driver_id=u2.users_id and u2.banned like \"No\"\\n    where \\n    # u1.banned like \"No\" and u2.banned like \"No\" and \\n    request_at=Day\\n  )\\n,2) as `Cancellation Rate`\\nfrom Trips\\ngroup by Day \\nhaving Day between \"2013-10-01\" and \"2013-10-03\" ;\\n```"
                    },
                    {
                        "username": "shailen86",
                        "content": "Don\\'t use round function. Use NVL and to_char(\\'day\\',\\'0.99\\') to get the output"
                    },
                    {
                        "username": "ktramos",
                        "content": "I also found a test case that seems wrong: (9/12)\\nThe test case uses a scenario where an existing users_id = 1, banned value is updated to \\'Yes\\'. \\nThe test case expects the Cancellation Rate output for 10/01 to be NULL, however when I run locally, the Cancellation Rate output for 10/01 is now .50 because there is 1 cancelled row / by are 2 valid rows "
                    },
                    {
                        "username": "MaheshBabuMummalaneni",
                        "content": "with cte1 as (select *,\\n  Case when status = \\'completed\\' then null else 1 end as cancelled_flag\\nfrom trips)\\n\\nselect request_at as Day,cast((count(cancelled_flag)*1.0 /count(status)) as decimal(10,2)) as \\'Cancellation Rate\\' from cte1 c\\nleft join users u\\non c.client_id = u.users_id where banned <> \\'Yes\\' \\ngroup by request_at\\n\\n\\nThe above query is running fine and giving the required output and it is showing as accepted but throwing error while submitting. This is what\\'s happening in many queries. It should let us submit when the answer is correct. Moreover, it is showing answer which is not even related to this question. \\n\\nI never faced this kind of issues with hacker rank. May be, these people have better questions but what\\'s the point when we are not even able to submit correct answers."
                    },
                    {
                        "username": "moeheinag",
                        "content": "I'm trying it to find cancellation_rate for just one date right now. And below is my query:\n\n```\nwith unbanned_trips as\n  (select * from Trips\n  join Users on client_id = users_id\n  or client_id = driver_id\n  where request_at = '2013-10-01'\n  and banned = 'No')\n\nwith unbanned_trip_count as (\n  select count(*) from unbanned_trips\n)\nwith cancelled_trip_count as (\n  select count(*) from unbanned_trips\n  where status = 'cancelled_by_client'\n)\n\nselect unbanned_trip_count / cancelled_trip_count\n```\nHow can I do this?"
                    },
                    {
                        "username": "tooytod",
                        "content": "why I can\\'t get the right result for division?\\nThe number of cancelled and total both correct, but after devision, it shows 0, even I used cast. Anyone knows what should I do to show the correct number? thanks!\\n| request_at | cancelled | total | Cancellation Rate |\\n| ---------- | --------- | ----- | ----------------- |\\n| 2013-10-01 | 1         | 3     | 0                 |\\n| 2013-10-02 | 0         | 2     | 0                 |\\n| 2013-10-03 | 1         | 2     | 0                 |"
                    },
                    {
                        "username": "fsanchez314159",
                        "content": "`\n# Write your MySQL query statement below\n\nwith t as (\n    select *\n    from Trips\n    where\n        client_id not in (\n            select distinct\n                users_id\n            from Users\n            where\n                role = 'client' and banned = 'Yes'\n        )\n        and driver_id not in (\n            select distinct\n                users_id\n            from Users\n            where\n                role = 'driver' and banned = 'Yes'\n        )\n), agg as (\n    select\n        request_at,\n        case when status = 'completed' then status else 'canceled' end as status,\n\n        count(distinct id) as trip_count\n    from t\n    group by request_at, status\n    order by request_at, status\n)\n\n\nselect\n    request_at as Day,\n\n    round(sum(case when status = 'canceled' then trip_count else 0 end) / sum(trip_count), 2) as \"Cancellation Rate\"\nfrom agg\nwhere\n    request_at between '2013-10-01' and '2013-10-03'\ngroup by Day\norder by Day\n`\n\nThis works for me"
                    },
                    {
                        "username": "wasitshafi",
                        "content": "# getting .66 in result while its expected result show to be .67\\nmy query \\n```sql\\nwith cte1 as (\\n  select\\n    request_at,\\n    count(*) as total_requests,\\n    sum(\\n      (\\n        case\\n          when status <> \\'completed\\' then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'total_cancelled_trips\\',\\n    sum(\\n      (\\n        case\\n          when status = \\'completed\\'\\n          and (\\n            client_id in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'client\\'\\n            )\\n            or driver_id in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'driver\\'\\n            )\\n          ) then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'banned_completed_trips\\',\\n    sum(\\n      (\\n        case\\n          when status <> \\'completed\\'\\n          and (\\n            client_id not in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'client\\'\\n            )\\n            and driver_id not in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'driver\\'\\n            )\\n          ) then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'unbanned_cancelled_trips\\'\\n  from\\n    trips\\n  group by\\n    request_at\\n),\\ncte2 as (\\n  select\\n    cte1.request_at as Day,\\n    truncate(\\n      (\\n        (cte1.unbanned_cancelled_trips) /(\\n          cte1.total_requests - (\\n            cte1.total_cancelled_trips - cte1.unbanned_cancelled_trips\\n          ) - banned_completed_trips\\n        )\\n      ),\\n      2\\n    ) as \\'Cancellation Rate\\'\\n  from\\n    cte1\\n  where\\n    (\\n      cte1.request_at between \\'2013-10-01\\'\\n      and \\'2013-10-03\\'\\n    )\\n)\\nselect\\n  *\\nfrom\\n  cte2\\nwhere\\n  `Cancellation Rate` is not null\\n```\\n\\nInput:\\n```\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | completed           | 2013-10-01 |\\n| 2  | 2         | 11        | 1       | cancelled_by_driver | 2013-10-01 |\\n| 3  | 3         | 12        | 6       | completed           | 2013-10-01 |\\n| 4  | 4         | 13        | 6       | cancelled_by_client | 2013-10-01 |\\n| 5  | 1         | 10        | 1       | completed           | 2013-10-02 |\\n| 6  | 2         | 11        | 6       | completed           | 2013-10-02 |\\n| 7  | 3         | 12        | 6       | completed           | 2013-10-02 |\\n| 8  | 2         | 12        | 12      | completed           | 2013-10-03 |\\n| 9  | 3         | 10        | 12      | completed           | 2013-10-03 |\\n| 10 | 4         | 13        | 12      | cancelled_by_driver | 2013-10-03 |\\n| 11 | 3         | 10        | 6       | cancelled_by_driver | 2013-10-02 |\\n| 12 | 5         | 12        | 12      | cancelled_by_client | 2013-10-01 |\\n| 13 | 4         | 13        | 1       | cancelled_by_driver | 2013-10-03 |\\n```\\n```\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 2        | Yes    | client |\\n| 3        | No     | client |\\n| 4        | No     | client |\\n| 5        | Yes    | client |\\n| 10       | No     | driver |\\n| 11       | No     | driver |\\n| 12       | No     | driver |\\n| 13       | No     | driver |\\n```\\n\\nResult :\\n```\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-02 | 0.33              |\\n| 2013-10-03 | 0.66              |\\n```\\n\\nExpected:\\n```\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-02 | 0.33              |\\n| 2013-10-03 | 0.67              |\\n```\\n\\n# all of 11 out of 12 test cases passed, i only got wrong ans due to the last cancellation rate, any ony who sees whats wrong with my query...?\\n\\n\\n"
                    },
                    {
                        "username": "jaluthriarohit",
                        "content": "select request_at as Day,\\nround((1.0 * count(case when status in (\\'cancelled_by_driver \\' , \\'cancelled_by_client \\') then 1 else null end)/\\ncount(1)  ),2) as \"Cancellation_Rate\"\\nfrom trips t \\njoin users u on t.client_id=u.users_id\\njoin users u1 on t.client_id=u1.users_id\\nwhere u.banned=\"no\" and u1.banned=\\'No\\'  \\ngroup by request_at\\n\\ncan anybody tell why this is wrong ?\\n"
                    },
                    {
                        "username": "rishavm",
                        "content": "can someone expain why this input has \n\n| id | client_id | driver_id | city_id | status              | request_at |\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\n\n| users_id | banned | role   |\n| -------- | ------ | ------ |\n| 1        | No     | client |\n| 10       | No     | driver |\n\nhas this output\n| Day | Cancellation Rate |\n| --- | ----------------- |\n\nbecause the according to the description cancelled_request/total_request;\n\nEither the test case is wrong or some description is missing"
                    },
                    {
                        "username": "i_only_do_this_for_fun",
                        "content": "Out of range.  Always read the instructions before submitting:\\nWrite a SQL query to find the cancellation rate of requests with unbanned users (both client and driver must not be banned) each day between \"2013-10-01\" and \"2013-10-03\". Round Cancellation Rate to two decimal points."
                    },
                    {
                        "username": "salikhussaini49",
                        "content": "Great Question... "
                    }
                ]
            },
            {
                "id": 1870941,
                "content": [
                    {
                        "username": "arzoop",
                        "content": "My solution fetches the day and null for the days where there are no unbanned transactions. How can I rectify this?\\n```\\nselect \\n(request_at) as Day,\\nround(\\n  (\\n    select count(*) from Trips\\n      inner join Users u1 on trips.client_id=u1.users_id and u1.banned like \"No\" \\n    inner join Users u2 on trips.driver_id=u2.users_id and u2.banned like \"No\"\\n    where\\n    #  u1.banned like \"No\" and u2.banned like \"No\" and\\n   Trips.status like \"cancelled_by%\" and request_at=Day\\n    )\\n  /\\n  (\\n    select count(*) from Trips\\n    inner join Users u1 on trips.client_id=u1.users_id and u1.banned like \"No\"\\n    inner join Users u2 on trips.driver_id=u2.users_id and u2.banned like \"No\"\\n    where \\n    # u1.banned like \"No\" and u2.banned like \"No\" and \\n    request_at=Day\\n  )\\n,2) as `Cancellation Rate`\\nfrom Trips\\ngroup by Day \\nhaving Day between \"2013-10-01\" and \"2013-10-03\" ;\\n```"
                    },
                    {
                        "username": "shailen86",
                        "content": "Don\\'t use round function. Use NVL and to_char(\\'day\\',\\'0.99\\') to get the output"
                    },
                    {
                        "username": "ktramos",
                        "content": "I also found a test case that seems wrong: (9/12)\\nThe test case uses a scenario where an existing users_id = 1, banned value is updated to \\'Yes\\'. \\nThe test case expects the Cancellation Rate output for 10/01 to be NULL, however when I run locally, the Cancellation Rate output for 10/01 is now .50 because there is 1 cancelled row / by are 2 valid rows "
                    },
                    {
                        "username": "MaheshBabuMummalaneni",
                        "content": "with cte1 as (select *,\\n  Case when status = \\'completed\\' then null else 1 end as cancelled_flag\\nfrom trips)\\n\\nselect request_at as Day,cast((count(cancelled_flag)*1.0 /count(status)) as decimal(10,2)) as \\'Cancellation Rate\\' from cte1 c\\nleft join users u\\non c.client_id = u.users_id where banned <> \\'Yes\\' \\ngroup by request_at\\n\\n\\nThe above query is running fine and giving the required output and it is showing as accepted but throwing error while submitting. This is what\\'s happening in many queries. It should let us submit when the answer is correct. Moreover, it is showing answer which is not even related to this question. \\n\\nI never faced this kind of issues with hacker rank. May be, these people have better questions but what\\'s the point when we are not even able to submit correct answers."
                    },
                    {
                        "username": "moeheinag",
                        "content": "I'm trying it to find cancellation_rate for just one date right now. And below is my query:\n\n```\nwith unbanned_trips as\n  (select * from Trips\n  join Users on client_id = users_id\n  or client_id = driver_id\n  where request_at = '2013-10-01'\n  and banned = 'No')\n\nwith unbanned_trip_count as (\n  select count(*) from unbanned_trips\n)\nwith cancelled_trip_count as (\n  select count(*) from unbanned_trips\n  where status = 'cancelled_by_client'\n)\n\nselect unbanned_trip_count / cancelled_trip_count\n```\nHow can I do this?"
                    },
                    {
                        "username": "tooytod",
                        "content": "why I can\\'t get the right result for division?\\nThe number of cancelled and total both correct, but after devision, it shows 0, even I used cast. Anyone knows what should I do to show the correct number? thanks!\\n| request_at | cancelled | total | Cancellation Rate |\\n| ---------- | --------- | ----- | ----------------- |\\n| 2013-10-01 | 1         | 3     | 0                 |\\n| 2013-10-02 | 0         | 2     | 0                 |\\n| 2013-10-03 | 1         | 2     | 0                 |"
                    },
                    {
                        "username": "fsanchez314159",
                        "content": "`\n# Write your MySQL query statement below\n\nwith t as (\n    select *\n    from Trips\n    where\n        client_id not in (\n            select distinct\n                users_id\n            from Users\n            where\n                role = 'client' and banned = 'Yes'\n        )\n        and driver_id not in (\n            select distinct\n                users_id\n            from Users\n            where\n                role = 'driver' and banned = 'Yes'\n        )\n), agg as (\n    select\n        request_at,\n        case when status = 'completed' then status else 'canceled' end as status,\n\n        count(distinct id) as trip_count\n    from t\n    group by request_at, status\n    order by request_at, status\n)\n\n\nselect\n    request_at as Day,\n\n    round(sum(case when status = 'canceled' then trip_count else 0 end) / sum(trip_count), 2) as \"Cancellation Rate\"\nfrom agg\nwhere\n    request_at between '2013-10-01' and '2013-10-03'\ngroup by Day\norder by Day\n`\n\nThis works for me"
                    },
                    {
                        "username": "wasitshafi",
                        "content": "# getting .66 in result while its expected result show to be .67\\nmy query \\n```sql\\nwith cte1 as (\\n  select\\n    request_at,\\n    count(*) as total_requests,\\n    sum(\\n      (\\n        case\\n          when status <> \\'completed\\' then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'total_cancelled_trips\\',\\n    sum(\\n      (\\n        case\\n          when status = \\'completed\\'\\n          and (\\n            client_id in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'client\\'\\n            )\\n            or driver_id in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'driver\\'\\n            )\\n          ) then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'banned_completed_trips\\',\\n    sum(\\n      (\\n        case\\n          when status <> \\'completed\\'\\n          and (\\n            client_id not in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'client\\'\\n            )\\n            and driver_id not in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'driver\\'\\n            )\\n          ) then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'unbanned_cancelled_trips\\'\\n  from\\n    trips\\n  group by\\n    request_at\\n),\\ncte2 as (\\n  select\\n    cte1.request_at as Day,\\n    truncate(\\n      (\\n        (cte1.unbanned_cancelled_trips) /(\\n          cte1.total_requests - (\\n            cte1.total_cancelled_trips - cte1.unbanned_cancelled_trips\\n          ) - banned_completed_trips\\n        )\\n      ),\\n      2\\n    ) as \\'Cancellation Rate\\'\\n  from\\n    cte1\\n  where\\n    (\\n      cte1.request_at between \\'2013-10-01\\'\\n      and \\'2013-10-03\\'\\n    )\\n)\\nselect\\n  *\\nfrom\\n  cte2\\nwhere\\n  `Cancellation Rate` is not null\\n```\\n\\nInput:\\n```\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | completed           | 2013-10-01 |\\n| 2  | 2         | 11        | 1       | cancelled_by_driver | 2013-10-01 |\\n| 3  | 3         | 12        | 6       | completed           | 2013-10-01 |\\n| 4  | 4         | 13        | 6       | cancelled_by_client | 2013-10-01 |\\n| 5  | 1         | 10        | 1       | completed           | 2013-10-02 |\\n| 6  | 2         | 11        | 6       | completed           | 2013-10-02 |\\n| 7  | 3         | 12        | 6       | completed           | 2013-10-02 |\\n| 8  | 2         | 12        | 12      | completed           | 2013-10-03 |\\n| 9  | 3         | 10        | 12      | completed           | 2013-10-03 |\\n| 10 | 4         | 13        | 12      | cancelled_by_driver | 2013-10-03 |\\n| 11 | 3         | 10        | 6       | cancelled_by_driver | 2013-10-02 |\\n| 12 | 5         | 12        | 12      | cancelled_by_client | 2013-10-01 |\\n| 13 | 4         | 13        | 1       | cancelled_by_driver | 2013-10-03 |\\n```\\n```\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 2        | Yes    | client |\\n| 3        | No     | client |\\n| 4        | No     | client |\\n| 5        | Yes    | client |\\n| 10       | No     | driver |\\n| 11       | No     | driver |\\n| 12       | No     | driver |\\n| 13       | No     | driver |\\n```\\n\\nResult :\\n```\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-02 | 0.33              |\\n| 2013-10-03 | 0.66              |\\n```\\n\\nExpected:\\n```\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-02 | 0.33              |\\n| 2013-10-03 | 0.67              |\\n```\\n\\n# all of 11 out of 12 test cases passed, i only got wrong ans due to the last cancellation rate, any ony who sees whats wrong with my query...?\\n\\n\\n"
                    },
                    {
                        "username": "jaluthriarohit",
                        "content": "select request_at as Day,\\nround((1.0 * count(case when status in (\\'cancelled_by_driver \\' , \\'cancelled_by_client \\') then 1 else null end)/\\ncount(1)  ),2) as \"Cancellation_Rate\"\\nfrom trips t \\njoin users u on t.client_id=u.users_id\\njoin users u1 on t.client_id=u1.users_id\\nwhere u.banned=\"no\" and u1.banned=\\'No\\'  \\ngroup by request_at\\n\\ncan anybody tell why this is wrong ?\\n"
                    },
                    {
                        "username": "rishavm",
                        "content": "can someone expain why this input has \n\n| id | client_id | driver_id | city_id | status              | request_at |\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\n\n| users_id | banned | role   |\n| -------- | ------ | ------ |\n| 1        | No     | client |\n| 10       | No     | driver |\n\nhas this output\n| Day | Cancellation Rate |\n| --- | ----------------- |\n\nbecause the according to the description cancelled_request/total_request;\n\nEither the test case is wrong or some description is missing"
                    },
                    {
                        "username": "i_only_do_this_for_fun",
                        "content": "Out of range.  Always read the instructions before submitting:\\nWrite a SQL query to find the cancellation rate of requests with unbanned users (both client and driver must not be banned) each day between \"2013-10-01\" and \"2013-10-03\". Round Cancellation Rate to two decimal points."
                    },
                    {
                        "username": "salikhussaini49",
                        "content": "Great Question... "
                    }
                ]
            },
            {
                "id": 1852733,
                "content": [
                    {
                        "username": "arzoop",
                        "content": "My solution fetches the day and null for the days where there are no unbanned transactions. How can I rectify this?\\n```\\nselect \\n(request_at) as Day,\\nround(\\n  (\\n    select count(*) from Trips\\n      inner join Users u1 on trips.client_id=u1.users_id and u1.banned like \"No\" \\n    inner join Users u2 on trips.driver_id=u2.users_id and u2.banned like \"No\"\\n    where\\n    #  u1.banned like \"No\" and u2.banned like \"No\" and\\n   Trips.status like \"cancelled_by%\" and request_at=Day\\n    )\\n  /\\n  (\\n    select count(*) from Trips\\n    inner join Users u1 on trips.client_id=u1.users_id and u1.banned like \"No\"\\n    inner join Users u2 on trips.driver_id=u2.users_id and u2.banned like \"No\"\\n    where \\n    # u1.banned like \"No\" and u2.banned like \"No\" and \\n    request_at=Day\\n  )\\n,2) as `Cancellation Rate`\\nfrom Trips\\ngroup by Day \\nhaving Day between \"2013-10-01\" and \"2013-10-03\" ;\\n```"
                    },
                    {
                        "username": "shailen86",
                        "content": "Don\\'t use round function. Use NVL and to_char(\\'day\\',\\'0.99\\') to get the output"
                    },
                    {
                        "username": "ktramos",
                        "content": "I also found a test case that seems wrong: (9/12)\\nThe test case uses a scenario where an existing users_id = 1, banned value is updated to \\'Yes\\'. \\nThe test case expects the Cancellation Rate output for 10/01 to be NULL, however when I run locally, the Cancellation Rate output for 10/01 is now .50 because there is 1 cancelled row / by are 2 valid rows "
                    },
                    {
                        "username": "MaheshBabuMummalaneni",
                        "content": "with cte1 as (select *,\\n  Case when status = \\'completed\\' then null else 1 end as cancelled_flag\\nfrom trips)\\n\\nselect request_at as Day,cast((count(cancelled_flag)*1.0 /count(status)) as decimal(10,2)) as \\'Cancellation Rate\\' from cte1 c\\nleft join users u\\non c.client_id = u.users_id where banned <> \\'Yes\\' \\ngroup by request_at\\n\\n\\nThe above query is running fine and giving the required output and it is showing as accepted but throwing error while submitting. This is what\\'s happening in many queries. It should let us submit when the answer is correct. Moreover, it is showing answer which is not even related to this question. \\n\\nI never faced this kind of issues with hacker rank. May be, these people have better questions but what\\'s the point when we are not even able to submit correct answers."
                    },
                    {
                        "username": "moeheinag",
                        "content": "I'm trying it to find cancellation_rate for just one date right now. And below is my query:\n\n```\nwith unbanned_trips as\n  (select * from Trips\n  join Users on client_id = users_id\n  or client_id = driver_id\n  where request_at = '2013-10-01'\n  and banned = 'No')\n\nwith unbanned_trip_count as (\n  select count(*) from unbanned_trips\n)\nwith cancelled_trip_count as (\n  select count(*) from unbanned_trips\n  where status = 'cancelled_by_client'\n)\n\nselect unbanned_trip_count / cancelled_trip_count\n```\nHow can I do this?"
                    },
                    {
                        "username": "tooytod",
                        "content": "why I can\\'t get the right result for division?\\nThe number of cancelled and total both correct, but after devision, it shows 0, even I used cast. Anyone knows what should I do to show the correct number? thanks!\\n| request_at | cancelled | total | Cancellation Rate |\\n| ---------- | --------- | ----- | ----------------- |\\n| 2013-10-01 | 1         | 3     | 0                 |\\n| 2013-10-02 | 0         | 2     | 0                 |\\n| 2013-10-03 | 1         | 2     | 0                 |"
                    },
                    {
                        "username": "fsanchez314159",
                        "content": "`\n# Write your MySQL query statement below\n\nwith t as (\n    select *\n    from Trips\n    where\n        client_id not in (\n            select distinct\n                users_id\n            from Users\n            where\n                role = 'client' and banned = 'Yes'\n        )\n        and driver_id not in (\n            select distinct\n                users_id\n            from Users\n            where\n                role = 'driver' and banned = 'Yes'\n        )\n), agg as (\n    select\n        request_at,\n        case when status = 'completed' then status else 'canceled' end as status,\n\n        count(distinct id) as trip_count\n    from t\n    group by request_at, status\n    order by request_at, status\n)\n\n\nselect\n    request_at as Day,\n\n    round(sum(case when status = 'canceled' then trip_count else 0 end) / sum(trip_count), 2) as \"Cancellation Rate\"\nfrom agg\nwhere\n    request_at between '2013-10-01' and '2013-10-03'\ngroup by Day\norder by Day\n`\n\nThis works for me"
                    },
                    {
                        "username": "wasitshafi",
                        "content": "# getting .66 in result while its expected result show to be .67\\nmy query \\n```sql\\nwith cte1 as (\\n  select\\n    request_at,\\n    count(*) as total_requests,\\n    sum(\\n      (\\n        case\\n          when status <> \\'completed\\' then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'total_cancelled_trips\\',\\n    sum(\\n      (\\n        case\\n          when status = \\'completed\\'\\n          and (\\n            client_id in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'client\\'\\n            )\\n            or driver_id in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'driver\\'\\n            )\\n          ) then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'banned_completed_trips\\',\\n    sum(\\n      (\\n        case\\n          when status <> \\'completed\\'\\n          and (\\n            client_id not in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'client\\'\\n            )\\n            and driver_id not in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'driver\\'\\n            )\\n          ) then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'unbanned_cancelled_trips\\'\\n  from\\n    trips\\n  group by\\n    request_at\\n),\\ncte2 as (\\n  select\\n    cte1.request_at as Day,\\n    truncate(\\n      (\\n        (cte1.unbanned_cancelled_trips) /(\\n          cte1.total_requests - (\\n            cte1.total_cancelled_trips - cte1.unbanned_cancelled_trips\\n          ) - banned_completed_trips\\n        )\\n      ),\\n      2\\n    ) as \\'Cancellation Rate\\'\\n  from\\n    cte1\\n  where\\n    (\\n      cte1.request_at between \\'2013-10-01\\'\\n      and \\'2013-10-03\\'\\n    )\\n)\\nselect\\n  *\\nfrom\\n  cte2\\nwhere\\n  `Cancellation Rate` is not null\\n```\\n\\nInput:\\n```\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | completed           | 2013-10-01 |\\n| 2  | 2         | 11        | 1       | cancelled_by_driver | 2013-10-01 |\\n| 3  | 3         | 12        | 6       | completed           | 2013-10-01 |\\n| 4  | 4         | 13        | 6       | cancelled_by_client | 2013-10-01 |\\n| 5  | 1         | 10        | 1       | completed           | 2013-10-02 |\\n| 6  | 2         | 11        | 6       | completed           | 2013-10-02 |\\n| 7  | 3         | 12        | 6       | completed           | 2013-10-02 |\\n| 8  | 2         | 12        | 12      | completed           | 2013-10-03 |\\n| 9  | 3         | 10        | 12      | completed           | 2013-10-03 |\\n| 10 | 4         | 13        | 12      | cancelled_by_driver | 2013-10-03 |\\n| 11 | 3         | 10        | 6       | cancelled_by_driver | 2013-10-02 |\\n| 12 | 5         | 12        | 12      | cancelled_by_client | 2013-10-01 |\\n| 13 | 4         | 13        | 1       | cancelled_by_driver | 2013-10-03 |\\n```\\n```\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 2        | Yes    | client |\\n| 3        | No     | client |\\n| 4        | No     | client |\\n| 5        | Yes    | client |\\n| 10       | No     | driver |\\n| 11       | No     | driver |\\n| 12       | No     | driver |\\n| 13       | No     | driver |\\n```\\n\\nResult :\\n```\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-02 | 0.33              |\\n| 2013-10-03 | 0.66              |\\n```\\n\\nExpected:\\n```\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-02 | 0.33              |\\n| 2013-10-03 | 0.67              |\\n```\\n\\n# all of 11 out of 12 test cases passed, i only got wrong ans due to the last cancellation rate, any ony who sees whats wrong with my query...?\\n\\n\\n"
                    },
                    {
                        "username": "jaluthriarohit",
                        "content": "select request_at as Day,\\nround((1.0 * count(case when status in (\\'cancelled_by_driver \\' , \\'cancelled_by_client \\') then 1 else null end)/\\ncount(1)  ),2) as \"Cancellation_Rate\"\\nfrom trips t \\njoin users u on t.client_id=u.users_id\\njoin users u1 on t.client_id=u1.users_id\\nwhere u.banned=\"no\" and u1.banned=\\'No\\'  \\ngroup by request_at\\n\\ncan anybody tell why this is wrong ?\\n"
                    },
                    {
                        "username": "rishavm",
                        "content": "can someone expain why this input has \n\n| id | client_id | driver_id | city_id | status              | request_at |\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\n\n| users_id | banned | role   |\n| -------- | ------ | ------ |\n| 1        | No     | client |\n| 10       | No     | driver |\n\nhas this output\n| Day | Cancellation Rate |\n| --- | ----------------- |\n\nbecause the according to the description cancelled_request/total_request;\n\nEither the test case is wrong or some description is missing"
                    },
                    {
                        "username": "i_only_do_this_for_fun",
                        "content": "Out of range.  Always read the instructions before submitting:\\nWrite a SQL query to find the cancellation rate of requests with unbanned users (both client and driver must not be banned) each day between \"2013-10-01\" and \"2013-10-03\". Round Cancellation Rate to two decimal points."
                    },
                    {
                        "username": "salikhussaini49",
                        "content": "Great Question... "
                    }
                ]
            },
            {
                "id": 1846361,
                "content": [
                    {
                        "username": "arzoop",
                        "content": "My solution fetches the day and null for the days where there are no unbanned transactions. How can I rectify this?\\n```\\nselect \\n(request_at) as Day,\\nround(\\n  (\\n    select count(*) from Trips\\n      inner join Users u1 on trips.client_id=u1.users_id and u1.banned like \"No\" \\n    inner join Users u2 on trips.driver_id=u2.users_id and u2.banned like \"No\"\\n    where\\n    #  u1.banned like \"No\" and u2.banned like \"No\" and\\n   Trips.status like \"cancelled_by%\" and request_at=Day\\n    )\\n  /\\n  (\\n    select count(*) from Trips\\n    inner join Users u1 on trips.client_id=u1.users_id and u1.banned like \"No\"\\n    inner join Users u2 on trips.driver_id=u2.users_id and u2.banned like \"No\"\\n    where \\n    # u1.banned like \"No\" and u2.banned like \"No\" and \\n    request_at=Day\\n  )\\n,2) as `Cancellation Rate`\\nfrom Trips\\ngroup by Day \\nhaving Day between \"2013-10-01\" and \"2013-10-03\" ;\\n```"
                    },
                    {
                        "username": "shailen86",
                        "content": "Don\\'t use round function. Use NVL and to_char(\\'day\\',\\'0.99\\') to get the output"
                    },
                    {
                        "username": "ktramos",
                        "content": "I also found a test case that seems wrong: (9/12)\\nThe test case uses a scenario where an existing users_id = 1, banned value is updated to \\'Yes\\'. \\nThe test case expects the Cancellation Rate output for 10/01 to be NULL, however when I run locally, the Cancellation Rate output for 10/01 is now .50 because there is 1 cancelled row / by are 2 valid rows "
                    },
                    {
                        "username": "MaheshBabuMummalaneni",
                        "content": "with cte1 as (select *,\\n  Case when status = \\'completed\\' then null else 1 end as cancelled_flag\\nfrom trips)\\n\\nselect request_at as Day,cast((count(cancelled_flag)*1.0 /count(status)) as decimal(10,2)) as \\'Cancellation Rate\\' from cte1 c\\nleft join users u\\non c.client_id = u.users_id where banned <> \\'Yes\\' \\ngroup by request_at\\n\\n\\nThe above query is running fine and giving the required output and it is showing as accepted but throwing error while submitting. This is what\\'s happening in many queries. It should let us submit when the answer is correct. Moreover, it is showing answer which is not even related to this question. \\n\\nI never faced this kind of issues with hacker rank. May be, these people have better questions but what\\'s the point when we are not even able to submit correct answers."
                    },
                    {
                        "username": "moeheinag",
                        "content": "I'm trying it to find cancellation_rate for just one date right now. And below is my query:\n\n```\nwith unbanned_trips as\n  (select * from Trips\n  join Users on client_id = users_id\n  or client_id = driver_id\n  where request_at = '2013-10-01'\n  and banned = 'No')\n\nwith unbanned_trip_count as (\n  select count(*) from unbanned_trips\n)\nwith cancelled_trip_count as (\n  select count(*) from unbanned_trips\n  where status = 'cancelled_by_client'\n)\n\nselect unbanned_trip_count / cancelled_trip_count\n```\nHow can I do this?"
                    },
                    {
                        "username": "tooytod",
                        "content": "why I can\\'t get the right result for division?\\nThe number of cancelled and total both correct, but after devision, it shows 0, even I used cast. Anyone knows what should I do to show the correct number? thanks!\\n| request_at | cancelled | total | Cancellation Rate |\\n| ---------- | --------- | ----- | ----------------- |\\n| 2013-10-01 | 1         | 3     | 0                 |\\n| 2013-10-02 | 0         | 2     | 0                 |\\n| 2013-10-03 | 1         | 2     | 0                 |"
                    },
                    {
                        "username": "fsanchez314159",
                        "content": "`\n# Write your MySQL query statement below\n\nwith t as (\n    select *\n    from Trips\n    where\n        client_id not in (\n            select distinct\n                users_id\n            from Users\n            where\n                role = 'client' and banned = 'Yes'\n        )\n        and driver_id not in (\n            select distinct\n                users_id\n            from Users\n            where\n                role = 'driver' and banned = 'Yes'\n        )\n), agg as (\n    select\n        request_at,\n        case when status = 'completed' then status else 'canceled' end as status,\n\n        count(distinct id) as trip_count\n    from t\n    group by request_at, status\n    order by request_at, status\n)\n\n\nselect\n    request_at as Day,\n\n    round(sum(case when status = 'canceled' then trip_count else 0 end) / sum(trip_count), 2) as \"Cancellation Rate\"\nfrom agg\nwhere\n    request_at between '2013-10-01' and '2013-10-03'\ngroup by Day\norder by Day\n`\n\nThis works for me"
                    },
                    {
                        "username": "wasitshafi",
                        "content": "# getting .66 in result while its expected result show to be .67\\nmy query \\n```sql\\nwith cte1 as (\\n  select\\n    request_at,\\n    count(*) as total_requests,\\n    sum(\\n      (\\n        case\\n          when status <> \\'completed\\' then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'total_cancelled_trips\\',\\n    sum(\\n      (\\n        case\\n          when status = \\'completed\\'\\n          and (\\n            client_id in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'client\\'\\n            )\\n            or driver_id in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'driver\\'\\n            )\\n          ) then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'banned_completed_trips\\',\\n    sum(\\n      (\\n        case\\n          when status <> \\'completed\\'\\n          and (\\n            client_id not in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'client\\'\\n            )\\n            and driver_id not in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'driver\\'\\n            )\\n          ) then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'unbanned_cancelled_trips\\'\\n  from\\n    trips\\n  group by\\n    request_at\\n),\\ncte2 as (\\n  select\\n    cte1.request_at as Day,\\n    truncate(\\n      (\\n        (cte1.unbanned_cancelled_trips) /(\\n          cte1.total_requests - (\\n            cte1.total_cancelled_trips - cte1.unbanned_cancelled_trips\\n          ) - banned_completed_trips\\n        )\\n      ),\\n      2\\n    ) as \\'Cancellation Rate\\'\\n  from\\n    cte1\\n  where\\n    (\\n      cte1.request_at between \\'2013-10-01\\'\\n      and \\'2013-10-03\\'\\n    )\\n)\\nselect\\n  *\\nfrom\\n  cte2\\nwhere\\n  `Cancellation Rate` is not null\\n```\\n\\nInput:\\n```\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | completed           | 2013-10-01 |\\n| 2  | 2         | 11        | 1       | cancelled_by_driver | 2013-10-01 |\\n| 3  | 3         | 12        | 6       | completed           | 2013-10-01 |\\n| 4  | 4         | 13        | 6       | cancelled_by_client | 2013-10-01 |\\n| 5  | 1         | 10        | 1       | completed           | 2013-10-02 |\\n| 6  | 2         | 11        | 6       | completed           | 2013-10-02 |\\n| 7  | 3         | 12        | 6       | completed           | 2013-10-02 |\\n| 8  | 2         | 12        | 12      | completed           | 2013-10-03 |\\n| 9  | 3         | 10        | 12      | completed           | 2013-10-03 |\\n| 10 | 4         | 13        | 12      | cancelled_by_driver | 2013-10-03 |\\n| 11 | 3         | 10        | 6       | cancelled_by_driver | 2013-10-02 |\\n| 12 | 5         | 12        | 12      | cancelled_by_client | 2013-10-01 |\\n| 13 | 4         | 13        | 1       | cancelled_by_driver | 2013-10-03 |\\n```\\n```\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 2        | Yes    | client |\\n| 3        | No     | client |\\n| 4        | No     | client |\\n| 5        | Yes    | client |\\n| 10       | No     | driver |\\n| 11       | No     | driver |\\n| 12       | No     | driver |\\n| 13       | No     | driver |\\n```\\n\\nResult :\\n```\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-02 | 0.33              |\\n| 2013-10-03 | 0.66              |\\n```\\n\\nExpected:\\n```\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-02 | 0.33              |\\n| 2013-10-03 | 0.67              |\\n```\\n\\n# all of 11 out of 12 test cases passed, i only got wrong ans due to the last cancellation rate, any ony who sees whats wrong with my query...?\\n\\n\\n"
                    },
                    {
                        "username": "jaluthriarohit",
                        "content": "select request_at as Day,\\nround((1.0 * count(case when status in (\\'cancelled_by_driver \\' , \\'cancelled_by_client \\') then 1 else null end)/\\ncount(1)  ),2) as \"Cancellation_Rate\"\\nfrom trips t \\njoin users u on t.client_id=u.users_id\\njoin users u1 on t.client_id=u1.users_id\\nwhere u.banned=\"no\" and u1.banned=\\'No\\'  \\ngroup by request_at\\n\\ncan anybody tell why this is wrong ?\\n"
                    },
                    {
                        "username": "rishavm",
                        "content": "can someone expain why this input has \n\n| id | client_id | driver_id | city_id | status              | request_at |\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\n\n| users_id | banned | role   |\n| -------- | ------ | ------ |\n| 1        | No     | client |\n| 10       | No     | driver |\n\nhas this output\n| Day | Cancellation Rate |\n| --- | ----------------- |\n\nbecause the according to the description cancelled_request/total_request;\n\nEither the test case is wrong or some description is missing"
                    },
                    {
                        "username": "i_only_do_this_for_fun",
                        "content": "Out of range.  Always read the instructions before submitting:\\nWrite a SQL query to find the cancellation rate of requests with unbanned users (both client and driver must not be banned) each day between \"2013-10-01\" and \"2013-10-03\". Round Cancellation Rate to two decimal points."
                    },
                    {
                        "username": "salikhussaini49",
                        "content": "Great Question... "
                    }
                ]
            },
            {
                "id": 1844949,
                "content": [
                    {
                        "username": "arzoop",
                        "content": "My solution fetches the day and null for the days where there are no unbanned transactions. How can I rectify this?\\n```\\nselect \\n(request_at) as Day,\\nround(\\n  (\\n    select count(*) from Trips\\n      inner join Users u1 on trips.client_id=u1.users_id and u1.banned like \"No\" \\n    inner join Users u2 on trips.driver_id=u2.users_id and u2.banned like \"No\"\\n    where\\n    #  u1.banned like \"No\" and u2.banned like \"No\" and\\n   Trips.status like \"cancelled_by%\" and request_at=Day\\n    )\\n  /\\n  (\\n    select count(*) from Trips\\n    inner join Users u1 on trips.client_id=u1.users_id and u1.banned like \"No\"\\n    inner join Users u2 on trips.driver_id=u2.users_id and u2.banned like \"No\"\\n    where \\n    # u1.banned like \"No\" and u2.banned like \"No\" and \\n    request_at=Day\\n  )\\n,2) as `Cancellation Rate`\\nfrom Trips\\ngroup by Day \\nhaving Day between \"2013-10-01\" and \"2013-10-03\" ;\\n```"
                    },
                    {
                        "username": "shailen86",
                        "content": "Don\\'t use round function. Use NVL and to_char(\\'day\\',\\'0.99\\') to get the output"
                    },
                    {
                        "username": "ktramos",
                        "content": "I also found a test case that seems wrong: (9/12)\\nThe test case uses a scenario where an existing users_id = 1, banned value is updated to \\'Yes\\'. \\nThe test case expects the Cancellation Rate output for 10/01 to be NULL, however when I run locally, the Cancellation Rate output for 10/01 is now .50 because there is 1 cancelled row / by are 2 valid rows "
                    },
                    {
                        "username": "MaheshBabuMummalaneni",
                        "content": "with cte1 as (select *,\\n  Case when status = \\'completed\\' then null else 1 end as cancelled_flag\\nfrom trips)\\n\\nselect request_at as Day,cast((count(cancelled_flag)*1.0 /count(status)) as decimal(10,2)) as \\'Cancellation Rate\\' from cte1 c\\nleft join users u\\non c.client_id = u.users_id where banned <> \\'Yes\\' \\ngroup by request_at\\n\\n\\nThe above query is running fine and giving the required output and it is showing as accepted but throwing error while submitting. This is what\\'s happening in many queries. It should let us submit when the answer is correct. Moreover, it is showing answer which is not even related to this question. \\n\\nI never faced this kind of issues with hacker rank. May be, these people have better questions but what\\'s the point when we are not even able to submit correct answers."
                    },
                    {
                        "username": "moeheinag",
                        "content": "I'm trying it to find cancellation_rate for just one date right now. And below is my query:\n\n```\nwith unbanned_trips as\n  (select * from Trips\n  join Users on client_id = users_id\n  or client_id = driver_id\n  where request_at = '2013-10-01'\n  and banned = 'No')\n\nwith unbanned_trip_count as (\n  select count(*) from unbanned_trips\n)\nwith cancelled_trip_count as (\n  select count(*) from unbanned_trips\n  where status = 'cancelled_by_client'\n)\n\nselect unbanned_trip_count / cancelled_trip_count\n```\nHow can I do this?"
                    },
                    {
                        "username": "tooytod",
                        "content": "why I can\\'t get the right result for division?\\nThe number of cancelled and total both correct, but after devision, it shows 0, even I used cast. Anyone knows what should I do to show the correct number? thanks!\\n| request_at | cancelled | total | Cancellation Rate |\\n| ---------- | --------- | ----- | ----------------- |\\n| 2013-10-01 | 1         | 3     | 0                 |\\n| 2013-10-02 | 0         | 2     | 0                 |\\n| 2013-10-03 | 1         | 2     | 0                 |"
                    },
                    {
                        "username": "fsanchez314159",
                        "content": "`\n# Write your MySQL query statement below\n\nwith t as (\n    select *\n    from Trips\n    where\n        client_id not in (\n            select distinct\n                users_id\n            from Users\n            where\n                role = 'client' and banned = 'Yes'\n        )\n        and driver_id not in (\n            select distinct\n                users_id\n            from Users\n            where\n                role = 'driver' and banned = 'Yes'\n        )\n), agg as (\n    select\n        request_at,\n        case when status = 'completed' then status else 'canceled' end as status,\n\n        count(distinct id) as trip_count\n    from t\n    group by request_at, status\n    order by request_at, status\n)\n\n\nselect\n    request_at as Day,\n\n    round(sum(case when status = 'canceled' then trip_count else 0 end) / sum(trip_count), 2) as \"Cancellation Rate\"\nfrom agg\nwhere\n    request_at between '2013-10-01' and '2013-10-03'\ngroup by Day\norder by Day\n`\n\nThis works for me"
                    },
                    {
                        "username": "wasitshafi",
                        "content": "# getting .66 in result while its expected result show to be .67\\nmy query \\n```sql\\nwith cte1 as (\\n  select\\n    request_at,\\n    count(*) as total_requests,\\n    sum(\\n      (\\n        case\\n          when status <> \\'completed\\' then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'total_cancelled_trips\\',\\n    sum(\\n      (\\n        case\\n          when status = \\'completed\\'\\n          and (\\n            client_id in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'client\\'\\n            )\\n            or driver_id in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'driver\\'\\n            )\\n          ) then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'banned_completed_trips\\',\\n    sum(\\n      (\\n        case\\n          when status <> \\'completed\\'\\n          and (\\n            client_id not in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'client\\'\\n            )\\n            and driver_id not in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'driver\\'\\n            )\\n          ) then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'unbanned_cancelled_trips\\'\\n  from\\n    trips\\n  group by\\n    request_at\\n),\\ncte2 as (\\n  select\\n    cte1.request_at as Day,\\n    truncate(\\n      (\\n        (cte1.unbanned_cancelled_trips) /(\\n          cte1.total_requests - (\\n            cte1.total_cancelled_trips - cte1.unbanned_cancelled_trips\\n          ) - banned_completed_trips\\n        )\\n      ),\\n      2\\n    ) as \\'Cancellation Rate\\'\\n  from\\n    cte1\\n  where\\n    (\\n      cte1.request_at between \\'2013-10-01\\'\\n      and \\'2013-10-03\\'\\n    )\\n)\\nselect\\n  *\\nfrom\\n  cte2\\nwhere\\n  `Cancellation Rate` is not null\\n```\\n\\nInput:\\n```\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | completed           | 2013-10-01 |\\n| 2  | 2         | 11        | 1       | cancelled_by_driver | 2013-10-01 |\\n| 3  | 3         | 12        | 6       | completed           | 2013-10-01 |\\n| 4  | 4         | 13        | 6       | cancelled_by_client | 2013-10-01 |\\n| 5  | 1         | 10        | 1       | completed           | 2013-10-02 |\\n| 6  | 2         | 11        | 6       | completed           | 2013-10-02 |\\n| 7  | 3         | 12        | 6       | completed           | 2013-10-02 |\\n| 8  | 2         | 12        | 12      | completed           | 2013-10-03 |\\n| 9  | 3         | 10        | 12      | completed           | 2013-10-03 |\\n| 10 | 4         | 13        | 12      | cancelled_by_driver | 2013-10-03 |\\n| 11 | 3         | 10        | 6       | cancelled_by_driver | 2013-10-02 |\\n| 12 | 5         | 12        | 12      | cancelled_by_client | 2013-10-01 |\\n| 13 | 4         | 13        | 1       | cancelled_by_driver | 2013-10-03 |\\n```\\n```\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 2        | Yes    | client |\\n| 3        | No     | client |\\n| 4        | No     | client |\\n| 5        | Yes    | client |\\n| 10       | No     | driver |\\n| 11       | No     | driver |\\n| 12       | No     | driver |\\n| 13       | No     | driver |\\n```\\n\\nResult :\\n```\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-02 | 0.33              |\\n| 2013-10-03 | 0.66              |\\n```\\n\\nExpected:\\n```\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-02 | 0.33              |\\n| 2013-10-03 | 0.67              |\\n```\\n\\n# all of 11 out of 12 test cases passed, i only got wrong ans due to the last cancellation rate, any ony who sees whats wrong with my query...?\\n\\n\\n"
                    },
                    {
                        "username": "jaluthriarohit",
                        "content": "select request_at as Day,\\nround((1.0 * count(case when status in (\\'cancelled_by_driver \\' , \\'cancelled_by_client \\') then 1 else null end)/\\ncount(1)  ),2) as \"Cancellation_Rate\"\\nfrom trips t \\njoin users u on t.client_id=u.users_id\\njoin users u1 on t.client_id=u1.users_id\\nwhere u.banned=\"no\" and u1.banned=\\'No\\'  \\ngroup by request_at\\n\\ncan anybody tell why this is wrong ?\\n"
                    },
                    {
                        "username": "rishavm",
                        "content": "can someone expain why this input has \n\n| id | client_id | driver_id | city_id | status              | request_at |\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\n\n| users_id | banned | role   |\n| -------- | ------ | ------ |\n| 1        | No     | client |\n| 10       | No     | driver |\n\nhas this output\n| Day | Cancellation Rate |\n| --- | ----------------- |\n\nbecause the according to the description cancelled_request/total_request;\n\nEither the test case is wrong or some description is missing"
                    },
                    {
                        "username": "i_only_do_this_for_fun",
                        "content": "Out of range.  Always read the instructions before submitting:\\nWrite a SQL query to find the cancellation rate of requests with unbanned users (both client and driver must not be banned) each day between \"2013-10-01\" and \"2013-10-03\". Round Cancellation Rate to two decimal points."
                    },
                    {
                        "username": "salikhussaini49",
                        "content": "Great Question... "
                    }
                ]
            },
            {
                "id": 1833916,
                "content": [
                    {
                        "username": "arzoop",
                        "content": "My solution fetches the day and null for the days where there are no unbanned transactions. How can I rectify this?\\n```\\nselect \\n(request_at) as Day,\\nround(\\n  (\\n    select count(*) from Trips\\n      inner join Users u1 on trips.client_id=u1.users_id and u1.banned like \"No\" \\n    inner join Users u2 on trips.driver_id=u2.users_id and u2.banned like \"No\"\\n    where\\n    #  u1.banned like \"No\" and u2.banned like \"No\" and\\n   Trips.status like \"cancelled_by%\" and request_at=Day\\n    )\\n  /\\n  (\\n    select count(*) from Trips\\n    inner join Users u1 on trips.client_id=u1.users_id and u1.banned like \"No\"\\n    inner join Users u2 on trips.driver_id=u2.users_id and u2.banned like \"No\"\\n    where \\n    # u1.banned like \"No\" and u2.banned like \"No\" and \\n    request_at=Day\\n  )\\n,2) as `Cancellation Rate`\\nfrom Trips\\ngroup by Day \\nhaving Day between \"2013-10-01\" and \"2013-10-03\" ;\\n```"
                    },
                    {
                        "username": "shailen86",
                        "content": "Don\\'t use round function. Use NVL and to_char(\\'day\\',\\'0.99\\') to get the output"
                    },
                    {
                        "username": "ktramos",
                        "content": "I also found a test case that seems wrong: (9/12)\\nThe test case uses a scenario where an existing users_id = 1, banned value is updated to \\'Yes\\'. \\nThe test case expects the Cancellation Rate output for 10/01 to be NULL, however when I run locally, the Cancellation Rate output for 10/01 is now .50 because there is 1 cancelled row / by are 2 valid rows "
                    },
                    {
                        "username": "MaheshBabuMummalaneni",
                        "content": "with cte1 as (select *,\\n  Case when status = \\'completed\\' then null else 1 end as cancelled_flag\\nfrom trips)\\n\\nselect request_at as Day,cast((count(cancelled_flag)*1.0 /count(status)) as decimal(10,2)) as \\'Cancellation Rate\\' from cte1 c\\nleft join users u\\non c.client_id = u.users_id where banned <> \\'Yes\\' \\ngroup by request_at\\n\\n\\nThe above query is running fine and giving the required output and it is showing as accepted but throwing error while submitting. This is what\\'s happening in many queries. It should let us submit when the answer is correct. Moreover, it is showing answer which is not even related to this question. \\n\\nI never faced this kind of issues with hacker rank. May be, these people have better questions but what\\'s the point when we are not even able to submit correct answers."
                    },
                    {
                        "username": "moeheinag",
                        "content": "I'm trying it to find cancellation_rate for just one date right now. And below is my query:\n\n```\nwith unbanned_trips as\n  (select * from Trips\n  join Users on client_id = users_id\n  or client_id = driver_id\n  where request_at = '2013-10-01'\n  and banned = 'No')\n\nwith unbanned_trip_count as (\n  select count(*) from unbanned_trips\n)\nwith cancelled_trip_count as (\n  select count(*) from unbanned_trips\n  where status = 'cancelled_by_client'\n)\n\nselect unbanned_trip_count / cancelled_trip_count\n```\nHow can I do this?"
                    },
                    {
                        "username": "tooytod",
                        "content": "why I can\\'t get the right result for division?\\nThe number of cancelled and total both correct, but after devision, it shows 0, even I used cast. Anyone knows what should I do to show the correct number? thanks!\\n| request_at | cancelled | total | Cancellation Rate |\\n| ---------- | --------- | ----- | ----------------- |\\n| 2013-10-01 | 1         | 3     | 0                 |\\n| 2013-10-02 | 0         | 2     | 0                 |\\n| 2013-10-03 | 1         | 2     | 0                 |"
                    },
                    {
                        "username": "fsanchez314159",
                        "content": "`\n# Write your MySQL query statement below\n\nwith t as (\n    select *\n    from Trips\n    where\n        client_id not in (\n            select distinct\n                users_id\n            from Users\n            where\n                role = 'client' and banned = 'Yes'\n        )\n        and driver_id not in (\n            select distinct\n                users_id\n            from Users\n            where\n                role = 'driver' and banned = 'Yes'\n        )\n), agg as (\n    select\n        request_at,\n        case when status = 'completed' then status else 'canceled' end as status,\n\n        count(distinct id) as trip_count\n    from t\n    group by request_at, status\n    order by request_at, status\n)\n\n\nselect\n    request_at as Day,\n\n    round(sum(case when status = 'canceled' then trip_count else 0 end) / sum(trip_count), 2) as \"Cancellation Rate\"\nfrom agg\nwhere\n    request_at between '2013-10-01' and '2013-10-03'\ngroup by Day\norder by Day\n`\n\nThis works for me"
                    },
                    {
                        "username": "wasitshafi",
                        "content": "# getting .66 in result while its expected result show to be .67\\nmy query \\n```sql\\nwith cte1 as (\\n  select\\n    request_at,\\n    count(*) as total_requests,\\n    sum(\\n      (\\n        case\\n          when status <> \\'completed\\' then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'total_cancelled_trips\\',\\n    sum(\\n      (\\n        case\\n          when status = \\'completed\\'\\n          and (\\n            client_id in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'client\\'\\n            )\\n            or driver_id in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'driver\\'\\n            )\\n          ) then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'banned_completed_trips\\',\\n    sum(\\n      (\\n        case\\n          when status <> \\'completed\\'\\n          and (\\n            client_id not in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'client\\'\\n            )\\n            and driver_id not in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'driver\\'\\n            )\\n          ) then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'unbanned_cancelled_trips\\'\\n  from\\n    trips\\n  group by\\n    request_at\\n),\\ncte2 as (\\n  select\\n    cte1.request_at as Day,\\n    truncate(\\n      (\\n        (cte1.unbanned_cancelled_trips) /(\\n          cte1.total_requests - (\\n            cte1.total_cancelled_trips - cte1.unbanned_cancelled_trips\\n          ) - banned_completed_trips\\n        )\\n      ),\\n      2\\n    ) as \\'Cancellation Rate\\'\\n  from\\n    cte1\\n  where\\n    (\\n      cte1.request_at between \\'2013-10-01\\'\\n      and \\'2013-10-03\\'\\n    )\\n)\\nselect\\n  *\\nfrom\\n  cte2\\nwhere\\n  `Cancellation Rate` is not null\\n```\\n\\nInput:\\n```\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | completed           | 2013-10-01 |\\n| 2  | 2         | 11        | 1       | cancelled_by_driver | 2013-10-01 |\\n| 3  | 3         | 12        | 6       | completed           | 2013-10-01 |\\n| 4  | 4         | 13        | 6       | cancelled_by_client | 2013-10-01 |\\n| 5  | 1         | 10        | 1       | completed           | 2013-10-02 |\\n| 6  | 2         | 11        | 6       | completed           | 2013-10-02 |\\n| 7  | 3         | 12        | 6       | completed           | 2013-10-02 |\\n| 8  | 2         | 12        | 12      | completed           | 2013-10-03 |\\n| 9  | 3         | 10        | 12      | completed           | 2013-10-03 |\\n| 10 | 4         | 13        | 12      | cancelled_by_driver | 2013-10-03 |\\n| 11 | 3         | 10        | 6       | cancelled_by_driver | 2013-10-02 |\\n| 12 | 5         | 12        | 12      | cancelled_by_client | 2013-10-01 |\\n| 13 | 4         | 13        | 1       | cancelled_by_driver | 2013-10-03 |\\n```\\n```\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 2        | Yes    | client |\\n| 3        | No     | client |\\n| 4        | No     | client |\\n| 5        | Yes    | client |\\n| 10       | No     | driver |\\n| 11       | No     | driver |\\n| 12       | No     | driver |\\n| 13       | No     | driver |\\n```\\n\\nResult :\\n```\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-02 | 0.33              |\\n| 2013-10-03 | 0.66              |\\n```\\n\\nExpected:\\n```\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-02 | 0.33              |\\n| 2013-10-03 | 0.67              |\\n```\\n\\n# all of 11 out of 12 test cases passed, i only got wrong ans due to the last cancellation rate, any ony who sees whats wrong with my query...?\\n\\n\\n"
                    },
                    {
                        "username": "jaluthriarohit",
                        "content": "select request_at as Day,\\nround((1.0 * count(case when status in (\\'cancelled_by_driver \\' , \\'cancelled_by_client \\') then 1 else null end)/\\ncount(1)  ),2) as \"Cancellation_Rate\"\\nfrom trips t \\njoin users u on t.client_id=u.users_id\\njoin users u1 on t.client_id=u1.users_id\\nwhere u.banned=\"no\" and u1.banned=\\'No\\'  \\ngroup by request_at\\n\\ncan anybody tell why this is wrong ?\\n"
                    },
                    {
                        "username": "rishavm",
                        "content": "can someone expain why this input has \n\n| id | client_id | driver_id | city_id | status              | request_at |\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\n\n| users_id | banned | role   |\n| -------- | ------ | ------ |\n| 1        | No     | client |\n| 10       | No     | driver |\n\nhas this output\n| Day | Cancellation Rate |\n| --- | ----------------- |\n\nbecause the according to the description cancelled_request/total_request;\n\nEither the test case is wrong or some description is missing"
                    },
                    {
                        "username": "i_only_do_this_for_fun",
                        "content": "Out of range.  Always read the instructions before submitting:\\nWrite a SQL query to find the cancellation rate of requests with unbanned users (both client and driver must not be banned) each day between \"2013-10-01\" and \"2013-10-03\". Round Cancellation Rate to two decimal points."
                    },
                    {
                        "username": "salikhussaini49",
                        "content": "Great Question... "
                    }
                ]
            },
            {
                "id": 1833195,
                "content": [
                    {
                        "username": "arzoop",
                        "content": "My solution fetches the day and null for the days where there are no unbanned transactions. How can I rectify this?\\n```\\nselect \\n(request_at) as Day,\\nround(\\n  (\\n    select count(*) from Trips\\n      inner join Users u1 on trips.client_id=u1.users_id and u1.banned like \"No\" \\n    inner join Users u2 on trips.driver_id=u2.users_id and u2.banned like \"No\"\\n    where\\n    #  u1.banned like \"No\" and u2.banned like \"No\" and\\n   Trips.status like \"cancelled_by%\" and request_at=Day\\n    )\\n  /\\n  (\\n    select count(*) from Trips\\n    inner join Users u1 on trips.client_id=u1.users_id and u1.banned like \"No\"\\n    inner join Users u2 on trips.driver_id=u2.users_id and u2.banned like \"No\"\\n    where \\n    # u1.banned like \"No\" and u2.banned like \"No\" and \\n    request_at=Day\\n  )\\n,2) as `Cancellation Rate`\\nfrom Trips\\ngroup by Day \\nhaving Day between \"2013-10-01\" and \"2013-10-03\" ;\\n```"
                    },
                    {
                        "username": "shailen86",
                        "content": "Don\\'t use round function. Use NVL and to_char(\\'day\\',\\'0.99\\') to get the output"
                    },
                    {
                        "username": "ktramos",
                        "content": "I also found a test case that seems wrong: (9/12)\\nThe test case uses a scenario where an existing users_id = 1, banned value is updated to \\'Yes\\'. \\nThe test case expects the Cancellation Rate output for 10/01 to be NULL, however when I run locally, the Cancellation Rate output for 10/01 is now .50 because there is 1 cancelled row / by are 2 valid rows "
                    },
                    {
                        "username": "MaheshBabuMummalaneni",
                        "content": "with cte1 as (select *,\\n  Case when status = \\'completed\\' then null else 1 end as cancelled_flag\\nfrom trips)\\n\\nselect request_at as Day,cast((count(cancelled_flag)*1.0 /count(status)) as decimal(10,2)) as \\'Cancellation Rate\\' from cte1 c\\nleft join users u\\non c.client_id = u.users_id where banned <> \\'Yes\\' \\ngroup by request_at\\n\\n\\nThe above query is running fine and giving the required output and it is showing as accepted but throwing error while submitting. This is what\\'s happening in many queries. It should let us submit when the answer is correct. Moreover, it is showing answer which is not even related to this question. \\n\\nI never faced this kind of issues with hacker rank. May be, these people have better questions but what\\'s the point when we are not even able to submit correct answers."
                    },
                    {
                        "username": "moeheinag",
                        "content": "I'm trying it to find cancellation_rate for just one date right now. And below is my query:\n\n```\nwith unbanned_trips as\n  (select * from Trips\n  join Users on client_id = users_id\n  or client_id = driver_id\n  where request_at = '2013-10-01'\n  and banned = 'No')\n\nwith unbanned_trip_count as (\n  select count(*) from unbanned_trips\n)\nwith cancelled_trip_count as (\n  select count(*) from unbanned_trips\n  where status = 'cancelled_by_client'\n)\n\nselect unbanned_trip_count / cancelled_trip_count\n```\nHow can I do this?"
                    },
                    {
                        "username": "tooytod",
                        "content": "why I can\\'t get the right result for division?\\nThe number of cancelled and total both correct, but after devision, it shows 0, even I used cast. Anyone knows what should I do to show the correct number? thanks!\\n| request_at | cancelled | total | Cancellation Rate |\\n| ---------- | --------- | ----- | ----------------- |\\n| 2013-10-01 | 1         | 3     | 0                 |\\n| 2013-10-02 | 0         | 2     | 0                 |\\n| 2013-10-03 | 1         | 2     | 0                 |"
                    },
                    {
                        "username": "fsanchez314159",
                        "content": "`\n# Write your MySQL query statement below\n\nwith t as (\n    select *\n    from Trips\n    where\n        client_id not in (\n            select distinct\n                users_id\n            from Users\n            where\n                role = 'client' and banned = 'Yes'\n        )\n        and driver_id not in (\n            select distinct\n                users_id\n            from Users\n            where\n                role = 'driver' and banned = 'Yes'\n        )\n), agg as (\n    select\n        request_at,\n        case when status = 'completed' then status else 'canceled' end as status,\n\n        count(distinct id) as trip_count\n    from t\n    group by request_at, status\n    order by request_at, status\n)\n\n\nselect\n    request_at as Day,\n\n    round(sum(case when status = 'canceled' then trip_count else 0 end) / sum(trip_count), 2) as \"Cancellation Rate\"\nfrom agg\nwhere\n    request_at between '2013-10-01' and '2013-10-03'\ngroup by Day\norder by Day\n`\n\nThis works for me"
                    },
                    {
                        "username": "wasitshafi",
                        "content": "# getting .66 in result while its expected result show to be .67\\nmy query \\n```sql\\nwith cte1 as (\\n  select\\n    request_at,\\n    count(*) as total_requests,\\n    sum(\\n      (\\n        case\\n          when status <> \\'completed\\' then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'total_cancelled_trips\\',\\n    sum(\\n      (\\n        case\\n          when status = \\'completed\\'\\n          and (\\n            client_id in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'client\\'\\n            )\\n            or driver_id in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'driver\\'\\n            )\\n          ) then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'banned_completed_trips\\',\\n    sum(\\n      (\\n        case\\n          when status <> \\'completed\\'\\n          and (\\n            client_id not in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'client\\'\\n            )\\n            and driver_id not in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'driver\\'\\n            )\\n          ) then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'unbanned_cancelled_trips\\'\\n  from\\n    trips\\n  group by\\n    request_at\\n),\\ncte2 as (\\n  select\\n    cte1.request_at as Day,\\n    truncate(\\n      (\\n        (cte1.unbanned_cancelled_trips) /(\\n          cte1.total_requests - (\\n            cte1.total_cancelled_trips - cte1.unbanned_cancelled_trips\\n          ) - banned_completed_trips\\n        )\\n      ),\\n      2\\n    ) as \\'Cancellation Rate\\'\\n  from\\n    cte1\\n  where\\n    (\\n      cte1.request_at between \\'2013-10-01\\'\\n      and \\'2013-10-03\\'\\n    )\\n)\\nselect\\n  *\\nfrom\\n  cte2\\nwhere\\n  `Cancellation Rate` is not null\\n```\\n\\nInput:\\n```\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | completed           | 2013-10-01 |\\n| 2  | 2         | 11        | 1       | cancelled_by_driver | 2013-10-01 |\\n| 3  | 3         | 12        | 6       | completed           | 2013-10-01 |\\n| 4  | 4         | 13        | 6       | cancelled_by_client | 2013-10-01 |\\n| 5  | 1         | 10        | 1       | completed           | 2013-10-02 |\\n| 6  | 2         | 11        | 6       | completed           | 2013-10-02 |\\n| 7  | 3         | 12        | 6       | completed           | 2013-10-02 |\\n| 8  | 2         | 12        | 12      | completed           | 2013-10-03 |\\n| 9  | 3         | 10        | 12      | completed           | 2013-10-03 |\\n| 10 | 4         | 13        | 12      | cancelled_by_driver | 2013-10-03 |\\n| 11 | 3         | 10        | 6       | cancelled_by_driver | 2013-10-02 |\\n| 12 | 5         | 12        | 12      | cancelled_by_client | 2013-10-01 |\\n| 13 | 4         | 13        | 1       | cancelled_by_driver | 2013-10-03 |\\n```\\n```\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 2        | Yes    | client |\\n| 3        | No     | client |\\n| 4        | No     | client |\\n| 5        | Yes    | client |\\n| 10       | No     | driver |\\n| 11       | No     | driver |\\n| 12       | No     | driver |\\n| 13       | No     | driver |\\n```\\n\\nResult :\\n```\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-02 | 0.33              |\\n| 2013-10-03 | 0.66              |\\n```\\n\\nExpected:\\n```\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-02 | 0.33              |\\n| 2013-10-03 | 0.67              |\\n```\\n\\n# all of 11 out of 12 test cases passed, i only got wrong ans due to the last cancellation rate, any ony who sees whats wrong with my query...?\\n\\n\\n"
                    },
                    {
                        "username": "jaluthriarohit",
                        "content": "select request_at as Day,\\nround((1.0 * count(case when status in (\\'cancelled_by_driver \\' , \\'cancelled_by_client \\') then 1 else null end)/\\ncount(1)  ),2) as \"Cancellation_Rate\"\\nfrom trips t \\njoin users u on t.client_id=u.users_id\\njoin users u1 on t.client_id=u1.users_id\\nwhere u.banned=\"no\" and u1.banned=\\'No\\'  \\ngroup by request_at\\n\\ncan anybody tell why this is wrong ?\\n"
                    },
                    {
                        "username": "rishavm",
                        "content": "can someone expain why this input has \n\n| id | client_id | driver_id | city_id | status              | request_at |\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\n\n| users_id | banned | role   |\n| -------- | ------ | ------ |\n| 1        | No     | client |\n| 10       | No     | driver |\n\nhas this output\n| Day | Cancellation Rate |\n| --- | ----------------- |\n\nbecause the according to the description cancelled_request/total_request;\n\nEither the test case is wrong or some description is missing"
                    },
                    {
                        "username": "i_only_do_this_for_fun",
                        "content": "Out of range.  Always read the instructions before submitting:\\nWrite a SQL query to find the cancellation rate of requests with unbanned users (both client and driver must not be banned) each day between \"2013-10-01\" and \"2013-10-03\". Round Cancellation Rate to two decimal points."
                    },
                    {
                        "username": "salikhussaini49",
                        "content": "Great Question... "
                    }
                ]
            },
            {
                "id": 1810652,
                "content": [
                    {
                        "username": "arzoop",
                        "content": "My solution fetches the day and null for the days where there are no unbanned transactions. How can I rectify this?\\n```\\nselect \\n(request_at) as Day,\\nround(\\n  (\\n    select count(*) from Trips\\n      inner join Users u1 on trips.client_id=u1.users_id and u1.banned like \"No\" \\n    inner join Users u2 on trips.driver_id=u2.users_id and u2.banned like \"No\"\\n    where\\n    #  u1.banned like \"No\" and u2.banned like \"No\" and\\n   Trips.status like \"cancelled_by%\" and request_at=Day\\n    )\\n  /\\n  (\\n    select count(*) from Trips\\n    inner join Users u1 on trips.client_id=u1.users_id and u1.banned like \"No\"\\n    inner join Users u2 on trips.driver_id=u2.users_id and u2.banned like \"No\"\\n    where \\n    # u1.banned like \"No\" and u2.banned like \"No\" and \\n    request_at=Day\\n  )\\n,2) as `Cancellation Rate`\\nfrom Trips\\ngroup by Day \\nhaving Day between \"2013-10-01\" and \"2013-10-03\" ;\\n```"
                    },
                    {
                        "username": "shailen86",
                        "content": "Don\\'t use round function. Use NVL and to_char(\\'day\\',\\'0.99\\') to get the output"
                    },
                    {
                        "username": "ktramos",
                        "content": "I also found a test case that seems wrong: (9/12)\\nThe test case uses a scenario where an existing users_id = 1, banned value is updated to \\'Yes\\'. \\nThe test case expects the Cancellation Rate output for 10/01 to be NULL, however when I run locally, the Cancellation Rate output for 10/01 is now .50 because there is 1 cancelled row / by are 2 valid rows "
                    },
                    {
                        "username": "MaheshBabuMummalaneni",
                        "content": "with cte1 as (select *,\\n  Case when status = \\'completed\\' then null else 1 end as cancelled_flag\\nfrom trips)\\n\\nselect request_at as Day,cast((count(cancelled_flag)*1.0 /count(status)) as decimal(10,2)) as \\'Cancellation Rate\\' from cte1 c\\nleft join users u\\non c.client_id = u.users_id where banned <> \\'Yes\\' \\ngroup by request_at\\n\\n\\nThe above query is running fine and giving the required output and it is showing as accepted but throwing error while submitting. This is what\\'s happening in many queries. It should let us submit when the answer is correct. Moreover, it is showing answer which is not even related to this question. \\n\\nI never faced this kind of issues with hacker rank. May be, these people have better questions but what\\'s the point when we are not even able to submit correct answers."
                    },
                    {
                        "username": "moeheinag",
                        "content": "I'm trying it to find cancellation_rate for just one date right now. And below is my query:\n\n```\nwith unbanned_trips as\n  (select * from Trips\n  join Users on client_id = users_id\n  or client_id = driver_id\n  where request_at = '2013-10-01'\n  and banned = 'No')\n\nwith unbanned_trip_count as (\n  select count(*) from unbanned_trips\n)\nwith cancelled_trip_count as (\n  select count(*) from unbanned_trips\n  where status = 'cancelled_by_client'\n)\n\nselect unbanned_trip_count / cancelled_trip_count\n```\nHow can I do this?"
                    },
                    {
                        "username": "tooytod",
                        "content": "why I can\\'t get the right result for division?\\nThe number of cancelled and total both correct, but after devision, it shows 0, even I used cast. Anyone knows what should I do to show the correct number? thanks!\\n| request_at | cancelled | total | Cancellation Rate |\\n| ---------- | --------- | ----- | ----------------- |\\n| 2013-10-01 | 1         | 3     | 0                 |\\n| 2013-10-02 | 0         | 2     | 0                 |\\n| 2013-10-03 | 1         | 2     | 0                 |"
                    },
                    {
                        "username": "fsanchez314159",
                        "content": "`\n# Write your MySQL query statement below\n\nwith t as (\n    select *\n    from Trips\n    where\n        client_id not in (\n            select distinct\n                users_id\n            from Users\n            where\n                role = 'client' and banned = 'Yes'\n        )\n        and driver_id not in (\n            select distinct\n                users_id\n            from Users\n            where\n                role = 'driver' and banned = 'Yes'\n        )\n), agg as (\n    select\n        request_at,\n        case when status = 'completed' then status else 'canceled' end as status,\n\n        count(distinct id) as trip_count\n    from t\n    group by request_at, status\n    order by request_at, status\n)\n\n\nselect\n    request_at as Day,\n\n    round(sum(case when status = 'canceled' then trip_count else 0 end) / sum(trip_count), 2) as \"Cancellation Rate\"\nfrom agg\nwhere\n    request_at between '2013-10-01' and '2013-10-03'\ngroup by Day\norder by Day\n`\n\nThis works for me"
                    },
                    {
                        "username": "wasitshafi",
                        "content": "# getting .66 in result while its expected result show to be .67\\nmy query \\n```sql\\nwith cte1 as (\\n  select\\n    request_at,\\n    count(*) as total_requests,\\n    sum(\\n      (\\n        case\\n          when status <> \\'completed\\' then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'total_cancelled_trips\\',\\n    sum(\\n      (\\n        case\\n          when status = \\'completed\\'\\n          and (\\n            client_id in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'client\\'\\n            )\\n            or driver_id in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'driver\\'\\n            )\\n          ) then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'banned_completed_trips\\',\\n    sum(\\n      (\\n        case\\n          when status <> \\'completed\\'\\n          and (\\n            client_id not in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'client\\'\\n            )\\n            and driver_id not in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'driver\\'\\n            )\\n          ) then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'unbanned_cancelled_trips\\'\\n  from\\n    trips\\n  group by\\n    request_at\\n),\\ncte2 as (\\n  select\\n    cte1.request_at as Day,\\n    truncate(\\n      (\\n        (cte1.unbanned_cancelled_trips) /(\\n          cte1.total_requests - (\\n            cte1.total_cancelled_trips - cte1.unbanned_cancelled_trips\\n          ) - banned_completed_trips\\n        )\\n      ),\\n      2\\n    ) as \\'Cancellation Rate\\'\\n  from\\n    cte1\\n  where\\n    (\\n      cte1.request_at between \\'2013-10-01\\'\\n      and \\'2013-10-03\\'\\n    )\\n)\\nselect\\n  *\\nfrom\\n  cte2\\nwhere\\n  `Cancellation Rate` is not null\\n```\\n\\nInput:\\n```\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | completed           | 2013-10-01 |\\n| 2  | 2         | 11        | 1       | cancelled_by_driver | 2013-10-01 |\\n| 3  | 3         | 12        | 6       | completed           | 2013-10-01 |\\n| 4  | 4         | 13        | 6       | cancelled_by_client | 2013-10-01 |\\n| 5  | 1         | 10        | 1       | completed           | 2013-10-02 |\\n| 6  | 2         | 11        | 6       | completed           | 2013-10-02 |\\n| 7  | 3         | 12        | 6       | completed           | 2013-10-02 |\\n| 8  | 2         | 12        | 12      | completed           | 2013-10-03 |\\n| 9  | 3         | 10        | 12      | completed           | 2013-10-03 |\\n| 10 | 4         | 13        | 12      | cancelled_by_driver | 2013-10-03 |\\n| 11 | 3         | 10        | 6       | cancelled_by_driver | 2013-10-02 |\\n| 12 | 5         | 12        | 12      | cancelled_by_client | 2013-10-01 |\\n| 13 | 4         | 13        | 1       | cancelled_by_driver | 2013-10-03 |\\n```\\n```\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 2        | Yes    | client |\\n| 3        | No     | client |\\n| 4        | No     | client |\\n| 5        | Yes    | client |\\n| 10       | No     | driver |\\n| 11       | No     | driver |\\n| 12       | No     | driver |\\n| 13       | No     | driver |\\n```\\n\\nResult :\\n```\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-02 | 0.33              |\\n| 2013-10-03 | 0.66              |\\n```\\n\\nExpected:\\n```\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-02 | 0.33              |\\n| 2013-10-03 | 0.67              |\\n```\\n\\n# all of 11 out of 12 test cases passed, i only got wrong ans due to the last cancellation rate, any ony who sees whats wrong with my query...?\\n\\n\\n"
                    },
                    {
                        "username": "jaluthriarohit",
                        "content": "select request_at as Day,\\nround((1.0 * count(case when status in (\\'cancelled_by_driver \\' , \\'cancelled_by_client \\') then 1 else null end)/\\ncount(1)  ),2) as \"Cancellation_Rate\"\\nfrom trips t \\njoin users u on t.client_id=u.users_id\\njoin users u1 on t.client_id=u1.users_id\\nwhere u.banned=\"no\" and u1.banned=\\'No\\'  \\ngroup by request_at\\n\\ncan anybody tell why this is wrong ?\\n"
                    },
                    {
                        "username": "rishavm",
                        "content": "can someone expain why this input has \n\n| id | client_id | driver_id | city_id | status              | request_at |\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\n\n| users_id | banned | role   |\n| -------- | ------ | ------ |\n| 1        | No     | client |\n| 10       | No     | driver |\n\nhas this output\n| Day | Cancellation Rate |\n| --- | ----------------- |\n\nbecause the according to the description cancelled_request/total_request;\n\nEither the test case is wrong or some description is missing"
                    },
                    {
                        "username": "i_only_do_this_for_fun",
                        "content": "Out of range.  Always read the instructions before submitting:\\nWrite a SQL query to find the cancellation rate of requests with unbanned users (both client and driver must not be banned) each day between \"2013-10-01\" and \"2013-10-03\". Round Cancellation Rate to two decimal points."
                    },
                    {
                        "username": "salikhussaini49",
                        "content": "Great Question... "
                    }
                ]
            },
            {
                "id": 1805810,
                "content": [
                    {
                        "username": "arzoop",
                        "content": "My solution fetches the day and null for the days where there are no unbanned transactions. How can I rectify this?\\n```\\nselect \\n(request_at) as Day,\\nround(\\n  (\\n    select count(*) from Trips\\n      inner join Users u1 on trips.client_id=u1.users_id and u1.banned like \"No\" \\n    inner join Users u2 on trips.driver_id=u2.users_id and u2.banned like \"No\"\\n    where\\n    #  u1.banned like \"No\" and u2.banned like \"No\" and\\n   Trips.status like \"cancelled_by%\" and request_at=Day\\n    )\\n  /\\n  (\\n    select count(*) from Trips\\n    inner join Users u1 on trips.client_id=u1.users_id and u1.banned like \"No\"\\n    inner join Users u2 on trips.driver_id=u2.users_id and u2.banned like \"No\"\\n    where \\n    # u1.banned like \"No\" and u2.banned like \"No\" and \\n    request_at=Day\\n  )\\n,2) as `Cancellation Rate`\\nfrom Trips\\ngroup by Day \\nhaving Day between \"2013-10-01\" and \"2013-10-03\" ;\\n```"
                    },
                    {
                        "username": "shailen86",
                        "content": "Don\\'t use round function. Use NVL and to_char(\\'day\\',\\'0.99\\') to get the output"
                    },
                    {
                        "username": "ktramos",
                        "content": "I also found a test case that seems wrong: (9/12)\\nThe test case uses a scenario where an existing users_id = 1, banned value is updated to \\'Yes\\'. \\nThe test case expects the Cancellation Rate output for 10/01 to be NULL, however when I run locally, the Cancellation Rate output for 10/01 is now .50 because there is 1 cancelled row / by are 2 valid rows "
                    },
                    {
                        "username": "MaheshBabuMummalaneni",
                        "content": "with cte1 as (select *,\\n  Case when status = \\'completed\\' then null else 1 end as cancelled_flag\\nfrom trips)\\n\\nselect request_at as Day,cast((count(cancelled_flag)*1.0 /count(status)) as decimal(10,2)) as \\'Cancellation Rate\\' from cte1 c\\nleft join users u\\non c.client_id = u.users_id where banned <> \\'Yes\\' \\ngroup by request_at\\n\\n\\nThe above query is running fine and giving the required output and it is showing as accepted but throwing error while submitting. This is what\\'s happening in many queries. It should let us submit when the answer is correct. Moreover, it is showing answer which is not even related to this question. \\n\\nI never faced this kind of issues with hacker rank. May be, these people have better questions but what\\'s the point when we are not even able to submit correct answers."
                    },
                    {
                        "username": "moeheinag",
                        "content": "I'm trying it to find cancellation_rate for just one date right now. And below is my query:\n\n```\nwith unbanned_trips as\n  (select * from Trips\n  join Users on client_id = users_id\n  or client_id = driver_id\n  where request_at = '2013-10-01'\n  and banned = 'No')\n\nwith unbanned_trip_count as (\n  select count(*) from unbanned_trips\n)\nwith cancelled_trip_count as (\n  select count(*) from unbanned_trips\n  where status = 'cancelled_by_client'\n)\n\nselect unbanned_trip_count / cancelled_trip_count\n```\nHow can I do this?"
                    },
                    {
                        "username": "tooytod",
                        "content": "why I can\\'t get the right result for division?\\nThe number of cancelled and total both correct, but after devision, it shows 0, even I used cast. Anyone knows what should I do to show the correct number? thanks!\\n| request_at | cancelled | total | Cancellation Rate |\\n| ---------- | --------- | ----- | ----------------- |\\n| 2013-10-01 | 1         | 3     | 0                 |\\n| 2013-10-02 | 0         | 2     | 0                 |\\n| 2013-10-03 | 1         | 2     | 0                 |"
                    },
                    {
                        "username": "fsanchez314159",
                        "content": "`\n# Write your MySQL query statement below\n\nwith t as (\n    select *\n    from Trips\n    where\n        client_id not in (\n            select distinct\n                users_id\n            from Users\n            where\n                role = 'client' and banned = 'Yes'\n        )\n        and driver_id not in (\n            select distinct\n                users_id\n            from Users\n            where\n                role = 'driver' and banned = 'Yes'\n        )\n), agg as (\n    select\n        request_at,\n        case when status = 'completed' then status else 'canceled' end as status,\n\n        count(distinct id) as trip_count\n    from t\n    group by request_at, status\n    order by request_at, status\n)\n\n\nselect\n    request_at as Day,\n\n    round(sum(case when status = 'canceled' then trip_count else 0 end) / sum(trip_count), 2) as \"Cancellation Rate\"\nfrom agg\nwhere\n    request_at between '2013-10-01' and '2013-10-03'\ngroup by Day\norder by Day\n`\n\nThis works for me"
                    },
                    {
                        "username": "wasitshafi",
                        "content": "# getting .66 in result while its expected result show to be .67\\nmy query \\n```sql\\nwith cte1 as (\\n  select\\n    request_at,\\n    count(*) as total_requests,\\n    sum(\\n      (\\n        case\\n          when status <> \\'completed\\' then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'total_cancelled_trips\\',\\n    sum(\\n      (\\n        case\\n          when status = \\'completed\\'\\n          and (\\n            client_id in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'client\\'\\n            )\\n            or driver_id in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'driver\\'\\n            )\\n          ) then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'banned_completed_trips\\',\\n    sum(\\n      (\\n        case\\n          when status <> \\'completed\\'\\n          and (\\n            client_id not in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'client\\'\\n            )\\n            and driver_id not in(\\n              select\\n                users_id\\n              from\\n                users\\n              where\\n                banned = \\'Yes\\'\\n                and role = \\'driver\\'\\n            )\\n          ) then 1\\n          else 0\\n        end\\n      )\\n    ) as \\'unbanned_cancelled_trips\\'\\n  from\\n    trips\\n  group by\\n    request_at\\n),\\ncte2 as (\\n  select\\n    cte1.request_at as Day,\\n    truncate(\\n      (\\n        (cte1.unbanned_cancelled_trips) /(\\n          cte1.total_requests - (\\n            cte1.total_cancelled_trips - cte1.unbanned_cancelled_trips\\n          ) - banned_completed_trips\\n        )\\n      ),\\n      2\\n    ) as \\'Cancellation Rate\\'\\n  from\\n    cte1\\n  where\\n    (\\n      cte1.request_at between \\'2013-10-01\\'\\n      and \\'2013-10-03\\'\\n    )\\n)\\nselect\\n  *\\nfrom\\n  cte2\\nwhere\\n  `Cancellation Rate` is not null\\n```\\n\\nInput:\\n```\\n| id | client_id | driver_id | city_id | status              | request_at |\\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\\n| 1  | 1         | 10        | 1       | completed           | 2013-10-01 |\\n| 2  | 2         | 11        | 1       | cancelled_by_driver | 2013-10-01 |\\n| 3  | 3         | 12        | 6       | completed           | 2013-10-01 |\\n| 4  | 4         | 13        | 6       | cancelled_by_client | 2013-10-01 |\\n| 5  | 1         | 10        | 1       | completed           | 2013-10-02 |\\n| 6  | 2         | 11        | 6       | completed           | 2013-10-02 |\\n| 7  | 3         | 12        | 6       | completed           | 2013-10-02 |\\n| 8  | 2         | 12        | 12      | completed           | 2013-10-03 |\\n| 9  | 3         | 10        | 12      | completed           | 2013-10-03 |\\n| 10 | 4         | 13        | 12      | cancelled_by_driver | 2013-10-03 |\\n| 11 | 3         | 10        | 6       | cancelled_by_driver | 2013-10-02 |\\n| 12 | 5         | 12        | 12      | cancelled_by_client | 2013-10-01 |\\n| 13 | 4         | 13        | 1       | cancelled_by_driver | 2013-10-03 |\\n```\\n```\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | No     | client |\\n| 2        | Yes    | client |\\n| 3        | No     | client |\\n| 4        | No     | client |\\n| 5        | Yes    | client |\\n| 10       | No     | driver |\\n| 11       | No     | driver |\\n| 12       | No     | driver |\\n| 13       | No     | driver |\\n```\\n\\nResult :\\n```\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-02 | 0.33              |\\n| 2013-10-03 | 0.66              |\\n```\\n\\nExpected:\\n```\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-02 | 0.33              |\\n| 2013-10-03 | 0.67              |\\n```\\n\\n# all of 11 out of 12 test cases passed, i only got wrong ans due to the last cancellation rate, any ony who sees whats wrong with my query...?\\n\\n\\n"
                    },
                    {
                        "username": "jaluthriarohit",
                        "content": "select request_at as Day,\\nround((1.0 * count(case when status in (\\'cancelled_by_driver \\' , \\'cancelled_by_client \\') then 1 else null end)/\\ncount(1)  ),2) as \"Cancellation_Rate\"\\nfrom trips t \\njoin users u on t.client_id=u.users_id\\njoin users u1 on t.client_id=u1.users_id\\nwhere u.banned=\"no\" and u1.banned=\\'No\\'  \\ngroup by request_at\\n\\ncan anybody tell why this is wrong ?\\n"
                    },
                    {
                        "username": "rishavm",
                        "content": "can someone expain why this input has \n\n| id | client_id | driver_id | city_id | status              | request_at |\n| -- | --------- | --------- | ------- | ------------------- | ---------- |\n| 1  | 1         | 10        | 1       | cancelled_by_client | 2013-10-04 |\n\n| users_id | banned | role   |\n| -------- | ------ | ------ |\n| 1        | No     | client |\n| 10       | No     | driver |\n\nhas this output\n| Day | Cancellation Rate |\n| --- | ----------------- |\n\nbecause the according to the description cancelled_request/total_request;\n\nEither the test case is wrong or some description is missing"
                    },
                    {
                        "username": "i_only_do_this_for_fun",
                        "content": "Out of range.  Always read the instructions before submitting:\\nWrite a SQL query to find the cancellation rate of requests with unbanned users (both client and driver must not be banned) each day between \"2013-10-01\" and \"2013-10-03\". Round Cancellation Rate to two decimal points."
                    },
                    {
                        "username": "salikhussaini49",
                        "content": "Great Question... "
                    }
                ]
            },
            {
                "id": 1804210,
                "content": [
                    {
                        "username": "dmstj0423",
                        "content": "why do I get the difference answer?\\n\\nselect request_at Day,\\n    round(sum(case when status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\' then 1 else 0 end) / count(*),2)  as \\'Cancellation Rate\\'\\nfrom\\n(select id, request_at, status\\nfrom trips T\\nleft join users C\\non T.client_id = C.users_id and C.banned = \\'No\\' and C.role =\\'client\\'\\nleft join users D\\non T.driver_id = D.users_id and D.banned = \\'No\\' and D.role = \\'driver\\'\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\') tmp\\ngroup by 1;"
                    },
                    {
                        "username": "keyur063solanki",
                        "content": "# Write your MySQL query statement below\\nSELECT\\n    request_at as Day,\\n    ROUND(COUNT(CASE WHEN status like \\'cancelled%\\' then 1 ELSE NULL END) /\\n   COUNT(status),2) as \\'Cancellation Rate\\'\\nFROM\\n    Trips \\nINNER JOIN\\n    Users\\nON\\n    Trips.client_id = Users.users_id AND Users.banned = \\'No\\'\\n    AND (request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\nGROUP BY\\n    request_at\\n"
                    },
                    {
                        "username": "saikat_sahana",
                        "content": "### Simple Mysql Solution\n\nselect request_at as Day,\nIFNULL(ROUND(SUM(CASE\nWHEN status != \"completed\"\nTHEN 1\nEND )/\nSUM(CASE\nWHEN status is not NULL\nTHEN 1\nELSE 0 \nEND ), 2), 0) as \"Cancellation Rate\"\nfrom Trips\nwhere request_at>='2013-10-01' \nand request_at<='2013-10-03'\nand (select banned from Users where users_id=client_id) = 'No'\nand (select banned from Users where users_id=driver_id) = 'No'\ngroup by Day;"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "output\\n Day        | cancellation rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-03 | 1                 |\\n\\nWHY am I getting this error ? can\\'t understand can someone clarify ?\\n\\nSELECT request_at as Day,ROUND(SUM(case when status like \\'cancelled%%\\' then 1 else 0 end) /COUNT(id),2)\\nas \"cancellation rate\"\\nFROM trips as t\\nLEFT JOIN users as u\\nON t.id=u.users_id\\nWHERE banned = \\'No\\'\\nAND  request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nGROUP BY request_at\\n\\n\\n"
                    },
                    {
                        "username": "souravsinha",
                        "content": "```\\nwith eligibleIds as(\\n    select users_id as id from users where banned = \"NO\" \\n),\\nnewtrips as(\\n    select * from trips \\n    where trips.client_id in\\n    (select * from eligibleIds)\\n    and (request_at >= \"2013-10-01\"\\n    and request_at <= \"2013-10-03\")\\n)\\n\\n-- select * from newtrips;\\n\\nselect request_at , \\ncount(status like \"c%\") , count(status like \"cancelled%\")\\nfrom newtrips\\ngroup by request_at;\\n```\\nWhy am I getting wrong count(status like \"c%\") , count(status like \"cancelled%\")?\\nPlease help."
                    },
                    {
                        "username": "leahchen777",
                        "content": "Can anybody tell me what\\'s wrong with my T-SQL query? I cannot find any error, but it cannot pass the task:\\nSELECT Trips.request_at AS Day, \\nROUND(SUM(CASE WHEN Status=\\'completed\\' THEN 0 ELSE 1 END)/COUNT(*),2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nJOIN Users ON Users.users_id = Trips.client_id OR Users.users_id =Trips.driver_id \\nWHERE banned = \\'No\\' AND request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY Trips.request_at;\\n\\nThank you very much.\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "Hi all\\n\\nSELECT \\nrequest_at \\'Day\\',\\nround(1.0*count(case when status like \\'%cancelled%\\' then 1 else NULL end )/count(1),2) as \\'Cancellation_Rate\\'\\nFROM TRIPS T \\nINNER JOIN USERS C ON T.CLIENT_ID = C.USERS_ID and C.BANNED =\\'No\\'\\nINNER JOIN USERS D ON T.DRIVER_ID = D.USERS_ID and D.BANNED =\\'No\\'\\ngroup by request_at\\n\\nthis query giving wrong answer but the output is same as the expected"
                    },
                    {
                        "username": "data_engineer_from_mars",
                        "content": " ```;with unbanned as\n(select t.*, ran = case when status <> 'completed' then 1.0 else 0 end \nfrom Trips t\njoin Users u  on u.users_id  = t.client_id\n              and u.banned     = 'No'\njoin Users uu on uu.users_id = t.driver_id\n              and uu.banned    = 'No'\n              and request_at between '2013-10-01' and '2013-10-03')\n\nselect request_at [Day]\n      , round(sum(ran)/count(*), 2) 'Cancellation Rate'\nfrom unbanned\ngroup by request_at;"
                    },
                    {
                        "username": "DhruvitModi",
                        "content": "Is there any issue with Submit, because while Run the code it is accepted.\\nbut when I try to submit, it shows wrong answer,\\nalso I noticed that after submit, data set are different than question which leads to wrong answer.\\nIs anyone faced same problem, or any solution ?"
                    },
                    {
                        "username": "udaykirang92",
                        "content": "Once you click on the Run button only one or 2 test cases will be executed. But once you click on Submit there will be nearly 10 to 12 test cases that will be executed. You code might have worked fine for a few test cases i.e. during the time you clicked the RUN button. But when you submitted the code your query might have failed for other test cases. Hope this helps."
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "SELECT \\nrequest_at as Day,\\n  ROUND(SUM(CASE WHEN t.status in (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') THEN 1 ELSE 0 END) / COUNT(DISTINCT t.id), 2) AS  \"Cancellation Rate\"\\nFROM \\n  Trips t\\n  JOIN Users  u1 ON t.client_id = u1.users_id AND u1.banned = \\'No\\'\\n  JOIN Users  u2 ON t.driver_id = u2.users_id AND u2.banned = \\'No\\'\\n  WHERE \\n   t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n  group by t.request_at"
                    }
                ]
            },
            {
                "id": 1802326,
                "content": [
                    {
                        "username": "dmstj0423",
                        "content": "why do I get the difference answer?\\n\\nselect request_at Day,\\n    round(sum(case when status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\' then 1 else 0 end) / count(*),2)  as \\'Cancellation Rate\\'\\nfrom\\n(select id, request_at, status\\nfrom trips T\\nleft join users C\\non T.client_id = C.users_id and C.banned = \\'No\\' and C.role =\\'client\\'\\nleft join users D\\non T.driver_id = D.users_id and D.banned = \\'No\\' and D.role = \\'driver\\'\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\') tmp\\ngroup by 1;"
                    },
                    {
                        "username": "keyur063solanki",
                        "content": "# Write your MySQL query statement below\\nSELECT\\n    request_at as Day,\\n    ROUND(COUNT(CASE WHEN status like \\'cancelled%\\' then 1 ELSE NULL END) /\\n   COUNT(status),2) as \\'Cancellation Rate\\'\\nFROM\\n    Trips \\nINNER JOIN\\n    Users\\nON\\n    Trips.client_id = Users.users_id AND Users.banned = \\'No\\'\\n    AND (request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\nGROUP BY\\n    request_at\\n"
                    },
                    {
                        "username": "saikat_sahana",
                        "content": "### Simple Mysql Solution\n\nselect request_at as Day,\nIFNULL(ROUND(SUM(CASE\nWHEN status != \"completed\"\nTHEN 1\nEND )/\nSUM(CASE\nWHEN status is not NULL\nTHEN 1\nELSE 0 \nEND ), 2), 0) as \"Cancellation Rate\"\nfrom Trips\nwhere request_at>='2013-10-01' \nand request_at<='2013-10-03'\nand (select banned from Users where users_id=client_id) = 'No'\nand (select banned from Users where users_id=driver_id) = 'No'\ngroup by Day;"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "output\\n Day        | cancellation rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-03 | 1                 |\\n\\nWHY am I getting this error ? can\\'t understand can someone clarify ?\\n\\nSELECT request_at as Day,ROUND(SUM(case when status like \\'cancelled%%\\' then 1 else 0 end) /COUNT(id),2)\\nas \"cancellation rate\"\\nFROM trips as t\\nLEFT JOIN users as u\\nON t.id=u.users_id\\nWHERE banned = \\'No\\'\\nAND  request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nGROUP BY request_at\\n\\n\\n"
                    },
                    {
                        "username": "souravsinha",
                        "content": "```\\nwith eligibleIds as(\\n    select users_id as id from users where banned = \"NO\" \\n),\\nnewtrips as(\\n    select * from trips \\n    where trips.client_id in\\n    (select * from eligibleIds)\\n    and (request_at >= \"2013-10-01\"\\n    and request_at <= \"2013-10-03\")\\n)\\n\\n-- select * from newtrips;\\n\\nselect request_at , \\ncount(status like \"c%\") , count(status like \"cancelled%\")\\nfrom newtrips\\ngroup by request_at;\\n```\\nWhy am I getting wrong count(status like \"c%\") , count(status like \"cancelled%\")?\\nPlease help."
                    },
                    {
                        "username": "leahchen777",
                        "content": "Can anybody tell me what\\'s wrong with my T-SQL query? I cannot find any error, but it cannot pass the task:\\nSELECT Trips.request_at AS Day, \\nROUND(SUM(CASE WHEN Status=\\'completed\\' THEN 0 ELSE 1 END)/COUNT(*),2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nJOIN Users ON Users.users_id = Trips.client_id OR Users.users_id =Trips.driver_id \\nWHERE banned = \\'No\\' AND request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY Trips.request_at;\\n\\nThank you very much.\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "Hi all\\n\\nSELECT \\nrequest_at \\'Day\\',\\nround(1.0*count(case when status like \\'%cancelled%\\' then 1 else NULL end )/count(1),2) as \\'Cancellation_Rate\\'\\nFROM TRIPS T \\nINNER JOIN USERS C ON T.CLIENT_ID = C.USERS_ID and C.BANNED =\\'No\\'\\nINNER JOIN USERS D ON T.DRIVER_ID = D.USERS_ID and D.BANNED =\\'No\\'\\ngroup by request_at\\n\\nthis query giving wrong answer but the output is same as the expected"
                    },
                    {
                        "username": "data_engineer_from_mars",
                        "content": " ```;with unbanned as\n(select t.*, ran = case when status <> 'completed' then 1.0 else 0 end \nfrom Trips t\njoin Users u  on u.users_id  = t.client_id\n              and u.banned     = 'No'\njoin Users uu on uu.users_id = t.driver_id\n              and uu.banned    = 'No'\n              and request_at between '2013-10-01' and '2013-10-03')\n\nselect request_at [Day]\n      , round(sum(ran)/count(*), 2) 'Cancellation Rate'\nfrom unbanned\ngroup by request_at;"
                    },
                    {
                        "username": "DhruvitModi",
                        "content": "Is there any issue with Submit, because while Run the code it is accepted.\\nbut when I try to submit, it shows wrong answer,\\nalso I noticed that after submit, data set are different than question which leads to wrong answer.\\nIs anyone faced same problem, or any solution ?"
                    },
                    {
                        "username": "udaykirang92",
                        "content": "Once you click on the Run button only one or 2 test cases will be executed. But once you click on Submit there will be nearly 10 to 12 test cases that will be executed. You code might have worked fine for a few test cases i.e. during the time you clicked the RUN button. But when you submitted the code your query might have failed for other test cases. Hope this helps."
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "SELECT \\nrequest_at as Day,\\n  ROUND(SUM(CASE WHEN t.status in (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') THEN 1 ELSE 0 END) / COUNT(DISTINCT t.id), 2) AS  \"Cancellation Rate\"\\nFROM \\n  Trips t\\n  JOIN Users  u1 ON t.client_id = u1.users_id AND u1.banned = \\'No\\'\\n  JOIN Users  u2 ON t.driver_id = u2.users_id AND u2.banned = \\'No\\'\\n  WHERE \\n   t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n  group by t.request_at"
                    }
                ]
            },
            {
                "id": 1801719,
                "content": [
                    {
                        "username": "dmstj0423",
                        "content": "why do I get the difference answer?\\n\\nselect request_at Day,\\n    round(sum(case when status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\' then 1 else 0 end) / count(*),2)  as \\'Cancellation Rate\\'\\nfrom\\n(select id, request_at, status\\nfrom trips T\\nleft join users C\\non T.client_id = C.users_id and C.banned = \\'No\\' and C.role =\\'client\\'\\nleft join users D\\non T.driver_id = D.users_id and D.banned = \\'No\\' and D.role = \\'driver\\'\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\') tmp\\ngroup by 1;"
                    },
                    {
                        "username": "keyur063solanki",
                        "content": "# Write your MySQL query statement below\\nSELECT\\n    request_at as Day,\\n    ROUND(COUNT(CASE WHEN status like \\'cancelled%\\' then 1 ELSE NULL END) /\\n   COUNT(status),2) as \\'Cancellation Rate\\'\\nFROM\\n    Trips \\nINNER JOIN\\n    Users\\nON\\n    Trips.client_id = Users.users_id AND Users.banned = \\'No\\'\\n    AND (request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\nGROUP BY\\n    request_at\\n"
                    },
                    {
                        "username": "saikat_sahana",
                        "content": "### Simple Mysql Solution\n\nselect request_at as Day,\nIFNULL(ROUND(SUM(CASE\nWHEN status != \"completed\"\nTHEN 1\nEND )/\nSUM(CASE\nWHEN status is not NULL\nTHEN 1\nELSE 0 \nEND ), 2), 0) as \"Cancellation Rate\"\nfrom Trips\nwhere request_at>='2013-10-01' \nand request_at<='2013-10-03'\nand (select banned from Users where users_id=client_id) = 'No'\nand (select banned from Users where users_id=driver_id) = 'No'\ngroup by Day;"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "output\\n Day        | cancellation rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-03 | 1                 |\\n\\nWHY am I getting this error ? can\\'t understand can someone clarify ?\\n\\nSELECT request_at as Day,ROUND(SUM(case when status like \\'cancelled%%\\' then 1 else 0 end) /COUNT(id),2)\\nas \"cancellation rate\"\\nFROM trips as t\\nLEFT JOIN users as u\\nON t.id=u.users_id\\nWHERE banned = \\'No\\'\\nAND  request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nGROUP BY request_at\\n\\n\\n"
                    },
                    {
                        "username": "souravsinha",
                        "content": "```\\nwith eligibleIds as(\\n    select users_id as id from users where banned = \"NO\" \\n),\\nnewtrips as(\\n    select * from trips \\n    where trips.client_id in\\n    (select * from eligibleIds)\\n    and (request_at >= \"2013-10-01\"\\n    and request_at <= \"2013-10-03\")\\n)\\n\\n-- select * from newtrips;\\n\\nselect request_at , \\ncount(status like \"c%\") , count(status like \"cancelled%\")\\nfrom newtrips\\ngroup by request_at;\\n```\\nWhy am I getting wrong count(status like \"c%\") , count(status like \"cancelled%\")?\\nPlease help."
                    },
                    {
                        "username": "leahchen777",
                        "content": "Can anybody tell me what\\'s wrong with my T-SQL query? I cannot find any error, but it cannot pass the task:\\nSELECT Trips.request_at AS Day, \\nROUND(SUM(CASE WHEN Status=\\'completed\\' THEN 0 ELSE 1 END)/COUNT(*),2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nJOIN Users ON Users.users_id = Trips.client_id OR Users.users_id =Trips.driver_id \\nWHERE banned = \\'No\\' AND request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY Trips.request_at;\\n\\nThank you very much.\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "Hi all\\n\\nSELECT \\nrequest_at \\'Day\\',\\nround(1.0*count(case when status like \\'%cancelled%\\' then 1 else NULL end )/count(1),2) as \\'Cancellation_Rate\\'\\nFROM TRIPS T \\nINNER JOIN USERS C ON T.CLIENT_ID = C.USERS_ID and C.BANNED =\\'No\\'\\nINNER JOIN USERS D ON T.DRIVER_ID = D.USERS_ID and D.BANNED =\\'No\\'\\ngroup by request_at\\n\\nthis query giving wrong answer but the output is same as the expected"
                    },
                    {
                        "username": "data_engineer_from_mars",
                        "content": " ```;with unbanned as\n(select t.*, ran = case when status <> 'completed' then 1.0 else 0 end \nfrom Trips t\njoin Users u  on u.users_id  = t.client_id\n              and u.banned     = 'No'\njoin Users uu on uu.users_id = t.driver_id\n              and uu.banned    = 'No'\n              and request_at between '2013-10-01' and '2013-10-03')\n\nselect request_at [Day]\n      , round(sum(ran)/count(*), 2) 'Cancellation Rate'\nfrom unbanned\ngroup by request_at;"
                    },
                    {
                        "username": "DhruvitModi",
                        "content": "Is there any issue with Submit, because while Run the code it is accepted.\\nbut when I try to submit, it shows wrong answer,\\nalso I noticed that after submit, data set are different than question which leads to wrong answer.\\nIs anyone faced same problem, or any solution ?"
                    },
                    {
                        "username": "udaykirang92",
                        "content": "Once you click on the Run button only one or 2 test cases will be executed. But once you click on Submit there will be nearly 10 to 12 test cases that will be executed. You code might have worked fine for a few test cases i.e. during the time you clicked the RUN button. But when you submitted the code your query might have failed for other test cases. Hope this helps."
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "SELECT \\nrequest_at as Day,\\n  ROUND(SUM(CASE WHEN t.status in (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') THEN 1 ELSE 0 END) / COUNT(DISTINCT t.id), 2) AS  \"Cancellation Rate\"\\nFROM \\n  Trips t\\n  JOIN Users  u1 ON t.client_id = u1.users_id AND u1.banned = \\'No\\'\\n  JOIN Users  u2 ON t.driver_id = u2.users_id AND u2.banned = \\'No\\'\\n  WHERE \\n   t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n  group by t.request_at"
                    }
                ]
            },
            {
                "id": 1799895,
                "content": [
                    {
                        "username": "dmstj0423",
                        "content": "why do I get the difference answer?\\n\\nselect request_at Day,\\n    round(sum(case when status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\' then 1 else 0 end) / count(*),2)  as \\'Cancellation Rate\\'\\nfrom\\n(select id, request_at, status\\nfrom trips T\\nleft join users C\\non T.client_id = C.users_id and C.banned = \\'No\\' and C.role =\\'client\\'\\nleft join users D\\non T.driver_id = D.users_id and D.banned = \\'No\\' and D.role = \\'driver\\'\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\') tmp\\ngroup by 1;"
                    },
                    {
                        "username": "keyur063solanki",
                        "content": "# Write your MySQL query statement below\\nSELECT\\n    request_at as Day,\\n    ROUND(COUNT(CASE WHEN status like \\'cancelled%\\' then 1 ELSE NULL END) /\\n   COUNT(status),2) as \\'Cancellation Rate\\'\\nFROM\\n    Trips \\nINNER JOIN\\n    Users\\nON\\n    Trips.client_id = Users.users_id AND Users.banned = \\'No\\'\\n    AND (request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\nGROUP BY\\n    request_at\\n"
                    },
                    {
                        "username": "saikat_sahana",
                        "content": "### Simple Mysql Solution\n\nselect request_at as Day,\nIFNULL(ROUND(SUM(CASE\nWHEN status != \"completed\"\nTHEN 1\nEND )/\nSUM(CASE\nWHEN status is not NULL\nTHEN 1\nELSE 0 \nEND ), 2), 0) as \"Cancellation Rate\"\nfrom Trips\nwhere request_at>='2013-10-01' \nand request_at<='2013-10-03'\nand (select banned from Users where users_id=client_id) = 'No'\nand (select banned from Users where users_id=driver_id) = 'No'\ngroup by Day;"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "output\\n Day        | cancellation rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-03 | 1                 |\\n\\nWHY am I getting this error ? can\\'t understand can someone clarify ?\\n\\nSELECT request_at as Day,ROUND(SUM(case when status like \\'cancelled%%\\' then 1 else 0 end) /COUNT(id),2)\\nas \"cancellation rate\"\\nFROM trips as t\\nLEFT JOIN users as u\\nON t.id=u.users_id\\nWHERE banned = \\'No\\'\\nAND  request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nGROUP BY request_at\\n\\n\\n"
                    },
                    {
                        "username": "souravsinha",
                        "content": "```\\nwith eligibleIds as(\\n    select users_id as id from users where banned = \"NO\" \\n),\\nnewtrips as(\\n    select * from trips \\n    where trips.client_id in\\n    (select * from eligibleIds)\\n    and (request_at >= \"2013-10-01\"\\n    and request_at <= \"2013-10-03\")\\n)\\n\\n-- select * from newtrips;\\n\\nselect request_at , \\ncount(status like \"c%\") , count(status like \"cancelled%\")\\nfrom newtrips\\ngroup by request_at;\\n```\\nWhy am I getting wrong count(status like \"c%\") , count(status like \"cancelled%\")?\\nPlease help."
                    },
                    {
                        "username": "leahchen777",
                        "content": "Can anybody tell me what\\'s wrong with my T-SQL query? I cannot find any error, but it cannot pass the task:\\nSELECT Trips.request_at AS Day, \\nROUND(SUM(CASE WHEN Status=\\'completed\\' THEN 0 ELSE 1 END)/COUNT(*),2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nJOIN Users ON Users.users_id = Trips.client_id OR Users.users_id =Trips.driver_id \\nWHERE banned = \\'No\\' AND request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY Trips.request_at;\\n\\nThank you very much.\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "Hi all\\n\\nSELECT \\nrequest_at \\'Day\\',\\nround(1.0*count(case when status like \\'%cancelled%\\' then 1 else NULL end )/count(1),2) as \\'Cancellation_Rate\\'\\nFROM TRIPS T \\nINNER JOIN USERS C ON T.CLIENT_ID = C.USERS_ID and C.BANNED =\\'No\\'\\nINNER JOIN USERS D ON T.DRIVER_ID = D.USERS_ID and D.BANNED =\\'No\\'\\ngroup by request_at\\n\\nthis query giving wrong answer but the output is same as the expected"
                    },
                    {
                        "username": "data_engineer_from_mars",
                        "content": " ```;with unbanned as\n(select t.*, ran = case when status <> 'completed' then 1.0 else 0 end \nfrom Trips t\njoin Users u  on u.users_id  = t.client_id\n              and u.banned     = 'No'\njoin Users uu on uu.users_id = t.driver_id\n              and uu.banned    = 'No'\n              and request_at between '2013-10-01' and '2013-10-03')\n\nselect request_at [Day]\n      , round(sum(ran)/count(*), 2) 'Cancellation Rate'\nfrom unbanned\ngroup by request_at;"
                    },
                    {
                        "username": "DhruvitModi",
                        "content": "Is there any issue with Submit, because while Run the code it is accepted.\\nbut when I try to submit, it shows wrong answer,\\nalso I noticed that after submit, data set are different than question which leads to wrong answer.\\nIs anyone faced same problem, or any solution ?"
                    },
                    {
                        "username": "udaykirang92",
                        "content": "Once you click on the Run button only one or 2 test cases will be executed. But once you click on Submit there will be nearly 10 to 12 test cases that will be executed. You code might have worked fine for a few test cases i.e. during the time you clicked the RUN button. But when you submitted the code your query might have failed for other test cases. Hope this helps."
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "SELECT \\nrequest_at as Day,\\n  ROUND(SUM(CASE WHEN t.status in (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') THEN 1 ELSE 0 END) / COUNT(DISTINCT t.id), 2) AS  \"Cancellation Rate\"\\nFROM \\n  Trips t\\n  JOIN Users  u1 ON t.client_id = u1.users_id AND u1.banned = \\'No\\'\\n  JOIN Users  u2 ON t.driver_id = u2.users_id AND u2.banned = \\'No\\'\\n  WHERE \\n   t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n  group by t.request_at"
                    }
                ]
            },
            {
                "id": 1798669,
                "content": [
                    {
                        "username": "dmstj0423",
                        "content": "why do I get the difference answer?\\n\\nselect request_at Day,\\n    round(sum(case when status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\' then 1 else 0 end) / count(*),2)  as \\'Cancellation Rate\\'\\nfrom\\n(select id, request_at, status\\nfrom trips T\\nleft join users C\\non T.client_id = C.users_id and C.banned = \\'No\\' and C.role =\\'client\\'\\nleft join users D\\non T.driver_id = D.users_id and D.banned = \\'No\\' and D.role = \\'driver\\'\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\') tmp\\ngroup by 1;"
                    },
                    {
                        "username": "keyur063solanki",
                        "content": "# Write your MySQL query statement below\\nSELECT\\n    request_at as Day,\\n    ROUND(COUNT(CASE WHEN status like \\'cancelled%\\' then 1 ELSE NULL END) /\\n   COUNT(status),2) as \\'Cancellation Rate\\'\\nFROM\\n    Trips \\nINNER JOIN\\n    Users\\nON\\n    Trips.client_id = Users.users_id AND Users.banned = \\'No\\'\\n    AND (request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\nGROUP BY\\n    request_at\\n"
                    },
                    {
                        "username": "saikat_sahana",
                        "content": "### Simple Mysql Solution\n\nselect request_at as Day,\nIFNULL(ROUND(SUM(CASE\nWHEN status != \"completed\"\nTHEN 1\nEND )/\nSUM(CASE\nWHEN status is not NULL\nTHEN 1\nELSE 0 \nEND ), 2), 0) as \"Cancellation Rate\"\nfrom Trips\nwhere request_at>='2013-10-01' \nand request_at<='2013-10-03'\nand (select banned from Users where users_id=client_id) = 'No'\nand (select banned from Users where users_id=driver_id) = 'No'\ngroup by Day;"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "output\\n Day        | cancellation rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-03 | 1                 |\\n\\nWHY am I getting this error ? can\\'t understand can someone clarify ?\\n\\nSELECT request_at as Day,ROUND(SUM(case when status like \\'cancelled%%\\' then 1 else 0 end) /COUNT(id),2)\\nas \"cancellation rate\"\\nFROM trips as t\\nLEFT JOIN users as u\\nON t.id=u.users_id\\nWHERE banned = \\'No\\'\\nAND  request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nGROUP BY request_at\\n\\n\\n"
                    },
                    {
                        "username": "souravsinha",
                        "content": "```\\nwith eligibleIds as(\\n    select users_id as id from users where banned = \"NO\" \\n),\\nnewtrips as(\\n    select * from trips \\n    where trips.client_id in\\n    (select * from eligibleIds)\\n    and (request_at >= \"2013-10-01\"\\n    and request_at <= \"2013-10-03\")\\n)\\n\\n-- select * from newtrips;\\n\\nselect request_at , \\ncount(status like \"c%\") , count(status like \"cancelled%\")\\nfrom newtrips\\ngroup by request_at;\\n```\\nWhy am I getting wrong count(status like \"c%\") , count(status like \"cancelled%\")?\\nPlease help."
                    },
                    {
                        "username": "leahchen777",
                        "content": "Can anybody tell me what\\'s wrong with my T-SQL query? I cannot find any error, but it cannot pass the task:\\nSELECT Trips.request_at AS Day, \\nROUND(SUM(CASE WHEN Status=\\'completed\\' THEN 0 ELSE 1 END)/COUNT(*),2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nJOIN Users ON Users.users_id = Trips.client_id OR Users.users_id =Trips.driver_id \\nWHERE banned = \\'No\\' AND request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY Trips.request_at;\\n\\nThank you very much.\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "Hi all\\n\\nSELECT \\nrequest_at \\'Day\\',\\nround(1.0*count(case when status like \\'%cancelled%\\' then 1 else NULL end )/count(1),2) as \\'Cancellation_Rate\\'\\nFROM TRIPS T \\nINNER JOIN USERS C ON T.CLIENT_ID = C.USERS_ID and C.BANNED =\\'No\\'\\nINNER JOIN USERS D ON T.DRIVER_ID = D.USERS_ID and D.BANNED =\\'No\\'\\ngroup by request_at\\n\\nthis query giving wrong answer but the output is same as the expected"
                    },
                    {
                        "username": "data_engineer_from_mars",
                        "content": " ```;with unbanned as\n(select t.*, ran = case when status <> 'completed' then 1.0 else 0 end \nfrom Trips t\njoin Users u  on u.users_id  = t.client_id\n              and u.banned     = 'No'\njoin Users uu on uu.users_id = t.driver_id\n              and uu.banned    = 'No'\n              and request_at between '2013-10-01' and '2013-10-03')\n\nselect request_at [Day]\n      , round(sum(ran)/count(*), 2) 'Cancellation Rate'\nfrom unbanned\ngroup by request_at;"
                    },
                    {
                        "username": "DhruvitModi",
                        "content": "Is there any issue with Submit, because while Run the code it is accepted.\\nbut when I try to submit, it shows wrong answer,\\nalso I noticed that after submit, data set are different than question which leads to wrong answer.\\nIs anyone faced same problem, or any solution ?"
                    },
                    {
                        "username": "udaykirang92",
                        "content": "Once you click on the Run button only one or 2 test cases will be executed. But once you click on Submit there will be nearly 10 to 12 test cases that will be executed. You code might have worked fine for a few test cases i.e. during the time you clicked the RUN button. But when you submitted the code your query might have failed for other test cases. Hope this helps."
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "SELECT \\nrequest_at as Day,\\n  ROUND(SUM(CASE WHEN t.status in (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') THEN 1 ELSE 0 END) / COUNT(DISTINCT t.id), 2) AS  \"Cancellation Rate\"\\nFROM \\n  Trips t\\n  JOIN Users  u1 ON t.client_id = u1.users_id AND u1.banned = \\'No\\'\\n  JOIN Users  u2 ON t.driver_id = u2.users_id AND u2.banned = \\'No\\'\\n  WHERE \\n   t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n  group by t.request_at"
                    }
                ]
            },
            {
                "id": 1797574,
                "content": [
                    {
                        "username": "dmstj0423",
                        "content": "why do I get the difference answer?\\n\\nselect request_at Day,\\n    round(sum(case when status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\' then 1 else 0 end) / count(*),2)  as \\'Cancellation Rate\\'\\nfrom\\n(select id, request_at, status\\nfrom trips T\\nleft join users C\\non T.client_id = C.users_id and C.banned = \\'No\\' and C.role =\\'client\\'\\nleft join users D\\non T.driver_id = D.users_id and D.banned = \\'No\\' and D.role = \\'driver\\'\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\') tmp\\ngroup by 1;"
                    },
                    {
                        "username": "keyur063solanki",
                        "content": "# Write your MySQL query statement below\\nSELECT\\n    request_at as Day,\\n    ROUND(COUNT(CASE WHEN status like \\'cancelled%\\' then 1 ELSE NULL END) /\\n   COUNT(status),2) as \\'Cancellation Rate\\'\\nFROM\\n    Trips \\nINNER JOIN\\n    Users\\nON\\n    Trips.client_id = Users.users_id AND Users.banned = \\'No\\'\\n    AND (request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\nGROUP BY\\n    request_at\\n"
                    },
                    {
                        "username": "saikat_sahana",
                        "content": "### Simple Mysql Solution\n\nselect request_at as Day,\nIFNULL(ROUND(SUM(CASE\nWHEN status != \"completed\"\nTHEN 1\nEND )/\nSUM(CASE\nWHEN status is not NULL\nTHEN 1\nELSE 0 \nEND ), 2), 0) as \"Cancellation Rate\"\nfrom Trips\nwhere request_at>='2013-10-01' \nand request_at<='2013-10-03'\nand (select banned from Users where users_id=client_id) = 'No'\nand (select banned from Users where users_id=driver_id) = 'No'\ngroup by Day;"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "output\\n Day        | cancellation rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-03 | 1                 |\\n\\nWHY am I getting this error ? can\\'t understand can someone clarify ?\\n\\nSELECT request_at as Day,ROUND(SUM(case when status like \\'cancelled%%\\' then 1 else 0 end) /COUNT(id),2)\\nas \"cancellation rate\"\\nFROM trips as t\\nLEFT JOIN users as u\\nON t.id=u.users_id\\nWHERE banned = \\'No\\'\\nAND  request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nGROUP BY request_at\\n\\n\\n"
                    },
                    {
                        "username": "souravsinha",
                        "content": "```\\nwith eligibleIds as(\\n    select users_id as id from users where banned = \"NO\" \\n),\\nnewtrips as(\\n    select * from trips \\n    where trips.client_id in\\n    (select * from eligibleIds)\\n    and (request_at >= \"2013-10-01\"\\n    and request_at <= \"2013-10-03\")\\n)\\n\\n-- select * from newtrips;\\n\\nselect request_at , \\ncount(status like \"c%\") , count(status like \"cancelled%\")\\nfrom newtrips\\ngroup by request_at;\\n```\\nWhy am I getting wrong count(status like \"c%\") , count(status like \"cancelled%\")?\\nPlease help."
                    },
                    {
                        "username": "leahchen777",
                        "content": "Can anybody tell me what\\'s wrong with my T-SQL query? I cannot find any error, but it cannot pass the task:\\nSELECT Trips.request_at AS Day, \\nROUND(SUM(CASE WHEN Status=\\'completed\\' THEN 0 ELSE 1 END)/COUNT(*),2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nJOIN Users ON Users.users_id = Trips.client_id OR Users.users_id =Trips.driver_id \\nWHERE banned = \\'No\\' AND request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY Trips.request_at;\\n\\nThank you very much.\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "Hi all\\n\\nSELECT \\nrequest_at \\'Day\\',\\nround(1.0*count(case when status like \\'%cancelled%\\' then 1 else NULL end )/count(1),2) as \\'Cancellation_Rate\\'\\nFROM TRIPS T \\nINNER JOIN USERS C ON T.CLIENT_ID = C.USERS_ID and C.BANNED =\\'No\\'\\nINNER JOIN USERS D ON T.DRIVER_ID = D.USERS_ID and D.BANNED =\\'No\\'\\ngroup by request_at\\n\\nthis query giving wrong answer but the output is same as the expected"
                    },
                    {
                        "username": "data_engineer_from_mars",
                        "content": " ```;with unbanned as\n(select t.*, ran = case when status <> 'completed' then 1.0 else 0 end \nfrom Trips t\njoin Users u  on u.users_id  = t.client_id\n              and u.banned     = 'No'\njoin Users uu on uu.users_id = t.driver_id\n              and uu.banned    = 'No'\n              and request_at between '2013-10-01' and '2013-10-03')\n\nselect request_at [Day]\n      , round(sum(ran)/count(*), 2) 'Cancellation Rate'\nfrom unbanned\ngroup by request_at;"
                    },
                    {
                        "username": "DhruvitModi",
                        "content": "Is there any issue with Submit, because while Run the code it is accepted.\\nbut when I try to submit, it shows wrong answer,\\nalso I noticed that after submit, data set are different than question which leads to wrong answer.\\nIs anyone faced same problem, or any solution ?"
                    },
                    {
                        "username": "udaykirang92",
                        "content": "Once you click on the Run button only one or 2 test cases will be executed. But once you click on Submit there will be nearly 10 to 12 test cases that will be executed. You code might have worked fine for a few test cases i.e. during the time you clicked the RUN button. But when you submitted the code your query might have failed for other test cases. Hope this helps."
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "SELECT \\nrequest_at as Day,\\n  ROUND(SUM(CASE WHEN t.status in (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') THEN 1 ELSE 0 END) / COUNT(DISTINCT t.id), 2) AS  \"Cancellation Rate\"\\nFROM \\n  Trips t\\n  JOIN Users  u1 ON t.client_id = u1.users_id AND u1.banned = \\'No\\'\\n  JOIN Users  u2 ON t.driver_id = u2.users_id AND u2.banned = \\'No\\'\\n  WHERE \\n   t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n  group by t.request_at"
                    }
                ]
            },
            {
                "id": 1789888,
                "content": [
                    {
                        "username": "dmstj0423",
                        "content": "why do I get the difference answer?\\n\\nselect request_at Day,\\n    round(sum(case when status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\' then 1 else 0 end) / count(*),2)  as \\'Cancellation Rate\\'\\nfrom\\n(select id, request_at, status\\nfrom trips T\\nleft join users C\\non T.client_id = C.users_id and C.banned = \\'No\\' and C.role =\\'client\\'\\nleft join users D\\non T.driver_id = D.users_id and D.banned = \\'No\\' and D.role = \\'driver\\'\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\') tmp\\ngroup by 1;"
                    },
                    {
                        "username": "keyur063solanki",
                        "content": "# Write your MySQL query statement below\\nSELECT\\n    request_at as Day,\\n    ROUND(COUNT(CASE WHEN status like \\'cancelled%\\' then 1 ELSE NULL END) /\\n   COUNT(status),2) as \\'Cancellation Rate\\'\\nFROM\\n    Trips \\nINNER JOIN\\n    Users\\nON\\n    Trips.client_id = Users.users_id AND Users.banned = \\'No\\'\\n    AND (request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\nGROUP BY\\n    request_at\\n"
                    },
                    {
                        "username": "saikat_sahana",
                        "content": "### Simple Mysql Solution\n\nselect request_at as Day,\nIFNULL(ROUND(SUM(CASE\nWHEN status != \"completed\"\nTHEN 1\nEND )/\nSUM(CASE\nWHEN status is not NULL\nTHEN 1\nELSE 0 \nEND ), 2), 0) as \"Cancellation Rate\"\nfrom Trips\nwhere request_at>='2013-10-01' \nand request_at<='2013-10-03'\nand (select banned from Users where users_id=client_id) = 'No'\nand (select banned from Users where users_id=driver_id) = 'No'\ngroup by Day;"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "output\\n Day        | cancellation rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-03 | 1                 |\\n\\nWHY am I getting this error ? can\\'t understand can someone clarify ?\\n\\nSELECT request_at as Day,ROUND(SUM(case when status like \\'cancelled%%\\' then 1 else 0 end) /COUNT(id),2)\\nas \"cancellation rate\"\\nFROM trips as t\\nLEFT JOIN users as u\\nON t.id=u.users_id\\nWHERE banned = \\'No\\'\\nAND  request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nGROUP BY request_at\\n\\n\\n"
                    },
                    {
                        "username": "souravsinha",
                        "content": "```\\nwith eligibleIds as(\\n    select users_id as id from users where banned = \"NO\" \\n),\\nnewtrips as(\\n    select * from trips \\n    where trips.client_id in\\n    (select * from eligibleIds)\\n    and (request_at >= \"2013-10-01\"\\n    and request_at <= \"2013-10-03\")\\n)\\n\\n-- select * from newtrips;\\n\\nselect request_at , \\ncount(status like \"c%\") , count(status like \"cancelled%\")\\nfrom newtrips\\ngroup by request_at;\\n```\\nWhy am I getting wrong count(status like \"c%\") , count(status like \"cancelled%\")?\\nPlease help."
                    },
                    {
                        "username": "leahchen777",
                        "content": "Can anybody tell me what\\'s wrong with my T-SQL query? I cannot find any error, but it cannot pass the task:\\nSELECT Trips.request_at AS Day, \\nROUND(SUM(CASE WHEN Status=\\'completed\\' THEN 0 ELSE 1 END)/COUNT(*),2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nJOIN Users ON Users.users_id = Trips.client_id OR Users.users_id =Trips.driver_id \\nWHERE banned = \\'No\\' AND request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY Trips.request_at;\\n\\nThank you very much.\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "Hi all\\n\\nSELECT \\nrequest_at \\'Day\\',\\nround(1.0*count(case when status like \\'%cancelled%\\' then 1 else NULL end )/count(1),2) as \\'Cancellation_Rate\\'\\nFROM TRIPS T \\nINNER JOIN USERS C ON T.CLIENT_ID = C.USERS_ID and C.BANNED =\\'No\\'\\nINNER JOIN USERS D ON T.DRIVER_ID = D.USERS_ID and D.BANNED =\\'No\\'\\ngroup by request_at\\n\\nthis query giving wrong answer but the output is same as the expected"
                    },
                    {
                        "username": "data_engineer_from_mars",
                        "content": " ```;with unbanned as\n(select t.*, ran = case when status <> 'completed' then 1.0 else 0 end \nfrom Trips t\njoin Users u  on u.users_id  = t.client_id\n              and u.banned     = 'No'\njoin Users uu on uu.users_id = t.driver_id\n              and uu.banned    = 'No'\n              and request_at between '2013-10-01' and '2013-10-03')\n\nselect request_at [Day]\n      , round(sum(ran)/count(*), 2) 'Cancellation Rate'\nfrom unbanned\ngroup by request_at;"
                    },
                    {
                        "username": "DhruvitModi",
                        "content": "Is there any issue with Submit, because while Run the code it is accepted.\\nbut when I try to submit, it shows wrong answer,\\nalso I noticed that after submit, data set are different than question which leads to wrong answer.\\nIs anyone faced same problem, or any solution ?"
                    },
                    {
                        "username": "udaykirang92",
                        "content": "Once you click on the Run button only one or 2 test cases will be executed. But once you click on Submit there will be nearly 10 to 12 test cases that will be executed. You code might have worked fine for a few test cases i.e. during the time you clicked the RUN button. But when you submitted the code your query might have failed for other test cases. Hope this helps."
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "SELECT \\nrequest_at as Day,\\n  ROUND(SUM(CASE WHEN t.status in (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') THEN 1 ELSE 0 END) / COUNT(DISTINCT t.id), 2) AS  \"Cancellation Rate\"\\nFROM \\n  Trips t\\n  JOIN Users  u1 ON t.client_id = u1.users_id AND u1.banned = \\'No\\'\\n  JOIN Users  u2 ON t.driver_id = u2.users_id AND u2.banned = \\'No\\'\\n  WHERE \\n   t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n  group by t.request_at"
                    }
                ]
            },
            {
                "id": 1787029,
                "content": [
                    {
                        "username": "dmstj0423",
                        "content": "why do I get the difference answer?\\n\\nselect request_at Day,\\n    round(sum(case when status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\' then 1 else 0 end) / count(*),2)  as \\'Cancellation Rate\\'\\nfrom\\n(select id, request_at, status\\nfrom trips T\\nleft join users C\\non T.client_id = C.users_id and C.banned = \\'No\\' and C.role =\\'client\\'\\nleft join users D\\non T.driver_id = D.users_id and D.banned = \\'No\\' and D.role = \\'driver\\'\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\') tmp\\ngroup by 1;"
                    },
                    {
                        "username": "keyur063solanki",
                        "content": "# Write your MySQL query statement below\\nSELECT\\n    request_at as Day,\\n    ROUND(COUNT(CASE WHEN status like \\'cancelled%\\' then 1 ELSE NULL END) /\\n   COUNT(status),2) as \\'Cancellation Rate\\'\\nFROM\\n    Trips \\nINNER JOIN\\n    Users\\nON\\n    Trips.client_id = Users.users_id AND Users.banned = \\'No\\'\\n    AND (request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\nGROUP BY\\n    request_at\\n"
                    },
                    {
                        "username": "saikat_sahana",
                        "content": "### Simple Mysql Solution\n\nselect request_at as Day,\nIFNULL(ROUND(SUM(CASE\nWHEN status != \"completed\"\nTHEN 1\nEND )/\nSUM(CASE\nWHEN status is not NULL\nTHEN 1\nELSE 0 \nEND ), 2), 0) as \"Cancellation Rate\"\nfrom Trips\nwhere request_at>='2013-10-01' \nand request_at<='2013-10-03'\nand (select banned from Users where users_id=client_id) = 'No'\nand (select banned from Users where users_id=driver_id) = 'No'\ngroup by Day;"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "output\\n Day        | cancellation rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-03 | 1                 |\\n\\nWHY am I getting this error ? can\\'t understand can someone clarify ?\\n\\nSELECT request_at as Day,ROUND(SUM(case when status like \\'cancelled%%\\' then 1 else 0 end) /COUNT(id),2)\\nas \"cancellation rate\"\\nFROM trips as t\\nLEFT JOIN users as u\\nON t.id=u.users_id\\nWHERE banned = \\'No\\'\\nAND  request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nGROUP BY request_at\\n\\n\\n"
                    },
                    {
                        "username": "souravsinha",
                        "content": "```\\nwith eligibleIds as(\\n    select users_id as id from users where banned = \"NO\" \\n),\\nnewtrips as(\\n    select * from trips \\n    where trips.client_id in\\n    (select * from eligibleIds)\\n    and (request_at >= \"2013-10-01\"\\n    and request_at <= \"2013-10-03\")\\n)\\n\\n-- select * from newtrips;\\n\\nselect request_at , \\ncount(status like \"c%\") , count(status like \"cancelled%\")\\nfrom newtrips\\ngroup by request_at;\\n```\\nWhy am I getting wrong count(status like \"c%\") , count(status like \"cancelled%\")?\\nPlease help."
                    },
                    {
                        "username": "leahchen777",
                        "content": "Can anybody tell me what\\'s wrong with my T-SQL query? I cannot find any error, but it cannot pass the task:\\nSELECT Trips.request_at AS Day, \\nROUND(SUM(CASE WHEN Status=\\'completed\\' THEN 0 ELSE 1 END)/COUNT(*),2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nJOIN Users ON Users.users_id = Trips.client_id OR Users.users_id =Trips.driver_id \\nWHERE banned = \\'No\\' AND request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY Trips.request_at;\\n\\nThank you very much.\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "Hi all\\n\\nSELECT \\nrequest_at \\'Day\\',\\nround(1.0*count(case when status like \\'%cancelled%\\' then 1 else NULL end )/count(1),2) as \\'Cancellation_Rate\\'\\nFROM TRIPS T \\nINNER JOIN USERS C ON T.CLIENT_ID = C.USERS_ID and C.BANNED =\\'No\\'\\nINNER JOIN USERS D ON T.DRIVER_ID = D.USERS_ID and D.BANNED =\\'No\\'\\ngroup by request_at\\n\\nthis query giving wrong answer but the output is same as the expected"
                    },
                    {
                        "username": "data_engineer_from_mars",
                        "content": " ```;with unbanned as\n(select t.*, ran = case when status <> 'completed' then 1.0 else 0 end \nfrom Trips t\njoin Users u  on u.users_id  = t.client_id\n              and u.banned     = 'No'\njoin Users uu on uu.users_id = t.driver_id\n              and uu.banned    = 'No'\n              and request_at between '2013-10-01' and '2013-10-03')\n\nselect request_at [Day]\n      , round(sum(ran)/count(*), 2) 'Cancellation Rate'\nfrom unbanned\ngroup by request_at;"
                    },
                    {
                        "username": "DhruvitModi",
                        "content": "Is there any issue with Submit, because while Run the code it is accepted.\\nbut when I try to submit, it shows wrong answer,\\nalso I noticed that after submit, data set are different than question which leads to wrong answer.\\nIs anyone faced same problem, or any solution ?"
                    },
                    {
                        "username": "udaykirang92",
                        "content": "Once you click on the Run button only one or 2 test cases will be executed. But once you click on Submit there will be nearly 10 to 12 test cases that will be executed. You code might have worked fine for a few test cases i.e. during the time you clicked the RUN button. But when you submitted the code your query might have failed for other test cases. Hope this helps."
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "SELECT \\nrequest_at as Day,\\n  ROUND(SUM(CASE WHEN t.status in (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') THEN 1 ELSE 0 END) / COUNT(DISTINCT t.id), 2) AS  \"Cancellation Rate\"\\nFROM \\n  Trips t\\n  JOIN Users  u1 ON t.client_id = u1.users_id AND u1.banned = \\'No\\'\\n  JOIN Users  u2 ON t.driver_id = u2.users_id AND u2.banned = \\'No\\'\\n  WHERE \\n   t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n  group by t.request_at"
                    }
                ]
            },
            {
                "id": 1785809,
                "content": [
                    {
                        "username": "dmstj0423",
                        "content": "why do I get the difference answer?\\n\\nselect request_at Day,\\n    round(sum(case when status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\' then 1 else 0 end) / count(*),2)  as \\'Cancellation Rate\\'\\nfrom\\n(select id, request_at, status\\nfrom trips T\\nleft join users C\\non T.client_id = C.users_id and C.banned = \\'No\\' and C.role =\\'client\\'\\nleft join users D\\non T.driver_id = D.users_id and D.banned = \\'No\\' and D.role = \\'driver\\'\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\') tmp\\ngroup by 1;"
                    },
                    {
                        "username": "keyur063solanki",
                        "content": "# Write your MySQL query statement below\\nSELECT\\n    request_at as Day,\\n    ROUND(COUNT(CASE WHEN status like \\'cancelled%\\' then 1 ELSE NULL END) /\\n   COUNT(status),2) as \\'Cancellation Rate\\'\\nFROM\\n    Trips \\nINNER JOIN\\n    Users\\nON\\n    Trips.client_id = Users.users_id AND Users.banned = \\'No\\'\\n    AND (request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\nGROUP BY\\n    request_at\\n"
                    },
                    {
                        "username": "saikat_sahana",
                        "content": "### Simple Mysql Solution\n\nselect request_at as Day,\nIFNULL(ROUND(SUM(CASE\nWHEN status != \"completed\"\nTHEN 1\nEND )/\nSUM(CASE\nWHEN status is not NULL\nTHEN 1\nELSE 0 \nEND ), 2), 0) as \"Cancellation Rate\"\nfrom Trips\nwhere request_at>='2013-10-01' \nand request_at<='2013-10-03'\nand (select banned from Users where users_id=client_id) = 'No'\nand (select banned from Users where users_id=driver_id) = 'No'\ngroup by Day;"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "output\\n Day        | cancellation rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-03 | 1                 |\\n\\nWHY am I getting this error ? can\\'t understand can someone clarify ?\\n\\nSELECT request_at as Day,ROUND(SUM(case when status like \\'cancelled%%\\' then 1 else 0 end) /COUNT(id),2)\\nas \"cancellation rate\"\\nFROM trips as t\\nLEFT JOIN users as u\\nON t.id=u.users_id\\nWHERE banned = \\'No\\'\\nAND  request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nGROUP BY request_at\\n\\n\\n"
                    },
                    {
                        "username": "souravsinha",
                        "content": "```\\nwith eligibleIds as(\\n    select users_id as id from users where banned = \"NO\" \\n),\\nnewtrips as(\\n    select * from trips \\n    where trips.client_id in\\n    (select * from eligibleIds)\\n    and (request_at >= \"2013-10-01\"\\n    and request_at <= \"2013-10-03\")\\n)\\n\\n-- select * from newtrips;\\n\\nselect request_at , \\ncount(status like \"c%\") , count(status like \"cancelled%\")\\nfrom newtrips\\ngroup by request_at;\\n```\\nWhy am I getting wrong count(status like \"c%\") , count(status like \"cancelled%\")?\\nPlease help."
                    },
                    {
                        "username": "leahchen777",
                        "content": "Can anybody tell me what\\'s wrong with my T-SQL query? I cannot find any error, but it cannot pass the task:\\nSELECT Trips.request_at AS Day, \\nROUND(SUM(CASE WHEN Status=\\'completed\\' THEN 0 ELSE 1 END)/COUNT(*),2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nJOIN Users ON Users.users_id = Trips.client_id OR Users.users_id =Trips.driver_id \\nWHERE banned = \\'No\\' AND request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY Trips.request_at;\\n\\nThank you very much.\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "Hi all\\n\\nSELECT \\nrequest_at \\'Day\\',\\nround(1.0*count(case when status like \\'%cancelled%\\' then 1 else NULL end )/count(1),2) as \\'Cancellation_Rate\\'\\nFROM TRIPS T \\nINNER JOIN USERS C ON T.CLIENT_ID = C.USERS_ID and C.BANNED =\\'No\\'\\nINNER JOIN USERS D ON T.DRIVER_ID = D.USERS_ID and D.BANNED =\\'No\\'\\ngroup by request_at\\n\\nthis query giving wrong answer but the output is same as the expected"
                    },
                    {
                        "username": "data_engineer_from_mars",
                        "content": " ```;with unbanned as\n(select t.*, ran = case when status <> 'completed' then 1.0 else 0 end \nfrom Trips t\njoin Users u  on u.users_id  = t.client_id\n              and u.banned     = 'No'\njoin Users uu on uu.users_id = t.driver_id\n              and uu.banned    = 'No'\n              and request_at between '2013-10-01' and '2013-10-03')\n\nselect request_at [Day]\n      , round(sum(ran)/count(*), 2) 'Cancellation Rate'\nfrom unbanned\ngroup by request_at;"
                    },
                    {
                        "username": "DhruvitModi",
                        "content": "Is there any issue with Submit, because while Run the code it is accepted.\\nbut when I try to submit, it shows wrong answer,\\nalso I noticed that after submit, data set are different than question which leads to wrong answer.\\nIs anyone faced same problem, or any solution ?"
                    },
                    {
                        "username": "udaykirang92",
                        "content": "Once you click on the Run button only one or 2 test cases will be executed. But once you click on Submit there will be nearly 10 to 12 test cases that will be executed. You code might have worked fine for a few test cases i.e. during the time you clicked the RUN button. But when you submitted the code your query might have failed for other test cases. Hope this helps."
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "SELECT \\nrequest_at as Day,\\n  ROUND(SUM(CASE WHEN t.status in (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') THEN 1 ELSE 0 END) / COUNT(DISTINCT t.id), 2) AS  \"Cancellation Rate\"\\nFROM \\n  Trips t\\n  JOIN Users  u1 ON t.client_id = u1.users_id AND u1.banned = \\'No\\'\\n  JOIN Users  u2 ON t.driver_id = u2.users_id AND u2.banned = \\'No\\'\\n  WHERE \\n   t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n  group by t.request_at"
                    }
                ]
            },
            {
                "id": 1779326,
                "content": [
                    {
                        "username": "dmstj0423",
                        "content": "why do I get the difference answer?\\n\\nselect request_at Day,\\n    round(sum(case when status = \\'cancelled_by_driver\\' or status = \\'cancelled_by_client\\' then 1 else 0 end) / count(*),2)  as \\'Cancellation Rate\\'\\nfrom\\n(select id, request_at, status\\nfrom trips T\\nleft join users C\\non T.client_id = C.users_id and C.banned = \\'No\\' and C.role =\\'client\\'\\nleft join users D\\non T.driver_id = D.users_id and D.banned = \\'No\\' and D.role = \\'driver\\'\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\') tmp\\ngroup by 1;"
                    },
                    {
                        "username": "keyur063solanki",
                        "content": "# Write your MySQL query statement below\\nSELECT\\n    request_at as Day,\\n    ROUND(COUNT(CASE WHEN status like \\'cancelled%\\' then 1 ELSE NULL END) /\\n   COUNT(status),2) as \\'Cancellation Rate\\'\\nFROM\\n    Trips \\nINNER JOIN\\n    Users\\nON\\n    Trips.client_id = Users.users_id AND Users.banned = \\'No\\'\\n    AND (request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\')\\nGROUP BY\\n    request_at\\n"
                    },
                    {
                        "username": "saikat_sahana",
                        "content": "### Simple Mysql Solution\n\nselect request_at as Day,\nIFNULL(ROUND(SUM(CASE\nWHEN status != \"completed\"\nTHEN 1\nEND )/\nSUM(CASE\nWHEN status is not NULL\nTHEN 1\nELSE 0 \nEND ), 2), 0) as \"Cancellation Rate\"\nfrom Trips\nwhere request_at>='2013-10-01' \nand request_at<='2013-10-03'\nand (select banned from Users where users_id=client_id) = 'No'\nand (select banned from Users where users_id=driver_id) = 'No'\ngroup by Day;"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "output\\n Day        | cancellation rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 | 0.33              |\\n| 2013-10-03 | 1                 |\\n\\nWHY am I getting this error ? can\\'t understand can someone clarify ?\\n\\nSELECT request_at as Day,ROUND(SUM(case when status like \\'cancelled%%\\' then 1 else 0 end) /COUNT(id),2)\\nas \"cancellation rate\"\\nFROM trips as t\\nLEFT JOIN users as u\\nON t.id=u.users_id\\nWHERE banned = \\'No\\'\\nAND  request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nGROUP BY request_at\\n\\n\\n"
                    },
                    {
                        "username": "souravsinha",
                        "content": "```\\nwith eligibleIds as(\\n    select users_id as id from users where banned = \"NO\" \\n),\\nnewtrips as(\\n    select * from trips \\n    where trips.client_id in\\n    (select * from eligibleIds)\\n    and (request_at >= \"2013-10-01\"\\n    and request_at <= \"2013-10-03\")\\n)\\n\\n-- select * from newtrips;\\n\\nselect request_at , \\ncount(status like \"c%\") , count(status like \"cancelled%\")\\nfrom newtrips\\ngroup by request_at;\\n```\\nWhy am I getting wrong count(status like \"c%\") , count(status like \"cancelled%\")?\\nPlease help."
                    },
                    {
                        "username": "leahchen777",
                        "content": "Can anybody tell me what\\'s wrong with my T-SQL query? I cannot find any error, but it cannot pass the task:\\nSELECT Trips.request_at AS Day, \\nROUND(SUM(CASE WHEN Status=\\'completed\\' THEN 0 ELSE 1 END)/COUNT(*),2) AS \\'Cancellation Rate\\'\\nFROM Trips\\nJOIN Users ON Users.users_id = Trips.client_id OR Users.users_id =Trips.driver_id \\nWHERE banned = \\'No\\' AND request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\nGROUP BY Trips.request_at;\\n\\nThank you very much.\\n"
                    },
                    {
                        "username": "rahuldave99",
                        "content": "Hi all\\n\\nSELECT \\nrequest_at \\'Day\\',\\nround(1.0*count(case when status like \\'%cancelled%\\' then 1 else NULL end )/count(1),2) as \\'Cancellation_Rate\\'\\nFROM TRIPS T \\nINNER JOIN USERS C ON T.CLIENT_ID = C.USERS_ID and C.BANNED =\\'No\\'\\nINNER JOIN USERS D ON T.DRIVER_ID = D.USERS_ID and D.BANNED =\\'No\\'\\ngroup by request_at\\n\\nthis query giving wrong answer but the output is same as the expected"
                    },
                    {
                        "username": "data_engineer_from_mars",
                        "content": " ```;with unbanned as\n(select t.*, ran = case when status <> 'completed' then 1.0 else 0 end \nfrom Trips t\njoin Users u  on u.users_id  = t.client_id\n              and u.banned     = 'No'\njoin Users uu on uu.users_id = t.driver_id\n              and uu.banned    = 'No'\n              and request_at between '2013-10-01' and '2013-10-03')\n\nselect request_at [Day]\n      , round(sum(ran)/count(*), 2) 'Cancellation Rate'\nfrom unbanned\ngroup by request_at;"
                    },
                    {
                        "username": "DhruvitModi",
                        "content": "Is there any issue with Submit, because while Run the code it is accepted.\\nbut when I try to submit, it shows wrong answer,\\nalso I noticed that after submit, data set are different than question which leads to wrong answer.\\nIs anyone faced same problem, or any solution ?"
                    },
                    {
                        "username": "udaykirang92",
                        "content": "Once you click on the Run button only one or 2 test cases will be executed. But once you click on Submit there will be nearly 10 to 12 test cases that will be executed. You code might have worked fine for a few test cases i.e. during the time you clicked the RUN button. But when you submitted the code your query might have failed for other test cases. Hope this helps."
                    },
                    {
                        "username": "rabikunwar177",
                        "content": "SELECT \\nrequest_at as Day,\\n  ROUND(SUM(CASE WHEN t.status in (\\'cancelled_by_driver\\',\\'cancelled_by_client\\') THEN 1 ELSE 0 END) / COUNT(DISTINCT t.id), 2) AS  \"Cancellation Rate\"\\nFROM \\n  Trips t\\n  JOIN Users  u1 ON t.client_id = u1.users_id AND u1.banned = \\'No\\'\\n  JOIN Users  u2 ON t.driver_id = u2.users_id AND u2.banned = \\'No\\'\\n  WHERE \\n   t.request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\'\\n  group by t.request_at"
                    }
                ]
            },
            {
                "id": 1778890,
                "content": [
                    {
                        "username": "LAOMAITOU",
                        "content": "with ligit as (\\n    select users_id,role from Users\\n    where banned=\\'No\\' and (role=\\'driver\\' or role=\\'client\\')\\n)\\n\\nselect request_at as \"Day\", round(sum(case when status=\\'cancelled_by_driver\\' or status=\\'cancelled_by_client\\' then 1 else 0 end)/count(*),2) as \"Cancellation Rate\"\\nfrom\\n(\\n    select status,request_at from Trips\\n    where client_id in (select users_id from ligit where role=\\'client\\')\\n      and driver_id in (select users_id from ligit where role=\\'driver\\')\\n) stats\\ngroup by request_at"
                    },
                    {
                        "username": "gaurangdamley",
                        "content": "Not sure what it is not accepting my solution. only difference I see is with the header.\\n\\nwith tot as (select count(*) as total,T.request_at as Day from Trips T, Users U\\nwhere T.client_id = U.users_id\\nAND U.banned = \\'No\\'\\ngroup by T.request_at),\\ncan as (select count(*) as total,T.request_at as Day from Trips T, users U\\nwhere t.client_id = u.users_id AND U.banned = \\'No\\'\\nAND T.status <>\\'completed\\'\\ngroup by T.request_at);\\n\\nselect t.Day as day, nvl(Trunc((c.total/t.total),2),0.00) cancellation_rate from tot t, can c\\nwhere t.Day = c.Day (+)\\norder by Day;"
                    },
                    {
                        "username": "jobless_lady",
                        "content": "9/11 test cases passed\\n\\nSELECT t.request_at as Day, \\nROUND((SUM(IF(t.status like \\'cancelled%\\' and u1.banned=\\'No\\',1,0)))/(SUM(IF(u1.banned=\\'No\\',1,0))),2) as \\'Cancellation Rate\\'\\n    FROM (SELECT * from Trips \\n    WHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\') t\\n    LEFT JOIN Users u1 ON t.client_id=u1.users_id\\n    LEFT JOIN Users u2 ON t.driver_id=u2.users_id\\nGROUP BY t.request_at\\n\\n\\nTrips =\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | Yes    | client |\\n| 10       | No     | driver |\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 |                   |\\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nKindly help in rectification of query"
                    },
                    {
                        "username": "athlchian",
                        "content": "`\nwith cancelCount as (\n    select count(id) as n1, request_at\n    from Trips\n    where status <> \"completed\"\n    and client_id in (select users_id from Users where banned = \"No\" and role = \"client\")\n    and driver_id in (select users_id from Users where banned = \"No\" and role = \"driver\")\n    group by request_at\n),\ntotalCount as (\n    select count(id) as n2, request_at\n    from Trips\n    group by request_at\n)\n\nselect totalCount.request_at as Day,\nIFNULL((cancelCount.n1 / totalCount.n2),0) as \"Cancellation Rate\"\nfrom totalCount\nleft join cancelCount\non totalCount.request_at = cancelCount.request_at\n`\n\nTest case is wrong"
                    },
                    {
                        "username": "joeybosa",
                        "content": "used CTEs to store banned users\\n\\n# banned drivers\\nwith banned_drivers as \\n(\\nselect distinct users_id\\nfrom Users\\nwhere role = \\'driver\\'\\nand banned = \\'Yes\\'\\n),\\n# banned clients\\nbanned_clients as \\n(\\nselect distinct users_id\\nfrom Users\\nwhere role = \\'client\\'\\nand banned = \\'Yes\\'\\n)\\n\\nselect request_at as Day, \\nround((sum(case status when \\'cancelled_by_driver\\' then 1 when \\'cancelled_by_client\\' then 1 else 0 end) \\n/\\ncount(*)),2) as \"Cancellation Rate\"\\nfrom Trips\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nand client_id not in (\\n    select users_id from banned_clients\\n)\\nand driver_id not in (\\n    select users_id from banned_drivers\\n)\\ngroup by 1\\n\\n"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "The leetcode answer has a bug, that it must requires the column to be called \"cancellation rate\" to pass, but when I put my couln as \"cancellation rate\", it put the rest of the code as string"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "WITH CTE AS (\\nSELECT client_id, driver_id, request_at, users_id, banned,\\nCASE WHEN status LIKE \\'cancelled%\\' THEN \\'cancelled\\' ELSE status END AS cancel_status\\nFROM Trips t LEFT JOIN Users u ON t.client_id = u.users_id OR t.driver_id = u.users_id\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\' AND driver_id != users_id AND banned != \\'Yes\\'\\nORDER BY request_at ASC\\n)\\n\\nSELECT request_at AS Day, ROUND(COUNT(CASE WHEN cancel_status = \\'cancelled\\' THEN 1 ELSE null END) / COUNT(*), 2) as Cancellation_Rate\\nFROM CTE\\nGROUP BY 1\\nORDER BY 1 ASC\\n"
                    },
                    {
                        "username": "musemen",
                        "content": "```\\n# total rides by unbanned users by day\\nwith total_rides as (SELECT t.request_at as day,\\ncount(1) as total_rides\\nfrom trips t  join \\nusers u on t.client_id = u.users_id and u.banned = \\'No\\' and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by 1),\\n\\n# cancelled rides by unbanned users by day\\ncancelled_rides as (\\nSELECT t.request_at as day,\\ncount(1) as cancelled_rides\\nfrom trips t join \\nusers u on t.client_id = u.users_id  \\nwhere t.status like \\'cancelled%\\'and u.banned = \\'No\\' and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by 1\\n),\\n\\ncombined as(select tr.day, tr.total_rides as total_rides, cr.cancelled_rides as cancelled_rides  from cancelled_rides cr\\nright join total_rides tr on cr.day = tr.day)\\n\\nselect day, case when cancelled_rides is NULL then 0\\nelse round(cancelled_rides/total_rides,2) end as \"cancellation rate\"\\nfrom combined\\n\\n```\\n\\nCan Someone help me with this, its failing 1 test case"
                    },
                    {
                        "username": "mailtopusapallip",
                        "content": "select t1.requested_at as Day ,\n        round()t2.cancel_trp_cnt/t1.cmplt_trp_cnt,2) as \"Cancellation Rate\" \n (select t.requested_at,count(1) as cmplt_trp_cnt from Trips t ,users c,users d\nwhere t.client_id =c.users_id \nand t.driver_id =d.users_id \nand t.requested_at between to_date ('2013-10-01','YYYY-MM-DD') and  to_date ('2013-10-03','YYYY-MM-DD')\nand c.banned='Yes'\nand d.banned='Yes'\nand t.status='Completed'\ngroup by t.requested_at\n)t1,\n(select t.requested_at,count(1) as cancel_trp_cnt from Trips t ,users c,users d\nwhere t.client_id =c.users_id \nand t.driver_id =d.users_id \nand t.requested_at between to_date ('2013-10-01','YYYY-MM-DD') and  to_date ('2013-10-03','YYYY-MM-DD')\nand c.banned='Yes'\nand d.banned='Yes'\nand t.status in ('cancelled_by_driver','cancelled_by_client')\ngroup by t.requested_at\n)t2\nwhere t1.requested_at=t2.requested_at\n\ncan somone check and let me know why this is not accepted .\nThis seems to be correct for me ,but not sure why run time error is coming .\nalso can someone from leetcode check and let me know ,how to check run time error .\nWhen I see error ,I will come to know what is the error and how to fix . Unfortunately leetcode is just saying run time error . which is not clear to me at all ,I am new to leetcode . Any help in this regard is highly appreciated .thank you ."
                    },
                    {
                        "username": "shellweCode",
                        "content": "Why there is a runtime error of \"Unknown column \\'t2.client_id\\' in \\'on clause\\' \" after running this line? It seems that i do not have any syntax error.\\nWith abc as (SELECT t1.request_at, COUNT(t1.id) AS \\'count\\' FROM Trips t1\\nLEFT JOIN Users ON Users.users_id = t1.client_id\\nWHERE t1.status IN (\\'cancelled_by_client\\',\\'cancelled_by_driver\\') AND Users.banned = \\'NO\\'\\nGROUP BY t1.request_at)\\nSELECT t2.request_at AS \\'Day\\', ROUND((abc.count/COUNT(t2.id)),2 )AS \\'Cancellation Rate\\' FROM Trips t2, abc\\nINNER JOIN Users u ON u.users_id = t2.client_id\\nWHERE u.banned = \\'NO\\' AND abc.request_at = t2.request_at\\nGROUP BY t2.request_at\\nORDER BY t2.request_at\\n\\nThank you for your help ><"
                    }
                ]
            },
            {
                "id": 1770140,
                "content": [
                    {
                        "username": "LAOMAITOU",
                        "content": "with ligit as (\\n    select users_id,role from Users\\n    where banned=\\'No\\' and (role=\\'driver\\' or role=\\'client\\')\\n)\\n\\nselect request_at as \"Day\", round(sum(case when status=\\'cancelled_by_driver\\' or status=\\'cancelled_by_client\\' then 1 else 0 end)/count(*),2) as \"Cancellation Rate\"\\nfrom\\n(\\n    select status,request_at from Trips\\n    where client_id in (select users_id from ligit where role=\\'client\\')\\n      and driver_id in (select users_id from ligit where role=\\'driver\\')\\n) stats\\ngroup by request_at"
                    },
                    {
                        "username": "gaurangdamley",
                        "content": "Not sure what it is not accepting my solution. only difference I see is with the header.\\n\\nwith tot as (select count(*) as total,T.request_at as Day from Trips T, Users U\\nwhere T.client_id = U.users_id\\nAND U.banned = \\'No\\'\\ngroup by T.request_at),\\ncan as (select count(*) as total,T.request_at as Day from Trips T, users U\\nwhere t.client_id = u.users_id AND U.banned = \\'No\\'\\nAND T.status <>\\'completed\\'\\ngroup by T.request_at);\\n\\nselect t.Day as day, nvl(Trunc((c.total/t.total),2),0.00) cancellation_rate from tot t, can c\\nwhere t.Day = c.Day (+)\\norder by Day;"
                    },
                    {
                        "username": "jobless_lady",
                        "content": "9/11 test cases passed\\n\\nSELECT t.request_at as Day, \\nROUND((SUM(IF(t.status like \\'cancelled%\\' and u1.banned=\\'No\\',1,0)))/(SUM(IF(u1.banned=\\'No\\',1,0))),2) as \\'Cancellation Rate\\'\\n    FROM (SELECT * from Trips \\n    WHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\') t\\n    LEFT JOIN Users u1 ON t.client_id=u1.users_id\\n    LEFT JOIN Users u2 ON t.driver_id=u2.users_id\\nGROUP BY t.request_at\\n\\n\\nTrips =\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | Yes    | client |\\n| 10       | No     | driver |\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 |                   |\\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nKindly help in rectification of query"
                    },
                    {
                        "username": "athlchian",
                        "content": "`\nwith cancelCount as (\n    select count(id) as n1, request_at\n    from Trips\n    where status <> \"completed\"\n    and client_id in (select users_id from Users where banned = \"No\" and role = \"client\")\n    and driver_id in (select users_id from Users where banned = \"No\" and role = \"driver\")\n    group by request_at\n),\ntotalCount as (\n    select count(id) as n2, request_at\n    from Trips\n    group by request_at\n)\n\nselect totalCount.request_at as Day,\nIFNULL((cancelCount.n1 / totalCount.n2),0) as \"Cancellation Rate\"\nfrom totalCount\nleft join cancelCount\non totalCount.request_at = cancelCount.request_at\n`\n\nTest case is wrong"
                    },
                    {
                        "username": "joeybosa",
                        "content": "used CTEs to store banned users\\n\\n# banned drivers\\nwith banned_drivers as \\n(\\nselect distinct users_id\\nfrom Users\\nwhere role = \\'driver\\'\\nand banned = \\'Yes\\'\\n),\\n# banned clients\\nbanned_clients as \\n(\\nselect distinct users_id\\nfrom Users\\nwhere role = \\'client\\'\\nand banned = \\'Yes\\'\\n)\\n\\nselect request_at as Day, \\nround((sum(case status when \\'cancelled_by_driver\\' then 1 when \\'cancelled_by_client\\' then 1 else 0 end) \\n/\\ncount(*)),2) as \"Cancellation Rate\"\\nfrom Trips\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nand client_id not in (\\n    select users_id from banned_clients\\n)\\nand driver_id not in (\\n    select users_id from banned_drivers\\n)\\ngroup by 1\\n\\n"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "The leetcode answer has a bug, that it must requires the column to be called \"cancellation rate\" to pass, but when I put my couln as \"cancellation rate\", it put the rest of the code as string"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "WITH CTE AS (\\nSELECT client_id, driver_id, request_at, users_id, banned,\\nCASE WHEN status LIKE \\'cancelled%\\' THEN \\'cancelled\\' ELSE status END AS cancel_status\\nFROM Trips t LEFT JOIN Users u ON t.client_id = u.users_id OR t.driver_id = u.users_id\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\' AND driver_id != users_id AND banned != \\'Yes\\'\\nORDER BY request_at ASC\\n)\\n\\nSELECT request_at AS Day, ROUND(COUNT(CASE WHEN cancel_status = \\'cancelled\\' THEN 1 ELSE null END) / COUNT(*), 2) as Cancellation_Rate\\nFROM CTE\\nGROUP BY 1\\nORDER BY 1 ASC\\n"
                    },
                    {
                        "username": "musemen",
                        "content": "```\\n# total rides by unbanned users by day\\nwith total_rides as (SELECT t.request_at as day,\\ncount(1) as total_rides\\nfrom trips t  join \\nusers u on t.client_id = u.users_id and u.banned = \\'No\\' and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by 1),\\n\\n# cancelled rides by unbanned users by day\\ncancelled_rides as (\\nSELECT t.request_at as day,\\ncount(1) as cancelled_rides\\nfrom trips t join \\nusers u on t.client_id = u.users_id  \\nwhere t.status like \\'cancelled%\\'and u.banned = \\'No\\' and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by 1\\n),\\n\\ncombined as(select tr.day, tr.total_rides as total_rides, cr.cancelled_rides as cancelled_rides  from cancelled_rides cr\\nright join total_rides tr on cr.day = tr.day)\\n\\nselect day, case when cancelled_rides is NULL then 0\\nelse round(cancelled_rides/total_rides,2) end as \"cancellation rate\"\\nfrom combined\\n\\n```\\n\\nCan Someone help me with this, its failing 1 test case"
                    },
                    {
                        "username": "mailtopusapallip",
                        "content": "select t1.requested_at as Day ,\n        round()t2.cancel_trp_cnt/t1.cmplt_trp_cnt,2) as \"Cancellation Rate\" \n (select t.requested_at,count(1) as cmplt_trp_cnt from Trips t ,users c,users d\nwhere t.client_id =c.users_id \nand t.driver_id =d.users_id \nand t.requested_at between to_date ('2013-10-01','YYYY-MM-DD') and  to_date ('2013-10-03','YYYY-MM-DD')\nand c.banned='Yes'\nand d.banned='Yes'\nand t.status='Completed'\ngroup by t.requested_at\n)t1,\n(select t.requested_at,count(1) as cancel_trp_cnt from Trips t ,users c,users d\nwhere t.client_id =c.users_id \nand t.driver_id =d.users_id \nand t.requested_at between to_date ('2013-10-01','YYYY-MM-DD') and  to_date ('2013-10-03','YYYY-MM-DD')\nand c.banned='Yes'\nand d.banned='Yes'\nand t.status in ('cancelled_by_driver','cancelled_by_client')\ngroup by t.requested_at\n)t2\nwhere t1.requested_at=t2.requested_at\n\ncan somone check and let me know why this is not accepted .\nThis seems to be correct for me ,but not sure why run time error is coming .\nalso can someone from leetcode check and let me know ,how to check run time error .\nWhen I see error ,I will come to know what is the error and how to fix . Unfortunately leetcode is just saying run time error . which is not clear to me at all ,I am new to leetcode . Any help in this regard is highly appreciated .thank you ."
                    },
                    {
                        "username": "shellweCode",
                        "content": "Why there is a runtime error of \"Unknown column \\'t2.client_id\\' in \\'on clause\\' \" after running this line? It seems that i do not have any syntax error.\\nWith abc as (SELECT t1.request_at, COUNT(t1.id) AS \\'count\\' FROM Trips t1\\nLEFT JOIN Users ON Users.users_id = t1.client_id\\nWHERE t1.status IN (\\'cancelled_by_client\\',\\'cancelled_by_driver\\') AND Users.banned = \\'NO\\'\\nGROUP BY t1.request_at)\\nSELECT t2.request_at AS \\'Day\\', ROUND((abc.count/COUNT(t2.id)),2 )AS \\'Cancellation Rate\\' FROM Trips t2, abc\\nINNER JOIN Users u ON u.users_id = t2.client_id\\nWHERE u.banned = \\'NO\\' AND abc.request_at = t2.request_at\\nGROUP BY t2.request_at\\nORDER BY t2.request_at\\n\\nThank you for your help ><"
                    }
                ]
            },
            {
                "id": 1767324,
                "content": [
                    {
                        "username": "LAOMAITOU",
                        "content": "with ligit as (\\n    select users_id,role from Users\\n    where banned=\\'No\\' and (role=\\'driver\\' or role=\\'client\\')\\n)\\n\\nselect request_at as \"Day\", round(sum(case when status=\\'cancelled_by_driver\\' or status=\\'cancelled_by_client\\' then 1 else 0 end)/count(*),2) as \"Cancellation Rate\"\\nfrom\\n(\\n    select status,request_at from Trips\\n    where client_id in (select users_id from ligit where role=\\'client\\')\\n      and driver_id in (select users_id from ligit where role=\\'driver\\')\\n) stats\\ngroup by request_at"
                    },
                    {
                        "username": "gaurangdamley",
                        "content": "Not sure what it is not accepting my solution. only difference I see is with the header.\\n\\nwith tot as (select count(*) as total,T.request_at as Day from Trips T, Users U\\nwhere T.client_id = U.users_id\\nAND U.banned = \\'No\\'\\ngroup by T.request_at),\\ncan as (select count(*) as total,T.request_at as Day from Trips T, users U\\nwhere t.client_id = u.users_id AND U.banned = \\'No\\'\\nAND T.status <>\\'completed\\'\\ngroup by T.request_at);\\n\\nselect t.Day as day, nvl(Trunc((c.total/t.total),2),0.00) cancellation_rate from tot t, can c\\nwhere t.Day = c.Day (+)\\norder by Day;"
                    },
                    {
                        "username": "jobless_lady",
                        "content": "9/11 test cases passed\\n\\nSELECT t.request_at as Day, \\nROUND((SUM(IF(t.status like \\'cancelled%\\' and u1.banned=\\'No\\',1,0)))/(SUM(IF(u1.banned=\\'No\\',1,0))),2) as \\'Cancellation Rate\\'\\n    FROM (SELECT * from Trips \\n    WHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\') t\\n    LEFT JOIN Users u1 ON t.client_id=u1.users_id\\n    LEFT JOIN Users u2 ON t.driver_id=u2.users_id\\nGROUP BY t.request_at\\n\\n\\nTrips =\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | Yes    | client |\\n| 10       | No     | driver |\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 |                   |\\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nKindly help in rectification of query"
                    },
                    {
                        "username": "athlchian",
                        "content": "`\nwith cancelCount as (\n    select count(id) as n1, request_at\n    from Trips\n    where status <> \"completed\"\n    and client_id in (select users_id from Users where banned = \"No\" and role = \"client\")\n    and driver_id in (select users_id from Users where banned = \"No\" and role = \"driver\")\n    group by request_at\n),\ntotalCount as (\n    select count(id) as n2, request_at\n    from Trips\n    group by request_at\n)\n\nselect totalCount.request_at as Day,\nIFNULL((cancelCount.n1 / totalCount.n2),0) as \"Cancellation Rate\"\nfrom totalCount\nleft join cancelCount\non totalCount.request_at = cancelCount.request_at\n`\n\nTest case is wrong"
                    },
                    {
                        "username": "joeybosa",
                        "content": "used CTEs to store banned users\\n\\n# banned drivers\\nwith banned_drivers as \\n(\\nselect distinct users_id\\nfrom Users\\nwhere role = \\'driver\\'\\nand banned = \\'Yes\\'\\n),\\n# banned clients\\nbanned_clients as \\n(\\nselect distinct users_id\\nfrom Users\\nwhere role = \\'client\\'\\nand banned = \\'Yes\\'\\n)\\n\\nselect request_at as Day, \\nround((sum(case status when \\'cancelled_by_driver\\' then 1 when \\'cancelled_by_client\\' then 1 else 0 end) \\n/\\ncount(*)),2) as \"Cancellation Rate\"\\nfrom Trips\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nand client_id not in (\\n    select users_id from banned_clients\\n)\\nand driver_id not in (\\n    select users_id from banned_drivers\\n)\\ngroup by 1\\n\\n"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "The leetcode answer has a bug, that it must requires the column to be called \"cancellation rate\" to pass, but when I put my couln as \"cancellation rate\", it put the rest of the code as string"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "WITH CTE AS (\\nSELECT client_id, driver_id, request_at, users_id, banned,\\nCASE WHEN status LIKE \\'cancelled%\\' THEN \\'cancelled\\' ELSE status END AS cancel_status\\nFROM Trips t LEFT JOIN Users u ON t.client_id = u.users_id OR t.driver_id = u.users_id\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\' AND driver_id != users_id AND banned != \\'Yes\\'\\nORDER BY request_at ASC\\n)\\n\\nSELECT request_at AS Day, ROUND(COUNT(CASE WHEN cancel_status = \\'cancelled\\' THEN 1 ELSE null END) / COUNT(*), 2) as Cancellation_Rate\\nFROM CTE\\nGROUP BY 1\\nORDER BY 1 ASC\\n"
                    },
                    {
                        "username": "musemen",
                        "content": "```\\n# total rides by unbanned users by day\\nwith total_rides as (SELECT t.request_at as day,\\ncount(1) as total_rides\\nfrom trips t  join \\nusers u on t.client_id = u.users_id and u.banned = \\'No\\' and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by 1),\\n\\n# cancelled rides by unbanned users by day\\ncancelled_rides as (\\nSELECT t.request_at as day,\\ncount(1) as cancelled_rides\\nfrom trips t join \\nusers u on t.client_id = u.users_id  \\nwhere t.status like \\'cancelled%\\'and u.banned = \\'No\\' and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by 1\\n),\\n\\ncombined as(select tr.day, tr.total_rides as total_rides, cr.cancelled_rides as cancelled_rides  from cancelled_rides cr\\nright join total_rides tr on cr.day = tr.day)\\n\\nselect day, case when cancelled_rides is NULL then 0\\nelse round(cancelled_rides/total_rides,2) end as \"cancellation rate\"\\nfrom combined\\n\\n```\\n\\nCan Someone help me with this, its failing 1 test case"
                    },
                    {
                        "username": "mailtopusapallip",
                        "content": "select t1.requested_at as Day ,\n        round()t2.cancel_trp_cnt/t1.cmplt_trp_cnt,2) as \"Cancellation Rate\" \n (select t.requested_at,count(1) as cmplt_trp_cnt from Trips t ,users c,users d\nwhere t.client_id =c.users_id \nand t.driver_id =d.users_id \nand t.requested_at between to_date ('2013-10-01','YYYY-MM-DD') and  to_date ('2013-10-03','YYYY-MM-DD')\nand c.banned='Yes'\nand d.banned='Yes'\nand t.status='Completed'\ngroup by t.requested_at\n)t1,\n(select t.requested_at,count(1) as cancel_trp_cnt from Trips t ,users c,users d\nwhere t.client_id =c.users_id \nand t.driver_id =d.users_id \nand t.requested_at between to_date ('2013-10-01','YYYY-MM-DD') and  to_date ('2013-10-03','YYYY-MM-DD')\nand c.banned='Yes'\nand d.banned='Yes'\nand t.status in ('cancelled_by_driver','cancelled_by_client')\ngroup by t.requested_at\n)t2\nwhere t1.requested_at=t2.requested_at\n\ncan somone check and let me know why this is not accepted .\nThis seems to be correct for me ,but not sure why run time error is coming .\nalso can someone from leetcode check and let me know ,how to check run time error .\nWhen I see error ,I will come to know what is the error and how to fix . Unfortunately leetcode is just saying run time error . which is not clear to me at all ,I am new to leetcode . Any help in this regard is highly appreciated .thank you ."
                    },
                    {
                        "username": "shellweCode",
                        "content": "Why there is a runtime error of \"Unknown column \\'t2.client_id\\' in \\'on clause\\' \" after running this line? It seems that i do not have any syntax error.\\nWith abc as (SELECT t1.request_at, COUNT(t1.id) AS \\'count\\' FROM Trips t1\\nLEFT JOIN Users ON Users.users_id = t1.client_id\\nWHERE t1.status IN (\\'cancelled_by_client\\',\\'cancelled_by_driver\\') AND Users.banned = \\'NO\\'\\nGROUP BY t1.request_at)\\nSELECT t2.request_at AS \\'Day\\', ROUND((abc.count/COUNT(t2.id)),2 )AS \\'Cancellation Rate\\' FROM Trips t2, abc\\nINNER JOIN Users u ON u.users_id = t2.client_id\\nWHERE u.banned = \\'NO\\' AND abc.request_at = t2.request_at\\nGROUP BY t2.request_at\\nORDER BY t2.request_at\\n\\nThank you for your help ><"
                    }
                ]
            },
            {
                "id": 1766410,
                "content": [
                    {
                        "username": "LAOMAITOU",
                        "content": "with ligit as (\\n    select users_id,role from Users\\n    where banned=\\'No\\' and (role=\\'driver\\' or role=\\'client\\')\\n)\\n\\nselect request_at as \"Day\", round(sum(case when status=\\'cancelled_by_driver\\' or status=\\'cancelled_by_client\\' then 1 else 0 end)/count(*),2) as \"Cancellation Rate\"\\nfrom\\n(\\n    select status,request_at from Trips\\n    where client_id in (select users_id from ligit where role=\\'client\\')\\n      and driver_id in (select users_id from ligit where role=\\'driver\\')\\n) stats\\ngroup by request_at"
                    },
                    {
                        "username": "gaurangdamley",
                        "content": "Not sure what it is not accepting my solution. only difference I see is with the header.\\n\\nwith tot as (select count(*) as total,T.request_at as Day from Trips T, Users U\\nwhere T.client_id = U.users_id\\nAND U.banned = \\'No\\'\\ngroup by T.request_at),\\ncan as (select count(*) as total,T.request_at as Day from Trips T, users U\\nwhere t.client_id = u.users_id AND U.banned = \\'No\\'\\nAND T.status <>\\'completed\\'\\ngroup by T.request_at);\\n\\nselect t.Day as day, nvl(Trunc((c.total/t.total),2),0.00) cancellation_rate from tot t, can c\\nwhere t.Day = c.Day (+)\\norder by Day;"
                    },
                    {
                        "username": "jobless_lady",
                        "content": "9/11 test cases passed\\n\\nSELECT t.request_at as Day, \\nROUND((SUM(IF(t.status like \\'cancelled%\\' and u1.banned=\\'No\\',1,0)))/(SUM(IF(u1.banned=\\'No\\',1,0))),2) as \\'Cancellation Rate\\'\\n    FROM (SELECT * from Trips \\n    WHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\') t\\n    LEFT JOIN Users u1 ON t.client_id=u1.users_id\\n    LEFT JOIN Users u2 ON t.driver_id=u2.users_id\\nGROUP BY t.request_at\\n\\n\\nTrips =\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | Yes    | client |\\n| 10       | No     | driver |\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 |                   |\\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nKindly help in rectification of query"
                    },
                    {
                        "username": "athlchian",
                        "content": "`\nwith cancelCount as (\n    select count(id) as n1, request_at\n    from Trips\n    where status <> \"completed\"\n    and client_id in (select users_id from Users where banned = \"No\" and role = \"client\")\n    and driver_id in (select users_id from Users where banned = \"No\" and role = \"driver\")\n    group by request_at\n),\ntotalCount as (\n    select count(id) as n2, request_at\n    from Trips\n    group by request_at\n)\n\nselect totalCount.request_at as Day,\nIFNULL((cancelCount.n1 / totalCount.n2),0) as \"Cancellation Rate\"\nfrom totalCount\nleft join cancelCount\non totalCount.request_at = cancelCount.request_at\n`\n\nTest case is wrong"
                    },
                    {
                        "username": "joeybosa",
                        "content": "used CTEs to store banned users\\n\\n# banned drivers\\nwith banned_drivers as \\n(\\nselect distinct users_id\\nfrom Users\\nwhere role = \\'driver\\'\\nand banned = \\'Yes\\'\\n),\\n# banned clients\\nbanned_clients as \\n(\\nselect distinct users_id\\nfrom Users\\nwhere role = \\'client\\'\\nand banned = \\'Yes\\'\\n)\\n\\nselect request_at as Day, \\nround((sum(case status when \\'cancelled_by_driver\\' then 1 when \\'cancelled_by_client\\' then 1 else 0 end) \\n/\\ncount(*)),2) as \"Cancellation Rate\"\\nfrom Trips\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nand client_id not in (\\n    select users_id from banned_clients\\n)\\nand driver_id not in (\\n    select users_id from banned_drivers\\n)\\ngroup by 1\\n\\n"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "The leetcode answer has a bug, that it must requires the column to be called \"cancellation rate\" to pass, but when I put my couln as \"cancellation rate\", it put the rest of the code as string"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "WITH CTE AS (\\nSELECT client_id, driver_id, request_at, users_id, banned,\\nCASE WHEN status LIKE \\'cancelled%\\' THEN \\'cancelled\\' ELSE status END AS cancel_status\\nFROM Trips t LEFT JOIN Users u ON t.client_id = u.users_id OR t.driver_id = u.users_id\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\' AND driver_id != users_id AND banned != \\'Yes\\'\\nORDER BY request_at ASC\\n)\\n\\nSELECT request_at AS Day, ROUND(COUNT(CASE WHEN cancel_status = \\'cancelled\\' THEN 1 ELSE null END) / COUNT(*), 2) as Cancellation_Rate\\nFROM CTE\\nGROUP BY 1\\nORDER BY 1 ASC\\n"
                    },
                    {
                        "username": "musemen",
                        "content": "```\\n# total rides by unbanned users by day\\nwith total_rides as (SELECT t.request_at as day,\\ncount(1) as total_rides\\nfrom trips t  join \\nusers u on t.client_id = u.users_id and u.banned = \\'No\\' and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by 1),\\n\\n# cancelled rides by unbanned users by day\\ncancelled_rides as (\\nSELECT t.request_at as day,\\ncount(1) as cancelled_rides\\nfrom trips t join \\nusers u on t.client_id = u.users_id  \\nwhere t.status like \\'cancelled%\\'and u.banned = \\'No\\' and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by 1\\n),\\n\\ncombined as(select tr.day, tr.total_rides as total_rides, cr.cancelled_rides as cancelled_rides  from cancelled_rides cr\\nright join total_rides tr on cr.day = tr.day)\\n\\nselect day, case when cancelled_rides is NULL then 0\\nelse round(cancelled_rides/total_rides,2) end as \"cancellation rate\"\\nfrom combined\\n\\n```\\n\\nCan Someone help me with this, its failing 1 test case"
                    },
                    {
                        "username": "mailtopusapallip",
                        "content": "select t1.requested_at as Day ,\n        round()t2.cancel_trp_cnt/t1.cmplt_trp_cnt,2) as \"Cancellation Rate\" \n (select t.requested_at,count(1) as cmplt_trp_cnt from Trips t ,users c,users d\nwhere t.client_id =c.users_id \nand t.driver_id =d.users_id \nand t.requested_at between to_date ('2013-10-01','YYYY-MM-DD') and  to_date ('2013-10-03','YYYY-MM-DD')\nand c.banned='Yes'\nand d.banned='Yes'\nand t.status='Completed'\ngroup by t.requested_at\n)t1,\n(select t.requested_at,count(1) as cancel_trp_cnt from Trips t ,users c,users d\nwhere t.client_id =c.users_id \nand t.driver_id =d.users_id \nand t.requested_at between to_date ('2013-10-01','YYYY-MM-DD') and  to_date ('2013-10-03','YYYY-MM-DD')\nand c.banned='Yes'\nand d.banned='Yes'\nand t.status in ('cancelled_by_driver','cancelled_by_client')\ngroup by t.requested_at\n)t2\nwhere t1.requested_at=t2.requested_at\n\ncan somone check and let me know why this is not accepted .\nThis seems to be correct for me ,but not sure why run time error is coming .\nalso can someone from leetcode check and let me know ,how to check run time error .\nWhen I see error ,I will come to know what is the error and how to fix . Unfortunately leetcode is just saying run time error . which is not clear to me at all ,I am new to leetcode . Any help in this regard is highly appreciated .thank you ."
                    },
                    {
                        "username": "shellweCode",
                        "content": "Why there is a runtime error of \"Unknown column \\'t2.client_id\\' in \\'on clause\\' \" after running this line? It seems that i do not have any syntax error.\\nWith abc as (SELECT t1.request_at, COUNT(t1.id) AS \\'count\\' FROM Trips t1\\nLEFT JOIN Users ON Users.users_id = t1.client_id\\nWHERE t1.status IN (\\'cancelled_by_client\\',\\'cancelled_by_driver\\') AND Users.banned = \\'NO\\'\\nGROUP BY t1.request_at)\\nSELECT t2.request_at AS \\'Day\\', ROUND((abc.count/COUNT(t2.id)),2 )AS \\'Cancellation Rate\\' FROM Trips t2, abc\\nINNER JOIN Users u ON u.users_id = t2.client_id\\nWHERE u.banned = \\'NO\\' AND abc.request_at = t2.request_at\\nGROUP BY t2.request_at\\nORDER BY t2.request_at\\n\\nThank you for your help ><"
                    }
                ]
            },
            {
                "id": 1756472,
                "content": [
                    {
                        "username": "LAOMAITOU",
                        "content": "with ligit as (\\n    select users_id,role from Users\\n    where banned=\\'No\\' and (role=\\'driver\\' or role=\\'client\\')\\n)\\n\\nselect request_at as \"Day\", round(sum(case when status=\\'cancelled_by_driver\\' or status=\\'cancelled_by_client\\' then 1 else 0 end)/count(*),2) as \"Cancellation Rate\"\\nfrom\\n(\\n    select status,request_at from Trips\\n    where client_id in (select users_id from ligit where role=\\'client\\')\\n      and driver_id in (select users_id from ligit where role=\\'driver\\')\\n) stats\\ngroup by request_at"
                    },
                    {
                        "username": "gaurangdamley",
                        "content": "Not sure what it is not accepting my solution. only difference I see is with the header.\\n\\nwith tot as (select count(*) as total,T.request_at as Day from Trips T, Users U\\nwhere T.client_id = U.users_id\\nAND U.banned = \\'No\\'\\ngroup by T.request_at),\\ncan as (select count(*) as total,T.request_at as Day from Trips T, users U\\nwhere t.client_id = u.users_id AND U.banned = \\'No\\'\\nAND T.status <>\\'completed\\'\\ngroup by T.request_at);\\n\\nselect t.Day as day, nvl(Trunc((c.total/t.total),2),0.00) cancellation_rate from tot t, can c\\nwhere t.Day = c.Day (+)\\norder by Day;"
                    },
                    {
                        "username": "jobless_lady",
                        "content": "9/11 test cases passed\\n\\nSELECT t.request_at as Day, \\nROUND((SUM(IF(t.status like \\'cancelled%\\' and u1.banned=\\'No\\',1,0)))/(SUM(IF(u1.banned=\\'No\\',1,0))),2) as \\'Cancellation Rate\\'\\n    FROM (SELECT * from Trips \\n    WHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\') t\\n    LEFT JOIN Users u1 ON t.client_id=u1.users_id\\n    LEFT JOIN Users u2 ON t.driver_id=u2.users_id\\nGROUP BY t.request_at\\n\\n\\nTrips =\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | Yes    | client |\\n| 10       | No     | driver |\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 |                   |\\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nKindly help in rectification of query"
                    },
                    {
                        "username": "athlchian",
                        "content": "`\nwith cancelCount as (\n    select count(id) as n1, request_at\n    from Trips\n    where status <> \"completed\"\n    and client_id in (select users_id from Users where banned = \"No\" and role = \"client\")\n    and driver_id in (select users_id from Users where banned = \"No\" and role = \"driver\")\n    group by request_at\n),\ntotalCount as (\n    select count(id) as n2, request_at\n    from Trips\n    group by request_at\n)\n\nselect totalCount.request_at as Day,\nIFNULL((cancelCount.n1 / totalCount.n2),0) as \"Cancellation Rate\"\nfrom totalCount\nleft join cancelCount\non totalCount.request_at = cancelCount.request_at\n`\n\nTest case is wrong"
                    },
                    {
                        "username": "joeybosa",
                        "content": "used CTEs to store banned users\\n\\n# banned drivers\\nwith banned_drivers as \\n(\\nselect distinct users_id\\nfrom Users\\nwhere role = \\'driver\\'\\nand banned = \\'Yes\\'\\n),\\n# banned clients\\nbanned_clients as \\n(\\nselect distinct users_id\\nfrom Users\\nwhere role = \\'client\\'\\nand banned = \\'Yes\\'\\n)\\n\\nselect request_at as Day, \\nround((sum(case status when \\'cancelled_by_driver\\' then 1 when \\'cancelled_by_client\\' then 1 else 0 end) \\n/\\ncount(*)),2) as \"Cancellation Rate\"\\nfrom Trips\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nand client_id not in (\\n    select users_id from banned_clients\\n)\\nand driver_id not in (\\n    select users_id from banned_drivers\\n)\\ngroup by 1\\n\\n"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "The leetcode answer has a bug, that it must requires the column to be called \"cancellation rate\" to pass, but when I put my couln as \"cancellation rate\", it put the rest of the code as string"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "WITH CTE AS (\\nSELECT client_id, driver_id, request_at, users_id, banned,\\nCASE WHEN status LIKE \\'cancelled%\\' THEN \\'cancelled\\' ELSE status END AS cancel_status\\nFROM Trips t LEFT JOIN Users u ON t.client_id = u.users_id OR t.driver_id = u.users_id\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\' AND driver_id != users_id AND banned != \\'Yes\\'\\nORDER BY request_at ASC\\n)\\n\\nSELECT request_at AS Day, ROUND(COUNT(CASE WHEN cancel_status = \\'cancelled\\' THEN 1 ELSE null END) / COUNT(*), 2) as Cancellation_Rate\\nFROM CTE\\nGROUP BY 1\\nORDER BY 1 ASC\\n"
                    },
                    {
                        "username": "musemen",
                        "content": "```\\n# total rides by unbanned users by day\\nwith total_rides as (SELECT t.request_at as day,\\ncount(1) as total_rides\\nfrom trips t  join \\nusers u on t.client_id = u.users_id and u.banned = \\'No\\' and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by 1),\\n\\n# cancelled rides by unbanned users by day\\ncancelled_rides as (\\nSELECT t.request_at as day,\\ncount(1) as cancelled_rides\\nfrom trips t join \\nusers u on t.client_id = u.users_id  \\nwhere t.status like \\'cancelled%\\'and u.banned = \\'No\\' and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by 1\\n),\\n\\ncombined as(select tr.day, tr.total_rides as total_rides, cr.cancelled_rides as cancelled_rides  from cancelled_rides cr\\nright join total_rides tr on cr.day = tr.day)\\n\\nselect day, case when cancelled_rides is NULL then 0\\nelse round(cancelled_rides/total_rides,2) end as \"cancellation rate\"\\nfrom combined\\n\\n```\\n\\nCan Someone help me with this, its failing 1 test case"
                    },
                    {
                        "username": "mailtopusapallip",
                        "content": "select t1.requested_at as Day ,\n        round()t2.cancel_trp_cnt/t1.cmplt_trp_cnt,2) as \"Cancellation Rate\" \n (select t.requested_at,count(1) as cmplt_trp_cnt from Trips t ,users c,users d\nwhere t.client_id =c.users_id \nand t.driver_id =d.users_id \nand t.requested_at between to_date ('2013-10-01','YYYY-MM-DD') and  to_date ('2013-10-03','YYYY-MM-DD')\nand c.banned='Yes'\nand d.banned='Yes'\nand t.status='Completed'\ngroup by t.requested_at\n)t1,\n(select t.requested_at,count(1) as cancel_trp_cnt from Trips t ,users c,users d\nwhere t.client_id =c.users_id \nand t.driver_id =d.users_id \nand t.requested_at between to_date ('2013-10-01','YYYY-MM-DD') and  to_date ('2013-10-03','YYYY-MM-DD')\nand c.banned='Yes'\nand d.banned='Yes'\nand t.status in ('cancelled_by_driver','cancelled_by_client')\ngroup by t.requested_at\n)t2\nwhere t1.requested_at=t2.requested_at\n\ncan somone check and let me know why this is not accepted .\nThis seems to be correct for me ,but not sure why run time error is coming .\nalso can someone from leetcode check and let me know ,how to check run time error .\nWhen I see error ,I will come to know what is the error and how to fix . Unfortunately leetcode is just saying run time error . which is not clear to me at all ,I am new to leetcode . Any help in this regard is highly appreciated .thank you ."
                    },
                    {
                        "username": "shellweCode",
                        "content": "Why there is a runtime error of \"Unknown column \\'t2.client_id\\' in \\'on clause\\' \" after running this line? It seems that i do not have any syntax error.\\nWith abc as (SELECT t1.request_at, COUNT(t1.id) AS \\'count\\' FROM Trips t1\\nLEFT JOIN Users ON Users.users_id = t1.client_id\\nWHERE t1.status IN (\\'cancelled_by_client\\',\\'cancelled_by_driver\\') AND Users.banned = \\'NO\\'\\nGROUP BY t1.request_at)\\nSELECT t2.request_at AS \\'Day\\', ROUND((abc.count/COUNT(t2.id)),2 )AS \\'Cancellation Rate\\' FROM Trips t2, abc\\nINNER JOIN Users u ON u.users_id = t2.client_id\\nWHERE u.banned = \\'NO\\' AND abc.request_at = t2.request_at\\nGROUP BY t2.request_at\\nORDER BY t2.request_at\\n\\nThank you for your help ><"
                    }
                ]
            },
            {
                "id": 1753835,
                "content": [
                    {
                        "username": "LAOMAITOU",
                        "content": "with ligit as (\\n    select users_id,role from Users\\n    where banned=\\'No\\' and (role=\\'driver\\' or role=\\'client\\')\\n)\\n\\nselect request_at as \"Day\", round(sum(case when status=\\'cancelled_by_driver\\' or status=\\'cancelled_by_client\\' then 1 else 0 end)/count(*),2) as \"Cancellation Rate\"\\nfrom\\n(\\n    select status,request_at from Trips\\n    where client_id in (select users_id from ligit where role=\\'client\\')\\n      and driver_id in (select users_id from ligit where role=\\'driver\\')\\n) stats\\ngroup by request_at"
                    },
                    {
                        "username": "gaurangdamley",
                        "content": "Not sure what it is not accepting my solution. only difference I see is with the header.\\n\\nwith tot as (select count(*) as total,T.request_at as Day from Trips T, Users U\\nwhere T.client_id = U.users_id\\nAND U.banned = \\'No\\'\\ngroup by T.request_at),\\ncan as (select count(*) as total,T.request_at as Day from Trips T, users U\\nwhere t.client_id = u.users_id AND U.banned = \\'No\\'\\nAND T.status <>\\'completed\\'\\ngroup by T.request_at);\\n\\nselect t.Day as day, nvl(Trunc((c.total/t.total),2),0.00) cancellation_rate from tot t, can c\\nwhere t.Day = c.Day (+)\\norder by Day;"
                    },
                    {
                        "username": "jobless_lady",
                        "content": "9/11 test cases passed\\n\\nSELECT t.request_at as Day, \\nROUND((SUM(IF(t.status like \\'cancelled%\\' and u1.banned=\\'No\\',1,0)))/(SUM(IF(u1.banned=\\'No\\',1,0))),2) as \\'Cancellation Rate\\'\\n    FROM (SELECT * from Trips \\n    WHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\') t\\n    LEFT JOIN Users u1 ON t.client_id=u1.users_id\\n    LEFT JOIN Users u2 ON t.driver_id=u2.users_id\\nGROUP BY t.request_at\\n\\n\\nTrips =\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | Yes    | client |\\n| 10       | No     | driver |\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 |                   |\\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nKindly help in rectification of query"
                    },
                    {
                        "username": "athlchian",
                        "content": "`\nwith cancelCount as (\n    select count(id) as n1, request_at\n    from Trips\n    where status <> \"completed\"\n    and client_id in (select users_id from Users where banned = \"No\" and role = \"client\")\n    and driver_id in (select users_id from Users where banned = \"No\" and role = \"driver\")\n    group by request_at\n),\ntotalCount as (\n    select count(id) as n2, request_at\n    from Trips\n    group by request_at\n)\n\nselect totalCount.request_at as Day,\nIFNULL((cancelCount.n1 / totalCount.n2),0) as \"Cancellation Rate\"\nfrom totalCount\nleft join cancelCount\non totalCount.request_at = cancelCount.request_at\n`\n\nTest case is wrong"
                    },
                    {
                        "username": "joeybosa",
                        "content": "used CTEs to store banned users\\n\\n# banned drivers\\nwith banned_drivers as \\n(\\nselect distinct users_id\\nfrom Users\\nwhere role = \\'driver\\'\\nand banned = \\'Yes\\'\\n),\\n# banned clients\\nbanned_clients as \\n(\\nselect distinct users_id\\nfrom Users\\nwhere role = \\'client\\'\\nand banned = \\'Yes\\'\\n)\\n\\nselect request_at as Day, \\nround((sum(case status when \\'cancelled_by_driver\\' then 1 when \\'cancelled_by_client\\' then 1 else 0 end) \\n/\\ncount(*)),2) as \"Cancellation Rate\"\\nfrom Trips\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nand client_id not in (\\n    select users_id from banned_clients\\n)\\nand driver_id not in (\\n    select users_id from banned_drivers\\n)\\ngroup by 1\\n\\n"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "The leetcode answer has a bug, that it must requires the column to be called \"cancellation rate\" to pass, but when I put my couln as \"cancellation rate\", it put the rest of the code as string"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "WITH CTE AS (\\nSELECT client_id, driver_id, request_at, users_id, banned,\\nCASE WHEN status LIKE \\'cancelled%\\' THEN \\'cancelled\\' ELSE status END AS cancel_status\\nFROM Trips t LEFT JOIN Users u ON t.client_id = u.users_id OR t.driver_id = u.users_id\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\' AND driver_id != users_id AND banned != \\'Yes\\'\\nORDER BY request_at ASC\\n)\\n\\nSELECT request_at AS Day, ROUND(COUNT(CASE WHEN cancel_status = \\'cancelled\\' THEN 1 ELSE null END) / COUNT(*), 2) as Cancellation_Rate\\nFROM CTE\\nGROUP BY 1\\nORDER BY 1 ASC\\n"
                    },
                    {
                        "username": "musemen",
                        "content": "```\\n# total rides by unbanned users by day\\nwith total_rides as (SELECT t.request_at as day,\\ncount(1) as total_rides\\nfrom trips t  join \\nusers u on t.client_id = u.users_id and u.banned = \\'No\\' and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by 1),\\n\\n# cancelled rides by unbanned users by day\\ncancelled_rides as (\\nSELECT t.request_at as day,\\ncount(1) as cancelled_rides\\nfrom trips t join \\nusers u on t.client_id = u.users_id  \\nwhere t.status like \\'cancelled%\\'and u.banned = \\'No\\' and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by 1\\n),\\n\\ncombined as(select tr.day, tr.total_rides as total_rides, cr.cancelled_rides as cancelled_rides  from cancelled_rides cr\\nright join total_rides tr on cr.day = tr.day)\\n\\nselect day, case when cancelled_rides is NULL then 0\\nelse round(cancelled_rides/total_rides,2) end as \"cancellation rate\"\\nfrom combined\\n\\n```\\n\\nCan Someone help me with this, its failing 1 test case"
                    },
                    {
                        "username": "mailtopusapallip",
                        "content": "select t1.requested_at as Day ,\n        round()t2.cancel_trp_cnt/t1.cmplt_trp_cnt,2) as \"Cancellation Rate\" \n (select t.requested_at,count(1) as cmplt_trp_cnt from Trips t ,users c,users d\nwhere t.client_id =c.users_id \nand t.driver_id =d.users_id \nand t.requested_at between to_date ('2013-10-01','YYYY-MM-DD') and  to_date ('2013-10-03','YYYY-MM-DD')\nand c.banned='Yes'\nand d.banned='Yes'\nand t.status='Completed'\ngroup by t.requested_at\n)t1,\n(select t.requested_at,count(1) as cancel_trp_cnt from Trips t ,users c,users d\nwhere t.client_id =c.users_id \nand t.driver_id =d.users_id \nand t.requested_at between to_date ('2013-10-01','YYYY-MM-DD') and  to_date ('2013-10-03','YYYY-MM-DD')\nand c.banned='Yes'\nand d.banned='Yes'\nand t.status in ('cancelled_by_driver','cancelled_by_client')\ngroup by t.requested_at\n)t2\nwhere t1.requested_at=t2.requested_at\n\ncan somone check and let me know why this is not accepted .\nThis seems to be correct for me ,but not sure why run time error is coming .\nalso can someone from leetcode check and let me know ,how to check run time error .\nWhen I see error ,I will come to know what is the error and how to fix . Unfortunately leetcode is just saying run time error . which is not clear to me at all ,I am new to leetcode . Any help in this regard is highly appreciated .thank you ."
                    },
                    {
                        "username": "shellweCode",
                        "content": "Why there is a runtime error of \"Unknown column \\'t2.client_id\\' in \\'on clause\\' \" after running this line? It seems that i do not have any syntax error.\\nWith abc as (SELECT t1.request_at, COUNT(t1.id) AS \\'count\\' FROM Trips t1\\nLEFT JOIN Users ON Users.users_id = t1.client_id\\nWHERE t1.status IN (\\'cancelled_by_client\\',\\'cancelled_by_driver\\') AND Users.banned = \\'NO\\'\\nGROUP BY t1.request_at)\\nSELECT t2.request_at AS \\'Day\\', ROUND((abc.count/COUNT(t2.id)),2 )AS \\'Cancellation Rate\\' FROM Trips t2, abc\\nINNER JOIN Users u ON u.users_id = t2.client_id\\nWHERE u.banned = \\'NO\\' AND abc.request_at = t2.request_at\\nGROUP BY t2.request_at\\nORDER BY t2.request_at\\n\\nThank you for your help ><"
                    }
                ]
            },
            {
                "id": 1753825,
                "content": [
                    {
                        "username": "LAOMAITOU",
                        "content": "with ligit as (\\n    select users_id,role from Users\\n    where banned=\\'No\\' and (role=\\'driver\\' or role=\\'client\\')\\n)\\n\\nselect request_at as \"Day\", round(sum(case when status=\\'cancelled_by_driver\\' or status=\\'cancelled_by_client\\' then 1 else 0 end)/count(*),2) as \"Cancellation Rate\"\\nfrom\\n(\\n    select status,request_at from Trips\\n    where client_id in (select users_id from ligit where role=\\'client\\')\\n      and driver_id in (select users_id from ligit where role=\\'driver\\')\\n) stats\\ngroup by request_at"
                    },
                    {
                        "username": "gaurangdamley",
                        "content": "Not sure what it is not accepting my solution. only difference I see is with the header.\\n\\nwith tot as (select count(*) as total,T.request_at as Day from Trips T, Users U\\nwhere T.client_id = U.users_id\\nAND U.banned = \\'No\\'\\ngroup by T.request_at),\\ncan as (select count(*) as total,T.request_at as Day from Trips T, users U\\nwhere t.client_id = u.users_id AND U.banned = \\'No\\'\\nAND T.status <>\\'completed\\'\\ngroup by T.request_at);\\n\\nselect t.Day as day, nvl(Trunc((c.total/t.total),2),0.00) cancellation_rate from tot t, can c\\nwhere t.Day = c.Day (+)\\norder by Day;"
                    },
                    {
                        "username": "jobless_lady",
                        "content": "9/11 test cases passed\\n\\nSELECT t.request_at as Day, \\nROUND((SUM(IF(t.status like \\'cancelled%\\' and u1.banned=\\'No\\',1,0)))/(SUM(IF(u1.banned=\\'No\\',1,0))),2) as \\'Cancellation Rate\\'\\n    FROM (SELECT * from Trips \\n    WHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\') t\\n    LEFT JOIN Users u1 ON t.client_id=u1.users_id\\n    LEFT JOIN Users u2 ON t.driver_id=u2.users_id\\nGROUP BY t.request_at\\n\\n\\nTrips =\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | Yes    | client |\\n| 10       | No     | driver |\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 |                   |\\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nKindly help in rectification of query"
                    },
                    {
                        "username": "athlchian",
                        "content": "`\nwith cancelCount as (\n    select count(id) as n1, request_at\n    from Trips\n    where status <> \"completed\"\n    and client_id in (select users_id from Users where banned = \"No\" and role = \"client\")\n    and driver_id in (select users_id from Users where banned = \"No\" and role = \"driver\")\n    group by request_at\n),\ntotalCount as (\n    select count(id) as n2, request_at\n    from Trips\n    group by request_at\n)\n\nselect totalCount.request_at as Day,\nIFNULL((cancelCount.n1 / totalCount.n2),0) as \"Cancellation Rate\"\nfrom totalCount\nleft join cancelCount\non totalCount.request_at = cancelCount.request_at\n`\n\nTest case is wrong"
                    },
                    {
                        "username": "joeybosa",
                        "content": "used CTEs to store banned users\\n\\n# banned drivers\\nwith banned_drivers as \\n(\\nselect distinct users_id\\nfrom Users\\nwhere role = \\'driver\\'\\nand banned = \\'Yes\\'\\n),\\n# banned clients\\nbanned_clients as \\n(\\nselect distinct users_id\\nfrom Users\\nwhere role = \\'client\\'\\nand banned = \\'Yes\\'\\n)\\n\\nselect request_at as Day, \\nround((sum(case status when \\'cancelled_by_driver\\' then 1 when \\'cancelled_by_client\\' then 1 else 0 end) \\n/\\ncount(*)),2) as \"Cancellation Rate\"\\nfrom Trips\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nand client_id not in (\\n    select users_id from banned_clients\\n)\\nand driver_id not in (\\n    select users_id from banned_drivers\\n)\\ngroup by 1\\n\\n"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "The leetcode answer has a bug, that it must requires the column to be called \"cancellation rate\" to pass, but when I put my couln as \"cancellation rate\", it put the rest of the code as string"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "WITH CTE AS (\\nSELECT client_id, driver_id, request_at, users_id, banned,\\nCASE WHEN status LIKE \\'cancelled%\\' THEN \\'cancelled\\' ELSE status END AS cancel_status\\nFROM Trips t LEFT JOIN Users u ON t.client_id = u.users_id OR t.driver_id = u.users_id\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\' AND driver_id != users_id AND banned != \\'Yes\\'\\nORDER BY request_at ASC\\n)\\n\\nSELECT request_at AS Day, ROUND(COUNT(CASE WHEN cancel_status = \\'cancelled\\' THEN 1 ELSE null END) / COUNT(*), 2) as Cancellation_Rate\\nFROM CTE\\nGROUP BY 1\\nORDER BY 1 ASC\\n"
                    },
                    {
                        "username": "musemen",
                        "content": "```\\n# total rides by unbanned users by day\\nwith total_rides as (SELECT t.request_at as day,\\ncount(1) as total_rides\\nfrom trips t  join \\nusers u on t.client_id = u.users_id and u.banned = \\'No\\' and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by 1),\\n\\n# cancelled rides by unbanned users by day\\ncancelled_rides as (\\nSELECT t.request_at as day,\\ncount(1) as cancelled_rides\\nfrom trips t join \\nusers u on t.client_id = u.users_id  \\nwhere t.status like \\'cancelled%\\'and u.banned = \\'No\\' and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by 1\\n),\\n\\ncombined as(select tr.day, tr.total_rides as total_rides, cr.cancelled_rides as cancelled_rides  from cancelled_rides cr\\nright join total_rides tr on cr.day = tr.day)\\n\\nselect day, case when cancelled_rides is NULL then 0\\nelse round(cancelled_rides/total_rides,2) end as \"cancellation rate\"\\nfrom combined\\n\\n```\\n\\nCan Someone help me with this, its failing 1 test case"
                    },
                    {
                        "username": "mailtopusapallip",
                        "content": "select t1.requested_at as Day ,\n        round()t2.cancel_trp_cnt/t1.cmplt_trp_cnt,2) as \"Cancellation Rate\" \n (select t.requested_at,count(1) as cmplt_trp_cnt from Trips t ,users c,users d\nwhere t.client_id =c.users_id \nand t.driver_id =d.users_id \nand t.requested_at between to_date ('2013-10-01','YYYY-MM-DD') and  to_date ('2013-10-03','YYYY-MM-DD')\nand c.banned='Yes'\nand d.banned='Yes'\nand t.status='Completed'\ngroup by t.requested_at\n)t1,\n(select t.requested_at,count(1) as cancel_trp_cnt from Trips t ,users c,users d\nwhere t.client_id =c.users_id \nand t.driver_id =d.users_id \nand t.requested_at between to_date ('2013-10-01','YYYY-MM-DD') and  to_date ('2013-10-03','YYYY-MM-DD')\nand c.banned='Yes'\nand d.banned='Yes'\nand t.status in ('cancelled_by_driver','cancelled_by_client')\ngroup by t.requested_at\n)t2\nwhere t1.requested_at=t2.requested_at\n\ncan somone check and let me know why this is not accepted .\nThis seems to be correct for me ,but not sure why run time error is coming .\nalso can someone from leetcode check and let me know ,how to check run time error .\nWhen I see error ,I will come to know what is the error and how to fix . Unfortunately leetcode is just saying run time error . which is not clear to me at all ,I am new to leetcode . Any help in this regard is highly appreciated .thank you ."
                    },
                    {
                        "username": "shellweCode",
                        "content": "Why there is a runtime error of \"Unknown column \\'t2.client_id\\' in \\'on clause\\' \" after running this line? It seems that i do not have any syntax error.\\nWith abc as (SELECT t1.request_at, COUNT(t1.id) AS \\'count\\' FROM Trips t1\\nLEFT JOIN Users ON Users.users_id = t1.client_id\\nWHERE t1.status IN (\\'cancelled_by_client\\',\\'cancelled_by_driver\\') AND Users.banned = \\'NO\\'\\nGROUP BY t1.request_at)\\nSELECT t2.request_at AS \\'Day\\', ROUND((abc.count/COUNT(t2.id)),2 )AS \\'Cancellation Rate\\' FROM Trips t2, abc\\nINNER JOIN Users u ON u.users_id = t2.client_id\\nWHERE u.banned = \\'NO\\' AND abc.request_at = t2.request_at\\nGROUP BY t2.request_at\\nORDER BY t2.request_at\\n\\nThank you for your help ><"
                    }
                ]
            },
            {
                "id": 1740844,
                "content": [
                    {
                        "username": "LAOMAITOU",
                        "content": "with ligit as (\\n    select users_id,role from Users\\n    where banned=\\'No\\' and (role=\\'driver\\' or role=\\'client\\')\\n)\\n\\nselect request_at as \"Day\", round(sum(case when status=\\'cancelled_by_driver\\' or status=\\'cancelled_by_client\\' then 1 else 0 end)/count(*),2) as \"Cancellation Rate\"\\nfrom\\n(\\n    select status,request_at from Trips\\n    where client_id in (select users_id from ligit where role=\\'client\\')\\n      and driver_id in (select users_id from ligit where role=\\'driver\\')\\n) stats\\ngroup by request_at"
                    },
                    {
                        "username": "gaurangdamley",
                        "content": "Not sure what it is not accepting my solution. only difference I see is with the header.\\n\\nwith tot as (select count(*) as total,T.request_at as Day from Trips T, Users U\\nwhere T.client_id = U.users_id\\nAND U.banned = \\'No\\'\\ngroup by T.request_at),\\ncan as (select count(*) as total,T.request_at as Day from Trips T, users U\\nwhere t.client_id = u.users_id AND U.banned = \\'No\\'\\nAND T.status <>\\'completed\\'\\ngroup by T.request_at);\\n\\nselect t.Day as day, nvl(Trunc((c.total/t.total),2),0.00) cancellation_rate from tot t, can c\\nwhere t.Day = c.Day (+)\\norder by Day;"
                    },
                    {
                        "username": "jobless_lady",
                        "content": "9/11 test cases passed\\n\\nSELECT t.request_at as Day, \\nROUND((SUM(IF(t.status like \\'cancelled%\\' and u1.banned=\\'No\\',1,0)))/(SUM(IF(u1.banned=\\'No\\',1,0))),2) as \\'Cancellation Rate\\'\\n    FROM (SELECT * from Trips \\n    WHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\') t\\n    LEFT JOIN Users u1 ON t.client_id=u1.users_id\\n    LEFT JOIN Users u2 ON t.driver_id=u2.users_id\\nGROUP BY t.request_at\\n\\n\\nTrips =\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | Yes    | client |\\n| 10       | No     | driver |\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 |                   |\\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nKindly help in rectification of query"
                    },
                    {
                        "username": "athlchian",
                        "content": "`\nwith cancelCount as (\n    select count(id) as n1, request_at\n    from Trips\n    where status <> \"completed\"\n    and client_id in (select users_id from Users where banned = \"No\" and role = \"client\")\n    and driver_id in (select users_id from Users where banned = \"No\" and role = \"driver\")\n    group by request_at\n),\ntotalCount as (\n    select count(id) as n2, request_at\n    from Trips\n    group by request_at\n)\n\nselect totalCount.request_at as Day,\nIFNULL((cancelCount.n1 / totalCount.n2),0) as \"Cancellation Rate\"\nfrom totalCount\nleft join cancelCount\non totalCount.request_at = cancelCount.request_at\n`\n\nTest case is wrong"
                    },
                    {
                        "username": "joeybosa",
                        "content": "used CTEs to store banned users\\n\\n# banned drivers\\nwith banned_drivers as \\n(\\nselect distinct users_id\\nfrom Users\\nwhere role = \\'driver\\'\\nand banned = \\'Yes\\'\\n),\\n# banned clients\\nbanned_clients as \\n(\\nselect distinct users_id\\nfrom Users\\nwhere role = \\'client\\'\\nand banned = \\'Yes\\'\\n)\\n\\nselect request_at as Day, \\nround((sum(case status when \\'cancelled_by_driver\\' then 1 when \\'cancelled_by_client\\' then 1 else 0 end) \\n/\\ncount(*)),2) as \"Cancellation Rate\"\\nfrom Trips\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nand client_id not in (\\n    select users_id from banned_clients\\n)\\nand driver_id not in (\\n    select users_id from banned_drivers\\n)\\ngroup by 1\\n\\n"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "The leetcode answer has a bug, that it must requires the column to be called \"cancellation rate\" to pass, but when I put my couln as \"cancellation rate\", it put the rest of the code as string"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "WITH CTE AS (\\nSELECT client_id, driver_id, request_at, users_id, banned,\\nCASE WHEN status LIKE \\'cancelled%\\' THEN \\'cancelled\\' ELSE status END AS cancel_status\\nFROM Trips t LEFT JOIN Users u ON t.client_id = u.users_id OR t.driver_id = u.users_id\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\' AND driver_id != users_id AND banned != \\'Yes\\'\\nORDER BY request_at ASC\\n)\\n\\nSELECT request_at AS Day, ROUND(COUNT(CASE WHEN cancel_status = \\'cancelled\\' THEN 1 ELSE null END) / COUNT(*), 2) as Cancellation_Rate\\nFROM CTE\\nGROUP BY 1\\nORDER BY 1 ASC\\n"
                    },
                    {
                        "username": "musemen",
                        "content": "```\\n# total rides by unbanned users by day\\nwith total_rides as (SELECT t.request_at as day,\\ncount(1) as total_rides\\nfrom trips t  join \\nusers u on t.client_id = u.users_id and u.banned = \\'No\\' and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by 1),\\n\\n# cancelled rides by unbanned users by day\\ncancelled_rides as (\\nSELECT t.request_at as day,\\ncount(1) as cancelled_rides\\nfrom trips t join \\nusers u on t.client_id = u.users_id  \\nwhere t.status like \\'cancelled%\\'and u.banned = \\'No\\' and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by 1\\n),\\n\\ncombined as(select tr.day, tr.total_rides as total_rides, cr.cancelled_rides as cancelled_rides  from cancelled_rides cr\\nright join total_rides tr on cr.day = tr.day)\\n\\nselect day, case when cancelled_rides is NULL then 0\\nelse round(cancelled_rides/total_rides,2) end as \"cancellation rate\"\\nfrom combined\\n\\n```\\n\\nCan Someone help me with this, its failing 1 test case"
                    },
                    {
                        "username": "mailtopusapallip",
                        "content": "select t1.requested_at as Day ,\n        round()t2.cancel_trp_cnt/t1.cmplt_trp_cnt,2) as \"Cancellation Rate\" \n (select t.requested_at,count(1) as cmplt_trp_cnt from Trips t ,users c,users d\nwhere t.client_id =c.users_id \nand t.driver_id =d.users_id \nand t.requested_at between to_date ('2013-10-01','YYYY-MM-DD') and  to_date ('2013-10-03','YYYY-MM-DD')\nand c.banned='Yes'\nand d.banned='Yes'\nand t.status='Completed'\ngroup by t.requested_at\n)t1,\n(select t.requested_at,count(1) as cancel_trp_cnt from Trips t ,users c,users d\nwhere t.client_id =c.users_id \nand t.driver_id =d.users_id \nand t.requested_at between to_date ('2013-10-01','YYYY-MM-DD') and  to_date ('2013-10-03','YYYY-MM-DD')\nand c.banned='Yes'\nand d.banned='Yes'\nand t.status in ('cancelled_by_driver','cancelled_by_client')\ngroup by t.requested_at\n)t2\nwhere t1.requested_at=t2.requested_at\n\ncan somone check and let me know why this is not accepted .\nThis seems to be correct for me ,but not sure why run time error is coming .\nalso can someone from leetcode check and let me know ,how to check run time error .\nWhen I see error ,I will come to know what is the error and how to fix . Unfortunately leetcode is just saying run time error . which is not clear to me at all ,I am new to leetcode . Any help in this regard is highly appreciated .thank you ."
                    },
                    {
                        "username": "shellweCode",
                        "content": "Why there is a runtime error of \"Unknown column \\'t2.client_id\\' in \\'on clause\\' \" after running this line? It seems that i do not have any syntax error.\\nWith abc as (SELECT t1.request_at, COUNT(t1.id) AS \\'count\\' FROM Trips t1\\nLEFT JOIN Users ON Users.users_id = t1.client_id\\nWHERE t1.status IN (\\'cancelled_by_client\\',\\'cancelled_by_driver\\') AND Users.banned = \\'NO\\'\\nGROUP BY t1.request_at)\\nSELECT t2.request_at AS \\'Day\\', ROUND((abc.count/COUNT(t2.id)),2 )AS \\'Cancellation Rate\\' FROM Trips t2, abc\\nINNER JOIN Users u ON u.users_id = t2.client_id\\nWHERE u.banned = \\'NO\\' AND abc.request_at = t2.request_at\\nGROUP BY t2.request_at\\nORDER BY t2.request_at\\n\\nThank you for your help ><"
                    }
                ]
            },
            {
                "id": 1738443,
                "content": [
                    {
                        "username": "LAOMAITOU",
                        "content": "with ligit as (\\n    select users_id,role from Users\\n    where banned=\\'No\\' and (role=\\'driver\\' or role=\\'client\\')\\n)\\n\\nselect request_at as \"Day\", round(sum(case when status=\\'cancelled_by_driver\\' or status=\\'cancelled_by_client\\' then 1 else 0 end)/count(*),2) as \"Cancellation Rate\"\\nfrom\\n(\\n    select status,request_at from Trips\\n    where client_id in (select users_id from ligit where role=\\'client\\')\\n      and driver_id in (select users_id from ligit where role=\\'driver\\')\\n) stats\\ngroup by request_at"
                    },
                    {
                        "username": "gaurangdamley",
                        "content": "Not sure what it is not accepting my solution. only difference I see is with the header.\\n\\nwith tot as (select count(*) as total,T.request_at as Day from Trips T, Users U\\nwhere T.client_id = U.users_id\\nAND U.banned = \\'No\\'\\ngroup by T.request_at),\\ncan as (select count(*) as total,T.request_at as Day from Trips T, users U\\nwhere t.client_id = u.users_id AND U.banned = \\'No\\'\\nAND T.status <>\\'completed\\'\\ngroup by T.request_at);\\n\\nselect t.Day as day, nvl(Trunc((c.total/t.total),2),0.00) cancellation_rate from tot t, can c\\nwhere t.Day = c.Day (+)\\norder by Day;"
                    },
                    {
                        "username": "jobless_lady",
                        "content": "9/11 test cases passed\\n\\nSELECT t.request_at as Day, \\nROUND((SUM(IF(t.status like \\'cancelled%\\' and u1.banned=\\'No\\',1,0)))/(SUM(IF(u1.banned=\\'No\\',1,0))),2) as \\'Cancellation Rate\\'\\n    FROM (SELECT * from Trips \\n    WHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\') t\\n    LEFT JOIN Users u1 ON t.client_id=u1.users_id\\n    LEFT JOIN Users u2 ON t.driver_id=u2.users_id\\nGROUP BY t.request_at\\n\\n\\nTrips =\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | Yes    | client |\\n| 10       | No     | driver |\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 |                   |\\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nKindly help in rectification of query"
                    },
                    {
                        "username": "athlchian",
                        "content": "`\nwith cancelCount as (\n    select count(id) as n1, request_at\n    from Trips\n    where status <> \"completed\"\n    and client_id in (select users_id from Users where banned = \"No\" and role = \"client\")\n    and driver_id in (select users_id from Users where banned = \"No\" and role = \"driver\")\n    group by request_at\n),\ntotalCount as (\n    select count(id) as n2, request_at\n    from Trips\n    group by request_at\n)\n\nselect totalCount.request_at as Day,\nIFNULL((cancelCount.n1 / totalCount.n2),0) as \"Cancellation Rate\"\nfrom totalCount\nleft join cancelCount\non totalCount.request_at = cancelCount.request_at\n`\n\nTest case is wrong"
                    },
                    {
                        "username": "joeybosa",
                        "content": "used CTEs to store banned users\\n\\n# banned drivers\\nwith banned_drivers as \\n(\\nselect distinct users_id\\nfrom Users\\nwhere role = \\'driver\\'\\nand banned = \\'Yes\\'\\n),\\n# banned clients\\nbanned_clients as \\n(\\nselect distinct users_id\\nfrom Users\\nwhere role = \\'client\\'\\nand banned = \\'Yes\\'\\n)\\n\\nselect request_at as Day, \\nround((sum(case status when \\'cancelled_by_driver\\' then 1 when \\'cancelled_by_client\\' then 1 else 0 end) \\n/\\ncount(*)),2) as \"Cancellation Rate\"\\nfrom Trips\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nand client_id not in (\\n    select users_id from banned_clients\\n)\\nand driver_id not in (\\n    select users_id from banned_drivers\\n)\\ngroup by 1\\n\\n"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "The leetcode answer has a bug, that it must requires the column to be called \"cancellation rate\" to pass, but when I put my couln as \"cancellation rate\", it put the rest of the code as string"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "WITH CTE AS (\\nSELECT client_id, driver_id, request_at, users_id, banned,\\nCASE WHEN status LIKE \\'cancelled%\\' THEN \\'cancelled\\' ELSE status END AS cancel_status\\nFROM Trips t LEFT JOIN Users u ON t.client_id = u.users_id OR t.driver_id = u.users_id\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\' AND driver_id != users_id AND banned != \\'Yes\\'\\nORDER BY request_at ASC\\n)\\n\\nSELECT request_at AS Day, ROUND(COUNT(CASE WHEN cancel_status = \\'cancelled\\' THEN 1 ELSE null END) / COUNT(*), 2) as Cancellation_Rate\\nFROM CTE\\nGROUP BY 1\\nORDER BY 1 ASC\\n"
                    },
                    {
                        "username": "musemen",
                        "content": "```\\n# total rides by unbanned users by day\\nwith total_rides as (SELECT t.request_at as day,\\ncount(1) as total_rides\\nfrom trips t  join \\nusers u on t.client_id = u.users_id and u.banned = \\'No\\' and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by 1),\\n\\n# cancelled rides by unbanned users by day\\ncancelled_rides as (\\nSELECT t.request_at as day,\\ncount(1) as cancelled_rides\\nfrom trips t join \\nusers u on t.client_id = u.users_id  \\nwhere t.status like \\'cancelled%\\'and u.banned = \\'No\\' and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by 1\\n),\\n\\ncombined as(select tr.day, tr.total_rides as total_rides, cr.cancelled_rides as cancelled_rides  from cancelled_rides cr\\nright join total_rides tr on cr.day = tr.day)\\n\\nselect day, case when cancelled_rides is NULL then 0\\nelse round(cancelled_rides/total_rides,2) end as \"cancellation rate\"\\nfrom combined\\n\\n```\\n\\nCan Someone help me with this, its failing 1 test case"
                    },
                    {
                        "username": "mailtopusapallip",
                        "content": "select t1.requested_at as Day ,\n        round()t2.cancel_trp_cnt/t1.cmplt_trp_cnt,2) as \"Cancellation Rate\" \n (select t.requested_at,count(1) as cmplt_trp_cnt from Trips t ,users c,users d\nwhere t.client_id =c.users_id \nand t.driver_id =d.users_id \nand t.requested_at between to_date ('2013-10-01','YYYY-MM-DD') and  to_date ('2013-10-03','YYYY-MM-DD')\nand c.banned='Yes'\nand d.banned='Yes'\nand t.status='Completed'\ngroup by t.requested_at\n)t1,\n(select t.requested_at,count(1) as cancel_trp_cnt from Trips t ,users c,users d\nwhere t.client_id =c.users_id \nand t.driver_id =d.users_id \nand t.requested_at between to_date ('2013-10-01','YYYY-MM-DD') and  to_date ('2013-10-03','YYYY-MM-DD')\nand c.banned='Yes'\nand d.banned='Yes'\nand t.status in ('cancelled_by_driver','cancelled_by_client')\ngroup by t.requested_at\n)t2\nwhere t1.requested_at=t2.requested_at\n\ncan somone check and let me know why this is not accepted .\nThis seems to be correct for me ,but not sure why run time error is coming .\nalso can someone from leetcode check and let me know ,how to check run time error .\nWhen I see error ,I will come to know what is the error and how to fix . Unfortunately leetcode is just saying run time error . which is not clear to me at all ,I am new to leetcode . Any help in this regard is highly appreciated .thank you ."
                    },
                    {
                        "username": "shellweCode",
                        "content": "Why there is a runtime error of \"Unknown column \\'t2.client_id\\' in \\'on clause\\' \" after running this line? It seems that i do not have any syntax error.\\nWith abc as (SELECT t1.request_at, COUNT(t1.id) AS \\'count\\' FROM Trips t1\\nLEFT JOIN Users ON Users.users_id = t1.client_id\\nWHERE t1.status IN (\\'cancelled_by_client\\',\\'cancelled_by_driver\\') AND Users.banned = \\'NO\\'\\nGROUP BY t1.request_at)\\nSELECT t2.request_at AS \\'Day\\', ROUND((abc.count/COUNT(t2.id)),2 )AS \\'Cancellation Rate\\' FROM Trips t2, abc\\nINNER JOIN Users u ON u.users_id = t2.client_id\\nWHERE u.banned = \\'NO\\' AND abc.request_at = t2.request_at\\nGROUP BY t2.request_at\\nORDER BY t2.request_at\\n\\nThank you for your help ><"
                    }
                ]
            },
            {
                "id": 1725285,
                "content": [
                    {
                        "username": "LAOMAITOU",
                        "content": "with ligit as (\\n    select users_id,role from Users\\n    where banned=\\'No\\' and (role=\\'driver\\' or role=\\'client\\')\\n)\\n\\nselect request_at as \"Day\", round(sum(case when status=\\'cancelled_by_driver\\' or status=\\'cancelled_by_client\\' then 1 else 0 end)/count(*),2) as \"Cancellation Rate\"\\nfrom\\n(\\n    select status,request_at from Trips\\n    where client_id in (select users_id from ligit where role=\\'client\\')\\n      and driver_id in (select users_id from ligit where role=\\'driver\\')\\n) stats\\ngroup by request_at"
                    },
                    {
                        "username": "gaurangdamley",
                        "content": "Not sure what it is not accepting my solution. only difference I see is with the header.\\n\\nwith tot as (select count(*) as total,T.request_at as Day from Trips T, Users U\\nwhere T.client_id = U.users_id\\nAND U.banned = \\'No\\'\\ngroup by T.request_at),\\ncan as (select count(*) as total,T.request_at as Day from Trips T, users U\\nwhere t.client_id = u.users_id AND U.banned = \\'No\\'\\nAND T.status <>\\'completed\\'\\ngroup by T.request_at);\\n\\nselect t.Day as day, nvl(Trunc((c.total/t.total),2),0.00) cancellation_rate from tot t, can c\\nwhere t.Day = c.Day (+)\\norder by Day;"
                    },
                    {
                        "username": "jobless_lady",
                        "content": "9/11 test cases passed\\n\\nSELECT t.request_at as Day, \\nROUND((SUM(IF(t.status like \\'cancelled%\\' and u1.banned=\\'No\\',1,0)))/(SUM(IF(u1.banned=\\'No\\',1,0))),2) as \\'Cancellation Rate\\'\\n    FROM (SELECT * from Trips \\n    WHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\') t\\n    LEFT JOIN Users u1 ON t.client_id=u1.users_id\\n    LEFT JOIN Users u2 ON t.driver_id=u2.users_id\\nGROUP BY t.request_at\\n\\n\\nTrips =\\n| id   | client_id | driver_id | city_id | status    | request_at |\\n| ---- | --------- | --------- | ------- | --------- | ---------- |\\n| 1111 | 1         | 10        | 1       | completed | 2013-10-01 |\\nUsers =\\n| users_id | banned | role   |\\n| -------- | ------ | ------ |\\n| 1        | Yes    | client |\\n| 10       | No     | driver |\\n\\nOutput\\n| Day        | Cancellation Rate |\\n| ---------- | ----------------- |\\n| 2013-10-01 |                   |\\nExpected\\n| Day | Cancellation Rate |\\n| --- | ----------------- |\\n\\nKindly help in rectification of query"
                    },
                    {
                        "username": "athlchian",
                        "content": "`\nwith cancelCount as (\n    select count(id) as n1, request_at\n    from Trips\n    where status <> \"completed\"\n    and client_id in (select users_id from Users where banned = \"No\" and role = \"client\")\n    and driver_id in (select users_id from Users where banned = \"No\" and role = \"driver\")\n    group by request_at\n),\ntotalCount as (\n    select count(id) as n2, request_at\n    from Trips\n    group by request_at\n)\n\nselect totalCount.request_at as Day,\nIFNULL((cancelCount.n1 / totalCount.n2),0) as \"Cancellation Rate\"\nfrom totalCount\nleft join cancelCount\non totalCount.request_at = cancelCount.request_at\n`\n\nTest case is wrong"
                    },
                    {
                        "username": "joeybosa",
                        "content": "used CTEs to store banned users\\n\\n# banned drivers\\nwith banned_drivers as \\n(\\nselect distinct users_id\\nfrom Users\\nwhere role = \\'driver\\'\\nand banned = \\'Yes\\'\\n),\\n# banned clients\\nbanned_clients as \\n(\\nselect distinct users_id\\nfrom Users\\nwhere role = \\'client\\'\\nand banned = \\'Yes\\'\\n)\\n\\nselect request_at as Day, \\nround((sum(case status when \\'cancelled_by_driver\\' then 1 when \\'cancelled_by_client\\' then 1 else 0 end) \\n/\\ncount(*)),2) as \"Cancellation Rate\"\\nfrom Trips\\nwhere request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\nand client_id not in (\\n    select users_id from banned_clients\\n)\\nand driver_id not in (\\n    select users_id from banned_drivers\\n)\\ngroup by 1\\n\\n"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "The leetcode answer has a bug, that it must requires the column to be called \"cancellation rate\" to pass, but when I put my couln as \"cancellation rate\", it put the rest of the code as string"
                    },
                    {
                        "username": "wutianwuye860",
                        "content": "WITH CTE AS (\\nSELECT client_id, driver_id, request_at, users_id, banned,\\nCASE WHEN status LIKE \\'cancelled%\\' THEN \\'cancelled\\' ELSE status END AS cancel_status\\nFROM Trips t LEFT JOIN Users u ON t.client_id = u.users_id OR t.driver_id = u.users_id\\nWHERE request_at BETWEEN \\'2013-10-01\\' AND \\'2013-10-03\\' AND driver_id != users_id AND banned != \\'Yes\\'\\nORDER BY request_at ASC\\n)\\n\\nSELECT request_at AS Day, ROUND(COUNT(CASE WHEN cancel_status = \\'cancelled\\' THEN 1 ELSE null END) / COUNT(*), 2) as Cancellation_Rate\\nFROM CTE\\nGROUP BY 1\\nORDER BY 1 ASC\\n"
                    },
                    {
                        "username": "musemen",
                        "content": "```\\n# total rides by unbanned users by day\\nwith total_rides as (SELECT t.request_at as day,\\ncount(1) as total_rides\\nfrom trips t  join \\nusers u on t.client_id = u.users_id and u.banned = \\'No\\' and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by 1),\\n\\n# cancelled rides by unbanned users by day\\ncancelled_rides as (\\nSELECT t.request_at as day,\\ncount(1) as cancelled_rides\\nfrom trips t join \\nusers u on t.client_id = u.users_id  \\nwhere t.status like \\'cancelled%\\'and u.banned = \\'No\\' and request_at between \\'2013-10-01\\' and \\'2013-10-03\\'\\ngroup by 1\\n),\\n\\ncombined as(select tr.day, tr.total_rides as total_rides, cr.cancelled_rides as cancelled_rides  from cancelled_rides cr\\nright join total_rides tr on cr.day = tr.day)\\n\\nselect day, case when cancelled_rides is NULL then 0\\nelse round(cancelled_rides/total_rides,2) end as \"cancellation rate\"\\nfrom combined\\n\\n```\\n\\nCan Someone help me with this, its failing 1 test case"
                    },
                    {
                        "username": "mailtopusapallip",
                        "content": "select t1.requested_at as Day ,\n        round()t2.cancel_trp_cnt/t1.cmplt_trp_cnt,2) as \"Cancellation Rate\" \n (select t.requested_at,count(1) as cmplt_trp_cnt from Trips t ,users c,users d\nwhere t.client_id =c.users_id \nand t.driver_id =d.users_id \nand t.requested_at between to_date ('2013-10-01','YYYY-MM-DD') and  to_date ('2013-10-03','YYYY-MM-DD')\nand c.banned='Yes'\nand d.banned='Yes'\nand t.status='Completed'\ngroup by t.requested_at\n)t1,\n(select t.requested_at,count(1) as cancel_trp_cnt from Trips t ,users c,users d\nwhere t.client_id =c.users_id \nand t.driver_id =d.users_id \nand t.requested_at between to_date ('2013-10-01','YYYY-MM-DD') and  to_date ('2013-10-03','YYYY-MM-DD')\nand c.banned='Yes'\nand d.banned='Yes'\nand t.status in ('cancelled_by_driver','cancelled_by_client')\ngroup by t.requested_at\n)t2\nwhere t1.requested_at=t2.requested_at\n\ncan somone check and let me know why this is not accepted .\nThis seems to be correct for me ,but not sure why run time error is coming .\nalso can someone from leetcode check and let me know ,how to check run time error .\nWhen I see error ,I will come to know what is the error and how to fix . Unfortunately leetcode is just saying run time error . which is not clear to me at all ,I am new to leetcode . Any help in this regard is highly appreciated .thank you ."
                    },
                    {
                        "username": "shellweCode",
                        "content": "Why there is a runtime error of \"Unknown column \\'t2.client_id\\' in \\'on clause\\' \" after running this line? It seems that i do not have any syntax error.\\nWith abc as (SELECT t1.request_at, COUNT(t1.id) AS \\'count\\' FROM Trips t1\\nLEFT JOIN Users ON Users.users_id = t1.client_id\\nWHERE t1.status IN (\\'cancelled_by_client\\',\\'cancelled_by_driver\\') AND Users.banned = \\'NO\\'\\nGROUP BY t1.request_at)\\nSELECT t2.request_at AS \\'Day\\', ROUND((abc.count/COUNT(t2.id)),2 )AS \\'Cancellation Rate\\' FROM Trips t2, abc\\nINNER JOIN Users u ON u.users_id = t2.client_id\\nWHERE u.banned = \\'NO\\' AND abc.request_at = t2.request_at\\nGROUP BY t2.request_at\\nORDER BY t2.request_at\\n\\nThank you for your help ><"
                    }
                ]
            }
        ]
    },
    {
        "title": "Design Hit Counter",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1564866,
                "content": [
                    {
                        "username": "kk262777",
                        "content": "Since this is a design question, we need to ask interviewer how this class is going to be used? \\nA working code is not the answer to this question, but how you adjust your program to meet different use cases.\\n\\nConsider: There are 1000 frequent hit() followed by 1 getHits(). If we only do removal in getHits() function, it will be very time consuming. For me, I prefer to do removal in both hit() and getHits(), so that the program avoids system lag in this case.\\nThis is important when you design a time-critical system."
                    },
                    {
                        "username": "roish",
                        "content": "http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/\\n\\nBasic ideas:\\n* Rolling Counter\\n* Staged Aggregator\\n* Partition"
                    },
                    {
                        "username": "nightcatzhou",
                        "content": "The follow-up is easy, but if I am the interviewer, I may ask how will you consider the multi-thread solution. \\nOne more thing is that, when it is in a distributed environment?\\nFortunately, I am still seeking a job and it seems that I will never find a job. So I won't be the interviewer. Good luck man."
                    },
                    {
                        "username": "trancememes",
                        "content": "what on earth is this question asking ? "
                    },
                    {
                        "username": "archersmind",
                        "content": "Can anyone explain why `counter.getHits(301)` return 3 in the example? I thought it was 4.\\n\\nThank you guys."
                    },
                    {
                        "username": "principoshi",
                        "content": "what [@atul rokade](/atul_rokade) said, but simpler:\\n\\nYou will disregard the call made at hitCounter.hit(1) because the past 300 seconds will be 301 - 300 thus excluding that first call."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "as timestamp is always increasing hence u will never get hit  call smaller than gethits call so u have to remove counts older than 300sec even in gethits call"
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "I really don\\'t understand what this problem is asking.\\n\\nCan someone explain the example test-case and tell me what they are saying by \"5 seconds?\""
                    },
                    {
                        "username": "vartikap06",
                        "content": "poorly worded"
                    },
                    {
                        "username": "rcwors02",
                        "content": "In a distributed system you wouldn\\'t be able to guarantee that the timestamps are coming in order. So for this problem, assuming all the timestamps come in order is not realistic."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "but it was clearly mentioned in constraints \\nIf TCP communication is used then all entries will be guaranteed to be in order but for UDP based system it may or may not be in order"
                    },
                    {
                        "username": "luscioustaxing",
                        "content": "Here\\'s how to scale up this problem to handle high traffic and concurrency:\\nhttp://blog.gainlo.co/index.php/2016/09/12/dropbox-interview-design-hit-counter/\\nhttps://www.geeksforgeeks.org/design-a-hit-counter/\\n\\nThe main approaches from simplest to most scalable are:\\n1. Simple table and SQL query O(N)\\n2. LinkedList\\n3. Circular buffer \\n4. Circular buffer with locks\\n5. Distributed circular buffer - partition the user set by the hash of user id and have circular buffer for each partition. The total count will be the sum of each of the circular buffers\\n\\nA distributed circular buffer (#5)  could be a scalable approach to handle a high volume of user visits\\n\\n\\n"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "u can use simple heap of size 299 and separate var for current timestamp, as u may get mult hit for same timestamp but once timestamp moved ahead u can add entry to heap and maintain sum of heap in separate var and every time u remove node from heap just adjust count"
                    },
                    {
                        "username": "wei69",
                        "content": "it seems that the getHit function must only accept an input that is greater than or equal to the timestamp of the last hit. As most of the solutions only maintains the hits of last 5 minutes, it will generate wrong answer if you call the getHit() function with a smaller timestamp."
                    },
                    {
                        "username": "Chang4Tech",
                        "content": " \"you may assume that calls are being made to the system in chronological order\""
                    }
                ]
            },
            {
                "id": 1565445,
                "content": [
                    {
                        "username": "kk262777",
                        "content": "Since this is a design question, we need to ask interviewer how this class is going to be used? \\nA working code is not the answer to this question, but how you adjust your program to meet different use cases.\\n\\nConsider: There are 1000 frequent hit() followed by 1 getHits(). If we only do removal in getHits() function, it will be very time consuming. For me, I prefer to do removal in both hit() and getHits(), so that the program avoids system lag in this case.\\nThis is important when you design a time-critical system."
                    },
                    {
                        "username": "roish",
                        "content": "http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/\\n\\nBasic ideas:\\n* Rolling Counter\\n* Staged Aggregator\\n* Partition"
                    },
                    {
                        "username": "nightcatzhou",
                        "content": "The follow-up is easy, but if I am the interviewer, I may ask how will you consider the multi-thread solution. \\nOne more thing is that, when it is in a distributed environment?\\nFortunately, I am still seeking a job and it seems that I will never find a job. So I won't be the interviewer. Good luck man."
                    },
                    {
                        "username": "trancememes",
                        "content": "what on earth is this question asking ? "
                    },
                    {
                        "username": "archersmind",
                        "content": "Can anyone explain why `counter.getHits(301)` return 3 in the example? I thought it was 4.\\n\\nThank you guys."
                    },
                    {
                        "username": "principoshi",
                        "content": "what [@atul rokade](/atul_rokade) said, but simpler:\\n\\nYou will disregard the call made at hitCounter.hit(1) because the past 300 seconds will be 301 - 300 thus excluding that first call."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "as timestamp is always increasing hence u will never get hit  call smaller than gethits call so u have to remove counts older than 300sec even in gethits call"
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "I really don\\'t understand what this problem is asking.\\n\\nCan someone explain the example test-case and tell me what they are saying by \"5 seconds?\""
                    },
                    {
                        "username": "vartikap06",
                        "content": "poorly worded"
                    },
                    {
                        "username": "rcwors02",
                        "content": "In a distributed system you wouldn\\'t be able to guarantee that the timestamps are coming in order. So for this problem, assuming all the timestamps come in order is not realistic."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "but it was clearly mentioned in constraints \\nIf TCP communication is used then all entries will be guaranteed to be in order but for UDP based system it may or may not be in order"
                    },
                    {
                        "username": "luscioustaxing",
                        "content": "Here\\'s how to scale up this problem to handle high traffic and concurrency:\\nhttp://blog.gainlo.co/index.php/2016/09/12/dropbox-interview-design-hit-counter/\\nhttps://www.geeksforgeeks.org/design-a-hit-counter/\\n\\nThe main approaches from simplest to most scalable are:\\n1. Simple table and SQL query O(N)\\n2. LinkedList\\n3. Circular buffer \\n4. Circular buffer with locks\\n5. Distributed circular buffer - partition the user set by the hash of user id and have circular buffer for each partition. The total count will be the sum of each of the circular buffers\\n\\nA distributed circular buffer (#5)  could be a scalable approach to handle a high volume of user visits\\n\\n\\n"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "u can use simple heap of size 299 and separate var for current timestamp, as u may get mult hit for same timestamp but once timestamp moved ahead u can add entry to heap and maintain sum of heap in separate var and every time u remove node from heap just adjust count"
                    },
                    {
                        "username": "wei69",
                        "content": "it seems that the getHit function must only accept an input that is greater than or equal to the timestamp of the last hit. As most of the solutions only maintains the hits of last 5 minutes, it will generate wrong answer if you call the getHit() function with a smaller timestamp."
                    },
                    {
                        "username": "Chang4Tech",
                        "content": " \"you may assume that calls are being made to the system in chronological order\""
                    }
                ]
            },
            {
                "id": 1566786,
                "content": [
                    {
                        "username": "kk262777",
                        "content": "Since this is a design question, we need to ask interviewer how this class is going to be used? \\nA working code is not the answer to this question, but how you adjust your program to meet different use cases.\\n\\nConsider: There are 1000 frequent hit() followed by 1 getHits(). If we only do removal in getHits() function, it will be very time consuming. For me, I prefer to do removal in both hit() and getHits(), so that the program avoids system lag in this case.\\nThis is important when you design a time-critical system."
                    },
                    {
                        "username": "roish",
                        "content": "http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/\\n\\nBasic ideas:\\n* Rolling Counter\\n* Staged Aggregator\\n* Partition"
                    },
                    {
                        "username": "nightcatzhou",
                        "content": "The follow-up is easy, but if I am the interviewer, I may ask how will you consider the multi-thread solution. \\nOne more thing is that, when it is in a distributed environment?\\nFortunately, I am still seeking a job and it seems that I will never find a job. So I won't be the interviewer. Good luck man."
                    },
                    {
                        "username": "trancememes",
                        "content": "what on earth is this question asking ? "
                    },
                    {
                        "username": "archersmind",
                        "content": "Can anyone explain why `counter.getHits(301)` return 3 in the example? I thought it was 4.\\n\\nThank you guys."
                    },
                    {
                        "username": "principoshi",
                        "content": "what [@atul rokade](/atul_rokade) said, but simpler:\\n\\nYou will disregard the call made at hitCounter.hit(1) because the past 300 seconds will be 301 - 300 thus excluding that first call."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "as timestamp is always increasing hence u will never get hit  call smaller than gethits call so u have to remove counts older than 300sec even in gethits call"
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "I really don\\'t understand what this problem is asking.\\n\\nCan someone explain the example test-case and tell me what they are saying by \"5 seconds?\""
                    },
                    {
                        "username": "vartikap06",
                        "content": "poorly worded"
                    },
                    {
                        "username": "rcwors02",
                        "content": "In a distributed system you wouldn\\'t be able to guarantee that the timestamps are coming in order. So for this problem, assuming all the timestamps come in order is not realistic."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "but it was clearly mentioned in constraints \\nIf TCP communication is used then all entries will be guaranteed to be in order but for UDP based system it may or may not be in order"
                    },
                    {
                        "username": "luscioustaxing",
                        "content": "Here\\'s how to scale up this problem to handle high traffic and concurrency:\\nhttp://blog.gainlo.co/index.php/2016/09/12/dropbox-interview-design-hit-counter/\\nhttps://www.geeksforgeeks.org/design-a-hit-counter/\\n\\nThe main approaches from simplest to most scalable are:\\n1. Simple table and SQL query O(N)\\n2. LinkedList\\n3. Circular buffer \\n4. Circular buffer with locks\\n5. Distributed circular buffer - partition the user set by the hash of user id and have circular buffer for each partition. The total count will be the sum of each of the circular buffers\\n\\nA distributed circular buffer (#5)  could be a scalable approach to handle a high volume of user visits\\n\\n\\n"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "u can use simple heap of size 299 and separate var for current timestamp, as u may get mult hit for same timestamp but once timestamp moved ahead u can add entry to heap and maintain sum of heap in separate var and every time u remove node from heap just adjust count"
                    },
                    {
                        "username": "wei69",
                        "content": "it seems that the getHit function must only accept an input that is greater than or equal to the timestamp of the last hit. As most of the solutions only maintains the hits of last 5 minutes, it will generate wrong answer if you call the getHit() function with a smaller timestamp."
                    },
                    {
                        "username": "Chang4Tech",
                        "content": " \"you may assume that calls are being made to the system in chronological order\""
                    }
                ]
            },
            {
                "id": 1738694,
                "content": [
                    {
                        "username": "kk262777",
                        "content": "Since this is a design question, we need to ask interviewer how this class is going to be used? \\nA working code is not the answer to this question, but how you adjust your program to meet different use cases.\\n\\nConsider: There are 1000 frequent hit() followed by 1 getHits(). If we only do removal in getHits() function, it will be very time consuming. For me, I prefer to do removal in both hit() and getHits(), so that the program avoids system lag in this case.\\nThis is important when you design a time-critical system."
                    },
                    {
                        "username": "roish",
                        "content": "http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/\\n\\nBasic ideas:\\n* Rolling Counter\\n* Staged Aggregator\\n* Partition"
                    },
                    {
                        "username": "nightcatzhou",
                        "content": "The follow-up is easy, but if I am the interviewer, I may ask how will you consider the multi-thread solution. \\nOne more thing is that, when it is in a distributed environment?\\nFortunately, I am still seeking a job and it seems that I will never find a job. So I won't be the interviewer. Good luck man."
                    },
                    {
                        "username": "trancememes",
                        "content": "what on earth is this question asking ? "
                    },
                    {
                        "username": "archersmind",
                        "content": "Can anyone explain why `counter.getHits(301)` return 3 in the example? I thought it was 4.\\n\\nThank you guys."
                    },
                    {
                        "username": "principoshi",
                        "content": "what [@atul rokade](/atul_rokade) said, but simpler:\\n\\nYou will disregard the call made at hitCounter.hit(1) because the past 300 seconds will be 301 - 300 thus excluding that first call."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "as timestamp is always increasing hence u will never get hit  call smaller than gethits call so u have to remove counts older than 300sec even in gethits call"
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "I really don\\'t understand what this problem is asking.\\n\\nCan someone explain the example test-case and tell me what they are saying by \"5 seconds?\""
                    },
                    {
                        "username": "vartikap06",
                        "content": "poorly worded"
                    },
                    {
                        "username": "rcwors02",
                        "content": "In a distributed system you wouldn\\'t be able to guarantee that the timestamps are coming in order. So for this problem, assuming all the timestamps come in order is not realistic."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "but it was clearly mentioned in constraints \\nIf TCP communication is used then all entries will be guaranteed to be in order but for UDP based system it may or may not be in order"
                    },
                    {
                        "username": "luscioustaxing",
                        "content": "Here\\'s how to scale up this problem to handle high traffic and concurrency:\\nhttp://blog.gainlo.co/index.php/2016/09/12/dropbox-interview-design-hit-counter/\\nhttps://www.geeksforgeeks.org/design-a-hit-counter/\\n\\nThe main approaches from simplest to most scalable are:\\n1. Simple table and SQL query O(N)\\n2. LinkedList\\n3. Circular buffer \\n4. Circular buffer with locks\\n5. Distributed circular buffer - partition the user set by the hash of user id and have circular buffer for each partition. The total count will be the sum of each of the circular buffers\\n\\nA distributed circular buffer (#5)  could be a scalable approach to handle a high volume of user visits\\n\\n\\n"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "u can use simple heap of size 299 and separate var for current timestamp, as u may get mult hit for same timestamp but once timestamp moved ahead u can add entry to heap and maintain sum of heap in separate var and every time u remove node from heap just adjust count"
                    },
                    {
                        "username": "wei69",
                        "content": "it seems that the getHit function must only accept an input that is greater than or equal to the timestamp of the last hit. As most of the solutions only maintains the hits of last 5 minutes, it will generate wrong answer if you call the getHit() function with a smaller timestamp."
                    },
                    {
                        "username": "Chang4Tech",
                        "content": " \"you may assume that calls are being made to the system in chronological order\""
                    }
                ]
            },
            {
                "id": 1574354,
                "content": [
                    {
                        "username": "kk262777",
                        "content": "Since this is a design question, we need to ask interviewer how this class is going to be used? \\nA working code is not the answer to this question, but how you adjust your program to meet different use cases.\\n\\nConsider: There are 1000 frequent hit() followed by 1 getHits(). If we only do removal in getHits() function, it will be very time consuming. For me, I prefer to do removal in both hit() and getHits(), so that the program avoids system lag in this case.\\nThis is important when you design a time-critical system."
                    },
                    {
                        "username": "roish",
                        "content": "http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/\\n\\nBasic ideas:\\n* Rolling Counter\\n* Staged Aggregator\\n* Partition"
                    },
                    {
                        "username": "nightcatzhou",
                        "content": "The follow-up is easy, but if I am the interviewer, I may ask how will you consider the multi-thread solution. \\nOne more thing is that, when it is in a distributed environment?\\nFortunately, I am still seeking a job and it seems that I will never find a job. So I won't be the interviewer. Good luck man."
                    },
                    {
                        "username": "trancememes",
                        "content": "what on earth is this question asking ? "
                    },
                    {
                        "username": "archersmind",
                        "content": "Can anyone explain why `counter.getHits(301)` return 3 in the example? I thought it was 4.\\n\\nThank you guys."
                    },
                    {
                        "username": "principoshi",
                        "content": "what [@atul rokade](/atul_rokade) said, but simpler:\\n\\nYou will disregard the call made at hitCounter.hit(1) because the past 300 seconds will be 301 - 300 thus excluding that first call."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "as timestamp is always increasing hence u will never get hit  call smaller than gethits call so u have to remove counts older than 300sec even in gethits call"
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "I really don\\'t understand what this problem is asking.\\n\\nCan someone explain the example test-case and tell me what they are saying by \"5 seconds?\""
                    },
                    {
                        "username": "vartikap06",
                        "content": "poorly worded"
                    },
                    {
                        "username": "rcwors02",
                        "content": "In a distributed system you wouldn\\'t be able to guarantee that the timestamps are coming in order. So for this problem, assuming all the timestamps come in order is not realistic."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "but it was clearly mentioned in constraints \\nIf TCP communication is used then all entries will be guaranteed to be in order but for UDP based system it may or may not be in order"
                    },
                    {
                        "username": "luscioustaxing",
                        "content": "Here\\'s how to scale up this problem to handle high traffic and concurrency:\\nhttp://blog.gainlo.co/index.php/2016/09/12/dropbox-interview-design-hit-counter/\\nhttps://www.geeksforgeeks.org/design-a-hit-counter/\\n\\nThe main approaches from simplest to most scalable are:\\n1. Simple table and SQL query O(N)\\n2. LinkedList\\n3. Circular buffer \\n4. Circular buffer with locks\\n5. Distributed circular buffer - partition the user set by the hash of user id and have circular buffer for each partition. The total count will be the sum of each of the circular buffers\\n\\nA distributed circular buffer (#5)  could be a scalable approach to handle a high volume of user visits\\n\\n\\n"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "u can use simple heap of size 299 and separate var for current timestamp, as u may get mult hit for same timestamp but once timestamp moved ahead u can add entry to heap and maintain sum of heap in separate var and every time u remove node from heap just adjust count"
                    },
                    {
                        "username": "wei69",
                        "content": "it seems that the getHit function must only accept an input that is greater than or equal to the timestamp of the last hit. As most of the solutions only maintains the hits of last 5 minutes, it will generate wrong answer if you call the getHit() function with a smaller timestamp."
                    },
                    {
                        "username": "Chang4Tech",
                        "content": " \"you may assume that calls are being made to the system in chronological order\""
                    }
                ]
            },
            {
                "id": 1569248,
                "content": [
                    {
                        "username": "kk262777",
                        "content": "Since this is a design question, we need to ask interviewer how this class is going to be used? \\nA working code is not the answer to this question, but how you adjust your program to meet different use cases.\\n\\nConsider: There are 1000 frequent hit() followed by 1 getHits(). If we only do removal in getHits() function, it will be very time consuming. For me, I prefer to do removal in both hit() and getHits(), so that the program avoids system lag in this case.\\nThis is important when you design a time-critical system."
                    },
                    {
                        "username": "roish",
                        "content": "http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/\\n\\nBasic ideas:\\n* Rolling Counter\\n* Staged Aggregator\\n* Partition"
                    },
                    {
                        "username": "nightcatzhou",
                        "content": "The follow-up is easy, but if I am the interviewer, I may ask how will you consider the multi-thread solution. \\nOne more thing is that, when it is in a distributed environment?\\nFortunately, I am still seeking a job and it seems that I will never find a job. So I won't be the interviewer. Good luck man."
                    },
                    {
                        "username": "trancememes",
                        "content": "what on earth is this question asking ? "
                    },
                    {
                        "username": "archersmind",
                        "content": "Can anyone explain why `counter.getHits(301)` return 3 in the example? I thought it was 4.\\n\\nThank you guys."
                    },
                    {
                        "username": "principoshi",
                        "content": "what [@atul rokade](/atul_rokade) said, but simpler:\\n\\nYou will disregard the call made at hitCounter.hit(1) because the past 300 seconds will be 301 - 300 thus excluding that first call."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "as timestamp is always increasing hence u will never get hit  call smaller than gethits call so u have to remove counts older than 300sec even in gethits call"
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "I really don\\'t understand what this problem is asking.\\n\\nCan someone explain the example test-case and tell me what they are saying by \"5 seconds?\""
                    },
                    {
                        "username": "vartikap06",
                        "content": "poorly worded"
                    },
                    {
                        "username": "rcwors02",
                        "content": "In a distributed system you wouldn\\'t be able to guarantee that the timestamps are coming in order. So for this problem, assuming all the timestamps come in order is not realistic."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "but it was clearly mentioned in constraints \\nIf TCP communication is used then all entries will be guaranteed to be in order but for UDP based system it may or may not be in order"
                    },
                    {
                        "username": "luscioustaxing",
                        "content": "Here\\'s how to scale up this problem to handle high traffic and concurrency:\\nhttp://blog.gainlo.co/index.php/2016/09/12/dropbox-interview-design-hit-counter/\\nhttps://www.geeksforgeeks.org/design-a-hit-counter/\\n\\nThe main approaches from simplest to most scalable are:\\n1. Simple table and SQL query O(N)\\n2. LinkedList\\n3. Circular buffer \\n4. Circular buffer with locks\\n5. Distributed circular buffer - partition the user set by the hash of user id and have circular buffer for each partition. The total count will be the sum of each of the circular buffers\\n\\nA distributed circular buffer (#5)  could be a scalable approach to handle a high volume of user visits\\n\\n\\n"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "u can use simple heap of size 299 and separate var for current timestamp, as u may get mult hit for same timestamp but once timestamp moved ahead u can add entry to heap and maintain sum of heap in separate var and every time u remove node from heap just adjust count"
                    },
                    {
                        "username": "wei69",
                        "content": "it seems that the getHit function must only accept an input that is greater than or equal to the timestamp of the last hit. As most of the solutions only maintains the hits of last 5 minutes, it will generate wrong answer if you call the getHit() function with a smaller timestamp."
                    },
                    {
                        "username": "Chang4Tech",
                        "content": " \"you may assume that calls are being made to the system in chronological order\""
                    }
                ]
            },
            {
                "id": 1864073,
                "content": [
                    {
                        "username": "kk262777",
                        "content": "Since this is a design question, we need to ask interviewer how this class is going to be used? \\nA working code is not the answer to this question, but how you adjust your program to meet different use cases.\\n\\nConsider: There are 1000 frequent hit() followed by 1 getHits(). If we only do removal in getHits() function, it will be very time consuming. For me, I prefer to do removal in both hit() and getHits(), so that the program avoids system lag in this case.\\nThis is important when you design a time-critical system."
                    },
                    {
                        "username": "roish",
                        "content": "http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/\\n\\nBasic ideas:\\n* Rolling Counter\\n* Staged Aggregator\\n* Partition"
                    },
                    {
                        "username": "nightcatzhou",
                        "content": "The follow-up is easy, but if I am the interviewer, I may ask how will you consider the multi-thread solution. \\nOne more thing is that, when it is in a distributed environment?\\nFortunately, I am still seeking a job and it seems that I will never find a job. So I won't be the interviewer. Good luck man."
                    },
                    {
                        "username": "trancememes",
                        "content": "what on earth is this question asking ? "
                    },
                    {
                        "username": "archersmind",
                        "content": "Can anyone explain why `counter.getHits(301)` return 3 in the example? I thought it was 4.\\n\\nThank you guys."
                    },
                    {
                        "username": "principoshi",
                        "content": "what [@atul rokade](/atul_rokade) said, but simpler:\\n\\nYou will disregard the call made at hitCounter.hit(1) because the past 300 seconds will be 301 - 300 thus excluding that first call."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "as timestamp is always increasing hence u will never get hit  call smaller than gethits call so u have to remove counts older than 300sec even in gethits call"
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "I really don\\'t understand what this problem is asking.\\n\\nCan someone explain the example test-case and tell me what they are saying by \"5 seconds?\""
                    },
                    {
                        "username": "vartikap06",
                        "content": "poorly worded"
                    },
                    {
                        "username": "rcwors02",
                        "content": "In a distributed system you wouldn\\'t be able to guarantee that the timestamps are coming in order. So for this problem, assuming all the timestamps come in order is not realistic."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "but it was clearly mentioned in constraints \\nIf TCP communication is used then all entries will be guaranteed to be in order but for UDP based system it may or may not be in order"
                    },
                    {
                        "username": "luscioustaxing",
                        "content": "Here\\'s how to scale up this problem to handle high traffic and concurrency:\\nhttp://blog.gainlo.co/index.php/2016/09/12/dropbox-interview-design-hit-counter/\\nhttps://www.geeksforgeeks.org/design-a-hit-counter/\\n\\nThe main approaches from simplest to most scalable are:\\n1. Simple table and SQL query O(N)\\n2. LinkedList\\n3. Circular buffer \\n4. Circular buffer with locks\\n5. Distributed circular buffer - partition the user set by the hash of user id and have circular buffer for each partition. The total count will be the sum of each of the circular buffers\\n\\nA distributed circular buffer (#5)  could be a scalable approach to handle a high volume of user visits\\n\\n\\n"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "u can use simple heap of size 299 and separate var for current timestamp, as u may get mult hit for same timestamp but once timestamp moved ahead u can add entry to heap and maintain sum of heap in separate var and every time u remove node from heap just adjust count"
                    },
                    {
                        "username": "wei69",
                        "content": "it seems that the getHit function must only accept an input that is greater than or equal to the timestamp of the last hit. As most of the solutions only maintains the hits of last 5 minutes, it will generate wrong answer if you call the getHit() function with a smaller timestamp."
                    },
                    {
                        "username": "Chang4Tech",
                        "content": " \"you may assume that calls are being made to the system in chronological order\""
                    }
                ]
            },
            {
                "id": 1712320,
                "content": [
                    {
                        "username": "kk262777",
                        "content": "Since this is a design question, we need to ask interviewer how this class is going to be used? \\nA working code is not the answer to this question, but how you adjust your program to meet different use cases.\\n\\nConsider: There are 1000 frequent hit() followed by 1 getHits(). If we only do removal in getHits() function, it will be very time consuming. For me, I prefer to do removal in both hit() and getHits(), so that the program avoids system lag in this case.\\nThis is important when you design a time-critical system."
                    },
                    {
                        "username": "roish",
                        "content": "http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/\\n\\nBasic ideas:\\n* Rolling Counter\\n* Staged Aggregator\\n* Partition"
                    },
                    {
                        "username": "nightcatzhou",
                        "content": "The follow-up is easy, but if I am the interviewer, I may ask how will you consider the multi-thread solution. \\nOne more thing is that, when it is in a distributed environment?\\nFortunately, I am still seeking a job and it seems that I will never find a job. So I won't be the interviewer. Good luck man."
                    },
                    {
                        "username": "trancememes",
                        "content": "what on earth is this question asking ? "
                    },
                    {
                        "username": "archersmind",
                        "content": "Can anyone explain why `counter.getHits(301)` return 3 in the example? I thought it was 4.\\n\\nThank you guys."
                    },
                    {
                        "username": "principoshi",
                        "content": "what [@atul rokade](/atul_rokade) said, but simpler:\\n\\nYou will disregard the call made at hitCounter.hit(1) because the past 300 seconds will be 301 - 300 thus excluding that first call."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "as timestamp is always increasing hence u will never get hit  call smaller than gethits call so u have to remove counts older than 300sec even in gethits call"
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "I really don\\'t understand what this problem is asking.\\n\\nCan someone explain the example test-case and tell me what they are saying by \"5 seconds?\""
                    },
                    {
                        "username": "vartikap06",
                        "content": "poorly worded"
                    },
                    {
                        "username": "rcwors02",
                        "content": "In a distributed system you wouldn\\'t be able to guarantee that the timestamps are coming in order. So for this problem, assuming all the timestamps come in order is not realistic."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "but it was clearly mentioned in constraints \\nIf TCP communication is used then all entries will be guaranteed to be in order but for UDP based system it may or may not be in order"
                    },
                    {
                        "username": "luscioustaxing",
                        "content": "Here\\'s how to scale up this problem to handle high traffic and concurrency:\\nhttp://blog.gainlo.co/index.php/2016/09/12/dropbox-interview-design-hit-counter/\\nhttps://www.geeksforgeeks.org/design-a-hit-counter/\\n\\nThe main approaches from simplest to most scalable are:\\n1. Simple table and SQL query O(N)\\n2. LinkedList\\n3. Circular buffer \\n4. Circular buffer with locks\\n5. Distributed circular buffer - partition the user set by the hash of user id and have circular buffer for each partition. The total count will be the sum of each of the circular buffers\\n\\nA distributed circular buffer (#5)  could be a scalable approach to handle a high volume of user visits\\n\\n\\n"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "u can use simple heap of size 299 and separate var for current timestamp, as u may get mult hit for same timestamp but once timestamp moved ahead u can add entry to heap and maintain sum of heap in separate var and every time u remove node from heap just adjust count"
                    },
                    {
                        "username": "wei69",
                        "content": "it seems that the getHit function must only accept an input that is greater than or equal to the timestamp of the last hit. As most of the solutions only maintains the hits of last 5 minutes, it will generate wrong answer if you call the getHit() function with a smaller timestamp."
                    },
                    {
                        "username": "Chang4Tech",
                        "content": " \"you may assume that calls are being made to the system in chronological order\""
                    }
                ]
            },
            {
                "id": 1573256,
                "content": [
                    {
                        "username": "kk262777",
                        "content": "Since this is a design question, we need to ask interviewer how this class is going to be used? \\nA working code is not the answer to this question, but how you adjust your program to meet different use cases.\\n\\nConsider: There are 1000 frequent hit() followed by 1 getHits(). If we only do removal in getHits() function, it will be very time consuming. For me, I prefer to do removal in both hit() and getHits(), so that the program avoids system lag in this case.\\nThis is important when you design a time-critical system."
                    },
                    {
                        "username": "roish",
                        "content": "http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/\\n\\nBasic ideas:\\n* Rolling Counter\\n* Staged Aggregator\\n* Partition"
                    },
                    {
                        "username": "nightcatzhou",
                        "content": "The follow-up is easy, but if I am the interviewer, I may ask how will you consider the multi-thread solution. \\nOne more thing is that, when it is in a distributed environment?\\nFortunately, I am still seeking a job and it seems that I will never find a job. So I won't be the interviewer. Good luck man."
                    },
                    {
                        "username": "trancememes",
                        "content": "what on earth is this question asking ? "
                    },
                    {
                        "username": "archersmind",
                        "content": "Can anyone explain why `counter.getHits(301)` return 3 in the example? I thought it was 4.\\n\\nThank you guys."
                    },
                    {
                        "username": "principoshi",
                        "content": "what [@atul rokade](/atul_rokade) said, but simpler:\\n\\nYou will disregard the call made at hitCounter.hit(1) because the past 300 seconds will be 301 - 300 thus excluding that first call."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "as timestamp is always increasing hence u will never get hit  call smaller than gethits call so u have to remove counts older than 300sec even in gethits call"
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "I really don\\'t understand what this problem is asking.\\n\\nCan someone explain the example test-case and tell me what they are saying by \"5 seconds?\""
                    },
                    {
                        "username": "vartikap06",
                        "content": "poorly worded"
                    },
                    {
                        "username": "rcwors02",
                        "content": "In a distributed system you wouldn\\'t be able to guarantee that the timestamps are coming in order. So for this problem, assuming all the timestamps come in order is not realistic."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "but it was clearly mentioned in constraints \\nIf TCP communication is used then all entries will be guaranteed to be in order but for UDP based system it may or may not be in order"
                    },
                    {
                        "username": "luscioustaxing",
                        "content": "Here\\'s how to scale up this problem to handle high traffic and concurrency:\\nhttp://blog.gainlo.co/index.php/2016/09/12/dropbox-interview-design-hit-counter/\\nhttps://www.geeksforgeeks.org/design-a-hit-counter/\\n\\nThe main approaches from simplest to most scalable are:\\n1. Simple table and SQL query O(N)\\n2. LinkedList\\n3. Circular buffer \\n4. Circular buffer with locks\\n5. Distributed circular buffer - partition the user set by the hash of user id and have circular buffer for each partition. The total count will be the sum of each of the circular buffers\\n\\nA distributed circular buffer (#5)  could be a scalable approach to handle a high volume of user visits\\n\\n\\n"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "u can use simple heap of size 299 and separate var for current timestamp, as u may get mult hit for same timestamp but once timestamp moved ahead u can add entry to heap and maintain sum of heap in separate var and every time u remove node from heap just adjust count"
                    },
                    {
                        "username": "wei69",
                        "content": "it seems that the getHit function must only accept an input that is greater than or equal to the timestamp of the last hit. As most of the solutions only maintains the hits of last 5 minutes, it will generate wrong answer if you call the getHit() function with a smaller timestamp."
                    },
                    {
                        "username": "Chang4Tech",
                        "content": " \"you may assume that calls are being made to the system in chronological order\""
                    }
                ]
            },
            {
                "id": 1571913,
                "content": [
                    {
                        "username": "kk262777",
                        "content": "Since this is a design question, we need to ask interviewer how this class is going to be used? \\nA working code is not the answer to this question, but how you adjust your program to meet different use cases.\\n\\nConsider: There are 1000 frequent hit() followed by 1 getHits(). If we only do removal in getHits() function, it will be very time consuming. For me, I prefer to do removal in both hit() and getHits(), so that the program avoids system lag in this case.\\nThis is important when you design a time-critical system."
                    },
                    {
                        "username": "roish",
                        "content": "http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/\\n\\nBasic ideas:\\n* Rolling Counter\\n* Staged Aggregator\\n* Partition"
                    },
                    {
                        "username": "nightcatzhou",
                        "content": "The follow-up is easy, but if I am the interviewer, I may ask how will you consider the multi-thread solution. \\nOne more thing is that, when it is in a distributed environment?\\nFortunately, I am still seeking a job and it seems that I will never find a job. So I won't be the interviewer. Good luck man."
                    },
                    {
                        "username": "trancememes",
                        "content": "what on earth is this question asking ? "
                    },
                    {
                        "username": "archersmind",
                        "content": "Can anyone explain why `counter.getHits(301)` return 3 in the example? I thought it was 4.\\n\\nThank you guys."
                    },
                    {
                        "username": "principoshi",
                        "content": "what [@atul rokade](/atul_rokade) said, but simpler:\\n\\nYou will disregard the call made at hitCounter.hit(1) because the past 300 seconds will be 301 - 300 thus excluding that first call."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "as timestamp is always increasing hence u will never get hit  call smaller than gethits call so u have to remove counts older than 300sec even in gethits call"
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "I really don\\'t understand what this problem is asking.\\n\\nCan someone explain the example test-case and tell me what they are saying by \"5 seconds?\""
                    },
                    {
                        "username": "vartikap06",
                        "content": "poorly worded"
                    },
                    {
                        "username": "rcwors02",
                        "content": "In a distributed system you wouldn\\'t be able to guarantee that the timestamps are coming in order. So for this problem, assuming all the timestamps come in order is not realistic."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "but it was clearly mentioned in constraints \\nIf TCP communication is used then all entries will be guaranteed to be in order but for UDP based system it may or may not be in order"
                    },
                    {
                        "username": "luscioustaxing",
                        "content": "Here\\'s how to scale up this problem to handle high traffic and concurrency:\\nhttp://blog.gainlo.co/index.php/2016/09/12/dropbox-interview-design-hit-counter/\\nhttps://www.geeksforgeeks.org/design-a-hit-counter/\\n\\nThe main approaches from simplest to most scalable are:\\n1. Simple table and SQL query O(N)\\n2. LinkedList\\n3. Circular buffer \\n4. Circular buffer with locks\\n5. Distributed circular buffer - partition the user set by the hash of user id and have circular buffer for each partition. The total count will be the sum of each of the circular buffers\\n\\nA distributed circular buffer (#5)  could be a scalable approach to handle a high volume of user visits\\n\\n\\n"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "u can use simple heap of size 299 and separate var for current timestamp, as u may get mult hit for same timestamp but once timestamp moved ahead u can add entry to heap and maintain sum of heap in separate var and every time u remove node from heap just adjust count"
                    },
                    {
                        "username": "wei69",
                        "content": "it seems that the getHit function must only accept an input that is greater than or equal to the timestamp of the last hit. As most of the solutions only maintains the hits of last 5 minutes, it will generate wrong answer if you call the getHit() function with a smaller timestamp."
                    },
                    {
                        "username": "Chang4Tech",
                        "content": " \"you may assume that calls are being made to the system in chronological order\""
                    }
                ]
            },
            {
                "id": 1564866,
                "content": [
                    {
                        "username": "kk262777",
                        "content": "Since this is a design question, we need to ask interviewer how this class is going to be used? \\nA working code is not the answer to this question, but how you adjust your program to meet different use cases.\\n\\nConsider: There are 1000 frequent hit() followed by 1 getHits(). If we only do removal in getHits() function, it will be very time consuming. For me, I prefer to do removal in both hit() and getHits(), so that the program avoids system lag in this case.\\nThis is important when you design a time-critical system."
                    },
                    {
                        "username": "roish",
                        "content": "http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/\\n\\nBasic ideas:\\n* Rolling Counter\\n* Staged Aggregator\\n* Partition"
                    },
                    {
                        "username": "nightcatzhou",
                        "content": "The follow-up is easy, but if I am the interviewer, I may ask how will you consider the multi-thread solution. \\nOne more thing is that, when it is in a distributed environment?\\nFortunately, I am still seeking a job and it seems that I will never find a job. So I won't be the interviewer. Good luck man."
                    },
                    {
                        "username": "trancememes",
                        "content": "what on earth is this question asking ? "
                    },
                    {
                        "username": "archersmind",
                        "content": "Can anyone explain why `counter.getHits(301)` return 3 in the example? I thought it was 4.\\n\\nThank you guys."
                    },
                    {
                        "username": "principoshi",
                        "content": "what [@atul rokade](/atul_rokade) said, but simpler:\\n\\nYou will disregard the call made at hitCounter.hit(1) because the past 300 seconds will be 301 - 300 thus excluding that first call."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "as timestamp is always increasing hence u will never get hit  call smaller than gethits call so u have to remove counts older than 300sec even in gethits call"
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "I really don\\'t understand what this problem is asking.\\n\\nCan someone explain the example test-case and tell me what they are saying by \"5 seconds?\""
                    },
                    {
                        "username": "vartikap06",
                        "content": "poorly worded"
                    },
                    {
                        "username": "rcwors02",
                        "content": "In a distributed system you wouldn\\'t be able to guarantee that the timestamps are coming in order. So for this problem, assuming all the timestamps come in order is not realistic."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "but it was clearly mentioned in constraints \\nIf TCP communication is used then all entries will be guaranteed to be in order but for UDP based system it may or may not be in order"
                    },
                    {
                        "username": "luscioustaxing",
                        "content": "Here\\'s how to scale up this problem to handle high traffic and concurrency:\\nhttp://blog.gainlo.co/index.php/2016/09/12/dropbox-interview-design-hit-counter/\\nhttps://www.geeksforgeeks.org/design-a-hit-counter/\\n\\nThe main approaches from simplest to most scalable are:\\n1. Simple table and SQL query O(N)\\n2. LinkedList\\n3. Circular buffer \\n4. Circular buffer with locks\\n5. Distributed circular buffer - partition the user set by the hash of user id and have circular buffer for each partition. The total count will be the sum of each of the circular buffers\\n\\nA distributed circular buffer (#5)  could be a scalable approach to handle a high volume of user visits\\n\\n\\n"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "u can use simple heap of size 299 and separate var for current timestamp, as u may get mult hit for same timestamp but once timestamp moved ahead u can add entry to heap and maintain sum of heap in separate var and every time u remove node from heap just adjust count"
                    },
                    {
                        "username": "wei69",
                        "content": "it seems that the getHit function must only accept an input that is greater than or equal to the timestamp of the last hit. As most of the solutions only maintains the hits of last 5 minutes, it will generate wrong answer if you call the getHit() function with a smaller timestamp."
                    },
                    {
                        "username": "Chang4Tech",
                        "content": " \"you may assume that calls are being made to the system in chronological order\""
                    }
                ]
            },
            {
                "id": 1565445,
                "content": [
                    {
                        "username": "kk262777",
                        "content": "Since this is a design question, we need to ask interviewer how this class is going to be used? \\nA working code is not the answer to this question, but how you adjust your program to meet different use cases.\\n\\nConsider: There are 1000 frequent hit() followed by 1 getHits(). If we only do removal in getHits() function, it will be very time consuming. For me, I prefer to do removal in both hit() and getHits(), so that the program avoids system lag in this case.\\nThis is important when you design a time-critical system."
                    },
                    {
                        "username": "roish",
                        "content": "http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/\\n\\nBasic ideas:\\n* Rolling Counter\\n* Staged Aggregator\\n* Partition"
                    },
                    {
                        "username": "nightcatzhou",
                        "content": "The follow-up is easy, but if I am the interviewer, I may ask how will you consider the multi-thread solution. \\nOne more thing is that, when it is in a distributed environment?\\nFortunately, I am still seeking a job and it seems that I will never find a job. So I won't be the interviewer. Good luck man."
                    },
                    {
                        "username": "trancememes",
                        "content": "what on earth is this question asking ? "
                    },
                    {
                        "username": "archersmind",
                        "content": "Can anyone explain why `counter.getHits(301)` return 3 in the example? I thought it was 4.\\n\\nThank you guys."
                    },
                    {
                        "username": "principoshi",
                        "content": "what [@atul rokade](/atul_rokade) said, but simpler:\\n\\nYou will disregard the call made at hitCounter.hit(1) because the past 300 seconds will be 301 - 300 thus excluding that first call."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "as timestamp is always increasing hence u will never get hit  call smaller than gethits call so u have to remove counts older than 300sec even in gethits call"
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "I really don\\'t understand what this problem is asking.\\n\\nCan someone explain the example test-case and tell me what they are saying by \"5 seconds?\""
                    },
                    {
                        "username": "vartikap06",
                        "content": "poorly worded"
                    },
                    {
                        "username": "rcwors02",
                        "content": "In a distributed system you wouldn\\'t be able to guarantee that the timestamps are coming in order. So for this problem, assuming all the timestamps come in order is not realistic."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "but it was clearly mentioned in constraints \\nIf TCP communication is used then all entries will be guaranteed to be in order but for UDP based system it may or may not be in order"
                    },
                    {
                        "username": "luscioustaxing",
                        "content": "Here\\'s how to scale up this problem to handle high traffic and concurrency:\\nhttp://blog.gainlo.co/index.php/2016/09/12/dropbox-interview-design-hit-counter/\\nhttps://www.geeksforgeeks.org/design-a-hit-counter/\\n\\nThe main approaches from simplest to most scalable are:\\n1. Simple table and SQL query O(N)\\n2. LinkedList\\n3. Circular buffer \\n4. Circular buffer with locks\\n5. Distributed circular buffer - partition the user set by the hash of user id and have circular buffer for each partition. The total count will be the sum of each of the circular buffers\\n\\nA distributed circular buffer (#5)  could be a scalable approach to handle a high volume of user visits\\n\\n\\n"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "u can use simple heap of size 299 and separate var for current timestamp, as u may get mult hit for same timestamp but once timestamp moved ahead u can add entry to heap and maintain sum of heap in separate var and every time u remove node from heap just adjust count"
                    },
                    {
                        "username": "wei69",
                        "content": "it seems that the getHit function must only accept an input that is greater than or equal to the timestamp of the last hit. As most of the solutions only maintains the hits of last 5 minutes, it will generate wrong answer if you call the getHit() function with a smaller timestamp."
                    },
                    {
                        "username": "Chang4Tech",
                        "content": " \"you may assume that calls are being made to the system in chronological order\""
                    }
                ]
            },
            {
                "id": 1566786,
                "content": [
                    {
                        "username": "kk262777",
                        "content": "Since this is a design question, we need to ask interviewer how this class is going to be used? \\nA working code is not the answer to this question, but how you adjust your program to meet different use cases.\\n\\nConsider: There are 1000 frequent hit() followed by 1 getHits(). If we only do removal in getHits() function, it will be very time consuming. For me, I prefer to do removal in both hit() and getHits(), so that the program avoids system lag in this case.\\nThis is important when you design a time-critical system."
                    },
                    {
                        "username": "roish",
                        "content": "http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/\\n\\nBasic ideas:\\n* Rolling Counter\\n* Staged Aggregator\\n* Partition"
                    },
                    {
                        "username": "nightcatzhou",
                        "content": "The follow-up is easy, but if I am the interviewer, I may ask how will you consider the multi-thread solution. \\nOne more thing is that, when it is in a distributed environment?\\nFortunately, I am still seeking a job and it seems that I will never find a job. So I won't be the interviewer. Good luck man."
                    },
                    {
                        "username": "trancememes",
                        "content": "what on earth is this question asking ? "
                    },
                    {
                        "username": "archersmind",
                        "content": "Can anyone explain why `counter.getHits(301)` return 3 in the example? I thought it was 4.\\n\\nThank you guys."
                    },
                    {
                        "username": "principoshi",
                        "content": "what [@atul rokade](/atul_rokade) said, but simpler:\\n\\nYou will disregard the call made at hitCounter.hit(1) because the past 300 seconds will be 301 - 300 thus excluding that first call."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "as timestamp is always increasing hence u will never get hit  call smaller than gethits call so u have to remove counts older than 300sec even in gethits call"
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "I really don\\'t understand what this problem is asking.\\n\\nCan someone explain the example test-case and tell me what they are saying by \"5 seconds?\""
                    },
                    {
                        "username": "vartikap06",
                        "content": "poorly worded"
                    },
                    {
                        "username": "rcwors02",
                        "content": "In a distributed system you wouldn\\'t be able to guarantee that the timestamps are coming in order. So for this problem, assuming all the timestamps come in order is not realistic."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "but it was clearly mentioned in constraints \\nIf TCP communication is used then all entries will be guaranteed to be in order but for UDP based system it may or may not be in order"
                    },
                    {
                        "username": "luscioustaxing",
                        "content": "Here\\'s how to scale up this problem to handle high traffic and concurrency:\\nhttp://blog.gainlo.co/index.php/2016/09/12/dropbox-interview-design-hit-counter/\\nhttps://www.geeksforgeeks.org/design-a-hit-counter/\\n\\nThe main approaches from simplest to most scalable are:\\n1. Simple table and SQL query O(N)\\n2. LinkedList\\n3. Circular buffer \\n4. Circular buffer with locks\\n5. Distributed circular buffer - partition the user set by the hash of user id and have circular buffer for each partition. The total count will be the sum of each of the circular buffers\\n\\nA distributed circular buffer (#5)  could be a scalable approach to handle a high volume of user visits\\n\\n\\n"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "u can use simple heap of size 299 and separate var for current timestamp, as u may get mult hit for same timestamp but once timestamp moved ahead u can add entry to heap and maintain sum of heap in separate var and every time u remove node from heap just adjust count"
                    },
                    {
                        "username": "wei69",
                        "content": "it seems that the getHit function must only accept an input that is greater than or equal to the timestamp of the last hit. As most of the solutions only maintains the hits of last 5 minutes, it will generate wrong answer if you call the getHit() function with a smaller timestamp."
                    },
                    {
                        "username": "Chang4Tech",
                        "content": " \"you may assume that calls are being made to the system in chronological order\""
                    }
                ]
            },
            {
                "id": 1738694,
                "content": [
                    {
                        "username": "kk262777",
                        "content": "Since this is a design question, we need to ask interviewer how this class is going to be used? \\nA working code is not the answer to this question, but how you adjust your program to meet different use cases.\\n\\nConsider: There are 1000 frequent hit() followed by 1 getHits(). If we only do removal in getHits() function, it will be very time consuming. For me, I prefer to do removal in both hit() and getHits(), so that the program avoids system lag in this case.\\nThis is important when you design a time-critical system."
                    },
                    {
                        "username": "roish",
                        "content": "http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/\\n\\nBasic ideas:\\n* Rolling Counter\\n* Staged Aggregator\\n* Partition"
                    },
                    {
                        "username": "nightcatzhou",
                        "content": "The follow-up is easy, but if I am the interviewer, I may ask how will you consider the multi-thread solution. \\nOne more thing is that, when it is in a distributed environment?\\nFortunately, I am still seeking a job and it seems that I will never find a job. So I won't be the interviewer. Good luck man."
                    },
                    {
                        "username": "trancememes",
                        "content": "what on earth is this question asking ? "
                    },
                    {
                        "username": "archersmind",
                        "content": "Can anyone explain why `counter.getHits(301)` return 3 in the example? I thought it was 4.\\n\\nThank you guys."
                    },
                    {
                        "username": "principoshi",
                        "content": "what [@atul rokade](/atul_rokade) said, but simpler:\\n\\nYou will disregard the call made at hitCounter.hit(1) because the past 300 seconds will be 301 - 300 thus excluding that first call."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "as timestamp is always increasing hence u will never get hit  call smaller than gethits call so u have to remove counts older than 300sec even in gethits call"
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "I really don\\'t understand what this problem is asking.\\n\\nCan someone explain the example test-case and tell me what they are saying by \"5 seconds?\""
                    },
                    {
                        "username": "vartikap06",
                        "content": "poorly worded"
                    },
                    {
                        "username": "rcwors02",
                        "content": "In a distributed system you wouldn\\'t be able to guarantee that the timestamps are coming in order. So for this problem, assuming all the timestamps come in order is not realistic."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "but it was clearly mentioned in constraints \\nIf TCP communication is used then all entries will be guaranteed to be in order but for UDP based system it may or may not be in order"
                    },
                    {
                        "username": "luscioustaxing",
                        "content": "Here\\'s how to scale up this problem to handle high traffic and concurrency:\\nhttp://blog.gainlo.co/index.php/2016/09/12/dropbox-interview-design-hit-counter/\\nhttps://www.geeksforgeeks.org/design-a-hit-counter/\\n\\nThe main approaches from simplest to most scalable are:\\n1. Simple table and SQL query O(N)\\n2. LinkedList\\n3. Circular buffer \\n4. Circular buffer with locks\\n5. Distributed circular buffer - partition the user set by the hash of user id and have circular buffer for each partition. The total count will be the sum of each of the circular buffers\\n\\nA distributed circular buffer (#5)  could be a scalable approach to handle a high volume of user visits\\n\\n\\n"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "u can use simple heap of size 299 and separate var for current timestamp, as u may get mult hit for same timestamp but once timestamp moved ahead u can add entry to heap and maintain sum of heap in separate var and every time u remove node from heap just adjust count"
                    },
                    {
                        "username": "wei69",
                        "content": "it seems that the getHit function must only accept an input that is greater than or equal to the timestamp of the last hit. As most of the solutions only maintains the hits of last 5 minutes, it will generate wrong answer if you call the getHit() function with a smaller timestamp."
                    },
                    {
                        "username": "Chang4Tech",
                        "content": " \"you may assume that calls are being made to the system in chronological order\""
                    }
                ]
            },
            {
                "id": 1574354,
                "content": [
                    {
                        "username": "kk262777",
                        "content": "Since this is a design question, we need to ask interviewer how this class is going to be used? \\nA working code is not the answer to this question, but how you adjust your program to meet different use cases.\\n\\nConsider: There are 1000 frequent hit() followed by 1 getHits(). If we only do removal in getHits() function, it will be very time consuming. For me, I prefer to do removal in both hit() and getHits(), so that the program avoids system lag in this case.\\nThis is important when you design a time-critical system."
                    },
                    {
                        "username": "roish",
                        "content": "http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/\\n\\nBasic ideas:\\n* Rolling Counter\\n* Staged Aggregator\\n* Partition"
                    },
                    {
                        "username": "nightcatzhou",
                        "content": "The follow-up is easy, but if I am the interviewer, I may ask how will you consider the multi-thread solution. \\nOne more thing is that, when it is in a distributed environment?\\nFortunately, I am still seeking a job and it seems that I will never find a job. So I won't be the interviewer. Good luck man."
                    },
                    {
                        "username": "trancememes",
                        "content": "what on earth is this question asking ? "
                    },
                    {
                        "username": "archersmind",
                        "content": "Can anyone explain why `counter.getHits(301)` return 3 in the example? I thought it was 4.\\n\\nThank you guys."
                    },
                    {
                        "username": "principoshi",
                        "content": "what [@atul rokade](/atul_rokade) said, but simpler:\\n\\nYou will disregard the call made at hitCounter.hit(1) because the past 300 seconds will be 301 - 300 thus excluding that first call."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "as timestamp is always increasing hence u will never get hit  call smaller than gethits call so u have to remove counts older than 300sec even in gethits call"
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "I really don\\'t understand what this problem is asking.\\n\\nCan someone explain the example test-case and tell me what they are saying by \"5 seconds?\""
                    },
                    {
                        "username": "vartikap06",
                        "content": "poorly worded"
                    },
                    {
                        "username": "rcwors02",
                        "content": "In a distributed system you wouldn\\'t be able to guarantee that the timestamps are coming in order. So for this problem, assuming all the timestamps come in order is not realistic."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "but it was clearly mentioned in constraints \\nIf TCP communication is used then all entries will be guaranteed to be in order but for UDP based system it may or may not be in order"
                    },
                    {
                        "username": "luscioustaxing",
                        "content": "Here\\'s how to scale up this problem to handle high traffic and concurrency:\\nhttp://blog.gainlo.co/index.php/2016/09/12/dropbox-interview-design-hit-counter/\\nhttps://www.geeksforgeeks.org/design-a-hit-counter/\\n\\nThe main approaches from simplest to most scalable are:\\n1. Simple table and SQL query O(N)\\n2. LinkedList\\n3. Circular buffer \\n4. Circular buffer with locks\\n5. Distributed circular buffer - partition the user set by the hash of user id and have circular buffer for each partition. The total count will be the sum of each of the circular buffers\\n\\nA distributed circular buffer (#5)  could be a scalable approach to handle a high volume of user visits\\n\\n\\n"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "u can use simple heap of size 299 and separate var for current timestamp, as u may get mult hit for same timestamp but once timestamp moved ahead u can add entry to heap and maintain sum of heap in separate var and every time u remove node from heap just adjust count"
                    },
                    {
                        "username": "wei69",
                        "content": "it seems that the getHit function must only accept an input that is greater than or equal to the timestamp of the last hit. As most of the solutions only maintains the hits of last 5 minutes, it will generate wrong answer if you call the getHit() function with a smaller timestamp."
                    },
                    {
                        "username": "Chang4Tech",
                        "content": " \"you may assume that calls are being made to the system in chronological order\""
                    }
                ]
            },
            {
                "id": 1569248,
                "content": [
                    {
                        "username": "kk262777",
                        "content": "Since this is a design question, we need to ask interviewer how this class is going to be used? \\nA working code is not the answer to this question, but how you adjust your program to meet different use cases.\\n\\nConsider: There are 1000 frequent hit() followed by 1 getHits(). If we only do removal in getHits() function, it will be very time consuming. For me, I prefer to do removal in both hit() and getHits(), so that the program avoids system lag in this case.\\nThis is important when you design a time-critical system."
                    },
                    {
                        "username": "roish",
                        "content": "http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/\\n\\nBasic ideas:\\n* Rolling Counter\\n* Staged Aggregator\\n* Partition"
                    },
                    {
                        "username": "nightcatzhou",
                        "content": "The follow-up is easy, but if I am the interviewer, I may ask how will you consider the multi-thread solution. \\nOne more thing is that, when it is in a distributed environment?\\nFortunately, I am still seeking a job and it seems that I will never find a job. So I won't be the interviewer. Good luck man."
                    },
                    {
                        "username": "trancememes",
                        "content": "what on earth is this question asking ? "
                    },
                    {
                        "username": "archersmind",
                        "content": "Can anyone explain why `counter.getHits(301)` return 3 in the example? I thought it was 4.\\n\\nThank you guys."
                    },
                    {
                        "username": "principoshi",
                        "content": "what [@atul rokade](/atul_rokade) said, but simpler:\\n\\nYou will disregard the call made at hitCounter.hit(1) because the past 300 seconds will be 301 - 300 thus excluding that first call."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "as timestamp is always increasing hence u will never get hit  call smaller than gethits call so u have to remove counts older than 300sec even in gethits call"
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "I really don\\'t understand what this problem is asking.\\n\\nCan someone explain the example test-case and tell me what they are saying by \"5 seconds?\""
                    },
                    {
                        "username": "vartikap06",
                        "content": "poorly worded"
                    },
                    {
                        "username": "rcwors02",
                        "content": "In a distributed system you wouldn\\'t be able to guarantee that the timestamps are coming in order. So for this problem, assuming all the timestamps come in order is not realistic."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "but it was clearly mentioned in constraints \\nIf TCP communication is used then all entries will be guaranteed to be in order but for UDP based system it may or may not be in order"
                    },
                    {
                        "username": "luscioustaxing",
                        "content": "Here\\'s how to scale up this problem to handle high traffic and concurrency:\\nhttp://blog.gainlo.co/index.php/2016/09/12/dropbox-interview-design-hit-counter/\\nhttps://www.geeksforgeeks.org/design-a-hit-counter/\\n\\nThe main approaches from simplest to most scalable are:\\n1. Simple table and SQL query O(N)\\n2. LinkedList\\n3. Circular buffer \\n4. Circular buffer with locks\\n5. Distributed circular buffer - partition the user set by the hash of user id and have circular buffer for each partition. The total count will be the sum of each of the circular buffers\\n\\nA distributed circular buffer (#5)  could be a scalable approach to handle a high volume of user visits\\n\\n\\n"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "u can use simple heap of size 299 and separate var for current timestamp, as u may get mult hit for same timestamp but once timestamp moved ahead u can add entry to heap and maintain sum of heap in separate var and every time u remove node from heap just adjust count"
                    },
                    {
                        "username": "wei69",
                        "content": "it seems that the getHit function must only accept an input that is greater than or equal to the timestamp of the last hit. As most of the solutions only maintains the hits of last 5 minutes, it will generate wrong answer if you call the getHit() function with a smaller timestamp."
                    },
                    {
                        "username": "Chang4Tech",
                        "content": " \"you may assume that calls are being made to the system in chronological order\""
                    }
                ]
            },
            {
                "id": 1864073,
                "content": [
                    {
                        "username": "kk262777",
                        "content": "Since this is a design question, we need to ask interviewer how this class is going to be used? \\nA working code is not the answer to this question, but how you adjust your program to meet different use cases.\\n\\nConsider: There are 1000 frequent hit() followed by 1 getHits(). If we only do removal in getHits() function, it will be very time consuming. For me, I prefer to do removal in both hit() and getHits(), so that the program avoids system lag in this case.\\nThis is important when you design a time-critical system."
                    },
                    {
                        "username": "roish",
                        "content": "http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/\\n\\nBasic ideas:\\n* Rolling Counter\\n* Staged Aggregator\\n* Partition"
                    },
                    {
                        "username": "nightcatzhou",
                        "content": "The follow-up is easy, but if I am the interviewer, I may ask how will you consider the multi-thread solution. \\nOne more thing is that, when it is in a distributed environment?\\nFortunately, I am still seeking a job and it seems that I will never find a job. So I won't be the interviewer. Good luck man."
                    },
                    {
                        "username": "trancememes",
                        "content": "what on earth is this question asking ? "
                    },
                    {
                        "username": "archersmind",
                        "content": "Can anyone explain why `counter.getHits(301)` return 3 in the example? I thought it was 4.\\n\\nThank you guys."
                    },
                    {
                        "username": "principoshi",
                        "content": "what [@atul rokade](/atul_rokade) said, but simpler:\\n\\nYou will disregard the call made at hitCounter.hit(1) because the past 300 seconds will be 301 - 300 thus excluding that first call."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "as timestamp is always increasing hence u will never get hit  call smaller than gethits call so u have to remove counts older than 300sec even in gethits call"
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "I really don\\'t understand what this problem is asking.\\n\\nCan someone explain the example test-case and tell me what they are saying by \"5 seconds?\""
                    },
                    {
                        "username": "vartikap06",
                        "content": "poorly worded"
                    },
                    {
                        "username": "rcwors02",
                        "content": "In a distributed system you wouldn\\'t be able to guarantee that the timestamps are coming in order. So for this problem, assuming all the timestamps come in order is not realistic."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "but it was clearly mentioned in constraints \\nIf TCP communication is used then all entries will be guaranteed to be in order but for UDP based system it may or may not be in order"
                    },
                    {
                        "username": "luscioustaxing",
                        "content": "Here\\'s how to scale up this problem to handle high traffic and concurrency:\\nhttp://blog.gainlo.co/index.php/2016/09/12/dropbox-interview-design-hit-counter/\\nhttps://www.geeksforgeeks.org/design-a-hit-counter/\\n\\nThe main approaches from simplest to most scalable are:\\n1. Simple table and SQL query O(N)\\n2. LinkedList\\n3. Circular buffer \\n4. Circular buffer with locks\\n5. Distributed circular buffer - partition the user set by the hash of user id and have circular buffer for each partition. The total count will be the sum of each of the circular buffers\\n\\nA distributed circular buffer (#5)  could be a scalable approach to handle a high volume of user visits\\n\\n\\n"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "u can use simple heap of size 299 and separate var for current timestamp, as u may get mult hit for same timestamp but once timestamp moved ahead u can add entry to heap and maintain sum of heap in separate var and every time u remove node from heap just adjust count"
                    },
                    {
                        "username": "wei69",
                        "content": "it seems that the getHit function must only accept an input that is greater than or equal to the timestamp of the last hit. As most of the solutions only maintains the hits of last 5 minutes, it will generate wrong answer if you call the getHit() function with a smaller timestamp."
                    },
                    {
                        "username": "Chang4Tech",
                        "content": " \"you may assume that calls are being made to the system in chronological order\""
                    }
                ]
            },
            {
                "id": 1712320,
                "content": [
                    {
                        "username": "kk262777",
                        "content": "Since this is a design question, we need to ask interviewer how this class is going to be used? \\nA working code is not the answer to this question, but how you adjust your program to meet different use cases.\\n\\nConsider: There are 1000 frequent hit() followed by 1 getHits(). If we only do removal in getHits() function, it will be very time consuming. For me, I prefer to do removal in both hit() and getHits(), so that the program avoids system lag in this case.\\nThis is important when you design a time-critical system."
                    },
                    {
                        "username": "roish",
                        "content": "http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/\\n\\nBasic ideas:\\n* Rolling Counter\\n* Staged Aggregator\\n* Partition"
                    },
                    {
                        "username": "nightcatzhou",
                        "content": "The follow-up is easy, but if I am the interviewer, I may ask how will you consider the multi-thread solution. \\nOne more thing is that, when it is in a distributed environment?\\nFortunately, I am still seeking a job and it seems that I will never find a job. So I won't be the interviewer. Good luck man."
                    },
                    {
                        "username": "trancememes",
                        "content": "what on earth is this question asking ? "
                    },
                    {
                        "username": "archersmind",
                        "content": "Can anyone explain why `counter.getHits(301)` return 3 in the example? I thought it was 4.\\n\\nThank you guys."
                    },
                    {
                        "username": "principoshi",
                        "content": "what [@atul rokade](/atul_rokade) said, but simpler:\\n\\nYou will disregard the call made at hitCounter.hit(1) because the past 300 seconds will be 301 - 300 thus excluding that first call."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "as timestamp is always increasing hence u will never get hit  call smaller than gethits call so u have to remove counts older than 300sec even in gethits call"
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "I really don\\'t understand what this problem is asking.\\n\\nCan someone explain the example test-case and tell me what they are saying by \"5 seconds?\""
                    },
                    {
                        "username": "vartikap06",
                        "content": "poorly worded"
                    },
                    {
                        "username": "rcwors02",
                        "content": "In a distributed system you wouldn\\'t be able to guarantee that the timestamps are coming in order. So for this problem, assuming all the timestamps come in order is not realistic."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "but it was clearly mentioned in constraints \\nIf TCP communication is used then all entries will be guaranteed to be in order but for UDP based system it may or may not be in order"
                    },
                    {
                        "username": "luscioustaxing",
                        "content": "Here\\'s how to scale up this problem to handle high traffic and concurrency:\\nhttp://blog.gainlo.co/index.php/2016/09/12/dropbox-interview-design-hit-counter/\\nhttps://www.geeksforgeeks.org/design-a-hit-counter/\\n\\nThe main approaches from simplest to most scalable are:\\n1. Simple table and SQL query O(N)\\n2. LinkedList\\n3. Circular buffer \\n4. Circular buffer with locks\\n5. Distributed circular buffer - partition the user set by the hash of user id and have circular buffer for each partition. The total count will be the sum of each of the circular buffers\\n\\nA distributed circular buffer (#5)  could be a scalable approach to handle a high volume of user visits\\n\\n\\n"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "u can use simple heap of size 299 and separate var for current timestamp, as u may get mult hit for same timestamp but once timestamp moved ahead u can add entry to heap and maintain sum of heap in separate var and every time u remove node from heap just adjust count"
                    },
                    {
                        "username": "wei69",
                        "content": "it seems that the getHit function must only accept an input that is greater than or equal to the timestamp of the last hit. As most of the solutions only maintains the hits of last 5 minutes, it will generate wrong answer if you call the getHit() function with a smaller timestamp."
                    },
                    {
                        "username": "Chang4Tech",
                        "content": " \"you may assume that calls are being made to the system in chronological order\""
                    }
                ]
            },
            {
                "id": 1573256,
                "content": [
                    {
                        "username": "kk262777",
                        "content": "Since this is a design question, we need to ask interviewer how this class is going to be used? \\nA working code is not the answer to this question, but how you adjust your program to meet different use cases.\\n\\nConsider: There are 1000 frequent hit() followed by 1 getHits(). If we only do removal in getHits() function, it will be very time consuming. For me, I prefer to do removal in both hit() and getHits(), so that the program avoids system lag in this case.\\nThis is important when you design a time-critical system."
                    },
                    {
                        "username": "roish",
                        "content": "http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/\\n\\nBasic ideas:\\n* Rolling Counter\\n* Staged Aggregator\\n* Partition"
                    },
                    {
                        "username": "nightcatzhou",
                        "content": "The follow-up is easy, but if I am the interviewer, I may ask how will you consider the multi-thread solution. \\nOne more thing is that, when it is in a distributed environment?\\nFortunately, I am still seeking a job and it seems that I will never find a job. So I won't be the interviewer. Good luck man."
                    },
                    {
                        "username": "trancememes",
                        "content": "what on earth is this question asking ? "
                    },
                    {
                        "username": "archersmind",
                        "content": "Can anyone explain why `counter.getHits(301)` return 3 in the example? I thought it was 4.\\n\\nThank you guys."
                    },
                    {
                        "username": "principoshi",
                        "content": "what [@atul rokade](/atul_rokade) said, but simpler:\\n\\nYou will disregard the call made at hitCounter.hit(1) because the past 300 seconds will be 301 - 300 thus excluding that first call."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "as timestamp is always increasing hence u will never get hit  call smaller than gethits call so u have to remove counts older than 300sec even in gethits call"
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "I really don\\'t understand what this problem is asking.\\n\\nCan someone explain the example test-case and tell me what they are saying by \"5 seconds?\""
                    },
                    {
                        "username": "vartikap06",
                        "content": "poorly worded"
                    },
                    {
                        "username": "rcwors02",
                        "content": "In a distributed system you wouldn\\'t be able to guarantee that the timestamps are coming in order. So for this problem, assuming all the timestamps come in order is not realistic."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "but it was clearly mentioned in constraints \\nIf TCP communication is used then all entries will be guaranteed to be in order but for UDP based system it may or may not be in order"
                    },
                    {
                        "username": "luscioustaxing",
                        "content": "Here\\'s how to scale up this problem to handle high traffic and concurrency:\\nhttp://blog.gainlo.co/index.php/2016/09/12/dropbox-interview-design-hit-counter/\\nhttps://www.geeksforgeeks.org/design-a-hit-counter/\\n\\nThe main approaches from simplest to most scalable are:\\n1. Simple table and SQL query O(N)\\n2. LinkedList\\n3. Circular buffer \\n4. Circular buffer with locks\\n5. Distributed circular buffer - partition the user set by the hash of user id and have circular buffer for each partition. The total count will be the sum of each of the circular buffers\\n\\nA distributed circular buffer (#5)  could be a scalable approach to handle a high volume of user visits\\n\\n\\n"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "u can use simple heap of size 299 and separate var for current timestamp, as u may get mult hit for same timestamp but once timestamp moved ahead u can add entry to heap and maintain sum of heap in separate var and every time u remove node from heap just adjust count"
                    },
                    {
                        "username": "wei69",
                        "content": "it seems that the getHit function must only accept an input that is greater than or equal to the timestamp of the last hit. As most of the solutions only maintains the hits of last 5 minutes, it will generate wrong answer if you call the getHit() function with a smaller timestamp."
                    },
                    {
                        "username": "Chang4Tech",
                        "content": " \"you may assume that calls are being made to the system in chronological order\""
                    }
                ]
            },
            {
                "id": 1571913,
                "content": [
                    {
                        "username": "kk262777",
                        "content": "Since this is a design question, we need to ask interviewer how this class is going to be used? \\nA working code is not the answer to this question, but how you adjust your program to meet different use cases.\\n\\nConsider: There are 1000 frequent hit() followed by 1 getHits(). If we only do removal in getHits() function, it will be very time consuming. For me, I prefer to do removal in both hit() and getHits(), so that the program avoids system lag in this case.\\nThis is important when you design a time-critical system."
                    },
                    {
                        "username": "roish",
                        "content": "http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/\\n\\nBasic ideas:\\n* Rolling Counter\\n* Staged Aggregator\\n* Partition"
                    },
                    {
                        "username": "nightcatzhou",
                        "content": "The follow-up is easy, but if I am the interviewer, I may ask how will you consider the multi-thread solution. \\nOne more thing is that, when it is in a distributed environment?\\nFortunately, I am still seeking a job and it seems that I will never find a job. So I won't be the interviewer. Good luck man."
                    },
                    {
                        "username": "trancememes",
                        "content": "what on earth is this question asking ? "
                    },
                    {
                        "username": "archersmind",
                        "content": "Can anyone explain why `counter.getHits(301)` return 3 in the example? I thought it was 4.\\n\\nThank you guys."
                    },
                    {
                        "username": "principoshi",
                        "content": "what [@atul rokade](/atul_rokade) said, but simpler:\\n\\nYou will disregard the call made at hitCounter.hit(1) because the past 300 seconds will be 301 - 300 thus excluding that first call."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "as timestamp is always increasing hence u will never get hit  call smaller than gethits call so u have to remove counts older than 300sec even in gethits call"
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "I really don\\'t understand what this problem is asking.\\n\\nCan someone explain the example test-case and tell me what they are saying by \"5 seconds?\""
                    },
                    {
                        "username": "vartikap06",
                        "content": "poorly worded"
                    },
                    {
                        "username": "rcwors02",
                        "content": "In a distributed system you wouldn\\'t be able to guarantee that the timestamps are coming in order. So for this problem, assuming all the timestamps come in order is not realistic."
                    },
                    {
                        "username": "atul_rokade",
                        "content": "but it was clearly mentioned in constraints \\nIf TCP communication is used then all entries will be guaranteed to be in order but for UDP based system it may or may not be in order"
                    },
                    {
                        "username": "luscioustaxing",
                        "content": "Here\\'s how to scale up this problem to handle high traffic and concurrency:\\nhttp://blog.gainlo.co/index.php/2016/09/12/dropbox-interview-design-hit-counter/\\nhttps://www.geeksforgeeks.org/design-a-hit-counter/\\n\\nThe main approaches from simplest to most scalable are:\\n1. Simple table and SQL query O(N)\\n2. LinkedList\\n3. Circular buffer \\n4. Circular buffer with locks\\n5. Distributed circular buffer - partition the user set by the hash of user id and have circular buffer for each partition. The total count will be the sum of each of the circular buffers\\n\\nA distributed circular buffer (#5)  could be a scalable approach to handle a high volume of user visits\\n\\n\\n"
                    },
                    {
                        "username": "atul_rokade",
                        "content": "u can use simple heap of size 299 and separate var for current timestamp, as u may get mult hit for same timestamp but once timestamp moved ahead u can add entry to heap and maintain sum of heap in separate var and every time u remove node from heap just adjust count"
                    },
                    {
                        "username": "wei69",
                        "content": "it seems that the getHit function must only accept an input that is greater than or equal to the timestamp of the last hit. As most of the solutions only maintains the hits of last 5 minutes, it will generate wrong answer if you call the getHit() function with a smaller timestamp."
                    },
                    {
                        "username": "Chang4Tech",
                        "content": " \"you may assume that calls are being made to the system in chronological order\""
                    }
                ]
            }
        ]
    }
]