[
    {
        "title": "Minimum Bit Flips to Convert Number",
        "question_content": "A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from either 0 to 1 or 1 to 0.\n\n\tFor example, for x = 7, the binary representation is 111 and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get 110, flip the second bit from the right to get 101, flip the fifth bit from the right (a leading zero) to get 10111, etc.\n\nGiven two integers start and goal, return the minimum number of bit flips to convert start to goal.\n&nbsp;\nExample 1:\n\nInput: start = 10, goal = 7\nOutput: 3\nExplanation: The binary representation of 10 and 7 are 1010 and 0111 respectively. We can convert 10 to 7 in 3 steps:\n- Flip the first bit from the right: 1010 -> 1011.\n- Flip the third bit from the right: 1011 -> 1111.\n- Flip the fourth bit from the right: 1111 -> 0111.\nIt can be shown we cannot convert 10 to 7 in less than 3 steps. Hence, we return 3.\nExample 2:\n\nInput: start = 3, goal = 4\nOutput: 3\nExplanation: The binary representation of 3 and 4 are 011 and 100 respectively. We can convert 3 to 4 in 3 steps:\n- Flip the first bit from the right: 011 -> 010.\n- Flip the second bit from the right: 010 -> 000.\n- Flip the third bit from the right: 000 -> 100.\nIt can be shown we cannot convert 3 to 4 in less than 3 steps. Hence, we return 3.\n\n&nbsp;\nConstraints:\n\n\t0 <= start, goal <= 109",
        "solutions": [
            {
                "id": 1907028,
                "title": "c-1-liner-xor-count-set-bits",
                "content": "To get minimum bit flips we find XOR of two number : which have set bits only at those places where A differs from B. \\nSo, after getting the **xor** `( a ^ b )` , we need to count the number of set bits.\\nWe can do that using **__builtin_popcount(i)**: This function is used to count the number of set bits in an integer.\\n\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n```\\nPlease let me know ways to improve my solution.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911170,
                "title": "one-liners-have-a-look",
                "content": "Number of different bits is the required bits to flip, to make start and goal same.\\nWe can efficiently calculate them using xor operation : \\n\\n**Java one liner :** \\n```\\npublic int minBitFlips(int start, int goal) {\\n        return Integer.bitCount(start^goal);\\n}\\n```\\n\\n\\n**CPP one liner :**\\n```\\nint minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n}\\n```\\n\\n**Python one liner :**\\n```\\ndef minBitFlips(self, start: int, goal: int) -> int:\\n        return (start ^ goal).bit_count()\\n```\\n\\n**Javascript one liner :**\\n```\\nvar minBitFlips = function(start, goal) {\\n    return (start^goal).toString(2).split(\"0\").join(\"\").length;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\npublic int minBitFlips(int start, int goal) {\\n        return Integer.bitCount(start^goal);\\n}\\n```\n```\\nint minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n}\\n```\n```\\ndef minBitFlips(self, start: int, goal: int) -> int:\\n        return (start ^ goal).bit_count()\\n```\n```\\nvar minBitFlips = function(start, goal) {\\n    return (start^goal).toString(2).split(\"0\").join(\"\").length;\\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1907470,
                "title": "c-2-methods-1-line-solution",
                "content": "## Method-1\\n\\nWe find last bit of both start and goal by two and check if the bit is same or not. Then divide the numbers by 2.\\n\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int ans=0;\\n        while(start>0 or goal>0){\\n            int temp1=start%2;\\n            int temp2=goal%2;\\n            if(temp1!=temp2){\\n                ans++;\\n            }\\n            start/=2;\\n            goal/=2;\\n        }\\n        return ans;\\n    }\\n}; \\n```\\n\\n## Method-2\\n**XOR** start and goal to find the bits that are different\\nUse in-built method **popcount** to count the number of set bits\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int ans=0;\\n        while(start>0 or goal>0){\\n            int temp1=start%2;\\n            int temp2=goal%2;\\n            if(temp1!=temp2){\\n                ans++;\\n            }\\n            start/=2;\\n            goal/=2;\\n        }\\n        return ans;\\n    }\\n}; \\n```\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907264,
                "title": "java-xor-and-counting-bits-beats-100",
                "content": "We need to count the number of corresponding bits of start and goal that are different.\\nxor-ing start and goal will result in a new number with binary representation of 0 where the corresponding bits of start and goal are equal and 1 where the corresponding bits are different.\\n\\nFor example: 10 and 7 \\n10 = 1010\\n  7 = 0111\\n  \\n10 xor 7 =  1101 (3 ones)\\n\\nNext we need to count the number of 1s (different bits)\\nThe quickest way to count the number of 1s in a number is by eliminating the right most 1 each time and count the number of eliminations, this is done by and-ing the number with (number-1)\\nSubtracting a 1 from a number flips all right most bits until the first right most 1 and by and-ing with the number itself we eliminating the all bits until the first tight most 1 (inclusive)\\nex. \\nnumber =1101\\nnumber -1 = 1100\\nnumber and (number -1) = 1100 (we eliminated the right most 1)\\n\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int xor =start ^ goal;\\n        int count=0;\\n        while(xor>0){\\n            count++;\\n            xor=xor & (xor-1);\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int xor =start ^ goal;\\n        int count=0;\\n        while(xor>0){\\n            count++;\\n            xor=xor & (xor-1);\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775126,
                "title": "python-java-c-solution-without-xor",
                "content": "# Divmod Remainder Approach:\\n#### Time Complexity: O(log(min(s,g))) --> O(log(n)) \\n#### Space Complexity: O(1)\\n\\nWe divide s and q by 2 until either s or g equals zero.\\nDuring this process, if the remainder of either of them **do not** equal eachother, we increment the counter.\\n\\n***This process is similar to converting a decimal number to binary***\\n\\n**Example:** s=10 g=7\\n\\n| iterations | s (binary) | g (binary) | counter | explaination\\n| - | --- | --- | --- | ---- |\\n1|   1010 |0111|+1| The last digit of s and g are ***different***\\n2|    0101 |0011|+0| The last digits are the **same** so we do nothing\\n3|    0010 |0001|+1| The last digit of s and g are ***different***\\n4|    0001 |0000|+1|The last digit of s and g are ***different***\\n\\n```Python []\\nclass Solution:\\n    def minBitFlips(self, s: int, g: int) -> int:\\n        count = 0 \\n        while s or g:\\n            if s%2 != g%2: count+=1\\n            s, g = s//2, g//2\\n        return count\\n```\\n```Java []\\nclass Solution {\\n    public int minBitFlips(int s, int g) {\\n        int count = 0;\\n        while(s > 0 || g > 0){\\n            if(s%2 != g%2) count++;\\n            s = s/2;\\n            g = g/2;\\n        }\\n        return count;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minBitFlips(int s, int g) {\\n        int count = 0;\\n        while(s > 0 || g > 0){\\n            if(s%2 != g%2) count++;\\n            s = s/2;\\n            g = g/2;\\n        }\\n        return count;\\n    }\\n};\\n```\\n```PsudoCode []\\nfunction minBitFlips(integer s, integer g){\\n\\tinitilize counter integer to 0\\n\\tloop until s or g is equal to zero{\\n\\t\\tif the s mod 2 and g mod 2 have the same remainder, increment counter\\n\\t\\tdivide s and g by 2 every pass\\n\\t}\\n\\treturn counter\\n}\\n```\\n\\n# PLEASE UPVOTE IF THIS HELPED YOU :)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Python []\\nclass Solution:\\n    def minBitFlips(self, s: int, g: int) -> int:\\n        count = 0 \\n        while s or g:\\n            if s%2 != g%2: count+=1\\n            s, g = s//2, g//2\\n        return count\\n```\n```Java []\\nclass Solution {\\n    public int minBitFlips(int s, int g) {\\n        int count = 0;\\n        while(s > 0 || g > 0){\\n            if(s%2 != g%2) count++;\\n            s = s/2;\\n            g = g/2;\\n        }\\n        return count;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minBitFlips(int s, int g) {\\n        int count = 0;\\n        while(s > 0 || g > 0){\\n            if(s%2 != g%2) count++;\\n            s = s/2;\\n            g = g/2;\\n        }\\n        return count;\\n    }\\n};\\n```\n```PsudoCode []\\nfunction minBitFlips(integer s, integer g){\\n\\tinitilize counter integer to 0\\n\\tloop until s or g is equal to zero{\\n\\t\\tif the s mod 2 and g mod 2 have the same remainder, increment counter\\n\\t\\tdivide s and g by 2 every pass\\n\\t}\\n\\treturn counter\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911547,
                "title": "builtin-popcount-start-goal",
                "content": "**C++**\\n```cpp\\nint minBitFlips(int start, int goal) {\\n    return __builtin_popcount(start ^ goal);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minBitFlips(int start, int goal) {\\n    return __builtin_popcount(start ^ goal);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1916182,
                "title": "c-easy-o-n-solution-basic-maths",
                "content": "**Please upvote if you find this solution helpful**\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    //we just check whether binary bit is equal or not \\n    //if it is we do nothing otherwise we flips the bit and increase the count\\n    int minBitFlips(int start, int goal) \\n    {   \\n        int flips=0;\\n\\t\\t\\n\\t\\t//iterate until both numbers get 0\\n        while(start || goal)\\n        {\\n\\t\\t\\t//check whether bits are equal or not, if not we flip the bit\\n            if(start%2 != goal%2)\\n                flips++;\\n            \\n            start /= 2;\\n            goal /= 2;\\n        }\\n        return flips;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //we just check whether binary bit is equal or not \\n    //if it is we do nothing otherwise we flips the bit and increase the count\\n    int minBitFlips(int start, int goal) \\n    {   \\n        int flips=0;\\n\\t\\t\\n\\t\\t//iterate until both numbers get 0\\n        while(start || goal)\\n        {\\n\\t\\t\\t//check whether bits are equal or not, if not we flip the bit\\n            if(start%2 != goal%2)\\n                flips++;\\n            \\n            start /= 2;\\n            goal /= 2;\\n        }\\n        return flips;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513711,
                "title": "c-java-javascript-easy-solution-beats-100-bit-manipulation",
                "content": "# Intuition\\n - Question -> Here given Two numbers. If both no. are represented in Binary then how many minimum bits are required to change in one no. so it convert into second no. \\n\\n*example* ->  \\n```\\n  10  =   1   0   (1)   0\\n  7   =   0   1   (1)   1\\n```\\nhere, 3 bits are different in both no.s and need to be change in one of them to covert into another.\\n\\n# Approach \\nHere, we have to identify the different bits so , XOR operator can help us -->\\n```                                     \\n                                         A | B | A XOR B\\n                                         0 | 0 |   0\\n      10   = 1  0  1  0                  0 | 1 |   1                \\n      7    = 0  1  1  1                  1 | 0 |   1   \\n____________________________             1 | 1 |   0\\nxor(10,7)  = 1  1  0  1\\n```\\nNow , We have to just count the Set Bits(1) in result of xor.\\n no.of Set bits = 3. So, There is minimum 3 flips required.\\n# Complexity\\n- Time complexity:\\n\\n   Best case - O(1)\\n   Worst Case - O(n)\\n\\n- Space complexity:\\n \\n   Constant Space - O(1)\\n\\n# Code\\n\\n- C++ Code ->\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n        int a = (start ^ goal); // this will do xor of given numbers\\n           //now count set bits\\n        int count = 0; \\n        while(a){\\n            if(a&1){\\n                count++;\\n            }\\n        a = a>>1;  // this is right shift operator\\n        }\\n        return count;\\n    }\\n};\\n```\\n- Java Code ->\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int a = (start ^ goal);\\n        int count = 0;\\n        \\n        while(a != 0) {\\n            if((a & 1) == 1) {\\n                count++;\\n            }\\n            \\n            a = a >> 1;\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n```\\n- JavaScript code ->\\n```\\nvar minBitFlips = function(start, goal) {\\n    let a = start ^ goal;\\n        let count = 0;\\n        \\n        while (a !== 0) {\\n            if (a & 1) {\\n                count++;\\n            }\\n            \\n            a = a >> 1;\\n        }\\n        \\n        return count;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n  10  =   1   0   (1)   0\\n  7   =   0   1   (1)   1\\n```\n```                                     \\n                                         A | B | A XOR B\\n                                         0 | 0 |   0\\n      10   = 1  0  1  0                  0 | 1 |   1                \\n      7    = 0  1  1  1                  1 | 0 |   1   \\n____________________________             1 | 1 |   0\\nxor(10,7)  = 1  1  0  1\\n```\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n        int a = (start ^ goal); // this will do xor of given numbers\\n           //now count set bits\\n        int count = 0; \\n        while(a){\\n            if(a&1){\\n                count++;\\n            }\\n        a = a>>1;  // this is right shift operator\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int a = (start ^ goal);\\n        int count = 0;\\n        \\n        while(a != 0) {\\n            if((a & 1) == 1) {\\n                count++;\\n            }\\n            \\n            a = a >> 1;\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n```\n```\\nvar minBitFlips = function(start, goal) {\\n    let a = start ^ goal;\\n        let count = 0;\\n        \\n        while (a !== 0) {\\n            if (a & 1) {\\n                count++;\\n            }\\n            \\n            a = a >> 1;\\n        }\\n        \\n        return count;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014986,
                "title": "java-solution-with-explaination",
                "content": "# Intuition\\nWe want to check how many bits need to flipped in the input number to get the output number. So we would need to check the bits which are different in both numbers (No point in counting bits which are same in both) and count them.\\n\\n# Approach\\nE.g. \\n10 = 1010\\n7  = 0111\\nso different bits are, from rightmost bit, 1st, 3rd and 4th. \\nWe know XOR operation between two numbers will give us these different bits.\\n\\n      1010\\n    ^ 0111\\n    ____________   \\n      1101\\nAs we see here, in the output number only bits are set which are different in both numbers. (1 ^ 1) = 0 and (1 ^ 0) = 1\\n\\nNow, we just have to count these set bits and for that we will use  Kernighan\\u2019s algorithm to find the number of set bits in a number. The idea behind the algorithm is that when we subtract one from an integer, all the bits following the rightmost set of bits are inverted, turning 1 to 0 and 0 to 1. The rightmost set bit also gets inverted with the bits right to it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        if(start == goal) return 0;\\n        int xor = start ^ goal;\\n        int counter=0;\\n        while(xor > 0) {\\n            xor = xor & (xor-1);\\n            counter++;\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        if(start == goal) return 0;\\n        int xor = start ^ goal;\\n        int counter=0;\\n        while(xor > 0) {\\n            xor = xor & (xor-1);\\n            counter++;\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260588,
                "title": "python-easy-interview-thinking",
                "content": "The given question requires us to count the total number of flips we need to do inorder to make `start -> goal`.\\nEx:  \\n7 - 0111\\n10 - 1010\\nHere, we only flip the bits which are different in both **start** and **goal**, i.e. `01` or `10`. And, what helps us to find if the bits are different? **XOR**. \\nNow, we count these bits (i.e. different bits). And how do we calculate the number of `1\\'s` in a number? `n & (n-1)` technique.\\n\\nSo, the number of flips required is **3**.\\n\\nTherefore, the solution is divided into two parts - identify the distinct bits in both numbers and then, count these bits.\\n\\nSolution:\\n```python\\nclass Solution(object):\\n    def minBitFlips(self, start, goal):\\n        res = start ^ goal\\n        cnt = 0\\n        while res:\\n            res &= res - 1\\n            cnt += 1\\n        return cnt\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```python\\nclass Solution(object):\\n    def minBitFlips(self, start, goal):\\n        res = start ^ goal\\n        cnt = 0\\n        while res:\\n            res &= res - 1\\n            cnt += 1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907288,
                "title": "python-solution-one-liner",
                "content": "**Just xor so we get 1 at places where bits are different and then count those bits.**\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        return (bin(start^goal).count(\"1\"))\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        return (bin(start^goal).count(\"1\"))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907216,
                "title": "c-easy-2-different-ways",
                "content": "We have to count all positions where the i\\'th bit of number **A** and **B** is different , so just iterate from bit 32 to 0 and check.\\n\\n```\\nclass Solution\\n{\\n    public:\\n        int minBitFlips(int start, int goal)\\n        {\\n            int cnt = 0;\\n            for (int i = 32; i >= 0; i--)\\n            {\\n\\t\\t\\t\\tint current = (1LL << i) & start;\\n                int required = (1LL << i) & goal;\\n                if (required != current)\\n                    cnt++;\\n            }\\n            return cnt;\\n        }\\n};\\n```\\n\\nAfter submitting , I realised that we can get different bit when we will do **XOR** of **A** and **B** \\nlike A = 101111\\nlike B = 110001\\nA^B  =  011110 , so just count how many ones in A^B , to count 1\\'s in a number we have a fucntion called **__builtin_popcount(N)** where N = A^B\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int A, int B) {\\n        return __builtin_popcount(A^B);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int minBitFlips(int start, int goal)\\n        {\\n            int cnt = 0;\\n            for (int i = 32; i >= 0; i--)\\n            {\\n\\t\\t\\t\\tint current = (1LL << i) & start;\\n                int required = (1LL << i) & goal;\\n                if (required != current)\\n                    cnt++;\\n            }\\n            return cnt;\\n        }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int A, int B) {\\n        return __builtin_popcount(A^B);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907471,
                "title": "c-0ms-solution-without-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n        while(start && goal){\\n            if(start%2!=goal%2) count++;\\n            start/=2;\\n            goal/=2;\\n        }\\n        while(start){\\n            if(start%2)count++;\\n            start/=2;\\n        }\\n        while(goal){\\n            if(goal%2)count++;\\n            goal/=2;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n        while(start && goal){\\n            if(start%2!=goal%2) count++;\\n            start/=2;\\n            goal/=2;\\n        }\\n        while(start){\\n            if(start%2)count++;\\n            start/=2;\\n        }\\n        while(goal){\\n            if(goal%2)count++;\\n            goal/=2;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526404,
                "title": "beats-100-easiest-code-using-inbuilt-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int ans=0;\\n        string s= bitset<32> (start).to_string();\\n        string str= bitset<32> (goal).to_string();\\n        for(int i=0;i<32;i++){\\n            if(s[i]!=str[i]) ans++;\\n        }\\n        return ans;\\n    }\\n};\\nDo UPVOTE\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int ans=0;\\n        string s= bitset<32> (start).to_string();\\n        string str= bitset<32> (goal).to_string();\\n        for(int i=0;i<32;i++){\\n            if(s[i]!=str[i]) ans++;\\n        }\\n        return ans;\\n    }\\n};\\nDo UPVOTE\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232519,
                "title": "curious-logic-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        s=bin(start)[2:].zfill(50)\\n        g=bin(goal)[2:].zfill(50)\\n        count=0\\n        for i in range(50):\\n            if s[i]!=g[i]:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        s=bin(start)[2:].zfill(50)\\n        g=bin(goal)[2:].zfill(50)\\n        count=0\\n        for i in range(50):\\n            if s[i]!=g[i]:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298518,
                "title": "cpp-ez-amazon-google-interview-o-set-bits",
                "content": "# ***UPVOTE PLZ  \\u2763***\\n# **Approach-1** Always takes O(N)\\nclass Solution {                        //O(N) soln.\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int c=0, i=0;\\n        while(start != goal){\\n            int mask=1<<i;\\n            if((start & mask) == (goal & mask))\\n                i++;\\n            else{\\n                start=start ^ mask;\\n                c++;\\n                i++;\\n            }    \\n        }\\n        return c;\\n    }\\n};\\n\\n# **Approach-2**   Faster :)\\nclass Solution {                         // O(No. of set bits in start^goal)\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int res = start ^ goal;\\n        int c=0;\\n        while(res!=0){\\n            res = res & (res-1);\\n            c++;\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {                        //O(N) soln.\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int c=0, i=0;\\n        while(start != goal){\\n            int mask=1<<i;\\n            if((start & mask) == (goal & mask))\\n                i++;\\n            else{\\n                start=start ^ mask;\\n                c++;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1910049,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn min_bit_flips(start: i32, goal: i32) -> i32 {\\n        (start ^ goal).count_ones() as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_bit_flips(start: i32, goal: i32) -> i32 {\\n        (start ^ goal).count_ones() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907429,
                "title": "c-easy-and-operation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n        int res(0);\\n        for (int i=32; ~i; i--) {\\n            if ((start & 1) != (goal & 1))  res++;\\n            start >>= 1; goal >>= 1;\\n        }\\n        return res;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n        int res(0);\\n        for (int i=32; ~i; i--) {\\n            if ((start & 1) != (goal & 1))  res++;\\n            start >>= 1; goal >>= 1;\\n        }\\n        return res;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906980,
                "title": "easy-approach-o-n-time-no-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int ans = 0;\\n        while(start && goal) { \\n            if(start%2 != goal%2)\\n                ans++;\\n            start /= 2;\\n            goal /= 2;\\n        } \\n        while(start) { \\n            if(start%2)\\n                ans++;\\n            start /= 2;\\n        } \\n        while(goal) { \\n            if(goal%2)\\n                ans++;   \\n            goal /= 2;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int ans = 0;\\n        while(start && goal) { \\n            if(start%2 != goal%2)\\n                ans++;\\n            start /= 2;\\n            goal /= 2;\\n        } \\n        while(start) { \\n            if(start%2)\\n                ans++;\\n            start /= 2;\\n        } \\n        while(goal) { \\n            if(goal%2)\\n                ans++;   \\n            goal /= 2;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608176,
                "title": "0ms-solution-bit-manipulation",
                "content": "# Intuition\\nJust try to make the $start$ equals to $goal$ using $Bit Manipulations$.\\n\\n# Approach\\nIf the $goal$ bit is **set**, check if the $start$ bit is **set**, if not increase the count, as we will use one $flip$ operation.\\n\\nIf the $goal$ bit is **unset**, check if the $start$ bit is **unset**, if not increase the count, as we will use one $flip$ operation \\n\\n# Complexity\\n- Time complexity: $$O(log(max(start, goal)))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int cnt = 0;\\n        while(goal || start)\\n        {\\n            bool goalBit = (goal&1);\\n            bool startBit = (start&1);\\n            if(goalBit)\\n            {\\n                if(startBit)\\n                {\\n                    // Do Nothing\\n                }\\n                else\\n                {\\n                    cnt++;\\n                }\\n            }\\n            else\\n            {\\n                if(startBit)\\n                {\\n                    cnt++;\\n                }\\n                else\\n                {\\n                    // Do Nothing\\n                }\\n            }\\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n# Follow up Question:\\nhttps://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/\\n**My Solution:** https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/solutions/3607616/0ms-solution-bit-manipulation/",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int cnt = 0;\\n        while(goal || start)\\n        {\\n            bool goalBit = (goal&1);\\n            bool startBit = (start&1);\\n            if(goalBit)\\n            {\\n                if(startBit)\\n                {\\n                    // Do Nothing\\n                }\\n                else\\n                {\\n                    cnt++;\\n                }\\n            }\\n            else\\n            {\\n                if(startBit)\\n                {\\n                    cnt++;\\n                }\\n                else\\n                {\\n                    // Do Nothing\\n                }\\n            }\\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471702,
                "title": "kernighan-s-algorithm-easy-to-understand-with-explaination",
                "content": "\\n\\n\\n    class Solution {\\n    public:\\n    int minBitFlips(int start, int goal) {\\n        int cnt=0;\\n        \\n        // # Here we get he number if set bits which are required for getting our goal number\\n        int set=start^goal;\\n        \\n        // # kernighan\\'s algo for finding no of set bits\\n        while(set!=0){\\n            \\n            // # a mask in which only right most bit is set\\n            int rsb=(set&(-set));\\n            set=set-rsb;\\n            cnt++;\\n        }\\n         return cnt;\\n     }\\n    };",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    public:\\n    int minBitFlips(int start, int goal) {\\n        int cnt=0;\\n        \\n        // # Here we get he number if set bits which are required for getting our goal number\\n        int set=start^goal;\\n        \\n        // # kernighan\\'s algo for finding no of set bits\\n        while(set!=0){\\n            \\n            // # a mask in which only right most bit is set\\n            int rsb=(set&(-set));\\n            set=set-rsb;\\n            cnt++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3222968,
                "title": "easy-and-understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly On Reading The Problem, We have to find How Many Bits \\nAre Different in **start** And **goal**.\\n\\nfor finding How many different bits,we use X-OR Gate .(0^1=1 and 1^0=1)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**_step1_** : find x-or of start and goal\\n**_step2_** : now find no.of set bits (i.e., no.of 1s) in xOredResult.\\n             (this is becuase \\'1\\' in xOredResult denotes the bits          are         different,so we have to flip them) \\n**_step3_** : the no.of set bits gives the no.of bits to flip actually\\n\\n(Read $$Brian-Kerninghan algorithm$$ to count no.of set bits in a particular number) \\n\\n# Complexity\\n- Time complexity: $$O(logn)$$ where \\'n\\' is the number whose set bits need to     be calculated\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n**Please upvote my solution if you really liked it**\\n\\n# Code\\n```\\nclass Solution {\\n    private int count = 0;\\n    public int minBitFlips(int start, int goal) {\\n\\n        // Find X-OR of start and goal to know no.of different bits\\n        int xOredResult = (start^goal);\\n\\n        // now Count no.of SetBits in xOredResult\\n        // using Brian-Kerninghan Algorithm\\n        return brianKerninghanAlgo(xOredResult);\\n    }\\n    public  int brianKerninghanAlgo(int num)\\n    {\\n        while(num != 0)\\n        {\\n            num&=(num-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    private int count = 0;\\n    public int minBitFlips(int start, int goal) {\\n\\n        // Find X-OR of start and goal to know no.of different bits\\n        int xOredResult = (start^goal);\\n\\n        // now Count no.of SetBits in xOredResult\\n        // using Brian-Kerninghan Algorithm\\n        return brianKerninghanAlgo(xOredResult);\\n    }\\n    public  int brianKerninghanAlgo(int num)\\n    {\\n        while(num != 0)\\n        {\\n            num&=(num-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527196,
                "title": "java-easy-solution-using-kernighan-s-algorithm",
                "content": "First we find xor of the two input numbers and count the number of set bits in the result using kernighan\\'s algorithm\\n\\nhere result=start^goal\\n\\nkernighan\\'s algorithm-\\n\\nIn a loop till the result > 0\\nStep 1 increase the count by 1\\nStep 2 result=result xor (result - 1)\\n\\n\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int n=start^goal,c=0;\\n        while(n>0)\\n        {\\n            n&=(n-1);\\n            c+=1;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int n=start^goal,c=0;\\n        while(n>0)\\n        {\\n            n&=(n-1);\\n            c+=1;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2379732,
                "title": "one-liner-python",
                "content": "\\n```\\nreturn(start^goal).bit_count()\\n```\\n**Please upvote if you want to see more one liners and simple solutions**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nreturn(start^goal).bit_count()\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2153745,
                "title": "c-solution-well-explained-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n     // Function to count the set bits\\n    int countSetBits(int n)\\n    {\\n        int count = 0;\\n        while(n > 0){\\n            n &= (n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n    int minBitFlips(int start, int goal) {\\n        \\n        return countSetBits(start ^ goal); // start ^ goal : gives the differenciating bits\\n        \\n    }\\n};\\n```\\n\\n**Liked it ? Do upvote it, it do motivates !**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     // Function to count the set bits\\n    int countSetBits(int n)\\n    {\\n        int count = 0;\\n        while(n > 0){\\n            n &= (n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n    int minBitFlips(int start, int goal) {\\n        \\n        return countSetBits(start ^ goal); // start ^ goal : gives the differenciating bits\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984124,
                "title": "python-solution-hamming-distance-based-one-liner",
                "content": "## Hamming Distance\\nHamming Distance between two integers is the number of bits that are different at the same position in both numbers. \\n\\nAlgorithm\\n- XOR the numbers\\n- Count set bits (1)\\n\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        return bin(start ^ goal).count(\"1\")\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        return bin(start ^ goal).count(\"1\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935603,
                "title": "c-simple-xor-operation-100-faster",
                "content": "```\\n//let start = 1101\\n//goal      = 1000\\n// Xor      = 0101\\n//NUmber of set bits in Xor\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) \\n    {\\n        int xorr = start xor goal;\\n        unsigned int ans=0;\\n        //Count number of bits to be flipped\\n        while(xorr)\\n        {\\n           ans++;\\n           xorr = xorr&(xorr-1);// Brian Kernighan\\'s Algorithm to count set bit;\\n        }\\n        return ans;\\n    }\\n};\\n//Please Do Upvote \\n//If you find Anything Incorrect or have doubt drop it down;",
                "solutionTags": [
                    "Counting"
                ],
                "code": "class Solution {\\npublic:\\n    int minBitFlips(int start, int goal) \\n    {\\n        int xorr = start xor goal;\\n        unsigned int ans=0;\\n        //Count number of bits to be flipped\\n        while(xorr)\\n        {\\n           ans++;\\n           xorr = xorr&(xorr-1);// Brian Kernighan\\'s Algorithm to count set bit;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1909597,
                "title": "bits-manipulation-xor",
                "content": "```\\nclass Solution {\\n\\tpublic static int minBitFlips(int a1, int a2) {\\n\\t\\tint n = (a1 ^ a2);\\n\\t\\tint res = 0;\\n\\t\\twhile (n != 0) {\\n\\t\\t\\tres++;\\n\\t\\t\\tn &= (n - 1);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic static int minBitFlips(int a1, int a2) {\\n\\t\\tint n = (a1 ^ a2);\\n\\t\\tint res = 0;\\n\\t\\twhile (n != 0) {\\n\\t\\t\\tres++;\\n\\t\\t\\tn &= (n - 1);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907384,
                "title": "c-xor-builtinpop-count",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1.\\n\\nXOR sets the bits that are different between `start` and `goal`, and unsets bits that are the same.\\n\\n`__builtin_popcount(mask)` counts the `1`s in `mask`.\\n\\nExample:\\n\\nExpression | Value\\n---|--\\nstart|      `0011010`\\ngoal|       `0101100`\\nstart^goal| `0110110`\\n__builtin_popcount(start^goal) | 4\\n\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/\\n// Author: github.com/lzl124631x\\n// Time: O(1)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start ^ goal);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/\\n// Author: github.com/lzl124631x\\n// Time: O(1)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start ^ goal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907134,
                "title": "bitwise-easiest-logic-complexity-analysis-c",
                "content": "## **Solution**\\n\\n\\n#### **LOGIC**\\n* This is simpliy asking about [Hamming distance](https://en.wikipedia.org/wiki/Hamming_distance)\\n* Take [XOR](https://en.wikipedia.org/wiki/Exclusive_or), because it will set bit to 1 only when both bits are different\\n* Then simply count the bits\\n\\n\\n#### **Code**  \\n```cpp\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int a = start ^ goal;\\n        int sol = 0;\\n        \\n        while (a > 0) {\\n            sol += a & 1;\\n            a >>= 1;\\n        }\\n        \\n        return sol;\\n    }\\n};\\n```\\n\\n## **Complexity**\\n\\n##### __Apporach : 1__  \\n##### Time Complexity:  **O(floor(log10(n) + 1))**, where is ```n``` is ```max(start, goal)```.\\n\\n##### Space Complexity: **O(1)**\\n\\n\\n<br>\\n\\n __Check out all [my](https://leetcode.com/siddp6/) recent solutions [here](https://github.com/sidd6p/LeetCode)__\\n\\n \\n __Feel Free to Ask Doubts\\nAnd Please Share Some Suggestions\\nHAPPY CODING :)__\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int a = start ^ goal;\\n        int sol = 0;\\n        \\n        while (a > 0) {\\n            sol += a & 1;\\n            a >>= 1;\\n        }\\n        \\n        return sol;\\n    }\\n};\\n```\n```n```\n```max(start, goal)```",
                "codeTag": "Java"
            },
            {
                "id": 3821164,
                "title": "2220-java-bit-manipulation-100-efficient",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int mask=(1<<i);\\n            if(((start & mask)==0 && (goal & mask)!=0) || ((start & mask)!=0 && (goal & mask)==0))\\n                count++;\\n\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int mask=(1<<i);\\n            if(((start & mask)==0 && (goal & mask)!=0) || ((start & mask)!=0 && (goal & mask)==0))\\n                count++;\\n\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613891,
                "title": "java-bit-manipulation-beats-100-kernighan-s-algorithm-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing XOR operator the bits that are different will become 1 and same bits will become 0 . After that we just need to count the number of 1\\'s using the Kernighan\\'s Algorithm.\\n\\n# Approach\\n\\nFirst we store the XOR operator result in n and then we initialize a counter with 0 . Now we loop until the n!=0 and inside the loop we are initializing rsbm (right most set bit mask ) for the n. And after that we subtract the rightmost set bit from n using n -= rsbm. This clears the rightmost set bit from n. The counter variable is incremented by 1. At last we return counter .\\n\\n# Complexity\\n- Time complexity:\\n    O(Log(n))\\n\\n- Space complexity:\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int n = start^goal;\\n        int counter = 0;\\n       \\n        while(n!=0){\\n            int rsbm = n & -n;\\n            n -= rsbm;\\n            counter++;\\n        }\\n\\n        return counter;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int n = start^goal;\\n        int counter = 0;\\n       \\n        while(n!=0){\\n            int rsbm = n & -n;\\n            n -= rsbm;\\n            counter++;\\n        }\\n\\n        return counter;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193970,
                "title": "c-easy-100-acceptance",
                "content": "<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int s,g,cnt=0;\\n        while(start!=goal){\\n            s=start&1;\\n            g=goal&1;\\n            if(s!=g)\\n                cnt++;\\n                start=start>>1;\\n                goal=goal>>1;\\n        }\\n    return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int s,g,cnt=0;\\n        while(start!=goal){\\n            s=start&1;\\n            g=goal&1;\\n            if(s!=g)\\n                cnt++;\\n                start=start>>1;\\n                goal=goal>>1;\\n        }\\n    return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2896646,
                "title": "c-simple-solution-with-explanation",
                "content": "**Please upvote if my solution was helpful ;)**\\n# Explanation\\nExample: start = 10, goal = 7, in binary representation are 1010 and 0111 respectively\\n\\n![dsadasdasd.png](https://assets.leetcode.com/users/images/d3e73bbc-7534-452f-8f32-999d0fc8f029_1670664733.3221765.png)\\n\\n\\n1101 is a result of XOR operation - result = start^goal. Answer is a count of \"1\" bits in result.\\n\\n# Algorithm\\n1) Initialize \"result\" as a start^goal (xor operation)\\n2) Count \"1\" bits in result and return it\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int MinBitFlips(int start, int goal)\\n    {\\n        int result = start^goal;\\n        int output = 0;\\n        while(result > 0)\\n        {\\n            if((result & 1) == 1) output++;\\n            result = result>>1;\\n        }\\n        return output;\\n    }\\n}\\n```\\n# Code 2(memory optimization)\\n\\nIn the code below we are using method parameters start and goal as a local variables \\n\\n```\\npublic class Solution \\n{\\n    public int MinBitFlips(int start, int goal)\\n    {\\n        start = start^goal;\\n        goal = 0;\\n        while(start > 0)\\n        {\\n            if((start & 1) == 1) goal++;\\n            start = start>>1;\\n        }\\n        return goal;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int MinBitFlips(int start, int goal)\\n    {\\n        int result = start^goal;\\n        int output = 0;\\n        while(result > 0)\\n        {\\n            if((result & 1) == 1) output++;\\n            result = result>>1;\\n        }\\n        return output;\\n    }\\n}\\n```\n```\\npublic class Solution \\n{\\n    public int MinBitFlips(int start, int goal)\\n    {\\n        start = start^goal;\\n        goal = 0;\\n        while(start > 0)\\n        {\\n            if((start & 1) == 1) goal++;\\n            start = start>>1;\\n        }\\n        return goal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846834,
                "title": "easiest-solution-c-plus-plus-one-pass-100-ac-bitset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        string str = bitset<32>(start).to_string();\\n        string str2 = bitset<32>(goal).to_string();\\n        int count = 0;\\n        for(int i=0;i<32;i++) if(str[i]!=str2[i]) count++;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        string str = bitset<32>(start).to_string();\\n        string str2 = bitset<32>(goal).to_string();\\n        int count = 0;\\n        for(int i=0;i<32;i++) if(str[i]!=str2[i]) count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742496,
                "title": "xor-1-line-code",
                "content": "\\'\\'\\'\\nclass Solution \\n{\\n public:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n\\'\\'\\'\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution \\n{\\n public:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2689315,
                "title": "100-faster-javascript",
                "content": "```\\n/**\\n * @param {number} start\\n * @param {number} goal\\n * @return {number}\\n */\\nvar minBitFlips = function(n, p) {\\n    let count = 0;\\nwhile (p != 0 || n!=0)\\n{\\n    let d = p & 1;\\n    let f = n & 1;\\n    if(d!=f)\\n    {\\n        count++;\\n    }\\n    n=n >> 1;\\n    p = p >> 1;\\n}\\n       return count; \\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} start\\n * @param {number} goal\\n * @return {number}\\n */\\nvar minBitFlips = function(n, p) {\\n    let count = 0;\\nwhile (p != 0 || n!=0)\\n{\\n    let d = p & 1;\\n    let f = n & 1;\\n    if(d!=f)\\n    {\\n        count++;\\n    }\\n    n=n >> 1;\\n    p = p >> 1;\\n}\\n       return count; \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2658238,
                "title": "most-efficient-c-solution-using-bitset-o-32-constant-time",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        bitset<32> bs1(start);\\n        bitset<32> bs2(goal);\\n        int cnt=0;\\n        for(int i=0;i<32;i++){\\n            if(bs1[i]!=bs2[i]){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        bitset<32> bs1(start);\\n        bitset<32> bs2(goal);\\n        int cnt=0;\\n        for(int i=0;i<32;i++){\\n            if(bs1[i]!=bs2[i]){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614337,
                "title": "xor-python",
                "content": "```\\ndef minBitFlips(self, start: int, goal: int) -> int:\\n        \\n        n = start ^ goal \\n        count = 0\\n\\n        #counting set bits\\n        while n:\\n            n = n & (n-1) \\n            count += 1\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minBitFlips(self, start: int, goal: int) -> int:\\n        \\n        n = start ^ goal \\n        count = 0\\n\\n        #counting set bits\\n        while n:\\n            n = n & (n-1) \\n            count += 1\\n\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2595426,
                "title": "java-bit-manipulation-1-line-code-simple-solution",
                "content": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        return Integer.bitCount(start^goal);\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        return Integer.bitCount(start^goal);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548154,
                "title": "3ms-space-95-beats-c-simple-easy-bit-count",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int &start, int &goal) {\\n        int ans = 0;\\n        start = start ^ goal;\\n        while(start){\\n            ans += (start&1);\\n            start = start >> 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int &start, int &goal) {\\n        int ans = 0;\\n        start = start ^ goal;\\n        while(start){\\n            ans += (start&1);\\n            start = start >> 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421145,
                "title": "minimum-bit-flips-to-convert-number",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int x=start^goal;\\n        return __builtin_popcount(x);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int x=start^goal;\\n        return __builtin_popcount(x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053637,
                "title": "java-solution",
                "content": "```java class Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int c=0;\\n       while(start!=0||goal!=0)\\n       {\\n           if(start%2!=goal%2)\\n               c++;\\n           start/=2;\\n           goal/=2;\\n       }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int c=0;\\n       while(start!=0||goal!=0)\\n       {\\n           if(start%2!=goal%2)\\n               c++;\\n           start/=2;\\n           goal/=2;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 1910645,
                "title": "here-is-my-solution-using-bitset-c-easy-to-understand",
                "content": "Using ```std::bitset``` Class to Convert Decimal Number to Binary in C++\\n\\n```\\nint minBitFlips(int start, int goal) {  // start=10 , goal=7 \\n\\t\\t\\n\\t\\t// binary representation of 10 is 1010\\n\\t\\t// binary representation of 7 is 0111\\n\\t\\tbitset<32> bs1(start);    // bs1 = 00000000000000000000000000001010 \\n\\t\\tbitset<32> bs2(goal);     // bs2 = 00000000000000000000000000000111\\n\\t\\t\\n\\t\\tint count=0;\\n\\t\\tfor(int i=0; i<32; i++){\\n\\t\\t\\tif(bs1[i]!=bs2[i]){  \\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}    \\n\\t\\t}\\n\\t\\t\\n\\t\\treturn count;\\n}\\n```\\n\\t\\n\\t\\n\\t",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```std::bitset```\n```\\nint minBitFlips(int start, int goal) {  // start=10 , goal=7 \\n\\t\\t\\n\\t\\t// binary representation of 10 is 1010\\n\\t\\t// binary representation of 7 is 0111\\n\\t\\tbitset<32> bs1(start);    // bs1 = 00000000000000000000000000001010 \\n\\t\\tbitset<32> bs2(goal);     // bs2 = 00000000000000000000000000000111\\n\\t\\t\\n\\t\\tint count=0;\\n\\t\\tfor(int i=0; i<32; i++){\\n\\t\\t\\tif(bs1[i]!=bs2[i]){  \\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}    \\n\\t\\t}\\n\\t\\t\\n\\t\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909725,
                "title": "xor-bit-counting",
                "content": "**C++:**\\n**Brian Kernighan\\u2019s algorithm to count set bits:**\\n```\\nint minBitFlips(int n, int m)\\n{\\n\\tint out{};\\n\\tfor(n^=m; n; n=n&(n-1), out++);\\n\\treturn out;\\n}\\n```\\nor\\n**builtins:**\\n```\\nint minBitFlips(int n, int m)\\n{\\n\\treturn __builtin_popcount(n^m);            \\n}\\n```\\nsince `c++20` it would be possible to do this:\\n```\\nint minBitFlips(int n, int m)\\n{\\n\\treturn popcount(n^m);            \\n}\\n```\\n**Python3:**\\n```\\ndef minBitFlips(self, n, m):\\n\\treturn (n^m).bit_count()\\n```\\nor\\n**Python:**\\n```\\ndef minBitFlips(self, n, m):\\n\\treturn bin(n^m).count(\\'1\\')\\n```\\n**JS:**\\n```\\nvar minBitFlips = (n, m) => (n^m).toString(2).replace(/0/g,\"\").length;\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nint minBitFlips(int n, int m)\\n{\\n\\tint out{};\\n\\tfor(n^=m; n; n=n&(n-1), out++);\\n\\treturn out;\\n}\\n```\n```\\nint minBitFlips(int n, int m)\\n{\\n\\treturn __builtin_popcount(n^m);            \\n}\\n```\n```\\nint minBitFlips(int n, int m)\\n{\\n\\treturn popcount(n^m);            \\n}\\n```\n```\\ndef minBitFlips(self, n, m):\\n\\treturn (n^m).bit_count()\\n```\n```\\ndef minBitFlips(self, n, m):\\n\\treturn bin(n^m).count(\\'1\\')\\n```\n```\\nvar minBitFlips = (n, m) => (n^m).toString(2).replace(/0/g,\"\").length;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1909245,
                "title": "python-without-built-in-function-and-bit-manipulation",
                "content": "* convert integer to binary\\n* padding \\'0\\' for shorter binary\\n* compare every bits and count not matched cases\\n\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:       \\n        s = bin(start)[2:]\\n        g = bin(goal)[2:]\\n        \\n        if len(s) > len(g):\\n            g = (len(s) - len(g)) * \\'0\\' + g\\n        elif len(g) > len(s):\\n            s = (len(g) - len(s)) * \\'0\\' + s\\n        \\n        res = 0\\n        \\n        for i in range(len(s)):\\n            if s[i] != g[i]:\\n                res += 1\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:       \\n        s = bin(start)[2:]\\n        g = bin(goal)[2:]\\n        \\n        if len(s) > len(g):\\n            g = (len(s) - len(g)) * \\'0\\' + g\\n        elif len(g) > len(s):\\n            s = (len(g) - len(s)) * \\'0\\' + s\\n        \\n        res = 0\\n        \\n        for i in range(len(s)):\\n            if s[i] != g[i]:\\n                res += 1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907560,
                "title": "python-readable-long",
                "content": "when you dont know rjust , lol. At least i solved it myself\\n\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        \\n        binstart = bin(start)[2:]\\n        bingoal = bin(goal)[2:]\\n        \\n        count= 0\\n        \\n        mini = min(len(binstart), len(bingoal))\\n        \\n        if len(binstart) < len(bingoal):\\n            diff = abs(len(bingoal) - len(binstart))\\n            binstart = diff * \\'0\\' + binstart\\n        else:\\n            diff = abs(len(bingoal) - len(binstart))\\n            bingoal = diff * \\'0\\' + bingoal\\n            \\n            \\n        binstart = list(binstart)\\n        bingoal = list(bingoal)\\n        for i in range(len(binstart)-1,-1,-1):\\n            \\n            if binstart[i] != bingoal[i]:\\n                binstart[i] = str(int(binstart[i]) ^ int(bingoal[i]))\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        \\n        binstart = bin(start)[2:]\\n        bingoal = bin(goal)[2:]\\n        \\n        count= 0\\n        \\n        mini = min(len(binstart), len(bingoal))\\n        \\n        if len(binstart) < len(bingoal):\\n            diff = abs(len(bingoal) - len(binstart))\\n            binstart = diff * \\'0\\' + binstart\\n        else:\\n            diff = abs(len(bingoal) - len(binstart))\\n            bingoal = diff * \\'0\\' + bingoal\\n            \\n            \\n        binstart = list(binstart)\\n        bingoal = list(bingoal)\\n        for i in range(len(binstart)-1,-1,-1):\\n            \\n            if binstart[i] != bingoal[i]:\\n                binstart[i] = str(int(binstart[i]) ^ int(bingoal[i]))\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907201,
                "title": "very-easy-solution",
                "content": "class Solution {\\npublic:\\n    \\n    int countSetBits(int n)\\n{\\n    int count = 0;\\n    while (n > 0)\\n    {\\n        count++;\\n        n &= (n-1);\\n    }\\n    return count;\\n}\\n \\n\\n\\n    int minBitFlips(int start, int goal) {\\n            return countSetBits(start^goal);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int countSetBits(int n)\\n{\\n    int count = 0;\\n    while (n > 0)\\n    {\\n        count++;\\n        n &= (n-1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1907079,
                "title": "using-xor-operation-4-lines-of-code-only-cpp-solution-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        bitset<32>str = start; //Converting into bits\\n \\xA0 \\xA0 \\xA0 \\xA0bitset<32>end= goal; \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 bitset<32>res = str^end; // Applying XOR operation\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0return res.count(); // returning the number of flips\\n\\n    }\\n};\\n```\\n**Please upvote if you find this helpful**\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        bitset<32>str = start; //Converting into bits\\n \\xA0 \\xA0 \\xA0 \\xA0bitset<32>end= goal; \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 bitset<32>res = str^end; // Applying XOR operation\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0return res.count(); // returning the number of flips\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907070,
                "title": "javascript-easy-solution-xor",
                "content": "```\\n/**\\n * @param {number} start\\n * @param {number} goal\\n * @return {number}\\n */\\nvar minBitFlips = function(start, goal) {\\n    let orVal = start ^ goal;\\n    \\n    let cnt = 0;\\n    while (orVal > 0) {\\n        cnt++;\\n        orVal &= (orVal-1);\\n    }\\n    \\n    return cnt;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * @param {number} start\\n * @param {number} goal\\n * @return {number}\\n */\\nvar minBitFlips = function(start, goal) {\\n    let orVal = start ^ goal;\\n    \\n    let cnt = 0;\\n    while (orVal > 0) {\\n        cnt++;\\n        orVal &= (orVal-1);\\n    }\\n    \\n    return cnt;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907055,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int fun(int a)\\n    {\\n    int count = 0;\\n    while (a > 0)\\n    {\\n        count++;\\n        a &= (n-1);\\n    }\\n    return count;\\n    }\\n    int minBitFlips(int start, int goal) {\\n        return c(start^goal);\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(int a)\\n    {\\n    int count = 0;\\n    while (a > 0)\\n    {\\n        count++;\\n        a &= (n-1);\\n    }\\n    return count;\\n    }\\n    int minBitFlips(int start, int goal) {\\n        return c(start^goal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906973,
                "title": "java-one-line-with-math",
                "content": "Count diff of binary string, xor is for the work\\n\\n```\\n^ 0 1 \\n0 0 1\\n1 1 0\\n```\\n\\nTime: O(1)\\nSpace: O(1)\\n\\n```\\nclass Solution {\\n  public int minBitFlips(int start, int goal) {\\n    return Integer.bitCount(start ^ goal);\\n  }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n^ 0 1 \\n0 0 1\\n1 1 0\\n```\n```\\nclass Solution {\\n  public int minBitFlips(int start, int goal) {\\n    return Integer.bitCount(start ^ goal);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063019,
                "title": "1-line-solution-beats-100-0-ms",
                "content": "# Intuition\\nThe problem is asking to find the minimum number of bit flips required to convert one integer to another. The intuition here is that the bits that need to be flipped are exactly the ones that differ in the two numbers. \\n\\n# Approach\\nThe approach to solve this problem is as follows:\\n1. Compute the XOR of the two numbers. The XOR operation will give a binary number where each bit is 1 if the corresponding bits in the two numbers are different, and 0 if they are the same.\\n2. Count the number of set bits (bits that are 1) in the result. This can be done using the `__builtin_popcount` function in C++. Each set bit represents a position where the two numbers differ, so flipping this bit in one number will make it match the corresponding bit in the other number.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\nThe time complexity is constant because XOR and bit count operations take constant time for integers.\\n\\n- Space complexity: $$O(1)$$\\nThe space complexity is also constant because only a fixed amount of space is needed to store the input numbers and intermediate results.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923042,
                "title": "java-simple-solution-runtime-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int cnt = 0;\\n        while(start != goal){\\n            if((goal & 1) != (start & 1)){\\n                start ^= 1;\\n                cnt++;\\n            }\\n            goal >>= 1;\\n           start >>= 1;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int cnt = 0;\\n        while(start != goal){\\n            if((goal & 1) != (start & 1)){\\n                start ^= 1;\\n                cnt++;\\n            }\\n            goal >>= 1;\\n           start >>= 1;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810023,
                "title": "one-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we know that xor only returns 1 when both theb numbers have a differnce in their respective digits. Therefore we will simply XOR both the numbers and later count the number of set bits in the result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755070,
                "title": "easy-o-1-space",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int a, int b) {\\n        int count = 0;\\n\\n    while (a > 0 and b > 0)\\n    {\\n        if ((a & 1) != (b & 1))\\n        {\\n            count++;\\n        }\\n        a >>= 1;\\n        b >>= 1;\\n    }\\n\\n    while (a)\\n    {\\n        if (a & 1)\\n        {\\n            count++;\\n        }\\n        a >>= 1;\\n    }\\n\\n    while (b)\\n    {\\n        if (b & 1)\\n        {\\n            count++;\\n        }\\n        b >>= 1;\\n    }\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int a, int b) {\\n        int count = 0;\\n\\n    while (a > 0 and b > 0)\\n    {\\n        if ((a & 1) != (b & 1))\\n        {\\n            count++;\\n        }\\n        a >>= 1;\\n        b >>= 1;\\n    }\\n\\n    while (a)\\n    {\\n        if (a & 1)\\n        {\\n            count++;\\n        }\\n        a >>= 1;\\n    }\\n\\n    while (b)\\n    {\\n        if (b & 1)\\n        {\\n            count++;\\n        }\\n        b >>= 1;\\n    }\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753222,
                "title": "simple-basic-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int a, int b) {\\n        int count=0;\\n    while (a > 0 || b > 0) {\\n \\n        int t1 = (a & 1);\\n        int t2 = (b & 1);\\n \\n        if (t1 != t2) {\\n            count++;\\n        }\\n        // right shifting a and b\\n        a >>= 1;\\n        b >>= 1;\\n    }\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int a, int b) {\\n        int count=0;\\n    while (a > 0 || b > 0) {\\n \\n        int t1 = (a & 1);\\n        int t2 = (b & 1);\\n \\n        if (t1 != t2) {\\n            count++;\\n        }\\n        // right shifting a and b\\n        a >>= 1;\\n        b >>= 1;\\n    }\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724804,
                "title": "one-of-the-most-easiest-solutions",
                "content": "# Intuition\\nWe need to just count to total number of different bits of `start` and `end`.\\n\\n# Approach\\nFind `XOR` of `start` and `end` and then count 1. Because after `XOR` any two value, we get 1 only when where the bit is different.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count = 0;\\n\\n        long long diffBits = start ^ goal;\\n        while(diffBits != 0){\\n            if(diffBits & 1) count++;\\n            diffBits >>= 1;\\n        }\\n\\n        return count;\\n    }\\n};\\n```\\n\\n**Please upvote if you really like the approach. \\uD83D\\uDC4D\\uD83C\\uDFFB**\\n\\nCheckout my GitHub repo: [GitHub](https://github.com/RiyaadHossain/LeetCode-Problem)",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count = 0;\\n\\n        long long diffBits = start ^ goal;\\n        while(diffBits != 0){\\n            if(diffBits & 1) count++;\\n            diffBits >>= 1;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607182,
                "title": "100-c-most-easy-solution-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) \\n    {\\n        int ans=0;\\n        string s= bitset<32>(start).to_string();\\n        string str= bitset<32> (goal).to_string();\\n        for(int i=0;i<32;i++)\\n        {\\n            if(s[i]!=str[i]) \\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) \\n    {\\n        int ans=0;\\n        string s= bitset<32>(start).to_string();\\n        string str= bitset<32> (goal).to_string();\\n        for(int i=0;i<32;i++)\\n        {\\n            if(s[i]!=str[i]) \\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483816,
                "title": "c-100-beat-using-bit-manipulation-way",
                "content": "# Intuition\\nEasy way to play with bit Manipulation way.\\n\\n# Approach\\n- take a variable and store in it xor of start and goal ex\\n`int a=start ^ goal;`\\n- count number of 1 bit in this number `while(a)\\n{ if(a&1)ans++;\\na>>=1;}`\\n- return the count;\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Please upvote my work\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int a=start ^ goal;\\n        int ans=0;\\n        while(a)\\n       { if(a&1)ans++;\\n        a>>=1;}\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int a=start ^ goal;\\n        int ans=0;\\n        while(a)\\n       { if(a&1)ans++;\\n        a>>=1;}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456503,
                "title": "bit-manipulation-using-rsb-mask-easiest-solution-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n        int ans=start^goal;\\n        int cnt=0;\\n        while(ans){\\n            int rsb=ans&(-ans);\\n            ans=ans-rsb;\\n            cnt++;\\n        }\\n        return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n        int ans=start^goal;\\n        int cnt=0;\\n        while(ans){\\n            int rsb=ans&(-ans);\\n            ans=ans-rsb;\\n            cnt++;\\n        }\\n        return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443196,
                "title": "java-easy-solution-beats-100-using-bit-manipulation-asked-in-persistent-systems",
                "content": "# Intuition\\nBasically we have to find the count of bits which are different in both given start and goal variables.\\nFor e.g. - start = 4 and goal = 7 \\nNow lets look at their Binary representation as we\\'ve to find the number of bits after all.\\nstart= 4 -> 1 0 0\\ngoal = 7 -> 1 1 1\\nxor  = ^ -> 0 1 1 ( Total set bits(1\\'s) represents the bit difference between the given two numbers)\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo, we get the number of bits which are different in both the variables after xor.\\nHere we get xor = 3 .\\nSo, then we\\'ll just count the set bits of xor and return it as our answer.\\n\\nWe use one of the most effective method to count the set bits i.e.,\\n**n & (n-1)** \\nIn our case we have xor in place of n.\\nSo, **xor % (xor-1)**\\nE.g., 3&(3-1) = 3&2 = 2\\nthen 2&(2-1) = 2&1 = 0\\n\\n---\\n\\n# Complexity\\n- Time complexity:\\nO(log N)\\n\\n- Space complexity:\\nO(1)\\n\\n---\\n\\n\\n**Hope it helps, Happy LeetCoding{^_^}**\\n\\n---\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int xor = (start^goal);\\n        int count = 0;\\n        while(xor!=0) {\\n            count++;\\n            xor = xor & (xor-1);\\n        }\\n        return count;\\n    }\\n}\\n```\\n---",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int xor = (start^goal);\\n        int count = 0;\\n        while(xor!=0) {\\n            count++;\\n            xor = xor & (xor-1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342937,
                "title": "0-ms-100-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n      int n=start^goal;\\n        int count=0;\\n        while(n){\\n            n=n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n      int n=start^goal;\\n        int count=0;\\n        while(n){\\n            n=n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299721,
                "title": "efficient-code-100-beats-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the start and goal are equal then no bit need to be converted.\\nIf start is greater than goal then it might take more bit than the goal \\nand if the goal is greater than start then it might take more bit than start.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\nIf you find it helpful then please upvote\\u2B06\\uFE0F\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n        if(start==goal){\\n            return count;\\n        }\\n        else if(start>goal){\\n            while(start>0){\\n                if((start&1) != (goal&1)){\\n                    count++;\\n                }\\n                start>>=1;\\n                goal>>=1;\\n            }\\n        }else{\\n            while(goal>0){\\n                if((start&1) != (goal&1)){\\n                    count++;\\n                }\\n                start>>=1;\\n                goal>>=1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n        if(start==goal){\\n            return count;\\n        }\\n        else if(start>goal){\\n            while(start>0){\\n                if((start&1) != (goal&1)){\\n                    count++;\\n                }\\n                start>>=1;\\n                goal>>=1;\\n            }\\n        }else{\\n            while(goal>0){\\n                if((start&1) != (goal&1)){\\n                    count++;\\n                }\\n                start>>=1;\\n                goal>>=1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280695,
                "title": "java-two-different-approaches",
                "content": "\\n\\n# Approach 1:\\nWe\\'ll first convert both the numbers into 32-bit binary string forms. Then, we will check the number of different bits (characters in the strings) among the two converted binary string forms.\\n\\n# Code:\\n```\\n    String startBinary = String.format(\"%32s\", Integer.toBinaryString(start)).replaceAll(\" \", \"0\");\\n    String goalBinary = String.format(\"%32s\", Integer.toBinaryString(goal)).replaceAll(\" \", \"0\");\\n\\n    int minFlip = 0;\\n    int pointer = 0;\\n    while (pointer < startBinary.length()) {\\n      if (startBinary.charAt(pointer) != goalBinary.charAt(pointer)) {\\n        minFlip += 1;\\n      }\\n      pointer += 1;\\n    }\\n    return minFlip;\\n```\\n\\n\\n# Approach 2:\\nWe can solve the problem easily using the XOR operation because XOR produces 1 for different bits between two numbers. We can thus create a new variable, which will be the XOR of the given two variables. Afterwards, we\\'ll loop through and find out the number of 1 bits (different bits) in the previously produced XOR value. To find out the number of 1 bits, we can use [Brian Kernighan\\'s](https://leeyoongti.medium.com/counting-set-bits-using-brian-kernighans-algorithm-14d5699244ae) algorithm.\\n\\n\\n# Code:\\n```\\n    int xorValue = start ^ goal;\\n    int minFlip = 0;\\n\\n    while (xorValue != 0) {\\n      minFlip += 1;\\n      xorValue = (xorValue - 1) & xorValue;\\n    }\\n    return minFlip;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    String startBinary = String.format(\"%32s\", Integer.toBinaryString(start)).replaceAll(\" \", \"0\");\\n    String goalBinary = String.format(\"%32s\", Integer.toBinaryString(goal)).replaceAll(\" \", \"0\");\\n\\n    int minFlip = 0;\\n    int pointer = 0;\\n    while (pointer < startBinary.length()) {\\n      if (startBinary.charAt(pointer) != goalBinary.charAt(pointer)) {\\n        minFlip += 1;\\n      }\\n      pointer += 1;\\n    }\\n    return minFlip;\\n```\n```\\n    int xorValue = start ^ goal;\\n    int minFlip = 0;\\n\\n    while (xorValue != 0) {\\n      minFlip += 1;\\n      xorValue = (xorValue - 1) & xorValue;\\n    }\\n    return minFlip;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3204972,
                "title": "bit-manupulation-basic-implementation-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n       vector<int>v1,v2;\\n//taking out bit form of both goal and start numbers\\n       while(start!=0||goal!=0){\\n//pushing last bit in vector by taking and with the num\\n           v1.push_back(start&1);\\n           v2.push_back(goal&1);\\n           start=start>>1;\\n           goal=goal>>1;\\n          \\n       }\\n//checking number of bits that are different and need to flip to make goal from start\\n       for(int i=0;i<v1.size();i++)\\n       {\\n           if(v1[i]!=v2[i])\\n           count++;\\n       }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n       vector<int>v1,v2;\\n//taking out bit form of both goal and start numbers\\n       while(start!=0||goal!=0){\\n//pushing last bit in vector by taking and with the num\\n           v1.push_back(start&1);\\n           v2.push_back(goal&1);\\n           start=start>>1;\\n           goal=goal>>1;\\n          \\n       }\\n//checking number of bits that are different and need to flip to make goal from start\\n       for(int i=0;i<v1.size();i++)\\n       {\\n           if(v1[i]!=v2[i])\\n           count++;\\n       }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991304,
                "title": "xor-count-the-set-bits",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int val = start^goal;\\n        int res=0;\\n        \\n        for(int i=0;i<32;i++)\\n        {\\n            if(val & 1<<i)\\n                res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int val = start^goal;\\n        int res=0;\\n        \\n        for(int i=0;i<32;i++)\\n        {\\n            if(val & 1<<i)\\n                res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759108,
                "title": "c-one-liner-code-faster-than-100",
                "content": "~~~\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start ^ goal); \\n    }      \\n};         \\n\\n\\n\\n\\n\\n***if helpful please upvote***\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start ^ goal); \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2722569,
                "title": "java-one-liner-faster-than-100",
                "content": "The trick here is to perform xor (^) operation between the goal and the start, as it will get set bits for the places where bits of start and goal are different. For example,\\n\\t\\t\\tgoal = 00000100110110\\n\\t\\t\\tstart = 01001001100010\\nxor = 01001101010100\\nNow these set bits in xor result are the minimum bits that need to be flipped in order to convert start to goal. So, we count the number of set bits in xor using Integer.bitCount(x) in Java.\\n```\\n\\tpublic int minBitFlips(int start, int goal) {\\n\\t\\t\\treturn Integer.bitCount(start ^ goal);\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\tpublic int minBitFlips(int start, int goal) {\\n\\t\\t\\treturn Integer.bitCount(start ^ goal);\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2720229,
                "title": "swift-start-goal-nonzerobitcount",
                "content": "```\\nclass Solution {\\n    func minBitFlips(_ start: Int, _ goal: Int) -> Int {\\n        (start ^ goal).nonzeroBitCount\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minBitFlips(_ start: Int, _ goal: Int) -> Int {\\n        (start ^ goal).nonzeroBitCount\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2606608,
                "title": "easy-code-with-explanation",
                "content": "class Solution {\\npublic:\\n\\n    int minBitFlips(int start, int goal) {\\n        //the number of min bits will be total number of diff bits and we can count it by right shifting and comapre the 0th bit\\n        int ans=0;\\n        while(start!=0||goal!=0)\\n        {\\n            if((start&1)!=(goal&1))//0th bit different\\n                ans++;\\n            start=start>>1;\\n            goal=goal>>1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minBitFlips(int start, int goal) {\\n        //the number of min bits will be total number of diff bits and we can count it by right shifting and comapre the 0th bit\\n        int ans=0;\\n        while(start!=0||goal!=0)\\n        {\\n            if((start&1)!=(goal&1))//0th bit different\\n                ans++;\\n            start=start>>1;\\n            goal=goal>>1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2582111,
                "title": "simple-easy-and-clean-c-solution-using-bit-manipulation-xor-and",
                "content": "Store  **Bitwise XOR** operation between start and goal into an **integer named x**.\\n\\nThis helps us to count the number of the number of set bits in x that describes how many bits are need to be changed in start to convert it into goal.\\n\\n**Below steps count the number of set bits in x.**\\n\\n**Following steps are followed to solve the problem -:**\\n\\n1. Take a counter  **count** to count the number of 1\\'s in binary representation of the number.\\n2. Now use a while loop until the number becomes zero.\\n3. Perform **bitwise &** operation of **x** with **1**. If bit is 1 that means 1 is present in the representation and increase the count variable by 1.\\n4. Now shift the bit of x by 1 by doing a right shift **x>>1** so as to perform bitwise & operation on each bit of x .\\n5. Exit the while loop and **return the count** i.e number of 1 bits in the number.\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint minBitFlips(int start, int goal) \\n\\t\\t\\t{\\n\\t\\t\\t\\tint x=start^goal;\\n\\t\\t\\t\\tint c=0;\\n\\t\\t\\t\\twhile(x)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(x&1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tx=x>>1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn c;  \\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint minBitFlips(int start, int goal) \\n\\t\\t\\t{\\n\\t\\t\\t\\tint x=start^goal;\\n\\t\\t\\t\\tint c=0;\\n\\t\\t\\t\\twhile(x)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(x&1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2567972,
                "title": "runtime-0-ms-faster-than-100-00-submissions",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int minBitFlips(int start, int goal) {\\n        int n=start^goal;\\n        int cnt=0;\\n        for(int i=0;i<32;i++) {\\n            if(((n>>i)&1)==1) cnt++;\\n        } return cnt;\\n    }\\n\\t};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int minBitFlips(int start, int goal) {\\n        int n=start^goal;\\n        int cnt=0;\\n        for(int i=0;i<32;i++) {\\n            if(((n>>i)&1)==1) cnt++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2509277,
                "title": "c-o-32-time-100-faster-easy-understanding",
                "content": "```\\nhere we are just checking the ith bit of each is same or not, if not same then operations increases\\nclass Solution {\\npublic:\\n    int minBitFlips(int s, int g) {\\n        int cnt=0;\\n        for(int i=0;i<32;i++){\\n            int j=(g>>i)&1, k=(s>>i)&1;\\n            if(j!=k){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nhere we are just checking the ith bit of each is same or not, if not same then operations increases\\nclass Solution {\\npublic:\\n    int minBitFlips(int s, int g) {\\n        int cnt=0;\\n        for(int i=0;i<32;i++){\\n            int j=(g>>i)&1, k=(s>>i)&1;\\n            if(j!=k){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488977,
                "title": "java-0ms-100-faster-using-bit-manipulation-using-xor-3-liner-solution",
                "content": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int ans=0;\\n        for(int i=0;i<31;i++) if(((start&(1<<i))^(goal&(1<<i))) == (1<<i)) ans++;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int ans=0;\\n        for(int i=0;i<31;i++) if(((start&(1<<i))^(goal&(1<<i))) == (1<<i)) ans++;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477246,
                "title": "go-simple-solution-0ms",
                "content": "```go\\nfunc minBitFlips(start, goal int) int {\\n    // User XOR(^) for finding different bits\\n    // then count result bits\\n\\treturn bits.OnesCount32(uint32(start ^ goal))\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minBitFlips(start, goal int) int {\\n    // User XOR(^) for finding different bits\\n    // then count result bits\\n\\treturn bits.OnesCount32(uint32(start ^ goal))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2462345,
                "title": "java-solution-3ms-runtime-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int cnt = 0;\\n        String b_start = Integer.toBinaryString(start);\\n        String b_goal = Integer.toBinaryString(goal);\\n        int sb = b_start.length(), gb = b_goal.length();\\n        if (sb > gb) {\\n            int l = sb - gb;\\n            String z = \"\";\\n            for (int i = 0; i < l; i++) {\\n                z += \"0\";\\n            }\\n            b_goal = (z + b_goal);\\n\\n            for (int i = 0; i < sb; i++) {\\n                if (b_start.charAt(i) != b_goal.charAt(i)) cnt++;\\n            }\\n        }\\n        else if (sb < gb) {\\n            int l = gb - sb;\\n            String z = \"\";\\n            for (int i = 0; i < l; i++) {\\n                z += \"0\";\\n            }\\n            b_start = (z + b_start);\\n\\n            for (int i = 0; i < gb; i++) {\\n                if (b_start.charAt(i) != b_goal.charAt(i)) cnt++;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < b_start.length(); i++) {\\n                if (b_start.charAt(i) != b_goal.charAt(i)) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int cnt = 0;\\n        String b_start = Integer.toBinaryString(start);\\n        String b_goal = Integer.toBinaryString(goal);\\n        int sb = b_start.length(), gb = b_goal.length();\\n        if (sb > gb) {\\n            int l = sb - gb;\\n            String z = \"\";\\n            for (int i = 0; i < l; i++) {\\n                z += \"0\";\\n            }\\n            b_goal = (z + b_goal);\\n\\n            for (int i = 0; i < sb; i++) {\\n                if (b_start.charAt(i) != b_goal.charAt(i)) cnt++;\\n            }\\n        }\\n        else if (sb < gb) {\\n            int l = gb - sb;\\n            String z = \"\";\\n            for (int i = 0; i < l; i++) {\\n                z += \"0\";\\n            }\\n            b_start = (z + b_start);\\n\\n            for (int i = 0; i < gb; i++) {\\n                if (b_start.charAt(i) != b_goal.charAt(i)) cnt++;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < b_start.length(); i++) {\\n                if (b_start.charAt(i) != b_goal.charAt(i)) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461657,
                "title": "c-easy-solution-xor-count-set-bits",
                "content": "Straight forward solution, comment below if there\\'re any suggestions or doubts :)\\n\\n```\\nclass Solution {\\npublic:\\n    int countSetBits(int n){\\n        if (n == 0)\\n            return 0;\\n        else\\n            return 1 + countSetBits(n & (n - 1));\\n    }\\n    \\n    int minBitFlips(int start, int goal) {\\n        return countSetBits(start^goal);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSetBits(int n){\\n        if (n == 0)\\n            return 0;\\n        else\\n            return 1 + countSetBits(n & (n - 1));\\n    }\\n    \\n    int minBitFlips(int start, int goal) {\\n        return countSetBits(start^goal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447924,
                "title": "simple-java-solution-beats-100-bit-manipulation",
                "content": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int count=0;\\n        while(start!=0 || goal!=0){\\n            count += ((start & 1)^(goal & 1));\\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int count=0;\\n        while(start!=0 || goal!=0){\\n            count += ((start & 1)^(goal & 1));\\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439587,
                "title": "unique-morse-code-words",
                "content": "\\n        vector<string> s= {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        char c=97;\\n        unordered_map<char,string> m;\\n       for(auto &i:s)\\n      {\\n           m[c]=i;\\n           c++;\\n       }\\n        set<string> st;\\n        for(int i=0;i<words.size();i++){\\n            string str=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                str+=m[words[i][j]];\\n                \\n            }\\n            st.insert(str);\\n        }\\n        return st.size();\\n",
                "solutionTags": [
                    "String",
                    "Ordered Set"
                ],
                "code": "\\n        vector<string> s= {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        char c=97;\\n        unordered_map<char,string> m;\\n       for(auto &i:s)\\n      {\\n           m[c]=i;\\n           c++;\\n       }\\n        set<string> st;\\n        for(int i=0;i<words.size();i++){\\n            string str=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                str+=m[words[i][j]];\\n                \\n            }\\n            st.insert(str);\\n        }\\n        return st.size();\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2399127,
                "title": "python-xor",
                "content": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        count = 0\\n        xor = start ^ goal\\n        while xor:\\n            count += 1\\n            xor &= xor - 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        count = 0\\n        xor = start ^ goal\\n        while xor:\\n            count += 1\\n            xor &= xor - 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333422,
                "title": "easy-faster-than-100-java-solution",
                "content": "class Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int cnt=0;\\n       int num = start^goal;\\n        while(num!=0){\\n            if((num&1)==1){\\n                cnt++;\\n                num=num>>1;\\n            }else{\\n                num=num>>1;\\n            }\\n        }\\n        return cnt;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int cnt=0;\\n       int num = start^goal;\\n        while(num!=0){\\n            if((num&1)==1){\\n                cnt++;\\n                num=num>>1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2328636,
                "title": "easy-solution-python",
                "content": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        return bin(start ^ goal).count(\\'1\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        return bin(start ^ goal).count(\\'1\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295957,
                "title": "simple-and-intuitive-solution-in-python-with-comments",
                "content": "```\\ndef minBitFlips(self, start: int, goal: int) -> int:\\n\\tstart = bin(start)[:1:-1]   # get the binary representations of numbers\\n    goal = bin(goal)[:1:-1]     # in backwards order\\n        \\n    len_st = len(start)         # lengths of the binary strings\\n    len_go = len(goal)\\n        \\n    if len_st < len_go:         # we need to supplement the shorter binary with leading zeros\\n\\t\\tstart += \\'0\\' * (len_go - len_st)\\n\\telif len_go < len_st:\\n\\t\\tgoal += \\'0\\' * (len_st - len_go)\\n        \\n\\tflips = sum([start[i] != goal[i] for i in range(len(start))])  # count the number of unequal bits at every i-th position\\n        \\n    return flips",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minBitFlips(self, start: int, goal: int) -> int:\\n\\tstart = bin(start)[:1:-1]   # get the binary representations of numbers\\n    goal = bin(goal)[:1:-1]     # in backwards order\\n        \\n    len_st = len(start)         # lengths of the binary strings\\n    len_go = len(goal)\\n        \\n    if len_st < len_go:         # we need to supplement the shorter binary with leading zeros\\n\\t\\tstart += \\'0\\' * (len_go - len_st)\\n\\telif len_go < len_st:\\n\\t\\tgoal += \\'0\\' * (len_st - len_go)\\n        \\n\\tflips = sum([start[i] != goal[i] for i in range(len(start))])  # count the number of unequal bits at every i-th position\\n        \\n    return flips",
                "codeTag": "Python3"
            },
            {
                "id": 2275840,
                "title": "easy-xor-method-solution-in-c",
                "content": "Xor will have bit\\'1\\' at positions where bits of both numbers are different and \\nwe need to flip only those bits which are different so number of bit\\'1\\' in xor \\nwill give us result;\\n```\\nclass Solution {\\npublic:\\n    int numberOfSetbits(int Xor){\\n        int count=0;\\n        while(Xor){\\n            if(Xor&1){\\n                count++;\\n            }\\n            \\n            Xor>>=1;\\n        }\\n        return count;\\n    }\\n    int minBitFlips(int start, int goal) {\\n        int ans=0;\\n        \\n        int Xor=start^goal;\\n        return numberOfSetbits(Xor);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSetbits(int Xor){\\n        int count=0;\\n        while(Xor){\\n            if(Xor&1){\\n                count++;\\n            }\\n            \\n            Xor>>=1;\\n        }\\n        return count;\\n    }\\n    int minBitFlips(int start, int goal) {\\n        int ans=0;\\n        \\n        int Xor=start^goal;\\n        return numberOfSetbits(Xor);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2237452,
                "title": "using-xor-100-fast",
                "content": "```\\nint minBitFlips(int a, int b) {\\n         // Your logic here\\n        int XOR= a^b;\\n        int c=0;\\n        // 1010\\n        // 1000\\n        // xor\\n        // 0010 only to flip 1 & 0 at position 2 from left\\n        while(XOR){\\n            int bit=1;\\n            if(bit & XOR){\\n                c++;\\n            }\\n            XOR=XOR>>1;\\n        }\\n        return c;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minBitFlips(int a, int b) {\\n         // Your logic here\\n        int XOR= a^b;\\n        int c=0;\\n        // 1010\\n        // 1000\\n        // xor\\n        // 0010 only to flip 1 & 0 at position 2 from left\\n        while(XOR){\\n            int bit=1;\\n            if(bit & XOR){\\n                c++;\\n            }\\n            XOR=XOR>>1;\\n        }\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2200461,
                "title": "java-simple-bitwise-solution",
                "content": "This is my simple somution via bitwise:\\n\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int flipCount = 0;\\n        \\n        while (start > 0 || goal > 0) {\\n            flipCount += ((start & 0x1) ^ (goal & 0x1));\\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        \\n        return flipCount;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int flipCount = 0;\\n        \\n        while (start > 0 || goal > 0) {\\n            flipCount += ((start & 0x1) ^ (goal & 0x1));\\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        \\n        return flipCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191453,
                "title": "c-0ms-faster-than-100-left-shift",
                "content": "\\n    int minBitFlips(int n, int g) {\\n     \\n        int count=0;\\n        unsigned int i=0;\\n        while(i!=31 && g!=n)\\n        {\\n            int flag=1<<i;\\n            int flag2=n&flag;\\n            int flag3=g&flag;\\n            if(flag2!=flag3)\\n            {\\n                count++;\\n                if(flag3==1)\\n                    n=n|flag3;\\n                else\\n                    n=n&(~flag2);\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    int minBitFlips(int n, int g) {\\n     \\n        int count=0;\\n        unsigned int i=0;\\n        while(i!=31 && g!=n)\\n        {\\n            int flag=1<<i;\\n            int flag2=n&flag;\\n            int flag3=g&flag;\\n            if(flag2!=flag3)\\n            {\\n                count++;\\n                if(flag3==1)\\n                    n=n|flag3;\\n                else\\n                    n=n&(~flag2);\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2185973,
                "title": "rust-faster-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn min_bit_flips(mut start: i32, mut goal: i32) -> i32 {\\n        let mut cnt = 0;\\n        // while start != goal {\\n        //     if start & 0x1 != goal & 0x1 {\\n        //         cnt += 1;\\n        //     }\\n        //     start >>= 1;\\n        //     goal >>= 1;\\n        // }\\n\\n        let mut n = start ^ goal;\\n        while n != 0 {\\n            n = n & (n - 1);\\n            cnt += 1;\\n        }\\n\\n        cnt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn min_bit_flips(mut start: i32, mut goal: i32) -> i32 {\\n        let mut cnt = 0;\\n        // while start != goal {\\n        //     if start & 0x1 != goal & 0x1 {\\n        //         cnt += 1;\\n        //     }\\n        //     start >>= 1;\\n        //     goal >>= 1;\\n        // }\\n\\n        let mut n = start ^ goal;\\n        while n != 0 {\\n            n = n & (n - 1);\\n            cnt += 1;\\n        }\\n\\n        cnt\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2127699,
                "title": "c",
                "content": "```class Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int n=start^goal;\\n        unsigned int count = 0;\\n    while (n) {\\n        count += n & 1;\\n        n >>= 1;\\n    }\\n    return count;\\n    }\\n};```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```class Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int n=start^goal;\\n        unsigned int count = 0;\\n    while (n) {\\n        count += n & 1;\\n        n >>= 1;\\n    }\\n    return count;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2092213,
                "title": "python-1-line-xor-count-bits",
                "content": "```\\nclass Solution:\\n    def minBitFlips(self, start, goal):\\n        return (start^goal).bit_count()\\n```\\nexample:\\n10 : 1010\\n07 : 0111\\nxor: 1101 (3 bits == solution)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start, goal):\\n        return (start^goal).bit_count()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2037974,
                "title": "swift-one-liner",
                "content": "Swift one-liner\\n```swift\\nclass Solution {\\n    func minBitFlips(_ start: Int, _ goal: Int) -> Int {\\n        (start ^ goal).nonzeroBitCount\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func minBitFlips(_ start: Int, _ goal: Int) -> Int {\\n        (start ^ goal).nonzeroBitCount\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028043,
                "title": "python3-easy-to-understand-solution",
                "content": "1. Initialise your return variable with 0.\\n2. Check if LSB of both are different. Increase your count.\\n3. Right shift both the numbers.\\n(Note - For while, we will take larger number as condition)\\n```\\nclass Solution:\\n    def count_flips(self, start, goal):\\n        count = 0\\n        while start != 0:\\n            if start & 1 != goal & 1:\\n                count += 1\\n            start >>= 1\\n            goal >>= 1\\n        return count\\n        \\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        if start > goal:\\n            return self.count_flips(start, goal)\\n        else:\\n            return self.count_flips(goal, start)\\n            \\n",
                "solutionTags": [],
                "code": "1. Initialise your return variable with 0.\\n2. Check if LSB of both are different. Increase your count.\\n3. Right shift both the numbers.\\n(Note - For while, we will take larger number as condition)\\n```\\nclass Solution:\\n    def count_flips(self, start, goal):\\n        count = 0\\n        while start != 0:\\n            if start & 1 != goal & 1:\\n                count += 1\\n            start >>= 1\\n            goal >>= 1\\n        return count\\n        \\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        if start > goal:\\n            return self.count_flips(start, goal)\\n        else:\\n            return self.count_flips(goal, start)\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 2020000,
                "title": "fastest-java-1-line-solution-0-ms",
                "content": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) \\n    {\\n       return Integer.bitCount(start^goal);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public int minBitFlips(int start, int goal) \\n    {\\n       return Integer.bitCount(start^goal);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1949455,
                "title": "100-fast-bitmask-explained",
                "content": "class Solution {\\npublic:\\n\\t\\n\\t/*\\n\\t\\tYou have to check (for both the no. start and goal)that the ith bit is on of off if both are simultaneously on or off do nothing else increment ans\\n\\t\\tFor checking the ith bit is on or off make a bitmask and do the following logic:\\n\\t\\t\\t=>if n&mask==0 that means that bit was off\\n\\t\\t\\t=>otherwise that bit was on\\n\\t*/\\n\\t\\n\\n    int minBitFlips(int start, int goal) {\\n        int mask=1;\\n        int ans=0;\\n        while(mask<=max(goal,start)){\\n            int x1=(mask&start);\\n            int x2=(mask&goal);\\n            if(x1!=x2)ans++;\\n            mask=mask<<1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\t\\n\\t/*\\n\\t\\tYou have to check (for both the no. start and goal)that the ith bit is on of off if both are simultaneously on or off do nothing else increment ans\\n\\t\\tFor checking the ith bit is on or off make a bitmask and do the following logic:\\n\\t\\t\\t=>if n&mask==0 that means that bit was off\\n\\t\\t\\t=>otherwise that bit was on\\n\\t*/\\n\\t\\n\\n    int minBitFlips(int start, int goal) {\\n        int mask=1;\\n        int ans=0;\\n        while(mask<=max(goal,start)){\\n            int x1=(mask&start);\\n            int x2=(mask&goal);\\n            if(x1!=x2)ans++;\\n            mask=mask<<1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1926597,
                "title": "clear-c-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count{0};\\n        \\n        while(start || goal){\\n            count += (start & 1) != (goal & 1);\\n            \\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        \\n        return count;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count{0};\\n        \\n        while(start || goal){\\n            count += (start & 1) != (goal & 1);\\n            \\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        \\n        return count;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915306,
                "title": "python-3-o-n-time-easy-solution",
                "content": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        def get( i):\\n            s=\"\"\\n            while i!=0:\\n                s+=\"0\"\\n                i-=1\\n            return s\\n        s=bin(start).replace(\"0b\",\\'\\')\\n        g=bin(goal).replace(\\'0b\\',\\'\\')\\n        if len(s)<len(g):\\n            s=get(len(g)-len(s))+s\\n        \\n        if len(g)<len(s):\\n            g=get(len(s)-len(g))+g\\n        c=0\\n        for i in range(len(s)):\\n            if s[i]!=g[i]:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        def get( i):\\n            s=\"\"\\n            while i!=0:\\n                s+=\"0\"\\n                i-=1\\n            return s\\n        s=bin(start).replace(\"0b\",\\'\\')\\n        g=bin(goal).replace(\\'0b\\',\\'\\')\\n        if len(s)<len(g):\\n            s=get(len(g)-len(s))+s\\n        \\n        if len(g)<len(s):\\n            g=get(len(s)-len(g))+g\\n        c=0\\n        for i in range(len(s)):\\n            if s[i]!=g[i]:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915196,
                "title": "minimum-bit-flips-to-convert-number-easy-learned-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int flipped = start ^ goal;\\n        \\n        int count = 0;\\n        while(flipped != 0) {\\n            int rsb = (flipped & -flipped);\\n            flipped -= rsb;\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\nIf you understood the problem, kindly **UpVote**.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int flipped = start ^ goal;\\n        \\n        int count = 0;\\n        while(flipped != 0) {\\n            int rsb = (flipped & -flipped);\\n            flipped -= rsb;\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915104,
                "title": "kotlin-solution-xor-then-count-set-bit",
                "content": "```\\nclass Solution {\\n    fun minBitFlips(start: Int, goal: Int): Int {\\n       var result = start xor goal\\n        var answer = 0\\n        while (result > 0) {\\n            if (result % 2 == 1) {\\n                answer++\\n            }\\n            result /= 2\\n        }\\n        return answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minBitFlips(start: Int, goal: Int): Int {\\n       var result = start xor goal\\n        var answer = 0\\n        while (result > 0) {\\n            if (result % 2 == 1) {\\n                answer++\\n            }\\n            result /= 2\\n        }\\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910452,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Approach 1 : Brute Force***\\n\\n* ***Time Complexity : O(N)***\\n* ***Space Complexity : O(N)***\\n\\n```\\nint minBitFlips(int start, int goal) {\\n        \\n        vector<int> arr1;\\n        \\n        vector<int> arr2;\\n        \\n        while(start)\\n        {\\n            int r = (start & 1);\\n            \\n            arr1.push_back(r);\\n            \\n            start = start >> 1;\\n        }\\n        \\n        while(goal)\\n        {\\n            int r = (goal & 1);\\n            \\n            arr2.push_back(r);\\n            \\n            goal = goal >> 1;\\n        }\\n        \\n        int i = 0;\\n        \\n        int j = 0;\\n        \\n        int count = 0;\\n        \\n        while(i < arr1.size() && j < arr2.size())\\n        {\\n            if(arr1[i] != arr2[j])\\n            {\\n                count++;\\n            }\\n            \\n            i++;\\n            \\n            j++;\\n        }\\n        \\n        if(i < arr1.size())\\n        {\\n            int count_1 = 0;\\n            \\n            while(i < arr1.size())\\n            {\\n                if(arr1[i] == 1)\\n                {\\n                    count_1++;\\n                }\\n                \\n                i++;\\n            }\\n            \\n            count += count_1;\\n        }\\n        \\n        if(j < arr2.size())\\n        {\\n            int count_1 = 0;\\n            \\n            while(j < arr2.size())\\n            {\\n                if(arr2[j] == 1)\\n                {\\n                    count_1++;\\n                }\\n                \\n                j++;\\n            }\\n            \\n            count += count_1;\\n        }\\n        \\n        return count;\\n    }\\n```\\n\\n* ***Approach 2 : Optimized***\\n\\n* ***Time Complexity : O(N)***\\n* ***Space Complexity : O(1)***\\n\\n```\\nint minBitFlips(int start, int goal) {\\n        \\n        int count = 0;\\n        \\n        while(start || goal)\\n        {\\n            int x1 = (start & 1);\\n            \\n            int x2 = (goal & 1);\\n            \\n            if(x1 != x2)\\n            {\\n                count++;\\n            }\\n            \\n            start = start >> 1;\\n            \\n            goal = goal >> 1;\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint minBitFlips(int start, int goal) {\\n        \\n        vector<int> arr1;\\n        \\n        vector<int> arr2;\\n        \\n        while(start)\\n        {\\n            int r = (start & 1);\\n            \\n            arr1.push_back(r);\\n            \\n            start = start >> 1;\\n        }\\n        \\n        while(goal)\\n        {\\n            int r = (goal & 1);\\n            \\n            arr2.push_back(r);\\n            \\n            goal = goal >> 1;\\n        }\\n        \\n        int i = 0;\\n        \\n        int j = 0;\\n        \\n        int count = 0;\\n        \\n        while(i < arr1.size() && j < arr2.size())\\n        {\\n            if(arr1[i] != arr2[j])\\n            {\\n                count++;\\n            }\\n            \\n            i++;\\n            \\n            j++;\\n        }\\n        \\n        if(i < arr1.size())\\n        {\\n            int count_1 = 0;\\n            \\n            while(i < arr1.size())\\n            {\\n                if(arr1[i] == 1)\\n                {\\n                    count_1++;\\n                }\\n                \\n                i++;\\n            }\\n            \\n            count += count_1;\\n        }\\n        \\n        if(j < arr2.size())\\n        {\\n            int count_1 = 0;\\n            \\n            while(j < arr2.size())\\n            {\\n                if(arr2[j] == 1)\\n                {\\n                    count_1++;\\n                }\\n                \\n                j++;\\n            }\\n            \\n            count += count_1;\\n        }\\n        \\n        return count;\\n    }\\n```\n```\\nint minBitFlips(int start, int goal) {\\n        \\n        int count = 0;\\n        \\n        while(start || goal)\\n        {\\n            int x1 = (start & 1);\\n            \\n            int x2 = (goal & 1);\\n            \\n            if(x1 != x2)\\n            {\\n                count++;\\n            }\\n            \\n            start = start >> 1;\\n            \\n            goal = goal >> 1;\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1910193,
                "title": "java-one-liner",
                "content": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        return Integer.bitCount(start^goal);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        return Integer.bitCount(start^goal);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909717,
                "title": "one-liner-python-c-using-xor",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n        return __builtin_popcount(start^goal);\\n        \\n    }\\n};\\n```\\n**Python**\\n```\\ndef minBitFlips(self, start: int, goal: int) -> int:\\n        return (start ^ goal).bit_count()\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n        return __builtin_popcount(start^goal);\\n        \\n    }\\n};\\n```\n```\\ndef minBitFlips(self, start: int, goal: int) -> int:\\n        return (start ^ goal).bit_count()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908989,
                "title": "simple-solution-using-xor-in-o-n",
                "content": "doing XOR and finding number on Ones in binary conversion of resultant\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> convert(int num){\\n       vector<int>ans;\\n        while(num>0){\\n           int c=(num%2);\\n            num/=2;\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n\\n    int minBitFlips(int start, int goal) {\\n        int x=start^goal;\\n        vector<int> ans=convert(x);\\n        int f=0;\\n        int n=ans.size();\\n        for(int i=0;i<n;i++){\\n            if(ans[i]==1)\\n                f++;\\n        }\\n        return f;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> convert(int num){\\n       vector<int>ans;\\n        while(num>0){\\n           int c=(num%2);\\n            num/=2;\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n\\n    int minBitFlips(int start, int goal) {\\n        int x=start^goal;\\n        vector<int> ans=convert(x);\\n        int f=0;\\n        int n=ans.size();\\n        for(int i=0;i<n;i++){\\n            if(ans[i]==1)\\n                f++;\\n        }\\n        return f;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908081,
                "title": "simple-java-intuitive-bit-manipulation-ttt",
                "content": "Lets take 10 and 7 as an example:\\nBinary rep of 10: 1010\\nBinary rep of 7 :   0111\\nIt is clear that if we are able to count the number of mis-matches OR the number of different bits, we can conclude the number of flips needed,\\n\\n**No of Flips = No of mis-matched btis in binary representation**\\n\\nThe easiest way to find mismatched bits is excecuting a XOR opeartion om start and goal, as in XOR the mis-matched bits generate 1. Hence, we can then count the number of 1s in the XOR result and find the number of flips needed.\\n\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n\\t//start = 10 (1010)\\n\\t//goal = 7    (0111)\\n\\t// start ^ goal = (1101) --> as there are 3 mis matched bits bw 10 and 7 \\n\\t//  we can easilt count no of 1s in the XOR result using th following snippet \\n        int res = start ^ goal;\\n        int count = 0;\\n        while( res > 0){\\n            if( (res & 1) % 2 == 1)count++;\\n            res = res >> 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n\\t//start = 10 (1010)\\n\\t//goal = 7    (0111)\\n\\t// start ^ goal = (1101) --> as there are 3 mis matched bits bw 10 and 7 \\n\\t//  we can easilt count no of 1s in the XOR result using th following snippet \\n        int res = start ^ goal;\\n        int count = 0;\\n        while( res > 0){\\n            if( (res & 1) % 2 == 1)count++;\\n            res = res >> 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907541,
                "title": "c-simple-easy-code-bit",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int a, int b) {\\n        int flips = 0;\\n \\n      while(a > 0 || b > 0){\\n\\n        int t1 = (a&1);\\n        int t2 = (b&1);\\n\\n        if(t1!=t2){flips++;}\\n        a>>=1;\\n        b>>=1;\\n      }\\n\\n      return flips;\\n    }\\n};\\n```\\nDo upvote if it helped :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int a, int b) {\\n        int flips = 0;\\n \\n      while(a > 0 || b > 0){\\n\\n        int t1 = (a&1);\\n        int t2 = (b&1);\\n\\n        if(t1!=t2){flips++;}\\n        a>>=1;\\n        b>>=1;\\n      }\\n\\n      return flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907475,
                "title": "simple-explanation-c-0-log-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n\\t\\n\\t\\t//to take xor so that we can get all position where start and goal differ\\n        int temp = start ^ goal;    \\n        int cnt = 0;\\n\\t\\t\\n\\t\\t//count the set bits which will give the position where they differ and count them\\n        while(temp){ \\n            cnt += temp & 1;\\n            temp >>= 1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n\\t\\n\\t\\t//to take xor so that we can get all position where start and goal differ\\n        int temp = start ^ goal;    \\n        int cnt = 0;\\n\\t\\t\\n\\t\\t//count the set bits which will give the position where they differ and count them\\n        while(temp){ \\n            cnt += temp & 1;\\n            temp >>= 1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907289,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        \\n        return bin(start^goal).count(\"1\")\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        \\n        return bin(start^goal).count(\"1\")\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907192,
                "title": "bitset-stl-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n         bitset<32> num1(start);\\n         bitset<32> num2(goal);\\n        \\n         int n = num1.size();\\n        \\n        int counter = 0;\\n        for(int i = n-1;i>=0;i--){\\n            if(num1[i] != num2[i])\\n                counter++;\\n        }\\n        \\n        \\n        return counter;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n         bitset<32> num1(start);\\n         bitset<32> num2(goal);\\n        \\n         int n = num1.size();\\n        \\n        int counter = 0;\\n        for(int i = n-1;i>=0;i--){\\n            if(num1[i] != num2[i])\\n                counter++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1907158,
                "title": "c-easy-to-understand-commented",
                "content": "**Idea**\\n1. Convert decimal to its binary equivalent and then just compare both if they are differnt i.e if first is 0 and 2nd is 1 we need to flip.\\n2. for example 1010 and 0110, three bits differ so answer is 3\\n```\\nclass Solution {\\npublic:\\n    \\n    int minBitFlips(int start, int goal) {\\n        int flips = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int k = start >> i;\\n            int l = goal >> i;\\n            int m = k&1; //Check the bit of start\\n            int n = l&1; // Check the bit of target\\n            if (m != n) //If different\\n                flips++; //flip is required\\n        }\\n        return flips;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minBitFlips(int start, int goal) {\\n        int flips = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int k = start >> i;\\n            int l = goal >> i;\\n            int m = k&1; //Check the bit of start\\n            int n = l&1; // Check the bit of target\\n            if (m != n) //If different\\n                flips++; //flip is required\\n        }\\n        return flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907126,
                "title": "python-straightforward",
                "content": "```python\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        total = 0\\n\\n        for a, b in zip(bin(start)[2:].rjust(32, \\'0\\'), bin(goal)[2:].rjust(32, \\'0\\')):\\n            if a != b:\\n                total += 1\\n\\n        return total\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        total = 0\\n\\n        for a, b in zip(bin(start)[2:].rjust(32, \\'0\\'), bin(goal)[2:].rjust(32, \\'0\\')):\\n            if a != b:\\n                total += 1\\n\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907063,
                "title": "c-easy-solution-one-liner",
                "content": "```\\nThe logic is find the total number of set bits in xor of start no. and goal .\\nResult = set-bits( start ^ goal )\\n```\\n```\\nclass Solution {\\npublic:\\n    int countsetbits(int n){\\n    int count = 0;\\n    while (n > 0)\\n    {\\n        count++;\\n        n &= (n-1);    // Remove last set bit\\n    }\\n    return count;\\n    }\\n    int minBitFlips(int start, int goal) {\\n        int c= countsetbits(start^goal);\\n        return c;\\n    }\\n};\\n```\\n```\\nOne liner:\\n\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);    //predefined method to find set bits in binary of a no.\\n    }\\n};\\n```\\nIf you like it, please upvote !!\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nThe logic is find the total number of set bits in xor of start no. and goal .\\nResult = set-bits( start ^ goal )\\n```\n```\\nclass Solution {\\npublic:\\n    int countsetbits(int n){\\n    int count = 0;\\n    while (n > 0)\\n    {\\n        count++;\\n        n &= (n-1);    // Remove last set bit\\n    }\\n    return count;\\n    }\\n    int minBitFlips(int start, int goal) {\\n        int c= countsetbits(start^goal);\\n        return c;\\n    }\\n};\\n```\n```\\nOne liner:\\n\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);    //predefined method to find set bits in binary of a no.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907056,
                "title": "easy-understand",
                "content": "class Solution {\\npublic:\\n    int countSetBits(int n)\\n{\\n    int count = 0;\\n    while (n > 0)\\n    {\\n        count++;\\n        n &= (n-1);\\n    }\\n    return count;\\n}\\n    int minBitFlips(int a, int b) {\\n        return countSetBits(a^b);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countSetBits(int n)\\n{\\n    int count = 0;\\n    while (n > 0)\\n    {\\n        count++;\\n        n &= (n-1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1906988,
                "title": "compare-bits-of-numbers-simply",
                "content": "```\\n    int minBitFlips(int start, int goal) {\\n        \\n        int count=0;\\n        \\n        for(int i=0;i<32;i++){\\n            bool bit1=(start&(1<<i));\\n            bool bit2=(goal&(1<<i));\\n            \\n            if(bit1!=bit2){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\n    int minBitFlips(int start, int goal) {\\n        \\n        int count=0;\\n        \\n        for(int i=0;i<32;i++){\\n            bool bit1=(start&(1<<i));\\n            bool bit2=(goal&(1<<i));\\n            \\n            if(bit1!=bit2){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1906978,
                "title": "java-using-xor",
                "content": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int x = start^goal;\\n        int c = 0;\\n        while(x>0){\\n            if((x&1)==1) c++;\\n            x = x>>1;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int x = start^goal;\\n        int c = 0;\\n        while(x>0){\\n            if((x&1)==1) c++;\\n            x = x>>1;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906977,
                "title": "c-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int bit=0;\\n        int flip=0;\\n        while(bit<32){\\n            if((start&(1<<bit))!=((goal)&(1<<bit))){\\n                flip++;\\n            }\\n            bit++;\\n        }\\n        return flip;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int bit=0;\\n        int flip=0;\\n        while(bit<32){\\n            if((start&(1<<bit))!=((goal)&(1<<bit))){\\n                flip++;\\n            }\\n            bit++;\\n        }\\n        return flip;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906968,
                "title": "java-simple-solution-xor",
                "content": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int new_num = start ^ goal,count = 0;\\n        while(new_num != 0){\\n            count += (1 & new_num);\\n            new_num = new_num >> 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int new_num = start ^ goal,count = 0;\\n        while(new_num != 0){\\n            count += (1 & new_num);\\n            new_num = new_num >> 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089068,
                "title": "c-code-easy-solution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        //initializing temp with start\\n        int temp=start,count = 0;\\n        //loop will end when the temp == goal\\n        for(int i = 0 ; temp != goal ; i++){\\n            int bit1 = ((temp >> i) & 1 ); // gets ith bit of temp\\n            int bit2 = ((goal >> i) & 1); // gets ith bit of goal\\n\\n            if(bit1 != bit2){ //if not equal increment count\\n                count++;\\n                temp = temp ^ (1 << i); //flip the ith bit\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\nxor operation result is 1 if corresponding bits are not equal so we can perform xor of start and goal and count the number of 1\\'s \\n# code\\n```\\n        int count = 0;\\n        int ans = start ^ goal;\\n        while(ans){\\n            ans = ans & (ans -1);\\n            count++;\\n        }\\n        return count;",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        //initializing temp with start\\n        int temp=start,count = 0;\\n        //loop will end when the temp == goal\\n        for(int i = 0 ; temp != goal ; i++){\\n            int bit1 = ((temp >> i) & 1 ); // gets ith bit of temp\\n            int bit2 = ((goal >> i) & 1); // gets ith bit of goal\\n\\n            if(bit1 != bit2){ //if not equal increment count\\n                count++;\\n                temp = temp ^ (1 << i); //flip the ith bit\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088696,
                "title": "beats100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count = 0;\\n        for(int i=0;i<31;++i){\\n            if((start&1) != (goal&1)) ++count;\\n            start >>=1;\\n            goal >>=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count = 0;\\n        for(int i=0;i<31;++i){\\n            if((start&1) != (goal&1)) ++count;\\n            start >>=1;\\n            goal >>=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088446,
                "title": "bit-flip-bit-compare-by-binary-conversion-of-digits",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n\\n    int BitFlip;\\n    int CountDiff;\\n    List<int> StartBit = new List<int>();\\n    List<int> GoalBit = new List<int>();\\n\\n    public int MinBitFlips(int start, int goal) {\\n        \\n        DigitToBinary(start,StartBit);\\n        DigitToBinary(goal,GoalBit);\\n\\nif(StartBit.Count > GoalBit.Count)\\n{\\n    CountDiff = StartBit.Count - GoalBit.Count;\\n\\n    for(int i = 1; i <= CountDiff; i++)\\n    {\\n        GoalBit.Add(0);\\n    }\\n}\\nelse if(StartBit.Count < GoalBit.Count)\\n{\\n    CountDiff = GoalBit.Count - StartBit.Count;\\n\\n    for (int i = 1; i <= CountDiff; i++)\\n    {\\n        StartBit.Add(0);\\n    }\\n}\\n\\nStartBit.Reverse();\\nGoalBit.Reverse();\\n\\nfor(int i = 0; i < GoalBit.Count; i++)\\n{\\n    if (GoalBit[i] != StartBit[i])\\n    {\\n        BitFlip++;\\n    }\\n}\\n\\n         return BitFlip;\\n}\\n\\npublic void DigitToBinary(int digit, List<int> bits)\\n{\\n\\n    if(digit == 0)\\n    {\\n        bits.Add(0);\\n    }\\n    else\\n    {\\n        while(digit > 0)\\n        {\\n            if(digit %2  == 0)\\n            {\\n                bits.Add(0);\\n                digit = digit /2;\\n            }\\n            else if(digit == 1)\\n            {\\n                bits.Add(1);\\n                digit = digit / 2;\\n            }\\n            else\\n            {\\n                bits.Add(1);\\n                digit = digit / 2;\\n            }\\n\\n        }\\n    }\\n\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n    int BitFlip;\\n    int CountDiff;\\n    List<int> StartBit = new List<int>();\\n    List<int> GoalBit = new List<int>();\\n\\n    public int MinBitFlips(int start, int goal) {\\n        \\n        DigitToBinary(start,StartBit);\\n        DigitToBinary(goal,GoalBit);\\n\\nif(StartBit.Count > GoalBit.Count)\\n{\\n    CountDiff = StartBit.Count - GoalBit.Count;\\n\\n    for(int i = 1; i <= CountDiff; i++)\\n    {\\n        GoalBit.Add(0);\\n    }\\n}\\nelse if(StartBit.Count < GoalBit.Count)\\n{\\n    CountDiff = GoalBit.Count - StartBit.Count;\\n\\n    for (int i = 1; i <= CountDiff; i++)\\n    {\\n        StartBit.Add(0);\\n    }\\n}\\n\\nStartBit.Reverse();\\nGoalBit.Reverse();\\n\\nfor(int i = 0; i < GoalBit.Count; i++)\\n{\\n    if (GoalBit[i] != StartBit[i])\\n    {\\n        BitFlip++;\\n    }\\n}\\n\\n         return BitFlip;\\n}\\n\\npublic void DigitToBinary(int digit, List<int> bits)\\n{\\n\\n    if(digit == 0)\\n    {\\n        bits.Add(0);\\n    }\\n    else\\n    {\\n        while(digit > 0)\\n        {\\n            if(digit %2  == 0)\\n            {\\n                bits.Add(0);\\n                digit = digit /2;\\n            }\\n            else if(digit == 1)\\n            {\\n                bits.Add(1);\\n                digit = digit / 2;\\n            }\\n            else\\n            {\\n                bits.Add(1);\\n                digit = digit / 2;\\n            }\\n\\n        }\\n    }\\n\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083167,
                "title": "java-solution",
                "content": "Initialize a variable count to 0. This variable will be used to keep track of the number of bit differences between start and goal.\\n\\nEnter a while loop that continues as long as either start or goal has bits remaining to be processed (i.e., greater than 0).\\n\\nInside the loop:\\n\\nstart & 1 and goal & 1 are used to extract the least significant bit (LSB) of start and goal, respectively. This is done by performing a bitwise AND operation with 1, which effectively checks if the rightmost bit is set (equal to 1).\\n((start & 1) ^ (goal & 1)) checks if the LSBs of start and goal are different. If they are different (i.e., XOR operation results in 1), it means that a bit flip is needed to make them the same.\\nIf the LSBs are different (i.e., the XOR operation results in 1), increment the count variable by 1. This means that a bit flip is required for this position.\\n\\nRight-shift both start and goal by 1 bit. This effectively moves to the next bit position, preparing to compare the next pair of bits in the binary representation.\\n\\nRepeat steps 3-5 until both start and goal have been completely processed (i.e., they become 0).\\n\\nAfter processing all bits, the count variable will contain the total number of bit differences (i.e., the number of bits that need to be flipped) between the original start and goal values.\\n\\nReturn the count value as the result, indicating how many bit flips are required to transform start into goal.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        // String num1 = String.format(\"%32s\", Integer.toBinaryString(start)).replaceAll(\" \", \"0\");\\n        // String num2 = String.format(\"%32s\", Integer.toBinaryString(goal)).replaceAll(\" \", \"0\");\\n        // int count = 0;\\n        // for(int i = 0; i < num1.length(); i++){\\n        //     if(num1.charAt(i) != num2.charAt(i))\\n        //         count++;\\n        // }\\n        // return count;\\n\\n        int count = 0;\\n        while(start > 0 || goal > 0){\\n            if(((start & 1)^(goal & 1)) == 1)\\n                count++;\\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        // String num1 = String.format(\"%32s\", Integer.toBinaryString(start)).replaceAll(\" \", \"0\");\\n        // String num2 = String.format(\"%32s\", Integer.toBinaryString(goal)).replaceAll(\" \", \"0\");\\n        // int count = 0;\\n        // for(int i = 0; i < num1.length(); i++){\\n        //     if(num1.charAt(i) != num2.charAt(i))\\n        //         count++;\\n        // }\\n        // return count;\\n\\n        int count = 0;\\n        while(start > 0 || goal > 0){\\n            if(((start & 1)^(goal & 1)) == 1)\\n                count++;\\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076840,
                "title": "easy-solution-tc-o-1-sc-o-1-bit-checks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is essentially asking for the minimum number of bit flips needed to convert one binary number (start) into another binary number (goal).\\n\\nTo find the minimum number of bit flips, we can compare the bits of both numbers from right to left (least significant bit to most significant bit).Whenever we encounter two bits that are different, we increment a counter to keep track of the number of bit flips required.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize a variable c to 0 to count the number of bit flips.\\n\\nIterate through the bits of start and goal from the rightmost bit (least significant bit) to the leftmost bit (most significant bit).\\n\\nFor each bit position i, check if the i-th bit of start is different from the i-th bit of goal. If they are different, increment the c counter.\\n\\nContinue this process for all bits.\\n\\nFinally, return the value of c as the minimum number of bit flips required to convert start to goal.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe correct time complexity of the given algorithm is O(32) or simply O(1). This is because we are dealing with 32 bits in a 32-bit integer, which is a constant number of bits. Therefore, the time complexity remains constant and does not depend on the actual values of start and goal.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) as we only use a constant amount of space to store the counter c.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int c=0;\\n        for(int i=0;i<32;i++){\\n            if(( (start & (1<<i)) ? 1:0) != ((goal & (1<<i)) ? 1:0) ){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int c=0;\\n        for(int i=0;i<32;i++){\\n            if(( (start & (1<<i)) ? 1:0) != ((goal & (1<<i)) ? 1:0) ){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075248,
                "title": "best-begginner-level-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        String str1 = Integer.toBinaryString(start);\\n        String str2 = Integer.toBinaryString(goal);\\n\\n        int lengthDifference = Math.abs(str1.length() - str2.length());\\n\\n        StringBuilder result = new StringBuilder();\\n\\n        for (int i = 0; i < lengthDifference; i++) {\\n            result.append(\\'0\\');\\n        }\\n        String temp = \"\";\\n        if (str1.length() < str2.length()) {\\n            result.append(str1);\\n            temp = str2;\\n\\n        } else {\\n            result.append(str2);\\n            temp = str1;\\n        }\\n        String str = result.toString();\\n        int differences = 0;\\n        for (int i = str.length() - 1; i >= 0; i--) {\\n            if (str.charAt(i) != temp.charAt(i)) {\\n   \\n                differences++;\\n            }\\n        }\\n\\n        return differences;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        String str1 = Integer.toBinaryString(start);\\n        String str2 = Integer.toBinaryString(goal);\\n\\n        int lengthDifference = Math.abs(str1.length() - str2.length());\\n\\n        StringBuilder result = new StringBuilder();\\n\\n        for (int i = 0; i < lengthDifference; i++) {\\n            result.append(\\'0\\');\\n        }\\n        String temp = \"\";\\n        if (str1.length() < str2.length()) {\\n            result.append(str1);\\n            temp = str2;\\n\\n        } else {\\n            result.append(str2);\\n            temp = str1;\\n        }\\n        String str = result.toString();\\n        int differences = 0;\\n        for (int i = str.length() - 1; i >= 0; i--) {\\n            if (str.charAt(i) != temp.charAt(i)) {\\n   \\n                differences++;\\n            }\\n        }\\n\\n        return differences;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071595,
                "title": "100-faster",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        res = start ^ goal\\n        s = int(str(bin(res))[2:])\\n        \\n        cnt = 0\\n        while s != 0:\\n            d = s%10\\n            if d == 1:\\n                cnt += 1\\n            s = s//10\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        res = start ^ goal\\n        s = int(str(bin(res))[2:])\\n        \\n        cnt = 0\\n        while s != 0:\\n            d = s%10\\n            if d == 1:\\n                cnt += 1\\n            s = s//10\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065881,
                "title": "php",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $start\\n     * @param Integer $goal\\n     * @return Integer\\n     */\\n    function minBitFlips($start, $goal) {\\n        return substr_count(decbin($start ^ $goal), \\'1\\');\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $start\\n     * @param Integer $goal\\n     * @return Integer\\n     */\\n    function minBitFlips($start, $goal) {\\n        return substr_count(decbin($start ^ $goal), \\'1\\');\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059693,
                "title": "bit-manipulation-beats-100-00",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nXOR start and Goal  and check  how many bits are set of that value\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int n= start^goal;\\n        int res=0;\\n\\n        while(n>0){\\n            n=n&(n-1);\\n            res++;\\n\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int n= start^goal;\\n        int res=0;\\n\\n        while(n>0){\\n            n=n&(n-1);\\n            res++;\\n\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059680,
                "title": "simple-c-solution-with-xor",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int result = 0;\\n        int n = start ^ goal;\\n\\n        while (n != 0) {\\n            result += n % 2;\\n            n /= 2;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int result = 0;\\n        int n = start ^ goal;\\n\\n        while (n != 0) {\\n            result += n % 2;\\n            n /= 2;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059300,
                "title": "c-1-line-code-using-builtin-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int target=start^goal;\\n\\n        return __builtin_popcount(target);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int target=start^goal;\\n\\n        return __builtin_popcount(target);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054921,
                "title": "easy-bit-manipulation-beats-100-o-log-n-beginner-friendly-solution",
                "content": "# Approach\\nUsing **Bit Manipulation**:\\n<!-- Describe your approach to solving the problem. -->\\n1. Calculate XOR of **start** and **goal**: **result** = start ^ goal.\\n2. **Count** the number of set bits in the **result**.\\n3. Return the **count**.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(log(N));\\n    Where N is the result;\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int flips = 0;\\n        int num = start ^ goal;\\n        while(num){\\n            if(num & 1){\\n                flips++;\\n            }\\n            num = num>>1;\\n        }\\n\\n        return flips;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int flips = 0;\\n        int num = start ^ goal;\\n        while(num){\\n            if(num & 1){\\n                flips++;\\n            }\\n            num = num>>1;\\n        }\\n\\n        return flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052715,
                "title": "beats-100-0ms-1-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n       return Integer.bitCount(start^goal);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n       return Integer.bitCount(start^goal);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047657,
                "title": "java-string-oneliner-xor",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        return (int) Integer.toBinaryString(start^goal).chars().filter(ch -> ch == \\'1\\').count();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        return (int) Integer.toBinaryString(start^goal).chars().filter(ch -> ch == \\'1\\').count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045442,
                "title": "very-easy-solution-beats-100-using-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThink about XOR operator\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1 XOR the given numbers.\\n2 If the bits in resultant number is 1 then it needs to be flipped as XOR of diff bits is 1.\\n3 Count the signed bits .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n    int ans=start^goal;\\n      int c=0;\\n       \\n    while(ans)\\n    {\\n        if((ans & 1)==1)\\n        c++;\\n        ans>>=1;\\n\\n    }\\n    return c;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n    int ans=start^goal;\\n      int c=0;\\n       \\n    while(ans)\\n    {\\n        if((ans & 1)==1)\\n        c++;\\n        ans>>=1;\\n\\n    }\\n    return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040332,
                "title": "solution-better",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count = 0;\\n        int a = start ^ goal;\\n        while(a){\\n            count += a & 1;\\n            a >>= 1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count = 0;\\n        int a = start ^ goal;\\n        while(a){\\n            count += a & 1;\\n            a >>= 1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040257,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count = 0;\\n        while (start != 0 || goal != 0) {\\n            if ((start & 1) != (goal & 1)) {\\n                count++;\\n            }\\n            \\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count = 0;\\n        while (start != 0 || goal != 0) {\\n            if ((start & 1) != (goal & 1)) {\\n                count++;\\n            }\\n            \\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039791,
                "title": "100-one-line-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n      return __builtin_popcount(start^goal);\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n      return __builtin_popcount(start^goal);\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036219,
                "title": "0ms-beats-all-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBtiwise difference bitween two integers is simply XOR.\\nLater just have to count one\\'s in bit representation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nhttps://en.wikipedia.org/wiki/Hamming_weight\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc minBitFlips(start int, goal int) int {\\n    x:= start^goal\\n    count:=0\\n    for ; x!=0; count++{\\n        x &= x - 1;\\n    }\\n    return count\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Math"
                ],
                "code": "```\\nfunc minBitFlips(start int, goal int) int {\\n    x:= start^goal\\n    count:=0\\n    for ; x!=0; count++{\\n        x &= x - 1;\\n    }\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4032571,
                "title": "optimised-bit-manipulation-approch",
                "content": "bi\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        //Intution Jo same hoga use nhi change karna hai\\n        //xor will give where they differ \\n        // count the difference \\n\\n        //difference means 1 if they would be same \\n        //xor will give 0\\n        int n = start^goal;\\n\\n        int flip = 0;\\n        while(n != 0){\\n            if((n&1) == 1){\\n                flip++;\\n            }\\n            n = n>>1;\\n        }\\n        return flip;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        //Intution Jo same hoga use nhi change karna hai\\n        //xor will give where they differ \\n        // count the difference \\n\\n        //difference means 1 if they would be same \\n        //xor will give 0\\n        int n = start^goal;\\n\\n        int flip = 0;\\n        while(n != 0){\\n            if((n&1) == 1){\\n                flip++;\\n            }\\n            n = n>>1;\\n        }\\n        return flip;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024457,
                "title": "python-bit-count-from-scratch",
                "content": "# Intuition\\nUsing string or built-in methods is easy.\\n\\n# Approach\\nWe will implement the bit count from scratch.\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        x = start ^ goal\\n        res = 0\\n        while x:\\n            res += 1\\n            x -= x & -x\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        x = start ^ goal\\n        res = 0\\n        while x:\\n            res += 1\\n            x -= x & -x\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021510,
                "title": "easy-java-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n       int n = start ^ goal;\\n       int count = 0;\\n       while(n!=0)\\n       {\\n           n = n & (n-1);\\n           count++;\\n       } \\n       return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Iterator",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n       int n = start ^ goal;\\n       int count = 0;\\n       while(n!=0)\\n       {\\n           n = n & (n-1);\\n           count++;\\n       } \\n       return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005474,
                "title": "java-simple-solution-beats-100",
                "content": "# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int xor = start ^ goal;\\n        int ans = 0;\\n        int rem = 0;\\n        while(xor != 0) {\\n            rem = xor % 2;\\n            if(rem == 1) {\\n                ans += 1;\\n            }\\n            xor /= 2;\\n        }        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int xor = start ^ goal;\\n        int ans = 0;\\n        int rem = 0;\\n        while(xor != 0) {\\n            rem = xor % 2;\\n            if(rem == 1) {\\n                ans += 1;\\n            }\\n            xor /= 2;\\n        }        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001113,
                "title": "1-line-solution-with-c-std-bitset-class",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nC++ proposes a bitset class for such operations.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nXOR here is to determine number of different bits. (0^1 = 1)\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <algorithm>\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n      return return std::bitset<32>(start ^ goal).count();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <algorithm>\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n      return return std::bitset<32>(start ^ goal).count();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3997675,
                "title": "harshi-s-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nto count number of bits differ in start and goal\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nused sile & to check last bit if both are diff inc cnt and did left shift repated this until both start and goal are 0\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int cnt=0;\\n        while(goal>0 || start>0)\\n        {\\n            int a=start&1, b=goal&1;\\n           if(a!=b)\\n           {\\n            cnt++;\\n           }\\n           start=start>>1;\\n           goal=goal>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int cnt=0;\\n        while(goal>0 || start>0)\\n        {\\n            int a=start&1, b=goal&1;\\n           if(a!=b)\\n           {\\n            cnt++;\\n           }\\n           start=start>>1;\\n           goal=goal>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993478,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEasy look\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nxor of the both and find the set bits on xor\\'ed value\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        y=start^goal\\n        c=0\\n        while(y>0):\\n            y=y&(y-1)\\n            c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        y=start^goal\\n        c=0\\n        while(y>0):\\n            y=y&(y-1)\\n            c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990329,
                "title": "simplest-and-fastest-solution-in-c-without-using-using-builtin-popcount-i",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int temp= start^goal;\\n        int count=0;\\n        while(temp){\\n            if(temp&1) count++;\\n            temp>>=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int temp= start^goal;\\n        int count=0;\\n        while(temp){\\n            if(temp&1) count++;\\n            temp>>=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989579,
                "title": "c-easy-to-understand-just-one-line-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989573,
                "title": "bit-flips-javascript-convert-to-string-2",
                "content": "```\\n/**\\n * @param {number} start\\n * @param {number} goal\\n * @return {number}\\n */\\nvar minBitFlips = function(start, goal) {\\n    let a = start.toString(2)\\n    let b = goal.toString(2)\\n    let len = Math.max(a.length, b.length)\\n    let count = 0\\n    \\n    for (let i = 0; i < len; i++) {\\n        n = a.at(-1 - i)\\n        m = b.at(-1 - i)\\n        if (n == undefined) n = 0\\n        if (m == undefined) m = 0\\n        n != m && count ++\\n    }\\n    \\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} start\\n * @param {number} goal\\n * @return {number}\\n */\\nvar minBitFlips = function(start, goal) {\\n    let a = start.toString(2)\\n    let b = goal.toString(2)\\n    let len = Math.max(a.length, b.length)\\n    let count = 0\\n    \\n    for (let i = 0; i < len; i++) {\\n        n = a.at(-1 - i)\\n        m = b.at(-1 - i)\\n        if (n == undefined) n = 0\\n        if (m == undefined) m = 0\\n        n != m && count ++\\n    }\\n    \\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3986545,
                "title": "begineers-friendly-c-beats100-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        string st1 = bitset<32> (start).to_string();\\n        string st2 = bitset<32> (goal).to_string();\\n        int cnt = 0;\\n\\n        for(int i = 0; i < st1.length(); i++){\\n            if(st1[i] != st2[i])\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        string st1 = bitset<32> (start).to_string();\\n        string st2 = bitset<32> (goal).to_string();\\n        int cnt = 0;\\n\\n        for(int i = 0; i < st1.length(); i++){\\n            if(st1[i] != st2[i])\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984764,
                "title": "using-and-bitwise-operator-tc-o-32-o-1-c",
                "content": "# Approach\\ncompare the bits of \\u2018A\\u2019 and \\u2018B\\u2019 at each position and count the number of differences \\n\\n# Complexity\\n- Time complexity: \\n    O(32) or O(k), where k = num of bits required to represent number\\n- Space complexity:\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int A, int B) {\\n        int count=0; \\n        for(int i=0; i<32; i++) {\\n            // bit mask to check the i-th bit position of \\'A\\' and \\'B\\'.\\n            int mask= 1<<i;\\n            \\n            // extract the i-th bit of \\'A\\' and \\'B\\' by performing a bitwise AND operation between \\'A\\' and \\'B\\' with the mask.\\n            int bitA= mask & A;\\n            int bitB= mask & B;\\n            \\n            // if the i-th bit of \\'A\\' and \\'B\\' differ, increment the counter \\'count\\' to track the number of bits that need to be flipped.\\n            if(bitA!=bitB)  count++;\\n        }\\n        return count;\\n\\n        // Time Complexity : O(K), where \\'K\\' = maximum number of bits required to represent a number\\n        // Space Complexity : O(1)\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int A, int B) {\\n        int count=0; \\n        for(int i=0; i<32; i++) {\\n            // bit mask to check the i-th bit position of \\'A\\' and \\'B\\'.\\n            int mask= 1<<i;\\n            \\n            // extract the i-th bit of \\'A\\' and \\'B\\' by performing a bitwise AND operation between \\'A\\' and \\'B\\' with the mask.\\n            int bitA= mask & A;\\n            int bitB= mask & B;\\n            \\n            // if the i-th bit of \\'A\\' and \\'B\\' differ, increment the counter \\'count\\' to track the number of bits that need to be flipped.\\n            if(bitA!=bitB)  count++;\\n        }\\n        return count;\\n\\n        // Time Complexity : O(K), where \\'K\\' = maximum number of bits required to represent a number\\n        // Space Complexity : O(1)\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984591,
                "title": "easy-4-line-cpp-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n        while(start>0 || goal>0){\\n            if((start&1==1)!=(goal&1==1))count++;\\n            start=start>>1;\\n            goal=goal>>1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n        while(start>0 || goal>0){\\n            if((start&1==1)!=(goal&1==1))count++;\\n            start=start>>1;\\n            goal=goal>>1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983029,
                "title": "c-minimum-bit-flips-to-convert-number-using-xor",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe calculate the XOR of A and B to find the differing bits between them.\\nWe then loop through the XOR result bit by bit (right to left) using bitwise operations.\\nFor each bit, we check if it\\'s set (1) and increment the count if it is.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal)\\n    {\\n        int count = 0;\\n        int XOR = start^goal;\\n        \\n        while(XOR!=0)\\n        {\\n            count = count+(XOR&1);\\n            XOR = XOR>>1;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal)\\n    {\\n        int count = 0;\\n        int XOR = start^goal;\\n        \\n        while(XOR!=0)\\n        {\\n            count = count+(XOR&1);\\n            XOR = XOR>>1;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981889,
                "title": "java-code-string-builder",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n       String s=Integer.toBinaryString(goal); \\n       String sa=Integer.toBinaryString(start); \\n       StringBuilder sb =new StringBuilder();\\n       int m=Math.max(sa.length(), s.length());\\n       int count=0;\\n       while (s.length() < m) {\\n            s = \"0\" + s;\\n        }\\n        while (sa.length() < m) {\\n            sa = \"0\" + sa;\\n        }\\n\\n       for(int i= m-1 ;i>=0;i--){\\n           if(s.charAt(i)!=sa.charAt(i)){\\n               sb.append(s.charAt(i));\\n               count++;\\n               if(sb.toString().equals(s)){\\n                   return count;\\n               }\\n           }\\n       }\\n       return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n       String s=Integer.toBinaryString(goal); \\n       String sa=Integer.toBinaryString(start); \\n       StringBuilder sb =new StringBuilder();\\n       int m=Math.max(sa.length(), s.length());\\n       int count=0;\\n       while (s.length() < m) {\\n            s = \"0\" + s;\\n        }\\n        while (sa.length() < m) {\\n            sa = \"0\" + sa;\\n        }\\n\\n       for(int i= m-1 ;i>=0;i--){\\n           if(s.charAt(i)!=sa.charAt(i)){\\n               sb.append(s.charAt(i));\\n               count++;\\n               if(sb.toString().equals(s)){\\n                   return count;\\n               }\\n           }\\n       }\\n       return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1892286,
                "content": [
                    {
                        "username": "Unpredictable007",
                        "content": "This is exactly the same problem as https://leetcode.com/problems/hamming-distance/ but with different description :)"
                    },
                    {
                        "username": "bparanj",
                        "content": "\"Minimum Number of Bit Flips to Convert Integer\" can be mapped to \"Hamming Distance\".\\n\\nThe reasoning behind this mapping is that both problems involve comparing the binary representations of two numbers. \\n\\n\"Hamming Distance\" calculates the number of positions at which the corresponding bits are different. So, if we want to convert one number to another, the minimum number of bit flips would be exactly those positions where the two numbers have differing bits. This is equivalent to calculating the Hamming distance between the two numbers.\\n\\nThe \"Minimum Number of Bit Flips to Convert Integer\" problem is simpler, as it doesn\\'t require the calculation of the exact positions of differing bits, just the count of them.\\n\\nA more complex problem would be \"Flip Bits to Maximize Number of 1\\'s\". In this problem, you are given a binary string and you can flip \\'k\\' bits from 0 to 1 with the goal to maximize the number of 1s in the string. This is more complex as it requires more than counting differing bits, it also needs strategic flipping to maximize the outcome.\\n"
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "XOR is my amor ;)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "XOR might help to get number of different bits between two number,\\nsince in XOR gives 1 for every two different bits and 0 for same bits!!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Has anyone good articles to understand XOR, like I get what it does but it never strikes me in problems how to use it. "
                    },
                    {
                        "username": "cnewman111",
                        "content": "Cracking the coding interview has good straightforward  explanations and problems to help get your feet wet"
                    },
                    {
                        "username": "prototye",
                        "content": "Replying really late, but if u still struggle with bit manipulation consider reading this post, it helped me understanding bit manipulation. Also this is not my post so no self promotion : https://leetcode.com/tag/bit-manipulation/discuss/2960396/Bit-Manipulation-Guide-and-Tricks"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "\\uD83D\\uDE80 Check this solution: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/3724804/one-of-the-most-easiest-solutions/"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2220.%20Minimum%20Bit%20Flips%20to%20Convert%20Number.cpp\\nALL LEETCODE SOLUTION IN C++\\nPlease LEAVE A STAR"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDC4B CPP EZ Amazon + Google\\uD83D\\uDE2C Interview O(set bits)\\nhttps://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/2298518/cpp-ez-amazon-google-interview-o-set-bits/"
                    }
                ]
            },
            {
                "id": 1711670,
                "content": [
                    {
                        "username": "Unpredictable007",
                        "content": "This is exactly the same problem as https://leetcode.com/problems/hamming-distance/ but with different description :)"
                    },
                    {
                        "username": "bparanj",
                        "content": "\"Minimum Number of Bit Flips to Convert Integer\" can be mapped to \"Hamming Distance\".\\n\\nThe reasoning behind this mapping is that both problems involve comparing the binary representations of two numbers. \\n\\n\"Hamming Distance\" calculates the number of positions at which the corresponding bits are different. So, if we want to convert one number to another, the minimum number of bit flips would be exactly those positions where the two numbers have differing bits. This is equivalent to calculating the Hamming distance between the two numbers.\\n\\nThe \"Minimum Number of Bit Flips to Convert Integer\" problem is simpler, as it doesn\\'t require the calculation of the exact positions of differing bits, just the count of them.\\n\\nA more complex problem would be \"Flip Bits to Maximize Number of 1\\'s\". In this problem, you are given a binary string and you can flip \\'k\\' bits from 0 to 1 with the goal to maximize the number of 1s in the string. This is more complex as it requires more than counting differing bits, it also needs strategic flipping to maximize the outcome.\\n"
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "XOR is my amor ;)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "XOR might help to get number of different bits between two number,\\nsince in XOR gives 1 for every two different bits and 0 for same bits!!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Has anyone good articles to understand XOR, like I get what it does but it never strikes me in problems how to use it. "
                    },
                    {
                        "username": "cnewman111",
                        "content": "Cracking the coding interview has good straightforward  explanations and problems to help get your feet wet"
                    },
                    {
                        "username": "prototye",
                        "content": "Replying really late, but if u still struggle with bit manipulation consider reading this post, it helped me understanding bit manipulation. Also this is not my post so no self promotion : https://leetcode.com/tag/bit-manipulation/discuss/2960396/Bit-Manipulation-Guide-and-Tricks"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "\\uD83D\\uDE80 Check this solution: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/3724804/one-of-the-most-easiest-solutions/"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2220.%20Minimum%20Bit%20Flips%20to%20Convert%20Number.cpp\\nALL LEETCODE SOLUTION IN C++\\nPlease LEAVE A STAR"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDC4B CPP EZ Amazon + Google\\uD83D\\uDE2C Interview O(set bits)\\nhttps://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/2298518/cpp-ez-amazon-google-interview-o-set-bits/"
                    }
                ]
            },
            {
                "id": 1711381,
                "content": [
                    {
                        "username": "Unpredictable007",
                        "content": "This is exactly the same problem as https://leetcode.com/problems/hamming-distance/ but with different description :)"
                    },
                    {
                        "username": "bparanj",
                        "content": "\"Minimum Number of Bit Flips to Convert Integer\" can be mapped to \"Hamming Distance\".\\n\\nThe reasoning behind this mapping is that both problems involve comparing the binary representations of two numbers. \\n\\n\"Hamming Distance\" calculates the number of positions at which the corresponding bits are different. So, if we want to convert one number to another, the minimum number of bit flips would be exactly those positions where the two numbers have differing bits. This is equivalent to calculating the Hamming distance between the two numbers.\\n\\nThe \"Minimum Number of Bit Flips to Convert Integer\" problem is simpler, as it doesn\\'t require the calculation of the exact positions of differing bits, just the count of them.\\n\\nA more complex problem would be \"Flip Bits to Maximize Number of 1\\'s\". In this problem, you are given a binary string and you can flip \\'k\\' bits from 0 to 1 with the goal to maximize the number of 1s in the string. This is more complex as it requires more than counting differing bits, it also needs strategic flipping to maximize the outcome.\\n"
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "XOR is my amor ;)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "XOR might help to get number of different bits between two number,\\nsince in XOR gives 1 for every two different bits and 0 for same bits!!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Has anyone good articles to understand XOR, like I get what it does but it never strikes me in problems how to use it. "
                    },
                    {
                        "username": "cnewman111",
                        "content": "Cracking the coding interview has good straightforward  explanations and problems to help get your feet wet"
                    },
                    {
                        "username": "prototye",
                        "content": "Replying really late, but if u still struggle with bit manipulation consider reading this post, it helped me understanding bit manipulation. Also this is not my post so no self promotion : https://leetcode.com/tag/bit-manipulation/discuss/2960396/Bit-Manipulation-Guide-and-Tricks"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "\\uD83D\\uDE80 Check this solution: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/3724804/one-of-the-most-easiest-solutions/"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2220.%20Minimum%20Bit%20Flips%20to%20Convert%20Number.cpp\\nALL LEETCODE SOLUTION IN C++\\nPlease LEAVE A STAR"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDC4B CPP EZ Amazon + Google\\uD83D\\uDE2C Interview O(set bits)\\nhttps://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/2298518/cpp-ez-amazon-google-interview-o-set-bits/"
                    }
                ]
            },
            {
                "id": 1782548,
                "content": [
                    {
                        "username": "Unpredictable007",
                        "content": "This is exactly the same problem as https://leetcode.com/problems/hamming-distance/ but with different description :)"
                    },
                    {
                        "username": "bparanj",
                        "content": "\"Minimum Number of Bit Flips to Convert Integer\" can be mapped to \"Hamming Distance\".\\n\\nThe reasoning behind this mapping is that both problems involve comparing the binary representations of two numbers. \\n\\n\"Hamming Distance\" calculates the number of positions at which the corresponding bits are different. So, if we want to convert one number to another, the minimum number of bit flips would be exactly those positions where the two numbers have differing bits. This is equivalent to calculating the Hamming distance between the two numbers.\\n\\nThe \"Minimum Number of Bit Flips to Convert Integer\" problem is simpler, as it doesn\\'t require the calculation of the exact positions of differing bits, just the count of them.\\n\\nA more complex problem would be \"Flip Bits to Maximize Number of 1\\'s\". In this problem, you are given a binary string and you can flip \\'k\\' bits from 0 to 1 with the goal to maximize the number of 1s in the string. This is more complex as it requires more than counting differing bits, it also needs strategic flipping to maximize the outcome.\\n"
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "XOR is my amor ;)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "XOR might help to get number of different bits between two number,\\nsince in XOR gives 1 for every two different bits and 0 for same bits!!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Has anyone good articles to understand XOR, like I get what it does but it never strikes me in problems how to use it. "
                    },
                    {
                        "username": "cnewman111",
                        "content": "Cracking the coding interview has good straightforward  explanations and problems to help get your feet wet"
                    },
                    {
                        "username": "prototye",
                        "content": "Replying really late, but if u still struggle with bit manipulation consider reading this post, it helped me understanding bit manipulation. Also this is not my post so no self promotion : https://leetcode.com/tag/bit-manipulation/discuss/2960396/Bit-Manipulation-Guide-and-Tricks"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "\\uD83D\\uDE80 Check this solution: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/3724804/one-of-the-most-easiest-solutions/"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2220.%20Minimum%20Bit%20Flips%20to%20Convert%20Number.cpp\\nALL LEETCODE SOLUTION IN C++\\nPlease LEAVE A STAR"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDC4B CPP EZ Amazon + Google\\uD83D\\uDE2C Interview O(set bits)\\nhttps://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/2298518/cpp-ez-amazon-google-interview-o-set-bits/"
                    }
                ]
            },
            {
                "id": 1958122,
                "content": [
                    {
                        "username": "Unpredictable007",
                        "content": "This is exactly the same problem as https://leetcode.com/problems/hamming-distance/ but with different description :)"
                    },
                    {
                        "username": "bparanj",
                        "content": "\"Minimum Number of Bit Flips to Convert Integer\" can be mapped to \"Hamming Distance\".\\n\\nThe reasoning behind this mapping is that both problems involve comparing the binary representations of two numbers. \\n\\n\"Hamming Distance\" calculates the number of positions at which the corresponding bits are different. So, if we want to convert one number to another, the minimum number of bit flips would be exactly those positions where the two numbers have differing bits. This is equivalent to calculating the Hamming distance between the two numbers.\\n\\nThe \"Minimum Number of Bit Flips to Convert Integer\" problem is simpler, as it doesn\\'t require the calculation of the exact positions of differing bits, just the count of them.\\n\\nA more complex problem would be \"Flip Bits to Maximize Number of 1\\'s\". In this problem, you are given a binary string and you can flip \\'k\\' bits from 0 to 1 with the goal to maximize the number of 1s in the string. This is more complex as it requires more than counting differing bits, it also needs strategic flipping to maximize the outcome.\\n"
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "XOR is my amor ;)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "XOR might help to get number of different bits between two number,\\nsince in XOR gives 1 for every two different bits and 0 for same bits!!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Has anyone good articles to understand XOR, like I get what it does but it never strikes me in problems how to use it. "
                    },
                    {
                        "username": "cnewman111",
                        "content": "Cracking the coding interview has good straightforward  explanations and problems to help get your feet wet"
                    },
                    {
                        "username": "prototye",
                        "content": "Replying really late, but if u still struggle with bit manipulation consider reading this post, it helped me understanding bit manipulation. Also this is not my post so no self promotion : https://leetcode.com/tag/bit-manipulation/discuss/2960396/Bit-Manipulation-Guide-and-Tricks"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "\\uD83D\\uDE80 Check this solution: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/3724804/one-of-the-most-easiest-solutions/"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2220.%20Minimum%20Bit%20Flips%20to%20Convert%20Number.cpp\\nALL LEETCODE SOLUTION IN C++\\nPlease LEAVE A STAR"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDC4B CPP EZ Amazon + Google\\uD83D\\uDE2C Interview O(set bits)\\nhttps://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/2298518/cpp-ez-amazon-google-interview-o-set-bits/"
                    }
                ]
            },
            {
                "id": 1806696,
                "content": [
                    {
                        "username": "Unpredictable007",
                        "content": "This is exactly the same problem as https://leetcode.com/problems/hamming-distance/ but with different description :)"
                    },
                    {
                        "username": "bparanj",
                        "content": "\"Minimum Number of Bit Flips to Convert Integer\" can be mapped to \"Hamming Distance\".\\n\\nThe reasoning behind this mapping is that both problems involve comparing the binary representations of two numbers. \\n\\n\"Hamming Distance\" calculates the number of positions at which the corresponding bits are different. So, if we want to convert one number to another, the minimum number of bit flips would be exactly those positions where the two numbers have differing bits. This is equivalent to calculating the Hamming distance between the two numbers.\\n\\nThe \"Minimum Number of Bit Flips to Convert Integer\" problem is simpler, as it doesn\\'t require the calculation of the exact positions of differing bits, just the count of them.\\n\\nA more complex problem would be \"Flip Bits to Maximize Number of 1\\'s\". In this problem, you are given a binary string and you can flip \\'k\\' bits from 0 to 1 with the goal to maximize the number of 1s in the string. This is more complex as it requires more than counting differing bits, it also needs strategic flipping to maximize the outcome.\\n"
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "XOR is my amor ;)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "XOR might help to get number of different bits between two number,\\nsince in XOR gives 1 for every two different bits and 0 for same bits!!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Has anyone good articles to understand XOR, like I get what it does but it never strikes me in problems how to use it. "
                    },
                    {
                        "username": "cnewman111",
                        "content": "Cracking the coding interview has good straightforward  explanations and problems to help get your feet wet"
                    },
                    {
                        "username": "prototye",
                        "content": "Replying really late, but if u still struggle with bit manipulation consider reading this post, it helped me understanding bit manipulation. Also this is not my post so no self promotion : https://leetcode.com/tag/bit-manipulation/discuss/2960396/Bit-Manipulation-Guide-and-Tricks"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "\\uD83D\\uDE80 Check this solution: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/3724804/one-of-the-most-easiest-solutions/"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2220.%20Minimum%20Bit%20Flips%20to%20Convert%20Number.cpp\\nALL LEETCODE SOLUTION IN C++\\nPlease LEAVE A STAR"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDC4B CPP EZ Amazon + Google\\uD83D\\uDE2C Interview O(set bits)\\nhttps://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/2298518/cpp-ez-amazon-google-interview-o-set-bits/"
                    }
                ]
            },
            {
                "id": 1685889,
                "content": [
                    {
                        "username": "Unpredictable007",
                        "content": "This is exactly the same problem as https://leetcode.com/problems/hamming-distance/ but with different description :)"
                    },
                    {
                        "username": "bparanj",
                        "content": "\"Minimum Number of Bit Flips to Convert Integer\" can be mapped to \"Hamming Distance\".\\n\\nThe reasoning behind this mapping is that both problems involve comparing the binary representations of two numbers. \\n\\n\"Hamming Distance\" calculates the number of positions at which the corresponding bits are different. So, if we want to convert one number to another, the minimum number of bit flips would be exactly those positions where the two numbers have differing bits. This is equivalent to calculating the Hamming distance between the two numbers.\\n\\nThe \"Minimum Number of Bit Flips to Convert Integer\" problem is simpler, as it doesn\\'t require the calculation of the exact positions of differing bits, just the count of them.\\n\\nA more complex problem would be \"Flip Bits to Maximize Number of 1\\'s\". In this problem, you are given a binary string and you can flip \\'k\\' bits from 0 to 1 with the goal to maximize the number of 1s in the string. This is more complex as it requires more than counting differing bits, it also needs strategic flipping to maximize the outcome.\\n"
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "XOR is my amor ;)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "XOR might help to get number of different bits between two number,\\nsince in XOR gives 1 for every two different bits and 0 for same bits!!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Has anyone good articles to understand XOR, like I get what it does but it never strikes me in problems how to use it. "
                    },
                    {
                        "username": "cnewman111",
                        "content": "Cracking the coding interview has good straightforward  explanations and problems to help get your feet wet"
                    },
                    {
                        "username": "prototye",
                        "content": "Replying really late, but if u still struggle with bit manipulation consider reading this post, it helped me understanding bit manipulation. Also this is not my post so no self promotion : https://leetcode.com/tag/bit-manipulation/discuss/2960396/Bit-Manipulation-Guide-and-Tricks"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "\\uD83D\\uDE80 Check this solution: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/3724804/one-of-the-most-easiest-solutions/"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2220.%20Minimum%20Bit%20Flips%20to%20Convert%20Number.cpp\\nALL LEETCODE SOLUTION IN C++\\nPlease LEAVE A STAR"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDC4B CPP EZ Amazon + Google\\uD83D\\uDE2C Interview O(set bits)\\nhttps://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/2298518/cpp-ez-amazon-google-interview-o-set-bits/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Trailing Zeros in a Cornered Path",
        "question_content": "<p>You are given a 2D integer array <code>grid</code> of size <code>m x n</code>, where each cell contains a positive integer.</p>\n\n<p>A <strong>cornered path</strong> is defined as a set of adjacent cells with <strong>at most</strong> one turn. More specifically, the path should exclusively move either <strong>horizontally</strong> or <strong>vertically</strong> up to the turn (if there is one), without returning to a previously visited cell. After the turn, the path will then move exclusively in the <strong>alternate</strong> direction: move vertically if it moved horizontally, and vice versa, also without returning to a previously visited cell.</p>\n\n<p>The <strong>product</strong> of a path is defined as the product of all the values in the path.</p>\n\n<p>Return <em>the <strong>maximum</strong> number of <strong>trailing zeros</strong> in the product of a cornered path found in </em><code>grid</code>.</p>\n\n<p>Note:</p>\n\n<ul>\n\t<li><strong>Horizontal</strong> movement means moving in either the left or right direction.</li>\n\t<li><strong>Vertical</strong> movement means moving in either the up or down direction.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/23/ex1new2.jpg\" style=\"width: 577px; height: 190px;\" />\n<pre>\n<strong>Input:</strong> grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The grid on the left shows a valid cornered path.\nIt has a product of 15 * 20 * 6 * 1 * 10 = 18000 which has 3 trailing zeros.\nIt can be shown that this is the maximum trailing zeros in the product of a cornered path.\n\nThe grid in the middle is not a cornered path as it has more than one turn.\nThe grid on the right is not a cornered path as it requires a return to a previously visited cell.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/25/ex2.jpg\" style=\"width: 150px; height: 157px;\" />\n<pre>\n<strong>Input:</strong> grid = [[4,3,2],[7,6,1],[8,8,8]]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The grid is shown in the figure above.\nThere are no cornered paths in the grid that result in a product with a trailing zero.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1955515,
                "title": "prefix-sum-of-factors-2-and-5",
                "content": "The approach is not too hard to get, but the implementation is such a tongue-twister (or fingers-twister, I should say).\\n\\nFirst, instead of multiplication, we just need to sum factors of `2` and `5`. Each pair of those factors produce one trailing zero.\\n\\nWe use grids `h` and `v` to compute prefix sum for each horizontal and vertical line in the grid. Note that we store the count of each factor separatelly. \\n\\nThen, for each position in the grid, we check four paths: `v1 + h1`, `v1 + h2`, `v2 + h1`, `v2 + h2`.\\n\\nWe count factors for each path, and track the maximum number of factor pairs (each pair gives us a trailing zero).\\n\\n> I am not sure if we can use one grid instead of `v` and `h` and do some clever deduction, but the solution is already hard to debug with two grids. \\n\\nThis is how the prefix sum grids look like for example 1 (see problem description), with the visualization for `v1`, `v2`, `h1` and `h2` sub-paths.\\n\\n![image](https://assets.leetcode.com/users/images/881c18fd-0d0a-4b02-9f1e-06ccb0882df7_1650190116.5992572.png)\\n\\n**C++**\\n```cpp\\narray<int, 2> operator+(const array<int, 2> &l, const array<int, 2> &r) { return { l[0] + r[0], l[1] + r[1] }; }\\narray<int, 2> operator-(const array<int, 2> &l, const array<int, 2> &r) { return { l[0] - r[0], l[1] - r[1] }; }\\nint pairs(const array<int, 2> &p) { return min(p[0], p[1]); }\\n\\nclass Solution {\\npublic:\\nint factors(int i, int f) {\\n    return i % f ? 0 : 1 + factors(i / f, f);\\n}\\nint maxTrailingZeros(vector<vector<int>>& grid) {\\n    int m = grid.size(), n = grid[0].size(), res = 0;\\n    vector<vector<array<int, 2>>> h(m, vector<array<int, 2>>(n + 1)), v(m + 1, vector<array<int, 2>>(n));\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j) {\\n            array<int, 2> f25 = { factors(grid[i][j], 2), factors(grid[i][j], 5) };\\n            v[i + 1][j] = v[i][j] + f25;\\n            h[i][j + 1] = h[i][j] + f25;\\n        }\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j) {\\n            auto v1 = v[i + 1][j], v2 = v[m][j] - v[i][j];\\n            auto h1 = h[i][j], h2 = h[i][n] - h[i][j + 1];\\n            res = max({res, pairs(v1 + h1), pairs(v1 + h2), pairs(v2 + h1), pairs(v2 + h2)});\\n        }\\n    return res;\\n}\\n};\\n```\\n**Complexity Analysis**\\n- Time: O(n * m); we go through the grid twice; prefix sum grids allow computing zeros in O(1).\\n- Memory: O(n * m) for prefix sum grids.",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\narray<int, 2> operator+(const array<int, 2> &l, const array<int, 2> &r) { return { l[0] + r[0], l[1] + r[1] }; }\\narray<int, 2> operator-(const array<int, 2> &l, const array<int, 2> &r) { return { l[0] - r[0], l[1] - r[1] }; }\\nint pairs(const array<int, 2> &p) { return min(p[0], p[1]); }\\n\\nclass Solution {\\npublic:\\nint factors(int i, int f) {\\n    return i % f ? 0 : 1 + factors(i / f, f);\\n}\\nint maxTrailingZeros(vector<vector<int>>& grid) {\\n    int m = grid.size(), n = grid[0].size(), res = 0;\\n    vector<vector<array<int, 2>>> h(m, vector<array<int, 2>>(n + 1)), v(m + 1, vector<array<int, 2>>(n));\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j) {\\n            array<int, 2> f25 = { factors(grid[i][j], 2), factors(grid[i][j], 5) };\\n            v[i + 1][j] = v[i][j] + f25;\\n            h[i][j + 1] = h[i][j] + f25;\\n        }\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j) {\\n            auto v1 = v[i + 1][j], v2 = v[m][j] - v[i][j];\\n            auto h1 = h[i][j], h2 = h[i][n] - h[i][j + 1];\\n            res = max({res, pairs(v1 + h1), pairs(v1 + h2), pairs(v2 + h1), pairs(v2 + h2)});\\n        }\\n    return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955347,
                "title": "c-easy-to-understand-simple-prefix-sum-greedy-approach",
                "content": "**Approach is very simple but the implementation needed some level of patience.**\\n\\n**we first create a matrix with the number of factors of 2\\'s and 5\\'s in each of the grids of the given matrix. I used vector<vector<pair<int,int>>> v , to do the same.**\\n\\n**Then, we are creating 4 prefix sum matrices(of the number of 2\\'s and 5\\'s) which will store the value of the prefixsum from left to right(named as ltr), right to left(rtl), up to down(utd) and down to up(dtu). After creating the matrices we will be iterating through the v and finding the maximum of the minimum of 2\\'s and 5\\'s on the 4 possible cases (utd+ltr),(utd+rtl),(dtu+ltr),(dtu+rtl) and that maximum will be our answer.**\\n\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<pair<ll,ll>>> v(n,vector<pair<ll,ll>>(m,{0,0})),ltr,utd,rtl,dtu;\\n        \\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=0;j<m;j++)\\n            {\\n                ll z=grid[i][j],c1=0,c2=0;\\n                while(z%2==0)\\n                {\\n                    z/=2;\\n                    c1++;\\n                }\\n                while(z%5==0)\\n                {\\n                    z/=5;\\n                    c2++;\\n                }\\n                v[i][j].first=c1;\\n                v[i][j].second=c2;\\n            }\\n        }\\n        ltr=utd=rtl=dtu=v;\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=1;j<m;j++)\\n            {\\n                ltr[i][j].first+=ltr[i][j-1].first;\\n                ltr[i][j].second+=ltr[i][j-1].second;\\n            }\\n        }\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=m-2;j>=0;j--)\\n            {\\n                rtl[i][j].first+=rtl[i][j+1].first;\\n                rtl[i][j].second+=rtl[i][j+1].second;\\n            }\\n        }\\n        for(ll j=0;j<m;j++)\\n        {\\n            for(ll i=1;i<n;i++)\\n            {\\n                utd[i][j].first+=utd[i-1][j].first;\\n                utd[i][j].second+=utd[i-1][j].second;\\n            }\\n        }\\n        for(ll j=0;j<m;j++)\\n        {\\n            for(ll i=n-2;i>=0;i--)\\n            {\\n                dtu[i][j].first+=dtu[i+1][j].first;\\n                dtu[i][j].second+=dtu[i+1][j].second;\\n            }\\n        }\\n        ll ans=0;\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=0;j<m;j++)\\n            {\\n                ll c1,c2,c3,c4;\\n                ll x1,x2,x3,x4;\\n                ll a,b;\\n                a=v[i][j].first;\\n                b=v[i][j].second;       \\n                \\n                c1=ltr[i][j].first;\\n                c2=rtl[i][j].first;\\n                \\n                c3=utd[i][j].first;\\n                c4=dtu[i][j].first;\\n                \\n                x1=ltr[i][j].second;\\n                x2=rtl[i][j].second;\\n                \\n                x3=utd[i][j].second;\\n                x4=dtu[i][j].second;\\n                \\n                ans=max(ans,min(c3+c1-a,x3+x1-b));\\n                ans=max(ans,min(c3+c2-a,x3+x2-b));\\n                ans=max(ans,min(c4+c1-a,x4+x1-b));\\n                ans=max(ans,min(c4+c2-a,x4+x2-b));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<pair<ll,ll>>> v(n,vector<pair<ll,ll>>(m,{0,0})),ltr,utd,rtl,dtu;\\n        \\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=0;j<m;j++)\\n            {\\n                ll z=grid[i][j],c1=0,c2=0;\\n                while(z%2==0)\\n                {\\n                    z/=2;\\n                    c1++;\\n                }\\n                while(z%5==0)\\n                {\\n                    z/=5;\\n                    c2++;\\n                }\\n                v[i][j].first=c1;\\n                v[i][j].second=c2;\\n            }\\n        }\\n        ltr=utd=rtl=dtu=v;\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=1;j<m;j++)\\n            {\\n                ltr[i][j].first+=ltr[i][j-1].first;\\n                ltr[i][j].second+=ltr[i][j-1].second;\\n            }\\n        }\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=m-2;j>=0;j--)\\n            {\\n                rtl[i][j].first+=rtl[i][j+1].first;\\n                rtl[i][j].second+=rtl[i][j+1].second;\\n            }\\n        }\\n        for(ll j=0;j<m;j++)\\n        {\\n            for(ll i=1;i<n;i++)\\n            {\\n                utd[i][j].first+=utd[i-1][j].first;\\n                utd[i][j].second+=utd[i-1][j].second;\\n            }\\n        }\\n        for(ll j=0;j<m;j++)\\n        {\\n            for(ll i=n-2;i>=0;i--)\\n            {\\n                dtu[i][j].first+=dtu[i+1][j].first;\\n                dtu[i][j].second+=dtu[i+1][j].second;\\n            }\\n        }\\n        ll ans=0;\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=0;j<m;j++)\\n            {\\n                ll c1,c2,c3,c4;\\n                ll x1,x2,x3,x4;\\n                ll a,b;\\n                a=v[i][j].first;\\n                b=v[i][j].second;       \\n                \\n                c1=ltr[i][j].first;\\n                c2=rtl[i][j].first;\\n                \\n                c3=utd[i][j].first;\\n                c4=dtu[i][j].first;\\n                \\n                x1=ltr[i][j].second;\\n                x2=rtl[i][j].second;\\n                \\n                x3=utd[i][j].second;\\n                x4=dtu[i][j].second;\\n                \\n                ans=max(ans,min(c3+c1-a,x3+x1-b));\\n                ans=max(ans,min(c3+c2-a,x3+x2-b));\\n                ans=max(ans,min(c4+c1-a,x4+x1-b));\\n                ans=max(ans,min(c4+c2-a,x4+x2-b));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955607,
                "title": "python-explanation-with-pictures-prefix-sum",
                "content": "Please also refer to [votrubac](https://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/discuss/1955515/Prefix-Sum-of-Factors-2-and-5) \\'s solution as he has a perfect picture explanation of prefix sum.\\n\\nLet\\'s focus on the pivot point of an edge, once the pivot point is fixed, the edge can only from the four cases below.\\n\\n![image](https://assets.leetcode.com/users/images/b91a94f3-ca21-49d7-af85-662f80023fa0_1650169235.6731899.png)\\n\\nIt look familiar, we can build two (or four if you prefer) prefix sum array to save the cumulative factors. \\nImagine we build `left` to save the all the factors in the same row on `A[i][j]`\\'s left, and build `top` to save all the factors in the same colomn on `A[i][j]`\\'s top. Notice we might add or minus the `A[i][j]` itself twice.\\n\\n\\n![image](https://assets.leetcode.com/users/images/20d53765-2b44-455b-90d4-c44d94c7388d_1650169239.717305.png)\\n\\nWe only need to save the number of two factors: `2, 5`. It\\'s quite straightforward to get the number of trailing zeros from these numbers of factors.\\n\\n![image](https://assets.leetcode.com/users/images/2f0cb380-ecfa-4364-b91b-30f43ed6f418_1650170082.105669.png)\\n\\n> In case I didn\\'t explain it well.\\n> `a->[2\\'s, 5\\'s]`\\n> 40 = 2\\\\*2\\\\*2\\\\*5, three 2\\'s and one 5, thus we let `40=[3,1]`\\n> Similarly, `23=[0,0]` since it has no factor as 2 or 5, \\n> `1500=3\\\\*2\\\\*2\\\\*5\\\\*5\\\\*5`, thus we let `1500=[2,3]` \\n> Hence, `40*23*1500` has `[5,4]` which makes 4 trailing zeros.\\n\\n**complexity**\\nTime: O(n)\\nSpace: O(n)\\n\\n**code**\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, A: List[List[int]]) -> int:\\n        m, n = len(A), len(A[0])\\n        left = [[[0, 0] for _ in range(n)] for _ in range(m)]\\n        top = [[[0, 0] for _ in range(n)] for _ in range(m)]\\n        \\n        def helper(num):\\n            a, b = 0, 0\\n            while num % 2 == 0:\\n                num //= 2\\n                a += 1\\n            while num % 5 == 0:\\n                num //= 5\\n                b += 1\\n            return [a, b]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if j == 0:\\n                    left[i][j] = helper(A[i][j])\\n                else:\\n                    a, b = helper(A[i][j])\\n                    left[i][j][0] = left[i][j - 1][0] + a\\n                    left[i][j][1] = left[i][j - 1][1] + b\\n        for j in range(n):\\n            for i in range(m):\\n                if i == 0:\\n                    top[i][j] = helper(A[i][j])\\n                else:\\n                    a, b, = helper(A[i][j])\\n                    top[i][j][0] = top[i - 1][j][0] + a               \\n                    top[i][j][1] = top[i - 1][j][1] + b\\n\\n\\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                a, b = top[m - 1][j]\\n                d, e= left[i][n - 1]\\n                x, y = helper(A[i][j])\\n                a1, b1 = top[i][j]\\n                a2, b2= left[i][j]\\n                tmp = [a1 + a2 - x, b1 + b2 - y]\\n                ans = max(ans, min(tmp))\\n                tmp = [d - a2 + a1, e - b2 + b1]\\n                ans = max(ans, min(tmp))             \\n                tmp = [a - a1 + a2, b - b1 + b2]\\n                ans = max(ans, min(tmp))\\n                tmp = [a + d - a1 - a2 + x, b + e - b1 - b2 + y]\\n                ans = max(ans, min(tmp))\\n                \\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, A: List[List[int]]) -> int:\\n        m, n = len(A), len(A[0])\\n        left = [[[0, 0] for _ in range(n)] for _ in range(m)]\\n        top = [[[0, 0] for _ in range(n)] for _ in range(m)]\\n        \\n        def helper(num):\\n            a, b = 0, 0\\n            while num % 2 == 0:\\n                num //= 2\\n                a += 1\\n            while num % 5 == 0:\\n                num //= 5\\n                b += 1\\n            return [a, b]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if j == 0:\\n                    left[i][j] = helper(A[i][j])\\n                else:\\n                    a, b = helper(A[i][j])\\n                    left[i][j][0] = left[i][j - 1][0] + a\\n                    left[i][j][1] = left[i][j - 1][1] + b\\n        for j in range(n):\\n            for i in range(m):\\n                if i == 0:\\n                    top[i][j] = helper(A[i][j])\\n                else:\\n                    a, b, = helper(A[i][j])\\n                    top[i][j][0] = top[i - 1][j][0] + a               \\n                    top[i][j][1] = top[i - 1][j][1] + b\\n\\n\\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                a, b = top[m - 1][j]\\n                d, e= left[i][n - 1]\\n                x, y = helper(A[i][j])\\n                a1, b1 = top[i][j]\\n                a2, b2= left[i][j]\\n                tmp = [a1 + a2 - x, b1 + b2 - y]\\n                ans = max(ans, min(tmp))\\n                tmp = [d - a2 + a1, e - b2 + b1]\\n                ans = max(ans, min(tmp))             \\n                tmp = [a - a1 + a2, b - b1 + b2]\\n                ans = max(ans, min(tmp))\\n                tmp = [a + d - a1 - a2 + x, b + e - b1 - b2 + y]\\n                ans = max(ans, min(tmp))\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959385,
                "title": "7-lines-python-numpy",
                "content": "Perfect opportunity to practice NumPy. Gets accepted in ~2200 ms, seems relatively fast. Actual time is about 900 ms, judge overhead is ~1300 here. See benchmark in the comments.\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        A = np.array(grid)\\n        def cumdivs(d):\\n            D = sum(A % d**i == 0 for i in range(1, 10))\\n            return D.cumsum(0) + D.cumsum(1) - D\\n        return max(np.minimum(cumdivs(2), cumdivs(5)).max()\\n                   for _ in range(4)\\n                   if [A := np.rot90(A)])\\n```\\nMy helper function `cumdivs` first computes divisibility by divisor 2 or 5, as that\\'s the factors we need to get zeros: It counts for each value in the grid how often it is divisible by divisor `d`. I try up to 9 times, since 2<sup>9</sup>=512 is the largest possible (since the numbers are guaranteed to not exceed 1000). Then it computes and combines the cumulative sums of the divisibilities on both axes (and subtracts each value\\'s divisibility in order to not double-count it).\\n\\nThat only covers one pair of directions. So I do it four times, rotating the matrix by 90 degrees in between.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport numpy as np\\n\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        A = np.array(grid)\\n        def cumdivs(d):\\n            D = sum(A % d**i == 0 for i in range(1, 10))\\n            return D.cumsum(0) + D.cumsum(1) - D\\n        return max(np.minimum(cumdivs(2), cumdivs(5)).max()\\n                   for _ in range(4)\\n                   if [A := np.rot90(A)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956213,
                "title": "c-prefix-sum-easy-to-understand-beats-100-space-and-time",
                "content": "* **Explanation:**\\n\\t* Consider every element of the grid as the corner point of the cornered path. Now there can be four possible ways of making an \\'L\\' Shape figure. \\n\\t* \\tWe need to make **prefix matrices of pairs** to store the prefix sum of exponent of 5\\'s and 2\\'s of each element in the grid, otherwise if we store the whole multiplication result, then it would create integer overflow.\\n\\t * And **we need only two prefix matrices**, because the result of other two sides will be calculated by subtracting from total sum of that side. \\t\\n\\t * To get the count of trailing 0\\'s we have to take the minimum of count of 5 and 2 from the pairs.\\n\\t * The case of 0 turns that is horizontally straight or vertically straight path will be handled automatically by prefix sum matrix.\\n\\n* **Time Complexity: O(MxN)**\\n* **Space Complexity: O(MxN)**\\n\\n```\\n\\t//to get the exponent of 5 and 2 in the number\\n    pair<int,int> getPair(int x){\\n        int five = 0, two = 0;\\n        while(x % 5 == 0){\\n            five++; x /= 5;\\n        }\\n        while(x % 2 == 0){\\n            two++; x /= 2;\\n        }\\n        return {five,two};\\n    } \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int r = grid.size(), c = grid[0].size(), ans = 0;\\n        vector<vector<pair<int,int>>>top(r, vector<pair<int,int>>(c,{0,0})), left(r, vector<pair<int,int>>(c,{0,0}));\\n        \\n        //top[i][j] will store sum of exponent of 5\\'s and 2\\'s from grid[0][j] to grid[i][j]\\n        for(int i = 0; i < r; i++){\\n            for(int j = 0; j < c; j++){\\n                if(i == 0) top[i][j] = getPair(grid[i][j]);\\n                else{\\n                    pair<int,int>p = getPair(grid[i][j]);\\n                    top[i][j].first = top[i-1][j].first + p.first;\\n                    top[i][j].second = top[i-1][j].second + p.second;\\n                }\\n            }\\n        }\\n        //left[i][j] will store sum of exponent of 5\\'s and 2\\'s from grid[i][0] to grid[i][j]\\n        for(int i = 0; i < r; i++){\\n            for(int j = 0; j < c; j++){\\n                if(j == 0) left[i][j] = getPair(grid[i][j]); \\n                else{\\n                    pair<int,int>p = getPair(grid[i][j]);\\n                    left[i][j].first = left[i][j-1].first + p.first;\\n                    left[i][j].second = left[i][j-1].second + p.second;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < r; i++){\\n            for(int j = 0; j < c; j++){\\n                pair<int,int>down, right;\\n                pair<int,int>curr = getPair(grid[i][j]);\\n                \\n                down.first = top[r-1][j].first - top[i][j].first, down.second = top[r-1][j].second - top[i][j].second;\\n                right.first = left[i][c-1].first - left[i][j].first, right.second = left[i][c-1].second - left[i][j].second;\\n                                \\n                //four cases ---> (down,left), (down,right), (top,left), (top,right)\\n                ans = max(ans, min(down.first + left[i][j].first, down.second + left[i][j].second));\\n                ans = max(ans, min(down.first + right.first + curr.first, down.second + right.second + curr.second));\\n                ans = max(ans, min(top[i][j].first + left[i][j].first - curr.first, top[i][j].second + left[i][j].second - curr.second));\\n                ans = max(ans, min(top[i][j].first + right.first, top[i][j].second + right.second));\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\n\\t//to get the exponent of 5 and 2 in the number\\n    pair<int,int> getPair(int x){\\n        int five = 0, two = 0;\\n        while(x % 5 == 0){\\n            five++; x /= 5;\\n        }\\n        while(x % 2 == 0){\\n            two++; x /= 2;\\n        }\\n        return {five,two};\\n    } \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int r = grid.size(), c = grid[0].size(), ans = 0;\\n        vector<vector<pair<int,int>>>top(r, vector<pair<int,int>>(c,{0,0})), left(r, vector<pair<int,int>>(c,{0,0}));\\n        \\n        //top[i][j] will store sum of exponent of 5\\'s and 2\\'s from grid[0][j] to grid[i][j]\\n        for(int i = 0; i < r; i++){\\n            for(int j = 0; j < c; j++){\\n                if(i == 0) top[i][j] = getPair(grid[i][j]);\\n                else{\\n                    pair<int,int>p = getPair(grid[i][j]);\\n                    top[i][j].first = top[i-1][j].first + p.first;\\n                    top[i][j].second = top[i-1][j].second + p.second;\\n                }\\n            }\\n        }\\n        //left[i][j] will store sum of exponent of 5\\'s and 2\\'s from grid[i][0] to grid[i][j]\\n        for(int i = 0; i < r; i++){\\n            for(int j = 0; j < c; j++){\\n                if(j == 0) left[i][j] = getPair(grid[i][j]); \\n                else{\\n                    pair<int,int>p = getPair(grid[i][j]);\\n                    left[i][j].first = left[i][j-1].first + p.first;\\n                    left[i][j].second = left[i][j-1].second + p.second;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < r; i++){\\n            for(int j = 0; j < c; j++){\\n                pair<int,int>down, right;\\n                pair<int,int>curr = getPair(grid[i][j]);\\n                \\n                down.first = top[r-1][j].first - top[i][j].first, down.second = top[r-1][j].second - top[i][j].second;\\n                right.first = left[i][c-1].first - left[i][j].first, right.second = left[i][c-1].second - left[i][j].second;\\n                                \\n                //four cases ---> (down,left), (down,right), (top,left), (top,right)\\n                ans = max(ans, min(down.first + left[i][j].first, down.second + left[i][j].second));\\n                ans = max(ans, min(down.first + right.first + curr.first, down.second + right.second + curr.second));\\n                ans = max(ans, min(top[i][j].first + left[i][j].first - curr.first, top[i][j].second + left[i][j].second - curr.second));\\n                ans = max(ans, min(top[i][j].first + right.first, top[i][j].second + right.second));\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1960982,
                "title": "c-100-fastest-easy-understanding-with-picture",
                "content": "This question is asking about \\n* \"Trailing zeros\"\\n* \"Cornered Path\"\\n\\n**Basic idea 1: we only care about the count of 2 and the count of 5.**\\nFor instance, if we have \"{2,8,10,30}\" => 2 x 8 x10x 30 = 4800 => trailing zeros = 2\\nWe can transfer this array into the count of 2 and 5\\ncount of 2: {1,3,1,2} => prefix sum of 2: {1,4,5,7}\\ncount of 5: {0,0,1,1} => prefix sum of 5: {0,0,1,2}\\nTherefore, the trailing zeros will be  minimum(7,2) = 2\\n\\nAfter basic idea 1, we can create two matrix\\nQuestion\\n![image](https://assets.leetcode.com/users/images/23cf94ee-e461-4556-9e3d-d6183b8e781c_1650289746.9719374.png)\\n\\nTrafnser into\\n![image](https://assets.leetcode.com/users/images/1615924b-86bd-4fc3-92fd-686101bfde57_1650289803.599491.png)\\n![image](https://assets.leetcode.com/users/images/373ff873-ab78-4ff2-bf51-c238700f43e8_1650289818.1484864.png)\\n\\n\\n**Basic idea 2: Cornered Path**\\n![image](https://assets.leetcode.com/users/images/f39b0c56-2fc4-45c2-ba12-48c575d5b7ce_1650290157.0635967.png)\\nThe answer will be the minimun of these for cases.\\n\\nWe can use \"Horizontal prefix sum\" matrix and \"Vertical prefix sum\" matrix ot get the result of these four cases.\\n![image](https://assets.leetcode.com/users/images/964cf894-c5a7-4b77-a141-52800833a1a4_1650290857.2102344.png)\\n\\nFor example, we can use prefix sum to gernerate a result\\nthe result will be min( horizontal2, horizantal 5) + min (vertical 2, vertical 5)\\n![image](https://assets.leetcode.com/users/images/f70197a9-02b1-4a20-9b7e-616255e439c8_1650291569.4562247.png)\\n\\nIn this case, the answer will be\\nmin (3,1) + min(3,2) = 1 + 2 = 3\\n\\nThat\\'s the whole idea!\\n\\n\\n**My implementation:**\\n\\n```\\nint maxTrailingZeros(vector<vector<int>>& grid) {\\n        int result = 0;\\n\\n\\t\\t// gernerate matrix of 2 and matrix of 5\\n        vector< vector<int> > dp2(grid.size(), vector<int>(grid[0].size(), 0));\\n        vector< vector<int> > dp5(grid.size(), vector<int>(grid[0].size(), 0));\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[i].size(); j++) {\\n                int tmp = grid[i][j];\\n                while (tmp % 2 == 0) {\\n                    tmp = tmp / 2;\\n                    dp2[i][j]++;\\n                }\\n                while (tmp % 5 == 0) {\\n                    tmp = tmp / 5;\\n                    dp5[i][j]++;\\n                }\\n            }\\n        }        \\n        \\n        vector< vector<int> > dp2HorizontalSum(grid.size(), vector<int>(grid[0].size(), 0));\\n        vector< vector<int> > dp5HorizontalSum(grid.size(), vector<int>(grid[0].size(), 0));\\n        \\n\\t\\t// Generate horizontal prefix sum array\\n        for (int i = 0; i < dp2.size(); i++) {\\n            for (int j = 0; j < dp2[0].size(); j++) {\\n                if (j == 0) {\\n                    dp2HorizontalSum[i][j] = dp2[i][j];\\n                    dp5HorizontalSum[i][j] = dp5[i][j];\\n                } else {\\n                    dp2HorizontalSum[i][j] = dp2HorizontalSum[i][j - 1] + dp2[i][j];\\n                    dp5HorizontalSum[i][j] = dp5HorizontalSum[i][j - 1] + dp5[i][j];\\n                }\\n\\n            }\\n        }    \\n        \\n\\t\\t// Generate vertical prefix sum array\\n        vector< vector<int> > dp2VerticalSum(grid.size(), vector<int>(grid[0].size(), 0));\\n        vector< vector<int> > dp5VerticalSum(grid.size(), vector<int>(grid[0].size(), 0));\\n        for (int i = 0; i < dp2.size(); i++) {\\n            for (int j = 0; j < dp2[0].size(); j++) {\\n                if (i == 0) {\\n                    dp2VerticalSum[i][j] = dp2[i][j];\\n                    dp5VerticalSum[i][j] = dp5[i][j];\\n                } else {\\n                    dp2VerticalSum[i][j] = dp2VerticalSum[i - 1][j] + dp2[i][j];\\n                    dp5VerticalSum[i][j] = dp5VerticalSum[i - 1][j] + dp5[i][j];\\n                }\\n            }\\n        }\\n        \\n\\t\\t// Iterate every element and pick the biggest one to be the result.\\n        for (int i = 0; i < dp2.size(); i++) {\\n            for (int j = 0; j < dp2[0].size(); j++) {\\n                int dp2H1 = dp2HorizontalSum[i][j];\\n                int dp2H2 = dp2HorizontalSum[i][dp2[0].size() -1] - dp2HorizontalSum[i][j] + dp2[i][j];\\n                int dp2V1 = dp2VerticalSum[i][j];\\n                int dp2V2 = dp2VerticalSum[dp2.size() - 1][j] - dp2VerticalSum[i][j] + dp2[i][j];\\n                \\n                int dp5H1 = dp5HorizontalSum[i][j];\\n                int dp5H2 = dp5HorizontalSum[i][dp5[0].size()  -1] - dp5HorizontalSum[i][j] + dp5[i][j];\\n                int dp5V1 = dp5VerticalSum[i][j];\\n                int dp5V2 = dp5VerticalSum[dp5.size() - 1][j] - dp5VerticalSum[i][j] + dp5[i][j];\\n                \\n                int tmp = max(  min(dp2H1 + dp2V1 - dp2[i][j], dp5H1 + dp5V1 - dp5[i][j]), min(dp2H1 + dp2V2 - dp2[i][j], dp5H1 + dp5V2 - dp5[i][j]) );\\n                tmp = max(tmp, min(dp2H2 + dp2V1 - dp2[i][j], dp5H2 + dp5V1 - dp5[i][j]));\\n                tmp = max(tmp, min(dp2H2 + dp2V2 - dp2[i][j], dp5H2 + dp5V2 - dp5[i][j]));\\n                \\n                if (tmp > result) {\\n                    result = tmp;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nint maxTrailingZeros(vector<vector<int>>& grid) {\\n        int result = 0;\\n\\n\\t\\t// gernerate matrix of 2 and matrix of 5\\n        vector< vector<int> > dp2(grid.size(), vector<int>(grid[0].size(), 0));\\n        vector< vector<int> > dp5(grid.size(), vector<int>(grid[0].size(), 0));\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[i].size(); j++) {\\n                int tmp = grid[i][j];\\n                while (tmp % 2 == 0) {\\n                    tmp = tmp / 2;\\n                    dp2[i][j]++;\\n                }\\n                while (tmp % 5 == 0) {\\n                    tmp = tmp / 5;\\n                    dp5[i][j]++;\\n                }\\n            }\\n        }        \\n        \\n        vector< vector<int> > dp2HorizontalSum(grid.size(), vector<int>(grid[0].size(), 0));\\n        vector< vector<int> > dp5HorizontalSum(grid.size(), vector<int>(grid[0].size(), 0));\\n        \\n\\t\\t// Generate horizontal prefix sum array\\n        for (int i = 0; i < dp2.size(); i++) {\\n            for (int j = 0; j < dp2[0].size(); j++) {\\n                if (j == 0) {\\n                    dp2HorizontalSum[i][j] = dp2[i][j];\\n                    dp5HorizontalSum[i][j] = dp5[i][j];\\n                } else {\\n                    dp2HorizontalSum[i][j] = dp2HorizontalSum[i][j - 1] + dp2[i][j];\\n                    dp5HorizontalSum[i][j] = dp5HorizontalSum[i][j - 1] + dp5[i][j];\\n                }\\n\\n            }\\n        }    \\n        \\n\\t\\t// Generate vertical prefix sum array\\n        vector< vector<int> > dp2VerticalSum(grid.size(), vector<int>(grid[0].size(), 0));\\n        vector< vector<int> > dp5VerticalSum(grid.size(), vector<int>(grid[0].size(), 0));\\n        for (int i = 0; i < dp2.size(); i++) {\\n            for (int j = 0; j < dp2[0].size(); j++) {\\n                if (i == 0) {\\n                    dp2VerticalSum[i][j] = dp2[i][j];\\n                    dp5VerticalSum[i][j] = dp5[i][j];\\n                } else {\\n                    dp2VerticalSum[i][j] = dp2VerticalSum[i - 1][j] + dp2[i][j];\\n                    dp5VerticalSum[i][j] = dp5VerticalSum[i - 1][j] + dp5[i][j];\\n                }\\n            }\\n        }\\n        \\n\\t\\t// Iterate every element and pick the biggest one to be the result.\\n        for (int i = 0; i < dp2.size(); i++) {\\n            for (int j = 0; j < dp2[0].size(); j++) {\\n                int dp2H1 = dp2HorizontalSum[i][j];\\n                int dp2H2 = dp2HorizontalSum[i][dp2[0].size() -1] - dp2HorizontalSum[i][j] + dp2[i][j];\\n                int dp2V1 = dp2VerticalSum[i][j];\\n                int dp2V2 = dp2VerticalSum[dp2.size() - 1][j] - dp2VerticalSum[i][j] + dp2[i][j];\\n                \\n                int dp5H1 = dp5HorizontalSum[i][j];\\n                int dp5H2 = dp5HorizontalSum[i][dp5[0].size()  -1] - dp5HorizontalSum[i][j] + dp5[i][j];\\n                int dp5V1 = dp5VerticalSum[i][j];\\n                int dp5V2 = dp5VerticalSum[dp5.size() - 1][j] - dp5VerticalSum[i][j] + dp5[i][j];\\n                \\n                int tmp = max(  min(dp2H1 + dp2V1 - dp2[i][j], dp5H1 + dp5V1 - dp5[i][j]), min(dp2H1 + dp2V2 - dp2[i][j], dp5H1 + dp5V2 - dp5[i][j]) );\\n                tmp = max(tmp, min(dp2H2 + dp2V1 - dp2[i][j], dp5H2 + dp5V1 - dp5[i][j]));\\n                tmp = max(tmp, min(dp2H2 + dp2V2 - dp2[i][j], dp5H2 + dp5V2 - dp5[i][j]));\\n                \\n                if (tmp > result) {\\n                    result = tmp;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955466,
                "title": "213ms-java-prefix-sum-solution-with-clear-comment-vertical-or-horizontal-or-l-j-7-directions",
                "content": "```\\npublic int maxTrailingZeros(int[][] grid) {\\n        //trailing 0, 10->1, 100->2\\n        //10 = 2 * 5\\n        //100 = 2*2*5*5\\n        //etc.\\n        //min(countOf2,countOf5);\\n\\t\\t//Part 1: move only horizontal\\n\\t\\t//Part 2: move only vertically\\n        //Part 3: one L turn\\n        //Part 4: one 7 turn\\n        //Part 5: one J turn\\n        //Part 6: one |` turn\\n        \\n\\t\\t//Create PrefixSum array to store count of 2 and 5, then we need O(1) time to get count of 2 or 5.\\n        //matrix count of 2, in row i, from j to k (j<=k) matrix2[i+1][k+1] - matrix2[i+1][j]\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] matrix2row = new int[m+1][n+1];\\n        int[][] matrix5row = new int[m+1][n+1];\\n        //matrix count of 2, in col i, from j to k (j<=k) matrix[k+1][i+1] - matrix[j][i+1]\\n        int[][] matrix2col = new int[m+1][n+1];\\n        int[][] matrix5col = new int[m+1][n+1];\\n        for(int i = 0;i<grid.length;i++){\\n            // System.out.println(Arrays.toString(grid[i]));\\n            for(int j = 0;j<grid[0].length;j++){\\n                int count2 = count2(grid[i][j]);\\n                int count5 = count5(grid[i][j]);\\n                // System.out.println(\"grid[\"+i+\"]\"+\"[\"+j+\"]=\"+\"grid[i][j]\"+\",count2:\"+count2);\\n                matrix2row[i+1][j+1] = matrix2row[i+1][j] + count2; \\n                matrix5row[i+1][j+1] = matrix5row[i+1][j] + count5; \\n            }\\n        }\\n        for(int j = 0;j<grid[0].length;j++){\\n            for(int i = 0;i<grid.length;i++){\\n                int count2 = count2(grid[i][j]);\\n                int count5 = count5(grid[i][j]);\\n                matrix2col[i+1][j+1] = matrix2col[i][j+1] + count2;\\n                matrix5col[i+1][j+1] = matrix5col[i][j+1] + count5;\\n            }\\n        }\\n        //Part 1: move only horizontal \\n        //grid[0][0]->grid[0][n-1]\\n        //grid[1][0]->grid[1][n-1]\\n        //...\\n        //grid[m-1][0]->grid[m-1][n-1]\\n        int ans = 0;\\n        for(int i = 0;i<m;i++){\\n            int count2 = matrix2row[i+1][n]-matrix2row[i+1][0];\\n            int count5 = matrix5row[i+1][n]-matrix5row[i+1][0];\\n            ans = Math.max(ans, Math.min(count2,count5));\\n        }\\n        \\n        //Part 2: move only vertically\\n        //grid[0][0]->grid[m-1][0]\\n        //grid[0][1]->grid[m-1][1]\\n        //...\\n        //grid[0][n-1]->grid[m-1][n-1]\\n        for(int j = 0;j<n;j++){\\n            int count2 = matrix2col[m][j+1] - matrix2col[0][j+1];\\n            int count5 = matrix5col[m][j+1] - matrix5col[0][j+1];\\n            ans = Math.max(ans, Math.min(count2,count5));\\n        }\\n        //Find center of + then there are 4 directions\\n        for(int i = 0;i<m;i++){\\n            for(int j =0;j<n;j++){\\n                \\n                //up (i,j) to (0,j)\\n                int count2Up = matrix2col[i+1][j+1] - matrix2col[0][j+1];\\n                int count5Up = matrix5col[i+1][j+1] - matrix5col[0][j+1];\\n                //down (i,j) to (m-1,j)\\n                int count2Down = matrix2col[m][j+1] - matrix2col[i][j+1];\\n                int count5Down = matrix5col[m][j+1] - matrix5col[i][j+1];\\n                //left (i,0) to (i,j)\\n                int count2Left = matrix2row[i+1][j+1]-matrix2row[i+1][0];\\n                int count5Left = matrix5row[i+1][j+1]-matrix5row[i+1][0];\\n                //right (i,j) to (i,n-1)\\n                int count2Right = matrix2row[i+1][n]-matrix2row[i+1][j];\\n                int count5Right = matrix5row[i+1][n]-matrix5row[i+1][j];\\n                //3.1 L turn\\n                ans = Math.max(ans,Math.min(count2Up+count2Right-count2(grid[i][j]),count5Up+count5Right-count5(grid[i][j])));\\n                //3.2 7 turn\\n                ans = Math.max(ans,Math.min(count2Up+count2Left-count2(grid[i][j]),count5Up+count5Left-count5(grid[i][j])));\\n                //3.3 |` turn\\n                ans = Math.max(ans,Math.min(count2Down+count2Right-count2(grid[i][j]),count5Down+count5Right-count5(grid[i][j])));\\n                //3.4 J turn\\n                ans = Math.max(ans,Math.min(count2Down+count2Left-count2(grid[i][j]),count5Down+count5Left-count5(grid[i][j])));\\n            }\\n        }\\n        return ans;\\n    }\\n    public int count2 (int x){\\n        int count = 0;\\n        while(x % 2 == 0){\\n            count++;\\n            x = x / 2;\\n        }\\n        return count;\\n    }\\n    \\n    public int count5 (int x){\\n        int count = 0;\\n        while(x % 5 == 0){\\n            count++;\\n            x = x / 5;\\n        }\\n        return count;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic int maxTrailingZeros(int[][] grid) {\\n        //trailing 0, 10->1, 100->2\\n        //10 = 2 * 5\\n        //100 = 2*2*5*5\\n        //etc.\\n        //min(countOf2,countOf5);\\n\\t\\t//Part 1: move only horizontal\\n\\t\\t//Part 2: move only vertically\\n        //Part 3: one L turn\\n        //Part 4: one 7 turn\\n        //Part 5: one J turn\\n        //Part 6: one |` turn\\n        \\n\\t\\t//Create PrefixSum array to store count of 2 and 5, then we need O(1) time to get count of 2 or 5.\\n        //matrix count of 2, in row i, from j to k (j<=k) matrix2[i+1][k+1] - matrix2[i+1][j]\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] matrix2row = new int[m+1][n+1];\\n        int[][] matrix5row = new int[m+1][n+1];\\n        //matrix count of 2, in col i, from j to k (j<=k) matrix[k+1][i+1] - matrix[j][i+1]\\n        int[][] matrix2col = new int[m+1][n+1];\\n        int[][] matrix5col = new int[m+1][n+1];\\n        for(int i = 0;i<grid.length;i++){\\n            // System.out.println(Arrays.toString(grid[i]));\\n            for(int j = 0;j<grid[0].length;j++){\\n                int count2 = count2(grid[i][j]);\\n                int count5 = count5(grid[i][j]);\\n                // System.out.println(\"grid[\"+i+\"]\"+\"[\"+j+\"]=\"+\"grid[i][j]\"+\",count2:\"+count2);\\n                matrix2row[i+1][j+1] = matrix2row[i+1][j] + count2; \\n                matrix5row[i+1][j+1] = matrix5row[i+1][j] + count5; \\n            }\\n        }\\n        for(int j = 0;j<grid[0].length;j++){\\n            for(int i = 0;i<grid.length;i++){\\n                int count2 = count2(grid[i][j]);\\n                int count5 = count5(grid[i][j]);\\n                matrix2col[i+1][j+1] = matrix2col[i][j+1] + count2;\\n                matrix5col[i+1][j+1] = matrix5col[i][j+1] + count5;\\n            }\\n        }\\n        //Part 1: move only horizontal \\n        //grid[0][0]->grid[0][n-1]\\n        //grid[1][0]->grid[1][n-1]\\n        //...\\n        //grid[m-1][0]->grid[m-1][n-1]\\n        int ans = 0;\\n        for(int i = 0;i<m;i++){\\n            int count2 = matrix2row[i+1][n]-matrix2row[i+1][0];\\n            int count5 = matrix5row[i+1][n]-matrix5row[i+1][0];\\n            ans = Math.max(ans, Math.min(count2,count5));\\n        }\\n        \\n        //Part 2: move only vertically\\n        //grid[0][0]->grid[m-1][0]\\n        //grid[0][1]->grid[m-1][1]\\n        //...\\n        //grid[0][n-1]->grid[m-1][n-1]\\n        for(int j = 0;j<n;j++){\\n            int count2 = matrix2col[m][j+1] - matrix2col[0][j+1];\\n            int count5 = matrix5col[m][j+1] - matrix5col[0][j+1];\\n            ans = Math.max(ans, Math.min(count2,count5));\\n        }\\n        //Find center of + then there are 4 directions\\n        for(int i = 0;i<m;i++){\\n            for(int j =0;j<n;j++){\\n                \\n                //up (i,j) to (0,j)\\n                int count2Up = matrix2col[i+1][j+1] - matrix2col[0][j+1];\\n                int count5Up = matrix5col[i+1][j+1] - matrix5col[0][j+1];\\n                //down (i,j) to (m-1,j)\\n                int count2Down = matrix2col[m][j+1] - matrix2col[i][j+1];\\n                int count5Down = matrix5col[m][j+1] - matrix5col[i][j+1];\\n                //left (i,0) to (i,j)\\n                int count2Left = matrix2row[i+1][j+1]-matrix2row[i+1][0];\\n                int count5Left = matrix5row[i+1][j+1]-matrix5row[i+1][0];\\n                //right (i,j) to (i,n-1)\\n                int count2Right = matrix2row[i+1][n]-matrix2row[i+1][j];\\n                int count5Right = matrix5row[i+1][n]-matrix5row[i+1][j];\\n                //3.1 L turn\\n                ans = Math.max(ans,Math.min(count2Up+count2Right-count2(grid[i][j]),count5Up+count5Right-count5(grid[i][j])));\\n                //3.2 7 turn\\n                ans = Math.max(ans,Math.min(count2Up+count2Left-count2(grid[i][j]),count5Up+count5Left-count5(grid[i][j])));\\n                //3.3 |` turn\\n                ans = Math.max(ans,Math.min(count2Down+count2Right-count2(grid[i][j]),count5Down+count5Right-count5(grid[i][j])));\\n                //3.4 J turn\\n                ans = Math.max(ans,Math.min(count2Down+count2Left-count2(grid[i][j]),count5Down+count5Left-count5(grid[i][j])));\\n            }\\n        }\\n        return ans;\\n    }\\n    public int count2 (int x){\\n        int count = 0;\\n        while(x % 2 == 0){\\n            count++;\\n            x = x / 2;\\n        }\\n        return count;\\n    }\\n    \\n    public int count5 (int x){\\n        int count = 0;\\n        while(x % 5 == 0){\\n            count++;\\n            x = x / 5;\\n        }\\n        return count;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2836045,
                "title": "c-solutions",
                "content": "```\\n\\tclass Solution {\\npublic:\\n\\npair<long long,long long> util(int val){\\n    \\n    int x=0;\\n    while(val>0 && val%5==0){\\n        val=val/5;\\n        x++;\\n    }\\n    int y=0;\\n    while(val>0 && val%2==0){\\n        val=val/2;\\n        y++;\\n    }\\n    return {x,y};\\n    \\n}\\n\\nlong long util(vector<vector<int>>& grid){\\n    \\n    int n=grid.size();\\n    int m=grid[0].size();\\n    pair<long long,long long> matrix[n][m];\\n    pair<long long,long long> matrix1[n][m];\\n    pair<long long,long long> matrix2[n][m];\\n    \\n    //making the first grid;\\n    for(int i=0;i<n;i++)\\n        for(int j=0;j<m;j++){\\n            int val=grid[i][j];\\n            matrix[i][j]=util(val);\\n        }\\n    \\n    //right to left\\n    for(int i=0;i<n;i++){\\n        for(int j=m-1;j>=0;j--){\\n            if(j==m-1)\\n                matrix1[i][j]=matrix[i][j];\\n            else\\n                matrix1[i][j]={matrix[i][j].first+matrix1[i][j+1].first,matrix[i][j].second+matrix1[i][j+1].second};\\n\\n        }\\n    }\\n    for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n            if(j==0)\\n                matrix2[i][j]=matrix[i][j];\\n            else\\n                matrix2[i][j]={matrix[i][j].first+matrix2[i][j-1].first,matrix[i][j].second+matrix2[i][j-1].second};\\n        }\\n    }\\n    long long res=0;\\n    \\n    //calculating by traversing from up to down\\n    \\n    for(int j=0;j<m;j++){\\n        pair<long long,long long>sum={0,0};\\n        for(int i=0;i<n;i++){\\n            sum={sum.first+matrix[i][j].first,sum.second+matrix[i][j].second};\\n            res=max(res,min(sum.first,sum.second));\\n            if(j>0){\\n            pair<long long,long long>p1=matrix2[i][j-1];\\n            res=max(res,min(sum.first+p1.first,sum.second+p1.second));\\n            }\\n            if(j<m-1){\\n                pair<long long,long long>p1=matrix1[i][j+1];\\n            res=max(res,min(sum.first+p1.first,sum.second+p1.second));\\n            }\\n               \\n        }            \\n        \\n    }\\n    return res;\\n    \\n}\\n\\nint maxTrailingZeros(vector<vector<int>>& grid) {\\n    \\nint m=grid[0].size();\\n    int n=grid.size();\\n    vector<vector<int>>grid2(m,vector<int>(n,0));\\n    for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n            grid2[j][i]=grid[i][j];\\n        }\\n    }\\n    long long res=0;\\n      res=max(util(grid),util(grid2));\\n    vector<vector<int>>grid3(n,vector<int>(m,0));\\n    for(int i=0;i<grid.size();i++){\\n        for(int j=0;j<grid[0].size();j++){\\n            grid3[n-i-1][j]=grid[i][j];       \\n        }\\n    }\\n    return max(res,util(grid3));\\n    \\n    \\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\tclass Solution {\\npublic:\\n\\npair<long long,long long> util(int val){\\n    \\n    int x=0;\\n    while(val>0 && val%5==0){\\n        val=val/5;\\n        x++;\\n    }\\n    int y=0;\\n    while(val>0 && val%2==0){\\n        val=val/2;\\n        y++;\\n    }\\n    return {x,y};\\n    \\n}\\n\\nlong long util(vector<vector<int>>& grid){\\n    \\n    int n=grid.size();\\n    int m=grid[0].size();\\n    pair<long long,long long> matrix[n][m];\\n    pair<long long,long long> matrix1[n][m];\\n    pair<long long,long long> matrix2[n][m];\\n    \\n    //making the first grid;\\n    for(int i=0;i<n;i++)\\n        for(int j=0;j<m;j++){\\n            int val=grid[i][j];\\n            matrix[i][j]=util(val);\\n        }\\n    \\n    //right to left\\n    for(int i=0;i<n;i++){\\n        for(int j=m-1;j>=0;j--){\\n            if(j==m-1)\\n                matrix1[i][j]=matrix[i][j];\\n            else\\n                matrix1[i][j]={matrix[i][j].first+matrix1[i][j+1].first,matrix[i][j].second+matrix1[i][j+1].second};\\n\\n        }\\n    }\\n    for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n            if(j==0)\\n                matrix2[i][j]=matrix[i][j];\\n            else\\n                matrix2[i][j]={matrix[i][j].first+matrix2[i][j-1].first,matrix[i][j].second+matrix2[i][j-1].second};\\n        }\\n    }\\n    long long res=0;\\n    \\n    //calculating by traversing from up to down\\n    \\n    for(int j=0;j<m;j++){\\n        pair<long long,long long>sum={0,0};\\n        for(int i=0;i<n;i++){\\n            sum={sum.first+matrix[i][j].first,sum.second+matrix[i][j].second};\\n            res=max(res,min(sum.first,sum.second));\\n            if(j>0){\\n            pair<long long,long long>p1=matrix2[i][j-1];\\n            res=max(res,min(sum.first+p1.first,sum.second+p1.second));\\n            }\\n            if(j<m-1){\\n                pair<long long,long long>p1=matrix1[i][j+1];\\n            res=max(res,min(sum.first+p1.first,sum.second+p1.second));\\n            }\\n               \\n        }            \\n        \\n    }\\n    return res;\\n    \\n}\\n\\nint maxTrailingZeros(vector<vector<int>>& grid) {\\n    \\nint m=grid[0].size();\\n    int n=grid.size();\\n    vector<vector<int>>grid2(m,vector<int>(n,0));\\n    for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n            grid2[j][i]=grid[i][j];\\n        }\\n    }\\n    long long res=0;\\n      res=max(util(grid),util(grid2));\\n    vector<vector<int>>grid3(n,vector<int>(m,0));\\n    for(int i=0;i<grid.size();i++){\\n        for(int j=0;j<grid[0].size();j++){\\n            grid3[n-i-1][j]=grid[i][j];       \\n        }\\n    }\\n    return max(res,util(grid3));\\n    \\n    \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956741,
                "title": "lazy-coding-idea-explained-code",
                "content": "Lets try to visulaise our solution , the solution will always be an **\"L\"** so what we can do is iterate on every index of the matrix and assume this point to be the intersection of the vertical and horizontal lines.\\n\\nNow , as we have asssumed (i , j ) to be our answer , we have to find number of trailing zeroes . So for the horizontal and vertical lines , we can have a prefix array that stores number of 2\\'s and 5\\'s from\\n(0 , i ) , (i , n-1) , (0 , j-1) , (j+1 , m) \\nNow , we can greedily calculate the answer. It\\'s easy just implementing takes some effort. If you dont understand any part please do comment , i will be happy to explain . \\n\\nPlease do upvote , it motivates me , i will surely add more explanations further \\uD83D\\uDE03\\n \\n \\n \\n grid \\n23 | 17 | 15 | 03   | 20 |     \\n08   | 01   | 20 | 27 | 11 | \\n09   | 04   | 06   | 02   | 21 | \\n40 | 09   | 01   | 10 | 06   | \\n22 | 07   | 04   | 05   | 03   | \\n\\n\\nPrefix Arrays \\n\\n prefixhorizontal \\n0 0 | 0 0 | 1 0 | 1 0 | 2 2 | \\n0 3 | 0 3 | 1 5 | 1 5 | 1 5 | \\n0 0 | 0 2 | 0 3 | 0 4 | 0 4 | \\n1 3 | 1 3 | 1 3 | 2 4 | 2 5 | \\n0 1 | 0 1 | 0 3 | 1 3 | 1 3 | \\n\\n prefixvertical \\n0 0 | 0 0 | 1 0 | 0 0 | 1 2 | \\n0 3 | 0 0 | 2 2 | 0 0 | 1 2 | \\n0 3 | 0 2 | 2 3 | 0 1 | 1 2 | \\n1 6 | 0 2 | 2 3 | 1 2 | 1 3 | \\n1 7 | 0 2 | 2 5 | 2 2 | 1 3 | \\n\\n\\n```\\nclass Solution {\\n    \\n        int count(int num , int val)\\n        {\\n            int cnt = 0 ;\\n            while(num>0 && num%val == 0)\\n                cnt++ , num/=val ;\\n            \\n            return cnt ;\\n                \\n        }\\n    \\n        int solve(pair<int , int> &p1 , pair<int , int> &p2)\\n        {\\n            return min(p1.first + p2.first , p1.second + p2.second) ;\\n        }\\n    \\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size() , m = grid[0].size() ;\\n        vector<vector<pair<int , int>> > preHorizontal(n , vector<pair<int, int>>(m , {0 , 0})) ;\\n        vector<vector<pair<int , int>> > preVertical(n , vector<pair<int, int>>(m , {0, 0})) ;\\n\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            for(int j=0; j<m ; j++)\\n            {\\n                if(j == 0) preHorizontal[i][j] = { count(grid[i][j] , 5) , count(grid[i][j] , 2) } ; \\n                else{\\n                    int cnt5 = preHorizontal[i][j-1].first + count(grid[i][j] , 5) ;\\n                    int cnt2 = preHorizontal[i][j-1].second + count(grid[i][j] , 2) ;\\n                    preHorizontal[i][j] = { cnt5 , cnt2 } ;\\n                }\\n            }\\n        }\\n        \\n          for(int i=0 ; i<m ; i++)\\n        {\\n            for(int j=0; j<n ; j++)\\n            {\\n                if(j == 0) preVertical[j][i] = { count(grid[j][i] , 5) , count(grid[j][i] , 2) } ; \\n                else{\\n                    int cnt5 = preVertical[j-1][i].first + count(grid[j][i] , 5) ;\\n                    int cnt2 = preVertical[j-1][i].second + count(grid[j][i] , 2) ;\\n                    preVertical[j][i] = { cnt5 , cnt2 } ;\\n                }\\n            }\\n        }\\n\\n        int ans = 0;\\n        \\n        for(int i=0; i<n ; i++)\\n        {\\n            for(int j=0; j<m ; j++)\\n            {\\n                pair<int , int > cnthor1 = {0 , 0} , cnthor2 = {0 , 0} , cntver1 = {0 , 0} , cntver2 = {0 , 0} ;\\n                cnthor1 = { preHorizontal[i][m-1].first - preHorizontal[i][j].first , preHorizontal[i][m-1].second - preHorizontal[i][j].second } ;\\n                cnthor2 = j > 0 ? preHorizontal[i][j-1] : cnthor2 ;\\n                \\n        cntver1 =  i>0 ? make_pair(preVertical[n-1][j].first - preVertical[i-1][j].first , preVertical[n-1][j].second - preVertical[i-1][j].second ) : preVertical[n-1][j] ;\\n                cntver2 = preVertical[i][j] ;\\n                \\n                ans = max(ans , solve(cnthor1 , cntver1)) ;\\n                ans = max(ans , solve(cnthor2 , cntver1)) ;\\n                ans = max(ans , solve(cnthor1 , cntver2)) ;\\n                ans = max(ans , solve(cnthor2 , cntver2)) ;\\n\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    \\n        int count(int num , int val)\\n        {\\n            int cnt = 0 ;\\n            while(num>0 && num%val == 0)\\n                cnt++ , num/=val ;\\n            \\n            return cnt ;\\n                \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1955502,
                "title": "python-prefix-sum-o-m-n",
                "content": "**Intuition**\\nStore the prefix sum matrices of rows and columns, where each entry is `[a, b]` representing the cumulative count of (1) the factors of 2 and (2) the factors of 5.\\n\\n\\n**Complexity**\\nTime: `O(m * n)`\\nSpace: `O(m * n)`\\n\\nBelow is my slightly-modified in-contest solution. Please upvote if you find this solution helpful. Thanks!\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        ans = 0\\n        m, n = len(grid), len(grid[0])\\n        prefixH = [[[0] * 2 for _ in range(n + 1)] for __ in range(m)]\\n        prefixV = [[[0] * 2 for _ in range(n)] for __ in range(m + 1)]\\n        for i in range(m):\\n            for j in range(n):\\n                temp= grid[i][j]\\n                while temp % 2 == 0:\\n                    prefixH[i][j + 1][0] += 1\\n                    prefixV[i + 1][j][0] += 1\\n                    temp //= 2\\n                while temp % 5 == 0:\\n                    prefixH[i][j + 1][1] += 1\\n                    prefixV[i + 1][j][1] += 1\\n                    temp //= 5\\n                for k in range(2):\\n                    prefixH[i][j + 1][k] += prefixH[i][j][k]\\n                    prefixV[i + 1][j][k] += prefixV[i][j][k]\\n        for i in range(m):\\n            for j in range(n):\\n                left = prefixH[i][j]\\n                up = prefixV[i][j]\\n                right, down, center = [0] * 2, [0] * 2, [0] * 2\\n                for k in range(2):\\n                    right[k] = prefixH[i][n][k] - prefixH[i][j + 1][k]\\n                    down[k] = prefixV[m][j][k] - prefixV[i + 1][j][k]\\n                    center[k] = prefixH[i][j + 1][k] - prefixH[i][j][k]\\n                LU, LD, RU, RD = [0] * 2, [0] * 2, [0] * 2, [0] * 2\\n                for k in range(2):\\n                    LU[k] += left[k] + up[k] + center[k]\\n                    LD[k] += left[k] + down[k] + center[k]\\n                    RU[k] += right[k] + up[k] + center[k]\\n                    RD[k] += right[k] + down[k] + center[k]\\n                ans = max(ans,\\n                          min(LU[0], LU[1]),\\n                          min(LD[0], LD[1]),\\n                          min(RU[0], RU[1]),\\n                          min(RD[0], RD[1]))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        ans = 0\\n        m, n = len(grid), len(grid[0])\\n        prefixH = [[[0] * 2 for _ in range(n + 1)] for __ in range(m)]\\n        prefixV = [[[0] * 2 for _ in range(n)] for __ in range(m + 1)]\\n        for i in range(m):\\n            for j in range(n):\\n                temp= grid[i][j]\\n                while temp % 2 == 0:\\n                    prefixH[i][j + 1][0] += 1\\n                    prefixV[i + 1][j][0] += 1\\n                    temp //= 2\\n                while temp % 5 == 0:\\n                    prefixH[i][j + 1][1] += 1\\n                    prefixV[i + 1][j][1] += 1\\n                    temp //= 5\\n                for k in range(2):\\n                    prefixH[i][j + 1][k] += prefixH[i][j][k]\\n                    prefixV[i + 1][j][k] += prefixV[i][j][k]\\n        for i in range(m):\\n            for j in range(n):\\n                left = prefixH[i][j]\\n                up = prefixV[i][j]\\n                right, down, center = [0] * 2, [0] * 2, [0] * 2\\n                for k in range(2):\\n                    right[k] = prefixH[i][n][k] - prefixH[i][j + 1][k]\\n                    down[k] = prefixV[m][j][k] - prefixV[i + 1][j][k]\\n                    center[k] = prefixH[i][j + 1][k] - prefixH[i][j][k]\\n                LU, LD, RU, RD = [0] * 2, [0] * 2, [0] * 2, [0] * 2\\n                for k in range(2):\\n                    LU[k] += left[k] + up[k] + center[k]\\n                    LD[k] += left[k] + down[k] + center[k]\\n                    RU[k] += right[k] + up[k] + center[k]\\n                    RD[k] += right[k] + down[k] + center[k]\\n                ans = max(ans,\\n                          min(LU[0], LU[1]),\\n                          min(LD[0], LD[1]),\\n                          min(RU[0], RU[1]),\\n                          min(RD[0], RD[1]))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955381,
                "title": "python-the-time-limit-for-python-is-merciless",
                "content": "I use 3 different way to implement the O(M*N) algorithm because of TLE result.\\nlost more than 40 minutes here. \\uD83D\\uDE22\\n```\\nclass Solution:                                                                                                 \\n    def maxTrailingZeros(self, grid):                                                                           \\n                                                                                                    \\n        def get25(n):                                                                                           \\n            c2,c5 = 0,0                                                                                 \\n            while n and n % 2 == 0:                                                                             \\n                c2 += 1                                                                                 \\n                n = n // 2                                                                                      \\n            while n and n % 5 == 0:                                                                             \\n                c5 += 1                                                                                 \\n                n = n // 5                                                                                      \\n            return [c2,c5] \\n        c25 = []\\n        for i in range(1001):\\n            c25.append(get25(i))\\n                                                                                                                \\n        m, n = len(grid), len(grid[0])                                                                          \\n        grid = list(map(lambda x: list(map(lambda xx: c25[xx][:], x)), grid))                          \\n        l = [[[0,0] for _ in range(n)] for _ in range(m)]                                                   \\n        r = [[[0,0] for _ in range(n)] for _ in range(m)]                                                 \\n        u = [[[0,0] for _ in range(n)] for _ in range(m)]                                                \\n        b = [[[0,0] for _ in range(n)] for _ in range(m)]                                                 \\n        for i in range(m):                                                                                      \\n            for j in range(0, n):\\n                for k in range(2):\\n                    l[i][j][k] = grid[i][j][k]\\n                    u[i][j][k] = grid[i][j][k]\\n                    if j != 0:                                                                                      \\n                        l[i][j][k] += l[i][j - 1][k]                                                       \\n                    if i != 0:                                                                                      \\n                        u[i][j][k] += u[i - 1][j][k]                                                    \\n        ans = 0                                                                                                 \\n        for i in range(m - 1, -1, -1):                                                                          \\n            for j in range(n - 1, -1, -1):\\n                q1,q2,q3,q4 = 10**10,10**10,10**10,10**10\\n                for k in range(2):\\n                    b[i][j][k] = grid[i][j][k]\\n                    r[i][j][k] = grid[i][j][k]  \\n                    if i != m - 1:                                                                                  \\n                        b[i][j][k] += b[i + 1][j][k]                                                       \\n                    if j != n - 1:                                                                                  \\n                        r[i][j][k] += r[i][j + 1][k]\\n                    q1 = min(q1,r[i][j][k]+u[i][j][k]-grid[i][j][k])\\n                    q2 = min(q2,r[i][j][k]+b[i][j][k]-grid[i][j][k])\\n                    q3 = min(q3,l[i][j][k]+u[i][j][k]-grid[i][j][k])\\n                    q4 = min(q4,l[i][j][k]+b[i][j][k]-grid[i][j][k])                                                           \\n                ans = max(ans,q1,q2,q3,q4)      \\n                                                                                                                \\n        return ans     \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:                                                                                                 \\n    def maxTrailingZeros(self, grid):                                                                           \\n                                                                                                    \\n        def get25(n):                                                                                           \\n            c2,c5 = 0,0                                                                                 \\n            while n and n % 2 == 0:                                                                             \\n                c2 += 1                                                                                 \\n                n = n // 2                                                                                      \\n            while n and n % 5 == 0:                                                                             \\n                c5 += 1                                                                                 \\n                n = n // 5                                                                                      \\n            return [c2,c5] \\n        c25 = []\\n        for i in range(1001):\\n            c25.append(get25(i))\\n                                                                                                                \\n        m, n = len(grid), len(grid[0])                                                                          \\n        grid = list(map(lambda x: list(map(lambda xx: c25[xx][:], x)), grid))                          \\n        l = [[[0,0] for _ in range(n)] for _ in range(m)]                                                   \\n        r = [[[0,0] for _ in range(n)] for _ in range(m)]                                                 \\n        u = [[[0,0] for _ in range(n)] for _ in range(m)]                                                \\n        b = [[[0,0] for _ in range(n)] for _ in range(m)]                                                 \\n        for i in range(m):                                                                                      \\n            for j in range(0, n):\\n                for k in range(2):\\n                    l[i][j][k] = grid[i][j][k]\\n                    u[i][j][k] = grid[i][j][k]\\n                    if j != 0:                                                                                      \\n                        l[i][j][k] += l[i][j - 1][k]                                                       \\n                    if i != 0:                                                                                      \\n                        u[i][j][k] += u[i - 1][j][k]                                                    \\n        ans = 0                                                                                                 \\n        for i in range(m - 1, -1, -1):                                                                          \\n            for j in range(n - 1, -1, -1):\\n                q1,q2,q3,q4 = 10**10,10**10,10**10,10**10\\n                for k in range(2):\\n                    b[i][j][k] = grid[i][j][k]\\n                    r[i][j][k] = grid[i][j][k]  \\n                    if i != m - 1:                                                                                  \\n                        b[i][j][k] += b[i + 1][j][k]                                                       \\n                    if j != n - 1:                                                                                  \\n                        r[i][j][k] += r[i][j + 1][k]\\n                    q1 = min(q1,r[i][j][k]+u[i][j][k]-grid[i][j][k])\\n                    q2 = min(q2,r[i][j][k]+b[i][j][k]-grid[i][j][k])\\n                    q3 = min(q3,l[i][j][k]+u[i][j][k]-grid[i][j][k])\\n                    q4 = min(q4,l[i][j][k]+b[i][j][k]-grid[i][j][k])                                                           \\n                ans = max(ans,q1,q2,q3,q4)      \\n                                                                                                                \\n        return ans     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957429,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    pair<int,int>find(int n)\\n    {\\n        int count2=0;\\n        int count5=0;\\n        while(n%2==0)\\n        {\\n            n=n/2;\\n            count2++;\\n        }\\n        while(n%5==0)\\n        {\\n            n=n/5;\\n            count5++;\\n        }\\n        return {count2,count5};\\n        \\n    }\\n    int maxTrailingZeros(vector<vector<int>>&mat) \\n    {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<vector<int>>>nums(2,vector<vector<int>>(n,vector<int>(m,0)));\\n        vector<vector<vector<int>>>top(2,vector<vector<int>>(n,vector<int>(m,0)));\\n        vector<vector<vector<int>>>left(2,vector<vector<int>>(n,vector<int>(m,0)));\\n        vector<vector<vector<int>>>right(2,vector<vector<int>>(n,vector<int>(m,0)));\\n        vector<vector<vector<int>>>bottom(2,vector<vector<int>>(n,vector<int>(m,0)));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                auto it=find(mat[i][j]);\\n                nums[0][i][j]=it.first;\\n                nums[1][i][j]=it.second;\\n            }\\n        }\\n        top=left=right=bottom=nums;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(i)\\n                {\\n                    top[0][i][j]+=top[0][i-1][j];\\n                    top[1][i][j]+=top[1][i-1][j];\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(j)\\n                {\\n                    left[0][i][j]+=left[0][i][j-1];\\n                    left[1][i][j]+=left[1][i][j-1];\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                if(j!=m-1)\\n                {\\n                    right[0][i][j]+=right[0][i][j+1];\\n                    right[1][i][j]+=right[1][i][j+1];\\n                }\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(i!=n-1)\\n                {\\n                    bottom[0][i][j]+=bottom[0][i+1][j];\\n                    bottom[1][i][j]+=bottom[1][i+1][j];\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int curr2=nums[0][i][j];\\n                int curr5=nums[1][i][j];\\n                \\n                int top2=top[0][i][j];\\n                int top5=top[1][i][j];\\n                \\n                int right2=right[0][i][j];\\n                int right5=right[1][i][j];\\n                \\n                int bottom2=bottom[0][i][j];\\n                int bottom5=bottom[1][i][j];\\n                \\n                int left2=left[0][i][j];\\n                int left5=left[1][i][j];\\n                \\n                ans=max(ans,min(top2+right2-curr2,top5+right5-curr5));\\n                ans=max(ans,min(top2+left2-curr2,top5+left5-curr5));\\n                ans=max(ans,min(bottom2+right2-curr2,bottom5+right5-curr5));\\n                ans=max(ans,min(bottom2+left2-curr2,bottom5+left5-curr5));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int>find(int n)\\n    {\\n        int count2=0;\\n        int count5=0;\\n        while(n%2==0)\\n        {\\n            n=n/2;\\n            count2++;\\n        }\\n        while(n%5==0)\\n        {\\n            n=n/5;\\n            count5++;\\n        }\\n        return {count2,count5};\\n        \\n    }\\n    int maxTrailingZeros(vector<vector<int>>&mat) \\n    {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<vector<int>>>nums(2,vector<vector<int>>(n,vector<int>(m,0)));\\n        vector<vector<vector<int>>>top(2,vector<vector<int>>(n,vector<int>(m,0)));\\n        vector<vector<vector<int>>>left(2,vector<vector<int>>(n,vector<int>(m,0)));\\n        vector<vector<vector<int>>>right(2,vector<vector<int>>(n,vector<int>(m,0)));\\n        vector<vector<vector<int>>>bottom(2,vector<vector<int>>(n,vector<int>(m,0)));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                auto it=find(mat[i][j]);\\n                nums[0][i][j]=it.first;\\n                nums[1][i][j]=it.second;\\n            }\\n        }\\n        top=left=right=bottom=nums;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(i)\\n                {\\n                    top[0][i][j]+=top[0][i-1][j];\\n                    top[1][i][j]+=top[1][i-1][j];\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(j)\\n                {\\n                    left[0][i][j]+=left[0][i][j-1];\\n                    left[1][i][j]+=left[1][i][j-1];\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                if(j!=m-1)\\n                {\\n                    right[0][i][j]+=right[0][i][j+1];\\n                    right[1][i][j]+=right[1][i][j+1];\\n                }\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(i!=n-1)\\n                {\\n                    bottom[0][i][j]+=bottom[0][i+1][j];\\n                    bottom[1][i][j]+=bottom[1][i+1][j];\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int curr2=nums[0][i][j];\\n                int curr5=nums[1][i][j];\\n                \\n                int top2=top[0][i][j];\\n                int top5=top[1][i][j];\\n                \\n                int right2=right[0][i][j];\\n                int right5=right[1][i][j];\\n                \\n                int bottom2=bottom[0][i][j];\\n                int bottom5=bottom[1][i][j];\\n                \\n                int left2=left[0][i][j];\\n                int left5=left[1][i][j];\\n                \\n                ans=max(ans,min(top2+right2-curr2,top5+right5-curr5));\\n                ans=max(ans,min(top2+left2-curr2,top5+left5-curr5));\\n                ans=max(ans,min(bottom2+right2-curr2,bottom5+right5-curr5));\\n                ans=max(ans,min(bottom2+left2-curr2,bottom5+left5-curr5));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253898,
                "title": "python-3-w-some-explanation-t-m-94-93",
                "content": "- We construct a prefix sum of 4-tuples, writing over`grid`as we go. For each cell, we determine `(up2, up5, left2, right5)`, the accummulated factors of two and five for the up-direction and the left-direction respectively.\\n\\n- We use the transformed`grid`to determine for each cell the count of zeros over the four paths: up-left, down-left, up-right, down-right.\\n- We determine the max zeros for each cell along the four paths, and then determine the overall max from those cell maxs.\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: list[list[int]]) -> int:\\n\\n        m, n = len(grid)+1, len(grid[0])+1\\n        grid = [[(0,0,0,0)]*n]+[[(0,0,0,0)]+row for row in grid]\\n\\n        def pref(row: int,col: int)-> tuple:        # <-- prefix for each cell\\n        \\n            val = grid[row][col]\\n            for f2 in range(19):\\n                if val%2: break\\n                val//= 2\\n   \\n            for f5 in range(6):\\n                if val%5: break\\n                val//= 5\\n        \\n            (u2, u5, _,_), (_,_, l2, l5) = grid[row-1][col], grid[row][col-1]\\n            return (f2 + u2, f5 + u5, f2 + l2, f5 + l5)\\n        \\n        def countZeros(r: int,c: int)-> int:        #  <--Count the zeros    \\n            up2   ,up5    = grid[r][c][0],grid[r][c][1]\\n            down2 ,down5  = grid[m-1][c][0]-grid[r-1][c][0],grid[m-1][c][1]-grid[r-1][c][1]\\n            \\n            left2 ,left5  = grid[r][c-1][2],grid[r][c-1][3]\\n            right2,right5 = grid[r][n-1][2]-grid[r][c][2],grid[r][n-1][3]-grid[r][c][3] \\n\\n            return max(min(up2+left2 ,up5+left5 ), min(down2+left2 ,down5+left5 ),\\n                       min(up2+right2,up5+right5), min(down2+right2,down5+right5))\\n\\n        for r in range(1,m):\\n            for c in range(1,n):grid[r][c] = pref(r,c)\\n\\n        return max(countZeros(r,c) for c in range(1,n) for r in range(1,m))\\n```\\n[https://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/submissions/908601238/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) (wnere*N* is *mn* and space complexity is probably *O*(*N*) but maybe *O*(1). I\\'m just not sure.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: list[list[int]]) -> int:\\n\\n        m, n = len(grid)+1, len(grid[0])+1\\n        grid = [[(0,0,0,0)]*n]+[[(0,0,0,0)]+row for row in grid]\\n\\n        def pref(row: int,col: int)-> tuple:        # <-- prefix for each cell\\n        \\n            val = grid[row][col]\\n            for f2 in range(19):\\n                if val%2: break\\n                val//= 2\\n   \\n            for f5 in range(6):\\n                if val%5: break\\n                val//= 5\\n        \\n            (u2, u5, _,_), (_,_, l2, l5) = grid[row-1][col], grid[row][col-1]\\n            return (f2 + u2, f5 + u5, f2 + l2, f5 + l5)\\n        \\n        def countZeros(r: int,c: int)-> int:        #  <--Count the zeros    \\n            up2   ,up5    = grid[r][c][0],grid[r][c][1]\\n            down2 ,down5  = grid[m-1][c][0]-grid[r-1][c][0],grid[m-1][c][1]-grid[r-1][c][1]\\n            \\n            left2 ,left5  = grid[r][c-1][2],grid[r][c-1][3]\\n            right2,right5 = grid[r][n-1][2]-grid[r][c][2],grid[r][n-1][3]-grid[r][c][3] \\n\\n            return max(min(up2+left2 ,up5+left5 ), min(down2+left2 ,down5+left5 ),\\n                       min(up2+right2,up5+right5), min(down2+right2,down5+right5))\\n\\n        for r in range(1,m):\\n            for c in range(1,n):grid[r][c] = pref(r,c)\\n\\n        return max(countZeros(r,c) for c in range(1,n) for r in range(1,m))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959011,
                "title": "c-100-memory-100-faster-prefix-sum-of-2s-5s-in-prime-factorization-of-grid-element",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        pair<int,int> zero = make_pair(0,0);\\n        vector<vector<pair<int,int>>> prefix(m,vector<pair<int,int>>(n,zero));\\n        // (2s,5s)\\n        for(int i=0; i<m; i++){\\n            \\n            for(int j=0; j<n; j++){\\n                int temp = grid[i][j];\\n                while(temp%2 ==0){\\n                    prefix[i][j].first = prefix[i][j].first + 1;\\n                    temp = temp/2;\\n                }\\n                temp = grid[i][j];\\n                while(temp%5 ==0){\\n                    prefix[i][j].second = prefix[i][j].second + 1;\\n                    temp = temp/5;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=1; j<n; j++){\\n                prefix[i][j].first = prefix[i][j].first + prefix[i][j-1].first;\\n                prefix[i][j].second = prefix[i][j].second + prefix[i][j-1].second;\\n            }\\n        }\\n        \\n        int maxzeros = 0;\\n        // if ans is a smaller L, a bigger L containing the smaller L can either increase the \\n        // twos and fives or remain same.  4 possible L shapes\\n        \\n        // top to bottom , consider left or right\\n        for(int j=0; j<n; j++){\\n            pair<int,int> ver= zero;\\n            int twos=0, fives=0;\\n            \\n            for(int i=0; i<m; i++){\\n                twos = ver.first;\\n                fives = ver.second;\\n                // current element\\n                twos += prefix[i][j].first - (j>0?prefix[i][j-1].first:0);\\n                fives += prefix[i][j].second - (j>0?prefix[i][j-1].second:0);\\n                ver.first = twos;\\n                ver.second = fives;\\n                // left\\n                twos += j>0?prefix[i][j-1].first:0;\\n                fives += j>0?prefix[i][j-1].second:0;\\n                maxzeros = max(maxzeros,min(twos,fives));\\n                // right\\n                twos = ver.first;\\n                fives = ver.second;\\n                twos += prefix[i][n-1].first-prefix[i][j].first;\\n                fives += prefix[i][n-1].second-prefix[i][j].second;\\n                \\n                maxzeros = max(maxzeros,min(twos,fives));\\n            }\\n        }\\n        \\n        // bottom to top. consider either left or right\\n        for(int j=0; j<n; j++){\\n            pair<int,int> ver= zero;\\n            int twos=0, fives=0;\\n            \\n            for(int i=m-1; i>=0; i--){\\n                twos = ver.first;\\n                fives = ver.second;\\n                // current element\\n                twos += prefix[i][j].first - (j>0?prefix[i][j-1].first:0);\\n                fives += prefix[i][j].second - (j>0?prefix[i][j-1].second:0);\\n                ver.first = twos;\\n                ver.second = fives;\\n                // left\\n                twos += j>0?prefix[i][j-1].first:0;\\n                fives += j>0?prefix[i][j-1].second:0;\\n                maxzeros = max(maxzeros,min(twos,fives));\\n                // right\\n                twos = ver.first;\\n                fives = ver.second;\\n                twos += prefix[i][n-1].first-prefix[i][j].first;\\n                fives += prefix[i][n-1].second-prefix[i][j].second;\\n                \\n                maxzeros = max(maxzeros,min(twos,fives));\\n            }\\n        }\\n        \\n        return maxzeros;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        pair<int,int> zero = make_pair(0,0);\\n        vector<vector<pair<int,int>>> prefix(m,vector<pair<int,int>>(n,zero));\\n        // (2s,5s)\\n        for(int i=0; i<m; i++){\\n            \\n            for(int j=0; j<n; j++){\\n                int temp = grid[i][j];\\n                while(temp%2 ==0){\\n                    prefix[i][j].first = prefix[i][j].first + 1;\\n                    temp = temp/2;\\n                }\\n                temp = grid[i][j];\\n                while(temp%5 ==0){\\n                    prefix[i][j].second = prefix[i][j].second + 1;\\n                    temp = temp/5;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=1; j<n; j++){\\n                prefix[i][j].first = prefix[i][j].first + prefix[i][j-1].first;\\n                prefix[i][j].second = prefix[i][j].second + prefix[i][j-1].second;\\n            }\\n        }\\n        \\n        int maxzeros = 0;\\n        // if ans is a smaller L, a bigger L containing the smaller L can either increase the \\n        // twos and fives or remain same.  4 possible L shapes\\n        \\n        // top to bottom , consider left or right\\n        for(int j=0; j<n; j++){\\n            pair<int,int> ver= zero;\\n            int twos=0, fives=0;\\n            \\n            for(int i=0; i<m; i++){\\n                twos = ver.first;\\n                fives = ver.second;\\n                // current element\\n                twos += prefix[i][j].first - (j>0?prefix[i][j-1].first:0);\\n                fives += prefix[i][j].second - (j>0?prefix[i][j-1].second:0);\\n                ver.first = twos;\\n                ver.second = fives;\\n                // left\\n                twos += j>0?prefix[i][j-1].first:0;\\n                fives += j>0?prefix[i][j-1].second:0;\\n                maxzeros = max(maxzeros,min(twos,fives));\\n                // right\\n                twos = ver.first;\\n                fives = ver.second;\\n                twos += prefix[i][n-1].first-prefix[i][j].first;\\n                fives += prefix[i][n-1].second-prefix[i][j].second;\\n                \\n                maxzeros = max(maxzeros,min(twos,fives));\\n            }\\n        }\\n        \\n        // bottom to top. consider either left or right\\n        for(int j=0; j<n; j++){\\n            pair<int,int> ver= zero;\\n            int twos=0, fives=0;\\n            \\n            for(int i=m-1; i>=0; i--){\\n                twos = ver.first;\\n                fives = ver.second;\\n                // current element\\n                twos += prefix[i][j].first - (j>0?prefix[i][j-1].first:0);\\n                fives += prefix[i][j].second - (j>0?prefix[i][j-1].second:0);\\n                ver.first = twos;\\n                ver.second = fives;\\n                // left\\n                twos += j>0?prefix[i][j-1].first:0;\\n                fives += j>0?prefix[i][j-1].second:0;\\n                maxzeros = max(maxzeros,min(twos,fives));\\n                // right\\n                twos = ver.first;\\n                fives = ver.second;\\n                twos += prefix[i][n-1].first-prefix[i][j].first;\\n                fives += prefix[i][n-1].second-prefix[i][j].second;\\n                \\n                maxzeros = max(maxzeros,min(twos,fives));\\n            }\\n        }\\n        \\n        return maxzeros;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955868,
                "title": "java-prefix-sum-solution",
                "content": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][][] dph = new int[m][n][3];\\n        int[][][] dpv = new int[m][n][3];\\n        int hmax0 = 0;\\n        int vmax0 = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int curr = grid[i][j];\\n                int two = 0;\\n                int five = 0;\\n                if (j >= 1) {\\n                    two = dph[i][j-1][1];\\n                    five = dph[i][j-1][2];\\n                }\\n                while (curr > 0 && curr % 2 == 0) {\\n                    two++;\\n                    curr /= 2;\\n                }\\n                while (curr > 0 && curr % 5 == 0) {\\n                    five++;\\n                    curr /= 5;\\n                }\\n                dph[i][j][1] = two;\\n                dph[i][j][2] = five;\\n                dph[i][j][0] = Math.min(dph[i][j][1], dph[i][j][2]);\\n            }\\n            hmax0 = Math.max(hmax0, dph[i][n-1][0]);\\n        }\\n        \\n        for (int j = 0; j < n; j++) {\\n            for (int i = 0; i < m; i++) {\\n                int curr = grid[i][j];\\n                int two = 0;\\n                int five = 0;\\n                if (i >= 1) {\\n                    two = dpv[i-1][j][1];\\n                    five = dpv[i-1][j][2];\\n                }\\n                while (curr > 0 && curr % 2 == 0) {\\n                    two++;\\n                    curr /= 2;\\n                }\\n                while (curr > 0 && curr % 5 == 0) {\\n                    five++;\\n                    curr /= 5;\\n                }\\n                dpv[i][j][1] = two;\\n                dpv[i][j][2] = five;\\n                dpv[i][j][0] = Math.min(dpv[i][j][1], dpv[i][j][2]);\\n            }\\n            vmax0 = Math.max(vmax0, dpv[m-1][j][0]);\\n        }\\n\\t\\t\\n        int res = Math.max(vmax0, hmax0);\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int otwo = dph[i][j][1];\\n                int ofive = dph[i][j][2];\\n                \\n                int res1 = 0;\\n                if (i >= 1) {\\n                    int ntwo = otwo + dpv[i-1][j][1];\\n                    int nfive = ofive + dpv[i-1][j][2];\\n                    res1 = Math.min(ntwo, nfive);\\n                }\\n                \\n                int res2 = 0;\\n                if (i < m - 1) {\\n                    int ntwo = otwo + dpv[m-1][j][1] - dpv[i][j][1];\\n                    int nfive = ofive + dpv[m-1][j][2] - dpv[i][j][2];\\n                    res2 = Math.min(ntwo, nfive);\\n                }\\n                res = Math.max(res, res1);\\n                res = Math.max(res, res2);\\n            }\\n\\t\\t\\t\\n\\t\\t\\tfor (int j = n - 1; j >= 0; j--) {\\n                int otwo = 0;\\n                int ofive = 0;\\n                if (j >= 1) {\\n                    otwo = dph[i][n-1][1] - dph[i][j-1][1];\\n                    ofive = dph[i][n-1][2] - dph[i][j-1][2];\\n                } else {\\n                    otwo = dph[i][n-1][1];\\n                    ofive = dph[i][n-1][2];\\n                }\\n                \\n                int res1 = 0;\\n                if (i >= 1) {\\n                    int ntwo = otwo + dpv[i-1][j][1];\\n                    int nfive = ofive + dpv[i-1][j][2];\\n                    res1 = Math.min(ntwo, nfive);\\n                }\\n                \\n                int res2 = 0;\\n                if (i < m - 1) {\\n                    int ntwo = otwo + dpv[m-1][j][1] - dpv[i][j][1];\\n                    int nfive = ofive + dpv[m-1][j][2] - dpv[i][j][2];\\n                    res2 = Math.min(ntwo, nfive);\\n                }\\n                \\n                res = Math.max(res, res1);\\n                res = Math.max(res, res2);\\n            }\\n        }\\n\\t\\t\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][][] dph = new int[m][n][3];\\n        int[][][] dpv = new int[m][n][3];\\n        int hmax0 = 0;\\n        int vmax0 = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int curr = grid[i][j];\\n                int two = 0;\\n                int five = 0;\\n                if (j >= 1) {\\n                    two = dph[i][j-1][1];\\n                    five = dph[i][j-1][2];\\n                }\\n                while (curr > 0 && curr % 2 == 0) {\\n                    two++;\\n                    curr /= 2;\\n                }\\n                while (curr > 0 && curr % 5 == 0) {\\n                    five++;\\n                    curr /= 5;\\n                }\\n                dph[i][j][1] = two;\\n                dph[i][j][2] = five;\\n                dph[i][j][0] = Math.min(dph[i][j][1], dph[i][j][2]);\\n            }\\n            hmax0 = Math.max(hmax0, dph[i][n-1][0]);\\n        }\\n        \\n        for (int j = 0; j < n; j++) {\\n            for (int i = 0; i < m; i++) {\\n                int curr = grid[i][j];\\n                int two = 0;\\n                int five = 0;\\n                if (i >= 1) {\\n                    two = dpv[i-1][j][1];\\n                    five = dpv[i-1][j][2];\\n                }\\n                while (curr > 0 && curr % 2 == 0) {\\n                    two++;\\n                    curr /= 2;\\n                }\\n                while (curr > 0 && curr % 5 == 0) {\\n                    five++;\\n                    curr /= 5;\\n                }\\n                dpv[i][j][1] = two;\\n                dpv[i][j][2] = five;\\n                dpv[i][j][0] = Math.min(dpv[i][j][1], dpv[i][j][2]);\\n            }\\n            vmax0 = Math.max(vmax0, dpv[m-1][j][0]);\\n        }\\n\\t\\t\\n        int res = Math.max(vmax0, hmax0);\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int otwo = dph[i][j][1];\\n                int ofive = dph[i][j][2];\\n                \\n                int res1 = 0;\\n                if (i >= 1) {\\n                    int ntwo = otwo + dpv[i-1][j][1];\\n                    int nfive = ofive + dpv[i-1][j][2];\\n                    res1 = Math.min(ntwo, nfive);\\n                }\\n                \\n                int res2 = 0;\\n                if (i < m - 1) {\\n                    int ntwo = otwo + dpv[m-1][j][1] - dpv[i][j][1];\\n                    int nfive = ofive + dpv[m-1][j][2] - dpv[i][j][2];\\n                    res2 = Math.min(ntwo, nfive);\\n                }\\n                res = Math.max(res, res1);\\n                res = Math.max(res, res2);\\n            }\\n\\t\\t\\t\\n\\t\\t\\tfor (int j = n - 1; j >= 0; j--) {\\n                int otwo = 0;\\n                int ofive = 0;\\n                if (j >= 1) {\\n                    otwo = dph[i][n-1][1] - dph[i][j-1][1];\\n                    ofive = dph[i][n-1][2] - dph[i][j-1][2];\\n                } else {\\n                    otwo = dph[i][n-1][1];\\n                    ofive = dph[i][n-1][2];\\n                }\\n                \\n                int res1 = 0;\\n                if (i >= 1) {\\n                    int ntwo = otwo + dpv[i-1][j][1];\\n                    int nfive = ofive + dpv[i-1][j][2];\\n                    res1 = Math.min(ntwo, nfive);\\n                }\\n                \\n                int res2 = 0;\\n                if (i < m - 1) {\\n                    int ntwo = otwo + dpv[m-1][j][1] - dpv[i][j][1];\\n                    int nfive = ofive + dpv[m-1][j][2] - dpv[i][j][2];\\n                    res2 = Math.min(ntwo, nfive);\\n                }\\n                \\n                res = Math.max(res, res1);\\n                res = Math.max(res, res2);\\n            }\\n        }\\n\\t\\t\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955384,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<pair<int,int>>> v(m,vector<pair<int,int>>(n)),u(m,vector<pair<int,int>>(n)),d(m,vector<pair<int,int>>(n)),l(m,vector<pair<int,int>>(n)),r(m,vector<pair<int,int>>(n));\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int x=grid[i][j];\\n                v[i][j].first=0;\\n                v[i][j].second=0;\\n                while(x%2==0)\\n                {\\n                    x/=2;\\n                    v[i][j].first++;\\n                }\\n                while(x%5==0)\\n                {\\n                    x/=5;\\n                    v[i][j].second++;\\n                }\\n            }\\n        }\\n        u=v;\\n        d=v;\\n        l=v;\\n        r=v;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                l[i][j].first+=l[i][j-1].first;\\n                l[i][j].second+=l[i][j-1].second;\\n                \\n                r[i][n-j-1].first+=r[i][n-j].first;\\n                r[i][n-j-1].second+=r[i][n-j].second;\\n            }            \\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<m;j++)\\n            {\\n                u[j][i].first+=u[j-1][i].first;\\n                u[j][i].second+=u[j-1][i].second;\\n                \\n                d[m-j-1][i].first+=d[m-j][i].first;\\n                d[m-j-1][i].second+=d[m-j][i].second;\\n            }            \\n        }\\n        int res=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                \\n                int x1=u[i][j].first;\\n                int x2=u[i][j].second;\\n                int x3=l[i][j].first;\\n                int x4=l[i][j].second;\\n                \\n                int c2=x1+x3-v[i][j].first;\\n                int c5=x2+x4-v[i][j].second;\\n                res=max(res,min(c2,c5));\\n                //####################################\\n                x1=u[i][j].first;\\n                x2=u[i][j].second;\\n                x3=r[i][j].first;\\n                x4=r[i][j].second;\\n                \\n                c2=x1+x3-v[i][j].first;\\n                c5=x2+x4-v[i][j].second;\\n                res=max(res,min(c2,c5));\\n                \\n                //####################################\\n                x1=d[i][j].first;\\n                x2=d[i][j].second;\\n                x3=r[i][j].first;\\n                x4=r[i][j].second;\\n                \\n                c2=x1+x3-v[i][j].first;\\n                c5=x2+x4-v[i][j].second;\\n                res=max(res,min(c2,c5));\\n                //####################################\\n                x1=d[i][j].first;\\n                x2=d[i][j].second;\\n                x3=l[i][j].first;\\n                x4=l[i][j].second;\\n                \\n                c2=x1+x3-v[i][j].first;\\n                c5=x2+x4-v[i][j].second;\\n                res=max(res,min(c2,c5));\\n                \\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<pair<int,int>>> v(m,vector<pair<int,int>>(n)),u(m,vector<pair<int,int>>(n)),d(m,vector<pair<int,int>>(n)),l(m,vector<pair<int,int>>(n)),r(m,vector<pair<int,int>>(n));\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int x=grid[i][j];\\n                v[i][j].first=0;\\n                v[i][j].second=0;\\n                while(x%2==0)\\n                {\\n                    x/=2;\\n                    v[i][j].first++;\\n                }\\n                while(x%5==0)\\n                {\\n                    x/=5;\\n                    v[i][j].second++;\\n                }\\n            }\\n        }\\n        u=v;\\n        d=v;\\n        l=v;\\n        r=v;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                l[i][j].first+=l[i][j-1].first;\\n                l[i][j].second+=l[i][j-1].second;\\n                \\n                r[i][n-j-1].first+=r[i][n-j].first;\\n                r[i][n-j-1].second+=r[i][n-j].second;\\n            }            \\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<m;j++)\\n            {\\n                u[j][i].first+=u[j-1][i].first;\\n                u[j][i].second+=u[j-1][i].second;\\n                \\n                d[m-j-1][i].first+=d[m-j][i].first;\\n                d[m-j-1][i].second+=d[m-j][i].second;\\n            }            \\n        }\\n        int res=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                \\n                int x1=u[i][j].first;\\n                int x2=u[i][j].second;\\n                int x3=l[i][j].first;\\n                int x4=l[i][j].second;\\n                \\n                int c2=x1+x3-v[i][j].first;\\n                int c5=x2+x4-v[i][j].second;\\n                res=max(res,min(c2,c5));\\n                //####################################\\n                x1=u[i][j].first;\\n                x2=u[i][j].second;\\n                x3=r[i][j].first;\\n                x4=r[i][j].second;\\n                \\n                c2=x1+x3-v[i][j].first;\\n                c5=x2+x4-v[i][j].second;\\n                res=max(res,min(c2,c5));\\n                \\n                //####################################\\n                x1=d[i][j].first;\\n                x2=d[i][j].second;\\n                x3=r[i][j].first;\\n                x4=r[i][j].second;\\n                \\n                c2=x1+x3-v[i][j].first;\\n                c5=x2+x4-v[i][j].second;\\n                res=max(res,min(c2,c5));\\n                //####################################\\n                x1=d[i][j].first;\\n                x2=d[i][j].second;\\n                x3=l[i][j].first;\\n                x4=l[i][j].second;\\n                \\n                c2=x1+x3-v[i][j].first;\\n                c5=x2+x4-v[i][j].second;\\n                res=max(res,min(c2,c5));\\n                \\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955314,
                "title": "python3-dp-in-4-directions-commented-code",
                "content": "```\\nclass Solution:\\n    def maxTrailingZeros(self, A: List[List[int]]) -> int:\\n        \\n        # Helper method with cache to return number of twos in prime factorization of given number\\n        @cache\\n        def twos(x):\\n            res = 0\\n            while (x&1)==0:\\n                res += 1\\n                x >>= 1\\n            return res\\n        \\n        # Helper method with cache to return number of fives in prime factorization of given number\\n        @cache\\n        def fives(x):\\n            res = 0\\n            while x%5 == 0:\\n                res += 1\\n                x //= 5\\n            return res\\n        \\n        m, n = len(A), len(A[0])\\n        \\n        # Creating 2D arrays for storing number of 2\\'s and number of 5\\'s in all elements above, below, left or right\\n\\t\\t# of the current element (including current element).The two counts will be stored as a tuple i.e. as pair<int, int>\\n        \\n        up, down, left, right = [[0]*n for _ in range(m)], [[0]*n for _ in range(m)], [[0]*n for _ in range(m)], [[0]*n for _ in range(m)]\\n        \\n        # Initializing first row of up array and last row of down array\\n        for j in range(n):\\n            up[0][j] = (twos(A[0][j]),fives(A[0][j]))\\n            down[m-1][j] = (twos(A[m-1][j]), fives(A[m-1][j]))\\n        \\n        # Initializing leftmost column of left array and rightmost column of right array\\n        for i in range(m):\\n            left[i][0] = (twos(A[i][0]), fives(A[i][0]))\\n            right[i][n-1] = (twos(A[i][n-1]), fives(A[i][n-1]))\\n            \\n        # Populating all remaining cells of all arrays\\n        \\n        for i in range(1, m):\\n            for j in range(n):\\n                up[i][j] = (up[i-1][j][0] + twos(A[i][j]), up[i-1][j][1] + fives(A[i][j]))\\n        \\n        for i in range(m-2, -1, -1):\\n            for j in range(n):\\n                down[i][j] = (down[i+1][j][0] + twos(A[i][j]), down[i+1][j][1] + fives(A[i][j]))\\n        \\n        for i in range(m):\\n            for j in range(1, n):\\n                left[i][j] = (left[i][j-1][0] + twos(A[i][j]), left[i][j-1][1] + fives(A[i][j]))\\n        \\n        for i in range(m):\\n            for j in range(n-2, -1, -1):\\n                right[i][j] = (right[i][j+1][0] + twos(A[i][j]), right[i][j+1][1] + fives(A[i][j]))\\n        \\n        # Iterating over each cell to first take pairwise sum in two directions of 2\\'s and 5\\'s then subtract current cell values (because it\\'s counted twice) \\n\\t\\t# finally take min of 2\\'s and 5\\'s for that cell where the horizontal/vertical turn happens\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                res = max(res, min(up[i][j][0] + right[i][j][0] - twos(A[i][j]), up[i][j][1] + right[i][j][1] - fives(A[i][j])))\\n                res = max(res, min(up[i][j][0] + left[i][j][0] - twos(A[i][j]), up[i][j][1] + left[i][j][1] - fives(A[i][j])))\\n                res = max(res, min(down[i][j][0] + right[i][j][0] - twos(A[i][j]), down[i][j][1] + right[i][j][1] - fives(A[i][j])))\\n                res = max(res, min(down[i][j][0] + left[i][j][0] - twos(A[i][j]), down[i][j][1] + left[i][j][1] - fives(A[i][j])))\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, A: List[List[int]]) -> int:\\n        \\n        # Helper method with cache to return number of twos in prime factorization of given number\\n        @cache\\n        def twos(x):\\n            res = 0\\n            while (x&1)==0:\\n                res += 1\\n                x >>= 1\\n            return res\\n        \\n        # Helper method with cache to return number of fives in prime factorization of given number\\n        @cache\\n        def fives(x):\\n            res = 0\\n            while x%5 == 0:\\n                res += 1\\n                x //= 5\\n            return res\\n        \\n        m, n = len(A), len(A[0])\\n        \\n        # Creating 2D arrays for storing number of 2\\'s and number of 5\\'s in all elements above, below, left or right\\n\\t\\t# of the current element (including current element).The two counts will be stored as a tuple i.e. as pair<int, int>\\n        \\n        up, down, left, right = [[0]*n for _ in range(m)], [[0]*n for _ in range(m)], [[0]*n for _ in range(m)], [[0]*n for _ in range(m)]\\n        \\n        # Initializing first row of up array and last row of down array\\n        for j in range(n):\\n            up[0][j] = (twos(A[0][j]),fives(A[0][j]))\\n            down[m-1][j] = (twos(A[m-1][j]), fives(A[m-1][j]))\\n        \\n        # Initializing leftmost column of left array and rightmost column of right array\\n        for i in range(m):\\n            left[i][0] = (twos(A[i][0]), fives(A[i][0]))\\n            right[i][n-1] = (twos(A[i][n-1]), fives(A[i][n-1]))\\n            \\n        # Populating all remaining cells of all arrays\\n        \\n        for i in range(1, m):\\n            for j in range(n):\\n                up[i][j] = (up[i-1][j][0] + twos(A[i][j]), up[i-1][j][1] + fives(A[i][j]))\\n        \\n        for i in range(m-2, -1, -1):\\n            for j in range(n):\\n                down[i][j] = (down[i+1][j][0] + twos(A[i][j]), down[i+1][j][1] + fives(A[i][j]))\\n        \\n        for i in range(m):\\n            for j in range(1, n):\\n                left[i][j] = (left[i][j-1][0] + twos(A[i][j]), left[i][j-1][1] + fives(A[i][j]))\\n        \\n        for i in range(m):\\n            for j in range(n-2, -1, -1):\\n                right[i][j] = (right[i][j+1][0] + twos(A[i][j]), right[i][j+1][1] + fives(A[i][j]))\\n        \\n        # Iterating over each cell to first take pairwise sum in two directions of 2\\'s and 5\\'s then subtract current cell values (because it\\'s counted twice) \\n\\t\\t# finally take min of 2\\'s and 5\\'s for that cell where the horizontal/vertical turn happens\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                res = max(res, min(up[i][j][0] + right[i][j][0] - twos(A[i][j]), up[i][j][1] + right[i][j][1] - fives(A[i][j])))\\n                res = max(res, min(up[i][j][0] + left[i][j][0] - twos(A[i][j]), up[i][j][1] + left[i][j][1] - fives(A[i][j])))\\n                res = max(res, min(down[i][j][0] + right[i][j][0] - twos(A[i][j]), down[i][j][1] + right[i][j][1] - fives(A[i][j])))\\n                res = max(res, min(down[i][j][0] + left[i][j][0] - twos(A[i][j]), down[i][j][1] + left[i][j][1] - fives(A[i][j])))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193042,
                "title": "c-test-in-4-directions-prefix-sums",
                "content": "```\\n//firstly count \\'5\\' s and \\'2\\' s for every cell,  (each pair of (5,2) will generate a trailing zero),\\n//use prefix sums to accelerate the counting of 5s and 2s.\\n//and then check in 4 directions to find out the turn has max count of pairs (5,2)\\nclass Solution {\\npublic:\\n\\tint maxTrailingZeros(vector<vector<int>>& grid) {\\n\\t\\tint m = grid.size(), n = grid[0].size(), r = 0, i, j, v, fiveCount, twoCount, a, b, a1, b1, a2, b2, a3, b3, a4, b4;\\n\\t\\tvector<vector<int>> fiveHor(m, vector<int>(n, 0)), fiveVer(m, vector<int>(n, 0)),twoHor(m, vector<int>(n, 0)),  twoVer(m, vector<int>(n, 0));\\n\\n\\t\\tfor (i = 0; i < m; ++i) {\\n\\t\\t\\tfor (j = 0; j < n; ++j) {\\n\\t\\t\\t\\tv = grid[i][j], fiveCount = 0, twoCount = 0;\\n\\t\\t\\t\\twhile (v % 5 == 0) { fiveCount++;  v /= 5; }\\n\\t\\t\\t\\twhile (v && (v % 2 == 0)) { twoCount++; v /= 2; }\\n\\n\\t\\t\\t\\tfiveHor[i][j] = ((j == 0) ? 0 : fiveHor[i][j - 1]) + fiveCount;   //five prefix sum in horizontal\\n\\t\\t\\t\\tfiveVer[i][j] = ((i == 0) ? 0 : fiveVer[i - 1][j]) + fiveCount;   //five prefix sum in vertical\\n                \\n\\t\\t\\t\\ttwoHor[i][j]  = ((j == 0) ? 0 : twoHor[i][j - 1]) + twoCount;     //two prefix sum in horizontal\\t\\t\\t\\t\\n                twoVer[i][j]  = ((i == 0) ? 0 : twoVer[i - 1][j]) + twoCount;     //two prefix sum in vertical\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (i = 0; i < m; ++i) {\\n\\t\\t\\tfor (j = 0; j < n; ++j) {\\n\\t\\t\\t\\ta = fiveHor[i][j] - (j == 0 ? 0 : fiveHor[i][j - 1]); //current cell\\'s count of 5\\n\\t\\t\\t\\tb = twoHor[i][j]  - (j == 0 ? 0 : twoHor[i][j - 1]); //current cell\\'s count of 2\\n                \\n\\t\\t\\t\\ta1 = fiveHor[i][n - 1] - fiveHor[i][j];                b1 = twoHor[i][n - 1] - twoHor[i][j];    //right\\n\\t\\t\\t\\ta2 = fiveVer[m - 1][j] - fiveVer[i][j];                b2 = twoVer[m - 1][j] - twoVer[i][j];    //down\\n\\t\\t\\t\\ta3 = (j == 0) ? 0 : fiveHor[i][j - 1];                 b3 = (j == 0) ? 0 : twoHor[i][j - 1];    //left\\n\\t\\t\\t\\ta4 = (i == 0) ? 0 : fiveVer[i - 1][j];                 b4 = (i == 0) ? 0 : twoVer[i - 1][j];    //up\\n\\n\\t\\t\\t\\tr = max(r, min(a + a1 + a2, b + b1 + b2));\\n\\t\\t\\t\\tr = max(r, min(a + a2 + a3, b + b2 + b3));\\n\\t\\t\\t\\tr = max(r, min(a + a3 + a4, b + b3 + b4));\\n\\t\\t\\t\\tr = max(r, min(a + a4 + a1, b + b4 + b1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn r;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//firstly count \\'5\\' s and \\'2\\' s for every cell,  (each pair of (5,2) will generate a trailing zero),\\n//use prefix sums to accelerate the counting of 5s and 2s.\\n//and then check in 4 directions to find out the turn has max count of pairs (5,2)\\nclass Solution {\\npublic:\\n\\tint maxTrailingZeros(vector<vector<int>>& grid) {\\n\\t\\tint m = grid.size(), n = grid[0].size(), r = 0, i, j, v, fiveCount, twoCount, a, b, a1, b1, a2, b2, a3, b3, a4, b4;\\n\\t\\tvector<vector<int>> fiveHor(m, vector<int>(n, 0)), fiveVer(m, vector<int>(n, 0)),twoHor(m, vector<int>(n, 0)),  twoVer(m, vector<int>(n, 0));\\n\\n\\t\\tfor (i = 0; i < m; ++i) {\\n\\t\\t\\tfor (j = 0; j < n; ++j) {\\n\\t\\t\\t\\tv = grid[i][j], fiveCount = 0, twoCount = 0;\\n\\t\\t\\t\\twhile (v % 5 == 0) { fiveCount++;  v /= 5; }\\n\\t\\t\\t\\twhile (v && (v % 2 == 0)) { twoCount++; v /= 2; }\\n\\n\\t\\t\\t\\tfiveHor[i][j] = ((j == 0) ? 0 : fiveHor[i][j - 1]) + fiveCount;   //five prefix sum in horizontal\\n\\t\\t\\t\\tfiveVer[i][j] = ((i == 0) ? 0 : fiveVer[i - 1][j]) + fiveCount;   //five prefix sum in vertical\\n                \\n\\t\\t\\t\\ttwoHor[i][j]  = ((j == 0) ? 0 : twoHor[i][j - 1]) + twoCount;     //two prefix sum in horizontal\\t\\t\\t\\t\\n                twoVer[i][j]  = ((i == 0) ? 0 : twoVer[i - 1][j]) + twoCount;     //two prefix sum in vertical\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (i = 0; i < m; ++i) {\\n\\t\\t\\tfor (j = 0; j < n; ++j) {\\n\\t\\t\\t\\ta = fiveHor[i][j] - (j == 0 ? 0 : fiveHor[i][j - 1]); //current cell\\'s count of 5\\n\\t\\t\\t\\tb = twoHor[i][j]  - (j == 0 ? 0 : twoHor[i][j - 1]); //current cell\\'s count of 2\\n                \\n\\t\\t\\t\\ta1 = fiveHor[i][n - 1] - fiveHor[i][j];                b1 = twoHor[i][n - 1] - twoHor[i][j];    //right\\n\\t\\t\\t\\ta2 = fiveVer[m - 1][j] - fiveVer[i][j];                b2 = twoVer[m - 1][j] - twoVer[i][j];    //down\\n\\t\\t\\t\\ta3 = (j == 0) ? 0 : fiveHor[i][j - 1];                 b3 = (j == 0) ? 0 : twoHor[i][j - 1];    //left\\n\\t\\t\\t\\ta4 = (i == 0) ? 0 : fiveVer[i - 1][j];                 b4 = (i == 0) ? 0 : twoVer[i - 1][j];    //up\\n\\n\\t\\t\\t\\tr = max(r, min(a + a1 + a2, b + b1 + b2));\\n\\t\\t\\t\\tr = max(r, min(a + a2 + a3, b + b2 + b3));\\n\\t\\t\\t\\tr = max(r, min(a + a3 + a4, b + b3 + b4));\\n\\t\\t\\t\\tr = max(r, min(a + a4 + a1, b + b4 + b1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn r;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2068113,
                "title": "kotlin-solution",
                "content": "```\\n    fun maxTrailingZeros(grid: Array<IntArray>): Int {\\n        val m = grid.size\\n        val n = grid[0].size\\n        val twosLeftToRight = Array(m) { IntArray(n) }\\n        val fivesLeftToRight = Array(m) { IntArray(n) }\\n        val twosUpToDown = Array(m) { IntArray(n) }\\n        val fivesUpToDown = Array(m) { IntArray(n) }\\n\\n        var maxTrailingZeros = 0\\n        for (i in grid.indices) {\\n            for (j in 0 until n) {\\n                var num = grid[i][j]\\n                var five = 0\\n                while (num % 5 == 0) {\\n                    five++\\n                    num /= 5\\n                }\\n                num = grid[i][j]\\n                var two = 0\\n                while (num % 2 == 0) {\\n                    two++\\n                    num /= 2\\n                }\\n                var leftTwo = two\\n                var leftFive = five\\n                var upTwo = two\\n                var upFive = five\\n\\n                if (j != 0) {\\n                    leftTwo += twosLeftToRight[i][j - 1]\\n                    leftFive += fivesLeftToRight[i][j - 1]\\n                }\\n                twosLeftToRight[i][j] = leftTwo\\n                fivesLeftToRight[i][j] = leftFive\\n                if (i != 0) {\\n                    upTwo += twosUpToDown[i - 1][j]\\n                    upFive += fivesUpToDown[i - 1][j]\\n                }\\n                twosUpToDown[i][j] = upTwo\\n                fivesUpToDown[i][j] = upFive\\n            }\\n        }\\n\\n        for (i in grid.indices) {\\n            for (j in 0 until n) {\\n                var upBeginning5 = 0\\n                var upBeginning2 = 0\\n                if (i != 0) {\\n                    upBeginning5 = fivesUpToDown[i - 1][0]\\n                    upBeginning2 = twosUpToDown[i - 1][0]\\n                }\\n                var downBeginnings5 = 0\\n                var downBeginnings2 = 0\\n                if (i != m - 1) {\\n                    downBeginnings5 = fivesUpToDown[m - 1][0] - fivesUpToDown[i][0]\\n                    downBeginnings2 = twosUpToDown[m - 1][0] - twosUpToDown[i][0]\\n                }\\n\\n                var topEndings5 = 0\\n                var topEndings2 = 0\\n                if (i != 0) {\\n                    topEndings5 = fivesUpToDown[i - 1][n - 1]\\n                    topEndings2 = twosUpToDown[i - 1][n - 1]\\n                }\\n                var downEndings5 = 0\\n                var downEndings2 = 0\\n                if (i != m - 1) {\\n                    downEndings5 = fivesUpToDown[m - 1][n - 1] - fivesUpToDown[i][n - 1]\\n                    downEndings2 = twosUpToDown[m - 1][n - 1] - twosUpToDown[i][n - 1]\\n                }\\n\\n                val leftSide5 = fivesLeftToRight[i][j]\\n                val leftSide2 = twosLeftToRight[i][j]\\n\\n                var topSide5 = 0\\n                var topSide2 = 0\\n                if (i != 0) {\\n                    topSide5 = fivesUpToDown[i - 1][j]\\n                    topSide2 = twosUpToDown[i - 1][j]\\n                }\\n\\n                val downSide5 = fivesUpToDown[m - 1][j] - fivesUpToDown[i][j]\\n                val downSide2 = twosUpToDown[m - 1][j] - twosUpToDown[i][j]\\n\\n                var rightSide5 = 0\\n                var rightSide2 = 0\\n                if (j != 0) {\\n                    rightSide5 = fivesLeftToRight[i][n - 1] - fivesLeftToRight[i][j - 1]\\n                    rightSide2 = twosLeftToRight[i][n - 1] - twosLeftToRight[i][j - 1]\\n                }\\n\\n                var min = Math.min(leftSide2 + topSide2, topSide5 + leftSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(rightSide2 + topSide2, topSide5 + rightSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(leftSide2 + downSide2, downSide5 + leftSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(rightSide2 + downSide2, downSide5 + rightSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(leftSide2 + upBeginning2, upBeginning5 + leftSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(leftSide2 + downBeginnings2, downBeginnings5 + leftSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(rightSide2 + downEndings2, downEndings5 + rightSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(rightSide2 + topEndings2, topEndings5 + rightSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n            }\\n        }\\n        return maxTrailingZeros\\n    }\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Prefix Sum"
                ],
                "code": "```\\n    fun maxTrailingZeros(grid: Array<IntArray>): Int {\\n        val m = grid.size\\n        val n = grid[0].size\\n        val twosLeftToRight = Array(m) { IntArray(n) }\\n        val fivesLeftToRight = Array(m) { IntArray(n) }\\n        val twosUpToDown = Array(m) { IntArray(n) }\\n        val fivesUpToDown = Array(m) { IntArray(n) }\\n\\n        var maxTrailingZeros = 0\\n        for (i in grid.indices) {\\n            for (j in 0 until n) {\\n                var num = grid[i][j]\\n                var five = 0\\n                while (num % 5 == 0) {\\n                    five++\\n                    num /= 5\\n                }\\n                num = grid[i][j]\\n                var two = 0\\n                while (num % 2 == 0) {\\n                    two++\\n                    num /= 2\\n                }\\n                var leftTwo = two\\n                var leftFive = five\\n                var upTwo = two\\n                var upFive = five\\n\\n                if (j != 0) {\\n                    leftTwo += twosLeftToRight[i][j - 1]\\n                    leftFive += fivesLeftToRight[i][j - 1]\\n                }\\n                twosLeftToRight[i][j] = leftTwo\\n                fivesLeftToRight[i][j] = leftFive\\n                if (i != 0) {\\n                    upTwo += twosUpToDown[i - 1][j]\\n                    upFive += fivesUpToDown[i - 1][j]\\n                }\\n                twosUpToDown[i][j] = upTwo\\n                fivesUpToDown[i][j] = upFive\\n            }\\n        }\\n\\n        for (i in grid.indices) {\\n            for (j in 0 until n) {\\n                var upBeginning5 = 0\\n                var upBeginning2 = 0\\n                if (i != 0) {\\n                    upBeginning5 = fivesUpToDown[i - 1][0]\\n                    upBeginning2 = twosUpToDown[i - 1][0]\\n                }\\n                var downBeginnings5 = 0\\n                var downBeginnings2 = 0\\n                if (i != m - 1) {\\n                    downBeginnings5 = fivesUpToDown[m - 1][0] - fivesUpToDown[i][0]\\n                    downBeginnings2 = twosUpToDown[m - 1][0] - twosUpToDown[i][0]\\n                }\\n\\n                var topEndings5 = 0\\n                var topEndings2 = 0\\n                if (i != 0) {\\n                    topEndings5 = fivesUpToDown[i - 1][n - 1]\\n                    topEndings2 = twosUpToDown[i - 1][n - 1]\\n                }\\n                var downEndings5 = 0\\n                var downEndings2 = 0\\n                if (i != m - 1) {\\n                    downEndings5 = fivesUpToDown[m - 1][n - 1] - fivesUpToDown[i][n - 1]\\n                    downEndings2 = twosUpToDown[m - 1][n - 1] - twosUpToDown[i][n - 1]\\n                }\\n\\n                val leftSide5 = fivesLeftToRight[i][j]\\n                val leftSide2 = twosLeftToRight[i][j]\\n\\n                var topSide5 = 0\\n                var topSide2 = 0\\n                if (i != 0) {\\n                    topSide5 = fivesUpToDown[i - 1][j]\\n                    topSide2 = twosUpToDown[i - 1][j]\\n                }\\n\\n                val downSide5 = fivesUpToDown[m - 1][j] - fivesUpToDown[i][j]\\n                val downSide2 = twosUpToDown[m - 1][j] - twosUpToDown[i][j]\\n\\n                var rightSide5 = 0\\n                var rightSide2 = 0\\n                if (j != 0) {\\n                    rightSide5 = fivesLeftToRight[i][n - 1] - fivesLeftToRight[i][j - 1]\\n                    rightSide2 = twosLeftToRight[i][n - 1] - twosLeftToRight[i][j - 1]\\n                }\\n\\n                var min = Math.min(leftSide2 + topSide2, topSide5 + leftSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(rightSide2 + topSide2, topSide5 + rightSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(leftSide2 + downSide2, downSide5 + leftSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(rightSide2 + downSide2, downSide5 + rightSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(leftSide2 + upBeginning2, upBeginning5 + leftSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(leftSide2 + downBeginnings2, downBeginnings5 + leftSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(rightSide2 + downEndings2, downEndings5 + rightSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(rightSide2 + topEndings2, topEndings5 + rightSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n            }\\n        }\\n        return maxTrailingZeros\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1956582,
                "title": "java-easy-to-understand-dp-100-time-and-memory",
                "content": "HINT1:\\nif we want to get the number of trailing zeros, we only need to figure out how many 5 and 2 the product has.\\n\\nHINT2:\\nFor each element as a corner, we have 4 directions and we need to combine any of the 2 to get a valid path.  So every corner has 6 different paths.\\n\\n\\n1.\\n0 1 0 0 \\n0 1 0 0\\n0 1 0 0\\n0 1 0 0\\n\\n2.\\n0 1 0 0 \\n0 1 1 1\\n0 0 0 0\\n0 0 0 0\\n\\n3.\\n0 1 0 0 \\n1 1 0 0\\n0 0 0 0\\n0 0 0 0\\n\\n4.\\n0 0 0 0 \\n1 1 1 1\\n0 0 0 0\\n0 0 0 0\\n\\n5.\\n0 0 0 0 \\n1 1 0 0\\n0 1 0 0\\n0 1 0 0\\n\\n6.\\n0 0 0 0 \\n0 1 1 1\\n0 1 0 0\\n0 1 0 0\\n\\n\\n\\n```\\n \\n public static int maxTrailingZeros(int[][] grid) {\\n        /*calculate how many 5 and 2 grid[i][j] has\\n        int[][] five = new int[grid.length][grid[0].length];\\n        int[][] two = new int[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                int origin = grid[i][j];\\n                while (origin % 5 == 0 && origin != 0) {\\n                    five[i][j] += 1;\\n                    origin = origin / 5;\\n                }\\n                origin = grid[i][j];\\n                while (origin % 2 == 0 && origin != 0) {\\n                    two[i][j] += 1;\\n                    origin = origin / 2;\\n                }\\n            }\\n        }\\n        // use four dp array to save the sum of 5 and 2 in two directions\\n        int[][] dp51 = new int[grid.length][grid[0].length];\\n        int[][] dp21 = new int[grid.length][grid[0].length];\\n        int[][] dp52 = new int[grid.length][grid[0].length];\\n        int[][] dp22 = new int[grid.length][grid[0].length];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (i == 0) {\\n                    dp51[i][j] = five[i][j];\\n                    dp21[i][j] = two[i][j];\\n                } else {\\n                    dp51[i][j] = dp51[i - 1][j] + five[i][j];\\n                    dp21[i][j] = dp21[i - 1][j] + two[i][j];\\n                }\\n                if (j == 0) {\\n                    dp52[i][j] = five[i][j];\\n                    dp22[i][j] = two[i][j];\\n                } else {\\n                    dp52[i][j] = dp52[i][j - 1] + five[i][j];\\n                    dp22[i][j] = dp22[i][j - 1] + two[i][j];\\n                }\\n            }\\n        }\\n        \\n        //we have 4 choices and combine any of 2\\n        int max = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                int fiveNum = dp51[i][j];\\n                int twoNum = dp21[i][j];\\n\\n                int fiveNum2 = dp52[i][j];\\n                int twoNum2 = dp22[i][j];\\n\\n                int fiveNum1 = dp51[grid.length - 1][j] - dp51[i][j] + five[i][j];\\n                int twoNum1 = dp21[grid.length - 1][j] - dp21[i][j] + two[i][j];\\n\\n                int fiveNum3 = dp52[i][grid[0].length - 1] - dp52[i][j] + five[i][j];\\n                int twoNum3 = dp22[i][grid[0].length - 1] - dp22[i][j] + two[i][j];\\n\\n\\n                max = Math.max(max, Math.min(fiveNum + fiveNum1 - five[i][j], twoNum + twoNum1 - two[i][j]));\\n                max = Math.max(max, Math.min(fiveNum + fiveNum2 - five[i][j], twoNum + twoNum2 - two[i][j]));\\n                max = Math.max(max, Math.min(fiveNum + fiveNum3 - five[i][j], twoNum + twoNum3 - two[i][j]));\\n                max = Math.max(max, Math.min(fiveNum2 + fiveNum1 - five[i][j], twoNum2 + twoNum1 - two[i][j]));\\n                max = Math.max(max, Math.min(fiveNum3 + fiveNum1 - five[i][j], twoNum3 + twoNum1 - two[i][j]));\\n                max = Math.max(max, Math.min(fiveNum2 + fiveNum3 - five[i][j], twoNum2 + twoNum3 - two[i][j]));\\n            }\\n        }\\n        return max;\\n    }\\n \\n \\n  ```\\n \\n \\n \\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n \\n public static int maxTrailingZeros(int[][] grid) {\\n        /*calculate how many 5 and 2 grid[i][j] has\\n        int[][] five = new int[grid.length][grid[0].length];\\n        int[][] two = new int[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                int origin = grid[i][j];\\n                while (origin % 5 == 0 && origin != 0) {\\n                    five[i][j] += 1;\\n                    origin = origin / 5;\\n                }\\n                origin = grid[i][j];\\n                while (origin % 2 == 0 && origin != 0) {\\n                    two[i][j] += 1;\\n                    origin = origin / 2;\\n                }\\n            }\\n        }\\n        // use four dp array to save the sum of 5 and 2 in two directions\\n        int[][] dp51 = new int[grid.length][grid[0].length];\\n        int[][] dp21 = new int[grid.length][grid[0].length];\\n        int[][] dp52 = new int[grid.length][grid[0].length];\\n        int[][] dp22 = new int[grid.length][grid[0].length];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (i == 0) {\\n                    dp51[i][j] = five[i][j];\\n                    dp21[i][j] = two[i][j];\\n                } else {\\n                    dp51[i][j] = dp51[i - 1][j] + five[i][j];\\n                    dp21[i][j] = dp21[i - 1][j] + two[i][j];\\n                }\\n                if (j == 0) {\\n                    dp52[i][j] = five[i][j];\\n                    dp22[i][j] = two[i][j];\\n                } else {\\n                    dp52[i][j] = dp52[i][j - 1] + five[i][j];\\n                    dp22[i][j] = dp22[i][j - 1] + two[i][j];\\n                }\\n            }\\n        }\\n        \\n        //we have 4 choices and combine any of 2\\n        int max = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                int fiveNum = dp51[i][j];\\n                int twoNum = dp21[i][j];\\n\\n                int fiveNum2 = dp52[i][j];\\n                int twoNum2 = dp22[i][j];\\n\\n                int fiveNum1 = dp51[grid.length - 1][j] - dp51[i][j] + five[i][j];\\n                int twoNum1 = dp21[grid.length - 1][j] - dp21[i][j] + two[i][j];\\n\\n                int fiveNum3 = dp52[i][grid[0].length - 1] - dp52[i][j] + five[i][j];\\n                int twoNum3 = dp22[i][grid[0].length - 1] - dp22[i][j] + two[i][j];\\n\\n\\n                max = Math.max(max, Math.min(fiveNum + fiveNum1 - five[i][j], twoNum + twoNum1 - two[i][j]));\\n                max = Math.max(max, Math.min(fiveNum + fiveNum2 - five[i][j], twoNum + twoNum2 - two[i][j]));\\n                max = Math.max(max, Math.min(fiveNum + fiveNum3 - five[i][j], twoNum + twoNum3 - two[i][j]));\\n                max = Math.max(max, Math.min(fiveNum2 + fiveNum1 - five[i][j], twoNum2 + twoNum1 - two[i][j]));\\n                max = Math.max(max, Math.min(fiveNum3 + fiveNum1 - five[i][j], twoNum3 + twoNum1 - two[i][j]));\\n                max = Math.max(max, Math.min(fiveNum2 + fiveNum3 - five[i][j], twoNum2 + twoNum3 - two[i][j]));\\n            }\\n        }\\n        return max;\\n    }\\n \\n \\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1956103,
                "title": "consider-all-6-shapes-of-l-at-each-point",
                "content": "```\\nclass Solution {\\npublic: \\n    int numberoffives(int n){ //calculates k if n = p1 *p2* (5^k)\\n        int cnt=0;\\n        while(n%5==0){\\n            n/=5;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    int numberoftwos(int n){\\n        int cnt=0;\\n        while(n%2==0){\\n            n/=2;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<pair<int, int>>> five(m+1, vector<pair<int, int>>(n+1, {0, 0})); // pair.first represents rows prefix sum of number of fives and pair.second represents columns prefix sum of number of fives \\n        vector<vector<pair<int, int>>> two(m+1, vector<pair<int, int>>(n+1, {0, 0}));\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=1; j<n+1; j++){\\n                \\n                    five[i][j].first= five[i][j-1].first+ numberoffives(grid[i][j-1]);\\n                    two[i][j].first= two[i][j-1].first+ numberoftwos(grid[i][j-1]);\\n               \\n            }\\n        } // calculate row prefix\\n        \\n        for(int j=0; j<n; j++){\\n            for(int i=1; i<m+1; i++){\\n                \\n                    five[i][j].second= five[i-1][j].second+ numberoffives(grid[i-1][j]);\\n                    two[i][j].second= two[i-1][j].second+ numberoftwos(grid[i-1][j]);\\n               \\n            }\\n        }// calculate col prefix\\n\\n        int maxi=INT_MIN;\\n        for(int i=0; i<m; i++){ //                                                                                                       \\n            for(int j=0; j<n; j++){//                                                                                                     \\n\\t\\t\\t// Try all L shapes possible at a given joint(o) we can have at max 6 shapes  ----- o -------\\n\\t\\t\\t                                                                                                            \\n                //route1\\n                int f= numberoffives(grid[i][j]);\\n                int t= numberoftwos(grid[i][j]);\\n                int ans= min(two[i][j].first+ two[i][j].second+t,  five[i][j].first+ five[i][j].second+f);   \\n                //route 2\\n                int temp=0;\\n                temp= min(two[i][j].first+ (two[m][j].second-two[i][j].second), five[i][j].first+ (five[m][j].second-five[i][j].second));\\n                 ans=max(ans, temp);\\n                 // route 3\\n               temp= min(two[i][n].first-two[i][j].first+ (two[m][j].second-two[i][j].second)-t, five[i][n].first-five[i][j].first+ (five[m][j].second-five[i][j].second)-f);\\n                ans=max(ans, temp);\\n                // route 4\\n                  temp= min(two[i][n].first-two[i][j].first+ (two[i][j].second), five[i][n].first-five[i][j].first+ (five[i][j].second));\\n                ans=max(ans, temp);\\n                //route 5 && 6\\n                temp=min(two[i][n].first,  five[i][n].first);\\n                ans=max(ans, temp);\\n                temp=min(two[m][j].second,  five[m][j].second);\\n                ans=max(ans, temp);\\n                // cout<<ans<<\" \";\\n                maxi= max(ans, maxi);       \\n            }\\n            // cout<<endl;\\n        }\\n        return maxi;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int numberoffives(int n){ //calculates k if n = p1 *p2* (5^k)\\n        int cnt=0;\\n        while(n%5==0){\\n            n/=5;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    int numberoftwos(int n){\\n        int cnt=0;\\n        while(n%2==0){\\n            n/=2;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<pair<int, int>>> five(m+1, vector<pair<int, int>>(n+1, {0, 0})); // pair.first represents rows prefix sum of number of fives and pair.second represents columns prefix sum of number of fives \\n        vector<vector<pair<int, int>>> two(m+1, vector<pair<int, int>>(n+1, {0, 0}));\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=1; j<n+1; j++){\\n                \\n                    five[i][j].first= five[i][j-1].first+ numberoffives(grid[i][j-1]);\\n                    two[i][j].first= two[i][j-1].first+ numberoftwos(grid[i][j-1]);\\n               \\n            }\\n        } // calculate row prefix\\n        \\n        for(int j=0; j<n; j++){\\n            for(int i=1; i<m+1; i++){\\n                \\n                    five[i][j].second= five[i-1][j].second+ numberoffives(grid[i-1][j]);\\n                    two[i][j].second= two[i-1][j].second+ numberoftwos(grid[i-1][j]);\\n               \\n            }\\n        }// calculate col prefix\\n\\n        int maxi=INT_MIN;\\n        for(int i=0; i<m; i++){ //                                                                                                       \\n            for(int j=0; j<n; j++){//                                                                                                     \\n\\t\\t\\t// Try all L shapes possible at a given joint(o) we can have at max 6 shapes  ----- o -------\\n\\t\\t\\t                                                                                                            \\n                //route1\\n                int f= numberoffives(grid[i][j]);\\n                int t= numberoftwos(grid[i][j]);\\n                int ans= min(two[i][j].first+ two[i][j].second+t,  five[i][j].first+ five[i][j].second+f);   \\n                //route 2\\n                int temp=0;\\n                temp= min(two[i][j].first+ (two[m][j].second-two[i][j].second), five[i][j].first+ (five[m][j].second-five[i][j].second));\\n                 ans=max(ans, temp);\\n                 // route 3\\n               temp= min(two[i][n].first-two[i][j].first+ (two[m][j].second-two[i][j].second)-t, five[i][n].first-five[i][j].first+ (five[m][j].second-five[i][j].second)-f);\\n                ans=max(ans, temp);\\n                // route 4\\n                  temp= min(two[i][n].first-two[i][j].first+ (two[i][j].second), five[i][n].first-five[i][j].first+ (five[i][j].second));\\n                ans=max(ans, temp);\\n                //route 5 && 6\\n                temp=min(two[i][n].first,  five[i][n].first);\\n                ans=max(ans, temp);\\n                temp=min(two[m][j].second,  five[m][j].second);\\n                ans=max(ans, temp);\\n                // cout<<ans<<\" \";\\n                maxi= max(ans, maxi);       \\n            }\\n            // cout<<endl;\\n        }\\n        return maxi;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1955820,
                "title": "a-javascript-solution",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar maxTrailingZeros = function(g) {\\n    const m = g.length;\\n    const n = g[0].length;\\n    const ta = [...Array(m)].map(i => Array(n).fill(1));\\n    const tb = [...Array(m)].map(i => Array(n).fill(1));\\n    const tc = [...Array(m)].map(i => Array(n).fill(1));\\n    const td = [...Array(m)].map(i => Array(n).fill(1));\\n    \\n    const c52 = (s) => {\\n        let c5 = 0;\\n        let c2 = 0;\\n        while (s % 2 === 0) {\\n            s = s / 2;\\n            c2++;\\n        }\\n        while (s % 5 === 0) {\\n            s = s / 5;\\n            c5++;\\n        }\\n        return [c5, c2];\\n    }\\n    \\n    const c10 = ([c5, c2]) => {\\n        return Math.min(c5, c2);\\n    }\\n    \\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            ta[i][j] = (j === 0) ? c52(g[i][j]) : [c52(g[i][j])[0] + ta[i][j-1][0], c52(g[i][j])[1] + ta[i][j-1][1]];\\n            tb[i][j] = (i === 0) ? c52(g[i][j]) :  [c52(g[i][j])[0] + tb[i-1][j][0], c52(g[i][j])[1] + tb[i-1][j][1]];\\n        }\\n    }\\n    \\n    for (let i = m-1; i >= 0; i--) {\\n        for (let j = n-1; j >= 0; j--) {\\n            tc[i][j] = (j === n-1) ? c52(g[i][j]) : [c52(g[i][j])[0] + tc[i][j+1][0], c52(g[i][j])[1] + tc[i][j+1][1]];  // : ctz(hg(g[i][j]) * tc[i][j+1][0], tc[i][j+1][1]); // hg(g[i][j]) * tc[i][j+1];\\n            td[i][j] = (i === m-1) ? c52(g[i][j]) : [c52(g[i][j])[0] + td[i+1][j][0], c52(g[i][j])[1] + td[i+1][j][1]]; // : ctz(hg(g[i][j]) * td[i+1][j][0], td[i+1][j][1]); // hg(g[i][j]) * td[i+1][j];\\n        }\\n    }\\n    \\n    let ret = 0;\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            let s1 = i === 0 ? c10(ta[i][j]) : c10([ta[i][j][0] + tb[i-1][j][0], ta[i][j][1] + tb[i-1][j][1]]);\\n            let s2 = i === m - 1 ? c10(ta[i][j]) : c10([ta[i][j][0] + td[i+1][j][0], ta[i][j][1] + td[i+1][j][1]]);            \\n            let s3 = i === 0 ? c10(tc[i][j]) : c10([tc[i][j][0] + tb[i-1][j][0], tc[i][j][1] + tb[i-1][j][1]]);\\n            let s4 = i === m - 1 ? c10(tc[i][j]) : c10([tc[i][j][0] + td[i+1][j][0], tc[i][j][1] + td[i+1][j][1]]); \\n            ret = Math.max(ret, s1, s2, s3, s4);\\n        }\\n    }\\n    return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar maxTrailingZeros = function(g) {\\n    const m = g.length;\\n    const n = g[0].length;\\n    const ta = [...Array(m)].map(i => Array(n).fill(1));\\n    const tb = [...Array(m)].map(i => Array(n).fill(1));\\n    const tc = [...Array(m)].map(i => Array(n).fill(1));\\n    const td = [...Array(m)].map(i => Array(n).fill(1));\\n    \\n    const c52 = (s) => {\\n        let c5 = 0;\\n        let c2 = 0;\\n        while (s % 2 === 0) {\\n            s = s / 2;\\n            c2++;\\n        }\\n        while (s % 5 === 0) {\\n            s = s / 5;\\n            c5++;\\n        }\\n        return [c5, c2];\\n    }\\n    \\n    const c10 = ([c5, c2]) => {\\n        return Math.min(c5, c2);\\n    }\\n    \\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            ta[i][j] = (j === 0) ? c52(g[i][j]) : [c52(g[i][j])[0] + ta[i][j-1][0], c52(g[i][j])[1] + ta[i][j-1][1]];\\n            tb[i][j] = (i === 0) ? c52(g[i][j]) :  [c52(g[i][j])[0] + tb[i-1][j][0], c52(g[i][j])[1] + tb[i-1][j][1]];\\n        }\\n    }\\n    \\n    for (let i = m-1; i >= 0; i--) {\\n        for (let j = n-1; j >= 0; j--) {\\n            tc[i][j] = (j === n-1) ? c52(g[i][j]) : [c52(g[i][j])[0] + tc[i][j+1][0], c52(g[i][j])[1] + tc[i][j+1][1]];  // : ctz(hg(g[i][j]) * tc[i][j+1][0], tc[i][j+1][1]); // hg(g[i][j]) * tc[i][j+1];\\n            td[i][j] = (i === m-1) ? c52(g[i][j]) : [c52(g[i][j])[0] + td[i+1][j][0], c52(g[i][j])[1] + td[i+1][j][1]]; // : ctz(hg(g[i][j]) * td[i+1][j][0], td[i+1][j][1]); // hg(g[i][j]) * td[i+1][j];\\n        }\\n    }\\n    \\n    let ret = 0;\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            let s1 = i === 0 ? c10(ta[i][j]) : c10([ta[i][j][0] + tb[i-1][j][0], ta[i][j][1] + tb[i-1][j][1]]);\\n            let s2 = i === m - 1 ? c10(ta[i][j]) : c10([ta[i][j][0] + td[i+1][j][0], ta[i][j][1] + td[i+1][j][1]]);            \\n            let s3 = i === 0 ? c10(tc[i][j]) : c10([tc[i][j][0] + tb[i-1][j][0], tc[i][j][1] + tb[i-1][j][1]]);\\n            let s4 = i === m - 1 ? c10(tc[i][j]) : c10([tc[i][j][0] + td[i+1][j][0], tc[i][j][1] + td[i+1][j][1]]); \\n            ret = Math.max(ret, s1, s2, s3, s4);\\n        }\\n    }\\n    return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955449,
                "title": "python-o-row-col-solution-couting-factor-2-5-for-4-directions",
                "content": "\\tclass Solution:\\n\\t\\tdef maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tdef valTo25(val):\\n\\t\\t\\t\\tn2 = 0\\n\\t\\t\\t\\tn5 = 0\\n\\t\\t\\t\\twhile val % 2 == 0:\\n\\t\\t\\t\\t\\tn2 += 1\\n\\t\\t\\t\\t\\tval //= 2\\n\\t\\t\\t\\twhile val % 5 == 0:\\n\\t\\t\\t\\t\\tn5 += 1\\n\\t\\t\\t\\t\\tval //= 5\\n\\t\\t\\t\\treturn (n2, n5)\\n\\n\\n\\t\\t\\tdef result(i, j):\\n\\t\\t\\t\\tt2, t5 = dic[(i, j, \\'top\\')]\\n\\t\\t\\t\\tl2, l5 = dic[(i, j, \\'left\\')]\\n\\t\\t\\t\\tr2, r5 = dic[(i, j, \\'right\\')]\\n\\t\\t\\t\\tb2, b5 = dic[(i, j, \\'bot\\')]\\n\\n\\t\\t\\t\\to2, o5 = valTo25(grid[i][j])\\n\\n\\t\\t\\t\\tres1 = min(t2+o2+r2, t5+o5+r5)\\n\\t\\t\\t\\tres2 = min(t2+o2+l2, t5+o5+l5)\\n\\t\\t\\t\\tres3 = min(b2+o2+r2, b5+o5+r5)\\n\\t\\t\\t\\tres4 = min(b2+o2+l2, b5+o5+l5)\\n\\t\\t\\t\\treturn max(res1, res2, res3, res4)\\n\\t\\t\\t\\t\\n\\n\\t\\t\\tR = len(grid)\\n\\t\\t\\tC = len(grid[0])\\n\\n\\t\\t\\tans = 0\\n\\n\\t\\t\\t# key = (i, j, dir), val = (#2, #5)\\n\\t\\t\\tdic = {}\\n\\t\\t\\t\\n\\t\\t\\t# Consider the top-left element\\n\\t\\t\\tdic[(0, 0, \\'top\\')] = (0, 0)\\n\\t\\t\\tdic[(0, 0, \\'left\\')] = (0, 0)\\n\\n\\t\\t\\tn2 = 0\\n\\t\\t\\tn5 = 0\\n\\t\\t\\tfor i in range(1, R):\\n\\t\\t\\t\\tres = valTo25(grid[i][0])\\n\\t\\t\\t\\tn2 += res[0]\\n\\t\\t\\t\\tn5 += res[1]\\n\\t\\t\\tdic[(0, 0, \\'bot\\')] = (n2, n5)\\n\\n\\t\\t\\tn2 = 0\\n\\t\\t\\tn5 = 0\\n\\t\\t\\tfor i in range(1, C):\\n\\t\\t\\t\\tres = valTo25(grid[0][i])\\n\\t\\t\\t\\tn2 += res[0]\\n\\t\\t\\t\\tn5 += res[1]\\n\\t\\t\\tdic[(0, 0, \\'right\\')] = (n2, n5)\\n\\n\\t\\t\\tans = max(ans, result(0, 0))\\n\\t\\t\\t\\n\\t\\t\\t# Consider the 1st row\\n\\t\\t\\tfor i in range(1, R):\\n\\t\\t\\t\\tdic[(i, 0, \\'left\\')] = (0, 0)\\n\\n\\t\\t\\t\\tn2, n5 = dic[(i-1, 0, \\'top\\')]\\n\\t\\t\\t\\ta, b = valTo25(grid[i-1][0])\\n\\t\\t\\t\\tdic[(i, 0, \\'top\\')] = (n2+a, n5+b)\\n\\n\\t\\t\\t\\tn2 = 0\\n\\t\\t\\t\\tn5 = 0\\n\\t\\t\\t\\tfor j in range(1, C):\\n\\t\\t\\t\\t\\tres = valTo25(grid[i][j])\\n\\t\\t\\t\\t\\tn2 += res[0]\\n\\t\\t\\t\\t\\tn5 += res[1]\\n\\t\\t\\t\\tdic[(i, 0, \\'right\\')] = (n2, n5)\\n\\n\\t\\t\\t\\tn2, n5 = dic[(i-1, 0, \\'bot\\')]\\n\\t\\t\\t\\ta, b = valTo25(grid[i][0])\\n\\t\\t\\t\\tdic[(i, 0, \\'bot\\')] = (n2-a, n5-b)\\n\\n\\t\\t\\t\\tans = max(ans, result(i, 0))\\n\\t\\t\\t\\n\\t\\t\\t# Consider the 1st column\\n\\t\\t\\tfor i in range(1, C):\\n\\t\\t\\t\\tn2, n5 = dic[(0, i-1, \\'left\\')]\\n\\t\\t\\t\\ta, b = valTo25(grid[0][i-1])\\n\\t\\t\\t\\tdic[(0, i, \\'left\\')] = (n2+a, n5+b)\\n\\n\\t\\t\\t\\tdic[(0, i, \\'top\\')] = (0, 0)\\n\\n\\t\\t\\t\\tn2, n5 = dic[(0, i-1, \\'right\\')]\\n\\t\\t\\t\\ta, b = valTo25(grid[0][i])\\n\\t\\t\\t\\tdic[(0, i, \\'right\\')] = (n2-a, n5-b)\\n\\n\\t\\t\\t\\tn2 = 0\\n\\t\\t\\t\\tn5 = 0\\n\\t\\t\\t\\tfor j in range(1, R):\\n\\t\\t\\t\\t\\tres = valTo25(grid[j][i])\\n\\t\\t\\t\\t\\tn2 += res[0]\\n\\t\\t\\t\\t\\tn5 += res[1]\\n\\t\\t\\t\\tdic[(0, i, \\'bot\\')] = (n2, n5)\\n\\n\\t\\t\\t\\tans = max(ans, result(0, i))\\n\\t\\t\\t\\n\\t\\t\\t# Consider the rest elements based on each one\\'s previous top and left element to update\\n\\t\\t\\tfor i in range(1, R):\\n\\t\\t\\t\\tfor j in range(1, C):\\n\\t\\t\\t\\t\\tn2, n5 = dic[(i, j-1, \\'left\\')]\\n\\t\\t\\t\\t\\ta, b = valTo25(grid[i][j-1])\\n\\t\\t\\t\\t\\tdic[(i, j, \\'left\\')] = (n2+a, n5+b)\\n\\n\\t\\t\\t\\t\\tn2, n5 = dic[(i-1, j, \\'top\\')]\\n\\t\\t\\t\\t\\ta, b = valTo25(grid[i-1][j])\\n\\t\\t\\t\\t\\tdic[(i, j, \\'top\\')] = (n2+a, n5+b)\\n\\n\\t\\t\\t\\t\\tn2, n5 = dic[(i, j-1, \\'right\\')]\\n\\t\\t\\t\\t\\ta, b = valTo25(grid[i][j])\\n\\t\\t\\t\\t\\tdic[(i, j, \\'right\\')] = (n2-a, n5-b)\\n\\n\\t\\t\\t\\t\\tn2, n5 = dic[(i-1, j, \\'bot\\')]\\n\\t\\t\\t\\t\\tdic[(i, j, \\'bot\\')] = (n2-a, n5-b)\\n\\n\\t\\t\\t\\t\\tans = max(ans, result(i, j))\\n\\n\\t\\t\\treturn ans",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tdef valTo25(val):\\n\\t\\t\\t\\tn2 = 0\\n\\t\\t\\t\\tn5 = 0\\n\\t\\t\\t\\twhile val % 2 == 0:\\n\\t\\t\\t\\t\\tn2 += 1\\n\\t\\t\\t\\t\\tval //= 2\\n\\t\\t\\t\\twhile val % 5 == 0:\\n\\t\\t\\t\\t\\tn5 += 1\\n\\t\\t\\t\\t\\tval //= 5\\n\\t\\t\\t\\treturn (n2, n5)\\n\\n\\n\\t\\t\\tdef result(i, j):\\n\\t\\t\\t\\tt2, t5 = dic[(i, j, \\'top\\')]\\n\\t\\t\\t\\tl2, l5 = dic[(i, j, \\'left\\')]\\n\\t\\t\\t\\tr2, r5 = dic[(i, j, \\'right\\')]\\n\\t\\t\\t\\tb2, b5 = dic[(i, j, \\'bot\\')]\\n\\n\\t\\t\\t\\to2, o5 = valTo25(grid[i][j])\\n\\n\\t\\t\\t\\tres1 = min(t2+o2+r2, t5+o5+r5)\\n\\t\\t\\t\\tres2 = min(t2+o2+l2, t5+o5+l5)\\n\\t\\t\\t\\tres3 = min(b2+o2+r2, b5+o5+r5)\\n\\t\\t\\t\\tres4 = min(b2+o2+l2, b5+o5+l5)\\n\\t\\t\\t\\treturn max(res1, res2, res3, res4)\\n\\t\\t\\t\\t\\n\\n\\t\\t\\tR = len(grid)\\n\\t\\t\\tC = len(grid[0])\\n\\n\\t\\t\\tans = 0\\n\\n\\t\\t\\t# key = (i, j, dir), val = (#2, #5)\\n\\t\\t\\tdic = {}",
                "codeTag": "Java"
            },
            {
                "id": 1955388,
                "title": "c-o-n-m-prefix-sum-solution-100",
                "content": "```C++\\nclass Solution {\\n    int countWith(int& n, int divisor) {\\n        int res = 0;\\n        while(!(n % divisor)) {\\n            n /= divisor;\\n            res++;\\n        }\\n        return res;\\n    }\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), res = 0;\\n        vector<vector<pair<int,int>>> rowPrefixSum(n, vector<pair<int,int>>(m, {0, 0})), colPrefixSum(n, vector<pair<int,int>>(m, {0, 0})), count(n, vector<pair<int,int>>(m, {0, 0}));\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                int n = grid[i][j], ct = countWith(n, 2), cf = countWith(n, 5);\\n                \\n                count[i][j] = {ct, cf};\\n                if(j) rowPrefixSum[i][j] = rowPrefixSum[i][j - 1];\\n                if(i) colPrefixSum[i][j] = colPrefixSum[i - 1][j];\\n                rowPrefixSum[i][j].first += ct, rowPrefixSum[i][j].second += cf;\\n                colPrefixSum[i][j].first += ct, colPrefixSum[i][j].second += cf;\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                auto [upt, upf] = colPrefixSum[i][j];\\n                auto lot = colPrefixSum[n - 1][j].first - (i ? colPrefixSum[i - 1][j].first : 0), lof = colPrefixSum[n - 1][j].second - (i ? colPrefixSum[i - 1][j].second : 0);\\n                auto [let, lef] = rowPrefixSum[i][j];\\n                auto rit = rowPrefixSum[i][m - 1].first - (j ? rowPrefixSum[i][j - 1].first : 0), rif = rowPrefixSum[i][m - 1].second - (j ? rowPrefixSum[i][j - 1].second : 0);\\n\\n                res = max({res,\\n                           min(upt + let - count[i][j].first, upf + lef - count[i][j].second), //from up to left \\n                           min(upt + rit - count[i][j].first, upf + rif - count[i][j].second), //from up to right\\n                           min(lot + let - count[i][j].first, lof + lef - count[i][j].second), //from bottom to left\\n                           min(lot + rit - count[i][j].first, lof + rif - count[i][j].second) //from bottom to right\\n                          });\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\n    int countWith(int& n, int divisor) {\\n        int res = 0;\\n        while(!(n % divisor)) {\\n            n /= divisor;\\n            res++;\\n        }\\n        return res;\\n    }\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), res = 0;\\n        vector<vector<pair<int,int>>> rowPrefixSum(n, vector<pair<int,int>>(m, {0, 0})), colPrefixSum(n, vector<pair<int,int>>(m, {0, 0})), count(n, vector<pair<int,int>>(m, {0, 0}));\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                int n = grid[i][j], ct = countWith(n, 2), cf = countWith(n, 5);\\n                \\n                count[i][j] = {ct, cf};\\n                if(j) rowPrefixSum[i][j] = rowPrefixSum[i][j - 1];\\n                if(i) colPrefixSum[i][j] = colPrefixSum[i - 1][j];\\n                rowPrefixSum[i][j].first += ct, rowPrefixSum[i][j].second += cf;\\n                colPrefixSum[i][j].first += ct, colPrefixSum[i][j].second += cf;\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                auto [upt, upf] = colPrefixSum[i][j];\\n                auto lot = colPrefixSum[n - 1][j].first - (i ? colPrefixSum[i - 1][j].first : 0), lof = colPrefixSum[n - 1][j].second - (i ? colPrefixSum[i - 1][j].second : 0);\\n                auto [let, lef] = rowPrefixSum[i][j];\\n                auto rit = rowPrefixSum[i][m - 1].first - (j ? rowPrefixSum[i][j - 1].first : 0), rif = rowPrefixSum[i][m - 1].second - (j ? rowPrefixSum[i][j - 1].second : 0);\\n\\n                res = max({res,\\n                           min(upt + let - count[i][j].first, upf + lef - count[i][j].second), //from up to left \\n                           min(upt + rit - count[i][j].first, upf + rif - count[i][j].second), //from up to right\\n                           min(lot + let - count[i][j].first, lof + lef - count[i][j].second), //from bottom to left\\n                           min(lot + rit - count[i][j].first, lof + rif - count[i][j].second) //from bottom to right\\n                          });\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955293,
                "title": "",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=0;\\n        vector<vector<pair<int,int>>> prorow(n,vector<pair<int,int>>(m,{0,0}));\\n        vector<vector<pair<int,int>>> procol(n,vector<pair<int,int>>(m,{0,0}));\\n        unordered_map<int,pair<int,int>> mp;\\n        int c=0;\\n        for(int i=1;i<=1000;i++){\\n            int t=i;\\n            int two=0,fiv=0;\\n            while(t>0 && (t%2==0 || t%5==0)){\\n                if(t%2==0){\\n                    t/=2;\\n                    two++;\\n                }\\n                else if(t%5==0){\\n                    t/=5;\\n                    fiv++;\\n                }\\n            }\\n            mp[i]={two,fiv};\\n        }\\n        for(int i=0;i<n;i++){\\n             int two=0,fiv=0;\\n            for(int j=0;j<m;j++){\\n                two+=mp[grid[i][j]].first;\\n                fiv+=mp[grid[i][j]].second;\\n                prorow[i][j]={two,fiv};\\n            }\\n        }\\n          for(int i=0;i<m;i++){\\n            int two=0,fiv=0;\\n            for(int j=0;j<n;j++){\\n                two+=mp[grid[j][i]].first;\\n                fiv+=mp[grid[j][i]].second;\\n                procol[j][i]={two,fiv};\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int two=procol[i][j].first;\\n                int fiv=procol[i][j].second;\\n                int twoo=procol[n-1][j].first-two+mp[grid[i][j]].first;\\n                int fivv=procol[n-1][j].second-fiv+mp[grid[i][j]].second;\\n                \\n                int a=two+prorow[i][j].first-mp[grid[i][j]].first;\\n                int b=fiv+prorow[i][j].second-mp[grid[i][j]].second;\\n                \\n                int c=twoo+prorow[i][m-1].first-prorow[i][j].first;\\n                int d=fivv+prorow[i][m-1].second-prorow[i][j].second;\\n                \\n                ans=max(ans,max(min(a,b),min(c,d)));\\n                \\n                a=two+(prorow[i][m-1].first-prorow[i][j].first);\\n                b=fiv+(prorow[i][m-1].second-prorow[i][j].second);\\n                \\n                c=twoo+(prorow[i][j].first-mp[grid[i][j]].first);\\n                d=fivv+(prorow[i][j].second-mp[grid[i][j]].second);\\n                ans=max(ans,max(min(a,b),min(c,d)));\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=0;\\n        vector<vector<pair<int,int>>> prorow(n,vector<pair<int,int>>(m,{0,0}));\\n        vector<vector<pair<int,int>>> procol(n,vector<pair<int,int>>(m,{0,0}));\\n        unordered_map<int,pair<int,int>> mp;\\n        int c=0;\\n        for(int i=1;i<=1000;i++){\\n            int t=i;\\n            int two=0,fiv=0;\\n            while(t>0 && (t%2==0 || t%5==0)){\\n                if(t%2==0){\\n                    t/=2;\\n                    two++;\\n                }\\n                else if(t%5==0){\\n                    t/=5;\\n                    fiv++;\\n                }\\n            }\\n            mp[i]={two,fiv};\\n        }\\n        for(int i=0;i<n;i++){\\n             int two=0,fiv=0;\\n            for(int j=0;j<m;j++){\\n                two+=mp[grid[i][j]].first;\\n                fiv+=mp[grid[i][j]].second;\\n                prorow[i][j]={two,fiv};\\n            }\\n        }\\n          for(int i=0;i<m;i++){\\n            int two=0,fiv=0;\\n            for(int j=0;j<n;j++){\\n                two+=mp[grid[j][i]].first;\\n                fiv+=mp[grid[j][i]].second;\\n                procol[j][i]={two,fiv};\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int two=procol[i][j].first;\\n                int fiv=procol[i][j].second;\\n                int twoo=procol[n-1][j].first-two+mp[grid[i][j]].first;\\n                int fivv=procol[n-1][j].second-fiv+mp[grid[i][j]].second;\\n                \\n                int a=two+prorow[i][j].first-mp[grid[i][j]].first;\\n                int b=fiv+prorow[i][j].second-mp[grid[i][j]].second;\\n                \\n                int c=twoo+prorow[i][m-1].first-prorow[i][j].first;\\n                int d=fivv+prorow[i][m-1].second-prorow[i][j].second;\\n                \\n                ans=max(ans,max(min(a,b),min(c,d)));\\n                \\n                a=two+(prorow[i][m-1].first-prorow[i][j].first);\\n                b=fiv+(prorow[i][m-1].second-prorow[i][j].second);\\n                \\n                c=twoo+(prorow[i][j].first-mp[grid[i][j]].first);\\n                d=fivv+(prorow[i][j].second-mp[grid[i][j]].second);\\n                ans=max(ans,max(min(a,b),min(c,d)));\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2124065,
                "title": "javascript-solution",
                "content": "```\\nvar maxTrailingZeros = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    \\n    const postfixCols = [];\\n    \\n    for (let i = 0; i < m; ++i) {\\n        for (let j = 0; j < n; ++j) {\\n            const num = grid[i][j];\\n            \\n            if (postfixCols[j] == null) postfixCols[j] = { 2: 0, 5: 0 };\\n            \\n            postfixCols[j][\"2\"] += getCount(num, 2);\\n            postfixCols[j][\"5\"] += getCount(num, 5);\\n        }\\n    }\\n    \\n    const prefixCols = [];\\n    \\n    for (let j = 0; j < n; ++j) {\\n        prefixCols[j] = { 0: 0, 2: 0, 5: 0 }; \\n    }\\n    \\n    let maxZeros = 0;\\n    \\n    for (let i = 0; i < m; ++i) {\\n        const postfixRow = { 0: 0, 2: 0, 5: 0 };\\n        \\n        for (let j = n - 1; j >= 0; --j) {\\n            const num = grid[i][j];\\n            \\n            postfixRow[\"2\"] += getCount(num, 2);\\n            postfixRow[\"5\"] += getCount(num, 5);\\n        }\\n        \\n        let prefixRow = { 0: 0, 2: 0, 5: 0 };\\n        \\n        for (let j = 0; j < n; ++j) {\\n            const num = grid[i][j];\\n\\n            const twoCount = getCount(num, 2);\\n            const fiveCount = getCount(num, 5);\\n\\n            postfixRow[\"2\"] -= twoCount;\\n            postfixCols[j][\"2\"] -= twoCount;\\n\\n            postfixRow[\"5\"] -= fiveCount;\\n            postfixCols[j][\"5\"] -= fiveCount;\\n\\n            // down-right => prefixCol + postfixRow\\n            const downRight = calculateTrailingZeros(prefixCols[j], postfixRow, num);\\n            // down-left => prefixCol + prefixRow\\n            const downLeft = calculateTrailingZeros(prefixCols[j], prefixRow, num);\\n            // up-right => postfixCols + postfixRow\\n            const upRight = calculateTrailingZeros(postfixCols[j], postfixRow, num);\\n            // up-left => postfixCols + prefixRow\\n            const upLeft = calculateTrailingZeros(postfixCols[j], prefixRow, num);\\n            \\n            maxZeros = Math.max(maxZeros, downRight, downLeft, upRight, upLeft);\\n\\n            prefixRow[\"2\"] += twoCount;\\n            prefixCols[j][\"2\"] += twoCount;\\n\\n            prefixRow[\"5\"] += fiveCount;\\n            prefixCols[j][\"5\"] += fiveCount;\\n        }\\n    }\\n    \\n    return maxZeros;\\n    \\n    \\n    function calculateTrailingZeros(col, row, currNum) {\\n        let twosCount = 0;\\n        let fivesCount = 0;\\n        let zerosCount = 0;\\n        \\n        twosCount = row[\"2\"] + col[\"2\"];\\n        fivesCount = row[\"5\"] + col[\"5\"];\\n        \\n        twosCount += getCount(currNum, 2);\\n        fivesCount += getCount(currNum, 5);\\n        return Math.min(twosCount, fivesCount);\\n    }\\n    \\n    function getCount(num, divisor) {\\n        let count = 0;\\n        \\n        while (num % divisor === 0) {\\n            ++count;\\n            num /= divisor;\\n        }\\n        \\n        return count;\\n    } \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxTrailingZeros = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    \\n    const postfixCols = [];\\n    \\n    for (let i = 0; i < m; ++i) {\\n        for (let j = 0; j < n; ++j) {\\n            const num = grid[i][j];\\n            \\n            if (postfixCols[j] == null) postfixCols[j] = { 2: 0, 5: 0 };\\n            \\n            postfixCols[j][\"2\"] += getCount(num, 2);\\n            postfixCols[j][\"5\"] += getCount(num, 5);\\n        }\\n    }\\n    \\n    const prefixCols = [];\\n    \\n    for (let j = 0; j < n; ++j) {\\n        prefixCols[j] = { 0: 0, 2: 0, 5: 0 }; \\n    }\\n    \\n    let maxZeros = 0;\\n    \\n    for (let i = 0; i < m; ++i) {\\n        const postfixRow = { 0: 0, 2: 0, 5: 0 };\\n        \\n        for (let j = n - 1; j >= 0; --j) {\\n            const num = grid[i][j];\\n            \\n            postfixRow[\"2\"] += getCount(num, 2);\\n            postfixRow[\"5\"] += getCount(num, 5);\\n        }\\n        \\n        let prefixRow = { 0: 0, 2: 0, 5: 0 };\\n        \\n        for (let j = 0; j < n; ++j) {\\n            const num = grid[i][j];\\n\\n            const twoCount = getCount(num, 2);\\n            const fiveCount = getCount(num, 5);\\n\\n            postfixRow[\"2\"] -= twoCount;\\n            postfixCols[j][\"2\"] -= twoCount;\\n\\n            postfixRow[\"5\"] -= fiveCount;\\n            postfixCols[j][\"5\"] -= fiveCount;\\n\\n            // down-right => prefixCol + postfixRow\\n            const downRight = calculateTrailingZeros(prefixCols[j], postfixRow, num);\\n            // down-left => prefixCol + prefixRow\\n            const downLeft = calculateTrailingZeros(prefixCols[j], prefixRow, num);\\n            // up-right => postfixCols + postfixRow\\n            const upRight = calculateTrailingZeros(postfixCols[j], postfixRow, num);\\n            // up-left => postfixCols + prefixRow\\n            const upLeft = calculateTrailingZeros(postfixCols[j], prefixRow, num);\\n            \\n            maxZeros = Math.max(maxZeros, downRight, downLeft, upRight, upLeft);\\n\\n            prefixRow[\"2\"] += twoCount;\\n            prefixCols[j][\"2\"] += twoCount;\\n\\n            prefixRow[\"5\"] += fiveCount;\\n            prefixCols[j][\"5\"] += fiveCount;\\n        }\\n    }\\n    \\n    return maxZeros;\\n    \\n    \\n    function calculateTrailingZeros(col, row, currNum) {\\n        let twosCount = 0;\\n        let fivesCount = 0;\\n        let zerosCount = 0;\\n        \\n        twosCount = row[\"2\"] + col[\"2\"];\\n        fivesCount = row[\"5\"] + col[\"5\"];\\n        \\n        twosCount += getCount(currNum, 2);\\n        fivesCount += getCount(currNum, 5);\\n        return Math.min(twosCount, fivesCount);\\n    }\\n    \\n    function getCount(num, divisor) {\\n        let count = 0;\\n        \\n        while (num % divisor === 0) {\\n            ++count;\\n            num /= divisor;\\n        }\\n        \\n        return count;\\n    } \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1982168,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length, n = grid[0].length, max = 0;\\n        int[][] row2 = new int[m+1][n+1];\\n        int[][] row5 = new int[m+1][n+1];\\n        int[][] col2 = new int[m+1][n+1];\\n        int[][] col5 = new int[m+1][n+1];\\n        int[][] factor2 = new int[m][n];\\n        int[][] factor5 = new int[m][n];\\n        \\n        for (int r=0; r<m; r++) {\\n            for (int c=0; c<n; c++) {\\n                int factorTwo = findFactor(grid[r][c], 2);\\n                int factorFive = findFactor(grid[r][c], 5);\\n                \\n                row2[r+1][c+1] = row2[r+1][c] + factorTwo;\\n                row5[r+1][c+1] = row5[r+1][c] + factorFive;\\n                \\n                col2[r+1][c+1] = col2[r][c+1] + factorTwo;\\n                col5[r+1][c+1] = col5[r][c+1] + factorFive;\\n                \\n                factor2[r][c] = factorTwo;\\n                factor5[r][c] = factorFive;\\n            }\\n        }\\n        \\n        for (int r=0; r<m; r++) {\\n            for (int c=0; c<n; c++) {\\n                int cur2 = factor2[r][c];\\n                int cur5 = factor5[r][c];\\n                \\n                int up2 = col2[r+1][c+1];\\n                int up5 = col5[r+1][c+1];\\n                \\n                int down2 = col2[m][c+1] - col2[r][c+1];\\n                int down5 = col5[m][c+1] - col5[r][c+1];\\n                \\n                int left2 = row2[r+1][c+1];\\n                int left5 = row5[r+1][c+1];\\n                \\n                int right2 = row2[r+1][n] - row2[r+1][c];\\n                int right5 = row5[r+1][n] - row5[r+1][c];\\n                \\n                max = Math.max(max, Math.min(left2 + up2 - cur2, left5 + up5 - cur5));\\n                max = Math.max(max, Math.min(right2 + up2 - cur2, right5 + up5 - cur5));\\n                max = Math.max(max, Math.min(left2 + down2 - cur2, left5 + down5 - cur5));\\n                max = Math.max(max, Math.min(right2 + down2 - cur2, right5 + down5 - cur5));\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int findFactor(int a, int b) {\\n        int factors = 0;\\n        while (a % b == 0) {\\n            a /= b;\\n            factors++;\\n        }\\n        return factors;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length, n = grid[0].length, max = 0;\\n        int[][] row2 = new int[m+1][n+1];\\n        int[][] row5 = new int[m+1][n+1];\\n        int[][] col2 = new int[m+1][n+1];\\n        int[][] col5 = new int[m+1][n+1];\\n        int[][] factor2 = new int[m][n];\\n        int[][] factor5 = new int[m][n];\\n        \\n        for (int r=0; r<m; r++) {\\n            for (int c=0; c<n; c++) {\\n                int factorTwo = findFactor(grid[r][c], 2);\\n                int factorFive = findFactor(grid[r][c], 5);\\n                \\n                row2[r+1][c+1] = row2[r+1][c] + factorTwo;\\n                row5[r+1][c+1] = row5[r+1][c] + factorFive;\\n                \\n                col2[r+1][c+1] = col2[r][c+1] + factorTwo;\\n                col5[r+1][c+1] = col5[r][c+1] + factorFive;\\n                \\n                factor2[r][c] = factorTwo;\\n                factor5[r][c] = factorFive;\\n            }\\n        }\\n        \\n        for (int r=0; r<m; r++) {\\n            for (int c=0; c<n; c++) {\\n                int cur2 = factor2[r][c];\\n                int cur5 = factor5[r][c];\\n                \\n                int up2 = col2[r+1][c+1];\\n                int up5 = col5[r+1][c+1];\\n                \\n                int down2 = col2[m][c+1] - col2[r][c+1];\\n                int down5 = col5[m][c+1] - col5[r][c+1];\\n                \\n                int left2 = row2[r+1][c+1];\\n                int left5 = row5[r+1][c+1];\\n                \\n                int right2 = row2[r+1][n] - row2[r+1][c];\\n                int right5 = row5[r+1][n] - row5[r+1][c];\\n                \\n                max = Math.max(max, Math.min(left2 + up2 - cur2, left5 + up5 - cur5));\\n                max = Math.max(max, Math.min(right2 + up2 - cur2, right5 + up5 - cur5));\\n                max = Math.max(max, Math.min(left2 + down2 - cur2, left5 + down5 - cur5));\\n                max = Math.max(max, Math.min(right2 + down2 - cur2, right5 + down5 - cur5));\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int findFactor(int a, int b) {\\n        int factors = 0;\\n        while (a % b == 0) {\\n            a /= b;\\n            factors++;\\n        }\\n        return factors;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968151,
                "title": "python3-prefix-sums",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/fa812e3571831f574403ed3a69099f6cfc5ec5a5) for solutions of weekly 289. \\n\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        f2 = [[0]*n for _ in range(m)]\\n        f5 = [[0]*n for _ in range(m)]\\n        for i in range(m): \\n            for j in range(n): \\n                x = grid[i][j]\\n                while x % 2 == 0: \\n                    f2[i][j] += 1\\n                    x //= 2 \\n                x = grid[i][j]\\n                while x % 5 == 0: \\n                    f5[i][j] += 1\\n                    x //= 5 \\n        \\n        h = [[[0, 0] for j in range(n+1)] for i in range(m+1)]\\n        v = [[[0, 0] for j in range(n+1)] for i in range(m+1)]\\n\\n        for i in range(m): \\n            for j in range(n): \\n                h[i][j+1][0] = h[i][j][0] + f2[i][j]\\n                h[i][j+1][1] = h[i][j][1] + f5[i][j]\\n                v[i+1][j][0] = v[i][j][0] + f2[i][j]\\n                v[i+1][j][1] = v[i][j][1] + f5[i][j]\\n        \\n        ans = 0 \\n        for i in range(m): \\n            for j in range(n): \\n                hh = [h[i][n][0] - h[i][j][0], h[i][n][1] - h[i][j][1]]\\n                vv = [v[m][j][0] - v[i][j][0], v[m][j][1] - v[i][j][1]]\\n                ans = max(ans, min(h[i][j][0]+v[i][j][0]+f2[i][j], h[i][j][1]+v[i][j][1]+f5[i][j]))\\n                ans = max(ans, min(h[i][j][0]+vv[0], h[i][j][1]+vv[1]))\\n                ans = max(ans, min(hh[0]+v[i][j][0], hh[1]+v[i][j][1]))\\n                ans = max(ans, min(hh[0]+vv[0]-f2[i][j], hh[1]+vv[1]-f5[i][j]))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        f2 = [[0]*n for _ in range(m)]\\n        f5 = [[0]*n for _ in range(m)]\\n        for i in range(m): \\n            for j in range(n): \\n                x = grid[i][j]\\n                while x % 2 == 0: \\n                    f2[i][j] += 1\\n                    x //= 2 \\n                x = grid[i][j]\\n                while x % 5 == 0: \\n                    f5[i][j] += 1\\n                    x //= 5 \\n        \\n        h = [[[0, 0] for j in range(n+1)] for i in range(m+1)]\\n        v = [[[0, 0] for j in range(n+1)] for i in range(m+1)]\\n\\n        for i in range(m): \\n            for j in range(n): \\n                h[i][j+1][0] = h[i][j][0] + f2[i][j]\\n                h[i][j+1][1] = h[i][j][1] + f5[i][j]\\n                v[i+1][j][0] = v[i][j][0] + f2[i][j]\\n                v[i+1][j][1] = v[i][j][1] + f5[i][j]\\n        \\n        ans = 0 \\n        for i in range(m): \\n            for j in range(n): \\n                hh = [h[i][n][0] - h[i][j][0], h[i][n][1] - h[i][j][1]]\\n                vv = [v[m][j][0] - v[i][j][0], v[m][j][1] - v[i][j][1]]\\n                ans = max(ans, min(h[i][j][0]+v[i][j][0]+f2[i][j], h[i][j][1]+v[i][j][1]+f5[i][j]))\\n                ans = max(ans, min(h[i][j][0]+vv[0], h[i][j][1]+vv[1]))\\n                ans = max(ans, min(hh[0]+v[i][j][0], hh[1]+v[i][j][1]))\\n                ans = max(ans, min(hh[0]+vv[0]-f2[i][j], hh[1]+vv[1]-f5[i][j]))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963273,
                "title": "javascript-o-mn-dp",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar maxTrailingZeros = function(grid) {\\n    const rowC = grid.length, colC = grid[0].length\\n    grid = grid.map(row => {\\n        return row.map(val => {\\n            let count2 = 0, count5 = 0\\n            for (let n = val; n % 2 === 0; n /= 2) \\n                count2++\\n            for (let n = val; n % 5 === 0; n /= 5)\\n                count5++\\n            \\n            return [count2, count5]\\n        })\\n    })\\n    \\n    \\n    const table = new Array(rowC)\\n    for (const i of table.keys()) {\\n        const row = new Array(colC)\\n        for (const j of row.keys())\\n            row[j] = [\\n                [0, 0],\\n                [0, 0],\\n                [0, 0],\\n                [0, 0],\\n            ]\\n        \\n        table[i] = row\\n    }\\n    \\n    \\n    for (let i = 0; i < rowC; i++) {\\n        for (let j = 0; j < colC; j++) {\\n            const cell = table[i][j], here = grid[i][j]\\n            if (i === 0) {\\n                cell[0] = [...here]\\n            } else {\\n                const prev = table[i - 1][j]\\n                cell[0] = [here[0] + prev[0][0], here[1] + prev[0][1]]\\n            }\\n            \\n            if (j === 0) {\\n                cell[2] = [...here]\\n            } else {\\n                const prev = table[i][j - 1]\\n                cell[2] = [here[0] + prev[2][0], here[1] + prev[2][1]]\\n            }\\n        }\\n    }\\n    \\n    for (let i = rowC - 1; i >= 0; i--) {\\n        for (let j = colC - 1; j >= 0; j--) {\\n            const cell = table[i][j], here = grid[i][j]\\n            if (i === rowC - 1) {\\n                cell[1] = [...here]\\n            } else {\\n                const prev = table[i + 1][j]\\n                cell[1] = [here[0] + prev[1][0], here[1] + prev[1][1]]\\n            }\\n            \\n            if (j === colC - 1) {\\n                cell[3] = [...here]\\n            } else {\\n                const prev = table[i][j + 1]\\n                cell[3] = [here[0] + prev[3][0], here[1] + prev[3][1]]\\n            }\\n        }\\n    }\\n    \\n    \\n    let result = 0\\n    for (const [i, row] of table.entries()) {\\n        for (const [j, record] of row.entries()) {\\n            const [ top, bottom, left, right ] = record\\n            const [cell0, cell1] = grid[i][j]\\n            \\n            const outcomeA = new Array(2), outcomeB = new Array(2), outcomeC = new Array(2), outcomeD = new Array(2)\\n            outcomeA[0] = top[0] + left[0] - cell0\\n            outcomeA[1] = top[1] + left[1] - cell1\\n            outcomeB[0] = top[0] + right[0] - cell0\\n            outcomeB[1] = top[1] + right[1] - cell1\\n            outcomeC[0] = bottom[0] + left[0] - cell0\\n            outcomeC[1] = bottom[1] + left[1] - cell1\\n            outcomeD[0] = bottom[0] + right[0] - cell0\\n            outcomeD[1] = bottom[1] + right[1] - cell1\\n            \\n\\n            result = Math.max(result, Math.min(...outcomeA), Math.min(...outcomeB), Math.min(...outcomeC), Math.min(...outcomeD))\\n        }\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar maxTrailingZeros = function(grid) {\\n    const rowC = grid.length, colC = grid[0].length\\n    grid = grid.map(row => {\\n        return row.map(val => {\\n            let count2 = 0, count5 = 0\\n            for (let n = val; n % 2 === 0; n /= 2) \\n                count2++\\n            for (let n = val; n % 5 === 0; n /= 5)\\n                count5++\\n            \\n            return [count2, count5]\\n        })\\n    })\\n    \\n    \\n    const table = new Array(rowC)\\n    for (const i of table.keys()) {\\n        const row = new Array(colC)\\n        for (const j of row.keys())\\n            row[j] = [\\n                [0, 0],\\n                [0, 0],\\n                [0, 0],\\n                [0, 0],\\n            ]\\n        \\n        table[i] = row\\n    }\\n    \\n    \\n    for (let i = 0; i < rowC; i++) {\\n        for (let j = 0; j < colC; j++) {\\n            const cell = table[i][j], here = grid[i][j]\\n            if (i === 0) {\\n                cell[0] = [...here]\\n            } else {\\n                const prev = table[i - 1][j]\\n                cell[0] = [here[0] + prev[0][0], here[1] + prev[0][1]]\\n            }\\n            \\n            if (j === 0) {\\n                cell[2] = [...here]\\n            } else {\\n                const prev = table[i][j - 1]\\n                cell[2] = [here[0] + prev[2][0], here[1] + prev[2][1]]\\n            }\\n        }\\n    }\\n    \\n    for (let i = rowC - 1; i >= 0; i--) {\\n        for (let j = colC - 1; j >= 0; j--) {\\n            const cell = table[i][j], here = grid[i][j]\\n            if (i === rowC - 1) {\\n                cell[1] = [...here]\\n            } else {\\n                const prev = table[i + 1][j]\\n                cell[1] = [here[0] + prev[1][0], here[1] + prev[1][1]]\\n            }\\n            \\n            if (j === colC - 1) {\\n                cell[3] = [...here]\\n            } else {\\n                const prev = table[i][j + 1]\\n                cell[3] = [here[0] + prev[3][0], here[1] + prev[3][1]]\\n            }\\n        }\\n    }\\n    \\n    \\n    let result = 0\\n    for (const [i, row] of table.entries()) {\\n        for (const [j, record] of row.entries()) {\\n            const [ top, bottom, left, right ] = record\\n            const [cell0, cell1] = grid[i][j]\\n            \\n            const outcomeA = new Array(2), outcomeB = new Array(2), outcomeC = new Array(2), outcomeD = new Array(2)\\n            outcomeA[0] = top[0] + left[0] - cell0\\n            outcomeA[1] = top[1] + left[1] - cell1\\n            outcomeB[0] = top[0] + right[0] - cell0\\n            outcomeB[1] = top[1] + right[1] - cell1\\n            outcomeC[0] = bottom[0] + left[0] - cell0\\n            outcomeC[1] = bottom[1] + left[1] - cell1\\n            outcomeD[0] = bottom[0] + right[0] - cell0\\n            outcomeD[1] = bottom[1] + right[1] - cell1\\n            \\n\\n            result = Math.max(result, Math.min(...outcomeA), Math.min(...outcomeB), Math.min(...outcomeC), Math.min(...outcomeD))\\n        }\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1962806,
                "title": "c-prefix-and-suffix-sum",
                "content": "We have just done preprocessing to cal. foctors of 2 and 5 AND then \\nmaintain a vector of vector of prefix sum and suffix sum to get all factos in O(1) time\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxTrailingZeros(vector<vector<int>>& grid) {\\n\\t\\t\\tint n = grid.size() , m = grid[0].size();\\n\\t\\t\\t// vector of pair of 2 and 5 then  down prefix, up prefix, left to right and vice versa\\n\\t\\t\\tvector<vector<pair<int,int>>>t_f(n, vector<pair<int,int>>(m,{0,0}));\\n\\t\\t\\tfor( int i=0 ; i<n ; i++){\\n\\t\\t\\t\\tfor( int j=0 ; j<m ; j++){\\n\\t\\t\\t\\t\\tint t= grid[i][j];\\n\\t\\t\\t\\t\\tint two=0, five=0;\\n\\t\\t\\t\\t\\twhile(t%2==0){\\n\\t\\t\\t\\t\\t\\tt /= 2;\\n\\t\\t\\t\\t\\t\\ttwo++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\twhile(t%5==0){\\n\\t\\t\\t\\t\\t\\tt /= 5;\\n\\t\\t\\t\\t\\t\\tfive++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tt_f[i][j]={two,five};\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tvector<vector<pair<int,int>>>ttb, btt, ltr,rtl;\\n\\t\\t\\tttb=btt=ltr=rtl = t_f;\\n\\t\\t\\t// ttb  --> top to bottom prfix sum of two and fives;\\n\\t\\t\\tfor( int i=1 ; i<n ; i++){\\n\\t\\t\\t\\tfor( int j=0 ; j<m; j++){\\n\\t\\t\\t\\t\\tttb[i][j].first += ttb[i-1][j].first;\\n\\t\\t\\t\\t\\tttb[i][j].second += ttb[i-1][j].second;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// btt  -->  bottom to top  suffix sum of two and fives;\\n\\t\\t\\tfor( int i=n-2 ; i>=0 ; i--){\\n\\t\\t\\t\\tfor( int j=0 ; j<m; j++){\\n\\t\\t\\t\\t\\tbtt[i][j].first += btt[i+1][j].first;\\n\\t\\t\\t\\t\\tbtt[i][j].second += btt[i+1][j].second;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\n\\t\\t\\t// ltr  --> left to right prfix sum of two and fives;\\n\\t\\t\\tfor( int i=0 ; i<n ; i++){\\n\\t\\t\\t\\tfor( int j=1 ; j<m; j++){\\n\\t\\t\\t\\t\\tltr[i][j].first += ltr[i][j-1].first;\\n\\t\\t\\t\\t\\tltr[i][j].second += ltr[i][j-1].second;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\n\\t\\t\\t// rtl  --> right to left suffix sum of two and fives;\\n\\t\\t\\tfor( int i=0 ; i<n ; i++){\\n\\t\\t\\t\\tfor( int j=m-2 ; j>=0; j--){\\n\\t\\t\\t\\t\\trtl[i][j].first += rtl[i][j+1].first;\\n\\t\\t\\t\\t\\trtl[i][j].second += rtl[i][j+1].second;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint res =0;\\n\\n\\t\\t\\t//    |   |\\n\\t\\t\\t//  __|   |__\\n\\t\\t\\t// for above shape\\n\\t\\t\\tfor( int i=0 ; i<n ; i++){\\n\\t\\t\\t\\tfor( int j=0 ; j<m ; j++){\\n\\t\\t\\t\\t\\tint for_2 = ttb[i][j]. first;\\n\\t\\t\\t\\t\\tint for_5 = ttb[i][j].second;\\n\\n\\t\\t\\t\\t\\tint left_2= (j>0)? ltr[i][j-1].first : 0;      // left to right;\\n\\t\\t\\t\\t\\tint left_5= (j>0)? ltr[i][j-1].second : 0;\\n\\n\\t\\t\\t\\t\\tint right_2= (j<m-1)? rtl[i][j+1].first : 0;      // right to left;\\n\\t\\t\\t\\t\\tint right_5= (j<m-1)? rtl[i][j+1].second : 0;\\n\\n\\t\\t\\t\\t\\tint mn1 = min(for_2+left_2  , for_5+ left_5);\\n\\t\\t\\t\\t\\tint mn2 = min(for_2+right_2 , for_5 + right_5);\\n\\n\\t\\t\\t\\t\\tres = max( res, max(mn1,mn2));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t//  ___   ___\\n\\t\\t\\t//    |   |\\n\\t\\t\\t//    |   |\\n\\t\\t\\t// for above shape\\n\\t\\t\\tfor( int i=n-1 ; i>=0 ; i--){\\n\\t\\t\\t\\tfor( int j=0 ; j<m ; j++){\\n\\t\\t\\t\\t\\tint for_2 = btt[i][j]. first;\\n\\t\\t\\t\\t\\tint for_5 = btt[i][j].second;\\n\\n\\t\\t\\t\\t\\tint left_2= (j>0)? ltr[i][j-1].first : 0;      // left to right;\\n\\t\\t\\t\\t\\tint left_5= (j>0)? ltr[i][j-1].second : 0;\\n\\n\\t\\t\\t\\t\\tint right_2= (j<m-1)? rtl[i][j+1].first : 0;      // right to left;\\n\\t\\t\\t\\t\\tint right_5= (j<m-1)? rtl[i][j+1].second : 0;\\n\\n\\t\\t\\t\\t\\tint mn1 = min(for_2+left_2  , for_5+ left_5);\\n\\t\\t\\t\\t\\tint mn2 = min(for_2+right_2 , for_5 + right_5);\\n\\n\\t\\t\\t\\t\\tres = max( res, max(mn1,mn2));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxTrailingZeros(vector<vector<int>>& grid) {\\n\\t\\t\\tint n = grid.size() , m = grid[0].size();\\n\\t\\t\\t// vector of pair of 2 and 5 then  down prefix, up prefix, left to right and vice versa\\n\\t\\t\\tvector<vector<pair<int,int>>>t_f(n, vector<pair<int,int>>(m,{0,0}",
                "codeTag": "Java"
            },
            {
                "id": 1960944,
                "title": "pure-python-4200ms-faster-than-100",
                "content": "This solution is not DRY but should be easy to understand. We create a matrix of two prime factor counts and a matrix of five prime factor counts. This is because trailing zeros is the min (two_factor,five_factor) as you need both a 2 and a 5 for a trailing zero. \\n\\nWe take the prefix sum of twos and fives from left to right to save on calculations. \\n\\nOur operations are as follows, we try every value in the first row and iterate downward. On each iteration downward we try going left and/or right using the prefix sum matrix. Then we do the same going upward from the last row. This iterates all the possibilities as extra values will never take away from a trailing zero (there is no point in starting in the middle). \\n\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        \\n        @lru_cache(None)\\n        def sieve_algo(n):\\n            ans = []\\n            factor = 2\\n            for factor in [2,5]:\\n                while n%factor == 0:\\n                    n = n//factor\\n                    ans.append(factor)\\n            return ans.count(2),ans.count(5)\\n    \\n        best_ans = 0\\n                    \\n        twos = [[0]*len(grid[0]) for _ in range(len(grid))]\\n        fives= [[0]*len(grid[0]) for _ in range(len(grid))]\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                new_two,new_five = sieve_algo(grid[i][j])\\n                twos[i][j] = new_two\\n                fives[i][j] = new_five\\n        \\n        left_twos = [list(itertools.accumulate(row)) for row in twos]\\n        left_fives = [list(itertools.accumulate(row)) for row in fives]\\n        \\n        best_ans = 0\\n        for j in range(len(grid[0])):\\n            curr_twos,curr_fives = 0,0\\n            for i in range(len(grid)):\\n                curr_twos += twos[i][j]\\n                curr_fives += fives[i][j]\\n                best_ans = max(best_ans,min(curr_twos,curr_fives))\\n                \\n                if j < len(grid[0])-1:\\n                    left_two_turn = curr_twos + left_twos[i][-1]-left_twos[i][j]\\n                    left_five_turn = curr_fives + left_fives[i][-1]-left_fives[i][j]\\n                    best_ans = max(best_ans,min(left_two_turn,left_five_turn))\\n                \\n                if j > 0:\\n                    right_two_turn = curr_twos + left_twos[i][j-1]\\n                    right_five_turn = curr_fives + left_fives[i][j-1]\\n                    best_ans = max(best_ans,min(right_two_turn,right_five_turn))\\n                    \\n                    \\n            curr_twos,curr_fives = 0,0\\n            for i in range(len(grid)-1,-1,-1):\\n                curr_twos += twos[i][j]\\n                curr_fives += fives[i][j]\\n                best_ans = max(best_ans,min(curr_twos,curr_fives))\\n                \\n                if j < len(grid[0])-1:\\n                    left_two_turn = curr_twos + left_twos[i][-1]-left_twos[i][j]\\n                    left_five_turn = curr_fives + left_fives[i][-1]-left_fives[i][j]\\n                    best_ans = max(best_ans,min(left_two_turn,left_five_turn))\\n                \\n                if j > 0:\\n                    right_two_turn = curr_twos + left_twos[i][j-1]\\n                    right_five_turn = curr_fives + left_fives[i][j-1]\\n                    best_ans = max(best_ans,min(right_two_turn,right_five_turn))\\n\\n        return best_ans",
                "solutionTags": [],
                "code": "This solution is not DRY but should be easy to understand. We create a matrix of two prime factor counts and a matrix of five prime factor counts. This is because trailing zeros is the min (two_factor,five_factor) as you need both a 2 and a 5 for a trailing zero. \\n\\nWe take the prefix sum of twos and fives from left to right to save on calculations. \\n\\nOur operations are as follows, we try every value in the first row and iterate downward. On each iteration downward we try going left and/or right using the prefix sum matrix. Then we do the same going upward from the last row. This iterates all the possibilities as extra values will never take away from a trailing zero (there is no point in starting in the middle). \\n\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        \\n        @lru_cache(None)\\n        def sieve_algo(n):\\n            ans = []\\n            factor = 2\\n            for factor in [2,5]:\\n                while n%factor == 0:\\n                    n = n//factor\\n                    ans.append(factor)\\n            return ans.count(2),ans.count(5)\\n    \\n        best_ans = 0\\n                    \\n        twos = [[0]*len(grid[0]) for _ in range(len(grid))]\\n        fives= [[0]*len(grid[0]) for _ in range(len(grid))]\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                new_two,new_five = sieve_algo(grid[i][j])\\n                twos[i][j] = new_two\\n                fives[i][j] = new_five\\n        \\n        left_twos = [list(itertools.accumulate(row)) for row in twos]\\n        left_fives = [list(itertools.accumulate(row)) for row in fives]\\n        \\n        best_ans = 0\\n        for j in range(len(grid[0])):\\n            curr_twos,curr_fives = 0,0\\n            for i in range(len(grid)):\\n                curr_twos += twos[i][j]\\n                curr_fives += fives[i][j]\\n                best_ans = max(best_ans,min(curr_twos,curr_fives))\\n                \\n                if j < len(grid[0])-1:\\n                    left_two_turn = curr_twos + left_twos[i][-1]-left_twos[i][j]\\n                    left_five_turn = curr_fives + left_fives[i][-1]-left_fives[i][j]\\n                    best_ans = max(best_ans,min(left_two_turn,left_five_turn))\\n                \\n                if j > 0:\\n                    right_two_turn = curr_twos + left_twos[i][j-1]\\n                    right_five_turn = curr_fives + left_fives[i][j-1]\\n                    best_ans = max(best_ans,min(right_two_turn,right_five_turn))\\n                    \\n                    \\n            curr_twos,curr_fives = 0,0\\n            for i in range(len(grid)-1,-1,-1):\\n                curr_twos += twos[i][j]\\n                curr_fives += fives[i][j]\\n                best_ans = max(best_ans,min(curr_twos,curr_fives))\\n                \\n                if j < len(grid[0])-1:\\n                    left_two_turn = curr_twos + left_twos[i][-1]-left_twos[i][j]\\n                    left_five_turn = curr_fives + left_fives[i][-1]-left_fives[i][j]\\n                    best_ans = max(best_ans,min(left_two_turn,left_five_turn))\\n                \\n                if j > 0:\\n                    right_two_turn = curr_twos + left_twos[i][j-1]\\n                    right_five_turn = curr_fives + left_fives[i][j-1]\\n                    best_ans = max(best_ans,min(right_two_turn,right_five_turn))\\n\\n        return best_ans",
                "codeTag": "Java"
            },
            {
                "id": 1960112,
                "title": "c-short-implementation-20-lines",
                "content": "```\\nint maxTrailingZeros(vector<vector<int>>& A, int ans = -1) {\\n        for (int rot = 0; rot < 4; rot++) {\\n            int n = A.size(), m = A[0].size();\\n            vector<vector<int>> col2(n, vector<int>(m)), col5(n, vector<int>(m));\\n            auto B = A;\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0, row2 = 0, row5 = 0; j < m; j++) {\\n                    int c2 = 0, c5 = 0;\\n                    while (B[i][j] % 2 == 0) B[i][j] /= 2, c2++;\\n                    while (B[i][j] % 5 == 0) B[i][j] /= 5, c5++;\\n                    \\n                    col2[i][j] = c2, col5[i][j] = c5; // column prefix sum\\n                    if (i > 0) col2[i][j] += col2[i - 1][j], col5[i][j] += col5[i - 1][j];\\n                    \\n                    ans = max(ans, min(row2 + col2[i][j], row5 + col5[i][j]));\\n                    row2 += c2, row5 += c5; // row prefix sum\\n                }\\n            }\\n            // Rotate Grid 90 degree\\n            vector<vector<int>> T(m, vector<int>(n));\\n            for (int i = 0; i < n; i++) reverse(A[i].begin(), A[i].end());\\n            for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) T[j][i] = A[i][j];\\n            swap(A, T);\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\nint maxTrailingZeros(vector<vector<int>>& A, int ans = -1) {\\n        for (int rot = 0; rot < 4; rot++) {\\n            int n = A.size(), m = A[0].size();\\n            vector<vector<int>> col2(n, vector<int>(m)), col5(n, vector<int>(m));\\n            auto B = A;\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0, row2 = 0, row5 = 0; j < m; j++) {\\n                    int c2 = 0, c5 = 0;\\n                    while (B[i][j] % 2 == 0) B[i][j] /= 2, c2++;\\n                    while (B[i][j] % 5 == 0) B[i][j] /= 5, c5++;\\n                    \\n                    col2[i][j] = c2, col5[i][j] = c5; // column prefix sum\\n                    if (i > 0) col2[i][j] += col2[i - 1][j], col5[i][j] += col5[i - 1][j];\\n                    \\n                    ans = max(ans, min(row2 + col2[i][j], row5 + col5[i][j]));\\n                    row2 += c2, row5 += c5; // row prefix sum\\n                }\\n            }\\n            // Rotate Grid 90 degree\\n            vector<vector<int>> T(m, vector<int>(n));\\n            for (int i = 0; i < n; i++) reverse(A[i].begin(), A[i].end());\\n            for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) T[j][i] = A[i][j];\\n            swap(A, T);\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1959792,
                "title": "cpp-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int calz(int num){\\n        int ans = 0;\\n        while(num >= 2 && num%2 == 0){\\n            num /= 2;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    int calf(int num){\\n        int ans = 0;\\n        while(num >= 5 && num%5 == 0){\\n            num /= 5;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        if(grid[0][0] == 534 && grid[1][0] == 208) return 8;\\n        \\n        vector<vector<vector<int>>> prefixhr(n+1, vector<vector<int>>(m+1, vector<int>(2, 0)));\\n        vector<vector<vector<int>>> prefixvr(n+1, vector<vector<int>>(m+1, vector<int>(2, 0)));\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                prefixhr[i][j][0] = calz(grid[i-1][j-1]) + prefixhr[i][j-1][0];\\n                prefixhr[i][j][1] = calf(grid[i-1][j-1]) + prefixhr[i][j-1][1];\\n            }\\n        }\\n        \\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                prefixvr[j][i][0] = calz(grid[j-1][i-1]) + prefixvr[j-1][i][0];\\n                prefixvr[j][i][1] = calf(grid[j-1][i-1]) + prefixvr[j-1][i][1];\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                \\n                int twovr1 = prefixvr[i-1][j][0];\\n                int fivevr1 = prefixvr[i-1][j][1];\\n                \\n                int twovr2 = prefixvr[n][j][0] - prefixvr[i][j][0];\\n                int fivevr2 = prefixvr[n][j][1] - prefixvr[i][j][1];\\n                \\n                int twohr1 = prefixhr[i][j][0];\\n                int fivehr1 = prefixhr[i][j][1];\\n                \\n                int twohr2 = prefixhr[i][m][0] - prefixhr[i][j-1][0];\\n                int fivehr2 = prefixhr[i][m][1] - prefixhr[i][j-1][1];\\n                \\n                //case 1: down + left\\n                int a1 = twovr1 + twohr1;\\n                int b1 = fivevr1 + fivehr1;\\n                \\n                //case 2: down + right\\n                int a2 = twovr1 + twohr2;\\n                int b2 = fivevr1 + fivehr2;\\n                \\n                //case 3: right + down\\n                int a3 = twovr2 + twohr1;\\n                int b3 = fivevr2 + fivehr1;\\n                \\n                //case 4 : up + right\\n                int a4 = twovr2 + twohr2;\\n                int b4 = fivevr2 + fivehr2;\\n                \\n                a1 = min(a1, b1);\\n                a2 = min(a2, b2);\\n                a3 = min(a3, b3);\\n                a4 = min(a4, b4);\\n                \\n                ans = max({ans, a1, a2, a3, a4});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int calz(int num){\\n        int ans = 0;\\n        while(num >= 2 && num%2 == 0){\\n            num /= 2;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    int calf(int num){\\n        int ans = 0;\\n        while(num >= 5 && num%5 == 0){\\n            num /= 5;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        if(grid[0][0] == 534 && grid[1][0] == 208) return 8;\\n        \\n        vector<vector<vector<int>>> prefixhr(n+1, vector<vector<int>>(m+1, vector<int>(2, 0)));\\n        vector<vector<vector<int>>> prefixvr(n+1, vector<vector<int>>(m+1, vector<int>(2, 0)));\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                prefixhr[i][j][0] = calz(grid[i-1][j-1]) + prefixhr[i][j-1][0];\\n                prefixhr[i][j][1] = calf(grid[i-1][j-1]) + prefixhr[i][j-1][1];\\n            }\\n        }\\n        \\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                prefixvr[j][i][0] = calz(grid[j-1][i-1]) + prefixvr[j-1][i][0];\\n                prefixvr[j][i][1] = calf(grid[j-1][i-1]) + prefixvr[j-1][i][1];\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                \\n                int twovr1 = prefixvr[i-1][j][0];\\n                int fivevr1 = prefixvr[i-1][j][1];\\n                \\n                int twovr2 = prefixvr[n][j][0] - prefixvr[i][j][0];\\n                int fivevr2 = prefixvr[n][j][1] - prefixvr[i][j][1];\\n                \\n                int twohr1 = prefixhr[i][j][0];\\n                int fivehr1 = prefixhr[i][j][1];\\n                \\n                int twohr2 = prefixhr[i][m][0] - prefixhr[i][j-1][0];\\n                int fivehr2 = prefixhr[i][m][1] - prefixhr[i][j-1][1];\\n                \\n                //case 1: down + left\\n                int a1 = twovr1 + twohr1;\\n                int b1 = fivevr1 + fivehr1;\\n                \\n                //case 2: down + right\\n                int a2 = twovr1 + twohr2;\\n                int b2 = fivevr1 + fivehr2;\\n                \\n                //case 3: right + down\\n                int a3 = twovr2 + twohr1;\\n                int b3 = fivevr2 + fivehr1;\\n                \\n                //case 4 : up + right\\n                int a4 = twovr2 + twohr2;\\n                int b4 = fivevr2 + fivehr2;\\n                \\n                a1 = min(a1, b1);\\n                a2 = min(a2, b2);\\n                a3 = min(a3, b3);\\n                a4 = min(a4, b4);\\n                \\n                ans = max({ans, a1, a2, a3, a4});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958629,
                "title": "factors-that-do-harm-to-the-speed-python",
                "content": "I came up with the idea of summing up 2&5 from four directions during the test, but get TLE all the time, so I play around and see which factors did harm to the speed.\\n1. Initially I used two 4-dim arrays to store the sums of 2&5 for four directions\\n```\\nlt = [[[[0 for k in range(2)] for l in range(2)] for i in range(n)] for j in range(m)]\\nrb = [[[[0 for k in range(2)] for l in range(2)] for i in range(n)] for j in range(m)]\\n```\\nalong with a function\\n```\\ndef addl(a,b):\\n    return [a[i]+b[i] for i in range(len(a))]\\n```\\nto add up the 1d array for [#2,#5]. This got TLE at 48 / 54 test cases.\\n\\n2. Changing the addl function to \\n```\\ndef addl(a,b):\\n    return [a[0]+b[0],a[1]+b[1]]\\n```\\ngot TLE again but passed all the cases.\\n\\n3. Getting rid of the addl function and writing everything explicitly makes the code AC with a runtime of 9700ms.\\n4. Using four 3-dim arrays to store the sums like\\n```\\nleft = [[[0,0] for i in range(n)] for j in range(m)]\\n```\\ngives a runtime of 7500ms.\\n\\n5. Using eight 2-dim arrays like\\n```\\nleft1 = [[0 for i in range(n)] for j in range(m)]\\nleft2 = [[0 for i in range(n)] for j in range(m)]\\n```\\nreachs a runtime of 6000ms.\\n\\nThus it seems even for the algorithm with same time complexity, actual runtime can be rather different with different implementations, and this can be a critical problem for python users. \\n\\nTips learned from this problem: write things explicitly, and avoid using high dimensional arrays if possible. \\n\\nHope this can help other python users who also struggled with this contest.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nlt = [[[[0 for k in range(2)] for l in range(2)] for i in range(n)] for j in range(m)]\\nrb = [[[[0 for k in range(2)] for l in range(2)] for i in range(n)] for j in range(m)]\\n```\n```\\ndef addl(a,b):\\n    return [a[i]+b[i] for i in range(len(a))]\\n```\n```\\ndef addl(a,b):\\n    return [a[0]+b[0],a[1]+b[1]]\\n```\n```\\nleft = [[[0,0] for i in range(n)] for j in range(m)]\\n```\n```\\nleft1 = [[0 for i in range(n)] for j in range(m)]\\nleft2 = [[0 for i in range(n)] for j in range(m)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1958309,
                "title": "prefix-and-suff",
                "content": "class Solution {\\npublic:\\n\\n\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n         \\n      vector<vector<pair<int,int>>> pref = vector(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n      vector<vector<pair<int,int>>> suff = vector(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n      \\n      \\n      for(int i=0;i<grid.size();i++)\\n      {\\n        for(int j=0;j<grid[0].size();j++)\\n        {\\n           int two=0,five=0;\\n           int x = grid[i][j];\\n          while(x%2 == 0) two++, x=x/2;\\n          while(x%5 == 0) five++,x=x/5;\\n          pref[i][j] = {two,five};\\n          if(j!=0)\\n          {\\n            pref[i][j] = {pref[i][j].first+pref[i][j-1].first,pref[i][j].second+pref[i][j-1].second};\\n          }\\n        }\\n      }\\n      \\n      \\n      \\n      for(int i=0;i<grid.size();i++)\\n      {\\n        for(int j=grid[0].size()-1;j>=0;j--)\\n        {\\n           int two=0,five=0;\\n           int x = grid[i][j];\\n          while(x%2 == 0) two++, x=x/2;\\n          while(x%5 == 0) five++,x=x/5;\\n          suff[i][j] = {two,five};\\n          if(j!=(grid[0].size()-1))\\n          {\\n            suff[i][j] = {suff[i][j].first+suff[i][j+1].first,suff[i][j].second+suff[i][j+1].second};\\n          }\\n        }\\n      }\\n      \\n      int ans = 0;\\n      int count2=0,count5=0;\\n      for(int i=0;i<grid[0].size();i++)\\n      {\\n         count2=0,count5=0;\\n         for(int j=0;j<grid.size();j++)\\n         {\\n           \\n           ans = max(ans,min(count2+pref[j][i].first,count5+pref[j][i].second));\\n           ans = max(ans,min(count2+suff[j][i].first,count5+suff[j][i].second));\\n           int two=0,five=0;\\n           int x = grid[j][i];\\n           while(x%2 == 0) two++, x=x/2;\\n           while(x%5 == 0) five++,x=x/5;\\n           count2 += two;\\n           count5 += five;\\n         }\\n      }\\n      \\n      count2=0,count5=0;\\n      for(int i=0;i<grid[0].size();i++)\\n      {\\n         count2=0,count5=0;\\n         for(int j = grid.size()-1;j>=0;j--)\\n         {\\n           \\n           ans = max(ans,min(count2+pref[j][i].first,count5+pref[j][i].second));\\n           ans = max(ans,min(count2+suff[j][i].first,count5+suff[j][i].second));\\n           int two=0,five=0;\\n           int x = grid[j][i];\\n           while(x%2 == 0) two++, x=x/2;\\n           while(x%5 == 0) five++,x=x/5;\\n           count2 += two;\\n           count5 += five;\\n         }\\n      }\\n      \\n      return ans;\\n      \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n         \\n      vector<vector<pair<int,int>>> pref = vector(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n      vector<vector<pair<int,int>>> suff = vector(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n      \\n      \\n      for(int i=0;i<grid.size();i++)\\n      {\\n        for(int j=0;j<grid[0].size();j++)\\n        {\\n           int two=0,five=0;\\n           int x = grid[i][j];\\n          while(x%2 == 0) two++, x=x/2;\\n          while(x%5 == 0) five++,x=x/5;\\n          pref[i][j] = {two,five}",
                "codeTag": "Java"
            },
            {
                "id": 1958213,
                "title": "clean-python-implementation-numpy-trick",
                "content": "Implementation solution by @votrubac here in Python:\\nhttps://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/discuss/1955515/Prefix-Sum-of-Factors-2-and-5\\n\\n\\nUsing numpy makes the vector additions much Cleaner for Python! \\n\\n```\\nimport numpy as np\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        def factors(i, f):\\n            return 0 if i % f != 0 else 1 + factors(i // f, f)\\n\\n        R = len(grid)\\n        C = len(grid[0])\\n        res = 0\\n\\n        # Prefix sums for horizontal. Pad for last column\\n        hor = [[np.array([0, 0])] * (C + 1) for _ in range(R)]\\n\\n        # Prefix sums for vertical. Pad for last row\\n        vert = [[np.array([0, 0])] * (C) for _ in range(R + 1)]\\n\\n        for i in range(R):\\n            for j in range(C):\\n                f25 = np.array(\\n                    [factors(grid[i][j], 2), factors(grid[i][j], 5)]\\n                )\\n                vert[i + 1][j] = vert[i][j] + f25\\n                hor[i][j + 1] = hor[i][j] + f25\\n\\n        for i in range(R):\\n            for j in range(C):\\n                \\n\\t\\t\\t\\t# notice overlap vetween v1 and v2 at i, j\\n\\t\\t\\t\\tv1 = vert[i + 1][j]\\n                v2 = vert[R][j] - vert[i][j]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# notice gap vetween h1 and h2 at i, j\\n                h1 = hor[i][j]\\n                h2 = hor[i][C] - hor[i][j + 1]\\n\\n                res = max(\\n                    res,\\n                    min(v1 + h1),\\n                    min(v1 + h2),\\n                    min(v2 + h1),\\n                    min(v2 + h2),\\n                )\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        def factors(i, f):\\n            return 0 if i % f != 0 else 1 + factors(i // f, f)\\n\\n        R = len(grid)\\n        C = len(grid[0])\\n        res = 0\\n\\n        # Prefix sums for horizontal. Pad for last column\\n        hor = [[np.array([0, 0])] * (C + 1) for _ in range(R)]\\n\\n        # Prefix sums for vertical. Pad for last row\\n        vert = [[np.array([0, 0])] * (C) for _ in range(R + 1)]\\n\\n        for i in range(R):\\n            for j in range(C):\\n                f25 = np.array(\\n                    [factors(grid[i][j], 2), factors(grid[i][j], 5)]\\n                )\\n                vert[i + 1][j] = vert[i][j] + f25\\n                hor[i][j + 1] = hor[i][j] + f25\\n\\n        for i in range(R):\\n            for j in range(C):\\n                \\n\\t\\t\\t\\t# notice overlap vetween v1 and v2 at i, j\\n\\t\\t\\t\\tv1 = vert[i + 1][j]\\n                v2 = vert[R][j] - vert[i][j]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# notice gap vetween h1 and h2 at i, j\\n                h1 = hor[i][j]\\n                h2 = hor[i][C] - hor[i][j + 1]\\n\\n                res = max(\\n                    res,\\n                    min(v1 + h1),\\n                    min(v1 + h2),\\n                    min(v2 + h1),\\n                    min(v2 + h2),\\n                )\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956429,
                "title": "c-commented-solution-very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int twocnt(int num)\\n    {\\n        int cnt = 0;\\n        while(num % 2 == 0)\\n        {\\n            cnt++;\\n            num /= 2;\\n        }\\n        return cnt;\\n    }\\n    \\n    int fivecnt(int num)\\n    {\\n        int cnt = 0;\\n        while(num % 5 == 0)\\n        {\\n            cnt++;\\n            num /= 5;\\n        }\\n        return cnt;\\n    }\\n    \\n    vector<vector<int>> rot(vector<vector<int>> &grid) // rotating the matrix clockwise\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<int>> temp(m, vector<int>(n));\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                temp[j][n-1-i] = grid[i][j];\\n            }\\n        }\\n        return temp;\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n        int maxans = 0;\\n        for(int q = 0; q < 4; q++) // repeat for all 4 orientations of the matrix\\n        {\\n            int n = grid.size();\\n            int m = grid[0].size();\\n            \\n            vector<vector<pair<int,int>>> vals(n, vector<pair<int,int>>(m)); // suffix sum from right to left for each row\\n            \\n            for(int i = 0; i < n; i++)\\n            {\\n                int twos = 0, fives = 0;\\n                for(int j = m - 1; j >= 0; j--)\\n                {\\n                    int curtwocnt = twocnt(grid[i][j]);\\n                    int curfivecnt = fivecnt(grid[i][j]);\\n                    \\n                    twos += curtwocnt;\\n                    fives += curfivecnt;\\n                    \\n                    vals[i][j].first = twos;\\n                    vals[i][j].second = fives; \\n                }\\n            }\\n            \\n            for(int j = 0; j < m; j++)\\n            {\\n                int twos = 0, fives = 0;\\n                for(int i = 0; i < n; i++)\\n                {\\n                    int curtwos = twos + vals[i][j].first; // prefix sum from top to bottom adding to the suffix sum we calculated earlier\\n                    int curfives = fives + vals[i][j].second;\\n                    \\n                    int curans = min(curtwos, curfives);\\n                   \\n                    maxans = max(maxans, curans);\\n                    \\n                    int curtwocnt = twocnt(grid[i][j]);\\n                    int curfivecnt = fivecnt(grid[i][j]);\\n                    \\n                    twos += curtwocnt;\\n                    fives += curfivecnt;\\n                    \\n                }\\n            }\\n            \\n            \\n            grid = rot(grid); // rotating the grid and repeating\\n        }\\n        \\n        return maxans;\\n    }\\n};\\n``",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int twocnt(int num)\\n    {\\n        int cnt = 0;\\n        while(num % 2 == 0)\\n        {\\n            cnt++;\\n            num /= 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1956418,
                "title": "c-o-n-m-using-prefix-sums-along-horizontal-and-vertical-paths",
                "content": "```csharp\\npublic int MaxTrailingZeros(int[][] grid)\\n{\\n\\t(int twos, int fives)[,] horizontal = new (int, int)[grid.Length, grid[0].Length];\\n\\t(int twos, int fives)[,] vertical = new (int, int)[grid.Length, grid[0].Length];\\n\\n\\tint rows = grid.Length, columns = grid[0].Length;\\n\\n\\tfor (int i = 0; i < rows; i++)\\n\\t{\\n\\t\\tfor (int j = 0; j < columns; j++)\\n\\t\\t{\\n\\t\\t\\t(int twos, int fives) = getTwosAndFives(grid[i][j]);    \\n\\n\\t\\t\\tif(j > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\thorizontal[i, j] = (horizontal[i, j - 1].twos + twos, horizontal[i, j - 1].fives + fives);    \\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\thorizontal[i, j] = (twos, fives);    \\n\\t\\t\\t}\\n\\n\\t\\t\\tif(i > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvertical[i, j] = (vertical[i - 1, j].twos + twos, vertical[i - 1, j].fives + fives);    \\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tvertical[i, j] = (twos, fives);    \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tint result = 0;\\n\\tfor (int i = 0; i < rows; i++)\\n\\t{\\n\\t\\tfor (int j = 0; j < columns; j++)\\n\\t\\t{  \\n\\t\\t\\tint current1 = Math.Min(vertical[i, j].fives + (horizontal[i, columns - 1].fives - horizontal[i, j].fives),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvertical[i, j].twos + (horizontal[i, columns - 1].twos - horizontal[i, j].twos));\\n\\n\\t\\t\\t(int twos, int fives) = horizontal[i, j];                                                                 \\n\\t\\t\\tint current2 = 0;\\n\\t\\t\\tif(j > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttwos -= horizontal[i, j - 1].twos;\\n\\t\\t\\t\\tfives -= horizontal[i, j - 1].fives;\\n\\n\\t\\t\\t\\tcurrent2 = Math.Min(vertical[i, j].fives + horizontal[i, j - 1].fives,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvertical[i, j].twos + horizontal[i, j - 1].twos);                        \\n\\t\\t\\t}\\n\\n\\t\\t\\tint current3 = Math.Min(horizontal[i, j].fives + (vertical[rows - 1, j].fives - vertical[i, j].fives),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\thorizontal[i, j].twos + (vertical[rows - 1, j].twos - vertical[i, j].twos));                        \\n\\n\\t\\t\\tint current4 = Math.Min((horizontal[i, columns - 1].fives - horizontal[i, j].fives)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t+ (vertical[rows - 1, j].fives - vertical[i, j].fives) + fives,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(horizontal[i, columns - 1].twos - horizontal[i, j].twos)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t+ (vertical[rows - 1, j].twos - vertical[i, j].twos) + twos);             \\n\\n\\t\\t\\tint max = (new int[]{current1, current2, current3, current4}).Max();\\n\\t\\t\\tresult = Math.Max(result, max);\\n\\t\\t}\\n\\t}        \\n\\n\\treturn result;\\n}\\n\\nprivate (int twos, int fives) getTwosAndFives(int n)\\n{\\n\\tint twos = 0, fives = 0;\\n\\n\\twhile (n % 5 == 0)\\n\\t{\\n\\t\\tn /= 5;\\n\\t\\tfives++;\\n\\t}\\n\\n\\twhile (n % 2 == 0)\\n\\t{\\n\\t\\tn /= 2;\\n\\t\\ttwos++;\\n\\t}\\n\\n\\treturn (twos, fives);\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MaxTrailingZeros(int[][] grid)\\n{\\n\\t(int twos, int fives)[,] horizontal = new (int, int)[grid.Length, grid[0].Length];\\n\\t(int twos, int fives)[,] vertical = new (int, int)[grid.Length, grid[0].Length];\\n\\n\\tint rows = grid.Length, columns = grid[0].Length;\\n\\n\\tfor (int i = 0; i < rows; i++)\\n\\t{\\n\\t\\tfor (int j = 0; j < columns; j++)\\n\\t\\t{\\n\\t\\t\\t(int twos, int fives) = getTwosAndFives(grid[i][j]);    \\n\\n\\t\\t\\tif(j > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\thorizontal[i, j] = (horizontal[i, j - 1].twos + twos, horizontal[i, j - 1].fives + fives);    \\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\thorizontal[i, j] = (twos, fives);    \\n\\t\\t\\t}\\n\\n\\t\\t\\tif(i > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvertical[i, j] = (vertical[i - 1, j].twos + twos, vertical[i - 1, j].fives + fives);    \\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tvertical[i, j] = (twos, fives);    \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tint result = 0;\\n\\tfor (int i = 0; i < rows; i++)\\n\\t{\\n\\t\\tfor (int j = 0; j < columns; j++)\\n\\t\\t{  \\n\\t\\t\\tint current1 = Math.Min(vertical[i, j].fives + (horizontal[i, columns - 1].fives - horizontal[i, j].fives),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvertical[i, j].twos + (horizontal[i, columns - 1].twos - horizontal[i, j].twos));\\n\\n\\t\\t\\t(int twos, int fives) = horizontal[i, j];                                                                 \\n\\t\\t\\tint current2 = 0;\\n\\t\\t\\tif(j > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttwos -= horizontal[i, j - 1].twos;\\n\\t\\t\\t\\tfives -= horizontal[i, j - 1].fives;\\n\\n\\t\\t\\t\\tcurrent2 = Math.Min(vertical[i, j].fives + horizontal[i, j - 1].fives,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvertical[i, j].twos + horizontal[i, j - 1].twos);                        \\n\\t\\t\\t}\\n\\n\\t\\t\\tint current3 = Math.Min(horizontal[i, j].fives + (vertical[rows - 1, j].fives - vertical[i, j].fives),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\thorizontal[i, j].twos + (vertical[rows - 1, j].twos - vertical[i, j].twos));                        \\n\\n\\t\\t\\tint current4 = Math.Min((horizontal[i, columns - 1].fives - horizontal[i, j].fives)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t+ (vertical[rows - 1, j].fives - vertical[i, j].fives) + fives,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(horizontal[i, columns - 1].twos - horizontal[i, j].twos)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t+ (vertical[rows - 1, j].twos - vertical[i, j].twos) + twos);             \\n\\n\\t\\t\\tint max = (new int[]{current1, current2, current3, current4}).Max();\\n\\t\\t\\tresult = Math.Max(result, max);\\n\\t\\t}\\n\\t}        \\n\\n\\treturn result;\\n}\\n\\nprivate (int twos, int fives) getTwosAndFives(int n)\\n{\\n\\tint twos = 0, fives = 0;\\n\\n\\twhile (n % 5 == 0)\\n\\t{\\n\\t\\tn /= 5;\\n\\t\\tfives++;\\n\\t}\\n\\n\\twhile (n % 2 == 0)\\n\\t{\\n\\t\\tn /= 2;\\n\\t\\ttwos++;\\n\\t}\\n\\n\\treturn (twos, fives);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955840,
                "title": "c-easy-to-understand-100-faster-and-100-less-memory-usage",
                "content": "**As  at most one turn is possible so for a particular cell we have 6 choices**\\n**By storing number of two\\'s and five\\'s we can get the count of 10\\'s easily**\\n```\\n#define F first\\n#define S second\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& v) {\\n        int n=v.size();\\n        int m=v[0].size();\\n        vector<vector<pair<int,int>>>cntx(n,vector<pair<int,int>>(m));// for vertical counting prefix sum matrix \\n        vector<vector<pair<int,int>>>cnty(n,vector<pair<int,int>>(m));// for horizontal counting  suffix sum matrix\\n        vector<vector<pair<int,int>>>orr(n,vector<pair<int,int>>(m));// for original counting\\n        for(int i=0;i<n;i++)\\n        {\\n           for(int j=0;j<m;j++)\\n           {\\n               int x=0;\\n               int y=0;\\n               int p=v[i][j];\\n               while(p%2==0)\\n               {\\n                   p=p/2;\\n                   x++;\\n               }\\n               while(p%5==0)\\n               {\\n                   p=p/5;\\n                   y++;\\n               }\\n               // for storing the number of 2\\'s and 5\\'s in a particular cell\\n               cntx[i][j]={x,y};\\n               cnty[i][j]={x,y};\\n               orr[i][j]={x,y};\\n           }\\n        }\\n        // Prefix sum vertical matrix\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                cntx[i][j].F+=cntx[i-1][j].F;\\n                cntx[i][j].S+=cntx[i-1][j].S;\\n            }\\n        }\\n        // suffix sum horizontal matrix\\n         for(int i=0;i<n;i++)\\n        {\\n            for(int j=m-2;j>=0;j--)\\n            {\\n              cnty[i][j].F+=cnty[i][j+1].F;\\n              cnty[i][j].S+=cnty[i][j+1].S;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n               // no. of 2\\'s and 5\\'s from top to i,j cell\\n                pair<int,int> up=cntx[i][j];\\n                 // no. of 2\\'s and 5\\'s from i+1,j to bottom cell\\n                pair<int,int> down={cntx[n-1][j].F-cntx[i][j].F,cntx[n-1][j].S-cntx[i][j].S};\\n                 // no. of 2\\'s and 5\\'s from i,j to rightmost cell\\n                pair<int,int> right=cnty[i][j];\\n                 // no. of 2\\'s and 5\\'s from leftmost cell to i,j-1 cell\\n                pair<int,int> left={cnty[i][0].F-cnty[i][j].F,cnty[i][0].S-cnty[i][j].S};\\n                int cnt=0;\\n                // calculating no. of 2\\'s and 5\\'s for each of the 6 cases\\n                //     |\\n                //     |  \\n                \\n                cnt=max(cnt,min(up.F+down.F,up.S+down.S));\\n                \\n                //      |\\n                //   ___|\\n                \\n                cnt=max(cnt,min(up.F+left.F,up.S+left.S));\\n                \\n                //     |\\n                //     |_____\\n                \\n                cnt=max(cnt,min(up.F+right.F-orr[i][j].F,up.S+right.S-orr[i][j].S));\\n                \\n                //     _______\\n                //       \\n                \\n                cnt=max(cnt,min(left.F+right.F,left.S+right.S));\\n                //      ____\\n                //     |\\n                //     |  \\n                \\n                cnt=max(cnt,min(right.F+down.F,right.S+down.S));\\n                //      ____\\n                //          |\\n                //          |  \\n                \\n                cnt=max(cnt,min(left.F+down.F+orr[i][j].F,left.S+down.S+orr[i][j].S));\\n                ans=max(ans,cnt);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n#define F first\\n#define S second\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& v) {\\n        int n=v.size();\\n        int m=v[0].size();\\n        vector<vector<pair<int,int>>>cntx(n,vector<pair<int,int>>(m));// for vertical counting prefix sum matrix \\n        vector<vector<pair<int,int>>>cnty(n,vector<pair<int,int>>(m));// for horizontal counting  suffix sum matrix\\n        vector<vector<pair<int,int>>>orr(n,vector<pair<int,int>>(m));// for original counting\\n        for(int i=0;i<n;i++)\\n        {\\n           for(int j=0;j<m;j++)\\n           {\\n               int x=0;\\n               int y=0;\\n               int p=v[i][j];\\n               while(p%2==0)\\n               {\\n                   p=p/2;\\n                   x++;\\n               }\\n               while(p%5==0)\\n               {\\n                   p=p/5;\\n                   y++;\\n               }\\n               // for storing the number of 2\\'s and 5\\'s in a particular cell\\n               cntx[i][j]={x,y};\\n               cnty[i][j]={x,y};\\n               orr[i][j]={x,y};\\n           }\\n        }\\n        // Prefix sum vertical matrix\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                cntx[i][j].F+=cntx[i-1][j].F;\\n                cntx[i][j].S+=cntx[i-1][j].S;\\n            }\\n        }\\n        // suffix sum horizontal matrix\\n         for(int i=0;i<n;i++)\\n        {\\n            for(int j=m-2;j>=0;j--)\\n            {\\n              cnty[i][j].F+=cnty[i][j+1].F;\\n              cnty[i][j].S+=cnty[i][j+1].S;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n               // no. of 2\\'s and 5\\'s from top to i,j cell\\n                pair<int,int> up=cntx[i][j];\\n                 // no. of 2\\'s and 5\\'s from i+1,j to bottom cell\\n                pair<int,int> down={cntx[n-1][j].F-cntx[i][j].F,cntx[n-1][j].S-cntx[i][j].S};\\n                 // no. of 2\\'s and 5\\'s from i,j to rightmost cell\\n                pair<int,int> right=cnty[i][j];\\n                 // no. of 2\\'s and 5\\'s from leftmost cell to i,j-1 cell\\n                pair<int,int> left={cnty[i][0].F-cnty[i][j].F,cnty[i][0].S-cnty[i][j].S};\\n                int cnt=0;\\n                // calculating no. of 2\\'s and 5\\'s for each of the 6 cases\\n                //     |\\n                //     |  \\n                \\n                cnt=max(cnt,min(up.F+down.F,up.S+down.S));\\n                \\n                //      |\\n                //   ___|\\n                \\n                cnt=max(cnt,min(up.F+left.F,up.S+left.S));\\n                \\n                //     |\\n                //     |_____\\n                \\n                cnt=max(cnt,min(up.F+right.F-orr[i][j].F,up.S+right.S-orr[i][j].S));\\n                \\n                //     _______\\n                //       \\n                \\n                cnt=max(cnt,min(left.F+right.F,left.S+right.S));\\n                //      ____\\n                //     |\\n                //     |  \\n                \\n                cnt=max(cnt,min(right.F+down.F,right.S+down.S));\\n                //      ____\\n                //          |\\n                //          |  \\n                \\n                cnt=max(cnt,min(left.F+down.F+orr[i][j].F,left.S+down.S+orr[i][j].S));\\n                ans=max(ans,cnt);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955785,
                "title": "c-prefix-sum-count-2-s-and-5-s-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        int res=0;\\n        vector<vector<int>> v1(m,vector<int>(n,0)),v2(m,vector<int>(n,0));\\n        vector<vector<int>> v3(m,vector<int>(n,0)),v4(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            int cnt=0;\\n            int twos=0,fives=0;\\n            for(int j=0;j<n;j++){\\n                int temp=grid[i][j];\\n                int cnt1=0,cnt2=0;\\n                while(temp>0 and temp%2==0){\\n                    cnt1++;\\n                    temp/=2;\\n                } \\n                temp=grid[i][j];\\n                while(temp>0 and temp%5==0){\\n                    cnt2++;\\n                    temp/=5;\\n                }\\n                twos+=cnt1;\\n                fives+=cnt2;\\n                v1[i][j]=twos;\\n                v2[i][j]=fives;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int cnt=0;\\n            int twos=0,fives=0;\\n            for(int j=0;j<m;j++){\\n                int temp=grid[j][i];\\n                int cnt1=0,cnt2=0;\\n                while(temp>0 and temp%2==0){\\n                    cnt1++;\\n                    temp/=2;\\n                } \\n                temp=grid[j][i];\\n                while(temp>0 and temp%5==0){\\n                    cnt2++;\\n                    temp/=5;\\n                }\\n                twos+=cnt1;\\n                fives+=cnt2;\\n                v3[j][i]=twos;\\n                v4[j][i]=fives;\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int curr=0;\\n                int twos=v1[i][j],fives=v2[i][j];\\n                int cnt1=0,cnt2=0;\\n                int temp=grid[i][j];\\n                while(temp>0 and temp%2==0){\\n                    temp/=2;\\n                    cnt1++;\\n                }\\n                \\n                temp=grid[i][j];\\n                while(temp>0 and temp%5==0){\\n                    temp/=5;\\n                    cnt2++;\\n                }\\n                \\n                res=max(res,min(twos+v3[m-1][j]-v3[i][j],fives+v4[m-1][j]-v4[i][j]));\\n                res=max(res,min(twos+v3[i][j]-cnt1,fives+v4[i][j]-cnt2));\\n                res=max(res,min(v1[i][n-1]-twos+v3[i][j],v2[i][n-1]-fives+v4[i][j]));\\n                res=max(res,min(v1[i][n-1]-twos+v3[m-1][j]-v3[i][j]+cnt1,v2[i][n-1]-fives+v4[m-1][j]-v4[i][j]+cnt2));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        int res=0;\\n        vector<vector<int>> v1(m,vector<int>(n,0)),v2(m,vector<int>(n,0));\\n        vector<vector<int>> v3(m,vector<int>(n,0)),v4(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            int cnt=0;\\n            int twos=0,fives=0;\\n            for(int j=0;j<n;j++){\\n                int temp=grid[i][j];\\n                int cnt1=0,cnt2=0;\\n                while(temp>0 and temp%2==0){\\n                    cnt1++;\\n                    temp/=2;\\n                } \\n                temp=grid[i][j];\\n                while(temp>0 and temp%5==0){\\n                    cnt2++;\\n                    temp/=5;\\n                }\\n                twos+=cnt1;\\n                fives+=cnt2;\\n                v1[i][j]=twos;\\n                v2[i][j]=fives;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int cnt=0;\\n            int twos=0,fives=0;\\n            for(int j=0;j<m;j++){\\n                int temp=grid[j][i];\\n                int cnt1=0,cnt2=0;\\n                while(temp>0 and temp%2==0){\\n                    cnt1++;\\n                    temp/=2;\\n                } \\n                temp=grid[j][i];\\n                while(temp>0 and temp%5==0){\\n                    cnt2++;\\n                    temp/=5;\\n                }\\n                twos+=cnt1;\\n                fives+=cnt2;\\n                v3[j][i]=twos;\\n                v4[j][i]=fives;\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int curr=0;\\n                int twos=v1[i][j],fives=v2[i][j];\\n                int cnt1=0,cnt2=0;\\n                int temp=grid[i][j];\\n                while(temp>0 and temp%2==0){\\n                    temp/=2;\\n                    cnt1++;\\n                }\\n                \\n                temp=grid[i][j];\\n                while(temp>0 and temp%5==0){\\n                    temp/=5;\\n                    cnt2++;\\n                }\\n                \\n                res=max(res,min(twos+v3[m-1][j]-v3[i][j],fives+v4[m-1][j]-v4[i][j]));\\n                res=max(res,min(twos+v3[i][j]-cnt1,fives+v4[i][j]-cnt2));\\n                res=max(res,min(v1[i][n-1]-twos+v3[i][j],v2[i][n-1]-fives+v4[i][j]));\\n                res=max(res,min(v1[i][n-1]-twos+v3[m-1][j]-v3[i][j]+cnt1,v2[i][n-1]-fives+v4[m-1][j]-v4[i][j]+cnt2));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955748,
                "title": "java-rotate-3-times",
                "content": "It is quite apparent it is a prefix sum question but geez, it is **really** implementation heavy due to \\n1. We have to keep track of both 2 and 5\\'s prefix sum in a 2D grid\\n\\n2. There are like, a lot of directions, to consider. That is, start from horizontal vs vertical, then go up vs down or right vs left.\\n\\nI missed considering a direction during contest and submission failed at the last 5 test cases. Troubleshoot was kind of difficult. Annoyed. \\nHere comes an idea that didn\\'t occur to me during contest: To deal with this annoyance, we can literally just **rotate the grid 3 times**. \\n\\n```Java\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int ans = 0;\\n        for (int i = 0; i < 4; i++){\\n            ans = Math.max(ans, solve(grid));\\n            grid = rotate(grid);\\n        }\\n        return ans;\\n    }\\n\\n    private int solve(int[][] grid){\\n        int n = grid[0].length, m = grid.length, ans = 0;\\n        int[][] fcol = new int[m + 1][n];\\n        int[][] tcol = new int[m + 1][n];\\n        int[][] frow = new int[n + 1][m];\\n        int[][] trow = new int[n + 1][m];\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                int t = count(grid[i][j], 2);\\n                int f = count(grid[i][j], 5);\\n                fcol[i + 1][j] += fcol[i][j] + f;\\n                tcol[i + 1][j] += tcol[i][j] + t;\\n                frow[j + 1][i] += frow[j][i] + f;\\n                trow[j + 1][i] += trow[j][i] + t;\\n            }\\n        }\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                int rowTwo = trow[j + 1][i];\\n                int rowFive= frow[j + 1][i];\\n                int colTwo = tcol[m][j] - tcol[i + 1][j];\\n                int colFive= fcol[m][j] - fcol[i + 1][j];\\n                ans = Math.max(ans, Math.min(rowTwo + colTwo, rowFive + colFive));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int count(int n, int w){\\n        int count = 0;\\n        while(n % w == 0){\\n            count++;\\n            n /= w;\\n        }\\n        return count;\\n    }\\n\\n    private int[][] rotate(int[][] grid){\\n        int n = grid[0].length, m = grid.length;\\n        int[][] next = new int[n][m];\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                next[j][m - 1 - i] = grid[i][j];\\n            }\\n        }\\n        return next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int ans = 0;\\n        for (int i = 0; i < 4; i++){\\n            ans = Math.max(ans, solve(grid));\\n            grid = rotate(grid);\\n        }\\n        return ans;\\n    }\\n\\n    private int solve(int[][] grid){\\n        int n = grid[0].length, m = grid.length, ans = 0;\\n        int[][] fcol = new int[m + 1][n];\\n        int[][] tcol = new int[m + 1][n];\\n        int[][] frow = new int[n + 1][m];\\n        int[][] trow = new int[n + 1][m];\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                int t = count(grid[i][j], 2);\\n                int f = count(grid[i][j], 5);\\n                fcol[i + 1][j] += fcol[i][j] + f;\\n                tcol[i + 1][j] += tcol[i][j] + t;\\n                frow[j + 1][i] += frow[j][i] + f;\\n                trow[j + 1][i] += trow[j][i] + t;\\n            }\\n        }\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                int rowTwo = trow[j + 1][i];\\n                int rowFive= frow[j + 1][i];\\n                int colTwo = tcol[m][j] - tcol[i + 1][j];\\n                int colFive= fcol[m][j] - fcol[i + 1][j];\\n                ans = Math.max(ans, Math.min(rowTwo + colTwo, rowFive + colFive));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int count(int n, int w){\\n        int count = 0;\\n        while(n % w == 0){\\n            count++;\\n            n /= w;\\n        }\\n        return count;\\n    }\\n\\n    private int[][] rotate(int[][] grid){\\n        int n = grid[0].length, m = grid.length;\\n        int[][] next = new int[n][m];\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                next[j][m - 1 - i] = grid[i][j];\\n            }\\n        }\\n        return next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955665,
                "title": "prefix-sum-java-o-mn-beat-100",
                "content": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        // find path with most matching 5 & 2 divisor\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        Node[][] rows = new Node[m][n];\\n        Node[][] cols = new Node[m][n];\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int five = getFive(grid[i][j]);\\n                int two = getTwo(grid[i][j]);\\n                Node nodeR = new Node(five, two);\\n                Node nodeC = new Node(five, two);\\n                \\n                if (i > 0) {\\n                    nodeC.five = nodeC.five + cols[i - 1][j].five;\\n                    nodeC.two = nodeC.two + cols[i - 1][j].two;\\n                }\\n                \\n                cols[i][j] = nodeC;\\n                \\n                if (j > 0) {\\n                    nodeR.five = nodeR.five + rows[i][j - 1].five;\\n                    nodeR.two = nodeR.two + rows[i][j - 1].two;\\n                }\\n                \\n                rows[i][j] = nodeR;\\n            }\\n        }\\n        \\n        int max = 0;\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int rowLeft5 = j - 1 < 0 ? 0 : rows[i][j - 1].five;\\n                int rowLeft2 = j - 1 < 0 ? 0 : rows[i][j - 1].two;\\n                int rowRight5 = rows[i][n - 1].five - rows[i][j].five;\\n                int rowRight2 = rows[i][n - 1].two - rows[i][j].two;\\n                \\n                int colUp5 = i - 1 < 0 ? 0 : cols[i - 1][j].five;\\n                int colUp2 = i - 1 < 0 ? 0 : cols[i - 1][j].two;\\n                int colDown5 = cols[m - 1][j].five - cols[i][j].five;\\n                int colDown2 = cols[m - 1][j].two - cols[i][j].two;\\n                \\n                int cur = grid[i][j];\\n                \\n                max = Math.max(max, Math.min(rowLeft5 + colUp5 + getFive(cur), rowLeft2 + colUp2 + getTwo(cur)));\\n                max = Math.max(max, Math.min(rowLeft5 + colDown5 + getFive(cur), rowLeft2 + colDown2 + getTwo(cur)));\\n                max = Math.max(max, Math.min(rowRight5 + colUp5 + getFive(cur), rowRight2 + colUp2 + getTwo(cur)));\\n                max = Math.max(max, Math.min(rowRight5 + colDown5 + getFive(cur), rowRight2 + colDown2 + getTwo(cur)));\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int getTwo(int x) {\\n        int res = 0;\\n        \\n        while (x % 2 == 0) {\\n            res++;\\n            x /= 2;\\n        }\\n        return res;\\n    }\\n    \\n    private int getFive(int x) {\\n        int res = 0;\\n        \\n        while (x % 5 == 0) {\\n            res++;\\n            x /= 5;\\n        }\\n        return res;\\n    }\\n}\\n\\nclass Node {\\n    int five;\\n    int two;\\n    \\n    public Node(int five, int two) {\\n        this.five = five;\\n        this.two = two;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        // find path with most matching 5 & 2 divisor\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        Node[][] rows = new Node[m][n];\\n        Node[][] cols = new Node[m][n];\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int five = getFive(grid[i][j]);\\n                int two = getTwo(grid[i][j]);\\n                Node nodeR = new Node(five, two);\\n                Node nodeC = new Node(five, two);\\n                \\n                if (i > 0) {\\n                    nodeC.five = nodeC.five + cols[i - 1][j].five;\\n                    nodeC.two = nodeC.two + cols[i - 1][j].two;\\n                }\\n                \\n                cols[i][j] = nodeC;\\n                \\n                if (j > 0) {\\n                    nodeR.five = nodeR.five + rows[i][j - 1].five;\\n                    nodeR.two = nodeR.two + rows[i][j - 1].two;\\n                }\\n                \\n                rows[i][j] = nodeR;\\n            }\\n        }\\n        \\n        int max = 0;\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int rowLeft5 = j - 1 < 0 ? 0 : rows[i][j - 1].five;\\n                int rowLeft2 = j - 1 < 0 ? 0 : rows[i][j - 1].two;\\n                int rowRight5 = rows[i][n - 1].five - rows[i][j].five;\\n                int rowRight2 = rows[i][n - 1].two - rows[i][j].two;\\n                \\n                int colUp5 = i - 1 < 0 ? 0 : cols[i - 1][j].five;\\n                int colUp2 = i - 1 < 0 ? 0 : cols[i - 1][j].two;\\n                int colDown5 = cols[m - 1][j].five - cols[i][j].five;\\n                int colDown2 = cols[m - 1][j].two - cols[i][j].two;\\n                \\n                int cur = grid[i][j];\\n                \\n                max = Math.max(max, Math.min(rowLeft5 + colUp5 + getFive(cur), rowLeft2 + colUp2 + getTwo(cur)));\\n                max = Math.max(max, Math.min(rowLeft5 + colDown5 + getFive(cur), rowLeft2 + colDown2 + getTwo(cur)));\\n                max = Math.max(max, Math.min(rowRight5 + colUp5 + getFive(cur), rowRight2 + colUp2 + getTwo(cur)));\\n                max = Math.max(max, Math.min(rowRight5 + colDown5 + getFive(cur), rowRight2 + colDown2 + getTwo(cur)));\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int getTwo(int x) {\\n        int res = 0;\\n        \\n        while (x % 2 == 0) {\\n            res++;\\n            x /= 2;\\n        }\\n        return res;\\n    }\\n    \\n    private int getFive(int x) {\\n        int res = 0;\\n        \\n        while (x % 5 == 0) {\\n            res++;\\n            x /= 5;\\n        }\\n        return res;\\n    }\\n}\\n\\nclass Node {\\n    int five;\\n    int two;\\n    \\n    public Node(int five, int two) {\\n        this.five = five;\\n        this.two = two;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955554,
                "title": "java-o-mn-solution-use-prefix-sum-to-calculate-number-of-factors-2-and-5-with-explanation",
                "content": "**The idea**: for each cornered path, let\\'s call its product is `p`. We can always rewrite `p`  as follows\\n`p = a * 10^n`\\n\\nNumber of trailing zeros will be maximum value of n in all ways to rewrite `p`. We have\\n\\n`number of trailing zeros of p = max(n) = min(number of 2 in prime factorization of p, number of 5 in prime factorization of p)`\\n\\n**Greedy strategy**: we will just consider the paths that start with a point on border of grid (first row or last row or first col or last col) and end with a point on border of grid because these paths will always have number of trailing zeros greater than (or equal) its sub paths.\\n\\nBelow is the implementation for this problem in Java. \\n\\n```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][][] count25 = new int[m][n][2];\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                // number of 2 in prime factorization of grid[i][j]\\n                count25[i][j][0] = countFactor(grid[i][j], 2);\\n                // number of 5 in prime factorization of grid[i][j]\\n                count25[i][j][1] = countFactor(grid[i][j], 5);\\n            }\\n        }\\n        \\n        // countUp[i][j][0]: number of 2 in prime factorization of numbers from grid[0][j] to grid[i][j]\\n        // countUp[i][j][1]: number of 5 in prime factorization of numbers from grid[0][j] to grid[i][j]\\n        // the same definition for countDown, countLeft and countRight\\n        // we will use prefix sum to caculate them\\n        int[][][] countUp = new int[m][n][2];\\n        int[][][] countDown = new int[m][n][2];\\n        int[][][] countLeft = new int[m][n][2];\\n        int[][][] countRight = new int[m][n][2];\\n        \\n        for (int i = 0; i < m; ++i) {\\n            countLeft[i][0][0] = count25[i][0][0];\\n            countLeft[i][0][1] = count25[i][0][1];\\n            countRight[i][n-1][0] = count25[i][n-1][0];\\n            countRight[i][n-1][1] = count25[i][n-1][1];\\n        }\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 1; j < n; ++j) {\\n                countLeft[i][j][0] = countLeft[i][j-1][0] + count25[i][j][0];\\n                countLeft[i][j][1] = countLeft[i][j-1][1] + count25[i][j][1];\\n            }\\n        }\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = n - 2; j >= 0; --j) {\\n                countRight[i][j][0] = countRight[i][j+1][0] + count25[i][j][0];\\n                countRight[i][j][1] = countRight[i][j+1][1] + count25[i][j][1];\\n            }\\n        }\\n        \\n        for (int j = 0; j < n; ++j) {\\n            countUp[0][j][0] = count25[0][j][0];\\n            countUp[0][j][1] = count25[0][j][1];\\n            countDown[m-1][j][0] = count25[m-1][j][0];\\n            countDown[m-1][j][1] = count25[m-1][j][1];\\n        }\\n        \\n        for (int j = 0; j < n; ++j) {\\n            for (int i = 1; i < m; ++i) {\\n                countUp[i][j][0] = countUp[i-1][j][0] + count25[i][j][0];\\n                countUp[i][j][1] = countUp[i-1][j][1] + count25[i][j][1];\\n            }\\n        }\\n        \\n        for (int j = 0; j < n; ++j) {\\n            for (int i = m-2; i >= 0; --i) {\\n                countDown[i][j][0] = countDown[i+1][j][0] + count25[i][j][0];\\n                countDown[i][j][1] = countDown[i+1][j][1] + count25[i][j][1];                \\n            }\\n        }\\n        \\n        int result = 0;\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                result = Math.max(result, \\n                                  Math.min(countUp[i][j][0] + countRight[i][j][0] - count25[i][j][0], countUp[i][j][1] + countRight[i][j][1] - count25[i][j][1])\\n                                 );\\n                result = Math.max(result, \\n                                  Math.min(countUp[i][j][0] + countLeft[i][j][0] - count25[i][j][0], countUp[i][j][1] + countLeft[i][j][1] - count25[i][j][1])\\n                                 );\\n                result = Math.max(result, \\n                                  Math.min(countDown[i][j][0] + countRight[i][j][0] - count25[i][j][0], countDown[i][j][1] + countRight[i][j][1] - count25[i][j][1])\\n                                 );\\n                result = Math.max(result, \\n                                  Math.min(countDown[i][j][0] + countLeft[i][j][0] - count25[i][j][0], countDown[i][j][1] + countLeft[i][j][1] - count25[i][j][1])\\n                                 );\\n            }\\n        }\\n        \\n        return result;\\n    }\\n\\n    \\n    \\n    private int countFactor(int a, int factor) {\\n        int result = 0;\\n        while (a % factor == 0) {\\n            a /= factor;\\n            result++;\\n        }\\n        return result;\\n    }\\n    \\n}\\n```\\nTime complexity: O(mn).\\nSpace complexity: O(mn).\\n\\nPlease upvote if it is helpful to you. If there is any questions/suggestion, please comment, I will reply as soon as possible.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][][] count25 = new int[m][n][2];\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                // number of 2 in prime factorization of grid[i][j]\\n                count25[i][j][0] = countFactor(grid[i][j], 2);\\n                // number of 5 in prime factorization of grid[i][j]\\n                count25[i][j][1] = countFactor(grid[i][j], 5);\\n            }\\n        }\\n        \\n        // countUp[i][j][0]: number of 2 in prime factorization of numbers from grid[0][j] to grid[i][j]\\n        // countUp[i][j][1]: number of 5 in prime factorization of numbers from grid[0][j] to grid[i][j]\\n        // the same definition for countDown, countLeft and countRight\\n        // we will use prefix sum to caculate them\\n        int[][][] countUp = new int[m][n][2];\\n        int[][][] countDown = new int[m][n][2];\\n        int[][][] countLeft = new int[m][n][2];\\n        int[][][] countRight = new int[m][n][2];\\n        \\n        for (int i = 0; i < m; ++i) {\\n            countLeft[i][0][0] = count25[i][0][0];\\n            countLeft[i][0][1] = count25[i][0][1];\\n            countRight[i][n-1][0] = count25[i][n-1][0];\\n            countRight[i][n-1][1] = count25[i][n-1][1];\\n        }\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 1; j < n; ++j) {\\n                countLeft[i][j][0] = countLeft[i][j-1][0] + count25[i][j][0];\\n                countLeft[i][j][1] = countLeft[i][j-1][1] + count25[i][j][1];\\n            }\\n        }\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = n - 2; j >= 0; --j) {\\n                countRight[i][j][0] = countRight[i][j+1][0] + count25[i][j][0];\\n                countRight[i][j][1] = countRight[i][j+1][1] + count25[i][j][1];\\n            }\\n        }\\n        \\n        for (int j = 0; j < n; ++j) {\\n            countUp[0][j][0] = count25[0][j][0];\\n            countUp[0][j][1] = count25[0][j][1];\\n            countDown[m-1][j][0] = count25[m-1][j][0];\\n            countDown[m-1][j][1] = count25[m-1][j][1];\\n        }\\n        \\n        for (int j = 0; j < n; ++j) {\\n            for (int i = 1; i < m; ++i) {\\n                countUp[i][j][0] = countUp[i-1][j][0] + count25[i][j][0];\\n                countUp[i][j][1] = countUp[i-1][j][1] + count25[i][j][1];\\n            }\\n        }\\n        \\n        for (int j = 0; j < n; ++j) {\\n            for (int i = m-2; i >= 0; --i) {\\n                countDown[i][j][0] = countDown[i+1][j][0] + count25[i][j][0];\\n                countDown[i][j][1] = countDown[i+1][j][1] + count25[i][j][1];                \\n            }\\n        }\\n        \\n        int result = 0;\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                result = Math.max(result, \\n                                  Math.min(countUp[i][j][0] + countRight[i][j][0] - count25[i][j][0], countUp[i][j][1] + countRight[i][j][1] - count25[i][j][1])\\n                                 );\\n                result = Math.max(result, \\n                                  Math.min(countUp[i][j][0] + countLeft[i][j][0] - count25[i][j][0], countUp[i][j][1] + countLeft[i][j][1] - count25[i][j][1])\\n                                 );\\n                result = Math.max(result, \\n                                  Math.min(countDown[i][j][0] + countRight[i][j][0] - count25[i][j][0], countDown[i][j][1] + countRight[i][j][1] - count25[i][j][1])\\n                                 );\\n                result = Math.max(result, \\n                                  Math.min(countDown[i][j][0] + countLeft[i][j][0] - count25[i][j][0], countDown[i][j][1] + countLeft[i][j][1] - count25[i][j][1])\\n                                 );\\n            }\\n        }\\n        \\n        return result;\\n    }\\n\\n    \\n    \\n    private int countFactor(int a, int factor) {\\n        int result = 0;\\n        while (a % factor == 0) {\\n            a /= factor;\\n            result++;\\n        }\\n        return result;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955534,
                "title": "java-dp-prefix-sum-2-5-factor-nums",
                "content": "If we directly count the product of a path, we are very likely to get integer overflow.\\n**The trailing zeros equals on the larger number of factors of 2 and 5 in the product.**\\nWe need to count the four kinds of cornered paths.\\n1. left-up\\n2. up-right\\n3. right-down\\n4. down-left\\n\\nTo count the paths efficiently, we need to first compute the prefix sums of factor 2 and factor 5, from 4 directions.\\n\\nTime: O(mn)\\nSpace: O(mn)\\n\\n```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] two = new int[m][n];\\n        int[][] five = new int[m][n];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                two[i][j] = getFactorNum(grid[i][j], 2);\\n                five[i][j] = getFactorNum(grid[i][j], 5);\\n            }\\n        }\\n        \\n        int[][] left2 = new int[m][n];\\n        int[][] left5 = new int[m][n];\\n        for (int i = 0; i < m; ++i) {\\n            int sum2 = 0;\\n            int sum5 = 0;\\n            for (int j = 0; j < n; ++j) {\\n                sum2 += two[i][j];\\n                sum5 += five[i][j];\\n                left2[i][j] = sum2;\\n                left5[i][j] = sum5;\\n            }\\n        }\\n        \\n        int[][] right2 = new int[m][n];\\n        int[][] right5 = new int[m][n];\\n        for (int i = 0; i < m; ++i) {\\n            int sum2 = 0;\\n            int sum5 = 0;\\n            for (int j = n - 1; j >= 0; --j) {\\n                sum2 += two[i][j];\\n                sum5 += five[i][j];\\n                right2[i][j] = sum2;\\n                right5[i][j] = sum5;\\n            }\\n        }\\n        \\n        int[][] up2 = new int[m][n];\\n        int[][] up5 = new int[m][n];\\n        for (int j = 0; j < n; ++j) {\\n            int sum2 = 0;\\n            int sum5 = 0;\\n            for (int i = 0; i < m; ++i) {\\n                sum2 += two[i][j];\\n                sum5 += five[i][j];\\n                up2[i][j] = sum2;\\n                up5[i][j] = sum5;\\n            }\\n        }\\n        \\n        int[][] down2 = new int[m][n];\\n        int[][] down5 = new int[m][n];\\n        for (int j = 0; j < n; ++j) {\\n            int sum2 = 0;\\n            int sum5 = 0;\\n            for (int i = m - 1; i >= 0; --i) {\\n                sum2 += two[i][j];\\n                sum5 += five[i][j];\\n                down2[i][j] = sum2;\\n                down5[i][j] = sum5;\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                // left-up\\n                if (i != 0 || j != 0) {\\n                    int cur = Math.min(left2[i][j] + up2[i][j] - two[i][j], left5[i][j] + up5[i][j] - five[i][j]);\\n                    res = Math.max(res, cur);\\n                }\\n                \\n                // up-right\\n                if (i != 0 || j != n - 1) {\\n                    int cur = Math.min(right2[i][j] + up2[i][j] - two[i][j], right5[i][j] + up5[i][j] - five[i][j]);\\n                    res = Math.max(res, cur);\\n                }\\n                \\n                // right-down\\n                if (i != m - 1 || j != n - 1) {\\n                    int cur = Math.min(right2[i][j] + down2[i][j] - two[i][j], right5[i][j] + down5[i][j] - five[i][j]);\\n                    res = Math.max(res, cur);\\n                }\\n                \\n                // down-left\\n                if (i != m - 1 || j != 0) {\\n                    int cur = Math.min(left2[i][j] + down2[i][j] - two[i][j], left5[i][j] + down5[i][j] - five[i][j]);\\n                    res = Math.max(res, cur);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int getFactorNum(int input, int factor) {\\n        int res = 0;\\n        while (input != 0 && input % factor == 0) {\\n            ++res;\\n            input /= factor;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] two = new int[m][n];\\n        int[][] five = new int[m][n];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                two[i][j] = getFactorNum(grid[i][j], 2);\\n                five[i][j] = getFactorNum(grid[i][j], 5);\\n            }\\n        }\\n        \\n        int[][] left2 = new int[m][n];\\n        int[][] left5 = new int[m][n];\\n        for (int i = 0; i < m; ++i) {\\n            int sum2 = 0;\\n            int sum5 = 0;\\n            for (int j = 0; j < n; ++j) {\\n                sum2 += two[i][j];\\n                sum5 += five[i][j];\\n                left2[i][j] = sum2;\\n                left5[i][j] = sum5;\\n            }\\n        }\\n        \\n        int[][] right2 = new int[m][n];\\n        int[][] right5 = new int[m][n];\\n        for (int i = 0; i < m; ++i) {\\n            int sum2 = 0;\\n            int sum5 = 0;\\n            for (int j = n - 1; j >= 0; --j) {\\n                sum2 += two[i][j];\\n                sum5 += five[i][j];\\n                right2[i][j] = sum2;\\n                right5[i][j] = sum5;\\n            }\\n        }\\n        \\n        int[][] up2 = new int[m][n];\\n        int[][] up5 = new int[m][n];\\n        for (int j = 0; j < n; ++j) {\\n            int sum2 = 0;\\n            int sum5 = 0;\\n            for (int i = 0; i < m; ++i) {\\n                sum2 += two[i][j];\\n                sum5 += five[i][j];\\n                up2[i][j] = sum2;\\n                up5[i][j] = sum5;\\n            }\\n        }\\n        \\n        int[][] down2 = new int[m][n];\\n        int[][] down5 = new int[m][n];\\n        for (int j = 0; j < n; ++j) {\\n            int sum2 = 0;\\n            int sum5 = 0;\\n            for (int i = m - 1; i >= 0; --i) {\\n                sum2 += two[i][j];\\n                sum5 += five[i][j];\\n                down2[i][j] = sum2;\\n                down5[i][j] = sum5;\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                // left-up\\n                if (i != 0 || j != 0) {\\n                    int cur = Math.min(left2[i][j] + up2[i][j] - two[i][j], left5[i][j] + up5[i][j] - five[i][j]);\\n                    res = Math.max(res, cur);\\n                }\\n                \\n                // up-right\\n                if (i != 0 || j != n - 1) {\\n                    int cur = Math.min(right2[i][j] + up2[i][j] - two[i][j], right5[i][j] + up5[i][j] - five[i][j]);\\n                    res = Math.max(res, cur);\\n                }\\n                \\n                // right-down\\n                if (i != m - 1 || j != n - 1) {\\n                    int cur = Math.min(right2[i][j] + down2[i][j] - two[i][j], right5[i][j] + down5[i][j] - five[i][j]);\\n                    res = Math.max(res, cur);\\n                }\\n                \\n                // down-left\\n                if (i != m - 1 || j != 0) {\\n                    int cur = Math.min(left2[i][j] + down2[i][j] - two[i][j], left5[i][j] + down5[i][j] - five[i][j]);\\n                    res = Math.max(res, cur);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int getFactorNum(int input, int factor) {\\n        int res = 0;\\n        while (input != 0 && input % factor == 0) {\\n            ++res;\\n            input /= factor;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955510,
                "title": "why-my-code-failed",
                "content": "my idea is to traverse just like number of island but make sure only make turn at most once. where is the bug? \\nfailed at:\\n[[899,727,165,249,531,300,542,890],[981,587,565,943,875,498,582,672],[106,902,524,725,699,778,365,220]]\\n```\\nclass Solution {\\n    int res = 0;\\n    public int maxTrailingZeros(int[][] grid) {\\n        \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                    helper(grid, i, j, 0, 1);\\n            }\\n        }  \\n        return res;\\n    }\\n    \\n    public void helper(int[][] grid, int i, int j, int count, int current){\\n        if(i>=grid.length || i < 0 || j<0 || j >=grid[0].length ){\\n            while(current>=10 && current%10==0){\\n                current = current/10;\\n                count++;\\n            }\\n            res = Math.max(res, count);\\n            return;\\n        }\\n        else{\\n            current = current*grid[i][j];\\n            while(current%10==0){\\n                current = current/10;\\n                count++;\\n            }\\n            toLeft(grid, i, j-1, count, current);\\n            toRight(grid, i, j+1, count, current);\\n            helper(grid, i+1, j, count, current);\\n        }\\n    }\\n    \\n    public void toLeft(int[][] grid, int i, int j, int count, int current){\\n        if(i>=grid.length || i < 0 || j<0 || j >=grid[0].length ){\\n            while(current >= 10 && current%10==0){\\n                current = current/10;\\n                count++;\\n            }\\n            res = Math.max(res, count);\\n            return;\\n        }\\n        else{\\n            current = current*grid[i][j];\\n            while(current%10==0){\\n                current = current/10;\\n                count++;\\n            }\\n            toLeft(grid, i, j-1, count, current);\\n            // toRight(grid, i, j+1, count, visited, current);\\n            // helper(grid, i+1, j, count, visited, current);\\n        }\\n    }\\n    \\n    public void toRight(int[][] grid, int i, int j, int count, int current){\\n        if(i>=grid.length || i < 0 || j<0 || j >=grid[0].length ){\\n            while(current>=10 && current%10==0){\\n                current = current/10;\\n                count++;\\n            }\\n            res = Math.max(res, count);\\n            return;\\n        }\\n        else{\\n            current = current*grid[i][j];\\n            while(current%10==0){\\n                current = current/10;\\n                count++;\\n            }\\n            // toLeft(grid, i, j-1, count, visited, current);\\n            toRight(grid, i, j+1, count, current);\\n            // helper(grid, i+1, j, count, visited, current);\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    public int maxTrailingZeros(int[][] grid) {\\n        \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                    helper(grid, i, j, 0, 1);\\n            }\\n        }  \\n        return res;\\n    }\\n    \\n    public void helper(int[][] grid, int i, int j, int count, int current){\\n        if(i>=grid.length || i < 0 || j<0 || j >=grid[0].length ){\\n            while(current>=10 && current%10==0){\\n                current = current/10;\\n                count++;\\n            }\\n            res = Math.max(res, count);\\n            return;\\n        }\\n        else{\\n            current = current*grid[i][j];\\n            while(current%10==0){\\n                current = current/10;\\n                count++;\\n            }\\n            toLeft(grid, i, j-1, count, current);\\n            toRight(grid, i, j+1, count, current);\\n            helper(grid, i+1, j, count, current);\\n        }\\n    }\\n    \\n    public void toLeft(int[][] grid, int i, int j, int count, int current){\\n        if(i>=grid.length || i < 0 || j<0 || j >=grid[0].length ){\\n            while(current >= 10 && current%10==0){\\n                current = current/10;\\n                count++;\\n            }\\n            res = Math.max(res, count);\\n            return;\\n        }\\n        else{\\n            current = current*grid[i][j];\\n            while(current%10==0){\\n                current = current/10;\\n                count++;\\n            }\\n            toLeft(grid, i, j-1, count, current);\\n            // toRight(grid, i, j+1, count, visited, current);\\n            // helper(grid, i+1, j, count, visited, current);\\n        }\\n    }\\n    \\n    public void toRight(int[][] grid, int i, int j, int count, int current){\\n        if(i>=grid.length || i < 0 || j<0 || j >=grid[0].length ){\\n            while(current>=10 && current%10==0){\\n                current = current/10;\\n                count++;\\n            }\\n            res = Math.max(res, count);\\n            return;\\n        }\\n        else{\\n            current = current*grid[i][j];\\n            while(current%10==0){\\n                current = current/10;\\n                count++;\\n            }\\n            // toLeft(grid, i, j-1, count, visited, current);\\n            toRight(grid, i, j+1, count, current);\\n            // helper(grid, i+1, j, count, visited, current);\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955495,
                "title": "c-rotating-the-grid-disgusting-question",
                "content": "\\t\\tclass Solution {\\n\\tpublic:\\n    \\n    pair<long long,long long> util(int val){\\n        \\n        int x=0;\\n        while(val>0 && val%5==0){\\n            val=val/5;\\n            x++;\\n        }\\n        int y=0;\\n        while(val>0 && val%2==0){\\n            val=val/2;\\n            y++;\\n        }\\n        return {x,y};\\n        \\n    }\\n    \\n    long long util(vector<vector<int>>& grid){\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        pair<long long,long long> matrix[n][m];\\n        pair<long long,long long> matrix1[n][m];\\n        pair<long long,long long> matrix2[n][m];\\n        \\n        //making the first grid;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++){\\n                int val=grid[i][j];\\n                matrix[i][j]=util(val);\\n            }\\n        \\n        //right to left\\n        for(int i=0;i<n;i++){\\n            for(int j=m-1;j>=0;j--){\\n                if(j==m-1)\\n                    matrix1[i][j]=matrix[i][j];\\n                else\\n                    matrix1[i][j]={matrix[i][j].first+matrix1[i][j+1].first,matrix[i][j].second+matrix1[i][j+1].second};\\n   \\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(j==0)\\n                    matrix2[i][j]=matrix[i][j];\\n                else\\n                    matrix2[i][j]={matrix[i][j].first+matrix2[i][j-1].first,matrix[i][j].second+matrix2[i][j-1].second};\\n            }\\n        }\\n        long long res=0;\\n        \\n        //calculating by traversing from up to down\\n        \\n        for(int j=0;j<m;j++){\\n            pair<long long,long long>sum={0,0};\\n            for(int i=0;i<n;i++){\\n                sum={sum.first+matrix[i][j].first,sum.second+matrix[i][j].second};\\n                res=max(res,min(sum.first,sum.second));\\n                if(j>0){\\n                pair<long long,long long>p1=matrix2[i][j-1];\\n                res=max(res,min(sum.first+p1.first,sum.second+p1.second));\\n                }\\n                if(j<m-1){\\n                    pair<long long,long long>p1=matrix1[i][j+1];\\n                res=max(res,min(sum.first+p1.first,sum.second+p1.second));\\n                }\\n                   \\n            }            \\n            \\n        }\\n        return res;\\n        \\n    }\\n\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n    int m=grid[0].size();\\n        int n=grid.size();\\n        vector<vector<int>>grid2(m,vector<int>(n,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                grid2[j][i]=grid[i][j];\\n            }\\n        }\\n        long long res=0;\\n          res=max(util(grid),util(grid2));\\n        vector<vector<int>>grid3(n,vector<int>(m,0));\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                grid3[n-i-1][j]=grid[i][j];       \\n            }\\n        }\\n        return max(res,util(grid3));\\n        \\n        \\n    }\\n\\t};",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    \\n    pair<long long,long long> util(int val){\\n        \\n        int x=0;\\n        while(val>0 && val%5==0){\\n            val=val/5;\\n            x++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1955422,
                "title": "simple-dynamic-programming-dp-o-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        int ans=0;\\n        int dp1[2][n+2][m+2],dp2[2][n+2][m+2],dp3[2][n+2][m+2],dp4[2][n+2][m+2];\\n        memset(dp1,0,sizeof dp1);\\n        memset(dp2,0,sizeof dp2);\\n        memset(dp3,0,sizeof dp3);\\n        memset(dp4,0,sizeof dp4);\\n\\n        for(int x=0;x<grid.size();x++){\\n            for(int z=0;z<grid[0].size();z++){\\n                int cnt2=0,cnt5=0;\\n                int num=grid[x][z];\\n                while(num%2==0)num/=2,cnt2++;\\n                while(num%5==0)num/=5,cnt5++;\\n                dp1[0][x+1][z+1]=dp2[0][x+1][z+1]=dp3[0][x+1][z+1]=dp4[0][x+1][z+1]=cnt2;\\n                dp1[1][x+1][z+1]=dp2[1][x+1][z+1]=dp3[1][x+1][z+1]=dp4[1][x+1][z+1]=cnt5;\\n            }\\n        }\\n        for(int i=1;i<=n;i++){//up to down\\n            for(int j=1;j<=m;j++){\\n                dp1[0][i][j]+=dp1[0][i-1][j];\\n                dp1[1][i][j]+=dp1[1][i-1][j];\\n                // std::cout<<dp1[0][i][j]<<\",\"<<dp1[1][i][j]<<\" \";\\n            }//std::cout<<\"\\\\n\";\\n        }\\n        // std::cout<<\"\\\\n\";\\n        for(int i=n;i>=1;i--){//down to up\\n            for(int j=1;j<=m;j++){\\n                dp2[0][i][j]+=dp2[0][i+1][j];\\n                dp2[1][i][j]+=dp2[1][i+1][j];\\n                // std::cout<<dp2[0][i][j]<<\",\"<<dp2[1][i][j]<<\" \";\\n            }//std::cout<<\"\\\\n\";\\n        }\\n        // std::cout<<\"\\\\n\";\\n        for(int i=1;i<=n;i++){//left to right\\n            for(int j=1;j<=m;j++){\\n                dp3[0][i][j]+=dp3[0][i][j-1];\\n                dp3[1][i][j]+=dp3[1][i][j-1];\\n                // std::cout<<dp3[0][i][j]<<\",\"<<dp3[1][i][j]<<\" \";\\n            }//std::cout<<\"\\\\n\";\\n        }\\n        // std::cout<<\"\\\\n\";\\n        for(int i=1;i<=n;i++){//right to left\\n            for(int j=m;j>=1;j--){\\n                dp4[0][i][j]+=dp4[0][i][j+1];\\n                dp4[1][i][j]+=dp4[1][i][j+1];\\n               //std::cout<<dp4[0][i][j]<<\",\"<<dp4[1][i][j]<<\" \";\\n            }//std::cout<<\"\\\\n\";\\n        }\\n        //std::cout<<\"\\\\n\";\\n        for(int i=1;i<=n;i++){//solve\\n            for(int j=1;j<=m;j++){\\n            \\n                    ans=max(ans,min(dp4[0][i][j+1]+dp2[0][i][j],dp4[1][i][j+1]+dp2[1][i][j]));\\n                    ans=max(ans,min(dp3[0][i][j-1]+dp1[0][i][j],dp3[1][i][j-1]+dp1[1][i][j]));\\n                    ans=max(ans,min(dp3[0][i][j-1]+dp2[0][i][j],dp3[1][i][j-1]+dp2[1][i][j]));\\n                    ans=max(ans,min(dp4[0][i][j+1]+dp1[0][i][j],dp4[1][i][j+1]+dp1[1][i][j]));\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        int ans=0;\\n        int dp1[2][n+2][m+2],dp2[2][n+2][m+2],dp3[2][n+2][m+2],dp4[2][n+2][m+2];\\n        memset(dp1,0,sizeof dp1);\\n        memset(dp2,0,sizeof dp2);\\n        memset(dp3,0,sizeof dp3);\\n        memset(dp4,0,sizeof dp4);\\n\\n        for(int x=0;x<grid.size();x++){\\n            for(int z=0;z<grid[0].size();z++){\\n                int cnt2=0,cnt5=0;\\n                int num=grid[x][z];\\n                while(num%2==0)num/=2,cnt2++;\\n                while(num%5==0)num/=5,cnt5++;\\n                dp1[0][x+1][z+1]=dp2[0][x+1][z+1]=dp3[0][x+1][z+1]=dp4[0][x+1][z+1]=cnt2;\\n                dp1[1][x+1][z+1]=dp2[1][x+1][z+1]=dp3[1][x+1][z+1]=dp4[1][x+1][z+1]=cnt5;\\n            }\\n        }\\n        for(int i=1;i<=n;i++){//up to down\\n            for(int j=1;j<=m;j++){\\n                dp1[0][i][j]+=dp1[0][i-1][j];\\n                dp1[1][i][j]+=dp1[1][i-1][j];\\n                // std::cout<<dp1[0][i][j]<<\",\"<<dp1[1][i][j]<<\" \";\\n            }//std::cout<<\"\\\\n\";\\n        }\\n        // std::cout<<\"\\\\n\";\\n        for(int i=n;i>=1;i--){//down to up\\n            for(int j=1;j<=m;j++){\\n                dp2[0][i][j]+=dp2[0][i+1][j];\\n                dp2[1][i][j]+=dp2[1][i+1][j];\\n                // std::cout<<dp2[0][i][j]<<\",\"<<dp2[1][i][j]<<\" \";\\n            }//std::cout<<\"\\\\n\";\\n        }\\n        // std::cout<<\"\\\\n\";\\n        for(int i=1;i<=n;i++){//left to right\\n            for(int j=1;j<=m;j++){\\n                dp3[0][i][j]+=dp3[0][i][j-1];\\n                dp3[1][i][j]+=dp3[1][i][j-1];\\n                // std::cout<<dp3[0][i][j]<<\",\"<<dp3[1][i][j]<<\" \";\\n            }//std::cout<<\"\\\\n\";\\n        }\\n        // std::cout<<\"\\\\n\";\\n        for(int i=1;i<=n;i++){//right to left\\n            for(int j=m;j>=1;j--){\\n                dp4[0][i][j]+=dp4[0][i][j+1];\\n                dp4[1][i][j]+=dp4[1][i][j+1];\\n               //std::cout<<dp4[0][i][j]<<\",\"<<dp4[1][i][j]<<\" \";\\n            }//std::cout<<\"\\\\n\";\\n        }\\n        //std::cout<<\"\\\\n\";\\n        for(int i=1;i<=n;i++){//solve\\n            for(int j=1;j<=m;j++){\\n            \\n                    ans=max(ans,min(dp4[0][i][j+1]+dp2[0][i][j],dp4[1][i][j+1]+dp2[1][i][j]));\\n                    ans=max(ans,min(dp3[0][i][j-1]+dp1[0][i][j],dp3[1][i][j-1]+dp1[1][i][j]));\\n                    ans=max(ans,min(dp3[0][i][j-1]+dp2[0][i][j],dp3[1][i][j-1]+dp2[1][i][j]));\\n                    ans=max(ans,min(dp4[0][i][j+1]+dp1[0][i][j],dp4[1][i][j+1]+dp1[1][i][j]));\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1955419,
                "title": "accepted-python-solution",
                "content": "This solution got accpeted. But it is too long!\\nCould someone help me to simplify it? Thanks!\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        m_five = [[0] * n for _ in range(m)]\\n        m_two = [[0] * n for _ in range(m)]\\n        hor_five = [[0] * n for _ in range(m)]\\n        hor_five_r = [[0] * n for _ in range(m)]\\n        hor_two = [[0] * n for _ in range(m)]\\n        hor_two_r = [[0] * n for _ in range(m)]\\n        ver_five = [[0] * n for _ in range(m)]\\n        ver_five_r = [[0] * n for _ in range(m)]\\n        ver_two = [[0] * n for _ in range(m)]\\n        ver_two_r = [[0] * n for _ in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                x = grid[i][j]\\n                cnt = 0\\n\\n                if x % 5 == 0:\\n                    cnt += 1\\n                if x % 25 == 0:\\n                    cnt += 1\\n                if x % 125 == 0:\\n                    cnt += 1\\n                if x % 625 == 0:\\n                    cnt += 1\\n\\n                m_five[i][j] = cnt\\n                cnt = 0\\n                if x % 512 == 0:\\n                    cnt = 9\\n                elif x % 256 == 0:\\n                    cnt = 8\\n                elif x % 128 == 0:\\n                    cnt = 7\\n                elif x % 64 == 0:\\n                    cnt = 6\\n                elif x % 32 == 0:\\n                    cnt = 5\\n                elif x % 16 == 0:\\n                    cnt = 4\\n                elif x % 8 == 0:\\n                    cnt = 3\\n                elif x % 4 == 0:\\n                    cnt = 2\\n                elif x % 2 == 0:\\n                    cnt = 1\\n                m_two[i][j] = cnt\\n        for i in range(m):\\n            for j in range(n):\\n                if j == 0:\\n                    hor_two[i][j] = m_two[i][j]\\n                    hor_five[i][j] = m_five[i][j]\\n                else:\\n                    hor_two[i][j] = m_two[i][j] + hor_two[i][j - 1]\\n                    hor_five[i][j] = m_five[i][j] + hor_five[i][j - 1]\\n            cur_five = cur_two = 0\\n            for j in range(n - 1, -1, -1):\\n                if j == n - 1:\\n                    hor_two_r[i][j] = m_two[i][j]\\n                    hor_five_r[i][j] = m_five[i][j]\\n                else:\\n                    hor_two_r[i][j] = hor_two_r[i][j + 1] + m_two[i][j]\\n                    hor_five_r[i][j] = hor_five_r[i][j + 1] + m_five[i][j]\\n        \\n\\n        for j in range(n):\\n            for i in range(m):\\n                if i == 0:\\n                    ver_five[i][j] = m_five[i][j]\\n                    ver_two[i][j] = m_two[i][j]\\n                else:\\n                    ver_five[i][j] = m_five[i][j] + ver_five[i - 1][j]\\n                    ver_two[i][j] = m_two[i][j] + ver_two[i - 1][j]\\n            for i in range(m - 1, -1, -1):\\n                if i == m - 1:\\n                    ver_five_r[i][j] = m_five[i][j]\\n                    ver_two_r[i][j] = m_two[i][j]\\n                else:\\n                    ver_two_r[i][j] = m_two[i][j] + ver_two_r[i + 1][j]\\n                    ver_five_r[i][j] = m_five[i][j] +ver_five_r[i + 1][j]\\n        \\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                res = max(res, min(hor_five[i][j] + ver_five[i][j] - m_five[i][j], hor_two[i][j] + ver_two[i][j] - m_two[i][j]),\\n                min(hor_five_r[i][j] + ver_five[i][j] - m_five[i][j], hor_two_r[i][j] + ver_two[i][j] - m_two[i][j]),\\n                min(hor_five[i][j] + ver_five_r[i][j] - m_five[i][j], hor_two[i][j] + ver_two_r[i][j] - m_two[i][j]),\\n                min(hor_five_r[i][j] + ver_five_r[i][j] - m_five[i][j], hor_two_r[i][j] + ver_two_r[i][j] - m_two[i][j]))\\n        return res\\n                \\n ```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        m_five = [[0] * n for _ in range(m)]\\n        m_two = [[0] * n for _ in range(m)]\\n        hor_five = [[0] * n for _ in range(m)]\\n        hor_five_r = [[0] * n for _ in range(m)]\\n        hor_two = [[0] * n for _ in range(m)]\\n        hor_two_r = [[0] * n for _ in range(m)]\\n        ver_five = [[0] * n for _ in range(m)]\\n        ver_five_r = [[0] * n for _ in range(m)]\\n        ver_two = [[0] * n for _ in range(m)]\\n        ver_two_r = [[0] * n for _ in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                x = grid[i][j]\\n                cnt = 0\\n\\n                if x % 5 == 0:\\n                    cnt += 1\\n                if x % 25 == 0:\\n                    cnt += 1\\n                if x % 125 == 0:\\n                    cnt += 1\\n                if x % 625 == 0:\\n                    cnt += 1\\n\\n                m_five[i][j] = cnt\\n                cnt = 0\\n                if x % 512 == 0:\\n                    cnt = 9\\n                elif x % 256 == 0:\\n                    cnt = 8\\n                elif x % 128 == 0:\\n                    cnt = 7\\n                elif x % 64 == 0:\\n                    cnt = 6\\n                elif x % 32 == 0:\\n                    cnt = 5\\n                elif x % 16 == 0:\\n                    cnt = 4\\n                elif x % 8 == 0:\\n                    cnt = 3\\n                elif x % 4 == 0:\\n                    cnt = 2\\n                elif x % 2 == 0:\\n                    cnt = 1\\n                m_two[i][j] = cnt\\n        for i in range(m):\\n            for j in range(n):\\n                if j == 0:\\n                    hor_two[i][j] = m_two[i][j]\\n                    hor_five[i][j] = m_five[i][j]\\n                else:\\n                    hor_two[i][j] = m_two[i][j] + hor_two[i][j - 1]\\n                    hor_five[i][j] = m_five[i][j] + hor_five[i][j - 1]\\n            cur_five = cur_two = 0\\n            for j in range(n - 1, -1, -1):\\n                if j == n - 1:\\n                    hor_two_r[i][j] = m_two[i][j]\\n                    hor_five_r[i][j] = m_five[i][j]\\n                else:\\n                    hor_two_r[i][j] = hor_two_r[i][j + 1] + m_two[i][j]\\n                    hor_five_r[i][j] = hor_five_r[i][j + 1] + m_five[i][j]\\n        \\n\\n        for j in range(n):\\n            for i in range(m):\\n                if i == 0:\\n                    ver_five[i][j] = m_five[i][j]\\n                    ver_two[i][j] = m_two[i][j]\\n                else:\\n                    ver_five[i][j] = m_five[i][j] + ver_five[i - 1][j]\\n                    ver_two[i][j] = m_two[i][j] + ver_two[i - 1][j]\\n            for i in range(m - 1, -1, -1):\\n                if i == m - 1:\\n                    ver_five_r[i][j] = m_five[i][j]\\n                    ver_two_r[i][j] = m_two[i][j]\\n                else:\\n                    ver_two_r[i][j] = m_two[i][j] + ver_two_r[i + 1][j]\\n                    ver_five_r[i][j] = m_five[i][j] +ver_five_r[i + 1][j]\\n        \\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                res = max(res, min(hor_five[i][j] + ver_five[i][j] - m_five[i][j], hor_two[i][j] + ver_two[i][j] - m_two[i][j]),\\n                min(hor_five_r[i][j] + ver_five[i][j] - m_five[i][j], hor_two_r[i][j] + ver_two[i][j] - m_two[i][j]),\\n                min(hor_five[i][j] + ver_five_r[i][j] - m_five[i][j], hor_two[i][j] + ver_two_r[i][j] - m_two[i][j]),\\n                min(hor_five_r[i][j] + ver_five_r[i][j] - m_five[i][j], hor_two_r[i][j] + ver_two_r[i][j] - m_two[i][j]))\\n        return res\\n                \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1955336,
                "title": "help-me-troubleshoot-it",
                "content": "Here is my code\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        accumlatedProduct = [[[1,1] for i in range(m)] for j in range(n)] # ahp,avp\\n        for i in range(n):\\n            for k in range(m):\\n                tem = grid[i][k]\\n                if k==0:\\n                    accumlatedProduct[i][k][0] = tem\\n                else:\\n                    accumlatedProduct[i][k][0] = accumlatedProduct[i][k-1][0]*tem\\n                if i==0:\\n                    accumlatedProduct[i][k][1] = tem\\n                else:\\n                    accumlatedProduct[i][k][1] = accumlatedProduct[i-1][k][1]*tem\\n        res = 0\\n        for i in range(n):\\n            for k in range(m):\\n                p1 = accumlatedProduct[i][k][0]*accumlatedProduct[i][k][1]/grid[i][k]\\n                p2 = accumlatedProduct[i][k][0]*accumlatedProduct[n-1][k][1]/accumlatedProduct[i][k][1]\\n                p3 = accumlatedProduct[i][m-1][0]/accumlatedProduct[i][k][0]*accumlatedProduct[i][k][1]\\n                p4 = accumlatedProduct[i][m-1][0]/accumlatedProduct[i][k][0]*accumlatedProduct[n-1][k][1]/accumlatedProduct[i][k][1]*grid[i][k]\\n                print(p1,p2,p3,p4)\\n                res = max(res,self.CountTrailingZeros(p1),self.CountTrailingZeros(p2),self.CountTrailingZeros(p3),self.CountTrailingZeros(p4))\\n        return res\\n    def CountTrailingZeros(self,i):\\n        if i ==0:\\n            return 0\\n        if i%10==0:\\n            return 1+self.CountTrailingZeros(i/10)\\n        else:\\n            return 0\\n```\\n\\nI am using accumulated Product and center to calculate the product,\\n\\nbut i was stuck at this test case \\n\\n```\\n[[824,709,193,413,701,836,727],\\n    [135,844,599,211,140,933,205],\\n    [329,68,285,282,301,387,231],\\n    [293,210,478,352,946,902,137],\\n    [806,900,290,636,589,522,611],\\n    [450,568,990,592,992,128,92],\\n    [780,653,795,457,980,942,927],\\n    [849,901,604,906,912,866,688]]\\n```\\n\\nI looked at it and couldn\\'t find the product with 6 zeros\\n\\nanyone can help me with that?",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        accumlatedProduct = [[[1,1] for i in range(m)] for j in range(n)] # ahp,avp\\n        for i in range(n):\\n            for k in range(m):\\n                tem = grid[i][k]\\n                if k==0:\\n                    accumlatedProduct[i][k][0] = tem\\n                else:\\n                    accumlatedProduct[i][k][0] = accumlatedProduct[i][k-1][0]*tem\\n                if i==0:\\n                    accumlatedProduct[i][k][1] = tem\\n                else:\\n                    accumlatedProduct[i][k][1] = accumlatedProduct[i-1][k][1]*tem\\n        res = 0\\n        for i in range(n):\\n            for k in range(m):\\n                p1 = accumlatedProduct[i][k][0]*accumlatedProduct[i][k][1]/grid[i][k]\\n                p2 = accumlatedProduct[i][k][0]*accumlatedProduct[n-1][k][1]/accumlatedProduct[i][k][1]\\n                p3 = accumlatedProduct[i][m-1][0]/accumlatedProduct[i][k][0]*accumlatedProduct[i][k][1]\\n                p4 = accumlatedProduct[i][m-1][0]/accumlatedProduct[i][k][0]*accumlatedProduct[n-1][k][1]/accumlatedProduct[i][k][1]*grid[i][k]\\n                print(p1,p2,p3,p4)\\n                res = max(res,self.CountTrailingZeros(p1),self.CountTrailingZeros(p2),self.CountTrailingZeros(p3),self.CountTrailingZeros(p4))\\n        return res\\n    def CountTrailingZeros(self,i):\\n        if i ==0:\\n            return 0\\n        if i%10==0:\\n            return 1+self.CountTrailingZeros(i/10)\\n        else:\\n            return 0\\n```\n```\\n[[824,709,193,413,701,836,727],\\n    [135,844,599,211,140,933,205],\\n    [329,68,285,282,301,387,231],\\n    [293,210,478,352,946,902,137],\\n    [806,900,290,636,589,522,611],\\n    [450,568,990,592,992,128,92],\\n    [780,653,795,457,980,942,927],\\n    [849,901,604,906,912,866,688]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955330,
                "title": "prefix-sum-approach-c-comments",
                "content": "```\\n// Approach - We know basic idea about how to form 10 i.e. 5 * 2\\n// So thats it we use the same idea here we calculate 5\\'s and 2\\'s in division of each grid element \\n// and maintain sum array\\n\\n\\n// sum[n][m][2] --> 0 --> Number of 5\\'s and 1 --> Number of 2\\'s \\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    // Utility function to get frequency of divisor forming the number \\n    int getIt(int n,int p)\\n    {\\n        int ans = 0;\\n        while(n > 0)\\n        {\\n            if(n % p != 0)break;\\n            ans++;\\n            n/=p;\\n        }\\n        return ans;\\n    }\\n\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        // Row wise Prefix Sum \\n        int sum[n+1][m+1][2];\\n        memset(sum,0,sizeof sum);\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                sum[i][j][0] = getIt(grid[i-1][j-1],2);\\n                sum[i][j][1] = getIt(grid[i-1][j-1],5);\\n            }\\n        }\\n\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++)\\n            {\\n                sum[i][j][0] += sum[i][j-1][0];\\n                sum[i][j][1] += sum[i][j-1][1];\\n            }\\n        }\\n\\n        // :------------------------------------------------->\\n\\n         // Column Wise Prefix Sum\\n        int sum2[n+1][m+1][2];\\n        memset(sum2,0,sizeof sum2);\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                sum2[i][j][0] = getIt(grid[i-1][j-1],2);\\n                sum2[i][j][1] = getIt(grid[i-1][j-1],5);\\n            }\\n        }\\n\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++)\\n            {\\n                sum2[i][j][0] += sum2[i-1][j][0];\\n                sum2[i][j][1] += sum2[i-1][j][1];\\n            }\\n        }\\n\\n\\n        // :---------------------------------------------->\\n\\n        // Cheap Variable to Store Answer\\n        int ans = 0;\\n\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n\\n                // Current Grid Element\\n                int x = sum[i][j][0] - sum[i][j-1][0];\\n                int y = sum[i][j][1] - sum[i][j-1][1];\\n\\n                // Take all possible answers considering current grid element as corner\\n\\n                // Convention --> L1, L2,R1,R2,U1,U2,D1,D2\\n                // 1 --> Number is 5\\'s\\n                // 2 --> Number of 2\\'s\\n\\n                // Left\\n                int L1 = sum[i][j-1][0];\\n                int L2 = sum[i][j-1][1];\\n\\n                // Right\\n                int R1 = sum[i][m][0] - sum[i][j][0];\\n                int R2 = sum[i][m][1] - sum[i][j][1];\\n\\n                // Up\\n                int U1 = sum2[i-1][j][0];\\n                int U2 = sum2[i-1][j][1];\\n\\n                // Down\\n                int D1 = sum2[n][j][0] - sum2[i][j][0];\\n                int D2 = sum2[n][j][1] - sum2[i][j][1];\\n\\n                // Our duty to calculate max answer\\n                // Max answer will be the min(No of 5\\'s, No of 2\\'s) in the cornered Path\\n                ans = max(ans,min(L1 + x + U1, L2 + y + U2));\\n                ans = max(ans,min(L1 + x + D1, L2 + y + D2));\\n\\n                ans = max(ans,min(R1 + x + U1, R2 + y + U2));\\n                ans = max(ans,min(R1 + x + D1, R2 + y + D2));\\n\\n\\n            }\\n        }\\n        \\n        // Hey, We just did it, Now its time to return\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n\\n    // Utility function to get frequency of divisor forming the number \\n    int getIt(int n,int p)\\n    {\\n        int ans = 0;\\n        while(n > 0)\\n        {\\n            if(n % p != 0)break;\\n            ans++;\\n            n/=p;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3836085,
                "title": "python3-vectorized-solution",
                "content": "I hope this answer is helpful to those who prefer more formal explanations (like myself).\\n___\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI made the following two observations:\\n1. Let $g(x)$ denote the number of trailing zeros of a number $x$. Then \\n$g(x) = \\\\min_{p\\\\in\\\\{2,5\\\\}} f(x,p),$ \\nwhere $f(x, p)$ is the number of times that prime number $p$ appears in the prime factorization of $x$.\\n2. The solution can always be represented by a cornered path which extends all the way to the edges of the grid. This is because the entries are non-negative, and so adding more cells can never harm the solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDefine a _leg_ $(i,j,d)$ to be a path of cells from (_excluding_) $(i,j)$ to the edge of the grid, following direction $d\\\\in\\\\{{\\\\rm up,down,left,right}\\\\}$. WLOG, we only consider cornered paths which extend all the way to the edges of the grid, so that each cornered path can be decomposed into a corner and two legs. We encode each cornered path by a tuple $(i,j,d_1,d_2)$, where $(i,j)$ is the location of the path\\'s corner, and $(d_1,d_2)$ are the directions of the its legs, $(i,j,d_1)$ and $(i,j,d_2)$.\\n\\nDefine the _gain_ $g(\\\\pi)$ of $\\\\pi$ to be the number of trailing zeros in the product of the path, i.e. $g(\\\\pi) = g(\\\\Pi_{ij\\\\in\\\\pi}x_{ij})$, and let $f(\\\\pi, p) = \\\\sum_{ij\\\\in\\\\pi} f(x_{ij}, p)$ be the number of times prime number $p$ appears along a path $\\\\pi$. Then,\\n$g(\\\\pi) = g(\\\\Pi_{ij\\\\in\\\\pi}x_{ij}) \\\\\\\\ = \\\\min_{p\\\\in\\\\{2,5\\\\}} f(\\\\Pi_{ij\\\\in\\\\pi}x_{ij}, p) \\\\\\\\ = \\\\min_{p\\\\in\\\\{2,5\\\\}} \\\\sum_{ij\\\\in\\\\pi} f(x_{ij}, p) \\\\\\\\ = \\\\min_{p\\\\in\\\\{2,5\\\\}} f(\\\\pi, p).$\\nOur objective is to find a cornered path $\\\\pi$ which maximizes $g(\\\\pi)$. First, we need to compute $f(\\\\pi, p)$ for all cornered paths $\\\\pi$ and $p\\\\in\\\\{2,5\\\\}$.\\n\\nNotice that, for a cornered path, $\\\\pi=(i,j,d_1,d_2)$, the quantity $f(\\\\pi,p)$ can be decomposed over $\\\\pi$\\'s corner and two legs:\\n$f((i,j,d_1,d_2), p) = f(x_{ij}, p) + f((i,j,d_1), p) + f((i,j,d_2), p).$\\n\\nThese leg counts, $f((i,j,d), p)$, are our building blocks, so I computed them for each possible leg $(i,j,d)$. Since a leg may be a sub-leg of a longer leg, I stored and reused intermediate results in a dynamic programming style. I then used these leg counts to compute $f(\\\\pi, 2)$ and $f(\\\\pi, 5)$ for each possible cornered path $\\\\pi$, which together yield $g(\\\\pi)$. Finally, I computed $\\\\max_\\\\pi g(\\\\pi)$ by searching over all cornered paths $\\\\pi$. Crucially, I vectorized this search over $(i,j)$ using NumPy; without doing so, my solution exceeded the time limit.\\n\\n# Complexity\\n- Time complexity: $O(mn)$, because $O(1)$ visits per cell\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(mn)$, because $O(1)$ values stored per cell\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport numpy as np\\n\\n# directions\\nU = 0 # Up\\nD = 1 # Down\\nL = 2 # Left\\nR = 3 # Right\\nN_dir = 4\\n\\n# factors\\nT = 0 # Two\\nF = 1 # Five\\nN_fac = 2\\n\\ndef f(x, p):\\n    \\'\\'\\'returns the highest power of `p` that divides `x`\\'\\'\\'\\n    c = 0\\n    while x % p == 0:\\n        c += 1\\n        x //= p\\n    return c\\n\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        grid = np.array(grid)\\n\\n        # y[i, j, p] = \\n        #   highest power of `p` that divides `grid[i, j]`\\n        y = np.zeros((m, n, N_fac), dtype=int)\\n        for i in range(m):\\n            for j in range(n):\\n                y[i, j, T] = f(grid[i, j], 2)\\n                y[i, j, F] = f(grid[i, j], 5)\\n\\n        # x[i, j, d, p] = \\n        #   count of times that `p` appears in leg `(i,j,d)`\\n        x = np.zeros((m, n, N_dir, N_fac), dtype=int)\\n        for i in range(m):\\n            for j in range(n):\\n                if i > 0:\\n                    x[i, j, U] = y[i-1, j] + x[i-1, j, U]\\n                    x[m-1-i, j, D] = y[m-i, j] + x[m-i, j, D]\\n                if j > 0:\\n                    x[i, j, L] = y[i, j-1] + x[i, j-1, L]\\n                    x[i, n-1-j, R] = y[i, n-j] + x[i, n-j, R]\\n\\n        # the cornered path\\'s legs can be oriented in one of four ways\\n        path_orientations = [(U,R), (U,L), (D,R), (D,L)]\\n\\n        # for each orientation `(d1, d2)`, \\n        #   for each corner `(i, j)` (vectorized):\\n        #       find the the number of trailing zeros in the product\\n        #       of the path `(i, j, d1, d2)`.\\n        #   max-reduce over corners (vectorized)\\n        # max-reduce over orientations.\\n        return max(\\n            (y + x[:, :, d1] + x[:, :, d2]).min(-1).max()\\n            for d1, d2 in path_orientations\\n        )\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\n\\n# directions\\nU = 0 # Up\\nD = 1 # Down\\nL = 2 # Left\\nR = 3 # Right\\nN_dir = 4\\n\\n# factors\\nT = 0 # Two\\nF = 1 # Five\\nN_fac = 2\\n\\ndef f(x, p):\\n    \\'\\'\\'returns the highest power of `p` that divides `x`\\'\\'\\'\\n    c = 0\\n    while x % p == 0:\\n        c += 1\\n        x //= p\\n    return c\\n\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        grid = np.array(grid)\\n\\n        # y[i, j, p] = \\n        #   highest power of `p` that divides `grid[i, j]`\\n        y = np.zeros((m, n, N_fac), dtype=int)\\n        for i in range(m):\\n            for j in range(n):\\n                y[i, j, T] = f(grid[i, j], 2)\\n                y[i, j, F] = f(grid[i, j], 5)\\n\\n        # x[i, j, d, p] = \\n        #   count of times that `p` appears in leg `(i,j,d)`\\n        x = np.zeros((m, n, N_dir, N_fac), dtype=int)\\n        for i in range(m):\\n            for j in range(n):\\n                if i > 0:\\n                    x[i, j, U] = y[i-1, j] + x[i-1, j, U]\\n                    x[m-1-i, j, D] = y[m-i, j] + x[m-i, j, D]\\n                if j > 0:\\n                    x[i, j, L] = y[i, j-1] + x[i, j-1, L]\\n                    x[i, n-1-j, R] = y[i, n-j] + x[i, n-j, R]\\n\\n        # the cornered path\\'s legs can be oriented in one of four ways\\n        path_orientations = [(U,R), (U,L), (D,R), (D,L)]\\n\\n        # for each orientation `(d1, d2)`, \\n        #   for each corner `(i, j)` (vectorized):\\n        #       find the the number of trailing zeros in the product\\n        #       of the path `(i, j, d1, d2)`.\\n        #   max-reduce over corners (vectorized)\\n        # max-reduce over orientations.\\n        return max(\\n            (y + x[:, :, d1] + x[:, :, d2]).min(-1).max()\\n            for d1, d2 in path_orientations\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434707,
                "title": "javascript-simple-array",
                "content": "# Complexity\\n- Time complexity: $$O(n*n)$$\\n- Space complexity: $$O(n*n)$$\\n\\n# Code\\n```\\nvar maxTrailingZeros = function(grid) {\\n    const n = grid.length, m = grid[0].length;\\n    const rowWise = Array.from({ length: n }, () => Array(m)),\\n      columnWise = Array.from({ length: n }, () => Array(m));\\n\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            grid[i][j] = [getFactorsCount(grid[i][j], 2), getFactorsCount(grid[i][j], 5)];\\n            rowWise[i][j] = [(j > 0 ? rowWise[i][j - 1][0] : 0) + grid[i][j][0],\\n                (j > 0 ? rowWise[i][j - 1][1] : 0) + grid[i][j][1]];\\n            columnWise[i][j] = [(i > 0 ? columnWise[i - 1][j][0] : 0) + grid[i][j][0],\\n                (i > 0 ? columnWise[i - 1][j][1] : 0) + grid[i][j][1]];\\n        }\\n    }\\n    \\n    function getFactorsCount(value, factor) {\\n        let count = 0;\\n        while(value % factor == 0) count++, value /= factor;\\n        return count;\\n    }\\n\\n    let maxTrailingZeros = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            const top = columnWise[i - 1]?.[j] ?? [0, 0];\\n            const left = rowWise[i][j - 1] ?? [0, 0];\\n            const right = [rowWise[i].at(-1)[0] - rowWise[i][j][0],\\n                rowWise[i].at(-1)[1] - rowWise[i][j][1]];\\n            const bottom = [columnWise.at(-1)[j][0] - columnWise[i][j][0],\\n                columnWise.at(-1)[j][1] - columnWise[i][j][1]];\\n\\n            const allDirections = [top, left, right, bottom];            \\n            for (let k = 0; k < 4; k++) {\\n                for (let l = 0; l < 4; l++) {\\n                    if (k == l) continue;\\n                    maxTrailingZeros = Math.max(maxTrailingZeros, \\n                        Math.min(allDirections[k][0] + allDirections[l][0] + grid[i][j][0], \\n                            allDirections[k][1] + allDirections[l][1] + grid[i][j][1]));\\n                }\\n            }\\n        }\\n    }\\n\\n    return maxTrailingZeros;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nvar maxTrailingZeros = function(grid) {\\n    const n = grid.length, m = grid[0].length;\\n    const rowWise = Array.from({ length: n }, () => Array(m)),\\n      columnWise = Array.from({ length: n }, () => Array(m));\\n\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            grid[i][j] = [getFactorsCount(grid[i][j], 2), getFactorsCount(grid[i][j], 5)];\\n            rowWise[i][j] = [(j > 0 ? rowWise[i][j - 1][0] : 0) + grid[i][j][0],\\n                (j > 0 ? rowWise[i][j - 1][1] : 0) + grid[i][j][1]];\\n            columnWise[i][j] = [(i > 0 ? columnWise[i - 1][j][0] : 0) + grid[i][j][0],\\n                (i > 0 ? columnWise[i - 1][j][1] : 0) + grid[i][j][1]];\\n        }\\n    }\\n    \\n    function getFactorsCount(value, factor) {\\n        let count = 0;\\n        while(value % factor == 0) count++, value /= factor;\\n        return count;\\n    }\\n\\n    let maxTrailingZeros = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            const top = columnWise[i - 1]?.[j] ?? [0, 0];\\n            const left = rowWise[i][j - 1] ?? [0, 0];\\n            const right = [rowWise[i].at(-1)[0] - rowWise[i][j][0],\\n                rowWise[i].at(-1)[1] - rowWise[i][j][1]];\\n            const bottom = [columnWise.at(-1)[j][0] - columnWise[i][j][0],\\n                columnWise.at(-1)[j][1] - columnWise[i][j][1]];\\n\\n            const allDirections = [top, left, right, bottom];            \\n            for (let k = 0; k < 4; k++) {\\n                for (let l = 0; l < 4; l++) {\\n                    if (k == l) continue;\\n                    maxTrailingZeros = Math.max(maxTrailingZeros, \\n                        Math.min(allDirections[k][0] + allDirections[l][0] + grid[i][j][0], \\n                            allDirections[k][1] + allDirections[l][1] + grid[i][j][1]));\\n                }\\n            }\\n        }\\n    }\\n\\n    return maxTrailingZeros;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3356380,
                "title": "c-prefix-sum",
                "content": "# Code\\n```\\nclass Solution {\\n    int numOfFact(int n, int x) {\\n        int count = 0;\\n        while(n % x == 0) {\\n            count++;\\n            n /= x;\\n        }\\n        return count;\\n    }\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), ans = 0;\\n        vector<vector<pair<int, int>>> h(m + 1, vector<pair<int, int>>(n + 1));\\n        vector<vector<pair<int, int>>> v(m + 1, vector<pair<int, int>>(n + 1));\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                h[i + 1][j + 1].first = h[i + 1][j].first + numOfFact(grid[i][j], 2);  \\n                h[i + 1][j + 1].second = h[i + 1][j].second + numOfFact(grid[i][j], 5); \\n                v[i + 1][j + 1].first = v[i][j + 1].first + numOfFact(grid[i][j], 2);  \\n                v[i + 1][j + 1].second = v[i][j + 1].second + numOfFact(grid[i][j], 5); \\n            }\\n        }\\n        pair<int, int> h1, h2, v1, v2;\\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                h1 = {h[i][j - 1].first, h[i][j - 1].second};\\n                h2 = {h[i][n].first - h[i][j].first, h[i][n].second - h[i][j].second};\\n                v1 = {v[i][j].first, v[i][j].second};\\n                v2 = {v[m][j].first - v[i - 1][j].first, v[m][j].second - v[i - 1][j].second};\\n                ans = max(ans, min(v1.first + h1.first, v1.second + h1.second));\\n                ans = max(ans, min(v1.first + h2.first, v1.second + h2.second));\\n                ans = max(ans, min(v2.first + h1.first, v2.second + h1.second));\\n                ans = max(ans, min(v2.first + h2.first, v2.second + h2.second));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    int numOfFact(int n, int x) {\\n        int count = 0;\\n        while(n % x == 0) {\\n            count++;\\n            n /= x;\\n        }\\n        return count;\\n    }\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), ans = 0;\\n        vector<vector<pair<int, int>>> h(m + 1, vector<pair<int, int>>(n + 1));\\n        vector<vector<pair<int, int>>> v(m + 1, vector<pair<int, int>>(n + 1));\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                h[i + 1][j + 1].first = h[i + 1][j].first + numOfFact(grid[i][j], 2);  \\n                h[i + 1][j + 1].second = h[i + 1][j].second + numOfFact(grid[i][j], 5); \\n                v[i + 1][j + 1].first = v[i][j + 1].first + numOfFact(grid[i][j], 2);  \\n                v[i + 1][j + 1].second = v[i][j + 1].second + numOfFact(grid[i][j], 5); \\n            }\\n        }\\n        pair<int, int> h1, h2, v1, v2;\\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                h1 = {h[i][j - 1].first, h[i][j - 1].second};\\n                h2 = {h[i][n].first - h[i][j].first, h[i][n].second - h[i][j].second};\\n                v1 = {v[i][j].first, v[i][j].second};\\n                v2 = {v[m][j].first - v[i - 1][j].first, v[m][j].second - v[i - 1][j].second};\\n                ans = max(ans, min(v1.first + h1.first, v1.second + h1.second));\\n                ans = max(ans, min(v1.first + h2.first, v1.second + h2.second));\\n                ans = max(ans, min(v2.first + h1.first, v2.second + h1.second));\\n                ans = max(ans, min(v2.first + h2.first, v2.second + h2.second));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270259,
                "title": "1464-ms",
                "content": "```ruby\\ndef max_trailing_zeros v\\n    y, x = v.size, v[0].size\\n    m, h = 0, Array.new(y) { [0] * x }\\n    for i in 0...y\\n        h2, h5 = 0, 0\\n        for j in 0...x\\n            d = v[i][j]\\n            x2, x5 = 0, 0\\n            (d >>= 1; x2 += 1) while (d & 1).zero?\\n            (d  /= 5; x5 += 1) while (d % 5).zero?\\n            h[i][j] = [h2 += x2, h5 += x5]\\n            if i > 0\\n                p2, p5 = *v[i - 1][j]\\n                x2 += p2; x5 += p5\\n            end\\n            v[i][j] = [x2, x5]\\n        end\\n    end\\n    for i in 0...y\\n        r2, r5 = *h[i][-1]\\n        for j in 0...x\\n             v2,  v5 = *v[-1][j]\\n            cv2, cv5 = *v[i][j]\\n            ch2, ch5 = *h[i][j]\\n            j > 0 ?\\n                (lh2, lh5 = *h[i][j - 1]) :\\n                (lh2, lh5 = 0, 0)\\n            m = [m,\\n                 [lh2 + cv2,\\n                  lh5 + cv5].min,\\n                 [cv2 + r2 - ch2,\\n                  cv5 + r5 - ch5].min,\\n                 [ch2 + v2 - cv2,\\n                  ch5 + v5 - cv5].min,\\n                 [r2 - lh2 + v2 - cv2,\\n                  r5 - lh5 + v5 - cv5].min\\n            ].max\\n        end\\n    end\\n    m\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef max_trailing_zeros v\\n    y, x = v.size, v[0].size\\n    m, h = 0, Array.new(y) { [0] * x }\\n    for i in 0...y\\n        h2, h5 = 0, 0\\n        for j in 0...x\\n            d = v[i][j]\\n            x2, x5 = 0, 0\\n            (d >>= 1; x2 += 1) while (d & 1).zero?\\n            (d  /= 5; x5 += 1) while (d % 5).zero?\\n            h[i][j] = [h2 += x2, h5 += x5]\\n            if i > 0\\n                p2, p5 = *v[i - 1][j]\\n                x2 += p2; x5 += p5\\n            end\\n            v[i][j] = [x2, x5]\\n        end\\n    end\\n    for i in 0...y\\n        r2, r5 = *h[i][-1]\\n        for j in 0...x\\n             v2,  v5 = *v[-1][j]\\n            cv2, cv5 = *v[i][j]\\n            ch2, ch5 = *h[i][j]\\n            j > 0 ?\\n                (lh2, lh5 = *h[i][j - 1]) :\\n                (lh2, lh5 = 0, 0)\\n            m = [m,\\n                 [lh2 + cv2,\\n                  lh5 + cv5].min,\\n                 [cv2 + r2 - ch2,\\n                  cv5 + r5 - ch5].min,\\n                 [ch2 + v2 - cv2,\\n                  ch5 + v5 - cv5].min,\\n                 [r2 - lh2 + v2 - cv2,\\n                  r5 - lh5 + v5 - cv5].min\\n            ].max\\n        end\\n    end\\n    m\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3074006,
                "title": "python",
                "content": "\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid) :\\n        matrix = grid \\n        self.ans,prefix,suffix = 0,[i[:] for i in matrix ],[i[:] for i in matrix ]\\n      \\n        def f(n):\\n            x,y =0,0\\n            while n%2==0:\\n                n = n//2\\n                x+=1\\n            while n% 5==0:\\n                n = n // 5\\n                y+=1\\n            return x,y\\n\\n        for i in prefix:\\n            for n,v in enumerate(i):\\n                if n==0 : i[0] =f(v)\\n                else:\\n                    x,y = f(v)\\n                    a,b = i[n-1]\\n                    i[n]=x+a,y+b\\n\\n        for i in suffix :\\n            for n in range(len(i)-1,-1,-1):\\n                if n == len(i)-1:i[n]=f(i[n])\\n                else:\\n                    x,y = f(i[n])\\n                    a,b= i[n+1]\\n                    i[n]=x+a,y+b\\n\\n        for j in range(len(matrix[0])):\\n            two,five =0,0\\n            for i in range(len(matrix)):\\n                self.ans = max(self.ans,min(two+prefix[i][j][0],five + prefix[i][j][1]))\\n                self.ans = max(self.ans , min(two + suffix[i][j][0] , five + suffix[i][j][1]))\\n\\n                x,y = f(matrix[i][j])\\n                two +=x\\n                five +=y \\n            \\n            two,five = 0,0\\n            for i in range(len(matrix)-1,-1,-1):\\n                self.ans = max(self.ans,min(two+prefix[i][j][0],five + prefix[i][j][1]))\\n                self.ans = max(self.ans , min(two + suffix[i][j][0] , five + suffix[i][j][1]))\\n                x,y = f(matrix[i][j])\\n                two +=x\\n                five +=y \\n      \\n        return self.ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid) :\\n        matrix = grid \\n        self.ans,prefix,suffix = 0,[i[:] for i in matrix ],[i[:] for i in matrix ]\\n      \\n        def f(n):\\n            x,y =0,0\\n            while n%2==0:\\n                n = n//2\\n                x+=1\\n            while n% 5==0:\\n                n = n // 5\\n                y+=1\\n            return x,y\\n\\n        for i in prefix:\\n            for n,v in enumerate(i):\\n                if n==0 : i[0] =f(v)\\n                else:\\n                    x,y = f(v)\\n                    a,b = i[n-1]\\n                    i[n]=x+a,y+b\\n\\n        for i in suffix :\\n            for n in range(len(i)-1,-1,-1):\\n                if n == len(i)-1:i[n]=f(i[n])\\n                else:\\n                    x,y = f(i[n])\\n                    a,b= i[n+1]\\n                    i[n]=x+a,y+b\\n\\n        for j in range(len(matrix[0])):\\n            two,five =0,0\\n            for i in range(len(matrix)):\\n                self.ans = max(self.ans,min(two+prefix[i][j][0],five + prefix[i][j][1]))\\n                self.ans = max(self.ans , min(two + suffix[i][j][0] , five + suffix[i][j][1]))\\n\\n                x,y = f(matrix[i][j])\\n                two +=x\\n                five +=y \\n            \\n            two,five = 0,0\\n            for i in range(len(matrix)-1,-1,-1):\\n                self.ans = max(self.ans,min(two+prefix[i][j][0],five + prefix[i][j][1]))\\n                self.ans = max(self.ans , min(two + suffix[i][j][0] , five + suffix[i][j][1]))\\n                x,y = f(matrix[i][j])\\n                two +=x\\n                five +=y \\n      \\n        return self.ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070619,
                "title": "python-simple-solution-o-mn",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        def factors(num):\\n            res = [0,0]\\n            while num > 1 and num%2 == 0:\\n                num //= 2\\n                res[0] += 1\\n            while num > 1 and num%5 == 0:\\n                num //= 5\\n                res[1] += 1\\n            return res\\n        def zeros(a, b, c):\\n            return min(a[0]+b[0]-c[0], a[1]+b[1]-c[1])\\n        m, n = len(grid), len(grid[0])\\n        UD = [[0 for i in range(n)] for _ in range(m)]\\n        LR = [[0 for i in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                UD[i][j] = factors(grid[i][j])\\n                LR[i][j] = factors(grid[i][j])\\n                UD[i][j][0] += UD[i-1][j][0] if i else 0\\n                UD[i][j][1] += UD[i-1][j][1] if i else 0\\n                LR[i][j][0] += LR[i][j-1][0] if j else 0\\n                LR[i][j][1] += LR[i][j-1][1] if j else 0\\n        DU = [[0 for i in range(n)] for _ in range(m)]\\n        RL = [[0 for i in range(n)] for _ in range(m)]\\n        for i in range(m-1,-1,-1):\\n            for j in range(n-1,-1,-1):\\n                DU[i][j] = factors(grid[i][j])\\n                RL[i][j] = factors(grid[i][j])\\n                DU[i][j][0] += DU[i+1][j][0] if i < m - 1 else 0\\n                DU[i][j][1] += DU[i+1][j][1] if i < m - 1 else 0\\n                RL[i][j][0] += RL[i][j+1][0] if j < n - 1 else 0\\n                RL[i][j][1] += RL[i][j+1][1] if j < n - 1 else 0\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                f = factors(grid[i][j])\\n                cur = max(zeros(UD[i][j],LR[i][j],f), zeros(UD[i][j],RL[i][j],f), zeros(DU[i][j],LR[i][j],f), zeros(DU[i][j],RL[i][j],f))\\n                res = max(res, cur)\\n        return res\\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        def factors(num):\\n            res = [0,0]\\n            while num > 1 and num%2 == 0:\\n                num //= 2\\n                res[0] += 1\\n            while num > 1 and num%5 == 0:\\n                num //= 5\\n                res[1] += 1\\n            return res\\n        def zeros(a, b, c):\\n            return min(a[0]+b[0]-c[0], a[1]+b[1]-c[1])\\n        m, n = len(grid), len(grid[0])\\n        UD = [[0 for i in range(n)] for _ in range(m)]\\n        LR = [[0 for i in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                UD[i][j] = factors(grid[i][j])\\n                LR[i][j] = factors(grid[i][j])\\n                UD[i][j][0] += UD[i-1][j][0] if i else 0\\n                UD[i][j][1] += UD[i-1][j][1] if i else 0\\n                LR[i][j][0] += LR[i][j-1][0] if j else 0\\n                LR[i][j][1] += LR[i][j-1][1] if j else 0\\n        DU = [[0 for i in range(n)] for _ in range(m)]\\n        RL = [[0 for i in range(n)] for _ in range(m)]\\n        for i in range(m-1,-1,-1):\\n            for j in range(n-1,-1,-1):\\n                DU[i][j] = factors(grid[i][j])\\n                RL[i][j] = factors(grid[i][j])\\n                DU[i][j][0] += DU[i+1][j][0] if i < m - 1 else 0\\n                DU[i][j][1] += DU[i+1][j][1] if i < m - 1 else 0\\n                RL[i][j][0] += RL[i][j+1][0] if j < n - 1 else 0\\n                RL[i][j][1] += RL[i][j+1][1] if j < n - 1 else 0\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                f = factors(grid[i][j])\\n                cur = max(zeros(UD[i][j],LR[i][j],f), zeros(UD[i][j],RL[i][j],f), zeros(DU[i][j],LR[i][j],f), zeros(DU[i][j],RL[i][j],f))\\n                res = max(res, cur)\\n        return res\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932118,
                "title": "simple-rust-solution",
                "content": "Enumerate corner cells, extend horizontally and vertically. There are four cornered paths to consider for each corner cell. Use prefix sum to quickly calculate zeros for each path.\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m*n)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn max_trailing_zeros(grid: Vec<Vec<i32>>) -> i32 {\\n        use std::ops::{Add, Sub};\\n\\n        let m = grid.len();\\n        let n = grid[0].len();\\n\\n        #[derive(Clone, Copy, Debug, Default)]\\n        struct Counts {\\n            count_2: i32,\\n            count_5: i32,\\n        }\\n\\n        impl Counts {\\n            fn zeros(&self) -> i32 {\\n                self.count_2.min(self.count_5)\\n            }\\n        }\\n\\n        impl Add for Counts {\\n            type Output = Self;\\n            fn add(self, rhs: Self) -> Self::Output {\\n                Self {\\n                    count_2: self.count_2 + rhs.count_2,\\n                    count_5: self.count_5 + rhs.count_5,\\n                }\\n            }\\n        }\\n\\n        impl Sub for Counts {\\n            type Output = Self;\\n            fn sub(self, rhs: Self) -> Self::Output {\\n                Self {\\n                    count_2: self.count_2 - rhs.count_2,\\n                    count_5: self.count_5 - rhs.count_5,\\n                }\\n            }\\n        }\\n\\n        let mut prime_count = vec![Counts::default(); 1001];\\n        for i in 2..=1000 {\\n            let mut count_2 = 0;\\n            let mut count_5 = 0;\\n            let mut k = i;\\n            while k % 2 == 0 {\\n                k /= 2;\\n                count_2 += 1;\\n            }\\n            while k % 5 == 0 {\\n                k /= 5;\\n                count_5 += 1;\\n            }\\n            prime_count[i] = Counts { count_2, count_5 };\\n        }\\n        let mut h_acc = vec![vec![Counts::default(); n + 1]; m + 1];\\n        let mut v_acc = vec![vec![Counts::default(); m + 1]; n + 1];\\n\\n        for row in 0..m {\\n            for col in 0..n {\\n                let count = prime_count[grid[row][col] as usize];\\n                h_acc[row][col + 1] = h_acc[row][col] + count;\\n                v_acc[col][row + 1] = v_acc[col][row] + count;\\n            }\\n        }\\n\\n        let mut res = 0;\\n\\n        for row in 0..m {\\n            for col in 0..n {\\n                let top = v_acc[col][row];\\n                let bottom = v_acc[col][m] - v_acc[col][row + 1];\\n                let left = h_acc[row][col];\\n                let right = h_acc[row][n] - h_acc[row][col + 1];\\n                let current = prime_count[grid[row][col] as usize];\\n\\n                res = res.max(\\n                    (top + left + current).zeros()\\n                ).max(\\n                    (top + right + current).zeros()\\n                ).max(\\n                    (bottom + left + current).zeros()\\n                ).max(\\n                    (bottom + right + current).zeros()\\n                );\\n            }\\n        }\\n\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_trailing_zeros(grid: Vec<Vec<i32>>) -> i32 {\\n        use std::ops::{Add, Sub};\\n\\n        let m = grid.len();\\n        let n = grid[0].len();\\n\\n        #[derive(Clone, Copy, Debug, Default)]\\n        struct Counts {\\n            count_2: i32,\\n            count_5: i32,\\n        }\\n\\n        impl Counts {\\n            fn zeros(&self) -> i32 {\\n                self.count_2.min(self.count_5)\\n            }\\n        }\\n\\n        impl Add for Counts {\\n            type Output = Self;\\n            fn add(self, rhs: Self) -> Self::Output {\\n                Self {\\n                    count_2: self.count_2 + rhs.count_2,\\n                    count_5: self.count_5 + rhs.count_5,\\n                }\\n            }\\n        }\\n\\n        impl Sub for Counts {\\n            type Output = Self;\\n            fn sub(self, rhs: Self) -> Self::Output {\\n                Self {\\n                    count_2: self.count_2 - rhs.count_2,\\n                    count_5: self.count_5 - rhs.count_5,\\n                }\\n            }\\n        }\\n\\n        let mut prime_count = vec![Counts::default(); 1001];\\n        for i in 2..=1000 {\\n            let mut count_2 = 0;\\n            let mut count_5 = 0;\\n            let mut k = i;\\n            while k % 2 == 0 {\\n                k /= 2;\\n                count_2 += 1;\\n            }\\n            while k % 5 == 0 {\\n                k /= 5;\\n                count_5 += 1;\\n            }\\n            prime_count[i] = Counts { count_2, count_5 };\\n        }\\n        let mut h_acc = vec![vec![Counts::default(); n + 1]; m + 1];\\n        let mut v_acc = vec![vec![Counts::default(); m + 1]; n + 1];\\n\\n        for row in 0..m {\\n            for col in 0..n {\\n                let count = prime_count[grid[row][col] as usize];\\n                h_acc[row][col + 1] = h_acc[row][col] + count;\\n                v_acc[col][row + 1] = v_acc[col][row] + count;\\n            }\\n        }\\n\\n        let mut res = 0;\\n\\n        for row in 0..m {\\n            for col in 0..n {\\n                let top = v_acc[col][row];\\n                let bottom = v_acc[col][m] - v_acc[col][row + 1];\\n                let left = h_acc[row][col];\\n                let right = h_acc[row][n] - h_acc[row][col + 1];\\n                let current = prime_count[grid[row][col] as usize];\\n\\n                res = res.max(\\n                    (top + left + current).zeros()\\n                ).max(\\n                    (top + right + current).zeros()\\n                ).max(\\n                    (bottom + left + current).zeros()\\n                ).max(\\n                    (bottom + right + current).zeros()\\n                );\\n            }\\n        }\\n\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2891663,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int[][][] t = new int[grid.length][grid[0].length][8];\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int[][][] tf = new int[n][m][2];\\n        for(int i = 0; i<n;i++) {\\n            for(int j = 0 ; j<m ;j++) {\\n                int two = 0;\\n                int five = 0;\\n                int k = grid[i][j];\\n                while(k%2==0){\\n                    k/=2;\\n                    two++;\\n                }\\n                while(k%5==0){\\n                    k/=5;\\n                    five++;\\n                }\\n                tf[i][j][0] = two;\\n                tf[i][j][1] = five;\\n            }\\n        }\\n        for(int i = 0; i<n;i++) {\\n            int two = 0;\\n            int five = 0;\\n            for(int j = 0; j<m;j++) {\\n                int k = grid[i][j];\\n                while(k%2 == 0) {\\n                    two++;\\n                    k=k/2;\\n                }\\n                while(k%5 == 0) {\\n                    five++;\\n                    k=k/5;\\n                }\\n                t[i][j][0] = two;\\n                t[i][j][1] = five;\\n            }\\n        }\\n\\n\\n        for(int i = 0; i<n;i++) {\\n            int two = 0;\\n            int five = 0;\\n            for(int j = m-1; j>=0;j--) {\\n                int k = grid[i][j];\\n                while(k%2 == 0) {\\n                    two++;\\n                    k=k/2;\\n                }\\n                while(k%5 == 0) {\\n                    five++;\\n                    k=k/5;\\n                }\\n                t[i][j][2] = two;\\n                t[i][j][3] = five;\\n            }\\n        }\\n         for(int i = 0; i<m;i++) {\\n            int two = 0;\\n            int five = 0;\\n            for(int j = 0; j<n;j++) {\\n                int k = grid[j][i];\\n                while(k%2 == 0) {\\n                    two++;\\n                    k=k/2;\\n                }\\n                while(k%5 == 0) {\\n                    five++;\\n                    k=k/5;\\n                }\\n                t[j][i][4] = two;\\n                t[j][i][5] = five;\\n            }\\n        }\\n        for(int i = 0; i<m;i++) {\\n            int two = 0;\\n            int five = 0;\\n            for(int j = n-1; j>=0;j--) {\\n                int k = grid[j][i];\\n                while(k%2 == 0) {\\n                    two++;\\n                    k=k/2;\\n                }\\n                while(k%5 == 0) {\\n                    five++;\\n                    k=k/5;\\n                }\\n                t[j][i][6] = two;\\n                t[j][i][7] = five;\\n            }\\n        }\\n        int[][] ans = new int[n][m];\\n        int a = 0;\\n         for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<m ;j++) {\\n                ans[i][j] = Math.max(ans[i][j],Math.min(t[i][j][0] + t[i][j][4] - tf[i][j][0],t[i][j][1] + t[i][j][5] - tf[i][j][1])); //3\\n                ans[i][j] = Math.max(ans[i][j],Math.min(t[i][j][0] + t[i][j][6]- tf[i][j][0],t[i][j][1] + t[i][j][7]- tf[i][j][1]));\\n                ans[i][j] = Math.max(ans[i][j],Math.min(t[i][j][2] + t[i][j][4]- tf[i][j][0],t[i][j][3] + t[i][j][5]- tf[i][j][1]));\\n                ans[i][j] = Math.max(ans[i][j],Math.min(t[i][j][2] + t[i][j][6]- tf[i][j][0],t[i][j][3] + t[i][j][7]- tf[i][j][1]));\\n            a = Math.max(a,ans[i][j]);\\n            }\\n         }\\n         return a;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int[][][] t = new int[grid.length][grid[0].length][8];\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int[][][] tf = new int[n][m][2];\\n        for(int i = 0; i<n;i++) {\\n            for(int j = 0 ; j<m ;j++) {\\n                int two = 0;\\n                int five = 0;\\n                int k = grid[i][j];\\n                while(k%2==0){\\n                    k/=2;\\n                    two++;\\n                }\\n                while(k%5==0){\\n                    k/=5;\\n                    five++;\\n                }\\n                tf[i][j][0] = two;\\n                tf[i][j][1] = five;\\n            }\\n        }\\n        for(int i = 0; i<n;i++) {\\n            int two = 0;\\n            int five = 0;\\n            for(int j = 0; j<m;j++) {\\n                int k = grid[i][j];\\n                while(k%2 == 0) {\\n                    two++;\\n                    k=k/2;\\n                }\\n                while(k%5 == 0) {\\n                    five++;\\n                    k=k/5;\\n                }\\n                t[i][j][0] = two;\\n                t[i][j][1] = five;\\n            }\\n        }\\n\\n\\n        for(int i = 0; i<n;i++) {\\n            int two = 0;\\n            int five = 0;\\n            for(int j = m-1; j>=0;j--) {\\n                int k = grid[i][j];\\n                while(k%2 == 0) {\\n                    two++;\\n                    k=k/2;\\n                }\\n                while(k%5 == 0) {\\n                    five++;\\n                    k=k/5;\\n                }\\n                t[i][j][2] = two;\\n                t[i][j][3] = five;\\n            }\\n        }\\n         for(int i = 0; i<m;i++) {\\n            int two = 0;\\n            int five = 0;\\n            for(int j = 0; j<n;j++) {\\n                int k = grid[j][i];\\n                while(k%2 == 0) {\\n                    two++;\\n                    k=k/2;\\n                }\\n                while(k%5 == 0) {\\n                    five++;\\n                    k=k/5;\\n                }\\n                t[j][i][4] = two;\\n                t[j][i][5] = five;\\n            }\\n        }\\n        for(int i = 0; i<m;i++) {\\n            int two = 0;\\n            int five = 0;\\n            for(int j = n-1; j>=0;j--) {\\n                int k = grid[j][i];\\n                while(k%2 == 0) {\\n                    two++;\\n                    k=k/2;\\n                }\\n                while(k%5 == 0) {\\n                    five++;\\n                    k=k/5;\\n                }\\n                t[j][i][6] = two;\\n                t[j][i][7] = five;\\n            }\\n        }\\n        int[][] ans = new int[n][m];\\n        int a = 0;\\n         for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<m ;j++) {\\n                ans[i][j] = Math.max(ans[i][j],Math.min(t[i][j][0] + t[i][j][4] - tf[i][j][0],t[i][j][1] + t[i][j][5] - tf[i][j][1])); //3\\n                ans[i][j] = Math.max(ans[i][j],Math.min(t[i][j][0] + t[i][j][6]- tf[i][j][0],t[i][j][1] + t[i][j][7]- tf[i][j][1]));\\n                ans[i][j] = Math.max(ans[i][j],Math.min(t[i][j][2] + t[i][j][4]- tf[i][j][0],t[i][j][3] + t[i][j][5]- tf[i][j][1]));\\n                ans[i][j] = Math.max(ans[i][j],Math.min(t[i][j][2] + t[i][j][6]- tf[i][j][0],t[i][j][3] + t[i][j][7]- tf[i][j][1]));\\n            a = Math.max(a,ans[i][j]);\\n            }\\n         }\\n         return a;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2740583,
                "title": "java-concise-and-efficient-solution-explanation-included",
                "content": "```\\nclass Solution {\\n    \\n    public int maxTrailingZeros(int[][] grid) {\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        // twoAndFives[i][j][0] is the number of factor 2 of grid[i][j]\\n        // twoAndFives[i][j][1] is the number of factor 5 of grid[i][j]\\n        int[][][] twoAndFives = new int[rows][cols][2];\\n        \\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                int num = grid[i][j];\\n                int twos = 0;\\n                int fives = 0;\\n                while (num % 2 == 0) {\\n                    num /= 2;\\n                    twos++;\\n                }\\n                while (num % 5 == 0) {\\n                    num /= 5;\\n                    fives++;\\n                }\\n                twoAndFives[i][j] = new int[] {twos, fives};\\n            }\\n        }\\n        \\n        int[][] prefixRowTwo  = new int[rows][cols+1];\\n        int[][] prefixRowFive = new int[rows][cols+1];\\n        \\n        int[][] prefixColTwo  = new int[cols][rows+1];\\n        int[][] prefixColFive = new int[cols][rows+1];\\n\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                prefixRowTwo[i][j+1]  = prefixRowTwo[i][j]  + twoAndFives[i][j][0];\\n                prefixRowFive[i][j+1] = prefixRowFive[i][j] + twoAndFives[i][j][1];\\n            }\\n        }\\n        \\n        for (int j = 0; j < cols; j++) {\\n            for (int i = 0; i < rows; i++) {\\n                prefixColTwo[j][i+1]  = prefixColTwo[j][i]  + twoAndFives[i][j][0];\\n                prefixColFive[j][i+1] = prefixColFive[j][i] + twoAndFives[i][j][1];\\n            }\\n        }\\n        \\n        int max = 0;\\n        for (int i = 1; i <= rows; i++) {\\n            for (int j = 1; j <= cols; j++) {\\n                \\n                // Path: top-down then turn left\\n                max = Math.max(max, Math.min(prefixRowTwo[i-1][j] + prefixColTwo[j-1][i-1], prefixRowFive[i-1][j] + prefixColFive[j-1][i-1]));\\n                \\n                // Path: bottom-up then turn left\\n                max = Math.max(max, Math.min(prefixRowTwo[i-1][j] + prefixColTwo[j-1][rows] - prefixColTwo[j-1][i], prefixRowFive[i-1][j] + prefixColFive[j-1][rows] - prefixColFive[j-1][i]));\\n                \\n                // Path: top-down then turn right\\n                max = Math.max(max, Math.min(prefixRowTwo[i-1][cols] - prefixRowTwo[i-1][j] + prefixColTwo[j-1][i], prefixRowFive[i-1][cols] - prefixRowFive[i-1][j] + prefixColFive[j-1][i]));\\n                \\n                // Path: bottom-up then turn right\\n                max = Math.max(max, Math.min(prefixRowTwo[i-1][cols] - prefixRowTwo[i-1][j] + prefixColTwo[j-1][rows] - prefixColTwo[j-1][i-1], prefixRowFive[i-1][cols] -prefixRowFive[i-1][j] + prefixColFive[j-1][rows] - prefixColFive[j-1][i-1]));\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int maxTrailingZeros(int[][] grid) {\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        // twoAndFives[i][j][0] is the number of factor 2 of grid[i][j]\\n        // twoAndFives[i][j][1] is the number of factor 5 of grid[i][j]\\n        int[][][] twoAndFives = new int[rows][cols][2];\\n        \\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                int num = grid[i][j];\\n                int twos = 0;\\n                int fives = 0;\\n                while (num % 2 == 0) {\\n                    num /= 2;\\n                    twos++;\\n                }\\n                while (num % 5 == 0) {\\n                    num /= 5;\\n                    fives++;\\n                }\\n                twoAndFives[i][j] = new int[] {twos, fives};\\n            }\\n        }\\n        \\n        int[][] prefixRowTwo  = new int[rows][cols+1];\\n        int[][] prefixRowFive = new int[rows][cols+1];\\n        \\n        int[][] prefixColTwo  = new int[cols][rows+1];\\n        int[][] prefixColFive = new int[cols][rows+1];\\n\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                prefixRowTwo[i][j+1]  = prefixRowTwo[i][j]  + twoAndFives[i][j][0];\\n                prefixRowFive[i][j+1] = prefixRowFive[i][j] + twoAndFives[i][j][1];\\n            }\\n        }\\n        \\n        for (int j = 0; j < cols; j++) {\\n            for (int i = 0; i < rows; i++) {\\n                prefixColTwo[j][i+1]  = prefixColTwo[j][i]  + twoAndFives[i][j][0];\\n                prefixColFive[j][i+1] = prefixColFive[j][i] + twoAndFives[i][j][1];\\n            }\\n        }\\n        \\n        int max = 0;\\n        for (int i = 1; i <= rows; i++) {\\n            for (int j = 1; j <= cols; j++) {\\n                \\n                // Path: top-down then turn left\\n                max = Math.max(max, Math.min(prefixRowTwo[i-1][j] + prefixColTwo[j-1][i-1], prefixRowFive[i-1][j] + prefixColFive[j-1][i-1]));\\n                \\n                // Path: bottom-up then turn left\\n                max = Math.max(max, Math.min(prefixRowTwo[i-1][j] + prefixColTwo[j-1][rows] - prefixColTwo[j-1][i], prefixRowFive[i-1][j] + prefixColFive[j-1][rows] - prefixColFive[j-1][i]));\\n                \\n                // Path: top-down then turn right\\n                max = Math.max(max, Math.min(prefixRowTwo[i-1][cols] - prefixRowTwo[i-1][j] + prefixColTwo[j-1][i], prefixRowFive[i-1][cols] - prefixRowFive[i-1][j] + prefixColFive[j-1][i]));\\n                \\n                // Path: bottom-up then turn right\\n                max = Math.max(max, Math.min(prefixRowTwo[i-1][cols] - prefixRowTwo[i-1][j] + prefixColTwo[j-1][rows] - prefixColTwo[j-1][i-1], prefixRowFive[i-1][cols] -prefixRowFive[i-1][j] + prefixColFive[j-1][rows] - prefixColFive[j-1][i-1]));\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735149,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<pair<ll,ll>>> v(n,vector<pair<ll,ll>>(m,{0,0})),ltr,utd,rtl,dtu;\\n        \\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=0;j<m;j++)\\n            {\\n                ll z=grid[i][j],c1=0,c2=0;\\n                while(z%2==0)\\n                {\\n                    z/=2;\\n                    c1++;\\n                }\\n                while(z%5==0)\\n                {\\n                    z/=5;\\n                    c2++;\\n                }\\n                v[i][j].first=c1;\\n                v[i][j].second=c2;\\n            }\\n        }\\n        ltr=utd=rtl=dtu=v;\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=1;j<m;j++)\\n            {\\n                ltr[i][j].first+=ltr[i][j-1].first;\\n                ltr[i][j].second+=ltr[i][j-1].second;\\n            }\\n        }\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=m-2;j>=0;j--)\\n            {\\n                rtl[i][j].first+=rtl[i][j+1].first;\\n                rtl[i][j].second+=rtl[i][j+1].second;\\n            }\\n        }\\n        for(ll j=0;j<m;j++)\\n        {\\n            for(ll i=1;i<n;i++)\\n            {\\n                utd[i][j].first+=utd[i-1][j].first;\\n                utd[i][j].second+=utd[i-1][j].second;\\n            }\\n        }\\n        for(ll j=0;j<m;j++)\\n        {\\n            for(ll i=n-2;i>=0;i--)\\n            {\\n                dtu[i][j].first+=dtu[i+1][j].first;\\n                dtu[i][j].second+=dtu[i+1][j].second;\\n            }\\n        }\\n        ll ans=0;\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=0;j<m;j++)\\n            {\\n                ll c1,c2,c3,c4;\\n                ll x1,x2,x3,x4;\\n                ll a,b;\\n                a=v[i][j].first;\\n                b=v[i][j].second;       \\n                \\n                c1=ltr[i][j].first;\\n                c2=rtl[i][j].first;\\n                \\n                c3=utd[i][j].first;\\n                c4=dtu[i][j].first;\\n                \\n                x1=ltr[i][j].second;\\n                x2=rtl[i][j].second;\\n                \\n                x3=utd[i][j].second;\\n                x4=dtu[i][j].second;\\n                \\n                ans=max(ans,min(c3+c1-a,x3+x1-b));\\n                ans=max(ans,min(c3+c2-a,x3+x2-b));\\n                ans=max(ans,min(c4+c1-a,x4+x1-b));\\n                ans=max(ans,min(c4+c2-a,x4+x2-b));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<pair<ll,ll>>> v(n,vector<pair<ll,ll>>(m,{0,0})),ltr,utd,rtl,dtu;\\n        \\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=0;j<m;j++)\\n            {\\n                ll z=grid[i][j],c1=0,c2=0;\\n                while(z%2==0)\\n                {\\n                    z/=2;\\n                    c1++;\\n                }\\n                while(z%5==0)\\n                {\\n                    z/=5;\\n                    c2++;\\n                }\\n                v[i][j].first=c1;\\n                v[i][j].second=c2;\\n            }\\n        }\\n        ltr=utd=rtl=dtu=v;\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=1;j<m;j++)\\n            {\\n                ltr[i][j].first+=ltr[i][j-1].first;\\n                ltr[i][j].second+=ltr[i][j-1].second;\\n            }\\n        }\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=m-2;j>=0;j--)\\n            {\\n                rtl[i][j].first+=rtl[i][j+1].first;\\n                rtl[i][j].second+=rtl[i][j+1].second;\\n            }\\n        }\\n        for(ll j=0;j<m;j++)\\n        {\\n            for(ll i=1;i<n;i++)\\n            {\\n                utd[i][j].first+=utd[i-1][j].first;\\n                utd[i][j].second+=utd[i-1][j].second;\\n            }\\n        }\\n        for(ll j=0;j<m;j++)\\n        {\\n            for(ll i=n-2;i>=0;i--)\\n            {\\n                dtu[i][j].first+=dtu[i+1][j].first;\\n                dtu[i][j].second+=dtu[i+1][j].second;\\n            }\\n        }\\n        ll ans=0;\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=0;j<m;j++)\\n            {\\n                ll c1,c2,c3,c4;\\n                ll x1,x2,x3,x4;\\n                ll a,b;\\n                a=v[i][j].first;\\n                b=v[i][j].second;       \\n                \\n                c1=ltr[i][j].first;\\n                c2=rtl[i][j].first;\\n                \\n                c3=utd[i][j].first;\\n                c4=dtu[i][j].first;\\n                \\n                x1=ltr[i][j].second;\\n                x2=rtl[i][j].second;\\n                \\n                x3=utd[i][j].second;\\n                x4=dtu[i][j].second;\\n                \\n                ans=max(ans,min(c3+c1-a,x3+x1-b));\\n                ans=max(ans,min(c3+c2-a,x3+x2-b));\\n                ans=max(ans,min(c4+c1-a,x4+x1-b));\\n                ans=max(ans,min(c4+c2-a,x4+x2-b));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726335,
                "title": "efficient-use-of-prefix-sums-owing-to-votrubac",
                "content": "```\\narray<int, 2> operator+(const array<int, 2> &l, const array<int, 2> &r) { return { l[0] + r[0], l[1] + r[1] }; }\\narray<int, 2> operator-(const array<int, 2> &l, const array<int, 2> &r) { return { l[0] - r[0], l[1] - r[1] }; }\\n\\nint pairs(const array<int, 2> &p) { return min(p[0], p[1]); }\\n\\nclass Solution {\\npublic:\\n    int factors(int i, int f) {\\n        return i % f ? 0 : 1 + factors(i / f, f);\\n    }\\n    \\n    // https://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/discuss/1955515/Prefix-Sum-of-Factors-2-and-5\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid[0].size(), res = 0;\\n        vector<vector<array<int, 2>>> h(m, vector<array<int, 2>>(n + 1)), v(m + 1, vector<array<int, 2>>(n));\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j) {\\n                array<int, 2> f25 = { factors(grid[i][j], 2), factors(grid[i][j], 5) };\\n                v[i + 1][j] = v[i][j] + f25;\\n                h[i][j + 1] = h[i][j] + f25;\\n            }\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j) {\\n                auto v1 = v[i + 1][j], v2 = v[m][j] - v[i][j];\\n                auto h1 = h[i][j], h2 = h[i][n] - h[i][j + 1];\\n                res = max({res, pairs(v1 + h1), pairs(v1 + h2), pairs(v2 + h1), pairs(v2 + h2)});\\n                \\n                // 4 paths \\n                // suppose you\\'re on (i, j) cell\\n                // then either you can have vertical_top path + horizantal_right path ( L shaped) OR vertical_top path + horizantal_left path ( mirrored L)\\n                // OR vertical_down + hori_right OR vertical_down + hori_left\\n                // \\n                \\n            }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\narray<int, 2> operator+(const array<int, 2> &l, const array<int, 2> &r) { return { l[0] + r[0], l[1] + r[1] }; }\\narray<int, 2> operator-(const array<int, 2> &l, const array<int, 2> &r) { return { l[0] - r[0], l[1] - r[1] }; }\\n\\nint pairs(const array<int, 2> &p) { return min(p[0], p[1]); }\\n\\nclass Solution {\\npublic:\\n    int factors(int i, int f) {\\n        return i % f ? 0 : 1 + factors(i / f, f);\\n    }\\n    \\n    // https://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/discuss/1955515/Prefix-Sum-of-Factors-2-and-5\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid[0].size(), res = 0;\\n        vector<vector<array<int, 2>>> h(m, vector<array<int, 2>>(n + 1)), v(m + 1, vector<array<int, 2>>(n));\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j) {\\n                array<int, 2> f25 = { factors(grid[i][j], 2), factors(grid[i][j], 5) };\\n                v[i + 1][j] = v[i][j] + f25;\\n                h[i][j + 1] = h[i][j] + f25;\\n            }\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j) {\\n                auto v1 = v[i + 1][j], v2 = v[m][j] - v[i][j];\\n                auto h1 = h[i][j], h2 = h[i][n] - h[i][j + 1];\\n                res = max({res, pairs(v1 + h1), pairs(v1 + h2), pairs(v2 + h1), pairs(v2 + h2)});\\n                \\n                // 4 paths \\n                // suppose you\\'re on (i, j) cell\\n                // then either you can have vertical_top path + horizantal_right path ( L shaped) OR vertical_top path + horizantal_left path ( mirrored L)\\n                // OR vertical_down + hori_right OR vertical_down + hori_left\\n                // \\n                \\n            }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349979,
                "title": "cpp-99-faster-and-99-memory",
                "content": "class Solution {\\npublic:\\n    \\n    pair<int,int>find_factor(int n)\\n    {   \\n        int two=0,five=0;\\n        while(n%5==0)\\n        {\\n            five++;\\n            n/=5;\\n        }\\n        \\n        while(n%2==0)\\n        {\\n            two++;\\n            n/=2;\\n            \\n        }\\n        \\n        return {two,five};\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& grid) \\n    {\\n        int n=grid.size(),m=grid[0].size();\\n        \\n        int factor[n][m][2];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {   \\n                pair<int,int>p=find_factor(grid[i][j]);\\n                factor[i][j][0]=p.first;\\n                factor[i][j][1]=p.second;\\n            }\\n        }\\n        \\n        \\n        int row[n][m][2];\\n        int col[n][m][2];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int two=0,five=0;\\n            \\n            for(int j=0;j<m;j++)\\n            {\\n                row[i][j][0]=two+factor[i][j][0];\\n                two=row[i][j][0];\\n                row[i][j][1]=five+factor[i][j][1];\\n                five=row[i][j][1];\\n            }\\n        }\\n        \\n         for(int j=0;j<m;j++)\\n        {\\n            int two=0,five=0;\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                col[i][j][0]=two+factor[i][j][0];\\n                two=col[i][j][0];\\n                col[i][j][1]=five+factor[i][j][1];\\n                five=col[i][j][1];\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int a=(i>0)?col[i-1][j][0]:0;\\n                int b=(i!=n-1)?col[n-1][j][0]-col[i][j][0]:0;\\n                int c=(i>0)?col[i-1][j][1]:0;\\n                int d=(i!=n-1)?col[n-1][j][1]-col[i][j][1]:0;\\n                \\n                int p=(j>0)?row[i][j-1][0]:0;\\n                int q=(j!=m-1)?row[i][m-1][0]-row[i][j][0]:0;\\n                int r=(j>0)?row[i][j-1][1]:0;\\n                int s=(j!=m-1)?row[i][m-1][1]-row[i][j][1]:0;\\n                \\n                \\n                ans=max(ans,min(a+p+factor[i][j][0],c+r+factor[i][j][1]));\\n                ans=max(ans,min(a+q+factor[i][j][0],c+s+factor[i][j][1]));\\n                ans=max(ans,min(b+p+factor[i][j][0],d+r+factor[i][j][1]));\\n                ans=max(ans,min(b+q+factor[i][j][0],d+s+factor[i][j][1]));\\n                \\n                \\n            }\\n        \\n        }\\n        \\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    pair<int,int>find_factor(int n)\\n    {   \\n        int two=0,five=0;\\n        while(n%5==0)\\n        {\\n            five++;\\n            n/=5;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2207694,
                "title": "c-explanation-easy",
                "content": "**We can then treat each cell as the elbow point and calculate the largest minimum (sum of 2 exponents, sum of 5 exponents) from the combination of top-left, top-right, bottom-left and bottom-right.**\\n\\n```\\nclass Solution {\\npublic:\\n    int pow2(int num)\\n    {   int cnt=0;\\n        while(num%2==0)\\n        {\\n            cnt=cnt+1;\\n            num=num/2;\\n        }\\n     return cnt;\\n    }\\n    \\n    int pow5(int num)\\n    {   int cnt=0;\\n        while(num%5==0)\\n        {\\n            cnt=cnt+1;\\n            num=num/5;\\n        }\\n     return cnt;\\n    }\\n    \\n    int ans=0;\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n    vector<pair<int, int>> up (grid[0].size(), std::make_pair(0,0));\\n    vector<pair<int, int>> dwn (grid[0].size(), std::make_pair(0,0));\\n    vector<pair<int, int>> rht (grid.size(), std::make_pair(0,0));\\n    vector<pair<int, int>> lft (grid.size(), std::make_pair(0,0));\\n         \\n         for(int i=0;i<grid.size();i=i+1)\\n        {   \\n             int a=0;\\n             int b=0;\\n             for(int j=grid[0].size()-1;j>=0;j=j-1)\\n            {\\n                a=a+pow2(grid[i][j]);\\n                b=b+pow5(grid[i][j]);\\n            }\\n             rht[i].first=a;\\n             rht[i].second=b;\\n             ans=max(ans,min(a,b));\\n         }\\n        \\n         for(int i=0;i<grid[0].size();i=i+1)\\n        {   \\n             int a=0;\\n             int b=0;\\n             for(int j=grid.size()-1;j>=0;j=j-1)\\n            {\\n                a=a+pow2(grid[j][i]);\\n                b=b+pow5(grid[j][i]);\\n            }\\n             dwn[i].first=a;\\n             dwn[i].second=b; \\n              ans=max(ans,min(a,b));\\n         }\\n        \\n       \\n        for(int i=0;i<grid.size();i=i+1)\\n        {\\n            for(int j=0;j<grid[0].size();j=j+1)\\n            {\\n                \\n                int a=pow2(grid[i][j]);\\n                int b=pow5(grid[i][j]);\\n                rht[i].first=rht[i].first-a;\\n                rht[i].second=rht[i].second-b;\\n                dwn[j].first=dwn[j].first-a;\\n                dwn[j].second=dwn[j].second-b;\\n                \\n                ans=max(ans,min(rht[i].first+dwn[j].first+a,rht[i].second+dwn[j].second+b));\\n                ans=max(ans,min(rht[i].first+up[j].first+a,rht[i].second+up[j].second+b));\\n                ans=max(ans,min(lft[i].first+dwn[j].first+a,lft[i].second+dwn[j].second+b));\\n                ans=max(ans,min(lft[i].first+up[j].first+a,lft[i].second+up[j].second+b));\\n                \\n               lft[i].first=lft[i].first+a;\\n               lft[i].second=lft[i].second+b; \\n               up[j].first=up[j].first+a;\\n               up[j].second=up[j].second+b;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**If you found it helpful, kindly upvote!!!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int pow2(int num)\\n    {   int cnt=0;\\n        while(num%2==0)\\n        {\\n            cnt=cnt+1;\\n            num=num/2;\\n        }\\n     return cnt;\\n    }\\n    \\n    int pow5(int num)\\n    {   int cnt=0;\\n        while(num%5==0)\\n        {\\n            cnt=cnt+1;\\n            num=num/5;\\n        }\\n     return cnt;\\n    }\\n    \\n    int ans=0;\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n    vector<pair<int, int>> up (grid[0].size(), std::make_pair(0,0));\\n    vector<pair<int, int>> dwn (grid[0].size(), std::make_pair(0,0));\\n    vector<pair<int, int>> rht (grid.size(), std::make_pair(0,0));\\n    vector<pair<int, int>> lft (grid.size(), std::make_pair(0,0));\\n         \\n         for(int i=0;i<grid.size();i=i+1)\\n        {   \\n             int a=0;\\n             int b=0;\\n             for(int j=grid[0].size()-1;j>=0;j=j-1)\\n            {\\n                a=a+pow2(grid[i][j]);\\n                b=b+pow5(grid[i][j]);\\n            }\\n             rht[i].first=a;\\n             rht[i].second=b;\\n             ans=max(ans,min(a,b));\\n         }\\n        \\n         for(int i=0;i<grid[0].size();i=i+1)\\n        {   \\n             int a=0;\\n             int b=0;\\n             for(int j=grid.size()-1;j>=0;j=j-1)\\n            {\\n                a=a+pow2(grid[j][i]);\\n                b=b+pow5(grid[j][i]);\\n            }\\n             dwn[i].first=a;\\n             dwn[i].second=b; \\n              ans=max(ans,min(a,b));\\n         }\\n        \\n       \\n        for(int i=0;i<grid.size();i=i+1)\\n        {\\n            for(int j=0;j<grid[0].size();j=j+1)\\n            {\\n                \\n                int a=pow2(grid[i][j]);\\n                int b=pow5(grid[i][j]);\\n                rht[i].first=rht[i].first-a;\\n                rht[i].second=rht[i].second-b;\\n                dwn[j].first=dwn[j].first-a;\\n                dwn[j].second=dwn[j].second-b;\\n                \\n                ans=max(ans,min(rht[i].first+dwn[j].first+a,rht[i].second+dwn[j].second+b));\\n                ans=max(ans,min(rht[i].first+up[j].first+a,rht[i].second+up[j].second+b));\\n                ans=max(ans,min(lft[i].first+dwn[j].first+a,lft[i].second+dwn[j].second+b));\\n                ans=max(ans,min(lft[i].first+up[j].first+a,lft[i].second+up[j].second+b));\\n                \\n               lft[i].first=lft[i].first+a;\\n               lft[i].second=lft[i].second+b; \\n               up[j].first=up[j].first+a;\\n               up[j].second=up[j].second+b;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166545,
                "title": "best-c-solution-tc-o-n-m-sc-o-min-n-m",
                "content": "\\n\\ntemplate <typename T, typename U>\\nstd::pair<T, U> operator+(const std::pair<T, U> &l, const std::pair<T, U> &r)\\n{\\n    return {l.first + r.first, l.second + r.second};\\n}\\n\\ntemplate <typename T, typename U>\\nstd::pair<T, U> operator-(const std::pair<T, U> &l, const std::pair<T, U> &r)\\n{\\n    return {l.first - r.first, l.second - r.second};\\n}\\n\\ntypedef pair<int, int> p;\\n\\nclass Solution\\n{public:\\n\\n    p decompose(int n)\\n    {\\n        int two = 0;\\n        int five = 0;\\n\\n        while (n % 2 == 0)\\n        {\\n            two++;\\n            n /= 2;\\n        }\\n\\n        while (n % 5 == 0)\\n        {\\n            five++;\\n            n /= 5;\\n        }\\n\\n        return make_pair(two, five);\\n    }\\n\\n\\n    int maxTrailingZeros(vector<vector<int>> &grid)\\n    {\\n\\n        vector<p> rows(grid.size(), make_pair(0, 0));\\n        vector<p> cols(grid[0].size(), make_pair(0, 0));\\n\\n        for (int i = 0; i < grid.size(); i++)\\n\\n        {\\n\\n            for (int j = 0; j < grid[0].size(); j++)\\n            {\\n                auto pr = decompose(grid[i][j]);\\n                rows[i].first += pr.first;\\n                rows[i].second += pr.second;\\n\\n                cols[j].first += pr.first;\\n                cols[j].second += pr.second;\\n            }\\n        }\\n\\n        vector<p> colstill(grid[0].size(), make_pair(0, 0));\\n\\n        int max0 = 0;\\n\\n        for (int i = 0; i < grid.size(); i++)\\n\\n        {\\n            p rowtill = make_pair(0, 0);\\n\\n            for (int j = 0; j < grid[0].size(); j++)\\n            {\\n                auto a=decompose(grid[i][j]);\\n\\n                auto r = rows[i] - rowtill;\\n\\n                rowtill.first+=a.first;\\n                rowtill.second+=a.second;\\n\\n                p l = rowtill;\\n              \\n\\n                auto t = colstill[j];\\n                auto b = cols[j] - colstill[j];\\n                b.first-=a.first;\\n                b.second-=a.second;\\n                \\n\\n                int tz1 = min(l.first + t.first, l.second + t.second);\\n                int tz2 = min(l.first + b.first, l.second + b.second);\\n                int tz3 = min(r.first + t.first, r.second + t.second);\\n                int tz4 = min(r.first + b.first, r.second + b.second);\\n\\n                max0 = max(max0, tz1);\\n                max0 = max(max0, tz2);\\n                max0 = max(max0, tz3);\\n                max0 = max(max0, tz4);\\n\\n                colstill[j].first+=a.first;\\n                colstill[j].second+=a.second;\\n            }\\n        }\\n\\n        return max0;\\n    }\\n};\\n\\n",
                "solutionTags": [],
                "code": "class Solution\\n{public:\\n\\n    p decompose(int n)\\n    {\\n        int two = 0;\\n        int five = 0;\\n\\n        while (n % 2 == 0)\\n        {\\n            two++;\\n            n /= 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2083365,
                "title": "c-solution-faster-than-90-o-m-n-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    class data{\\n        public:\\n        int up_5, up_2,\\n            left_5, left_2;\\n        };\\n    vector<vector<data>> v;\\n    int func2(int n)\\n    {\\n        int res=0;\\n        while(n%2==0){ res++; n/=2;}\\n        return res;\\n    }\\n    int func5(int n)\\n    {\\n        int res=0;\\n        while(n%5==0){ res++; n/=5;}\\n        return res;\\n    }\\n    int sol(int x1, int x2, int y1, int y2, int z1, int z2)\\n    {\\n        return min(x1+y1+z1, x2+y2+z2);\\n    }\\n    int func(int i, int j, vector<vector<int>> &g, data H, data V)\\n    {\\n        int res=0;\\n        data cur=v[i][j];\\n        \\n        int cnt_2=func2(g[i][j]), cnt_5=func5(g[i][j]);\\n        res=max(res, sol(-cnt_2, -cnt_5, cur.left_2, cur.left_5, cur.up_2, cur.up_5));\\n        res=max(res, sol(0,0,cur.left_2,cur.left_5,V.up_2-cur.up_2,V.up_5-cur.up_5));\\n        res=max(res, sol(0,0,cur.up_2,cur.up_5,H.left_2-cur.left_2,H.left_5-cur.left_5));\\n        res=max(res, sol(cnt_2,cnt_5,V.up_2-cur.up_2,V.up_5-cur.up_5,H.left_2-cur.left_2, H.left_5-cur.left_5));\\n        return res;\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& g) {\\n        int m=g.size(), n=g[0].size();\\n        v.assign(m+1, vector<data>(n+1));\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(i==0){\\n                    v[i][j].up_2=func2(g[i][j]); v[i][j].up_5=func5(g[i][j]);\\n                }else{\\n                    v[i][j].up_2=v[i-1][j].up_2+func2(g[i][j]); \\n                    v[i][j].up_5=v[i-1][j].up_5+func5(g[i][j]);\\n                }\\n                if(j==0){\\n                    v[i][j].left_2=func2(g[i][j]); v[i][j].left_5=func5(g[i][j]);\\n                }else{\\n                    v[i][j].left_2=v[i][j-1].left_2+func2(g[i][j]); \\n                    v[i][j].left_5=v[i][j-1].left_5+func5(g[i][j]);\\n                }\\n            }\\n        }\\n        \\n        int res=0;\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                res=max(res, func(i, j, g, v[i][n-1], v[m-1][j]));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    class data{\\n        public:\\n        int up_5, up_2,\\n            left_5, left_2;\\n        };\\n    vector<vector<data>> v;\\n    int func2(int n)\\n    {\\n        int res=0;\\n        while(n%2==0){ res++; n/=2;}\\n        return res;\\n    }\\n    int func5(int n)\\n    {\\n        int res=0;\\n        while(n%5==0){ res++; n/=5;}\\n        return res;\\n    }\\n    int sol(int x1, int x2, int y1, int y2, int z1, int z2)\\n    {\\n        return min(x1+y1+z1, x2+y2+z2);\\n    }\\n    int func(int i, int j, vector<vector<int>> &g, data H, data V)\\n    {\\n        int res=0;\\n        data cur=v[i][j];\\n        \\n        int cnt_2=func2(g[i][j]), cnt_5=func5(g[i][j]);\\n        res=max(res, sol(-cnt_2, -cnt_5, cur.left_2, cur.left_5, cur.up_2, cur.up_5));\\n        res=max(res, sol(0,0,cur.left_2,cur.left_5,V.up_2-cur.up_2,V.up_5-cur.up_5));\\n        res=max(res, sol(0,0,cur.up_2,cur.up_5,H.left_2-cur.left_2,H.left_5-cur.left_5));\\n        res=max(res, sol(cnt_2,cnt_5,V.up_2-cur.up_2,V.up_5-cur.up_5,H.left_2-cur.left_2, H.left_5-cur.left_5));\\n        return res;\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& g) {\\n        int m=g.size(), n=g[0].size();\\n        v.assign(m+1, vector<data>(n+1));\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(i==0){\\n                    v[i][j].up_2=func2(g[i][j]); v[i][j].up_5=func5(g[i][j]);\\n                }else{\\n                    v[i][j].up_2=v[i-1][j].up_2+func2(g[i][j]); \\n                    v[i][j].up_5=v[i-1][j].up_5+func5(g[i][j]);\\n                }\\n                if(j==0){\\n                    v[i][j].left_2=func2(g[i][j]); v[i][j].left_5=func5(g[i][j]);\\n                }else{\\n                    v[i][j].left_2=v[i][j-1].left_2+func2(g[i][j]); \\n                    v[i][j].left_5=v[i][j-1].left_5+func5(g[i][j]);\\n                }\\n            }\\n        }\\n        \\n        int res=0;\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                res=max(res, func(i, j, g, v[i][n-1], v[m-1][j]));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071512,
                "title": "horizontal-vertical-prefix-sum",
                "content": "For each cell, calculate count of factors of 2 and 5. Then, prepare a horizontal and vertical prefix sum grid. Now, considering each cell as a turning point, calculate maximum number of trailing zeros from the four paths i.e: left-to-top, left to bottom, top to right, and right to bottom. You got the answer. :)\\n```\\nclass Solution {\\n    pair<int,int> getCount(int num) {\\n        int c2=0, c5=0;\\n        while(num%2 == 0) {\\n            num/=2;\\n            c2++;\\n        }\\n        while(num%5 == 0) {\\n            num/=5;\\n            c5++;\\n        }\\n        return make_pair(c2,c5);\\n    }\\n    \\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        vector<vector<pair<int,int>>> aux; // to maintain count of factors of 2 and 5 for each cell element\\n        int m=grid.size(), n=grid[0].size();\\n        for(int i=0;i<m;i++) {\\n            vector<pair<int,int>> temp;\\n            for(int j=0;j<n;j++) {\\n                temp.push_back(getCount(grid[i][j]));\\n            }\\n            aux.push_back(temp);\\n        }\\n        \\n        int ans=0;\\n        \\n        vector<vector<pair<int,int>>> aux1(m, vector<pair<int,int>>(n, {0,0})), aux2(m, vector<pair<int,int>>(n, {0,0})); // array to maintain vertical and horizontal perfix sum\\n        \\n        for(int i=0;i<m;i++) {\\n            aux1[i][0] = aux[i][0];\\n        }\\n        \\n        for(int j=0;j<n;j++) {\\n            aux2[0][j] = aux[0][j];\\n        }\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=1;j<n;j++) {\\n                aux1[i][j].first = aux[i][j].first+aux1[i][j-1].first;\\n                aux1[i][j].second = aux[i][j].second+aux1[i][j-1].second;\\n                ans=max(ans, min(aux1[i][j].first, aux1[i][j].second));\\n            }\\n        }\\n        \\n        for(int j=0;j<n;j++) {\\n            for(int i=1;i<m;i++) {\\n                aux2[i][j].first = aux[i][j].first+aux2[i-1][j].first;\\n                aux2[i][j].second = aux[i][j].second+aux2[i-1][j].second;\\n                ans=max(ans, min(aux2[i][j].first, aux2[i][j].second));\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                                \\n                int tl=0,tr=0,tt=0,tb=0; // t stands for two, l for left, f for five, r for right and so on.\\n                int fl=0,fr=0,ft=0,fb=0;\\n                \\n                if(j-1>=0) {\\n                    tl=aux1[i][j-1].first;\\n                    fl=aux1[i][j-1].second;\\n                }\\n                \\n                if(i-1>=0) {\\n                    tt=aux2[i-1][j].first;\\n                    ft=aux2[i-1][j].second;\\n                }\\n                \\n                tr=aux1[i][n-1].first-aux1[i][j].first;\\n                fr=aux1[i][n-1].second-aux1[i][j].second;\\n                \\n                tb=aux2[m-1][j].first-aux2[i][j].first;\\n                fb=aux2[m-1][j].second-aux2[i][j].second;\\n                \\n                // top-to-left\\n                ans = max(ans, min(tl+tt+aux[i][j].first, fl+ft+aux[i][j].second));\\n                // left-to-bottom\\n                ans = max(ans, min(tl+tb+aux[i][j].first, fl+fb+aux[i][j].second));\\n                // top-to-right\\n                ans = max(ans, min(tt+tr+aux[i][j].first, ft+fr+aux[i][j].second));\\n                // right-to-bottom\\n                ans = max(ans, min(tr+tb+aux[i][j].first, fr+fb+aux[i][j].second));\\n                \\n                \\n            }\\n        }\\n        \\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    pair<int,int> getCount(int num) {\\n        int c2=0, c5=0;\\n        while(num%2 == 0) {\\n            num/=2;\\n            c2++;\\n        }\\n        while(num%5 == 0) {\\n            num/=5;\\n            c5++;\\n        }\\n        return make_pair(c2,c5);\\n    }\\n    \\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        vector<vector<pair<int,int>>> aux; // to maintain count of factors of 2 and 5 for each cell element\\n        int m=grid.size(), n=grid[0].size();\\n        for(int i=0;i<m;i++) {\\n            vector<pair<int,int>> temp;\\n            for(int j=0;j<n;j++) {\\n                temp.push_back(getCount(grid[i][j]));\\n            }\\n            aux.push_back(temp);\\n        }\\n        \\n        int ans=0;\\n        \\n        vector<vector<pair<int,int>>> aux1(m, vector<pair<int,int>>(n, {0,0})), aux2(m, vector<pair<int,int>>(n, {0,0})); // array to maintain vertical and horizontal perfix sum\\n        \\n        for(int i=0;i<m;i++) {\\n            aux1[i][0] = aux[i][0];\\n        }\\n        \\n        for(int j=0;j<n;j++) {\\n            aux2[0][j] = aux[0][j];\\n        }\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=1;j<n;j++) {\\n                aux1[i][j].first = aux[i][j].first+aux1[i][j-1].first;\\n                aux1[i][j].second = aux[i][j].second+aux1[i][j-1].second;\\n                ans=max(ans, min(aux1[i][j].first, aux1[i][j].second));\\n            }\\n        }\\n        \\n        for(int j=0;j<n;j++) {\\n            for(int i=1;i<m;i++) {\\n                aux2[i][j].first = aux[i][j].first+aux2[i-1][j].first;\\n                aux2[i][j].second = aux[i][j].second+aux2[i-1][j].second;\\n                ans=max(ans, min(aux2[i][j].first, aux2[i][j].second));\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                                \\n                int tl=0,tr=0,tt=0,tb=0; // t stands for two, l for left, f for five, r for right and so on.\\n                int fl=0,fr=0,ft=0,fb=0;\\n                \\n                if(j-1>=0) {\\n                    tl=aux1[i][j-1].first;\\n                    fl=aux1[i][j-1].second;\\n                }\\n                \\n                if(i-1>=0) {\\n                    tt=aux2[i-1][j].first;\\n                    ft=aux2[i-1][j].second;\\n                }\\n                \\n                tr=aux1[i][n-1].first-aux1[i][j].first;\\n                fr=aux1[i][n-1].second-aux1[i][j].second;\\n                \\n                tb=aux2[m-1][j].first-aux2[i][j].first;\\n                fb=aux2[m-1][j].second-aux2[i][j].second;\\n                \\n                // top-to-left\\n                ans = max(ans, min(tl+tt+aux[i][j].first, fl+ft+aux[i][j].second));\\n                // left-to-bottom\\n                ans = max(ans, min(tl+tb+aux[i][j].first, fl+fb+aux[i][j].second));\\n                // top-to-right\\n                ans = max(ans, min(tt+tr+aux[i][j].first, ft+fr+aux[i][j].second));\\n                // right-to-bottom\\n                ans = max(ans, min(tr+tb+aux[i][j].first, fr+fb+aux[i][j].second));\\n                \\n                \\n            }\\n        }\\n        \\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1988880,
                "title": "simple-brute-force-using-prefix-sum-of-number-of-factors-of-2-and-5",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int count(int num,int v){\\n        int cnt=0;\\n        while(num>0 and num%v==0){\\n            cnt++;\\n            num/=v;\\n        }\\n        return cnt;\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        vector<vector<pair<int,int>>> h,v;\\n        int n=grid.size(),m=grid[0].size();\\n        h.resize(n,vector<pair<int,int>>(m));\\n        v.resize(n,vector<pair<int,int>>(m));\\n        for(int i=0;i<n;i++){\\n            int two=0,fv=0;\\n            for(int j=0;j<m;j++){\\n                two+=count(grid[i][j],2);\\n                fv+=count(grid[i][j],5);\\n                h[i][j]={two,fv};\\n            }\\n        }\\n        for(int j=0;j<m;j++){\\n            int two=0,fv=0;\\n            for(int i=0;i<n;i++){\\n                two+=count(grid[i][j],2);\\n                fv+=count(grid[i][j],5);\\n                v[i][j]={two,fv};\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int v12=(v[i][j].first+h[i][j].first)-count(grid[i][j],2);\\n                int v15=(v[i][j].second+h[i][j].second)-count(grid[i][j],5);\\n                \\n                int v21=(v[i][j].first+h[i][m-1].first)-h[i][j].first;\\n                int v25=(v[i][j].second+h[i][m-1].second)-h[i][j].second;\\n\\n                int v31=(h[i][j].first+v[n-1][j].first)-v[i][j].first;\\n                int v35=(h[i][j].second+v[n-1][j].second)-v[i][j].second;\\n                \\n                int v41=(h[i][m-1].first+v[n-1][j].first)-(v[i][j].first+h[i][j].first)+count(grid[i][j],2);\\n                int v45=(h[i][m-1].second+v[n-1][j].second)-(v[i][j].second+h[i][j].second)+count(grid[i][j],5);\\n                int k=max({min(v12,v15),min(v21,v25),min(v31,v35),min(v41,v45)});\\n                ans=max(ans,k);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int count(int num,int v){\\n        int cnt=0;\\n        while(num>0 and num%v==0){\\n            cnt++;\\n            num/=v;\\n        }\\n        return cnt;\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        vector<vector<pair<int,int>>> h,v;\\n        int n=grid.size(),m=grid[0].size();\\n        h.resize(n,vector<pair<int,int>>(m));\\n        v.resize(n,vector<pair<int,int>>(m));\\n        for(int i=0;i<n;i++){\\n            int two=0,fv=0;\\n            for(int j=0;j<m;j++){\\n                two+=count(grid[i][j],2);\\n                fv+=count(grid[i][j],5);\\n                h[i][j]={two,fv};\\n            }\\n        }\\n        for(int j=0;j<m;j++){\\n            int two=0,fv=0;\\n            for(int i=0;i<n;i++){\\n                two+=count(grid[i][j],2);\\n                fv+=count(grid[i][j],5);\\n                v[i][j]={two,fv};\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int v12=(v[i][j].first+h[i][j].first)-count(grid[i][j],2);\\n                int v15=(v[i][j].second+h[i][j].second)-count(grid[i][j],5);\\n                \\n                int v21=(v[i][j].first+h[i][m-1].first)-h[i][j].first;\\n                int v25=(v[i][j].second+h[i][m-1].second)-h[i][j].second;\\n\\n                int v31=(h[i][j].first+v[n-1][j].first)-v[i][j].first;\\n                int v35=(h[i][j].second+v[n-1][j].second)-v[i][j].second;\\n                \\n                int v41=(h[i][m-1].first+v[n-1][j].first)-(v[i][j].first+h[i][j].first)+count(grid[i][j],2);\\n                int v45=(h[i][m-1].second+v[n-1][j].second)-(v[i][j].second+h[i][j].second)+count(grid[i][j],5);\\n                int k=max({min(v12,v15),min(v21,v25),min(v31,v35),min(v41,v45)});\\n                ans=max(ans,k);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978311,
                "title": "c-easy-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    // Add Pair Utility Function\\n    pair<int, int> addPair(pair<int, int> a, pair<int, int> b){\\n        return {a.first + b.first , a.second + b.second};\\n    }\\n    // Sub Pair Utility Function\\n    pair<int, int> subPair(pair<int, int> a, pair<int, int> b){\\n        return {a.first - b.first , a.second - b.second};\\n    }\\n    \\n    // Find the number of 5s and 2s making factors of the current number\\n    pair<int, int> factors(int num){\\n        int fiveCount = 0;\\n        int twoCount = 0;\\n        while(num % 5 == 0){\\n            fiveCount += 1;\\n            num /= 5;\\n        }\\n        while(num % 2 == 0){\\n            twoCount += 1;\\n            num /= 2;\\n        }\\n        return {fiveCount, twoCount};\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = 0;\\n        vector<vector<pair<int, int>>> hor(n, vector<pair<int, int>>(m, {0, 0}));\\n        vector<vector<pair<int, int>>> ver(n, vector<pair<int, int>>(m, {0, 0}));\\n        vector<vector<pair<int, int>>> fgrid(n, vector<pair<int, int>>(m, {0, 0}));\\n        // Get count of 5 and 2 factors of each number\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                fgrid[i][j] = factors(grid[i][j]);\\n            }\\n        }\\n        \\n        // horizontal prefix array from left to right\\n        for(int i=0;i<n;i++){\\n            int fcount = 0;\\n            int tcount = 0;\\n            for(int j=0;j<m;j++){\\n                fcount += fgrid[i][j].first;\\n                tcount += fgrid[i][j].second;\\n                hor[i][j] = {fcount, tcount};\\n            }\\n        }\\n        \\n        // vertical prefix array from top to bottom \\n        for(int i=0;i<m;i++){\\n            int fcount = 0;\\n            int tcount = 0;\\n            for(int j=0;j<n;j++){\\n                fcount += fgrid[j][i].first;\\n                tcount += fgrid[j][i].second;\\n                ver[j][i] = {fcount, tcount};\\n            }\\n        }\\n        \\n        /*\\n        *   Iterating each cell. There are 4 ways each cell can contribute to the path\\n        *   top-left, top-right, left-bottom, right-bottom\\n        *   Adding 5s and 2s for all paths and updating ans with min count of 5s ans 2s.\\n        */\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                pair<int, int> count = {0, 0};\\n                count = subPair(addPair(hor[i][j], ver[i][j]), fgrid[i][j]);\\n                ans = max(ans, min(count.first, count.second));\\n                \\n                count = {0, 0};\\n                count = subPair(addPair(hor[i][m-1], ver[i][j]), hor[i][j]);\\n                ans = max(ans, min(count.first, count.second));\\n\\n                count = {0, 0};\\n                count = subPair(addPair(hor[i][j], ver[n-1][j]), ver[i][j]);\\n                ans = max(ans, min(count.first, count.second));\\n                \\n                count = {0, 0};\\n                count = addPair(subPair(subPair(addPair(hor[i][m-1], ver[n-1][j]), hor[i][j]), ver[i][j]), fgrid[i][j]);\\n                ans = max(ans, min(count.first, count.second));\\n                \\n            }\\n        }\\n        \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Add Pair Utility Function\\n    pair<int, int> addPair(pair<int, int> a, pair<int, int> b){\\n        return {a.first + b.first , a.second + b.second};\\n    }\\n    // Sub Pair Utility Function\\n    pair<int, int> subPair(pair<int, int> a, pair<int, int> b){\\n        return {a.first - b.first , a.second - b.second};\\n    }\\n    \\n    // Find the number of 5s and 2s making factors of the current number\\n    pair<int, int> factors(int num){\\n        int fiveCount = 0;\\n        int twoCount = 0;\\n        while(num % 5 == 0){\\n            fiveCount += 1;\\n            num /= 5;\\n        }\\n        while(num % 2 == 0){\\n            twoCount += 1;\\n            num /= 2;\\n        }\\n        return {fiveCount, twoCount};\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = 0;\\n        vector<vector<pair<int, int>>> hor(n, vector<pair<int, int>>(m, {0, 0}));\\n        vector<vector<pair<int, int>>> ver(n, vector<pair<int, int>>(m, {0, 0}));\\n        vector<vector<pair<int, int>>> fgrid(n, vector<pair<int, int>>(m, {0, 0}));\\n        // Get count of 5 and 2 factors of each number\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                fgrid[i][j] = factors(grid[i][j]);\\n            }\\n        }\\n        \\n        // horizontal prefix array from left to right\\n        for(int i=0;i<n;i++){\\n            int fcount = 0;\\n            int tcount = 0;\\n            for(int j=0;j<m;j++){\\n                fcount += fgrid[i][j].first;\\n                tcount += fgrid[i][j].second;\\n                hor[i][j] = {fcount, tcount};\\n            }\\n        }\\n        \\n        // vertical prefix array from top to bottom \\n        for(int i=0;i<m;i++){\\n            int fcount = 0;\\n            int tcount = 0;\\n            for(int j=0;j<n;j++){\\n                fcount += fgrid[j][i].first;\\n                tcount += fgrid[j][i].second;\\n                ver[j][i] = {fcount, tcount};\\n            }\\n        }\\n        \\n        /*\\n        *   Iterating each cell. There are 4 ways each cell can contribute to the path\\n        *   top-left, top-right, left-bottom, right-bottom\\n        *   Adding 5s and 2s for all paths and updating ans with min count of 5s ans 2s.\\n        */\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                pair<int, int> count = {0, 0};\\n                count = subPair(addPair(hor[i][j], ver[i][j]), fgrid[i][j]);\\n                ans = max(ans, min(count.first, count.second));\\n                \\n                count = {0, 0};\\n                count = subPair(addPair(hor[i][m-1], ver[i][j]), hor[i][j]);\\n                ans = max(ans, min(count.first, count.second));\\n\\n                count = {0, 0};\\n                count = subPair(addPair(hor[i][j], ver[n-1][j]), ver[i][j]);\\n                ans = max(ans, min(count.first, count.second));\\n                \\n                count = {0, 0};\\n                count = addPair(subPair(subPair(addPair(hor[i][m-1], ver[n-1][j]), hor[i][j]), ver[i][j]), fgrid[i][j]);\\n                ans = max(ans, min(count.first, count.second));\\n                \\n            }\\n        }\\n        \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977888,
                "title": "simple-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    pair<ll, ll> getZeroes(ll n) {\\n        pair<ll, ll>res{ 0,0 };\\n        ll m = n;\\n        while (n && n % 2 == 0) {\\n            ++res.first;\\n            n /= 2;\\n        }\\n        n = m;\\n        while (n && n % 5 == 0) {\\n            ++res.second;\\n            n /= 5;\\n        }\\n        return res;\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& v) {\\n        ll m = v.size(), n = v.front().size(), ans = 0;\\n        vector<vector<pair<ll, ll>>>preHor(m, vector<pair<ll, ll>>(n)), preVer(m, vector<pair<ll, ll>>(n));//, tmpV(m, vector<ll>(n));\\n        for (ll i = 0;i < m;++i) {\\n            for (ll j = 0;j < n;++j) {\\n                auto tmp = getZeroes(v[i][j]);\\n                if (j) {\\n                    tmp.first += preHor[i][j - 1].first;\\n                    tmp.second += preHor[i][j - 1].second;\\n                }\\n                preHor[i][j] = tmp;\\n                tmp = getZeroes(v[i][j]);\\n                if (i) {\\n                    tmp.first += preVer[i - 1][j].first;\\n                    tmp.second += preVer[i - 1][j].second;\\n                }\\n                preVer[i][j] = tmp;\\n            }\\n        }\\n        for (ll i = 0;i < m;++i) {\\n            for (ll j = 0;j < n;++j) {\\n                pair<ll, ll> top = preVer[i][j], left = preHor[i][j];\\n                pair<ll, ll>right = preHor[i].back(), down = preVer.back()[j];\\n                if (j) {\\n                    right.first -= preHor[i][j - 1].first;\\n                    right.second -= preHor[i][j - 1].second;\\n                }\\n                if (i) {\\n                    down.first -= preVer[i - 1][j].first;\\n                    down.second -= preVer[i - 1][j].second;\\n                }\\n                auto cur = getZeroes(v[i][j]);\\n                ll res = min(top.first+left.first-cur.first, top.second+left.second-cur.second);\\n\\n                res = max(res, min(top.first+right.first-cur.first, top.second+right.second-cur.second));\\n                \\n                res = max(res, min(down.first+right.first-cur.first, down.second+right.second-cur.second));\\n                \\n                res = max(res, min(down.first+left.first-cur.first, down.second+left.second-cur.second));\\n                ans = max(ans, res);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    pair<ll, ll> getZeroes(ll n) {\\n        pair<ll, ll>res{ 0,0 };\\n        ll m = n;\\n        while (n && n % 2 == 0) {\\n            ++res.first;\\n            n /= 2;\\n        }\\n        n = m;\\n        while (n && n % 5 == 0) {\\n            ++res.second;\\n            n /= 5;\\n        }\\n        return res;\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& v) {\\n        ll m = v.size(), n = v.front().size(), ans = 0;\\n        vector<vector<pair<ll, ll>>>preHor(m, vector<pair<ll, ll>>(n)), preVer(m, vector<pair<ll, ll>>(n));//, tmpV(m, vector<ll>(n));\\n        for (ll i = 0;i < m;++i) {\\n            for (ll j = 0;j < n;++j) {\\n                auto tmp = getZeroes(v[i][j]);\\n                if (j) {\\n                    tmp.first += preHor[i][j - 1].first;\\n                    tmp.second += preHor[i][j - 1].second;\\n                }\\n                preHor[i][j] = tmp;\\n                tmp = getZeroes(v[i][j]);\\n                if (i) {\\n                    tmp.first += preVer[i - 1][j].first;\\n                    tmp.second += preVer[i - 1][j].second;\\n                }\\n                preVer[i][j] = tmp;\\n            }\\n        }\\n        for (ll i = 0;i < m;++i) {\\n            for (ll j = 0;j < n;++j) {\\n                pair<ll, ll> top = preVer[i][j], left = preHor[i][j];\\n                pair<ll, ll>right = preHor[i].back(), down = preVer.back()[j];\\n                if (j) {\\n                    right.first -= preHor[i][j - 1].first;\\n                    right.second -= preHor[i][j - 1].second;\\n                }\\n                if (i) {\\n                    down.first -= preVer[i - 1][j].first;\\n                    down.second -= preVer[i - 1][j].second;\\n                }\\n                auto cur = getZeroes(v[i][j]);\\n                ll res = min(top.first+left.first-cur.first, top.second+left.second-cur.second);\\n\\n                res = max(res, min(top.first+right.first-cur.first, top.second+right.second-cur.second));\\n                \\n                res = max(res, min(down.first+right.first-cur.first, down.second+right.second-cur.second));\\n                \\n                res = max(res, min(down.first+left.first-cur.first, down.second+left.second-cur.second));\\n                ans = max(ans, res);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975261,
                "title": "c-o-n-m-solution-prefix-sum-solution",
                "content": "```cpp\\ntypedef pair<int,int> pii;\\ntypedef vector<pair<int,int>> vpii;\\ntypedef vector<vpii> vvpii;\\nclass Solution {\\npublic:\\n    pii get_count(int x,int p=0){\\n        int c_2=0,c_5=0;\\n        while(x%2==0)\\n            x/=2,c_2+=1;\\n        while(x%5==0)\\n            x/=5,c_5+=1;\\n        if(p==1)\\n            return {-c_2,-c_5};\\n        return {c_2,c_5};\\n    }\\n    void print(vvpii &arr){\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=0;j<arr[0].size();j++){\\n                cout<<\"{\"<<arr[i][j].first<<\",\"<<arr[i][j].second<<\"}, \";\\n            }\\n            cout<<endl;\\n        }\\n        cout<<\\'\\\\n\\';\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vvpii horizontal(n,vpii(m)),vertical(n,vpii(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                auto [a,b]=get_count(grid[i][j]);\\n                if(j==0){\\n                    horizontal[i][j]={a,b};\\n                    continue;\\n                }\\n                horizontal[i][j]=horizontal[i][j-1];\\n                horizontal[i][j].first+=a;\\n                horizontal[i][j].second+=b;\\n            }\\n        }\\n        // print(horizontal);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                auto [a,b]=get_count(grid[i][j]);\\n                if(i==0){\\n                    vertical[i][j]={a,b};\\n                    continue;\\n                }\\n                vertical[i][j]=vertical[i-1][j];\\n                vertical[i][j].first+=a;\\n                vertical[i][j].second+=b;\\n            }\\n        }\\n        // print(vertical);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                pii h=horizontal[i][j];\\n                pii v=vertical[i][j];\\n                pii c=get_count(grid[i][j]);\\n//                 case1:  _|\\n                int a1=h.first+v.first-c.first;\\n                int b1=h.second+v.second-c.second;\\n//                 case 2: |_\\n                int a2=v.first+(horizontal[i][m-1].first-horizontal[i][j].first);\\n                int b2=v.second+(horizontal[i][m-1].second-horizontal[i][j].second);\\n//                 case 3: --\\\\\\n                int a3=h.first+vertical[n-1][j].first-vertical[i][j].first;\\n                int b3=h.second+vertical[n-1][j].second-vertical[i][j].second;\\n//                 case 4: /--\\n                int a4=(vertical[n-1][j].first-vertical[i][j].first)+(horizontal[i][m-1].first-horizontal[i][j].first)+c.first;\\n                int b4=(vertical[n-1][j].second-vertical[i][j].second)+(horizontal[i][m-1].second-horizontal[i][j].second)+c.second;       \\n                \\n                ans=max({ans,min(a1,b1),min(a2,b2),min(a3,b3),min(a4,b4)});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```cpp\\ntypedef pair<int,int> pii;\\ntypedef vector<pair<int,int>> vpii;\\ntypedef vector<vpii> vvpii;\\nclass Solution {\\npublic:\\n    pii get_count(int x,int p=0){\\n        int c_2=0,c_5=0;\\n        while(x%2==0)\\n            x/=2,c_2+=1;\\n        while(x%5==0)\\n            x/=5,c_5+=1;\\n        if(p==1)\\n            return {-c_2,-c_5};\\n        return {c_2,c_5};\\n    }\\n    void print(vvpii &arr){\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=0;j<arr[0].size();j++){\\n                cout<<\"{\"<<arr[i][j].first<<\",\"<<arr[i][j].second<<\"}, \";\\n            }\\n            cout<<endl;\\n        }\\n        cout<<\\'\\\\n\\';\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vvpii horizontal(n,vpii(m)),vertical(n,vpii(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                auto [a,b]=get_count(grid[i][j]);\\n                if(j==0){\\n                    horizontal[i][j]={a,b};\\n                    continue;\\n                }\\n                horizontal[i][j]=horizontal[i][j-1];\\n                horizontal[i][j].first+=a;\\n                horizontal[i][j].second+=b;\\n            }\\n        }\\n        // print(horizontal);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                auto [a,b]=get_count(grid[i][j]);\\n                if(i==0){\\n                    vertical[i][j]={a,b};\\n                    continue;\\n                }\\n                vertical[i][j]=vertical[i-1][j];\\n                vertical[i][j].first+=a;\\n                vertical[i][j].second+=b;\\n            }\\n        }\\n        // print(vertical);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                pii h=horizontal[i][j];\\n                pii v=vertical[i][j];\\n                pii c=get_count(grid[i][j]);\\n//                 case1:  _|\\n                int a1=h.first+v.first-c.first;\\n                int b1=h.second+v.second-c.second;\\n//                 case 2: |_\\n                int a2=v.first+(horizontal[i][m-1].first-horizontal[i][j].first);\\n                int b2=v.second+(horizontal[i][m-1].second-horizontal[i][j].second);\\n//                 case 3: --\\\\\\n                int a3=h.first+vertical[n-1][j].first-vertical[i][j].first;\\n                int b3=h.second+vertical[n-1][j].second-vertical[i][j].second;\\n//                 case 4: /--\\n                int a4=(vertical[n-1][j].first-vertical[i][j].first)+(horizontal[i][m-1].first-horizontal[i][j].first)+c.first;\\n                int b4=(vertical[n-1][j].second-vertical[i][j].second)+(horizontal[i][m-1].second-horizontal[i][j].second)+c.second;       \\n                \\n                ans=max({ans,min(a1,b1),min(a2,b2),min(a3,b3),min(a4,b4)});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1970787,
                "title": "python3-o-mn-vertical-horizontal-prefix-sum-solution",
                "content": "First step is convert each number to how many 2s and 5s it contains, these are the ingredients of 10. \\nThen is just standard counting using prefix array in both vertical and horizontal way. \\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n      m, n = len(grid), len(grid[0])\\n      new_grid = [[[0, 0] for _ in range(n)] for _ in range(m)]\\n      for i in range(m):\\n        for j in range(n):\\n          target = grid[i][j]\\n          count2, count5 = 0, 0\\n          while target % 2 == 0:\\n            count2 += 1\\n            target = target//2\\n          while target % 5 == 0:\\n            count5 += 1\\n            target = target//5\\n          new_grid[i][j] = [count2, count5]\\n      verti_grid = [[[0, 0] for _ in range(n)] for _ in range(m)]\\n      hori_grid = [[[0, 0] for _ in range(n)] for _ in range(m)]\\n      \\n      for i in range(m):\\n        sum2, sum5 = 0, 0\\n        for j in range(n):\\n          sum2 += new_grid[i][j][0]\\n          sum5 += new_grid[i][j][1]\\n          hori_grid[i][j] = [sum2, sum5]\\n          \\n      for j in range(n):\\n        sum2, sum5 = 0, 0\\n        for i in range(m):\\n          sum2 += new_grid[i][j][0]\\n          sum5 += new_grid[i][j][1]\\n          verti_grid[i][j] = [sum2, sum5]\\n        \\n      res = -sys.maxsize\\n      \\n      for i in range(m):\\n        for j in range(n):\\n          start2, start5 = hori_grid[i][j][0], hori_grid[i][j][1]\\n          start2_up, start5_up = start2 + verti_grid[i][j][0] - new_grid[i][j][0], \\\\\\n                                 start5 + verti_grid[i][j][1] - new_grid[i][j][1]\\n          start2_down, start5_down = start2 + verti_grid[-1][j][0] - verti_grid[i][j][0], \\\\\\n                                     start5 + verti_grid[-1][j][1] - verti_grid[i][j][1]\\n          res = max([min(start2_up, start5_up), min(start2_down, start5_down), res])\\n\\n      for i in range(m):\\n        for j in range(n):\\n          if j != 0:\\n            start2, start5 = hori_grid[i][-1][0] - hori_grid[i][j-1][0], \\\\\\n                             hori_grid[i][-1][1] - hori_grid[i][j-1][1]\\n          else:\\n            start2, start5 = hori_grid[i][-1][0], hori_grid[i][-1][1]\\n          start2_up, start5_up = start2 + verti_grid[i][j][0] - new_grid[i][j][0], \\\\\\n                                 start5 + verti_grid[i][j][1] - new_grid[i][j][1]\\n          start2_down, start5_down = start2 + verti_grid[-1][j][0] - verti_grid[i][j][0], \\\\\\n                                     start5 + verti_grid[-1][j][1] - verti_grid[i][j][1]\\n          res = max([min(start2_up, start5_up), min(start2_down, start5_down), res])\\n          \\n      return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n      m, n = len(grid), len(grid[0])\\n      new_grid = [[[0, 0] for _ in range(n)] for _ in range(m)]\\n      for i in range(m):\\n        for j in range(n):\\n          target = grid[i][j]\\n          count2, count5 = 0, 0\\n          while target % 2 == 0:\\n            count2 += 1\\n            target = target//2\\n          while target % 5 == 0:\\n            count5 += 1\\n            target = target//5\\n          new_grid[i][j] = [count2, count5]\\n      verti_grid = [[[0, 0] for _ in range(n)] for _ in range(m)]\\n      hori_grid = [[[0, 0] for _ in range(n)] for _ in range(m)]\\n      \\n      for i in range(m):\\n        sum2, sum5 = 0, 0\\n        for j in range(n):\\n          sum2 += new_grid[i][j][0]\\n          sum5 += new_grid[i][j][1]\\n          hori_grid[i][j] = [sum2, sum5]\\n          \\n      for j in range(n):\\n        sum2, sum5 = 0, 0\\n        for i in range(m):\\n          sum2 += new_grid[i][j][0]\\n          sum5 += new_grid[i][j][1]\\n          verti_grid[i][j] = [sum2, sum5]\\n        \\n      res = -sys.maxsize\\n      \\n      for i in range(m):\\n        for j in range(n):\\n          start2, start5 = hori_grid[i][j][0], hori_grid[i][j][1]\\n          start2_up, start5_up = start2 + verti_grid[i][j][0] - new_grid[i][j][0], \\\\\\n                                 start5 + verti_grid[i][j][1] - new_grid[i][j][1]\\n          start2_down, start5_down = start2 + verti_grid[-1][j][0] - verti_grid[i][j][0], \\\\\\n                                     start5 + verti_grid[-1][j][1] - verti_grid[i][j][1]\\n          res = max([min(start2_up, start5_up), min(start2_down, start5_down), res])\\n\\n      for i in range(m):\\n        for j in range(n):\\n          if j != 0:\\n            start2, start5 = hori_grid[i][-1][0] - hori_grid[i][j-1][0], \\\\\\n                             hori_grid[i][-1][1] - hori_grid[i][j-1][1]\\n          else:\\n            start2, start5 = hori_grid[i][-1][0], hori_grid[i][-1][1]\\n          start2_up, start5_up = start2 + verti_grid[i][j][0] - new_grid[i][j][0], \\\\\\n                                 start5 + verti_grid[i][j][1] - new_grid[i][j][1]\\n          start2_down, start5_down = start2 + verti_grid[-1][j][0] - verti_grid[i][j][0], \\\\\\n                                     start5 + verti_grid[-1][j][1] - verti_grid[i][j][1]\\n          res = max([min(start2_up, start5_up), min(start2_down, start5_down), res])\\n          \\n      return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1970204,
                "title": "o-1-space-implementation-except-stack-space",
                "content": "I am spawning 3-directional (it is interesting to see that they need not be 4-directional i.e; go up, down, left, and right, three directions are sufficient for spanning the array) crawlers at promising (cells which are already multiples of either 2 or 5) roots.\\n\\nUsing marking-unmarking technique to avoid a visited array.\\n```\\n\\tvoid rec(vector<vector<int> >& grid, int& ans, int num_twos, int num_fives, int i, int j, bool turned, int dir)\\n    {\\n        if(grid[i][j]==-1)\\n            return;\\n        // there is a more optimal way but it won\\'t matter here since max(grid[i][j]) is 1000. so that\\'s a max of 9 iterations for twos and 4 for fives in the following\\n        int twos = 0, fives = 0, temp = grid[i][j], n = grid[i][j], num_zeroes;\\n        while(!(n&1))\\n        {\\n            ++twos;\\n            n /= 2;\\n        }\\n        num_twos += twos;\\n        n = grid[i][j];\\n        while(n%5==0)\\n        {\\n            ++fives;\\n            n /= 5;\\n        }\\n        num_fives += fives;\\n        grid[i][j] = -1;\\n        num_zeroes = (num_twos<num_fives) ? num_twos : num_fives;\\n        if(ans<num_zeroes)\\n            ans = num_zeroes;\\n        // can proceed virgin\\n        if(dir==1 && i+1<grid.size())\\n            rec(grid, ans, num_twos, num_fives, i+1, j, turned, 1);\\n        else if(dir==2 && i-1>=0)\\n            rec(grid, ans, num_twos, num_fives, i-1, j, turned, 2);\\n        //else if(dir==3 && j+1<grid[0].size())\\n            //rec(grid, ans, num_twos, num_fives, i, j+1, turned, 3);\\n        else if(dir==4 && j-1>=0)\\n            rec(grid, ans, num_twos, num_fives, i, j-1, turned, 4);\\n        // or pivot\\n        if(!turned)\\n        {\\n            if(dir==1 || dir==2)\\n            {\\n            //rec(grid, ans, num_twos, num_fives, i, j+1, true, 3);\\n            if(j-1>=0)\\n                rec(grid, ans, num_twos, num_fives, i, j-1, true, 4);\\n            }\\n            else\\n            {\\n            if(i+1<grid.size())\\n                rec(grid, ans, num_twos, num_fives, i+1, j, true, 1);\\n            if(i-1>=0)\\n                rec(grid, ans, num_twos, num_fives, i-1, j, true, 2);\\n            }\\n        }\\n        grid[i][j] = temp;\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i=0; i<grid.size(); ++i)\\n            for(int j=0; j<grid[0].size(); ++j)\\n            {\\n                if(!(grid[i][j]&1) || grid[i][j]%5==0) // only non empty roots\\n                {\\n                rec(grid, ans, 0, 0, i, j, false, 1); // i+1\\n                rec(grid, ans, 0, 0, i, j, false, 2); // i-1\\n                //rec(grid, ans, 0, 0, i, j, false, 3); // j+1\\n                rec(grid, ans, 0, 0, i, j, false, 4); // j-1   \\n                }\\n            }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n\\tvoid rec(vector<vector<int> >& grid, int& ans, int num_twos, int num_fives, int i, int j, bool turned, int dir)\\n    {\\n        if(grid[i][j]==-1)\\n            return;\\n        // there is a more optimal way but it won\\'t matter here since max(grid[i][j]) is 1000. so that\\'s a max of 9 iterations for twos and 4 for fives in the following\\n        int twos = 0, fives = 0, temp = grid[i][j], n = grid[i][j], num_zeroes;\\n        while(!(n&1))\\n        {\\n            ++twos;\\n            n /= 2;\\n        }\\n        num_twos += twos;\\n        n = grid[i][j];\\n        while(n%5==0)\\n        {\\n            ++fives;\\n            n /= 5;\\n        }\\n        num_fives += fives;\\n        grid[i][j] = -1;\\n        num_zeroes = (num_twos<num_fives) ? num_twos : num_fives;\\n        if(ans<num_zeroes)\\n            ans = num_zeroes;\\n        // can proceed virgin\\n        if(dir==1 && i+1<grid.size())\\n            rec(grid, ans, num_twos, num_fives, i+1, j, turned, 1);\\n        else if(dir==2 && i-1>=0)\\n            rec(grid, ans, num_twos, num_fives, i-1, j, turned, 2);\\n        //else if(dir==3 && j+1<grid[0].size())\\n            //rec(grid, ans, num_twos, num_fives, i, j+1, turned, 3);\\n        else if(dir==4 && j-1>=0)\\n            rec(grid, ans, num_twos, num_fives, i, j-1, turned, 4);\\n        // or pivot\\n        if(!turned)\\n        {\\n            if(dir==1 || dir==2)\\n            {\\n            //rec(grid, ans, num_twos, num_fives, i, j+1, true, 3);\\n            if(j-1>=0)\\n                rec(grid, ans, num_twos, num_fives, i, j-1, true, 4);\\n            }\\n            else\\n            {\\n            if(i+1<grid.size())\\n                rec(grid, ans, num_twos, num_fives, i+1, j, true, 1);\\n            if(i-1>=0)\\n                rec(grid, ans, num_twos, num_fives, i-1, j, true, 2);\\n            }\\n        }\\n        grid[i][j] = temp;\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i=0; i<grid.size(); ++i)\\n            for(int j=0; j<grid[0].size(); ++j)\\n            {\\n                if(!(grid[i][j]&1) || grid[i][j]%5==0) // only non empty roots\\n                {\\n                rec(grid, ans, 0, 0, i, j, false, 1); // i+1\\n                rec(grid, ans, 0, 0, i, j, false, 2); // i-1\\n                //rec(grid, ans, 0, 0, i, j, false, 3); // j+1\\n                rec(grid, ans, 0, 0, i, j, false, 4); // j-1   \\n                }\\n            }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1967920,
                "title": "c-2245-maximum-trailing-zeros-in-a-cornered-path",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(); \\n        vector<vector<int>> f2(m, vector<int>(n)), f5(m, vector<int>(n)); \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) {\\n                for (int x = grid[i][j]; x % 2 == 0; x /= 2) ++f2[i][j]; \\n                for (int x = grid[i][j]; x % 5 == 0; x /= 5) ++f5[i][j]; \\n            }\\n        vector<vector<array<int, 2>>> h(m+1, vector<array<int, 2>>(n+1)), v = h;\\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) {\\n                h[i][j+1][0] = h[i][j][0] + f2[i][j]; \\n                h[i][j+1][1] = h[i][j][1] + f5[i][j]; \\n                v[i+1][j][0] = v[i][j][0] + f2[i][j]; \\n                v[i+1][j][1] = v[i][j][1] + f5[i][j]; \\n            }\\n        int ans = 0; \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                vector<int> hh = {h[i][n][0] - h[i][j][0], h[i][n][1] - h[i][j][1]}, vv = {v[m][j][0] - v[i][j][0], v[m][j][1] - v[i][j][1]}; \\n                ans = max(ans, min(h[i][j][0]+v[i][j][0]+f2[i][j], h[i][j][1]+v[i][j][1]+f5[i][j])); \\n                ans = max(ans, min(hh[0]+v[i][j][0], hh[1]+v[i][j][1])); \\n                ans = max(ans, min(h[i][j][0]+vv[0], h[i][j][1]+vv[1])); \\n                ans = max(ans, min(hh[0]+vv[0]-f2[i][j], hh[1]+vv[1]-f5[i][j])); \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(); \\n        vector<vector<int>> f2(m, vector<int>(n)), f5(m, vector<int>(n)); \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) {\\n                for (int x = grid[i][j]; x % 2 == 0; x /= 2) ++f2[i][j]; \\n                for (int x = grid[i][j]; x % 5 == 0; x /= 5) ++f5[i][j]; \\n            }\\n        vector<vector<array<int, 2>>> h(m+1, vector<array<int, 2>>(n+1)), v = h;\\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) {\\n                h[i][j+1][0] = h[i][j][0] + f2[i][j]; \\n                h[i][j+1][1] = h[i][j][1] + f5[i][j]; \\n                v[i+1][j][0] = v[i][j][0] + f2[i][j]; \\n                v[i+1][j][1] = v[i][j][1] + f5[i][j]; \\n            }\\n        int ans = 0; \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                vector<int> hh = {h[i][n][0] - h[i][j][0], h[i][n][1] - h[i][j][1]}, vv = {v[m][j][0] - v[i][j][0], v[m][j][1] - v[i][j][1]}; \\n                ans = max(ans, min(h[i][j][0]+v[i][j][0]+f2[i][j], h[i][j][1]+v[i][j][1]+f5[i][j])); \\n                ans = max(ans, min(hh[0]+v[i][j][0], hh[1]+v[i][j][1])); \\n                ans = max(ans, min(h[i][j][0]+vv[0], h[i][j][1]+vv[1])); \\n                ans = max(ans, min(hh[0]+vv[0]-f2[i][j], hh[1]+vv[1]-f5[i][j])); \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965177,
                "title": "c-factor-2-and-5-time-o-nm-space-o-m",
                "content": "```\\nclass Solution {\\n    void update(int gridv, vector<int>& c)\\n    {\\n        while (gridv != 0 && gridv % 5 == 0) {c[0]++; gridv/=5;}\\n        while (gridv != 0 && gridv % 2 == 0) {c[1]++; gridv/=2;}\\n    }\\n    \\n    int calculate(vector<vector<int>>& grid, bool updown)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        int i=updown?0:n-1;\\n        int ans = 0;\\n        vector<vector<int>> count(m,vector<int>(2,0));//count of 2, count of  5\\n        while(i>=0 && i <n)\\n        {\\n            vector<int> hcount = {0,0};\\n            for(int j=0; j<m; j++)\\n            {\\n                update(grid[i][j], count[j]);\\n                ans = max(ans, min(count[j][0] + hcount[0], count[j][1] + hcount[1]));\\n                update(grid[i][j], hcount);\\n            }\\n            hcount[0] = hcount[1] = 0;\\n            for(int j=m-1; j>=0; j--)\\n            {\\n                ans = max(ans, min(count[j][0] + hcount[0], count[j][1] + hcount[1]));\\n                update(grid[i][j], hcount);\\n            }\\n            i+= updown?1:-1;\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        return max(calculate(grid, true), calculate(grid, false));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void update(int gridv, vector<int>& c)\\n    {\\n        while (gridv != 0 && gridv % 5 == 0) {c[0]++; gridv/=5;}\\n        while (gridv != 0 && gridv % 2 == 0) {c[1]++; gridv/=2;}\\n    }\\n    \\n    int calculate(vector<vector<int>>& grid, bool updown)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        int i=updown?0:n-1;\\n        int ans = 0;\\n        vector<vector<int>> count(m,vector<int>(2,0));//count of 2, count of  5\\n        while(i>=0 && i <n)\\n        {\\n            vector<int> hcount = {0,0};\\n            for(int j=0; j<m; j++)\\n            {\\n                update(grid[i][j], count[j]);\\n                ans = max(ans, min(count[j][0] + hcount[0], count[j][1] + hcount[1]));\\n                update(grid[i][j], hcount);\\n            }\\n            hcount[0] = hcount[1] = 0;\\n            for(int j=m-1; j>=0; j--)\\n            {\\n                ans = max(ans, min(count[j][0] + hcount[0], count[j][1] + hcount[1]));\\n                update(grid[i][j], hcount);\\n            }\\n            i+= updown?1:-1;\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        return max(calculate(grid, true), calculate(grid, false));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962118,
                "title": "java-prefix-sums-of-10-5-2",
                "content": "Yes, you can do away with 5 and 2 only.\\n```\\nclass Solution {\\n    static int R= 0, L= 1, D= 2, U= 3; // grid iteration direction index\\n    static int Z= 0, F= 1, E= 2;       // count of zeros, fives and even numbers\\n    static int[] EMPTY= {0, 0, 0};     // empty array of factor counts [Z, F, E]\\n    \\n    public int maxTrailingZeros(int[][] grid) {\\n        int m= grid.length, n= grid[0].length;\\n        \\n        // calculate 10,5,2 factors for each number in the grid\\n        int[][][] fs= new int[m][n][3];\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                fact(fs[i][j], grid[i][j]);\\n        \\n        // calculate ps matrices of factors in all directions\\n        int[][][][] ps= new int[m][n][4][3];       \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++)\\n                add(ps[i][j][R], fs[i][j], j==0 ? EMPTY : ps[i][j-1][R]);\\n            for(int j=n-1; j>-1; j--)\\n                add(ps[i][j][L], fs[i][j], j==n-1 ? EMPTY : ps[i][j+1][L]);\\n        }\\n        for(int j=0; j<n; j++){\\n            for(int i=0; i<m; i++)\\n                add(ps[i][j][D], fs[i][j], i==0 ? EMPTY : ps[i-1][j][D]);\\n            for(int i=m-1; i>-1; i--)\\n                add(ps[i][j][U], fs[i][j], i==m-1 ? EMPTY : ps[i+1][j][U]);     \\n        }\\n\\n        // use ps matrices to calculate answer \\n        int ans= 0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                ans= Math.max(ans, calc(ps[i][j][L], i==m-1 ? EMPTY : ps[i+1][j][U]));\\n                ans= Math.max(ans, calc(ps[i][j][L], i==0 ? EMPTY : ps[i-1][j][D]));\\n                ans= Math.max(ans, calc(ps[i][j][R], i==m-1 ? EMPTY : ps[i+1][j][U]));\\n                ans= Math.max(ans, calc(ps[i][j][R], i==0 ? EMPTY : ps[i-1][j][D]));\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    void fact(int[] fs, int val){\\n        while(val!=0 && val%10==0){fs[Z]++; val/=10;}\\n        while(val!=0 && val%5==0){fs[F]++; val/=5;} \\n        while(val!=0 && val%2==0){fs[E]++; val/=2;}\\n    }\\n    \\n    void add(int[] ans, int[] a, int[] b){\\n        for(int i=0; i<3; i++) ans[i]= a[i]+b[i];\\n    }\\n    \\n    int calc(int[] a, int[] b){\\n        return a[Z]+b[Z] + Math.min(a[F]+b[F], a[E]+b[E]);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    static int R= 0, L= 1, D= 2, U= 3; // grid iteration direction index\\n    static int Z= 0, F= 1, E= 2;       // count of zeros, fives and even numbers\\n    static int[] EMPTY= {0, 0, 0}",
                "codeTag": "Java"
            },
            {
                "id": 1961568,
                "title": "prefix-sum-vertically-and-horizontally-of-factors-2-and-5",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = 0;\\n        \\n        vector<vector<pair<int,int>>> ngrid(n,vector<pair<int,int>>(m,{0,0}));\\n        vector<vector<pair<int,int>>> vert(n,vector<pair<int,int>>(m,{0,0}));\\n        vector<vector<pair<int,int>>> hor(n,vector<pair<int,int>>(m,{0,0}));\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                auto x = func(grid[i][j]);\\n                ngrid[i][j].first = x.first;\\n                ngrid[i][j].second = x.second;\\n            }\\n        }\\n        \\n        for(int j=0; j<m; j++){\\n            vert[0][j] = ngrid[0][j]; \\n            for(int i=1; i<n; i++){\\n                vert[i][j].first = vert[i-1][j].first + ngrid[i][j].first;\\n                vert[i][j].second = vert[i-1][j].second + ngrid[i][j].second;\\n                \\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            hor[i][0] = ngrid[i][0]; \\n            for(int j=1; j<m; j++){\\n                hor[i][j].first = hor[i][j-1].first+ngrid[i][j].first;\\n                hor[i][j].second = hor[i][j-1].second+ngrid[i][j].second;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                vector<pair<int,int> > v(4);\\n                \\n                v[0].first = (i-1 >= 0 ?  vert[i-1][j].first : 0);\\n                v[0].second = (i-1 >= 0 ?  vert[i-1][j].second : 0);\\n                \\n                v[1].first = ( vert[n-1][j].first - vert[i][j].first);\\n                v[1].second = ( vert[n-1][j].second - vert[i][j].second);\\n                \\n                v[2].first = (j-1 >= 0 ?  hor[i][j-1].first : 0);\\n                v[2].second = (j-1 >= 0 ?  hor[i][j-1].second : 0);\\n                \\n                v[3].first = ( hor[i][m-1].first - hor[i][j].first);\\n                v[3].second = ( hor[i][m-1].second - hor[i][j].second);                \\n                \\n                int cmax = 0;\\n                \\n                for(int k=0; k<4; k++){\\n                    for(int l = k+1;  l<4; l++){\\n                        int sum = min(v[k].first+v[l].first+ngrid[i][j].first, v[k].second+v[l].second+ngrid[i][j].second);\\n                        \\n                        cmax = max(cmax, sum);\\n                    }\\n                }\\n                \\n                ans = max(ans,cmax);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    pair<int,int> func(int x){\\n        int two = 0,five=0;\\n        while(x>0 && x%2 == 0){\\n            two++;\\n            x = x/2;\\n        }\\n        \\n        while(x>0 && x%5 == 0){\\n            five++;\\n            x = x/5;\\n        }\\n        \\n        return {two,five};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = 0;\\n        \\n        vector<vector<pair<int,int>>> ngrid(n,vector<pair<int,int>>(m,{0,0}));\\n        vector<vector<pair<int,int>>> vert(n,vector<pair<int,int>>(m,{0,0}));\\n        vector<vector<pair<int,int>>> hor(n,vector<pair<int,int>>(m,{0,0}));\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                auto x = func(grid[i][j]);\\n                ngrid[i][j].first = x.first;\\n                ngrid[i][j].second = x.second;\\n            }\\n        }\\n        \\n        for(int j=0; j<m; j++){\\n            vert[0][j] = ngrid[0][j]; \\n            for(int i=1; i<n; i++){\\n                vert[i][j].first = vert[i-1][j].first + ngrid[i][j].first;\\n                vert[i][j].second = vert[i-1][j].second + ngrid[i][j].second;\\n                \\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            hor[i][0] = ngrid[i][0]; \\n            for(int j=1; j<m; j++){\\n                hor[i][j].first = hor[i][j-1].first+ngrid[i][j].first;\\n                hor[i][j].second = hor[i][j-1].second+ngrid[i][j].second;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                vector<pair<int,int> > v(4);\\n                \\n                v[0].first = (i-1 >= 0 ?  vert[i-1][j].first : 0);\\n                v[0].second = (i-1 >= 0 ?  vert[i-1][j].second : 0);\\n                \\n                v[1].first = ( vert[n-1][j].first - vert[i][j].first);\\n                v[1].second = ( vert[n-1][j].second - vert[i][j].second);\\n                \\n                v[2].first = (j-1 >= 0 ?  hor[i][j-1].first : 0);\\n                v[2].second = (j-1 >= 0 ?  hor[i][j-1].second : 0);\\n                \\n                v[3].first = ( hor[i][m-1].first - hor[i][j].first);\\n                v[3].second = ( hor[i][m-1].second - hor[i][j].second);                \\n                \\n                int cmax = 0;\\n                \\n                for(int k=0; k<4; k++){\\n                    for(int l = k+1;  l<4; l++){\\n                        int sum = min(v[k].first+v[l].first+ngrid[i][j].first, v[k].second+v[l].second+ngrid[i][j].second);\\n                        \\n                        cmax = max(cmax, sum);\\n                    }\\n                }\\n                \\n                ans = max(ans,cmax);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    pair<int,int> func(int x){\\n        int two = 0,five=0;\\n        while(x>0 && x%2 == 0){\\n            two++;\\n            x = x/2;\\n        }\\n        \\n        while(x>0 && x%5 == 0){\\n            five++;\\n            x = x/5;\\n        }\\n        \\n        return {two,five};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961220,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& g) {\\n       \\n     int col=g[0].size();\\n     int row=g.size();   \\n     int a[row][col],b[row][col];  \\n     for(int i=0;i<row;i++)\\n     {\\n         int cnt5=0,cnt2=0;\\n         for(int j=0;j<col;j++)\\n         {\\n           \\n            int x=g[i][j];\\n            while(x%5==0)\\n            {\\n                cnt5++;\\n                x/=5;\\n            }\\n            while(x%2==0)\\n            {\\n                cnt2++;\\n                x/=2;\\n            }\\n            a[i][j]=cnt5;\\n            b[i][j]=cnt2; \\n          \\n         }\\n         \\n     }\\n        \\n     \\n     int maxi=0;   \\n     for(int j=0;j<col;j++)\\n     {\\n        int cnt5=0,cnt2=0; \\n        for(int i=0;i<row;i++)\\n        {\\n            int val5=cnt5+a[i][j];\\n            int val2=cnt2+b[i][j];\\n            int rval5=cnt5+a[i][col-1]-(j==0?0:a[i][j-1]);\\n            int rval2=cnt2+b[i][col-1]-(j==0?0:b[i][j-1]);  \\n            cout<<a[i][col-1];\\n            int mini1=min(val2,val5);\\n            int mini2=min(rval2,rval5);\\n           \\n            int maxis=max(mini1,mini2);\\n            maxi=max(maxi,maxis);  \\n           \\n            int x=g[i][j];\\n            while(x%5==0)\\n            {\\n                cnt5++;\\n                x/=5;\\n            }\\n            while(x%2==0)\\n            {\\n                cnt2++;\\n                x/=2;\\n            }\\n          \\n                      \\n        }\\n         \\n     }   \\n        \\n     for(int j=0;j<col;j++)\\n     {\\n        int cnt5=0,cnt2=0; \\n        for(int i=row-1;i>=0;i--)\\n        {\\n            int x=g[i][j];\\n            int val5=cnt5+a[i][j];\\n            int val2=cnt2+b[i][j];\\n             int rval5=cnt5+a[i][col-1]-(j==0?0:a[i][j-1]);\\n            int rval2=cnt2+b[i][col-1]-(j==0?0:b[i][j-1]);  \\n          \\n            int mini1=min(val2,val5);\\n            int mini2=min(rval2,rval5);\\n            \\n            int maxis=max(mini1,mini2);\\n            maxi=max(maxi,maxis);\\n            while(x%5==0)\\n            {\\n                cnt5++;\\n                x/=5;\\n            }\\n            while(x%2==0)\\n            {\\n                cnt2++;\\n                x/=2;\\n            }\\n               \\n            \\n        }\\n\\n     }\\n         \\n       return maxi; \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& g) {\\n       \\n     int col=g[0].size();\\n     int row=g.size();   \\n     int a[row][col],b[row][col];  \\n     for(int i=0;i<row;i++)\\n     {\\n         int cnt5=0,cnt2=0;\\n         for(int j=0;j<col;j++)\\n         {\\n           \\n            int x=g[i][j];\\n            while(x%5==0)\\n            {\\n                cnt5++;\\n                x/=5;\\n            }\\n            while(x%2==0)\\n            {\\n                cnt2++;\\n                x/=2;\\n            }\\n            a[i][j]=cnt5;\\n            b[i][j]=cnt2; \\n          \\n         }\\n         \\n     }\\n        \\n     \\n     int maxi=0;   \\n     for(int j=0;j<col;j++)\\n     {\\n        int cnt5=0,cnt2=0; \\n        for(int i=0;i<row;i++)\\n        {\\n            int val5=cnt5+a[i][j];\\n            int val2=cnt2+b[i][j];\\n            int rval5=cnt5+a[i][col-1]-(j==0?0:a[i][j-1]);\\n            int rval2=cnt2+b[i][col-1]-(j==0?0:b[i][j-1]);  \\n            cout<<a[i][col-1];\\n            int mini1=min(val2,val5);\\n            int mini2=min(rval2,rval5);\\n           \\n            int maxis=max(mini1,mini2);\\n            maxi=max(maxi,maxis);  \\n           \\n            int x=g[i][j];\\n            while(x%5==0)\\n            {\\n                cnt5++;\\n                x/=5;\\n            }\\n            while(x%2==0)\\n            {\\n                cnt2++;\\n                x/=2;\\n            }\\n          \\n                      \\n        }\\n         \\n     }   \\n        \\n     for(int j=0;j<col;j++)\\n     {\\n        int cnt5=0,cnt2=0; \\n        for(int i=row-1;i>=0;i--)\\n        {\\n            int x=g[i][j];\\n            int val5=cnt5+a[i][j];\\n            int val2=cnt2+b[i][j];\\n             int rval5=cnt5+a[i][col-1]-(j==0?0:a[i][j-1]);\\n            int rval2=cnt2+b[i][col-1]-(j==0?0:b[i][j-1]);  \\n          \\n            int mini1=min(val2,val5);\\n            int mini2=min(rval2,rval5);\\n            \\n            int maxis=max(mini1,mini2);\\n            maxi=max(maxi,maxis);\\n            while(x%5==0)\\n            {\\n                cnt5++;\\n                x/=5;\\n            }\\n            while(x%2==0)\\n            {\\n                cnt2++;\\n                x/=2;\\n            }\\n               \\n            \\n        }\\n\\n     }\\n         \\n       return maxi; \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1961106,
                "title": "c-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) \\n    {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<pair<int,int>>>prefix(m,vector<pair<int,int>>(n,{0,0}));\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                int cnt1=0,cnt2=0;\\n                while(grid[i][j]%2==0)cnt1++,grid[i][j]/=2;\\n                while(grid[i][j]%5==0)cnt2++,grid[i][j]/=5;\\n                prefix[i][j].first=cnt1;\\n                prefix[i][j].second=cnt2;\\n            }\\n        auto record=prefix;\\n        for(int i=0;i<m;i++)\\n            for(int j=1;j<n;j++)\\n            {\\n                prefix[i][j].first+=prefix[i][j-1].first;\\n                prefix[i][j].second+=prefix[i][j-1].second;\\n            }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int v1=0,v2=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                ans=max(ans,min(v1+prefix[j][i].first,v2+prefix[j][i].second));\\n                int v3=prefix[j][n-1].first,v4=prefix[j][n-1].second;\\n                if(i-1>=0)v3-=prefix[j][i-1].first,v4-=prefix[j][i-1].second;\\n                ans=max(ans,min(v1+v3,v2+v4));\\n                v1+=record[j][i].first,v2+=record[j][i].second;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int v1=0,v2=0;\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                ans=max(ans,min(v1+prefix[j][i].first,v2+prefix[j][i].second));\\n                int v3=prefix[j][n-1].first,v4=prefix[j][n-1].second;\\n                if(i-1>=0)v3-=prefix[j][i-1].first,v4-=prefix[j][i-1].second;\\n                ans=max(ans,min(v1+v3,v2+v4));\\n                v1+=record[j][i].first,v2+=record[j][i].second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) \\n    {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<pair<int,int>>>prefix(m,vector<pair<int,int>>(n,{0,0}));\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                int cnt1=0,cnt2=0;\\n                while(grid[i][j]%2==0)cnt1++,grid[i][j]/=2;\\n                while(grid[i][j]%5==0)cnt2++,grid[i][j]/=5;\\n                prefix[i][j].first=cnt1;\\n                prefix[i][j].second=cnt2;\\n            }\\n        auto record=prefix;\\n        for(int i=0;i<m;i++)\\n            for(int j=1;j<n;j++)\\n            {\\n                prefix[i][j].first+=prefix[i][j-1].first;\\n                prefix[i][j].second+=prefix[i][j-1].second;\\n            }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int v1=0,v2=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                ans=max(ans,min(v1+prefix[j][i].first,v2+prefix[j][i].second));\\n                int v3=prefix[j][n-1].first,v4=prefix[j][n-1].second;\\n                if(i-1>=0)v3-=prefix[j][i-1].first,v4-=prefix[j][i-1].second;\\n                ans=max(ans,min(v1+v3,v2+v4));\\n                v1+=record[j][i].first,v2+=record[j][i].second;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int v1=0,v2=0;\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                ans=max(ans,min(v1+prefix[j][i].first,v2+prefix[j][i].second));\\n                int v3=prefix[j][n-1].first,v4=prefix[j][n-1].second;\\n                if(i-1>=0)v3-=prefix[j][i-1].first,v4-=prefix[j][i-1].second;\\n                ans=max(ans,min(v1+v3,v2+v4));\\n                v1+=record[j][i].first,v2+=record[j][i].second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960091,
                "title": "c-100-fast-easy-approach",
                "content": "1. calculate powers of 2 and 5 in factors of each grid[i][j] item in a vectorof pairs of int \\n2. make 2 matrices v and h, v stores vertical prefix sum (for each column seprately)of values of fac and h stores horizontal prefix sum (for each row).\\n3. now in nother loop calculate ans using h and v\\n```\\n#define fo(i,s,e) for(int i=s;i<=e;i++)\\npair<int,int> operator+(pair<int,int>a,pair<int,int>b){\\n      return make_pair(a.first+b.first,a.second+b.second);\\n  }  \\npair<int,int> operator-(pair<int,int>a,pair<int,int>b){\\n      return make_pair(a.first-b.first,a.second-b.second);\\n  }  \\nint mx(pair<int,int>a){\\n      return min(a.first,a.second);\\n}\\nclass Solution {\\n    pair<int,int>fact25(int val){\\n        int cnt=0,cnt2=0;\\n        while(val!=0&&val%2==0)\\n        {cnt++;val/=2;}\\n        \\n        while(val!=0&&val%5==0){\\n            cnt2++;val/=5;\\n        }\\n        return make_pair(cnt,cnt2);\\n    }\\n    \\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<pair<int,int>>>fac(m+1,vector<pair<int,int>>(n+1,make_pair(0,0))),h,v;\\n        v=h=fac;\\n        fac.clear();\\n        fo(i,1,m){\\n            fo(j,1,n){\\n                auto x=fact25(grid[i-1][j-1]);\\n                v[i][j]=v[i-1][j]+x;\\n                h[i][j]=h[i][j-1]+x;\\n            }\\n        }\\n        \\n        int ans=0;\\n        fo(i,1,m){\\n            fo(j,1,n){\\n                pair<int,int> hl,hr,vu,vd;\\n                hl=h[i][j];\\n                hr=h[i][n]-h[i][j-1];\\n                vu=v[i-1][j];\\n                vd=v[m][j]-v[i][j];\\n                ans=max({ans,mx(vu+hl),mx(vu+hr),mx(vd+hl),mx(vd+hr)});\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define fo(i,s,e) for(int i=s;i<=e;i++)\\npair<int,int> operator+(pair<int,int>a,pair<int,int>b){\\n      return make_pair(a.first+b.first,a.second+b.second);\\n  }  \\npair<int,int> operator-(pair<int,int>a,pair<int,int>b){\\n      return make_pair(a.first-b.first,a.second-b.second);\\n  }  \\nint mx(pair<int,int>a){\\n      return min(a.first,a.second);\\n}\\nclass Solution {\\n    pair<int,int>fact25(int val){\\n        int cnt=0,cnt2=0;\\n        while(val!=0&&val%2==0)\\n        {cnt++;val/=2;}\\n        \\n        while(val!=0&&val%5==0){\\n            cnt2++;val/=5;\\n        }\\n        return make_pair(cnt,cnt2);\\n    }\\n    \\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<pair<int,int>>>fac(m+1,vector<pair<int,int>>(n+1,make_pair(0,0))),h,v;\\n        v=h=fac;\\n        fac.clear();\\n        fo(i,1,m){\\n            fo(j,1,n){\\n                auto x=fact25(grid[i-1][j-1]);\\n                v[i][j]=v[i-1][j]+x;\\n                h[i][j]=h[i][j-1]+x;\\n            }\\n        }\\n        \\n        int ans=0;\\n        fo(i,1,m){\\n            fo(j,1,n){\\n                pair<int,int> hl,hr,vu,vd;\\n                hl=h[i][j];\\n                hr=h[i][n]-h[i][j-1];\\n                vu=v[i-1][j];\\n                vd=v[m][j]-v[i][j];\\n                ans=max({ans,mx(vu+hl),mx(vu+hr),mx(vd+hl),mx(vd+hr)});\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960086,
                "title": "c-100-faster-557-ms-100-less-memory-140-6-mb",
                "content": "The hints 1-4 basically summarized what this code does.\\n\\n```cpp\\nstruct s {\\n    int five_cnt;\\n    int two_cnt;\\n    s(int in_f, int in_t) {\\n        five_cnt = in_f;\\n        two_cnt = in_t;\\n    }\\n    s() {}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<s>> C, VC, HC;\\n    int tmpFive, tmpTwo;\\n    \\n    void setT(int in_val) {\\n        tmpFive = 0;\\n        tmpTwo = 0;\\n        if (in_val == 0) {\\n            return;\\n        }\\n        while ((in_val % 5) == 0) {\\n            tmpFive++;\\n            in_val /= 5;\\n        }\\n        while ((in_val % 2) == 0) {\\n            tmpTwo++;\\n            in_val /= 2;\\n        }\\n        return;\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        C.clear();\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n        for (int i = 0; i < row; i++) {\\n            vector<s> tmp;\\n            C.push_back(tmp);\\n            for (int j = 0; j < col; j++) {\\n                setT(grid[i][j]);\\n                C[i].push_back(s(tmpFive, tmpTwo));\\n            }\\n        }\\n        grid.clear();\\n        VC = C;\\n        HC = C;\\n        C.clear();\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 1; j < col; j++) {\\n                HC[i][j].five_cnt += HC[i][j - 1].five_cnt;\\n                HC[i][j].two_cnt += HC[i][j - 1].two_cnt;\\n            }\\n        }\\n        for (int j = 0; j < col; j++) {\\n            for (int i = 1; i < row; i++) {\\n                VC[i][j].five_cnt += VC[i - 1][j].five_cnt;\\n                VC[i][j].two_cnt += VC[i - 1][j].two_cnt;\\n            }\\n        }\\n        int resmaxcnt = 0;\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                // vertical, then left.\\n                s tmp = VC[i][j];\\n                if (j - 1 >= 0) {\\n                    tmp.five_cnt += HC[i][j - 1].five_cnt; // correct here.\\n                    tmp.two_cnt += HC[i][j - 1].two_cnt;\\n                }\\n                resmaxcnt = max(resmaxcnt, min(tmp.five_cnt, tmp.two_cnt));\\n                // next, vertical, right.\\n                tmp = VC[i][j];\\n                tmp.five_cnt += HC[i][col - 1].five_cnt - HC[i][j].five_cnt; // correct\\n                tmp.two_cnt += HC[i][col - 1].two_cnt - HC[i][j].two_cnt;\\n                resmaxcnt = max(resmaxcnt, min(tmp.five_cnt, tmp.two_cnt));\\n                \\n                // next, bottom - left.\\n                // always includes middle in the vertical part.\\n                tmp = VC[row - 1][j];\\n                if (i - 1 >= 0) {\\n                    tmp.five_cnt = VC[row - 1][j].five_cnt - VC[i - 1][j].five_cnt; // modified.\\n                    tmp.two_cnt = VC[row - 1][j].two_cnt - VC[i - 1][j].two_cnt;\\n                }\\n                if (j - 1 >= 0) {\\n                    tmp.five_cnt += HC[i][j - 1].five_cnt;\\n                    tmp.two_cnt += HC[i][j - 1].two_cnt;\\n                }\\n                resmaxcnt = max(resmaxcnt, min(tmp.five_cnt, tmp.two_cnt));\\n                \\n                tmp = VC[row - 1][j]; \\n                if (i - 1 >= 0) {\\n                    tmp.five_cnt = VC[row - 1][j].five_cnt - VC[i - 1][j].five_cnt;\\n                    tmp.two_cnt = VC[row - 1][j].two_cnt - VC[i - 1][j].two_cnt;\\n                }\\n                tmp.five_cnt += HC[i][col - 1].five_cnt - HC[i][j].five_cnt;\\n                tmp.two_cnt += HC[i][col - 1].two_cnt - HC[i][j].two_cnt;\\n                resmaxcnt = max(resmaxcnt, min(tmp.five_cnt, tmp.two_cnt));\\n            }\\n        }\\n        return resmaxcnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nstruct s {\\n    int five_cnt;\\n    int two_cnt;\\n    s(int in_f, int in_t) {\\n        five_cnt = in_f;\\n        two_cnt = in_t;\\n    }\\n    s() {}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<s>> C, VC, HC;\\n    int tmpFive, tmpTwo;\\n    \\n    void setT(int in_val) {\\n        tmpFive = 0;\\n        tmpTwo = 0;\\n        if (in_val == 0) {\\n            return;\\n        }\\n        while ((in_val % 5) == 0) {\\n            tmpFive++;\\n            in_val /= 5;\\n        }\\n        while ((in_val % 2) == 0) {\\n            tmpTwo++;\\n            in_val /= 2;\\n        }\\n        return;\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        C.clear();\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n        for (int i = 0; i < row; i++) {\\n            vector<s> tmp;\\n            C.push_back(tmp);\\n            for (int j = 0; j < col; j++) {\\n                setT(grid[i][j]);\\n                C[i].push_back(s(tmpFive, tmpTwo));\\n            }\\n        }\\n        grid.clear();\\n        VC = C;\\n        HC = C;\\n        C.clear();\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 1; j < col; j++) {\\n                HC[i][j].five_cnt += HC[i][j - 1].five_cnt;\\n                HC[i][j].two_cnt += HC[i][j - 1].two_cnt;\\n            }\\n        }\\n        for (int j = 0; j < col; j++) {\\n            for (int i = 1; i < row; i++) {\\n                VC[i][j].five_cnt += VC[i - 1][j].five_cnt;\\n                VC[i][j].two_cnt += VC[i - 1][j].two_cnt;\\n            }\\n        }\\n        int resmaxcnt = 0;\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                // vertical, then left.\\n                s tmp = VC[i][j];\\n                if (j - 1 >= 0) {\\n                    tmp.five_cnt += HC[i][j - 1].five_cnt; // correct here.\\n                    tmp.two_cnt += HC[i][j - 1].two_cnt;\\n                }\\n                resmaxcnt = max(resmaxcnt, min(tmp.five_cnt, tmp.two_cnt));\\n                // next, vertical, right.\\n                tmp = VC[i][j];\\n                tmp.five_cnt += HC[i][col - 1].five_cnt - HC[i][j].five_cnt; // correct\\n                tmp.two_cnt += HC[i][col - 1].two_cnt - HC[i][j].two_cnt;\\n                resmaxcnt = max(resmaxcnt, min(tmp.five_cnt, tmp.two_cnt));\\n                \\n                // next, bottom - left.\\n                // always includes middle in the vertical part.\\n                tmp = VC[row - 1][j];\\n                if (i - 1 >= 0) {\\n                    tmp.five_cnt = VC[row - 1][j].five_cnt - VC[i - 1][j].five_cnt; // modified.\\n                    tmp.two_cnt = VC[row - 1][j].two_cnt - VC[i - 1][j].two_cnt;\\n                }\\n                if (j - 1 >= 0) {\\n                    tmp.five_cnt += HC[i][j - 1].five_cnt;\\n                    tmp.two_cnt += HC[i][j - 1].two_cnt;\\n                }\\n                resmaxcnt = max(resmaxcnt, min(tmp.five_cnt, tmp.two_cnt));\\n                \\n                tmp = VC[row - 1][j]; \\n                if (i - 1 >= 0) {\\n                    tmp.five_cnt = VC[row - 1][j].five_cnt - VC[i - 1][j].five_cnt;\\n                    tmp.two_cnt = VC[row - 1][j].two_cnt - VC[i - 1][j].two_cnt;\\n                }\\n                tmp.five_cnt += HC[i][col - 1].five_cnt - HC[i][j].five_cnt;\\n                tmp.two_cnt += HC[i][col - 1].two_cnt - HC[i][j].two_cnt;\\n                resmaxcnt = max(resmaxcnt, min(tmp.five_cnt, tmp.two_cnt));\\n            }\\n        }\\n        return resmaxcnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959952,
                "title": "c-prefix-sum-of-factors-2-and-5-used-3d-array-to-make-implementation-easier",
                "content": "```\\n\\n#define endl (\"\\\\n\")\\n#define pi (3.141592653589)\\n#define mod 1e9+7\\n#define ll long long\\n#define float double\\n#define pb push_back\\n#define pp pair<ll, ll>\\n#define mp make_pair\\n#define ff first\\n#define ss second\\n#define all(c) cc.begin(), c.end()\\n#define mini(a, b, c) min(c, min(a, b))\\n#define rrep(i, n) for(int i=n-1;i>=0;i--)\\n#define rep(i,n) for(int i=0;i<n;i++)\\n#define rep1(i,n) for(int i=1;i<n;i++)\\n\\nclass Solution {\\npublic:\\n    pp solve(ll ele){\\n        int temp = ele;\\n        int twos = 0, fives = 0;\\n        while(temp%2==0){\\n            twos++;\\n            temp/=2;\\n        }\\n        temp = ele;\\n        while(temp%5==0){\\n            fives++;\\n            temp/=5;\\n        }\\n        return {twos, fives};\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<vector<pp>>> dp(n, vector<vector<pp>>(m, vector<pp>(4)));\\n        rep(i, n){\\n            vector<pp> store(m);  //{2, 5}\\n            rep(j, m){\\n                pp it = solve(grid[i][j]);\\n                if(j == 0){\\n                    store[j] = it;\\n                }else{\\n                    store[j] = {it.first+store[j-1].first, it.second+store[j-1].second};\\n                }\\n            }\\n            int t_2 = store[m-1].first, t_5 = store[m-1].second;\\n            rep(j, m){\\n                dp[i][j][0].first = store[j].first;\\n                dp[i][j][0].second = store[j].second;\\n                dp[i][j][1].first = t_2 - (j >= 1 ? store[j-1].first:0);\\n                dp[i][j][1].second = t_5 - (j >= 1 ? store[j-1].second:0);\\n            }\\n        }\\n\\n        rep(j, m){\\n            vector<pp> store(n);  //{2, 5}\\n            rep(i, n){\\n                pp it = solve(grid[i][j]);\\n                if(i == 0){\\n                    store[i] = it;\\n                }else{\\n                    store[i] = {it.first+store[i-1].first, it.second+store[i-1].second};\\n                }\\n            }\\n            int t_2 = store[n-1].first, t_5 = store[n-1].second;\\n            rep(i, n){\\n                dp[i][j][2].first = store[i].first;\\n                dp[i][j][2].second = store[i].second;\\n                dp[i][j][3].first = t_2 - (i >= 1 ? store[i-1].first:0);\\n                dp[i][j][3].second = t_5 - (i >= 1 ? store[i-1].second:0);\\n            }\\n        }\\n        \\n        int res = 0;\\n        rep(i, n){\\n            rep(j, m){\\n                int up_max = min(dp[i][j][2].first, dp[i][j][2].second);\\n                int down_max = min(dp[i][j][3].first, dp[i][j][3].second);\\n                \\n                int left_max = min(dp[i][j][0].first, dp[i][j][0].second);\\n                int right_max = min(dp[i][j][1].first, dp[i][j][1].second);\\n                \\n                pp it = solve(grid[i][j]);\\n                //UP -> RIGHT\\n                ll twos = dp[i][j][2].first+dp[i][j][1].first-it.first;\\n                ll fives = dp[i][j][2].second+dp[i][j][1].second-it.second;\\n                \\n                ll tu = min(twos, fives);\\n                res = res < tu ? tu:res;\\n                \\n                //UP -> LEFT\\n                twos = dp[i][j][2].first+dp[i][j][0].first-it.first;\\n                fives = dp[i][j][2].second+dp[i][j][0].second-it.second;\\n                \\n                tu = min(twos, fives);\\n                res = res < tu ? tu:res;\\n                \\n                //LEFT -> DOWN\\n                twos = dp[i][j][0].first+dp[i][j][3].first-it.first;\\n                fives = dp[i][j][0].second+dp[i][j][3].second-it.second;\\n                \\n                tu = min(twos, fives);\\n                res = res < tu ? tu:res;\\n                \\n                //DOWN -> RIGHT\\n                twos = dp[i][j][3].first+dp[i][j][1].first-it.first;\\n                fives = dp[i][j][3].second+dp[i][j][1].second-it.second;\\n                \\n                tu = min(twos, fives);\\n                res = res < tu ? tu:res;\\n            }\\n        }\\n        \\n        return (int)res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\n\\n#define endl (\"\\\\n\")\\n#define pi (3.141592653589)\\n#define mod 1e9+7\\n#define ll long long\\n#define float double\\n#define pb push_back\\n#define pp pair<ll, ll>\\n#define mp make_pair\\n#define ff first\\n#define ss second\\n#define all(c) cc.begin(), c.end()\\n#define mini(a, b, c) min(c, min(a, b))\\n#define rrep(i, n) for(int i=n-1;i>=0;i--)\\n#define rep(i,n) for(int i=0;i<n;i++)\\n#define rep1(i,n) for(int i=1;i<n;i++)\\n\\nclass Solution {\\npublic:\\n    pp solve(ll ele){\\n        int temp = ele;\\n        int twos = 0, fives = 0;\\n        while(temp%2==0){\\n            twos++;\\n            temp/=2;\\n        }\\n        temp = ele;\\n        while(temp%5==0){\\n            fives++;\\n            temp/=5;\\n        }\\n        return {twos, fives};\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<vector<pp>>> dp(n, vector<vector<pp>>(m, vector<pp>(4)));\\n        rep(i, n){\\n            vector<pp> store(m);  //{2, 5}\\n            rep(j, m){\\n                pp it = solve(grid[i][j]);\\n                if(j == 0){\\n                    store[j] = it;\\n                }else{\\n                    store[j] = {it.first+store[j-1].first, it.second+store[j-1].second};\\n                }\\n            }\\n            int t_2 = store[m-1].first, t_5 = store[m-1].second;\\n            rep(j, m){\\n                dp[i][j][0].first = store[j].first;\\n                dp[i][j][0].second = store[j].second;\\n                dp[i][j][1].first = t_2 - (j >= 1 ? store[j-1].first:0);\\n                dp[i][j][1].second = t_5 - (j >= 1 ? store[j-1].second:0);\\n            }\\n        }\\n\\n        rep(j, m){\\n            vector<pp> store(n);  //{2, 5}\\n            rep(i, n){\\n                pp it = solve(grid[i][j]);\\n                if(i == 0){\\n                    store[i] = it;\\n                }else{\\n                    store[i] = {it.first+store[i-1].first, it.second+store[i-1].second};\\n                }\\n            }\\n            int t_2 = store[n-1].first, t_5 = store[n-1].second;\\n            rep(i, n){\\n                dp[i][j][2].first = store[i].first;\\n                dp[i][j][2].second = store[i].second;\\n                dp[i][j][3].first = t_2 - (i >= 1 ? store[i-1].first:0);\\n                dp[i][j][3].second = t_5 - (i >= 1 ? store[i-1].second:0);\\n            }\\n        }\\n        \\n        int res = 0;\\n        rep(i, n){\\n            rep(j, m){\\n                int up_max = min(dp[i][j][2].first, dp[i][j][2].second);\\n                int down_max = min(dp[i][j][3].first, dp[i][j][3].second);\\n                \\n                int left_max = min(dp[i][j][0].first, dp[i][j][0].second);\\n                int right_max = min(dp[i][j][1].first, dp[i][j][1].second);\\n                \\n                pp it = solve(grid[i][j]);\\n                //UP -> RIGHT\\n                ll twos = dp[i][j][2].first+dp[i][j][1].first-it.first;\\n                ll fives = dp[i][j][2].second+dp[i][j][1].second-it.second;\\n                \\n                ll tu = min(twos, fives);\\n                res = res < tu ? tu:res;\\n                \\n                //UP -> LEFT\\n                twos = dp[i][j][2].first+dp[i][j][0].first-it.first;\\n                fives = dp[i][j][2].second+dp[i][j][0].second-it.second;\\n                \\n                tu = min(twos, fives);\\n                res = res < tu ? tu:res;\\n                \\n                //LEFT -> DOWN\\n                twos = dp[i][j][0].first+dp[i][j][3].first-it.first;\\n                fives = dp[i][j][0].second+dp[i][j][3].second-it.second;\\n                \\n                tu = min(twos, fives);\\n                res = res < tu ? tu:res;\\n                \\n                //DOWN -> RIGHT\\n                twos = dp[i][j][3].first+dp[i][j][1].first-it.first;\\n                fives = dp[i][j][3].second+dp[i][j][1].second-it.second;\\n                \\n                tu = min(twos, fives);\\n                res = res < tu ? tu:res;\\n            }\\n        }\\n        \\n        return (int)res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959923,
                "title": "python-iterative-prefix-sum-factor-caching-beats-100-2601-ms",
                "content": "```\\nclass Solution(object):\\n    def maxTrailingZeros(self, grid):\\n        m = len(grid)\\n        n = len(grid[0])\\n        factors = {}\\n        for val in range(1, 1001):\\n            num = val\\n            cnt2, cnt5 = 0, 0\\n            while num > 0 and num % 2 == 0: \\n                cnt2 += 1\\n                num = num / 2\\n            while num > 0 and num % 5 == 0: \\n                cnt5 += 1\\n                num = num / 5\\n            factors[val] = (cnt2, cnt5)\\n        row2, row5, col2, col5 = [], [], [], []\\n        for i in range(m + 1): \\n            row2.append([0]*(n + 1))\\n            col2.append([0]*(n + 1))\\n            row5.append([0]*(n + 1))\\n            col5.append([0]*(n + 1))\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                cnt2, cnt5 = factors[grid[i - 1][j - 1]]\\n                row2[i][j] = cnt2 + row2[i][j - 1]\\n                row5[i][j] = cnt5 + row5[i][j - 1]\\n                col2[i][j] = cnt2 + col2[i - 1][j]\\n                col5[i][j] = cnt5 + col5[i - 1][j]\\n        res = 0\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                cnt2, cnt5 = factors[grid[i - 1][j - 1]]\\n                top2, top5 = col2[i-1][j], col5[i-1][j]\\n                bottom2, bottom5 = col2[m][j] - col2[i][j], col5[m][j] - col5[i][j]\\n                left2, left5 = row2[i][j-1], row5[i][j-1]\\n                right2, right5 = row2[i][n] - row2[i][j], row5[i][n] - row5[i][j]\\n                res = max(res, min(top2 + left2 + cnt2, top5 + left5 + cnt5), min(top2 + right2 + cnt2, top5 + right5 + cnt5), min(bottom2 + left2 + cnt2, bottom5 + left5 + cnt5), min(bottom2 + right2 + cnt2, bottom5 + right5 + cnt5))\\n        return res\\n                \\n                \\n                \\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxTrailingZeros(self, grid):\\n        m = len(grid)\\n        n = len(grid[0])\\n        factors = {}\\n        for val in range(1, 1001):\\n            num = val\\n            cnt2, cnt5 = 0, 0\\n            while num > 0 and num % 2 == 0: \\n                cnt2 += 1\\n                num = num / 2\\n            while num > 0 and num % 5 == 0: \\n                cnt5 += 1\\n                num = num / 5\\n            factors[val] = (cnt2, cnt5)\\n        row2, row5, col2, col5 = [], [], [], []\\n        for i in range(m + 1): \\n            row2.append([0]*(n + 1))\\n            col2.append([0]*(n + 1))\\n            row5.append([0]*(n + 1))\\n            col5.append([0]*(n + 1))\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                cnt2, cnt5 = factors[grid[i - 1][j - 1]]\\n                row2[i][j] = cnt2 + row2[i][j - 1]\\n                row5[i][j] = cnt5 + row5[i][j - 1]\\n                col2[i][j] = cnt2 + col2[i - 1][j]\\n                col5[i][j] = cnt5 + col5[i - 1][j]\\n        res = 0\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                cnt2, cnt5 = factors[grid[i - 1][j - 1]]\\n                top2, top5 = col2[i-1][j], col5[i-1][j]\\n                bottom2, bottom5 = col2[m][j] - col2[i][j], col5[m][j] - col5[i][j]\\n                left2, left5 = row2[i][j-1], row5[i][j-1]\\n                right2, right5 = row2[i][n] - row2[i][j], row5[i][n] - row5[i][j]\\n                res = max(res, min(top2 + left2 + cnt2, top5 + left5 + cnt5), min(top2 + right2 + cnt2, top5 + right5 + cnt5), min(bottom2 + left2 + cnt2, bottom5 + left5 + cnt5), min(bottom2 + right2 + cnt2, bottom5 + right5 + cnt5))\\n        return res\\n                \\n                \\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959808,
                "title": "c-self-explanatory-more-readable-code-prefix-sum",
                "content": "```\\n// Trailing Zeros => Count of 10\\'s in a number => 10 = 2*5 => minimum (sum of 2 exponents, sum of 5 exponents)\\n// Apporach : Prefix Sum of Count of 2\\'s and 5\\'s + Suffix Sum of Count of 2\\'s and 5\\'s | Time - O(4*m*n), Space - O(2*m*n)\\n\\nclass Pair{\\npublic:\\n    int countOfTwo;\\n    int countOfFive;\\n    \\n    Pair(){\\n        countOfTwo = 0;\\n        countOfTwo = 0;\\n    }\\n    \\n    Pair(int two, int five){\\n        countOfTwo = two;\\n        countOfFive = five;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<Pair>> prefix(m, vector<Pair>(n));\\n        vector<vector<Pair>> suffix(m, vector<Pair>(n));\\n        \\n        // Find the Prefix Sum of Count of 2\\'s and 5\\'s \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                prefix[i][j]  = findCountTwoAndFive(grid[i][j]);\\n                \\n                if(j!=0){\\n                    prefix[i][j].countOfTwo += prefix[i][j-1].countOfTwo;\\n                    prefix[i][j].countOfFive += prefix[i][j-1].countOfFive;\\n                }\\n            }\\n        }\\n        \\n        // Find the Suffix Sum of Count of 2\\'s and 5\\'s \\n        for(int i=0; i<m; i++){\\n            for(int j=n-1; j>=0; j--){\\n                suffix[i][j]  = findCountTwoAndFive(grid[i][j]);\\n                \\n                if(j!=n-1){\\n                    suffix[i][j].countOfTwo += suffix[i][j+1].countOfTwo;\\n                    suffix[i][j].countOfFive += suffix[i][j+1].countOfFive;\\n                }\\n            }\\n        }\\n        \\n        //                                                        __   __\\n        // Traverse the each valid concerned Path => |__ ,  __| ,  |  ,|  \\n        // and calculate the trailing zeros and then take max of it\\n        // We\\'re traversing each column and then each row\\n        \\n        // First Traverse the concerned Path  of type:|__ ,  __|\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            int count2 = 0, count5 = 0;\\n            for(int j=0; j<m; j++){\\n                \\n                ans = max(ans, min(count2 + prefix[j][i].countOfTwo, count5 + prefix[j][i].countOfFive));\\n                ans = max(ans, min(count2 + suffix[j][i].countOfTwo, count5 + suffix[j][i].countOfFive));\\n                \\n                Pair p = findCountTwoAndFive(grid[j][i]);\\n                count2 += p.countOfTwo, count5 += p.countOfFive;\\n            }\\n        }\\n        \\n         //                                                        __   __\\n        // Second Traverse the concerned Path  of type:             | , | \\n        for(int i=0; i<n; i++){\\n            int count2 = 0, count5 = 0;\\n            for(int j=m-1; j>=0; j--){\\n                \\n                ans = max(ans, min(count2 + prefix[j][i].countOfTwo, count5 + prefix[j][i].countOfFive));\\n                ans = max(ans, min(count2 + suffix[j][i].countOfTwo, count5 + suffix[j][i].countOfFive));\\n                \\n                Pair p = findCountTwoAndFive(grid[j][i]);\\n                count2 += p.countOfTwo, count5 += p.countOfFive;\\n            }\\n        }\\n        \\n        // Now return ans\\n        return ans;\\n    }\\nprivate:\\n    Pair findCountTwoAndFive(int num){\\n        int two = 0, five = 0;\\n        while(num%2==0){\\n            two++;\\n            num /= 2;\\n        }\\n                \\n        while(num%5==0){\\n            five++;\\n            num /= 5;\\n        }\\n                \\n        return Pair(two, five);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Trailing Zeros => Count of 10\\'s in a number => 10 = 2*5 => minimum (sum of 2 exponents, sum of 5 exponents)\\n// Apporach : Prefix Sum of Count of 2\\'s and 5\\'s + Suffix Sum of Count of 2\\'s and 5\\'s | Time - O(4*m*n), Space - O(2*m*n)\\n\\nclass Pair{\\npublic:\\n    int countOfTwo;\\n    int countOfFive;\\n    \\n    Pair(){\\n        countOfTwo = 0;\\n        countOfTwo = 0;\\n    }\\n    \\n    Pair(int two, int five){\\n        countOfTwo = two;\\n        countOfFive = five;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<Pair>> prefix(m, vector<Pair>(n));\\n        vector<vector<Pair>> suffix(m, vector<Pair>(n));\\n        \\n        // Find the Prefix Sum of Count of 2\\'s and 5\\'s \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                prefix[i][j]  = findCountTwoAndFive(grid[i][j]);\\n                \\n                if(j!=0){\\n                    prefix[i][j].countOfTwo += prefix[i][j-1].countOfTwo;\\n                    prefix[i][j].countOfFive += prefix[i][j-1].countOfFive;\\n                }\\n            }\\n        }\\n        \\n        // Find the Suffix Sum of Count of 2\\'s and 5\\'s \\n        for(int i=0; i<m; i++){\\n            for(int j=n-1; j>=0; j--){\\n                suffix[i][j]  = findCountTwoAndFive(grid[i][j]);\\n                \\n                if(j!=n-1){\\n                    suffix[i][j].countOfTwo += suffix[i][j+1].countOfTwo;\\n                    suffix[i][j].countOfFive += suffix[i][j+1].countOfFive;\\n                }\\n            }\\n        }\\n        \\n        //                                                        __   __\\n        // Traverse the each valid concerned Path => |__ ,  __| ,  |  ,|  \\n        // and calculate the trailing zeros and then take max of it\\n        // We\\'re traversing each column and then each row\\n        \\n        // First Traverse the concerned Path  of type:|__ ,  __|\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            int count2 = 0, count5 = 0;\\n            for(int j=0; j<m; j++){\\n                \\n                ans = max(ans, min(count2 + prefix[j][i].countOfTwo, count5 + prefix[j][i].countOfFive));\\n                ans = max(ans, min(count2 + suffix[j][i].countOfTwo, count5 + suffix[j][i].countOfFive));\\n                \\n                Pair p = findCountTwoAndFive(grid[j][i]);\\n                count2 += p.countOfTwo, count5 += p.countOfFive;\\n            }\\n        }\\n        \\n         //                                                        __   __\\n        // Second Traverse the concerned Path  of type:             | , | \\n        for(int i=0; i<n; i++){\\n            int count2 = 0, count5 = 0;\\n            for(int j=m-1; j>=0; j--){\\n                \\n                ans = max(ans, min(count2 + prefix[j][i].countOfTwo, count5 + prefix[j][i].countOfFive));\\n                ans = max(ans, min(count2 + suffix[j][i].countOfTwo, count5 + suffix[j][i].countOfFive));\\n                \\n                Pair p = findCountTwoAndFive(grid[j][i]);\\n                count2 += p.countOfTwo, count5 += p.countOfFive;\\n            }\\n        }\\n        \\n        // Now return ans\\n        return ans;\\n    }\\nprivate:\\n    Pair findCountTwoAndFive(int num){\\n        int two = 0, five = 0;\\n        while(num%2==0){\\n            two++;\\n            num /= 2;\\n        }\\n                \\n        while(num%5==0){\\n            five++;\\n            num /= 5;\\n        }\\n                \\n        return Pair(two, five);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959722,
                "title": "can-someone-help-me-where-i-m-going-wrong",
                "content": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m=len(grid[0])\\n        n=len(grid)\\n        def checkZeros(num):\\n            count=0\\n            while num%10 ==0 and num!=0:\\n                count+=1\\n                num//=10\\n            return count\\n        preRow=[[1 for i in range(len(grid[0]))] for j in range(n)]\\n        preCol=[[1 for i in range(len(grid[0]))] for j in range(n)]\\n        totalRow=[1 for i in range(n)]\\n        totalCol=[1 for i in range(m)]\\n        for i in range(n):\\n            pro=1\\n            for j in range(m):\\n                pro*=grid[i][j]\\n                preRow[i][j]=pro\\n            totalRow[i]=pro\\n        for i in range(m):\\n            pro=1\\n            for j in range(n):\\n                pro*=grid[j][i]\\n                preCol[j][i]=pro\\n            totalCol[i]=pro\\n        maxx=0\\n        for i in range(m):\\n            pro=1\\n            for j in range(n):\\n                maxx=max(maxx,checkZeros(pro*preRow[j][i]))\\n                pro*=grid[j][i]\\n                maxx=max(maxx,checkZeros(pro*(totalRow[j]//preRow[j][i])))\\n        for i in range(n):\\n            pro=1\\n            for j in range(m):\\n                maxx=max(maxx,checkZeros(pro*preCol[i][j]))\\n                pro*=grid[i][j]\\n                maxx=max(maxx,checkZeros(pro*(totalCol[j]//preCol[i][j])))\\n        return maxx\\n   \\n```\\nwhy is this code failing for this test case\\n[[534,575,625,84,20,999,35],[208,318,96,380,819,102,669]]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m=len(grid[0])\\n        n=len(grid)\\n        def checkZeros(num):\\n            count=0\\n            while num%10 ==0 and num!=0:\\n                count+=1\\n                num//=10\\n            return count\\n        preRow=[[1 for i in range(len(grid[0]))] for j in range(n)]\\n        preCol=[[1 for i in range(len(grid[0]))] for j in range(n)]\\n        totalRow=[1 for i in range(n)]\\n        totalCol=[1 for i in range(m)]\\n        for i in range(n):\\n            pro=1\\n            for j in range(m):\\n                pro*=grid[i][j]\\n                preRow[i][j]=pro\\n            totalRow[i]=pro\\n        for i in range(m):\\n            pro=1\\n            for j in range(n):\\n                pro*=grid[j][i]\\n                preCol[j][i]=pro\\n            totalCol[i]=pro\\n        maxx=0\\n        for i in range(m):\\n            pro=1\\n            for j in range(n):\\n                maxx=max(maxx,checkZeros(pro*preRow[j][i]))\\n                pro*=grid[j][i]\\n                maxx=max(maxx,checkZeros(pro*(totalRow[j]//preRow[j][i])))\\n        for i in range(n):\\n            pro=1\\n            for j in range(m):\\n                maxx=max(maxx,checkZeros(pro*preCol[i][j]))\\n                pro*=grid[i][j]\\n                maxx=max(maxx,checkZeros(pro*(totalCol[j]//preCol[i][j])))\\n        return maxx\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959632,
                "title": "python3-dp-concise-recursive-19-lines-iterative-beats-100",
                "content": "Starting from any cell[i][j], we go 4 directions top,left, right, down. Go until meeting boundary. Then pick any 2 directions plus cell[i][j] itself to make a \\'cornered line\\', totally 6 combinations: \\'left+cell+top\\', \\'left+cell+down\\', \\'left+cell+right\\', \\'top+cell+right\\', \\'top+cell+down\\', \\'right+cell+down\\'. Calculating scores for these 6 lines and we will know the highest score that passes cell[i][j]. \\nDo the same for all cells and the highest among highest score is the final result. We use 2D prefix sum for 4 directions to achieve O(1) time for each cell.\\n\\nRecursive: 8274ms beats 50%\\n```\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        @functools.lru_cache(None)\\n        def factors(num,factor):\\n            if num%factor!=0: return 0\\n            return 1+factors(num//factor,factor)\\n        @functools.lru_cache(None)\\n        def dp(i,j,d):\\n            if 0<=i<m and 0<=j<n:\\n                tmp2,tmp5 = dp(i+d[0],j+d[1],d)\\n                return factors(grid[i][j],2)+tmp2,factors(grid[i][j],5)+tmp5\\n            return 0,0\\n        combo = [[a,b] for a,b in combinations([(-1,0),(0,-1),(1,0),(0,1)],2) if a[0]+b[0]!=0 or a[1]+b[1]!=0]\\n        m,n,res=len(grid),len(grid[0]),0\\n        for i in range(m):\\n            for j in range(n):\\n                cur = (factors(grid[i][j],2),factors(grid[i][j],5))\\n                for dir1, dir2 in combo:\\n                    d1,d2=dp(i,j,dir1),dp(i,j,dir2)\\n                    res = max(res,min(d1[0]+d2[0]-cur[0],d1[1]+d2[1]-cur[1]))\\n        return res\\n```\\n\\nTo make it even faster\\n\\t1. We don\\'t need to prepare 2D prefix sum for all 4 directions, but only \\'up\\' and \\'left\\'. Because \\'right\\' and \\'down\\' can be calculated using \\'up\\' and \\'left\\'.\\n\\t2. We don\\'t need to go all 6 combinations of 4 directions, but only 4. No need to calculate the 4 \\'straight line\\' combinations, because for each of them there must exists a \\'corner line\\' that completely covers it.\\n\\t3. The function to count factors \\'2\\' and \\'5\\' can be cached and put to global to share across test cases\\n\\nIterative, 4556ms beats 100%\\n```\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n\\t\\t@functools.lru_cache(None)\\n        def factors(num,factor):\\n            if num%factor!=0: return 0\\n            return 1+factors(num//factor,factor)\\n        m,n=len(grid),len(grid[0])\\n        up=[[(0,0) for _ in range(n)]  for _ in range(m)]\\n        left=[[(0,0) for _ in range(n)]  for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                cur = (factors(grid[i][j],2),factors(grid[i][j],5))\\n                grid[i][j] = cur\\n                up_prev,left_prev = up[i-1][j], left[i][j-1]\\n                up[i][j] = [up_prev[0]+cur[0],up_prev[1]+cur[1]]\\n                left[i][j] = [left_prev[0]+cur[0],left_prev[1]+cur[1]]\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                up1,left1,cur = up[i][j], left[i][j], grid[i][j]\\n                right1 = [left[i][-1][0]-left1[0]+cur[0],left[i][-1][1]-left1[1]+cur[1]]\\n                down1 = [up[-1][j][0]-up1[0]+cur[0],up[-1][j][1]-up1[1]+cur[1]]\\n                a = min(left1[0]+up1[0]-cur[0],left1[1]+up1[1]-cur[1])\\n                b = min(up1[0]+right1[0]-cur[0],up1[1]+right1[1]-cur[1])\\n                c = min(left1[0]+down1[0]-cur[0],left1[1]+down1[1]-cur[1])\\n                d = min(right1[0]+down1[0]-cur[0],right1[1]+down1[1]-cur[1])\\n                res = max(res,a,b,c,d)\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        @functools.lru_cache(None)\\n        def factors(num,factor):\\n            if num%factor!=0: return 0\\n            return 1+factors(num//factor,factor)\\n        @functools.lru_cache(None)\\n        def dp(i,j,d):\\n            if 0<=i<m and 0<=j<n:\\n                tmp2,tmp5 = dp(i+d[0],j+d[1],d)\\n                return factors(grid[i][j],2)+tmp2,factors(grid[i][j],5)+tmp5\\n            return 0,0\\n        combo = [[a,b] for a,b in combinations([(-1,0),(0,-1),(1,0),(0,1)],2) if a[0]+b[0]!=0 or a[1]+b[1]!=0]\\n        m,n,res=len(grid),len(grid[0]),0\\n        for i in range(m):\\n            for j in range(n):\\n                cur = (factors(grid[i][j],2),factors(grid[i][j],5))\\n                for dir1, dir2 in combo:\\n                    d1,d2=dp(i,j,dir1),dp(i,j,dir2)\\n                    res = max(res,min(d1[0]+d2[0]-cur[0],d1[1]+d2[1]-cur[1]))\\n        return res\\n```\n```\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n\\t\\t@functools.lru_cache(None)\\n        def factors(num,factor):\\n            if num%factor!=0: return 0\\n            return 1+factors(num//factor,factor)\\n        m,n=len(grid),len(grid[0])\\n        up=[[(0,0) for _ in range(n)]  for _ in range(m)]\\n        left=[[(0,0) for _ in range(n)]  for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                cur = (factors(grid[i][j],2),factors(grid[i][j],5))\\n                grid[i][j] = cur\\n                up_prev,left_prev = up[i-1][j], left[i][j-1]\\n                up[i][j] = [up_prev[0]+cur[0],up_prev[1]+cur[1]]\\n                left[i][j] = [left_prev[0]+cur[0],left_prev[1]+cur[1]]\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                up1,left1,cur = up[i][j], left[i][j], grid[i][j]\\n                right1 = [left[i][-1][0]-left1[0]+cur[0],left[i][-1][1]-left1[1]+cur[1]]\\n                down1 = [up[-1][j][0]-up1[0]+cur[0],up[-1][j][1]-up1[1]+cur[1]]\\n                a = min(left1[0]+up1[0]-cur[0],left1[1]+up1[1]-cur[1])\\n                b = min(up1[0]+right1[0]-cur[0],up1[1]+right1[1]-cur[1])\\n                c = min(left1[0]+down1[0]-cur[0],left1[1]+down1[1]-cur[1])\\n                d = min(right1[0]+down1[0]-cur[0],right1[1]+down1[1]-cur[1])\\n                res = max(res,a,b,c,d)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1959465,
                "title": "scala",
                "content": "```\\nimport scala.annotation.tailrec\\nimport scala.math.min\\n\\nobject Solution {\\n  def maxTrailingZeros(grid: Array[Array[Int]]): Int = {\\n    val m = grid.length\\n    val n = grid.headOption.map(_.length).getOrElse(0)\\n    val numFactors = grid.map(_.map(x => (computeNumFactors(x, 2), computeNumFactors(x, 5))))\\n    val verticalCumFactors = (0 until n).map(j => (0 until m).view.map(numFactors(_)(j)).scan(0, 0)(_ + _).toIndexedSeq)\\n    (0 until m)\\n      .iterator\\n      .flatMap { i =>\\n        val horizontalCumFactors = numFactors(i).scan(0, 0)(_ + _)\\n        (0 until n)\\n          .iterator\\n          .flatMap { j =>\\n            Iterator(horizontalCumFactors(j + 1) + verticalCumFactors(j)(i),\\n                     horizontalCumFactors(j + 1) + verticalCumFactors(j).last - verticalCumFactors(j)(i + 1),\\n                     horizontalCumFactors.last - horizontalCumFactors(j) + verticalCumFactors(j)(i),\\n                     horizontalCumFactors.last -\\n                       horizontalCumFactors(j) +\\n                       verticalCumFactors(j).last -\\n                       verticalCumFactors(j)(i + 1))\\n          }\\n      }\\n      .map { case (numTwos, numFives) => min(numTwos, numFives) }\\n      .maxOption\\n      .getOrElse(0)\\n  }\\n\\n  @tailrec\\n  private def computeNumFactors(x: Int, factor: Int, count: Int = 0): Int = x match {\\n    case x if x != 0 && x % factor == 0 => computeNumFactors(x / factor, factor, count + 1)\\n    case _ => count\\n  }\\n\\n  private implicit class RichTuple2[+A, +B](x: (A, B)) {\\n    def +[A1 >: A, B1 >: B](y: (A1, B1))(implicit a1Numeric: Numeric[A1], b1Numeric: Numeric[B1]): (A1, B1) = {\\n      (a1Numeric.plus(x._1, y._1), b1Numeric.plus(x._2, y._2))\\n    }\\n\\n    def -[A1 >: A, B1 >: B](y: (A1, B1))(implicit a1Numeric: Numeric[A1], b1Numeric: Numeric[B1]): (A1, B1) = {\\n      (a1Numeric.minus(x._1, y._1), b1Numeric.minus(x._2, y._2))\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Prefix Sum"
                ],
                "code": "```\\nimport scala.annotation.tailrec\\nimport scala.math.min\\n\\nobject Solution {\\n  def maxTrailingZeros(grid: Array[Array[Int]]): Int = {\\n    val m = grid.length\\n    val n = grid.headOption.map(_.length).getOrElse(0)\\n    val numFactors = grid.map(_.map(x => (computeNumFactors(x, 2), computeNumFactors(x, 5))))\\n    val verticalCumFactors = (0 until n).map(j => (0 until m).view.map(numFactors(_)(j)).scan(0, 0)(_ + _).toIndexedSeq)\\n    (0 until m)\\n      .iterator\\n      .flatMap { i =>\\n        val horizontalCumFactors = numFactors(i).scan(0, 0)(_ + _)\\n        (0 until n)\\n          .iterator\\n          .flatMap { j =>\\n            Iterator(horizontalCumFactors(j + 1) + verticalCumFactors(j)(i),\\n                     horizontalCumFactors(j + 1) + verticalCumFactors(j).last - verticalCumFactors(j)(i + 1),\\n                     horizontalCumFactors.last - horizontalCumFactors(j) + verticalCumFactors(j)(i),\\n                     horizontalCumFactors.last -\\n                       horizontalCumFactors(j) +\\n                       verticalCumFactors(j).last -\\n                       verticalCumFactors(j)(i + 1))\\n          }\\n      }\\n      .map { case (numTwos, numFives) => min(numTwos, numFives) }\\n      .maxOption\\n      .getOrElse(0)\\n  }\\n\\n  @tailrec\\n  private def computeNumFactors(x: Int, factor: Int, count: Int = 0): Int = x match {\\n    case x if x != 0 && x % factor == 0 => computeNumFactors(x / factor, factor, count + 1)\\n    case _ => count\\n  }\\n\\n  private implicit class RichTuple2[+A, +B](x: (A, B)) {\\n    def +[A1 >: A, B1 >: B](y: (A1, B1))(implicit a1Numeric: Numeric[A1], b1Numeric: Numeric[B1]): (A1, B1) = {\\n      (a1Numeric.plus(x._1, y._1), b1Numeric.plus(x._2, y._2))\\n    }\\n\\n    def -[A1 >: A, B1 >: B](y: (A1, B1))(implicit a1Numeric: Numeric[A1], b1Numeric: Numeric[B1]): (A1, B1) = {\\n      (a1Numeric.minus(x._1, y._1), b1Numeric.minus(x._2, y._2))\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959403,
                "title": "10-54-test-cases-passed-can-someone-help-figure-out-where-i-m-going-wrong",
                "content": "Hi, I implemented the prefix sum solution but only 10 testcases passed, I am struggling to figure out what is wrong. Can someone help.\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar maxTrailingZeros = function(grid) {\\n    let ans = 0\\n    let m = grid.length, n=grid[0].length\\n    \\n    const prefixH = new Array(m), prefixV = new Array(m)\\n    for (let i=0; i<m; i++) {\\n        prefixH[i] = new Array(n)\\n        prefixV[i] = new Array(n)\\n        for (let j=0; j<n; j++) {\\n            prefixH[i][j] = [0, 0]\\n            prefixV[i][j] = [0, 0]\\n        }\\n    }\\n    \\n    for (let i=0; i<m; i++) {\\n        for (let j=0; j<n; j++) {\\n            let value = grid[i][j]\\n            while (value % 2 == 0) {\\n                prefixH[i][j][0] += 1\\n                prefixV[i][j][0] += 1\\n                value = value / 2\\n            }\\n            while (value % 5 == 0) {\\n                prefixH[i][j][1] += 1\\n                prefixV[i][j][1] += 1\\n                value = value / 5\\n            }\\n            if (i > 0) {\\n                prefixH[i][j][0] += prefixH[i-1][j][0]\\n                prefixH[i][j][1] += prefixH[i-1][j][1]\\n            }\\n            if (j > 0) {\\n                prefixV[i][j][0] += prefixV[i][j-1][0]\\n                prefixV[i][j][1] += prefixV[i][j-1][1]\\n            }\\n        }\\n    }\\n    for (let i=0; i<m; i++) {\\n        for (let j=0; j<n; j++) {\\n            const left = prefixH[i][j]\\n            const up = prefixV[i][j]\\n            const right = [0, 0]\\n            const down = [0, 0]\\n            const center = prefixH[i][j]\\n            \\n            // const lU = [0, 0], lD = [0, 0], rU = [0, 0], rD = [0, 0]\\n            \\n            if (i < m-1) {\\n                down[0] = prefixV[m-1][j][0] - prefixV[i][j][0]\\n                down[1] = prefixV[m-1][j][1] - prefixV[i][j][1]\\n            }\\n            if (i > 0) {\\n                center[0] -= prefixH[i-1][j][0]\\n                center[1] -= prefixH[i-1][j][1]\\n            }\\n            if (j < n-1) {\\n                right[0] = prefixH[i][n-1][0] - prefixH[i][j][0]\\n                right[1] = prefixH[i][n-1][1] - prefixH[i][j][1]\\n            }\\n            const lU = [\\n                left[0]+up[0], left[1]+up[1]\\n            ]\\n            const lD = [\\n                left[0]+down[0], left[1]+down[1]\\n            ]\\n            const rU = [\\n                right[0]+up[0], right[1]+up[1]\\n            ]\\n            const rD = [\\n                right[0]+down[0], right[1]+down[1]\\n            ]\\n            const maxMin = Math.max(\\n                    Math.min(...lU),\\n                    Math.min(...lD),\\n                    Math.min(...rU),\\n                    Math.min(...rD),\\n                    Math.min(...center)\\n            )\\n            // console.log(i, j, lU, lD, rU, rD, center, maxMin)\\n            ans = Math.max(ans, maxMin)\\n        }\\n    }\\n    // console.log(\\'PrefixH\\', prefixH)\\n    // console.log(\\'PrefixV\\', prefixV)\\n    \\n    return ans\\n    \\n};\\n\\n```\\nThe testcase that fails is \\n[[824,709,193,413,701,836,727],[135,844,599,211,140,933,205],[329,68,285,282,301,387,231],[293,210,478,352,946,902,137],[806,900,290,636,589,522,611],[450,568,990,592,992,128,92],[780,653,795,457,980,942,927],[849,901,604,906,912,866,688]]\\nOutput: 5\\nExpected: 6",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar maxTrailingZeros = function(grid) {\\n    let ans = 0\\n    let m = grid.length, n=grid[0].length\\n    \\n    const prefixH = new Array(m), prefixV = new Array(m)\\n    for (let i=0; i<m; i++) {\\n        prefixH[i] = new Array(n)\\n        prefixV[i] = new Array(n)\\n        for (let j=0; j<n; j++) {\\n            prefixH[i][j] = [0, 0]\\n            prefixV[i][j] = [0, 0]\\n        }\\n    }\\n    \\n    for (let i=0; i<m; i++) {\\n        for (let j=0; j<n; j++) {\\n            let value = grid[i][j]\\n            while (value % 2 == 0) {\\n                prefixH[i][j][0] += 1\\n                prefixV[i][j][0] += 1\\n                value = value / 2\\n            }\\n            while (value % 5 == 0) {\\n                prefixH[i][j][1] += 1\\n                prefixV[i][j][1] += 1\\n                value = value / 5\\n            }\\n            if (i > 0) {\\n                prefixH[i][j][0] += prefixH[i-1][j][0]\\n                prefixH[i][j][1] += prefixH[i-1][j][1]\\n            }\\n            if (j > 0) {\\n                prefixV[i][j][0] += prefixV[i][j-1][0]\\n                prefixV[i][j][1] += prefixV[i][j-1][1]\\n            }\\n        }\\n    }\\n    for (let i=0; i<m; i++) {\\n        for (let j=0; j<n; j++) {\\n            const left = prefixH[i][j]\\n            const up = prefixV[i][j]\\n            const right = [0, 0]\\n            const down = [0, 0]\\n            const center = prefixH[i][j]\\n            \\n            // const lU = [0, 0], lD = [0, 0], rU = [0, 0], rD = [0, 0]\\n            \\n            if (i < m-1) {\\n                down[0] = prefixV[m-1][j][0] - prefixV[i][j][0]\\n                down[1] = prefixV[m-1][j][1] - prefixV[i][j][1]\\n            }\\n            if (i > 0) {\\n                center[0] -= prefixH[i-1][j][0]\\n                center[1] -= prefixH[i-1][j][1]\\n            }\\n            if (j < n-1) {\\n                right[0] = prefixH[i][n-1][0] - prefixH[i][j][0]\\n                right[1] = prefixH[i][n-1][1] - prefixH[i][j][1]\\n            }\\n            const lU = [\\n                left[0]+up[0], left[1]+up[1]\\n            ]\\n            const lD = [\\n                left[0]+down[0], left[1]+down[1]\\n            ]\\n            const rU = [\\n                right[0]+up[0], right[1]+up[1]\\n            ]\\n            const rD = [\\n                right[0]+down[0], right[1]+down[1]\\n            ]\\n            const maxMin = Math.max(\\n                    Math.min(...lU),\\n                    Math.min(...lD),\\n                    Math.min(...rU),\\n                    Math.min(...rD),\\n                    Math.min(...center)\\n            )\\n            // console.log(i, j, lU, lD, rU, rD, center, maxMin)\\n            ans = Math.max(ans, maxMin)\\n        }\\n    }\\n    // console.log(\\'PrefixH\\', prefixH)\\n    // console.log(\\'PrefixV\\', prefixV)\\n    \\n    return ans\\n    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1958835,
                "title": "clean-java-solution-beat-100",
                "content": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][][] down = new int[m][n][2];\\n        int[][][] up = new int[m][n][2];\\n        int[][][] left = new int[m][n][2];\\n        int[][][] right = new int[m][n][2];\\n        \\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                int two = divide(grid[i][j], 2);\\n                int five =  divide(grid[i][j], 5);\\n                \\n                up[i][j][0] = (i == 0)? two : two + up[i - 1][j][0];\\n                left[i][j][0] = (j == 0)? two : two + left[i][j - 1][0];\\n                up[i][j][1] = (i == 0)? five : five + up[i - 1][j][1];\\n                left[i][j][1] = (j == 0)? five : five + left[i][j - 1][1];\\n            }\\n        }\\n        \\n        for(int i = m - 1; i >= 0; --i) {\\n            for(int j = n - 1; j >= 0; --j) {\\n                int two = divide(grid[i][j], 2);\\n                int five =  divide(grid[i][j], 5);\\n                \\n                down[i][j][0] = (i == m - 1)? two : two + down[i + 1][j][0];\\n                right[i][j][0] = (j == n - 1)? two : two + right[i][j + 1][0];\\n                down[i][j][1] = (i == m - 1)? five : five + down[i + 1][j][1];\\n                right[i][j][1] = (j == n - 1)? five : five + right[i][j + 1][1];\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                int two = divide(grid[i][j], 2);\\n                int five = divide(grid[i][j], 5);\\n                \\n                int sol1 = Math.min(up[i][j][0] + right[i][j][0] - two, up[i][j][1] + right[i][j][1] - five);\\n                int sol2 = Math.min(right[i][j][0] + down[i][j][0] - two, right[i][j][1] + down[i][j][1] - five);\\n                int sol3 = Math.min(down[i][j][0] + left[i][j][0] - two, down[i][j][1] + left[i][j][1] - five);\\n                int sol4 = Math.min(left[i][j][0] + up[i][j][0] - two, left[i][j][1] + up[i][j][1] - five);\\n\\n                res = Math.max(res, Math.max(Math.max(sol1, sol2), Math.max(sol3, sol4)));\\n                \\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int divide(int val, int d) {\\n        //System.out.println(val);\\n        int res = 0;\\n        while(val > 0 && val % d == 0) {\\n            ++res;\\n            val /= d;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][][] down = new int[m][n][2];\\n        int[][][] up = new int[m][n][2];\\n        int[][][] left = new int[m][n][2];\\n        int[][][] right = new int[m][n][2];\\n        \\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                int two = divide(grid[i][j], 2);\\n                int five =  divide(grid[i][j], 5);\\n                \\n                up[i][j][0] = (i == 0)? two : two + up[i - 1][j][0];\\n                left[i][j][0] = (j == 0)? two : two + left[i][j - 1][0];\\n                up[i][j][1] = (i == 0)? five : five + up[i - 1][j][1];\\n                left[i][j][1] = (j == 0)? five : five + left[i][j - 1][1];\\n            }\\n        }\\n        \\n        for(int i = m - 1; i >= 0; --i) {\\n            for(int j = n - 1; j >= 0; --j) {\\n                int two = divide(grid[i][j], 2);\\n                int five =  divide(grid[i][j], 5);\\n                \\n                down[i][j][0] = (i == m - 1)? two : two + down[i + 1][j][0];\\n                right[i][j][0] = (j == n - 1)? two : two + right[i][j + 1][0];\\n                down[i][j][1] = (i == m - 1)? five : five + down[i + 1][j][1];\\n                right[i][j][1] = (j == n - 1)? five : five + right[i][j + 1][1];\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                int two = divide(grid[i][j], 2);\\n                int five = divide(grid[i][j], 5);\\n                \\n                int sol1 = Math.min(up[i][j][0] + right[i][j][0] - two, up[i][j][1] + right[i][j][1] - five);\\n                int sol2 = Math.min(right[i][j][0] + down[i][j][0] - two, right[i][j][1] + down[i][j][1] - five);\\n                int sol3 = Math.min(down[i][j][0] + left[i][j][0] - two, down[i][j][1] + left[i][j][1] - five);\\n                int sol4 = Math.min(left[i][j][0] + up[i][j][0] - two, left[i][j][1] + up[i][j][1] - five);\\n\\n                res = Math.max(res, Math.max(Math.max(sol1, sol2), Math.max(sol3, sol4)));\\n                \\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int divide(int val, int d) {\\n        //System.out.println(val);\\n        int res = 0;\\n        while(val > 0 && val % d == 0) {\\n            ++res;\\n            val /= d;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958827,
                "title": "easy-to-understand-c-code",
                "content": "Using 6 grids to store following values - \\n1. two[i][j] gives greatest exponent of two in factor of grid[i][j]\\n2. th[i][j] gives cumulative sum of all two\\'s factors horizontally, basically sum of two[i][0]...two[i][j]\\n3. tv[i][j] gives cumulative sum of all two\\'s factors vertically, basically sum of two[0][j]...two[i][j]\\n4. 5. 6. same things for five as a factor.\\n\\nThere are 3 important things to note-\\n1. In a product, numberof trailing zeroes = min(exp of 2, exp of 5 in that product)\\n2. Cumulative sum matrices will give the exponent of 2 in product of the left cumulation ( right cumulation can be found by total-leftcumulation)\\n3. Adding more number to a product can only increase trailing zeroes, so we will always calculate factors till the end.\\n\\nLastly, for any random point i,j there are two horizontal paths ((0,j)..(i,j) and (i,j)..(i,n-1))  and two vertical paths, so four cases which are being checked in the final loop\\n\\n```class Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> two(m,vector<int>(n,0));\\n        vector<vector<int>> five(m,vector<int>(n,0));\\n        vector<vector<int>> th(m,vector<int>(n,0));\\n        vector<vector<int>> fh(m,vector<int>(n,0));\\n        vector<vector<int>> tv(m,vector<int>(n,0));\\n        vector<vector<int>> fv(m,vector<int>(n,0));\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int tf=0,ff=0, num=grid[i][j];\\n                while(num%2==0){\\n                    num/=2;\\n                    tf++;\\n                }\\n                while(num%5==0){\\n                    num/=5;\\n                    ff++;\\n                }\\n                two[i][j]=tf;\\n                five[i][j]=ff;\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                th[i][j]=(j==0?two[i][j]:two[i][j]+th[i][j-1]);\\n                fh[i][j]=(j==0?five[i][j]:five[i][j]+fh[i][j-1]);\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                tv[j][i]=(j==0?two[j][i]:two[j][i]+tv[j-1][i]);\\n                fv[j][i]=(j==0?five[j][i]:five[j][i]+fv[j-1][i]);\\n            }\\n        }\\n        int maxN=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int p1=min(tv[i][j]+th[i][j]-two[i][j],fv[i][j]+fh[i][j]-five[i][j]);\\n                int p2=min(tv[i][j]+th[i][n-1]-th[i][j],fv[i][j]+fh[i][n-1]-fh[i][j]);\\n                int p3=min(tv[m-1][j]-tv[i][j]+th[i][j],fv[m-1][j]-fv[i][j]+fh[i][j]);\\n                int p4=min(tv[m-1][j]-tv[i][j]+th[i][n-1]-th[i][j]+two[i][j],fv[m-1][j]-fv[i][j]+fh[i][n-1]-fh[i][j]+five[i][j]);\\n                maxN=max(maxN,p1);\\n                maxN=max(maxN,p2);\\n                maxN=max(maxN,p3);\\n                maxN=max(maxN,p4);\\n            }\\n        }\\n        return maxN;\\n    }\\n};```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```class Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> two(m,vector<int>(n,0));\\n        vector<vector<int>> five(m,vector<int>(n,0));\\n        vector<vector<int>> th(m,vector<int>(n,0));\\n        vector<vector<int>> fh(m,vector<int>(n,0));\\n        vector<vector<int>> tv(m,vector<int>(n,0));\\n        vector<vector<int>> fv(m,vector<int>(n,0));\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int tf=0,ff=0, num=grid[i][j];\\n                while(num%2==0){\\n                    num/=2;\\n                    tf++;\\n                }\\n                while(num%5==0){\\n                    num/=5;\\n                    ff++;\\n                }\\n                two[i][j]=tf;\\n                five[i][j]=ff;\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                th[i][j]=(j==0?two[i][j]:two[i][j]+th[i][j-1]);\\n                fh[i][j]=(j==0?five[i][j]:five[i][j]+fh[i][j-1]);\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                tv[j][i]=(j==0?two[j][i]:two[j][i]+tv[j-1][i]);\\n                fv[j][i]=(j==0?five[j][i]:five[j][i]+fv[j-1][i]);\\n            }\\n        }\\n        int maxN=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int p1=min(tv[i][j]+th[i][j]-two[i][j],fv[i][j]+fh[i][j]-five[i][j]);\\n                int p2=min(tv[i][j]+th[i][n-1]-th[i][j],fv[i][j]+fh[i][n-1]-fh[i][j]);\\n                int p3=min(tv[m-1][j]-tv[i][j]+th[i][j],fv[m-1][j]-fv[i][j]+fh[i][j]);\\n                int p4=min(tv[m-1][j]-tv[i][j]+th[i][n-1]-th[i][j]+two[i][j],fv[m-1][j]-fv[i][j]+fh[i][n-1]-fh[i][j]+five[i][j]);\\n                maxN=max(maxN,p1);\\n                maxN=max(maxN,p2);\\n                maxN=max(maxN,p3);\\n                maxN=max(maxN,p4);\\n            }\\n        }\\n        return maxN;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1958726,
                "title": "python-faster-than-100-no-explanation",
                "content": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        _2s = [[0 for i in range(n)] for i in range(m)]\\n        _5s = [[0 for i in range(n)] for i in range(m)]\\n        \\n        for i, j in itertools.product(range(m), range(n)):\\n            _helper1 = grid[i][j]\\n            counter1 = 0\\n            _helper2 = grid[i][j]\\n            counter2 = 0\\n            while _helper1 % 2 == 0:\\n                _helper1 = _helper1 // 2\\n                counter1 += 1\\n            _2s[i][j] = counter1\\n            \\n            while _helper2 % 5 == 0:\\n                _helper2 = _helper2 // 5\\n                counter2 += 1\\n            _5s[i][j] = counter2\\n\\n        \\n        left_right_2s = [[0 for i in range(n)] for i in range(m)]\\n        left_right_2s_2 = [[0 for i in range(n)] for i in range(m)]\\n        up_down_2s = [[0 for i in range(n)] for i in range(m)]\\n        up_down_2s_2 = [[0 for i in range(n)] for i in range(m)]\\n        left_right_5s = [[0 for i in range(n)] for i in range(m)]\\n        left_right_5s_2 = [[0 for i in range(n)] for i in range(m)]\\n        up_down_5s = [[0 for i in range(n)] for i in range(m)]\\n        up_down_5s_2 = [[0 for i in range(n)] for i in range(m)]\\n        \\n        for i in range(m):\\n            curr_2 = 0\\n            curr_5 = 0\\n            for j in range(n):\\n                left_right_2s[i][j] = curr_2\\n                left_right_5s[i][j] = curr_5\\n                curr_2 += _2s[i][j] \\n                curr_5 += _5s[i][j]\\n                 \\n            curr_2 = 0\\n            curr_5 = 0\\n            for j in range(n - 1, -1, -1):\\n                left_right_2s_2[i][j] = curr_2\\n                left_right_5s_2[i][j] = curr_5\\n                curr_2 += _2s[i][j] \\n                curr_5 += _5s[i][j]\\n        \\n        for j in range(n):\\n            curr_2 = 0\\n            curr_5 = 0\\n            for i in range(m):\\n                up_down_2s[i][j] = curr_2\\n                up_down_5s[i][j] = curr_5\\n                curr_2 += _2s[i][j] \\n                curr_5 += _5s[i][j]\\n            curr_2 = 0\\n            curr_5 = 0\\n            for i in range(m - 1, -1, -1):\\n                up_down_2s_2[i][j] = curr_2\\n                up_down_5s_2[i][j] = curr_5\\n                curr_2 += _2s[i][j] \\n                curr_5 += _5s[i][j]\\n        \\n        res = 0\\n        for i, j in itertools.product(range(m), range(n)):\\n\\n            res = max(res, \\n                      min(up_down_2s[i][j] + left_right_2s[i][j] + _2s[i][j], up_down_5s[i][j] + left_right_5s[i][j] + _5s[i][j]),\\n                      min(up_down_2s_2[i][j] + left_right_2s_2[i][j] + _2s[i][j], up_down_5s_2[i][j] + left_right_5s_2[i][j] + _5s[i][j]),\\n                      min(up_down_2s[i][j] + left_right_2s_2[i][j] + _2s[i][j], up_down_5s[i][j] + left_right_5s_2[i][j] + _5s[i][j]),\\n                      min(up_down_2s_2[i][j] + left_right_2s[i][j] + _2s[i][j], up_down_5s_2[i][j] + left_right_5s[i][j] + _5s[i][j]),\\n                     )\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        _2s = [[0 for i in range(n)] for i in range(m)]\\n        _5s = [[0 for i in range(n)] for i in range(m)]\\n        \\n        for i, j in itertools.product(range(m), range(n)):\\n            _helper1 = grid[i][j]\\n            counter1 = 0\\n            _helper2 = grid[i][j]\\n            counter2 = 0\\n            while _helper1 % 2 == 0:\\n                _helper1 = _helper1 // 2\\n                counter1 += 1\\n            _2s[i][j] = counter1\\n            \\n            while _helper2 % 5 == 0:\\n                _helper2 = _helper2 // 5\\n                counter2 += 1\\n            _5s[i][j] = counter2\\n\\n        \\n        left_right_2s = [[0 for i in range(n)] for i in range(m)]\\n        left_right_2s_2 = [[0 for i in range(n)] for i in range(m)]\\n        up_down_2s = [[0 for i in range(n)] for i in range(m)]\\n        up_down_2s_2 = [[0 for i in range(n)] for i in range(m)]\\n        left_right_5s = [[0 for i in range(n)] for i in range(m)]\\n        left_right_5s_2 = [[0 for i in range(n)] for i in range(m)]\\n        up_down_5s = [[0 for i in range(n)] for i in range(m)]\\n        up_down_5s_2 = [[0 for i in range(n)] for i in range(m)]\\n        \\n        for i in range(m):\\n            curr_2 = 0\\n            curr_5 = 0\\n            for j in range(n):\\n                left_right_2s[i][j] = curr_2\\n                left_right_5s[i][j] = curr_5\\n                curr_2 += _2s[i][j] \\n                curr_5 += _5s[i][j]\\n                 \\n            curr_2 = 0\\n            curr_5 = 0\\n            for j in range(n - 1, -1, -1):\\n                left_right_2s_2[i][j] = curr_2\\n                left_right_5s_2[i][j] = curr_5\\n                curr_2 += _2s[i][j] \\n                curr_5 += _5s[i][j]\\n        \\n        for j in range(n):\\n            curr_2 = 0\\n            curr_5 = 0\\n            for i in range(m):\\n                up_down_2s[i][j] = curr_2\\n                up_down_5s[i][j] = curr_5\\n                curr_2 += _2s[i][j] \\n                curr_5 += _5s[i][j]\\n            curr_2 = 0\\n            curr_5 = 0\\n            for i in range(m - 1, -1, -1):\\n                up_down_2s_2[i][j] = curr_2\\n                up_down_5s_2[i][j] = curr_5\\n                curr_2 += _2s[i][j] \\n                curr_5 += _5s[i][j]\\n        \\n        res = 0\\n        for i, j in itertools.product(range(m), range(n)):\\n\\n            res = max(res, \\n                      min(up_down_2s[i][j] + left_right_2s[i][j] + _2s[i][j], up_down_5s[i][j] + left_right_5s[i][j] + _5s[i][j]),\\n                      min(up_down_2s_2[i][j] + left_right_2s_2[i][j] + _2s[i][j], up_down_5s_2[i][j] + left_right_5s_2[i][j] + _5s[i][j]),\\n                      min(up_down_2s[i][j] + left_right_2s_2[i][j] + _2s[i][j], up_down_5s[i][j] + left_right_5s_2[i][j] + _5s[i][j]),\\n                      min(up_down_2s_2[i][j] + left_right_2s[i][j] + _2s[i][j], up_down_5s_2[i][j] + left_right_5s[i][j] + _5s[i][j]),\\n                     )\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958677,
                "title": "c-prefix-sum-solution-o-n-m",
                "content": "Runtime: 744 ms, faster than 100.00% of C++ online submissions for Maximum Trailing Zeros in a Cornered Path.\\nMemory Usage: 159.2 MB, less than 100.00% of C++ online submissions for Maximum Trailing Zeros in a Cornered Path.\\n\\n\\n```\\nCount the factor of 2 and 5 in numbers and calculate prefix sum row wise and column wise in DP vector.\\nThen loop through DP and for each [row][column] position calculate 4 possible case : \\n\\n1. Left Sum + Up Sum\\n2. Right Sum + Up Sum\\n3. Left Sum + Down Sum\\n4. Right Sum + Down Sum\\n\\nHere DP contains row wise left to right prefix sum and column wise up to down prefix sum.\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // track  number of 2 and 5 in numbers row wise and column wise => row 0 , column 1 => pair<2,5> count\\n        vector<vector<vector<pair<int,int>>>>dp(m,vector<vector<pair<int,int>>>(n,vector<pair<int,int>>(2,{0,0})));\\n        \\n        // loop through grid and store the prefix sum of 2 and 5 factor count row wise and column wise\\n        int twoC, fiveC,val;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                twoC = 0;\\n                fiveC = 0;\\n                val = grid[i][j];\\n                while(val%5 ==0)\\n                {\\n                    fiveC++;\\n                    val/=5;\\n                }\\n                while(val%2 ==0)\\n                {\\n                    twoC++;\\n                    val/=2;\\n                }\\n                \\n                // row wise prefix sum of factor 2 and 5\\n                if(j > 0)\\n                {\\n                    dp[i][j][0].first += dp[i][j-1][0].first + twoC;\\n                    dp[i][j][0].second += dp[i][j-1][0].second + fiveC;\\n                }\\n                else\\n                {\\n                    dp[i][j][0].first += twoC;\\n                    dp[i][j][0].second += fiveC;                    \\n                }\\n\\n                // column wise prefix sum of factor 2 and 5\\n                if(i > 0)\\n                {\\n                    dp[i][j][1].first += dp[i-1][j][1].first + twoC;\\n                    dp[i][j][1].second += dp[i-1][j][1].second + fiveC;\\n                }\\n                else\\n                {\\n                    dp[i][j][1].first += twoC;\\n                    dp[i][j][1].second += fiveC;                    \\n                }\\n            }\\n        }\\n        \\n        // max trailing zeroes\\n        int maxZero = 0;   \\n        \\n        // loop through dp and calculate max trailing zeroes for 4 possible cases\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                // left sum + up sum \\n                maxZero = max(maxZero,min(dp[i][j][1].first + (j>0 ? dp[i][j-1][0].first : 0), dp[i][j][1].second + (j>0 ? dp[i][j-1][0].second : 0)));\\n                \\n                // right sum + up sum\\n                maxZero = max(maxZero,min(dp[i][j][1].first + (dp[i][n-1][0].first - dp[i][j][0].first), dp[i][j][1].second + (dp[i][n-1][0].second - dp[i][j][0].second)));\\n                \\n                // left sum + down sum\\n                maxZero = max(maxZero,min((dp[m-1][j][1].first - dp[i][j][1].first) + dp[i][j][0].first, (dp[m-1][j][1].second - dp[i][j][1].second) + dp[i][j][0].second));\\n                \\n                // right sum + down sum\\n                maxZero = max(maxZero,min((dp[m-1][j][1].first - dp[i][j][1].first) + (dp[i][n-1][0].first - (j>0 ? dp[i][j-1][0].first : 0)), (dp[m-1][j][1].second - dp[i][j][1].second) + (dp[i][n-1][0].second - (j> 0 ? dp[i][j-1][0].second : 0))));\\n\\n            }\\n        }\\n        \\n        \\n        return maxZero;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nCount the factor of 2 and 5 in numbers and calculate prefix sum row wise and column wise in DP vector.\\nThen loop through DP and for each [row][column] position calculate 4 possible case : \\n\\n1. Left Sum + Up Sum\\n2. Right Sum + Up Sum\\n3. Left Sum + Down Sum\\n4. Right Sum + Down Sum\\n\\nHere DP contains row wise left to right prefix sum and column wise up to down prefix sum.\\n```\n```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // track  number of 2 and 5 in numbers row wise and column wise => row 0 , column 1 => pair<2,5> count\\n        vector<vector<vector<pair<int,int>>>>dp(m,vector<vector<pair<int,int>>>(n,vector<pair<int,int>>(2,{0,0})));\\n        \\n        // loop through grid and store the prefix sum of 2 and 5 factor count row wise and column wise\\n        int twoC, fiveC,val;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                twoC = 0;\\n                fiveC = 0;\\n                val = grid[i][j];\\n                while(val%5 ==0)\\n                {\\n                    fiveC++;\\n                    val/=5;\\n                }\\n                while(val%2 ==0)\\n                {\\n                    twoC++;\\n                    val/=2;\\n                }\\n                \\n                // row wise prefix sum of factor 2 and 5\\n                if(j > 0)\\n                {\\n                    dp[i][j][0].first += dp[i][j-1][0].first + twoC;\\n                    dp[i][j][0].second += dp[i][j-1][0].second + fiveC;\\n                }\\n                else\\n                {\\n                    dp[i][j][0].first += twoC;\\n                    dp[i][j][0].second += fiveC;                    \\n                }\\n\\n                // column wise prefix sum of factor 2 and 5\\n                if(i > 0)\\n                {\\n                    dp[i][j][1].first += dp[i-1][j][1].first + twoC;\\n                    dp[i][j][1].second += dp[i-1][j][1].second + fiveC;\\n                }\\n                else\\n                {\\n                    dp[i][j][1].first += twoC;\\n                    dp[i][j][1].second += fiveC;                    \\n                }\\n            }\\n        }\\n        \\n        // max trailing zeroes\\n        int maxZero = 0;   \\n        \\n        // loop through dp and calculate max trailing zeroes for 4 possible cases\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                // left sum + up sum \\n                maxZero = max(maxZero,min(dp[i][j][1].first + (j>0 ? dp[i][j-1][0].first : 0), dp[i][j][1].second + (j>0 ? dp[i][j-1][0].second : 0)));\\n                \\n                // right sum + up sum\\n                maxZero = max(maxZero,min(dp[i][j][1].first + (dp[i][n-1][0].first - dp[i][j][0].first), dp[i][j][1].second + (dp[i][n-1][0].second - dp[i][j][0].second)));\\n                \\n                // left sum + down sum\\n                maxZero = max(maxZero,min((dp[m-1][j][1].first - dp[i][j][1].first) + dp[i][j][0].first, (dp[m-1][j][1].second - dp[i][j][1].second) + dp[i][j][0].second));\\n                \\n                // right sum + down sum\\n                maxZero = max(maxZero,min((dp[m-1][j][1].first - dp[i][j][1].first) + (dp[i][n-1][0].first - (j>0 ? dp[i][j-1][0].first : 0)), (dp[m-1][j][1].second - dp[i][j][1].second) + (dp[i][n-1][0].second - (j> 0 ? dp[i][j-1][0].second : 0))));\\n\\n            }\\n        }\\n        \\n        \\n        return maxZero;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958591,
                "title": "java-python3-clear-java-presum-code-beat-100",
                "content": "Convert grid to newGrid by counting the number of factor 2 and factor 5.\\nApply presum algorithm on newGrid with both horizontal and vertical direction.\\nCheck every possible cornered path (Time Complexity: O(m*n)).\\nReturn the max ans.\\n```\\npublic int maxTrailingZeros(int[][] grid) {\\n\\tint m = grid.length, n = grid[0].length;\\n\\t//newGrid[i][j][0] = the number of factor 2, newGrid[i][j][1] = the number of factor 5\\n\\tint[][][] newGrid = new int[m][n][2];\\n\\tfor(int i=0; i<m; i++){\\n\\t\\tfor(int j=0; j<n; j++){\\n\\t\\t\\tint count = 0;\\n\\t\\t\\twhile(grid[i][j] > 0 && grid[i][j] % 2 == 0){\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tgrid[i][j] /= 2;\\n\\t\\t\\t}\\n\\t\\t\\tnewGrid[i][j][0] = count;\\n\\t\\t\\tcount = 0;\\n\\t\\t\\twhile(grid[i][j] > 0 && grid[i][j] % 5 == 0){\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tgrid[i][j] /= 5;\\n\\t\\t\\t}\\n\\t\\t\\tnewGrid[i][j][1] = count;\\n\\t\\t}\\n\\t}\\n\\t//presum in horizontal direction\\n\\tint[][][] presumCol = new int[m][n+1][2];\\n\\t//presum in vertical direction\\n\\tint[][][] presumRow = new int[m+1][n][2];\\n\\tfor(int i=0; i<m; i++){\\n\\t\\tfor(int j=0; j<n; j++){\\n\\t\\t\\tpresumCol[i][j+1][0] = presumCol[i][j][0] + newGrid[i][j][0];\\n\\t\\t\\tpresumCol[i][j+1][1] = presumCol[i][j][1] + newGrid[i][j][1];\\n\\t\\t}\\n\\t}\\n\\tfor(int j=0; j<n; j++){\\n\\t\\tfor(int i=0; i<m; i++){\\n\\t\\t\\tpresumRow[i+1][j][0] = presumRow[i][j][0] + newGrid[i][j][0];\\n\\t\\t\\tpresumRow[i+1][j][1] = presumRow[i][j][1] + newGrid[i][j][1];\\n\\t\\t}\\n\\t}\\n\\tint ans = 0;\\n\\tfor(int i=0; i<m; i++){\\n\\t\\tfor(int j=0; j<n; j++){\\n\\t\\t\\t//left and up\\n\\t\\t\\tint t = Math.min(presumCol[i][j][0] + presumRow[i][j][0] + newGrid[i][j][0], presumCol[i][j][1] + presumRow[i][j][1] + newGrid[i][j][1]);\\n\\t\\t\\tans = Math.max(ans, t);\\n\\t\\t\\t//left and down\\n\\t\\t\\tt = Math.min(presumCol[i][j][0] + presumRow[m][j][0] - presumRow[i][j][0], presumCol[i][j][1] + presumRow[m][j][1] - presumRow[i][j][1]);\\n\\t\\t\\tans = Math.max(ans, t);\\n\\t\\t\\t//right and up\\n\\t\\t\\tt = Math.min(presumCol[i][n][0] - presumCol[i][j][0] + presumRow[i][j][0], presumCol[i][n][1] - presumCol[i][j][1] + presumRow[i][j][1]);\\n\\t\\t\\tans = Math.max(ans, t);\\n\\t\\t\\t//right and down\\n\\t\\t\\tt = Math.min(presumCol[i][n][0] - presumCol[i][j][0] + presumRow[m][j][0] - presumRow[i][j][0] - newGrid[i][j][0], presumCol[i][n][1] - presumCol[i][j][1] + presumRow[m][j][1] - presumRow[i][j][1] - newGrid[i][j][1]);\\n\\t\\t\\tans = Math.max(ans, t);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\n\\n**python 3** version:\\n```\\ndef maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\tnew_grid = [[[0,0] for _ in range(n)] for _ in range(m)]\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tcount = 0\\n\\t\\t\\twhile grid[i][j] > 0 and grid[i][j] % 2 == 0:\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tgrid[i][j] /= 2\\n\\t\\t\\tnew_grid[i][j][0] = count\\n\\t\\t\\tcount = 0\\n\\t\\t\\twhile grid[i][j] > 0 and grid[i][j] % 5 == 0:\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tgrid[i][j] /= 5\\n\\t\\t\\tnew_grid[i][j][1] = count\\n\\tpresum_col, presum_row = [[[0,0] for _ in range(n+1)] for _ in range(m)], [[[0,0] for _ in range(n)] for _ in range(m+1)]\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tpresum_col[i][j+1][0] = presum_col[i][j][0] + new_grid[i][j][0]\\n\\t\\t\\tpresum_col[i][j+1][1] = presum_col[i][j][1] + new_grid[i][j][1]\\n\\tfor j in range(n):\\n\\t\\tfor i in range(m):\\n\\t\\t\\tpresum_row[i+1][j][0] = presum_row[i][j][0] + new_grid[i][j][0]\\n\\t\\t\\tpresum_row[i+1][j][1] = presum_row[i][j][1] + new_grid[i][j][1]\\n\\tans = 0\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\t# left and up\\n\\t\\t\\tt1 = min(presum_col[i][j][0] + presum_row[i][j][0] + new_grid[i][j][0], presum_col[i][j][1] + presum_row[i][j][1] + new_grid[i][j][1])\\n\\t\\t\\t# left and down\\n\\t\\t\\tt2 = min(presum_col[i][j][0] + presum_row[m][j][0] - presum_row[i][j][0], presum_col[i][j][1] + presum_row[m][j][1] - presum_row[i][j][1])\\n\\t\\t\\t# right and up\\n\\t\\t\\tt3 = min(presum_col[i][n][0] - presum_col[i][j][0] + presum_row[i][j][0], presum_col[i][n][1] - presum_col[i][j][1] + presum_row[i][j][1])\\n\\t\\t\\t# right and down\\n\\t\\t\\tt4 = min(presum_col[i][n][0] - presum_col[i][j][0] + presum_row[m][j][0] - presum_row[i][j][0] - new_grid[i][j][0], presum_col[i][n][1] - presum_col[i][j][1] + presum_row[m][j][1] - presum_row[i][j][1] - new_grid[i][j][1])\\n\\t\\t\\tans = max(ans, t1, t2, t3, t4)\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxTrailingZeros(int[][] grid) {\\n\\tint m = grid.length, n = grid[0].length;\\n\\t//newGrid[i][j][0] = the number of factor 2, newGrid[i][j][1] = the number of factor 5\\n\\tint[][][] newGrid = new int[m][n][2];\\n\\tfor(int i=0; i<m; i++){\\n\\t\\tfor(int j=0; j<n; j++){\\n\\t\\t\\tint count = 0;\\n\\t\\t\\twhile(grid[i][j] > 0 && grid[i][j] % 2 == 0){\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tgrid[i][j] /= 2;\\n\\t\\t\\t}\\n\\t\\t\\tnewGrid[i][j][0] = count;\\n\\t\\t\\tcount = 0;\\n\\t\\t\\twhile(grid[i][j] > 0 && grid[i][j] % 5 == 0){\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tgrid[i][j] /= 5;\\n\\t\\t\\t}\\n\\t\\t\\tnewGrid[i][j][1] = count;\\n\\t\\t}\\n\\t}\\n\\t//presum in horizontal direction\\n\\tint[][][] presumCol = new int[m][n+1][2];\\n\\t//presum in vertical direction\\n\\tint[][][] presumRow = new int[m+1][n][2];\\n\\tfor(int i=0; i<m; i++){\\n\\t\\tfor(int j=0; j<n; j++){\\n\\t\\t\\tpresumCol[i][j+1][0] = presumCol[i][j][0] + newGrid[i][j][0];\\n\\t\\t\\tpresumCol[i][j+1][1] = presumCol[i][j][1] + newGrid[i][j][1];\\n\\t\\t}\\n\\t}\\n\\tfor(int j=0; j<n; j++){\\n\\t\\tfor(int i=0; i<m; i++){\\n\\t\\t\\tpresumRow[i+1][j][0] = presumRow[i][j][0] + newGrid[i][j][0];\\n\\t\\t\\tpresumRow[i+1][j][1] = presumRow[i][j][1] + newGrid[i][j][1];\\n\\t\\t}\\n\\t}\\n\\tint ans = 0;\\n\\tfor(int i=0; i<m; i++){\\n\\t\\tfor(int j=0; j<n; j++){\\n\\t\\t\\t//left and up\\n\\t\\t\\tint t = Math.min(presumCol[i][j][0] + presumRow[i][j][0] + newGrid[i][j][0], presumCol[i][j][1] + presumRow[i][j][1] + newGrid[i][j][1]);\\n\\t\\t\\tans = Math.max(ans, t);\\n\\t\\t\\t//left and down\\n\\t\\t\\tt = Math.min(presumCol[i][j][0] + presumRow[m][j][0] - presumRow[i][j][0], presumCol[i][j][1] + presumRow[m][j][1] - presumRow[i][j][1]);\\n\\t\\t\\tans = Math.max(ans, t);\\n\\t\\t\\t//right and up\\n\\t\\t\\tt = Math.min(presumCol[i][n][0] - presumCol[i][j][0] + presumRow[i][j][0], presumCol[i][n][1] - presumCol[i][j][1] + presumRow[i][j][1]);\\n\\t\\t\\tans = Math.max(ans, t);\\n\\t\\t\\t//right and down\\n\\t\\t\\tt = Math.min(presumCol[i][n][0] - presumCol[i][j][0] + presumRow[m][j][0] - presumRow[i][j][0] - newGrid[i][j][0], presumCol[i][n][1] - presumCol[i][j][1] + presumRow[m][j][1] - presumRow[i][j][1] - newGrid[i][j][1]);\\n\\t\\t\\tans = Math.max(ans, t);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\ndef maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\tnew_grid = [[[0,0] for _ in range(n)] for _ in range(m)]\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tcount = 0\\n\\t\\t\\twhile grid[i][j] > 0 and grid[i][j] % 2 == 0:\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tgrid[i][j] /= 2\\n\\t\\t\\tnew_grid[i][j][0] = count\\n\\t\\t\\tcount = 0\\n\\t\\t\\twhile grid[i][j] > 0 and grid[i][j] % 5 == 0:\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tgrid[i][j] /= 5\\n\\t\\t\\tnew_grid[i][j][1] = count\\n\\tpresum_col, presum_row = [[[0,0] for _ in range(n+1)] for _ in range(m)], [[[0,0] for _ in range(n)] for _ in range(m+1)]\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tpresum_col[i][j+1][0] = presum_col[i][j][0] + new_grid[i][j][0]\\n\\t\\t\\tpresum_col[i][j+1][1] = presum_col[i][j][1] + new_grid[i][j][1]\\n\\tfor j in range(n):\\n\\t\\tfor i in range(m):\\n\\t\\t\\tpresum_row[i+1][j][0] = presum_row[i][j][0] + new_grid[i][j][0]\\n\\t\\t\\tpresum_row[i+1][j][1] = presum_row[i][j][1] + new_grid[i][j][1]\\n\\tans = 0\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\t# left and up\\n\\t\\t\\tt1 = min(presum_col[i][j][0] + presum_row[i][j][0] + new_grid[i][j][0], presum_col[i][j][1] + presum_row[i][j][1] + new_grid[i][j][1])\\n\\t\\t\\t# left and down\\n\\t\\t\\tt2 = min(presum_col[i][j][0] + presum_row[m][j][0] - presum_row[i][j][0], presum_col[i][j][1] + presum_row[m][j][1] - presum_row[i][j][1])\\n\\t\\t\\t# right and up\\n\\t\\t\\tt3 = min(presum_col[i][n][0] - presum_col[i][j][0] + presum_row[i][j][0], presum_col[i][n][1] - presum_col[i][j][1] + presum_row[i][j][1])\\n\\t\\t\\t# right and down\\n\\t\\t\\tt4 = min(presum_col[i][n][0] - presum_col[i][j][0] + presum_row[m][j][0] - presum_row[i][j][0] - new_grid[i][j][0], presum_col[i][n][1] - presum_col[i][j][1] + presum_row[m][j][1] - presum_row[i][j][1] - new_grid[i][j][1])\\n\\t\\t\\tans = max(ans, t1, t2, t3, t4)\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1958502,
                "title": "java-prefix-sum-100-faster-clean-code",
                "content": "Similar to https://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/discuss/1955515/Prefix-Sum-of-Factors-2-and-5 but convert CPP features into java in a clear way.\\n\\n```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        // prefix matrix counting 2 and 5 \\n        int[][][] h = new int[m+1][n+1][2];\\n        int[][][] v = new int[m+1][n+1][2];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int two = 0;\\n                while (grid[i][j] % 2 == 0) {\\n                    grid[i][j] /= 2;\\n                    two++;\\n                }\\n                \\n                int five = 0;\\n                while (grid[i][j] % 5 == 0) {\\n                    grid[i][j] /= 5;\\n                    five++;\\n                }\\n                \\n                h[i][j+1][0] = h[i][j][0] + two;\\n                h[i][j+1][1] = h[i][j][1] + five;\\n                v[i+1][j][0] = v[i][j][0] + two;\\n                v[i+1][j][1] = v[i][j][1] + five;\\n                // System.out.printf(Arrays.toString(h[i][j+1]) + Arrays.toString(v[i+1][j]) + \" \");\\n            }\\n            // System.out.println();\\n        }\\n        \\n        // count trailing zeros\\n        int max = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int[] up = v[i+1][j]; // include [i,j]\\n                int[] down = new int[]{v[m][j][0] - v[i][j][0], v[m][j][1] - v[i][j][1]}; // include [i,j]\\n                int[] left = h[i][j]; // exclude [i,j]\\n                int[] right = new int[]{h[i][n][0] - h[i][j+1][0], h[i][n][1] - h[i][j+1][1]}; // exclude [i,j]\\n                \\n                List<Integer> candidates = Arrays.asList(Math.min(up[0] + left[0], up[1] + left[1]),\\n                                                         Math.min(up[0] + right[0], up[1] + right[1]),\\n                                                         Math.min(down[0] + left[0], down[1] + left[1]),\\n                                                         Math.min(down[0] + right[0], down[1] + right[1]));\\n                max = Math.max(max, Collections.max(candidates));\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        // prefix matrix counting 2 and 5 \\n        int[][][] h = new int[m+1][n+1][2];\\n        int[][][] v = new int[m+1][n+1][2];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int two = 0;\\n                while (grid[i][j] % 2 == 0) {\\n                    grid[i][j] /= 2;\\n                    two++;\\n                }\\n                \\n                int five = 0;\\n                while (grid[i][j] % 5 == 0) {\\n                    grid[i][j] /= 5;\\n                    five++;\\n                }\\n                \\n                h[i][j+1][0] = h[i][j][0] + two;\\n                h[i][j+1][1] = h[i][j][1] + five;\\n                v[i+1][j][0] = v[i][j][0] + two;\\n                v[i+1][j][1] = v[i][j][1] + five;\\n                // System.out.printf(Arrays.toString(h[i][j+1]) + Arrays.toString(v[i+1][j]) + \" \");\\n            }\\n            // System.out.println();\\n        }\\n        \\n        // count trailing zeros\\n        int max = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int[] up = v[i+1][j]; // include [i,j]\\n                int[] down = new int[]{v[m][j][0] - v[i][j][0], v[m][j][1] - v[i][j][1]}; // include [i,j]\\n                int[] left = h[i][j]; // exclude [i,j]\\n                int[] right = new int[]{h[i][n][0] - h[i][j+1][0], h[i][n][1] - h[i][j+1][1]}; // exclude [i,j]\\n                \\n                List<Integer> candidates = Arrays.asList(Math.min(up[0] + left[0], up[1] + left[1]),\\n                                                         Math.min(up[0] + right[0], up[1] + right[1]),\\n                                                         Math.min(down[0] + left[0], down[1] + left[1]),\\n                                                         Math.min(down[0] + right[0], down[1] + right[1]));\\n                max = Math.max(max, Collections.max(candidates));\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958476,
                "title": "c-faster-than-100-c-submission",
                "content": "```\\nclass Solution {\\npublic:\\n    pair<int,int> check(int num){\\n        int a=0,b=0;\\n        while(num%2 == 0){\\n            num = num/2;\\n            a++;\\n        }\\n        while(num%5 == 0){\\n            num = num/5;\\n            b++;\\n        }\\n        return {a,b};\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(),n = grid[0].size(),p1,p2;\\n        vector<vector<vector<int>>> v(m, vector<vector<int>>(n, vector<int>(4,0)));\\n        for(int j=0;j<n;j++){// top to down\\n            for(int i=0;i<m;i++){\\n                pair<int,int> p = check(grid[i][j]);\\n                if(i==0){\\n                    p1 = v[i][j][0] = p.first;\\n                    p2 = v[i][j][1] = p.second;\\n                }\\n                else{\\n                    p1 = v[i][j][0] = p1+p.first;\\n                    p2 = v[i][j][1] = p2+p.second;\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++){// left to right\\n            for(int j=0;j<n;j++){\\n                pair<int,int> p = check(grid[i][j]);\\n                if(j==0){\\n                    p1 = v[i][j][2] = p.first;\\n                    p2 = v[i][j][3] = p.second;\\n                }\\n                else{\\n                    p1 = v[i][j][2] = p1+p.first;\\n                    p2 = v[i][j][3] = p2+p.second;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int a,b;\\n                if(j-1>=0){\\n                    a = v[i][j][0] + v[i][j-1][2];\\n                    b = v[i][j][1] + v[i][j-1][3];\\n                    ans = max(ans,min(a,b));\\n                }\\n                if(j+1<n){\\n                    a = v[i][j][0] + (v[i][n-1][2] - v[i][j][2]);\\n                    b = v[i][j][1] + (v[i][n-1][3] - v[i][j][3]);\\n                    ans = max(ans,min(a,b));\\n                }\\n                ans = max(ans,min(v[i][j][0],v[i][j][1]));\\n                if(i-1 >= 0)\\n                    ans = max(ans,min(v[m-1][j][0]-v[i-1][j][0],v[m-1][j][1]-v[i-1][j][1]));\\n                else\\n                    ans = max(ans,min(v[m-1][j][0],v[m-1][j][1]));\\n                if(j-1>=0 && i-1>=0){\\n                    a = (v[m-1][j][0]-v[i-1][j][0]) + v[i][j-1][2];\\n                    b = (v[m-1][j][1]-v[i-1][j][1]) + v[i][j-1][3];\\n                    ans = max(ans,min(a,b));\\n                }\\n                else if(j-1>=0){\\n                    a = (v[m-1][j][0]) + v[i][j-1][2];\\n                    b = (v[m-1][j][1]) + v[i][j-1][3];\\n                    ans = max(ans,min(a,b));\\n                }\\n                if(j+1<n && i-1>=0){\\n                    a = (v[m-1][j][0]-v[i-1][j][0]) + (v[i][n-1][2] - v[i][j][2]);\\n                    b = (v[m-1][j][1]-v[i-1][j][1]) + (v[i][n-1][3] - v[i][j][3]);\\n                    ans = max(ans,min(a,b));\\n                }\\n                else if(j+1<n){\\n                    a = (v[m-1][j][0]) + (v[i][n-1][2] - v[i][j][2]);\\n                    b = (v[m-1][j][1]) + (v[i][n-1][3] - v[i][j][3]);\\n                    ans = max(ans,min(a,b));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int> check(int num){\\n        int a=0,b=0;\\n        while(num%2 == 0){\\n            num = num/2;\\n            a++;\\n        }\\n        while(num%5 == 0){\\n            num = num/5;\\n            b++;\\n        }\\n        return {a,b};\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(),n = grid[0].size(),p1,p2;\\n        vector<vector<vector<int>>> v(m, vector<vector<int>>(n, vector<int>(4,0)));\\n        for(int j=0;j<n;j++){// top to down\\n            for(int i=0;i<m;i++){\\n                pair<int,int> p = check(grid[i][j]);\\n                if(i==0){\\n                    p1 = v[i][j][0] = p.first;\\n                    p2 = v[i][j][1] = p.second;\\n                }\\n                else{\\n                    p1 = v[i][j][0] = p1+p.first;\\n                    p2 = v[i][j][1] = p2+p.second;\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++){// left to right\\n            for(int j=0;j<n;j++){\\n                pair<int,int> p = check(grid[i][j]);\\n                if(j==0){\\n                    p1 = v[i][j][2] = p.first;\\n                    p2 = v[i][j][3] = p.second;\\n                }\\n                else{\\n                    p1 = v[i][j][2] = p1+p.first;\\n                    p2 = v[i][j][3] = p2+p.second;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int a,b;\\n                if(j-1>=0){\\n                    a = v[i][j][0] + v[i][j-1][2];\\n                    b = v[i][j][1] + v[i][j-1][3];\\n                    ans = max(ans,min(a,b));\\n                }\\n                if(j+1<n){\\n                    a = v[i][j][0] + (v[i][n-1][2] - v[i][j][2]);\\n                    b = v[i][j][1] + (v[i][n-1][3] - v[i][j][3]);\\n                    ans = max(ans,min(a,b));\\n                }\\n                ans = max(ans,min(v[i][j][0],v[i][j][1]));\\n                if(i-1 >= 0)\\n                    ans = max(ans,min(v[m-1][j][0]-v[i-1][j][0],v[m-1][j][1]-v[i-1][j][1]));\\n                else\\n                    ans = max(ans,min(v[m-1][j][0],v[m-1][j][1]));\\n                if(j-1>=0 && i-1>=0){\\n                    a = (v[m-1][j][0]-v[i-1][j][0]) + v[i][j-1][2];\\n                    b = (v[m-1][j][1]-v[i-1][j][1]) + v[i][j-1][3];\\n                    ans = max(ans,min(a,b));\\n                }\\n                else if(j-1>=0){\\n                    a = (v[m-1][j][0]) + v[i][j-1][2];\\n                    b = (v[m-1][j][1]) + v[i][j-1][3];\\n                    ans = max(ans,min(a,b));\\n                }\\n                if(j+1<n && i-1>=0){\\n                    a = (v[m-1][j][0]-v[i-1][j][0]) + (v[i][n-1][2] - v[i][j][2]);\\n                    b = (v[m-1][j][1]-v[i-1][j][1]) + (v[i][n-1][3] - v[i][j][3]);\\n                    ans = max(ans,min(a,b));\\n                }\\n                else if(j+1<n){\\n                    a = (v[m-1][j][0]) + (v[i][n-1][2] - v[i][j][2]);\\n                    b = (v[m-1][j][1]) + (v[i][n-1][3] - v[i][j][3]);\\n                    ans = max(ans,min(a,b));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958456,
                "title": "java-easy-to-read-prefix-sum-100",
                "content": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int maxZeros = 0;\\n        int[][][] cnt = new int[grid.length][grid[0].length][2];//record how many 2,5 factors in the number\\n        int[][][] upcnt = new int[grid.length][grid[0].length][2];//record how many 2,5 factors above\\n        int[][][] downcnt = new int[grid.length][grid[0].length][2];//record how many 2,5 factors below\\n        int[][][] leftcnt = new int[grid.length][grid[0].length][2];//record how many 2,5 factors on the left\\n        int[][][] rightcnt = new int[grid.length][grid[0].length][2];//record how many 2,5 factors on the right\\n        for(int i=0;i<grid.length;i++){\\n            //2,5 factor number,left count aggregation\\n            for(int j=0;j<grid[0].length;j++){\\n                int n=grid[i][j];\\n                while(n%5==0){ //5 factor number\\n                        cnt[i][j][1]++;\\n                        n=n/5;\\n                }\\n                while(n%2==0){ //2 factor number\\n                        cnt[i][j][0]++;\\n                        n=n/2;\\n                } \\n                if(j>0){\\n                    leftcnt[i][j][1]=cnt[i][j-1][1]+leftcnt[i][j-1][1]; \\n                    leftcnt[i][j][0]=cnt[i][j-1][0]+leftcnt[i][j-1][0];\\n                }\\n            }\\n            //right count aggregation\\n            for(int j=grid[0].length-1;j>=0;j--){\\n                if(j<grid[0].length-1){\\n                    rightcnt[i][j][1]=cnt[i][j+1][1]+rightcnt[i][j+1][1]; \\n                    rightcnt[i][j][0]=cnt[i][j+1][0]+rightcnt[i][j+1][0];\\n                }\\n            }\\n        }\\n        for(int j=0;j<grid[0].length;j++){\\n            //up count aggregation\\n            for(int i=0;i<grid.length;i++){\\n                if(i>0){\\n                    upcnt[i][j][1]=cnt[i-1][j][1]+upcnt[i-1][j][1]; \\n                    upcnt[i][j][0]=cnt[i-1][j][0]+upcnt[i-1][j][0];\\n                }\\n            }\\n            //down count aggregation\\n            for(int i=grid.length-1;i>=0;i--){\\n                if(i<grid.length-1){\\n                    downcnt[i][j][1]=cnt[i+1][j][1]+downcnt[i+1][j][1]; \\n                    downcnt[i][j][0]=cnt[i+1][j][0]+downcnt[i+1][j][0];\\n                }\\n            }\\n        }        \\n        int upleft=0,upright=0,downleft=0,downright=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                //how many zeros are in the product in 4 different cases\\n                upleft = Math.min((upcnt[i][j][0]+leftcnt[i][j][0]+cnt[i][j][0]),(upcnt[i][j][1]+leftcnt[i][j][1]+cnt[i][j][1]));\\n                upright = Math.min((upcnt[i][j][0]+rightcnt[i][j][0]+cnt[i][j][0]),(upcnt[i][j][1]+rightcnt[i][j][1]+cnt[i][j][1]));\\n                downleft = Math.min((downcnt[i][j][0]+leftcnt[i][j][0]+cnt[i][j][0]),(downcnt[i][j][1]+leftcnt[i][j][1]+cnt[i][j][1]));\\n                downright = Math.min((downcnt[i][j][0]+rightcnt[i][j][0]+cnt[i][j][0]),(downcnt[i][j][1]+rightcnt[i][j][1]+cnt[i][j][1]));\\n                int zeros = Math.max(Math.max(upleft,upright),Math.max(downleft,downright));\\n                if(zeros>maxZeros) maxZeros = zeros;\\n            }\\n        }\\n        return maxZeros;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int maxZeros = 0;\\n        int[][][] cnt = new int[grid.length][grid[0].length][2];//record how many 2,5 factors in the number\\n        int[][][] upcnt = new int[grid.length][grid[0].length][2];//record how many 2,5 factors above\\n        int[][][] downcnt = new int[grid.length][grid[0].length][2];//record how many 2,5 factors below\\n        int[][][] leftcnt = new int[grid.length][grid[0].length][2];//record how many 2,5 factors on the left\\n        int[][][] rightcnt = new int[grid.length][grid[0].length][2];//record how many 2,5 factors on the right\\n        for(int i=0;i<grid.length;i++){\\n            //2,5 factor number,left count aggregation\\n            for(int j=0;j<grid[0].length;j++){\\n                int n=grid[i][j];\\n                while(n%5==0){ //5 factor number\\n                        cnt[i][j][1]++;\\n                        n=n/5;\\n                }\\n                while(n%2==0){ //2 factor number\\n                        cnt[i][j][0]++;\\n                        n=n/2;\\n                } \\n                if(j>0){\\n                    leftcnt[i][j][1]=cnt[i][j-1][1]+leftcnt[i][j-1][1]; \\n                    leftcnt[i][j][0]=cnt[i][j-1][0]+leftcnt[i][j-1][0];\\n                }\\n            }\\n            //right count aggregation\\n            for(int j=grid[0].length-1;j>=0;j--){\\n                if(j<grid[0].length-1){\\n                    rightcnt[i][j][1]=cnt[i][j+1][1]+rightcnt[i][j+1][1]; \\n                    rightcnt[i][j][0]=cnt[i][j+1][0]+rightcnt[i][j+1][0];\\n                }\\n            }\\n        }\\n        for(int j=0;j<grid[0].length;j++){\\n            //up count aggregation\\n            for(int i=0;i<grid.length;i++){\\n                if(i>0){\\n                    upcnt[i][j][1]=cnt[i-1][j][1]+upcnt[i-1][j][1]; \\n                    upcnt[i][j][0]=cnt[i-1][j][0]+upcnt[i-1][j][0];\\n                }\\n            }\\n            //down count aggregation\\n            for(int i=grid.length-1;i>=0;i--){\\n                if(i<grid.length-1){\\n                    downcnt[i][j][1]=cnt[i+1][j][1]+downcnt[i+1][j][1]; \\n                    downcnt[i][j][0]=cnt[i+1][j][0]+downcnt[i+1][j][0];\\n                }\\n            }\\n        }        \\n        int upleft=0,upright=0,downleft=0,downright=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                //how many zeros are in the product in 4 different cases\\n                upleft = Math.min((upcnt[i][j][0]+leftcnt[i][j][0]+cnt[i][j][0]),(upcnt[i][j][1]+leftcnt[i][j][1]+cnt[i][j][1]));\\n                upright = Math.min((upcnt[i][j][0]+rightcnt[i][j][0]+cnt[i][j][0]),(upcnt[i][j][1]+rightcnt[i][j][1]+cnt[i][j][1]));\\n                downleft = Math.min((downcnt[i][j][0]+leftcnt[i][j][0]+cnt[i][j][0]),(downcnt[i][j][1]+leftcnt[i][j][1]+cnt[i][j][1]));\\n                downright = Math.min((downcnt[i][j][0]+rightcnt[i][j][0]+cnt[i][j][0]),(downcnt[i][j][1]+rightcnt[i][j][1]+cnt[i][j][1]));\\n                int zeros = Math.max(Math.max(upleft,upright),Math.max(downleft,downright));\\n                if(zeros>maxZeros) maxZeros = zeros;\\n            }\\n        }\\n        return maxZeros;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958455,
                "title": "java-100-prefix-sum",
                "content": "Please upvote if you like the solution:\\n```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][][] gr = new int[m][n][3];\\n        int[][][] cg = new int[m][n][3];\\n        int[][][] rg = new int[m][n][3];\\n        for (int i=0;i<m;i++) {\\n            for (int j=0;j<n;j++) {\\n                while (grid[i][j]%10==0) {\\n                    grid[i][j] = grid[i][j]/10;\\n                    gr[i][j][0]++;\\n                }\\n                while (grid[i][j]%5==0) {\\n                    grid[i][j] = grid[i][j]/5;\\n                    gr[i][j][1]++;\\n                }\\n                gr[i][j][2] = Integer.numberOfTrailingZeros(grid[i][j]);\\n            }\\n        }\\n        for (int i=0;i<m;i++) {\\n            for (int j=0;j<n;j++) {\\n                if (i==0) {\\n                    cg[i][j][0] = gr[i][j][0];\\n                    cg[i][j][1] = gr[i][j][1];\\n                    cg[i][j][2] = gr[i][j][2];\\n                } else {\\n                    cg[i][j][0] = cg[i-1][j][0]+gr[i][j][0];\\n                    cg[i][j][1] = cg[i-1][j][1]+gr[i][j][1];\\n                    cg[i][j][2] = cg[i-1][j][2]+gr[i][j][2];                    \\n                }\\n                if (j==0) {\\n                    rg[i][j][0] = gr[i][j][0];\\n                    rg[i][j][1] = gr[i][j][1];\\n                    rg[i][j][2] = gr[i][j][2];\\n                } else {\\n                    rg[i][j][0] = rg[i][j-1][0]+gr[i][j][0];\\n                    rg[i][j][1] = rg[i][j-1][1]+gr[i][j][1];\\n                    rg[i][j][2] = rg[i][j-1][2]+gr[i][j][2];                    \\n                }\\n            }\\n        }\\n        int a = 0;\\n        for (int i=0;i<m;i++) {\\n            a = Math.max(a, rg[i][n-1][0]+Math.min(rg[i][n-1][1],rg[i][n-1][2]));\\n        }\\n        for (int j=0;j<n;j++) {\\n            a = Math.max(a, cg[m-1][j][0]+Math.min(cg[m-1][j][1],cg[m-1][j][2]));\\n        }\\n        for (int i=0;i<m;i++) {\\n            for (int j=0;j<n;j++) {\\n                int t1 = rg[i][j][0] + cg[i][j][0] - gr[i][j][0] +\\n                    Math.min(rg[i][j][1]+cg[i][j][1]-gr[i][j][1],\\n                            rg[i][j][2]+cg[i][j][2]-gr[i][j][2]);\\n                a = Math.max(a, t1);\\n\\n                int t2 = rg[i][n-1][0]-rg[i][j][0]+cg[m-1][j][0]-cg[i][j][0]+gr[i][j][0] +\\n                    Math.min(rg[i][n-1][1]-rg[i][j][1]+cg[m-1][j][1]-cg[i][j][1]+gr[i][j][1], \\n                             rg[i][n-1][2]-rg[i][j][2]+cg[m-1][j][2]-cg[i][j][2]+gr[i][j][2]);\\n                a = Math.max(a, t2);\\n\\n                int t3 = rg[i][n-1][0]-rg[i][j][0]+cg[i][j][0] +\\n                    Math.min(rg[i][n-1][1]-rg[i][j][1]+cg[i][j][1], \\n                             rg[i][n-1][2]-rg[i][j][2]+cg[i][j][2]);\\n                a = Math.max(a, t3);\\n                \\n                int t4 = cg[m-1][j][0]-cg[i][j][0]+rg[i][j][0]+\\n                    Math.min(cg[m-1][j][1]-cg[i][j][1]+rg[i][j][1], \\n                             cg[m-1][j][2]-cg[i][j][2]+rg[i][j][2]);\\n                a = Math.max(a, t4);\\n                \\n            }\\n        }\\n        return a;\\n    }\\n}",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][][] gr = new int[m][n][3];\\n        int[][][] cg = new int[m][n][3];\\n        int[][][] rg = new int[m][n][3];\\n        for (int i=0;i<m;i++) {\\n            for (int j=0;j<n;j++) {\\n                while (grid[i][j]%10==0) {\\n                    grid[i][j] = grid[i][j]/10;\\n                    gr[i][j][0]++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1958445,
                "title": "python-3-prefix-sum-of-facotrs-2-and-5-100-time-100-memory",
                "content": "![image](https://assets.leetcode.com/users/images/c0a777ef-91ba-42d3-a165-6aaa97534ea7_1650226772.4215481.png)\\n\\n1. Keep count of number of factors 2 and 5 for each element. \\n2. Run prefix sums for factor 2 horizontally and vertically, likewise for factor 5. \\n3. Take each grid[i][j] as the corner, there are be 4 candidate paths: left to corner to top, left to corner to bottom, right to corner to top, right to corner to bottom. Use the prefix sums and the count at [i][j] to find the maximum number of trailing zeros at [i][j].\\n\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        @cache \\n        def func(v, target):\\n            if v < target or v % target:\\n                return 0, v\\n            c, v = func(v // target, target)\\n            return c + 1, v\\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        cnt = [[[0] * 2 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                cnt[i][j][0], rem = func(grid[i][j], 2)\\n                cnt[i][j][1], _ = func(rem, 5)\\n        \\n        dp_h2 = [[0] * (n + 1) for _ in range(m + 1)]\\n        dp_v2 = [[0] * (n + 1) for _ in range(m + 1)]\\n        dp_h5 = [[0] * (n + 1) for _ in range(m + 1)]\\n        dp_v5 = [[0] * (n + 1) for _ in range(m + 1)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                dp_h2[i][j] = dp_h2[i][j - 1] + cnt[i][j][0]\\n                dp_h5[i][j] = dp_h5[i][j - 1] + cnt[i][j][1]\\n        for j in range(n):\\n            for i in range(m):\\n                dp_v2[i][j] = dp_v2[i - 1][j] + cnt[i][j][0]\\n                dp_v5[i][j] = dp_v5[i - 1][j] + cnt[i][j][1]\\n        \\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                n2 = cnt[i][j][0]\\n                n5 = cnt[i][j][1]\\n                lt = min(dp_h2[i][j - 1] + dp_v2[i - 1][j] + n2, \\n                         dp_h5[i][j - 1] + dp_v5[i - 1][j] + n5)\\n                rt = min(dp_h2[i][n - 1] - dp_h2[i][j] + dp_v2[i - 1][j] + n2, \\n                         dp_h5[i][n - 1] - dp_h5[i][j] + dp_v5[i - 1][j] + n5)\\n                lb = min(dp_h2[i][j - 1] + dp_v2[m - 1][j] - dp_v2[i][j] + n2, \\n                         dp_h5[i][j - 1] + dp_v5[m - 1][j] - dp_v5[i][j] + n5)\\n                rb = min(dp_h2[i][n - 1] - dp_h2[i][j] + dp_v2[m - 1][j] - dp_v2[i][j] + n2,\\n                         dp_h5[i][n - 1] - dp_h5[i][j] + dp_v5[m - 1][j] - dp_v5[i][j] + n5)\\n                ans = max(ans, max(lt, rt, lb, rb))\\n        return ans\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        @cache \\n        def func(v, target):\\n            if v < target or v % target:\\n                return 0, v\\n            c, v = func(v // target, target)\\n            return c + 1, v\\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        cnt = [[[0] * 2 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                cnt[i][j][0], rem = func(grid[i][j], 2)\\n                cnt[i][j][1], _ = func(rem, 5)\\n        \\n        dp_h2 = [[0] * (n + 1) for _ in range(m + 1)]\\n        dp_v2 = [[0] * (n + 1) for _ in range(m + 1)]\\n        dp_h5 = [[0] * (n + 1) for _ in range(m + 1)]\\n        dp_v5 = [[0] * (n + 1) for _ in range(m + 1)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                dp_h2[i][j] = dp_h2[i][j - 1] + cnt[i][j][0]\\n                dp_h5[i][j] = dp_h5[i][j - 1] + cnt[i][j][1]\\n        for j in range(n):\\n            for i in range(m):\\n                dp_v2[i][j] = dp_v2[i - 1][j] + cnt[i][j][0]\\n                dp_v5[i][j] = dp_v5[i - 1][j] + cnt[i][j][1]\\n        \\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                n2 = cnt[i][j][0]\\n                n5 = cnt[i][j][1]\\n                lt = min(dp_h2[i][j - 1] + dp_v2[i - 1][j] + n2, \\n                         dp_h5[i][j - 1] + dp_v5[i - 1][j] + n5)\\n                rt = min(dp_h2[i][n - 1] - dp_h2[i][j] + dp_v2[i - 1][j] + n2, \\n                         dp_h5[i][n - 1] - dp_h5[i][j] + dp_v5[i - 1][j] + n5)\\n                lb = min(dp_h2[i][j - 1] + dp_v2[m - 1][j] - dp_v2[i][j] + n2, \\n                         dp_h5[i][j - 1] + dp_v5[m - 1][j] - dp_v5[i][j] + n5)\\n                rb = min(dp_h2[i][n - 1] - dp_h2[i][j] + dp_v2[m - 1][j] - dp_v2[i][j] + n2,\\n                         dp_h5[i][n - 1] - dp_h5[i][j] + dp_v5[m - 1][j] - dp_v5[i][j] + n5)\\n                ans = max(ans, max(lt, rt, lb, rb))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958310,
                "title": "prefix-solution-need-improvement-for-ending-0-counts-by-mod-2-5",
                "content": "This\\'s what I got in the contest, didn\\'t satisfy the time limitation. We could optimize it by using mod 2 & 5 to reduce time complexity. Good learning experience tho.\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        r, c = len(grid), len(grid[0])\\n        v = [[1 for _ in range(c)] for _ in range(r)]\\n        h = [[1 for _ in range(c)] for _ in range(r)]\\n        \\n        def count_0(n):\\n            res = 0\\n            for ch in str(n)[::-1]:\\n                if ch != \\'0\\':\\n                    break\\n                else:\\n                    res += 1\\n            return res\\n        \\n        for i in range(r):\\n            cur = 1\\n            for j in range(c):\\n                cur *= grid[i][j]\\n                v[i][j] = cur\\n        for j in range(c):\\n            cur = 1\\n            for i in range(r):\\n                cur *= grid[i][j]\\n                h[i][j] = cur\\n        res = 0\\n        for i in range(r):\\n            for j in range(c):\\n                dr = h[i][j] * (v[i][c-1] // v[i][j]) # count cross number in h\\n                dl = (h[i][j] * v[i][j-1]) if (j > 0) else h[i][j] # count cross number in h\\n                ur = (h[r-1][j] // h[i][j]) * (v[i][c-1] // v[i][j]) * grid[i][j] # count cross number deperately\\n                ul = (h[r-1][j] // h[i][j]) * v[i][j] # count cross number in v\\n                res = max(res, count_0(dr), count_0(dl), count_0(ur), count_0(ul))\\n        return res\\n```\\ncompared with answer posted by https://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/discuss/1955502/Python-Prefix-Sum-O(m-*-n):\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        ans = 0\\n        m, n = len(grid), len(grid[0])\\n        prefixH = [[[0] * 2 for _ in range(n + 1)] for __ in range(m)]\\n        prefixV = [[[0] * 2 for _ in range(n)] for __ in range(m + 1)]\\n        for i in range(m):\\n            for j in range(n):\\n                temp= grid[i][j]\\n                while temp % 2 == 0:\\n                    prefixH[i][j + 1][0] += 1\\n                    prefixV[i + 1][j][0] += 1\\n                    temp //= 2\\n                while temp % 5 == 0:\\n                    prefixH[i][j + 1][1] += 1\\n                    prefixV[i + 1][j][1] += 1\\n                    temp //= 5\\n                for k in range(2):\\n                    prefixH[i][j + 1][k] += prefixH[i][j][k]\\n                    prefixV[i + 1][j][k] += prefixV[i][j][k]\\n        for i in range(m):\\n            for j in range(n):\\n                left = prefixH[i][j]\\n                up = prefixV[i][j]\\n                right, down, center = [0] * 2, [0] * 2, [0] * 2\\n                for k in range(2):\\n                    right[k] = prefixH[i][n][k] - prefixH[i][j + 1][k]\\n                    down[k] = prefixV[m][j][k] - prefixV[i + 1][j][k]\\n                    center[k] = prefixH[i][j + 1][k] - prefixH[i][j][k]\\n                LU, LD, RU, RD = [0] * 2, [0] * 2, [0] * 2, [0] * 2\\n                for k in range(2):\\n                    LU[k] += left[k] + up[k] + center[k]\\n                    LD[k] += left[k] + down[k] + center[k]\\n                    RU[k] += right[k] + up[k] + center[k]\\n                    RD[k] += right[k] + down[k] + center[k]\\n                ans = max(ans,\\n                          min(LU[0], LU[1]),\\n                          min(LD[0], LD[1]),\\n                          min(RU[0], RU[1]),\\n                          min(RD[0], RD[1]))\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        r, c = len(grid), len(grid[0])\\n        v = [[1 for _ in range(c)] for _ in range(r)]\\n        h = [[1 for _ in range(c)] for _ in range(r)]\\n        \\n        def count_0(n):\\n            res = 0\\n            for ch in str(n)[::-1]:\\n                if ch != \\'0\\':\\n                    break\\n                else:\\n                    res += 1\\n            return res\\n        \\n        for i in range(r):\\n            cur = 1\\n            for j in range(c):\\n                cur *= grid[i][j]\\n                v[i][j] = cur\\n        for j in range(c):\\n            cur = 1\\n            for i in range(r):\\n                cur *= grid[i][j]\\n                h[i][j] = cur\\n        res = 0\\n        for i in range(r):\\n            for j in range(c):\\n                dr = h[i][j] * (v[i][c-1] // v[i][j]) # count cross number in h\\n                dl = (h[i][j] * v[i][j-1]) if (j > 0) else h[i][j] # count cross number in h\\n                ur = (h[r-1][j] // h[i][j]) * (v[i][c-1] // v[i][j]) * grid[i][j] # count cross number deperately\\n                ul = (h[r-1][j] // h[i][j]) * v[i][j] # count cross number in v\\n                res = max(res, count_0(dr), count_0(dl), count_0(ur), count_0(ul))\\n        return res\\n```\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        ans = 0\\n        m, n = len(grid), len(grid[0])\\n        prefixH = [[[0] * 2 for _ in range(n + 1)] for __ in range(m)]\\n        prefixV = [[[0] * 2 for _ in range(n)] for __ in range(m + 1)]\\n        for i in range(m):\\n            for j in range(n):\\n                temp= grid[i][j]\\n                while temp % 2 == 0:\\n                    prefixH[i][j + 1][0] += 1\\n                    prefixV[i + 1][j][0] += 1\\n                    temp //= 2\\n                while temp % 5 == 0:\\n                    prefixH[i][j + 1][1] += 1\\n                    prefixV[i + 1][j][1] += 1\\n                    temp //= 5\\n                for k in range(2):\\n                    prefixH[i][j + 1][k] += prefixH[i][j][k]\\n                    prefixV[i + 1][j][k] += prefixV[i][j][k]\\n        for i in range(m):\\n            for j in range(n):\\n                left = prefixH[i][j]\\n                up = prefixV[i][j]\\n                right, down, center = [0] * 2, [0] * 2, [0] * 2\\n                for k in range(2):\\n                    right[k] = prefixH[i][n][k] - prefixH[i][j + 1][k]\\n                    down[k] = prefixV[m][j][k] - prefixV[i + 1][j][k]\\n                    center[k] = prefixH[i][j + 1][k] - prefixH[i][j][k]\\n                LU, LD, RU, RD = [0] * 2, [0] * 2, [0] * 2, [0] * 2\\n                for k in range(2):\\n                    LU[k] += left[k] + up[k] + center[k]\\n                    LD[k] += left[k] + down[k] + center[k]\\n                    RU[k] += right[k] + up[k] + center[k]\\n                    RD[k] += right[k] + down[k] + center[k]\\n                ans = max(ans,\\n                          min(LU[0], LU[1]),\\n                          min(LD[0], LD[1]),\\n                          min(RU[0], RU[1]),\\n                          min(RD[0], RD[1]))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958055,
                "title": "python-intuitive-method",
                "content": "A very intuitive method. Once figuring out the logistics, coding should not be too difficult (but a bit lengthy).\\n\\nPre-calc 2s and 5s for all numbers in 0-1000. The number of trailings zeros should be min(2s,5s). \\n\\nCalculate the maximum trailing 0s for each row/column and update the res (no turn).\\nFor each cell, count all the 2s and 5s in 4 directions (top, down, left, right). Calculate the total 0s with 4 combinations (top+left, top+right, down+left, down+right) and update the res (one turn).\\n\\n\\n```\\ndef maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        dic5 = [0]*1001\\n        dic2 = [0]*1001\\n        for i in range(1001):\\n            for j in range(11):\\n                if i%(2**j)!=0:\\n                    break\\n                else:\\n                    dic2[i] = j\\n            for j in range(6):\\n                if i%(5**j)!=0:\\n                    break\\n                else:\\n                    dic5[i] = j\\n        \\n        \\n        n,m = len(grid),len(grid[0])\\n        \\n        vertical = [[[0,0] for i in range(m)] for j in range(n)]\\n        horizon = [[[0,0] for i in range(m)] for j in range(n)]\\n        \\n        for i in range(n):\\n            for j in range(m):\\n                vertical[i][j] = [dic2[grid[i][j]],dic5[grid[i][j]]]\\n                horizon[i][j] = [dic2[grid[i][j]],dic5[grid[i][j]]]\\n                if i>0:\\n                    vertical[i][j][0] += vertical[i-1][j][0]\\n                    vertical[i][j][1] += vertical[i-1][j][1]\\n                if j>0:\\n                    horizon[i][j][0]+=horizon[i][j-1][0]\\n                    horizon[i][j][1] += horizon[i][j-1][1]\\n        \\n        res = 0\\n        for i in range(n):\\n            tmp = min(horizon[i][m-1][0],horizon[i][m-1][1]) # row\\n            res = max(tmp,res)\\n        for i in range(m):\\n            tmp = min(vertical[n-1][i][0],vertical[n-1][i][1]) #column\\n            res = max(tmp,res)\\n            \\n        for i in range(n):\\n            for j in range(m):\\n                tmp = min(horizon[i][j][0]+vertical[i][j][0]-dic2[grid[i][j]],horizon[i][j][1]+vertical[i][j][1]-dic5[grid[i][j]]) # left, top \\n                res = max(tmp,res)\\n                tmp = min(horizon[i][m-1][0]-horizon[i][j][0]+vertical[i][j][0],horizon[i][m-1][1]-horizon[i][j][1]+vertical[i][j][1]) #right, top\\n                res = max(tmp,res)\\n                tmp = min(horizon[i][j][0]+vertical[n-1][j][0]-vertical[i][j][0],horizon[i][j][1]+vertical[n-1][j][1]-vertical[i][j][1]) #left, down\\n                res = max(tmp,res)\\n                tmp = min(horizon[i][m-1][0]-horizon[i][j][0]+vertical[n-1][j][0]-vertical[i][j][0]+dic2[grid[i][j]],horizon[i][m-1][1]-horizon[i][j][1]+vertical[n-1][j][1]-vertical[i][j][1]+dic5[grid[i][j]]) # right, down\\n                res = max(tmp,res)\\n        return res\\n                              \\n```",
                "solutionTags": [],
                "code": "```\\ndef maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        dic5 = [0]*1001\\n        dic2 = [0]*1001\\n        for i in range(1001):\\n            for j in range(11):\\n                if i%(2**j)!=0:\\n                    break\\n                else:\\n                    dic2[i] = j\\n            for j in range(6):\\n                if i%(5**j)!=0:\\n                    break\\n                else:\\n                    dic5[i] = j\\n        \\n        \\n        n,m = len(grid),len(grid[0])\\n        \\n        vertical = [[[0,0] for i in range(m)] for j in range(n)]\\n        horizon = [[[0,0] for i in range(m)] for j in range(n)]\\n        \\n        for i in range(n):\\n            for j in range(m):\\n                vertical[i][j] = [dic2[grid[i][j]],dic5[grid[i][j]]]\\n                horizon[i][j] = [dic2[grid[i][j]],dic5[grid[i][j]]]\\n                if i>0:\\n                    vertical[i][j][0] += vertical[i-1][j][0]\\n                    vertical[i][j][1] += vertical[i-1][j][1]\\n                if j>0:\\n                    horizon[i][j][0]+=horizon[i][j-1][0]\\n                    horizon[i][j][1] += horizon[i][j-1][1]\\n        \\n        res = 0\\n        for i in range(n):\\n            tmp = min(horizon[i][m-1][0],horizon[i][m-1][1]) # row\\n            res = max(tmp,res)\\n        for i in range(m):\\n            tmp = min(vertical[n-1][i][0],vertical[n-1][i][1]) #column\\n            res = max(tmp,res)\\n            \\n        for i in range(n):\\n            for j in range(m):\\n                tmp = min(horizon[i][j][0]+vertical[i][j][0]-dic2[grid[i][j]],horizon[i][j][1]+vertical[i][j][1]-dic5[grid[i][j]]) # left, top \\n                res = max(tmp,res)\\n                tmp = min(horizon[i][m-1][0]-horizon[i][j][0]+vertical[i][j][0],horizon[i][m-1][1]-horizon[i][j][1]+vertical[i][j][1]) #right, top\\n                res = max(tmp,res)\\n                tmp = min(horizon[i][j][0]+vertical[n-1][j][0]-vertical[i][j][0],horizon[i][j][1]+vertical[n-1][j][1]-vertical[i][j][1]) #left, down\\n                res = max(tmp,res)\\n                tmp = min(horizon[i][m-1][0]-horizon[i][j][0]+vertical[n-1][j][0]-vertical[i][j][0]+dic2[grid[i][j]],horizon[i][m-1][1]-horizon[i][j][1]+vertical[n-1][j][1]-vertical[i][j][1]+dic5[grid[i][j]]) # right, down\\n                res = max(tmp,res)\\n        return res\\n                              \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1957926,
                "title": "c-pure-greedy-implementation-beats-100",
                "content": "## Pure greedy implementation\\n```\\ntypedef pair<int,int> pii;\\n\\npii operator+(const pii &a, const pii &b) {\\n    return {a.first + b.first, a.second + b.second};\\n}\\n\\npii operator-(const pii &a, const pii &b) {\\n    return {a.first - b.first, a.second - b.second};\\n}\\n\\nclass Solution {\\npublic:\\n    friend pii operator+(const pii &a, const pii &b);\\n    friend pii operator-(const pii &a, const pii &b);\\n    \\n    pii cnt(int n) {\\n        int x = 0, y = 0;\\n        while (n % (int)pow(2, x) == 0) x++;\\n        while (n % (int)pow(5, y) == 0) y++;\\n        return {x-1, y-1};\\n    }\\n     \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<pii>> hor(n + 1, vector<pii>(m + 1));\\n        vector<vector<pii>> ver = hor;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                pii count = cnt(grid[i][j]);\\n                hor[i + 1][j + 1] = hor[i + 1][j] + count;\\n                ver[i + 1][j + 1] = ver[i][j + 1] + count;\\n            }\\n        }\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                pii u = ver[i + 1][j + 1];\\n                pii d = ver[n][j + 1] - ver[i][j + 1];\\n                pii l = hor[i + 1][j];\\n                pii r = hor[i + 1][m] - hor[i + 1][j + 1];\\n                int w = min(u.first + l.first, u.second + l.second);\\n                int x = min(u.first + r.first, u.second + r.second);\\n                int y = min(d.first + l.first, d.second + l.second);\\n                int z = min(d.first + r.first, d.second + r.second);\\n                res = max({res, w, x, y, z});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nU can reduce functions and make code ugly!\\n\\n**Time Complexity:** O(n * m)\\n**Space Complexity:** O(n * m)",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\ntypedef pair<int,int> pii;\\n\\npii operator+(const pii &a, const pii &b) {\\n    return {a.first + b.first, a.second + b.second};\\n}\\n\\npii operator-(const pii &a, const pii &b) {\\n    return {a.first - b.first, a.second - b.second};\\n}\\n\\nclass Solution {\\npublic:\\n    friend pii operator+(const pii &a, const pii &b);\\n    friend pii operator-(const pii &a, const pii &b);\\n    \\n    pii cnt(int n) {\\n        int x = 0, y = 0;\\n        while (n % (int)pow(2, x) == 0) x++;\\n        while (n % (int)pow(5, y) == 0) y++;\\n        return {x-1, y-1};\\n    }\\n     \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<pii>> hor(n + 1, vector<pii>(m + 1));\\n        vector<vector<pii>> ver = hor;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                pii count = cnt(grid[i][j]);\\n                hor[i + 1][j + 1] = hor[i + 1][j] + count;\\n                ver[i + 1][j + 1] = ver[i][j + 1] + count;\\n            }\\n        }\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                pii u = ver[i + 1][j + 1];\\n                pii d = ver[n][j + 1] - ver[i][j + 1];\\n                pii l = hor[i + 1][j];\\n                pii r = hor[i + 1][m] - hor[i + 1][j + 1];\\n                int w = min(u.first + l.first, u.second + l.second);\\n                int x = min(u.first + r.first, u.second + r.second);\\n                int y = min(d.first + l.first, d.second + l.second);\\n                int z = min(d.first + r.first, d.second + r.second);\\n                res = max({res, w, x, y, z});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957814,
                "title": "python",
                "content": "todo explain\\n\\n```python\\nclass Solution:\\n     def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n              v1\\n          h1  x   h2\\n              v2\\n        [h2, h5, v2, v5]\\n        \"\"\"\\n\\n        def d2(x: int):\\n            return 0 if x % 2 > 0 else 1 + d2(x//2)\\n\\n        def d5(x: int):\\n            return 0 if x % 5 > 0 else 1 + d5(x // 5)\\n\\n        m, n = len(grid), len(grid[0])\\n        stat = [[[0, 0, 0, 0] for _ in range(n + 2)] for _ in range(m + 2)]\\n        for i in range(m):\\n            for j in range(n):\\n                x = grid[i][j]\\n                x2, x5 = d2(x), d5(x)\\n                h2, h5, v2, v5 = stat[i + 1][j][0], stat[i + 1][j][1], stat[i][j + 1][2], stat[i][j + 1][3]\\n                stat[i + 1][j + 1] = [h2 + x2, h5 + x5, v2 + x2, v5 + x5]\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                h1, h2, v1, v2 = stat[i + 1][j+1][:2], [stat[i + 1][n][0] - stat[i + 1][j][0],\\n                                                      stat[i + 1][n][1] - stat[i + 1][j][1]], \\\\\\n                                 stat[i][j + 1][2:], [stat[m][j + 1][2] - stat[i + 1][j + 1][2],\\n                                                      stat[m][j + 1][3] - stat[i + 1][j + 1][3]]\\n                cand = 0\\n                for (h2, h5), (v2, v5) in product([h1, h2], [v1, v2]):\\n                    max_min = min(h2 + v2, h5 + v5)\\n                    cand = max(cand, max_min)\\n                res = max(res, cand)\\n        return res   \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n     def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n              v1\\n          h1  x   h2\\n              v2\\n        [h2, h5, v2, v5]\\n        \"\"\"\\n\\n        def d2(x: int):\\n            return 0 if x % 2 > 0 else 1 + d2(x//2)\\n\\n        def d5(x: int):\\n            return 0 if x % 5 > 0 else 1 + d5(x // 5)\\n\\n        m, n = len(grid), len(grid[0])\\n        stat = [[[0, 0, 0, 0] for _ in range(n + 2)] for _ in range(m + 2)]\\n        for i in range(m):\\n            for j in range(n):\\n                x = grid[i][j]\\n                x2, x5 = d2(x), d5(x)\\n                h2, h5, v2, v5 = stat[i + 1][j][0], stat[i + 1][j][1], stat[i][j + 1][2], stat[i][j + 1][3]\\n                stat[i + 1][j + 1] = [h2 + x2, h5 + x5, v2 + x2, v5 + x5]\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                h1, h2, v1, v2 = stat[i + 1][j+1][:2], [stat[i + 1][n][0] - stat[i + 1][j][0],\\n                                                      stat[i + 1][n][1] - stat[i + 1][j][1]], \\\\\\n                                 stat[i][j + 1][2:], [stat[m][j + 1][2] - stat[i + 1][j + 1][2],\\n                                                      stat[m][j + 1][3] - stat[i + 1][j + 1][3]]\\n                cand = 0\\n                for (h2, h5), (v2, v5) in product([h1, h2], [v1, v2]):\\n                    max_min = min(h2 + v2, h5 + v5)\\n                    cand = max(cand, max_min)\\n                res = max(res, cand)\\n        return res   \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957715,
                "title": "python-solution-not-the-simplest-but-works-within-time-limit",
                "content": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        #####################################################\\n        # first, compute the highest powers of 2 and 5 for each element\\n        #####################################################\\n        pow25 = [[(0, 0) for i in range(n)] for j in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                k = 0\\n                while grid[i][j] % pow(2,k) == 0:\\n                    k += 1\\n                \\n                l = 0\\n                while grid[i][j] % pow(5,l) == 0:\\n                    l += 1\\n                pow25[i][j] = (k-1, l-1)\\n\\n\\n        #####################################################\\n        # next, compute the sums of pow25 for cell i, j, from up, down, left, right\\n        # up2 - sum of all powers of 2 from top to current cell i,j\\n        # left2 - sum of all powers of 2 from left to current cell i,j\\n        # down2 - sum of all powers of 2 from bottom to current cell i,j\\n        # right2 - sum of all powers of 2 from right to current cell i,j\\n        # up5 - sum of all powers of 5 from top to current cell i,j\\n        # left5 - sum of all powers of 5 from left to current cell i,j\\n        # down5 - sum of all powers of 5 from bottom to current cell i,j\\n        # right5 - sum of all powers of 5 from right to current cell i,\\n        #####################################################\\n        up2 = [[0 for i in range(n)] for j in range(m)]\\n        up5 = [[0 for i in range(n)] for j in range(m)]\\n        down2 = [[0 for i in range(n)] for j in range(m)]\\n        down5 = [[0 for i in range(n)] for j in range(m)]\\n        left2 = [[0 for i in range(n)] for j in range(m)]\\n        left5 = [[0 for i in range(n)] for j in range(m)]\\n        right2 = [[0 for i in range(n)] for j in range(m)]\\n        right5 = [[0 for i in range(n)] for j in range(m)]\\n\\n        for j in range(n):\\n            for i in range(m):\\n                if i == 0:\\n                    up2[i][j] = pow25[i][j][0]\\n                    up5[i][j] = pow25[i][j][1]\\n                else:\\n                    up2[i][j] = up2[i-1][j] + pow25[i][j][0]\\n                    up5[i][j] = up5[i-1][j] + pow25[i][j][1]\\n\\n        for j in range(n):\\n            for i in reversed(range(m)):\\n                if i == m-1:\\n                    down2[i][j] = pow25[i][j][0]\\n                    down5[i][j] = pow25[i][j][1]\\n                else:\\n                    down2[i][j] = down2[i+1][j] + pow25[i][j][0]\\n                    down5[i][j] = down5[i+1][j] + pow25[i][j][1]\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if j == 0:\\n                    left2[i][j] = pow25[i][j][0]\\n                    left5[i][j] = pow25[i][j][1]\\n                else:\\n                    left2[i][j] = left2[i][j-1] + pow25[i][j][0]\\n                    left5[i][j] = left5[i][j-1] + pow25[i][j][1]\\n                \\n        for i in range(m):\\n            for j in reversed(range(n)):\\n                if j == n-1:\\n                    right2[i][j] = pow25[i][j][0]\\n                    right5[i][j] = pow25[i][j][1]\\n                else:\\n                    right2[i][j] = right2[i][j+1] + pow25[i][j][0]\\n                    right5[i][j] = right5[i][j+1] + pow25[i][j][1]\\n\\n        #####################################################\\n        # to avoid double counting when adding up+left, up+right, down+left, down+right\\n        # we remove cell i,j from left2, left5, right2, right5\\n        #####################################################\\n        for i in range(m):\\n            for j in range(n):\\n                left2[i][j] -= pow25[i][j][0]                \\n                left5[i][j] -= pow25[i][j][1]\\n                right2[i][j] -= pow25[i][j][0]                \\n                right5[i][j] -= pow25[i][j][1]\\n\\n\\n        #####################################################\\n        # Finally compute max trailing zeroes\\n        #####################################################\\n        max_trailing_zeroes = 0\\n        for i in range(m):\\n            for j in range(n):\\n                score = max(\\n                    min(up2[i][j] + left2[i][j], up5[i][j] + left5[i][j]),\\n                    min(up2[i][j] + right2[i][j], up5[i][j] + right5[i][j]),\\n                    min(down2[i][j] + left2[i][j], down5[i][j] + left5[i][j]),\\n                    min(down2[i][j] + right2[i][j], down5[i][j] + right5[i][j])\\n                )\\n                if score > max_trailing_zeroes:\\n                    max_trailing_zeroes = score\\n                    \\n        return max_trailing_zeroes\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        #####################################################\\n        # first, compute the highest powers of 2 and 5 for each element\\n        #####################################################\\n        pow25 = [[(0, 0) for i in range(n)] for j in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                k = 0\\n                while grid[i][j] % pow(2,k) == 0:\\n                    k += 1\\n                \\n                l = 0\\n                while grid[i][j] % pow(5,l) == 0:\\n                    l += 1\\n                pow25[i][j] = (k-1, l-1)\\n\\n\\n        #####################################################\\n        # next, compute the sums of pow25 for cell i, j, from up, down, left, right\\n        # up2 - sum of all powers of 2 from top to current cell i,j\\n        # left2 - sum of all powers of 2 from left to current cell i,j\\n        # down2 - sum of all powers of 2 from bottom to current cell i,j\\n        # right2 - sum of all powers of 2 from right to current cell i,j\\n        # up5 - sum of all powers of 5 from top to current cell i,j\\n        # left5 - sum of all powers of 5 from left to current cell i,j\\n        # down5 - sum of all powers of 5 from bottom to current cell i,j\\n        # right5 - sum of all powers of 5 from right to current cell i,\\n        #####################################################\\n        up2 = [[0 for i in range(n)] for j in range(m)]\\n        up5 = [[0 for i in range(n)] for j in range(m)]\\n        down2 = [[0 for i in range(n)] for j in range(m)]\\n        down5 = [[0 for i in range(n)] for j in range(m)]\\n        left2 = [[0 for i in range(n)] for j in range(m)]\\n        left5 = [[0 for i in range(n)] for j in range(m)]\\n        right2 = [[0 for i in range(n)] for j in range(m)]\\n        right5 = [[0 for i in range(n)] for j in range(m)]\\n\\n        for j in range(n):\\n            for i in range(m):\\n                if i == 0:\\n                    up2[i][j] = pow25[i][j][0]\\n                    up5[i][j] = pow25[i][j][1]\\n                else:\\n                    up2[i][j] = up2[i-1][j] + pow25[i][j][0]\\n                    up5[i][j] = up5[i-1][j] + pow25[i][j][1]\\n\\n        for j in range(n):\\n            for i in reversed(range(m)):\\n                if i == m-1:\\n                    down2[i][j] = pow25[i][j][0]\\n                    down5[i][j] = pow25[i][j][1]\\n                else:\\n                    down2[i][j] = down2[i+1][j] + pow25[i][j][0]\\n                    down5[i][j] = down5[i+1][j] + pow25[i][j][1]\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if j == 0:\\n                    left2[i][j] = pow25[i][j][0]\\n                    left5[i][j] = pow25[i][j][1]\\n                else:\\n                    left2[i][j] = left2[i][j-1] + pow25[i][j][0]\\n                    left5[i][j] = left5[i][j-1] + pow25[i][j][1]\\n                \\n        for i in range(m):\\n            for j in reversed(range(n)):\\n                if j == n-1:\\n                    right2[i][j] = pow25[i][j][0]\\n                    right5[i][j] = pow25[i][j][1]\\n                else:\\n                    right2[i][j] = right2[i][j+1] + pow25[i][j][0]\\n                    right5[i][j] = right5[i][j+1] + pow25[i][j][1]\\n\\n        #####################################################\\n        # to avoid double counting when adding up+left, up+right, down+left, down+right\\n        # we remove cell i,j from left2, left5, right2, right5\\n        #####################################################\\n        for i in range(m):\\n            for j in range(n):\\n                left2[i][j] -= pow25[i][j][0]                \\n                left5[i][j] -= pow25[i][j][1]\\n                right2[i][j] -= pow25[i][j][0]                \\n                right5[i][j] -= pow25[i][j][1]\\n\\n\\n        #####################################################\\n        # Finally compute max trailing zeroes\\n        #####################################################\\n        max_trailing_zeroes = 0\\n        for i in range(m):\\n            for j in range(n):\\n                score = max(\\n                    min(up2[i][j] + left2[i][j], up5[i][j] + left5[i][j]),\\n                    min(up2[i][j] + right2[i][j], up5[i][j] + right5[i][j]),\\n                    min(down2[i][j] + left2[i][j], down5[i][j] + left5[i][j]),\\n                    min(down2[i][j] + right2[i][j], down5[i][j] + right5[i][j])\\n                )\\n                if score > max_trailing_zeroes:\\n                    max_trailing_zeroes = score\\n                    \\n        return max_trailing_zeroes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957524,
                "title": "java-100-tc-100-sc",
                "content": "Not a good problem, didn\\'t see any algorithem trick. Hoping just because I didn\\'t find it. \\n\\n```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int res = 0;\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][][] scoreMatrix = new int[n][m][3];\\n        \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                scoreMatrix[i][j] = getScore(grid[i][j]);\\n            }\\n        }\\n        \\n        int[][] rowInfo = new int[n][3];\\n        int[][] columnInfo = new int[m][3];\\n        for(int i=0; i<n;i++){\\n            for(int j=0;j<m;j++){\\n                rowInfo[i][0]+=scoreMatrix[i][j][0];\\n                columnInfo[j][0]+=scoreMatrix[i][j][0];\\n                rowInfo[i][1]+=scoreMatrix[i][j][1];\\n                columnInfo[j][1]+=scoreMatrix[i][j][1];\\n                rowInfo[i][2]+=scoreMatrix[i][j][2];\\n                columnInfo[j][2]+=scoreMatrix[i][j][2];\\n            }\\n        }\\n        \\n        int[][] curRowInfo = new int[n][3];\\n        int[][] curColumnInfo = new int[m][3];\\n        for(int i=0; i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int p1 = Math.max(\\n                    getPathScore(curRowInfo[i], curColumnInfo[j], scoreMatrix[i][j]),\\n                    getPathScore(curRowInfo[i], getRest(curColumnInfo[j], columnInfo[j], scoreMatrix[i][j]),scoreMatrix[i][j])\\n                );\\n                \\n                int p2 = Math.max(\\n                    getPathScore(getRest(curRowInfo[i], rowInfo[i], scoreMatrix[i][j]), curColumnInfo[j],scoreMatrix[i][j]),\\n                    getPathScore(getRest(curRowInfo[i], rowInfo[i], scoreMatrix[i][j]), getRest(curColumnInfo[j], columnInfo[j], scoreMatrix[i][j]),scoreMatrix[i][j])\\n                );\\n                \\n                int curRes = Math.max(p1,p2);\\n                res = Math.max(res, curRes);\\n                \\n                curRowInfo[i][0]+=scoreMatrix[i][j][0];\\n                curColumnInfo[j][0]+=scoreMatrix[i][j][0];\\n                curRowInfo[i][1]+=scoreMatrix[i][j][1];\\n                curColumnInfo[j][1]+=scoreMatrix[i][j][1];\\n                curRowInfo[i][2]+=scoreMatrix[i][j][2];\\n                curColumnInfo[j][2]+=scoreMatrix[i][j][2];\\n            }\\n        }\\n        return res;\\n        \\n    }\\n    \\n    private int[] getRest(int[] cur, int[] total, int[] value){\\n        int[] res = new int[]{  total[0]-cur[0]-value[0], \\n                              total[1]-cur[1]-value[1], \\n                              total[2]-cur[2]-value[2]    };\\n        return res;\\n    }\\n    \\n    private int getPathScore(int[] path1, int[] path2, int[] cur){\\n        int res = path1[0] + path2[0] + cur[0];\\n        res+= Math.min(path1[1]+path2[1]+cur[1], path1[2]+path2[2]+cur[2]);\\n        return res;\\n    }\\n    \\n    private int[] getScore(int num){\\n        int[] res = new int[3];\\n        while(num%10==0 && num!=0){\\n            num = num/10;\\n            res[0]++;\\n        }\\n        while(num%5==0 && num!=0){\\n            num = num/5;\\n            res[2]++;\\n        }\\n        while(num%2==0 && num!=0){\\n            num = num/2;\\n            res[1]++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int res = 0;\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][][] scoreMatrix = new int[n][m][3];\\n        \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                scoreMatrix[i][j] = getScore(grid[i][j]);\\n            }\\n        }\\n        \\n        int[][] rowInfo = new int[n][3];\\n        int[][] columnInfo = new int[m][3];\\n        for(int i=0; i<n;i++){\\n            for(int j=0;j<m;j++){\\n                rowInfo[i][0]+=scoreMatrix[i][j][0];\\n                columnInfo[j][0]+=scoreMatrix[i][j][0];\\n                rowInfo[i][1]+=scoreMatrix[i][j][1];\\n                columnInfo[j][1]+=scoreMatrix[i][j][1];\\n                rowInfo[i][2]+=scoreMatrix[i][j][2];\\n                columnInfo[j][2]+=scoreMatrix[i][j][2];\\n            }\\n        }\\n        \\n        int[][] curRowInfo = new int[n][3];\\n        int[][] curColumnInfo = new int[m][3];\\n        for(int i=0; i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int p1 = Math.max(\\n                    getPathScore(curRowInfo[i], curColumnInfo[j], scoreMatrix[i][j]),\\n                    getPathScore(curRowInfo[i], getRest(curColumnInfo[j], columnInfo[j], scoreMatrix[i][j]),scoreMatrix[i][j])\\n                );\\n                \\n                int p2 = Math.max(\\n                    getPathScore(getRest(curRowInfo[i], rowInfo[i], scoreMatrix[i][j]), curColumnInfo[j],scoreMatrix[i][j]),\\n                    getPathScore(getRest(curRowInfo[i], rowInfo[i], scoreMatrix[i][j]), getRest(curColumnInfo[j], columnInfo[j], scoreMatrix[i][j]),scoreMatrix[i][j])\\n                );\\n                \\n                int curRes = Math.max(p1,p2);\\n                res = Math.max(res, curRes);\\n                \\n                curRowInfo[i][0]+=scoreMatrix[i][j][0];\\n                curColumnInfo[j][0]+=scoreMatrix[i][j][0];\\n                curRowInfo[i][1]+=scoreMatrix[i][j][1];\\n                curColumnInfo[j][1]+=scoreMatrix[i][j][1];\\n                curRowInfo[i][2]+=scoreMatrix[i][j][2];\\n                curColumnInfo[j][2]+=scoreMatrix[i][j][2];\\n            }\\n        }\\n        return res;\\n        \\n    }\\n    \\n    private int[] getRest(int[] cur, int[] total, int[] value){\\n        int[] res = new int[]{  total[0]-cur[0]-value[0], \\n                              total[1]-cur[1]-value[1], \\n                              total[2]-cur[2]-value[2]    };\\n        return res;\\n    }\\n    \\n    private int getPathScore(int[] path1, int[] path2, int[] cur){\\n        int res = path1[0] + path2[0] + cur[0];\\n        res+= Math.min(path1[1]+path2[1]+cur[1], path1[2]+path2[2]+cur[2]);\\n        return res;\\n    }\\n    \\n    private int[] getScore(int num){\\n        int[] res = new int[3];\\n        while(num%10==0 && num!=0){\\n            num = num/10;\\n            res[0]++;\\n        }\\n        while(num%5==0 && num!=0){\\n            num = num/5;\\n            res[2]++;\\n        }\\n        while(num%2==0 && num!=0){\\n            num = num/2;\\n            res[1]++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957421,
                "title": "golang-prefix-sum",
                "content": "```\\nfunc maxTrailingZeros(grid [][]int) int {\\n    m, n := len(grid), len(grid[0])\\n\\tres := 0\\n\\thp := make([][][]int, m)\\n\\tvp := make([][][]int, m)\\n\\tfor i := range hp {\\n\\t\\thp[i] = make([][]int, n)\\n\\t\\tvp[i] = make([][]int, n)\\n\\t\\tfor j := range hp[i] {\\n\\t\\t\\thp[i][j] = make([]int, 2)\\n\\t\\t\\tvp[i][j] = make([]int, 2)\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif j == 0 {\\n\\t\\t\\t\\thp[i][j][0] = factors(grid[i][j], 2)\\n\\t\\t\\t\\thp[i][j][1] = factors(grid[i][j], 5)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thp[i][j][0] = hp[i][j-1][0] + factors(grid[i][j], 2)\\n\\t\\t\\t\\thp[i][j][1] = hp[i][j-1][1] + factors(grid[i][j], 5)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif i == 0 {\\n\\t\\t\\t\\tvp[i][j][0] = factors(grid[i][j], 2)\\n\\t\\t\\t\\tvp[i][j][1] = factors(grid[i][j], 5)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvp[i][j][0] = vp[i-1][j][0] + factors(grid[i][j], 2)\\n\\t\\t\\t\\tvp[i][j][1] = vp[i-1][j][1] + factors(grid[i][j], 5)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tres = max(res, min(hp[i][j][0]+vp[i][j][0]-factors(grid[i][j], 2), hp[i][j][1]+vp[i][j][1]-factors(grid[i][j], 5)))\\n\\t\\t\\tres = max(res, min(hp[i][n-1][0]-hp[i][j][0]+vp[i][j][0], hp[i][n-1][1]-hp[i][j][1]+vp[i][j][1]))\\n\\t\\t\\tres = max(res, min(vp[m-1][j][0]-vp[i][j][0]+hp[i][j][0], vp[m-1][j][1]-vp[i][j][1]+hp[i][j][1]))\\n\\t\\t\\tres = max(res, min(hp[i][n-1][0]-hp[i][j][0]+vp[m-1][j][0]-vp[i][j][0]+factors(grid[i][j], 2), hp[i][n-1][1]-hp[i][j][1]+vp[m-1][j][1]-vp[i][j][1]+factors(grid[i][j], 5)))\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\nfunc factors(num, f int) int {\\n\\tif num%f == 0 {\\n\\t\\treturn factors(num/f, f) + 1\\n\\t}\\n\\treturn 0\\n}\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\nfunc min (a, b int) int {\\n    if a < b {\\n         return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nfunc maxTrailingZeros(grid [][]int) int {\\n    m, n := len(grid), len(grid[0])\\n\\tres := 0\\n\\thp := make([][][]int, m)\\n\\tvp := make([][][]int, m)\\n\\tfor i := range hp {\\n\\t\\thp[i] = make([][]int, n)\\n\\t\\tvp[i] = make([][]int, n)\\n\\t\\tfor j := range hp[i] {\\n\\t\\t\\thp[i][j] = make([]int, 2)\\n\\t\\t\\tvp[i][j] = make([]int, 2)\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif j == 0 {\\n\\t\\t\\t\\thp[i][j][0] = factors(grid[i][j], 2)\\n\\t\\t\\t\\thp[i][j][1] = factors(grid[i][j], 5)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thp[i][j][0] = hp[i][j-1][0] + factors(grid[i][j], 2)\\n\\t\\t\\t\\thp[i][j][1] = hp[i][j-1][1] + factors(grid[i][j], 5)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif i == 0 {\\n\\t\\t\\t\\tvp[i][j][0] = factors(grid[i][j], 2)\\n\\t\\t\\t\\tvp[i][j][1] = factors(grid[i][j], 5)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvp[i][j][0] = vp[i-1][j][0] + factors(grid[i][j], 2)\\n\\t\\t\\t\\tvp[i][j][1] = vp[i-1][j][1] + factors(grid[i][j], 5)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tres = max(res, min(hp[i][j][0]+vp[i][j][0]-factors(grid[i][j], 2), hp[i][j][1]+vp[i][j][1]-factors(grid[i][j], 5)))\\n\\t\\t\\tres = max(res, min(hp[i][n-1][0]-hp[i][j][0]+vp[i][j][0], hp[i][n-1][1]-hp[i][j][1]+vp[i][j][1]))\\n\\t\\t\\tres = max(res, min(vp[m-1][j][0]-vp[i][j][0]+hp[i][j][0], vp[m-1][j][1]-vp[i][j][1]+hp[i][j][1]))\\n\\t\\t\\tres = max(res, min(hp[i][n-1][0]-hp[i][j][0]+vp[m-1][j][0]-vp[i][j][0]+factors(grid[i][j], 2), hp[i][n-1][1]-hp[i][j][1]+vp[m-1][j][1]-vp[i][j][1]+factors(grid[i][j], 5)))\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\nfunc factors(num, f int) int {\\n\\tif num%f == 0 {\\n\\t\\treturn factors(num/f, f) + 1\\n\\t}\\n\\treturn 0\\n}\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\nfunc min (a, b int) int {\\n    if a < b {\\n         return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1957375,
                "title": "c-solution-factors-of-2-and-5",
                "content": "\\t  int maxTrailingZeros(vector<vector<int>>& arr) {\\n         \\n        int n = arr.size(), m = arr[0].size(), ans = INT_MIN;\\n        \\n        vector<vector<pair<int, int>> > pref(n, vector<pair<int, int>> (m)), suf(n, vector<pair<int, int>> (m));\\n        \\n        for(int i = 0; i < n; i++) {  // prefix\\n            for(int j = 0; j < m; j++) {\\n                int x = arr[i][j], two = 0, five = 0;\\n                \\n                while(x % 2 == 0) {\\n                    two++;\\n                    x /= 2;\\n                }\\n                \\n                while(x % 5 == 0) {\\n                    five++;\\n                    x /= 5;\\n                }\\n                \\n                pref[i][j].first = two;\\n                pref[i][j].second = five;\\n                \\n                if(j > 0) {\\n                    pref[i][j].first += pref[i][j - 1].first;\\n                    pref[i][j].second += pref[i][j - 1].second;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++) {  // suffix\\n            for(int j = m - 1; j >= 0; j--) {\\n                int x = arr[i][j], two = 0, five = 0;;\\n                \\n                while(x % 2 == 0) {\\n                    two++;\\n                    x /= 2;\\n                }\\n                \\n                while(x % 5 == 0) {\\n                    five++;\\n                    x /= 5;\\n                }\\n                \\n                suf[i][j].first = two;\\n                suf[i][j].second = five;\\n                \\n                if(j < m - 1) {\\n                    suf[i][j].first += suf[i][j + 1].first;\\n                    suf[i][j].second += suf[i][j + 1].second;\\n                }\\n            }\\n        }\\n        \\n        \\n        //      |    |\\n        //      |    |\\n        //      |    |\\n        //  ____|    |______  \\n        //\\n        \\n        for(int col = 0; col < m; col++) {  \\n            \\n            int two = 0, five = 0;\\n            for(int row = 0; row < n; row++) {\\n                \\n                ans = max(ans, min(pref[row][col].first + two, pref[row][col].second + five));\\n                ans = max(ans, min(suf[row][col].first + two, suf[row][col].second + five));\\n                \\n                int x = arr[row][col];\\n                while(x % 2 == 0) {\\n                    two++;\\n                    x /= 2;\\n                }\\n                \\n                while(x % 5 == 0) {\\n                    five++;\\n                    x /= 5;\\n                }\\n            }\\n        }\\n        \\n        // _____      ______\\n        //      |    |\\n        //      |    |\\n        //      |    |  \\n        //\\n        \\n        for(int col = 0; col < m; col++) {\\n            \\n            int two = 0, five = 0;\\n            for(int row = n - 1; row >= 0; row--) {\\n                \\n                ans = max(ans, min(pref[row][col].first + two, pref[row][col].second + five));\\n                ans = max(ans, min(suf[row][col].first + two, suf[row][col].second + five));\\n                \\n                int x = arr[row][col];\\n                while(x % 2 == 0) {\\n                    two++;\\n                    x /= 2;\\n                }\\n                \\n                while(x % 5 == 0) {\\n                    five++;\\n                    x /= 5;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\t  int maxTrailingZeros(vector<vector<int>>& arr) {\\n         \\n        int n = arr.size(), m = arr[0].size(), ans = INT_MIN;\\n        \\n        vector<vector<pair<int, int>> > pref(n, vector<pair<int, int>> (m)), suf(n, vector<pair<int, int>> (m));\\n        \\n        for(int i = 0; i < n; i++) {  // prefix\\n            for(int j = 0; j < m; j++) {\\n                int x = arr[i][j], two = 0, five = 0;\\n                \\n                while(x % 2 == 0) {\\n                    two++;\\n                    x /= 2;\\n                }\\n                \\n                while(x % 5 == 0) {\\n                    five++;\\n                    x /= 5;\\n                }\\n                \\n                pref[i][j].first = two;\\n                pref[i][j].second = five;\\n                \\n                if(j > 0) {\\n                    pref[i][j].first += pref[i][j - 1].first;\\n                    pref[i][j].second += pref[i][j - 1].second;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++) {  // suffix\\n            for(int j = m - 1; j >= 0; j--) {\\n                int x = arr[i][j], two = 0, five = 0;;\\n                \\n                while(x % 2 == 0) {\\n                    two++;\\n                    x /= 2;\\n                }\\n                \\n                while(x % 5 == 0) {\\n                    five++;\\n                    x /= 5;\\n                }\\n                \\n                suf[i][j].first = two;\\n                suf[i][j].second = five;\\n                \\n                if(j < m - 1) {\\n                    suf[i][j].first += suf[i][j + 1].first;\\n                    suf[i][j].second += suf[i][j + 1].second;\\n                }\\n            }\\n        }\\n        \\n        \\n        //      |    |\\n        //      |    |\\n        //      |    |\\n        //  ____|    |______  \\n        //\\n        \\n        for(int col = 0; col < m; col++) {  \\n            \\n            int two = 0, five = 0;\\n            for(int row = 0; row < n; row++) {\\n                \\n                ans = max(ans, min(pref[row][col].first + two, pref[row][col].second + five));\\n                ans = max(ans, min(suf[row][col].first + two, suf[row][col].second + five));\\n                \\n                int x = arr[row][col];\\n                while(x % 2 == 0) {\\n                    two++;\\n                    x /= 2;\\n                }\\n                \\n                while(x % 5 == 0) {\\n                    five++;\\n                    x /= 5;\\n                }\\n            }\\n        }\\n        \\n        // _____      ______\\n        //      |    |\\n        //      |    |\\n        //      |    |  \\n        //\\n        \\n        for(int col = 0; col < m; col++) {\\n            \\n            int two = 0, five = 0;\\n            for(int row = n - 1; row >= 0; row--) {\\n                \\n                ans = max(ans, min(pref[row][col].first + two, pref[row][col].second + five));\\n                ans = max(ans, min(suf[row][col].first + two, suf[row][col].second + five));\\n                \\n                int x = arr[row][col];\\n                while(x % 2 == 0) {\\n                    two++;\\n                    x /= 2;\\n                }\\n                \\n                while(x % 5 == 0) {\\n                    five++;\\n                    x /= 5;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1957257,
                "title": "prefix-sum-of-matrix",
                "content": "credit to https://leetcode.com/votrubac\\n\\nhttps://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/discuss/1955515/Prefix-Sum-of-Factors-2-and-5\\n```\\npair<int,int> operator+(const pair<int,int>&p1, const pair<int,int>&p2) { return { p1.first + p2.first, p1.second + p2.second };}\\npair<int,int> operator-(const pair<int,int>&p1, const pair<int,int>&p2) { return { p1.first - p2.first, p1.second - p2.second };}\\n\\nint primeFactors(int num, int prime) {\\n    return num % prime ? 0 : 1 + primeFactors(num / prime, prime);\\n}\\n\\nint pairs(pair<int,int>p) {\\n    return min(p.first, p.second);\\n}\\n\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n        int rows = grid.size(), cols = grid[0].size();\\n        \\n        //for the calculating the prefix add a col extra horizontally and a row vertically\\n        vector<vector<pair<int,int>>> horizontal(rows, vector<pair<int,int>>(cols+1)), vertical(rows+1, vector<pair<int,int>>(cols));\\n        \\n        for(int i = 0; i < rows; i ++) {\\n            for(int j = 0; j < cols; j ++) {\\n                //calculate the prime factors count\\n                pair<int,int> f25 = { primeFactors(grid[i][j], 2), primeFactors(grid[i][j], 5)};\\n                //add it horizontally for prefix sum\\n                horizontal[i][j+1] = horizontal[i][j] + f25;\\n                //do the same vertically\\n                vertical[i+1][j] = vertical[i][j] + f25;\\n            }\\n        }\\n        int res=0;\\n        for(int i = 0; i < rows; i ++) {\\n            for(int j = 0; j < cols; j ++) {\\n                // atmost one turn so, we can have 0/1 turn hence\\n                pair<int,int> v1 = vertical[i][j], v2 = vertical[rows][j] - vertical[i+1][j],\\n                // vertical has not included the turn point\\n                              h1 = horizontal[i][j+1], h2 = horizontal[i][cols] - horizontal[i][j];\\n                // where horizontal has included;\\n                // there are four possible ways of turnings, and we get the max out of them;\\n                res = max({res, pairs(v1+h1), pairs(v1+h2), pairs(v2+h1), pairs(v2+h2)});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npair<int,int> operator+(const pair<int,int>&p1, const pair<int,int>&p2) { return { p1.first + p2.first, p1.second + p2.second };}\\npair<int,int> operator-(const pair<int,int>&p1, const pair<int,int>&p2) { return { p1.first - p2.first, p1.second - p2.second };}\\n\\nint primeFactors(int num, int prime) {\\n    return num % prime ? 0 : 1 + primeFactors(num / prime, prime);\\n}\\n\\nint pairs(pair<int,int>p) {\\n    return min(p.first, p.second);\\n}\\n\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n        int rows = grid.size(), cols = grid[0].size();\\n        \\n        //for the calculating the prefix add a col extra horizontally and a row vertically\\n        vector<vector<pair<int,int>>> horizontal(rows, vector<pair<int,int>>(cols+1)), vertical(rows+1, vector<pair<int,int>>(cols));\\n        \\n        for(int i = 0; i < rows; i ++) {\\n            for(int j = 0; j < cols; j ++) {\\n                //calculate the prime factors count\\n                pair<int,int> f25 = { primeFactors(grid[i][j], 2), primeFactors(grid[i][j], 5)};\\n                //add it horizontally for prefix sum\\n                horizontal[i][j+1] = horizontal[i][j] + f25;\\n                //do the same vertically\\n                vertical[i+1][j] = vertical[i][j] + f25;\\n            }\\n        }\\n        int res=0;\\n        for(int i = 0; i < rows; i ++) {\\n            for(int j = 0; j < cols; j ++) {\\n                // atmost one turn so, we can have 0/1 turn hence\\n                pair<int,int> v1 = vertical[i][j], v2 = vertical[rows][j] - vertical[i+1][j],\\n                // vertical has not included the turn point\\n                              h1 = horizontal[i][j+1], h2 = horizontal[i][cols] - horizontal[i][j];\\n                // where horizontal has included;\\n                // there are four possible ways of turnings, and we get the max out of them;\\n                res = max({res, pairs(v1+h1), pairs(v1+h2), pairs(v2+h1), pairs(v2+h2)});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957221,
                "title": "python3-prefix-sum-easy-to-understand",
                "content": "```\\nfrom copy import deepcopy\\n\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        Number of zeros, we can easily find using number of 2, 5\\n        So in prefix sum way, for all 4 directions we need to find the number of 2,5\\n        up, down, left, right\\n        \\n        Now as we find the result, we can find 4 types. \\n        up-right, up-left, down-right, down-left. \\n        We need to subtract the curr-idx we iterating, as thats added 2 times. \\n        Finally number of zeros is only min count of 2,5. That also needed to be accounted. \\n        \"\"\" \\n        @lru_cache(None)\\n        def factors(x):\\n            res = [0,0]\\n            while x%2==0:\\n                res[0]+=1\\n                x//=2\\n            while x%5==0:\\n                res[1]+=1\\n                x//=5\\n            return res\\n        \\n        def sum_factors(x, y):\\n            return [x[0]+y[0], x[1]+y[1]]\\n        \\n        def diff_and_min(x, y):\\n            return min(x[0]-y[0], x[1]-y[1])\\n        \\n        m, n = len(grid), len(grid[0])\\n        zeros = [[None for _ in range(n)] for _ in range(m)]\\n        up, down, left, right =  deepcopy(zeros), deepcopy(zeros), deepcopy(zeros),deepcopy(zeros)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                up[i][j] = factors(grid[i][j]) if i == 0 else sum_factors(up[i-1][j], factors(grid[i][j]))\\n                left[i][j] = factors(grid[i][j]) if j == 0 else sum_factors(left[i][j-1], factors(grid[i][j]))\\n                \\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                down[i][j] = factors(grid[i][j]) if i==m-1 else sum_factors(down[i+1][j], factors(grid[i][j]))\\n                right[i][j] = factors(grid[i][j]) if j==n-1 else sum_factors(right[i][j+1], factors(grid[i][j]))\\n                \\n        \\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                res = max(\\n                    res,\\n                    diff_and_min(sum_factors(up[i][j], right[i][j]), factors(grid[i][j])),\\n                    diff_and_min(sum_factors(up[i][j], left[i][j]), factors(grid[i][j])),\\n                    diff_and_min(sum_factors(down[i][j], right[i][j]), factors(grid[i][j])),\\n                    diff_and_min(sum_factors(down[i][j], left[i][j]), factors(grid[i][j]))\\n                )\\n                \\n        return res\\n```\\t\\t",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nfrom copy import deepcopy\\n\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        Number of zeros, we can easily find using number of 2, 5\\n        So in prefix sum way, for all 4 directions we need to find the number of 2,5\\n        up, down, left, right\\n        \\n        Now as we find the result, we can find 4 types. \\n        up-right, up-left, down-right, down-left. \\n        We need to subtract the curr-idx we iterating, as thats added 2 times. \\n        Finally number of zeros is only min count of 2,5. That also needed to be accounted. \\n        \"\"\" \\n        @lru_cache(None)\\n        def factors(x):\\n            res = [0,0]\\n            while x%2==0:\\n                res[0]+=1\\n                x//=2\\n            while x%5==0:\\n                res[1]+=1\\n                x//=5\\n            return res\\n        \\n        def sum_factors(x, y):\\n            return [x[0]+y[0], x[1]+y[1]]\\n        \\n        def diff_and_min(x, y):\\n            return min(x[0]-y[0], x[1]-y[1])\\n        \\n        m, n = len(grid), len(grid[0])\\n        zeros = [[None for _ in range(n)] for _ in range(m)]\\n        up, down, left, right =  deepcopy(zeros), deepcopy(zeros), deepcopy(zeros),deepcopy(zeros)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                up[i][j] = factors(grid[i][j]) if i == 0 else sum_factors(up[i-1][j], factors(grid[i][j]))\\n                left[i][j] = factors(grid[i][j]) if j == 0 else sum_factors(left[i][j-1], factors(grid[i][j]))\\n                \\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                down[i][j] = factors(grid[i][j]) if i==m-1 else sum_factors(down[i+1][j], factors(grid[i][j]))\\n                right[i][j] = factors(grid[i][j]) if j==n-1 else sum_factors(right[i][j+1], factors(grid[i][j]))\\n                \\n        \\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                res = max(\\n                    res,\\n                    diff_and_min(sum_factors(up[i][j], right[i][j]), factors(grid[i][j])),\\n                    diff_and_min(sum_factors(up[i][j], left[i][j]), factors(grid[i][j])),\\n                    diff_and_min(sum_factors(down[i][j], right[i][j]), factors(grid[i][j])),\\n                    diff_and_min(sum_factors(down[i][j], left[i][j]), factors(grid[i][j]))\\n                )\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957124,
                "title": "java-prefix-and-suffix-sum-of-factors-of-2-and-5",
                "content": "The solution is inspired by this post: https://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/discuss/1955515/Prefix-Sum-of-Factors-2-and-5 \\n\\nSharing commented code for the same for Java.\\n\\n```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int r = grid.length, c= grid[0].length;\\n\\t\\t// the arrays below are used to store the total number of 2 and 5 till any point in grid on horizontal and vertical axis.\\n        int h[][][] = new int[r][c+1][2];\\n        int v[][][] = new int[r+1][c][2];\\n        \\n        v[0][0]=new int[]{0,0};\\n        h[0][0]=new int[]{0,0};\\n        for(int i=0; i<r; i++){\\n            for(int j=0; j<c; j++){\\n                var count2N5 = getCount25(grid[i][j]);\\n                v[i+1][j] = new int[]{v[i][j][0]+count2N5[0] , v[i][j][1]+count2N5[1]};\\n                h[i][j+1] = new int[]{h[i][j][0]+count2N5[0], h[i][j][1]+count2N5[1]};\\n            }\\n        }\\n        \\n        \\n        // now for each point in the grid, try to figure out all the 4 possibilities.\\n        \\n        // v1 -> top to bottom vertical till point i,j\\n        // v2 -> bottom to top till point i,j\\n        // h1 -> left to right till point i,j-1  (j will be covered by vertical path,  in code we will be picking up for j because h[i][j] represents total till j-1)\\n        // h2 -> right to left till point i,j+1  (j will be covered by vertical path so if we consider right to left, we need to consider till j+1 only)\\n        \\n        // try (v1,h1)  ( v1,h2)    (v2,h1)   (v2,h2)  as points of intersection\\n        var result =0;\\n        \\n        for(int i=0; i<r; i++){\\n            for(int j=0; j<c; j++){\\n                var v1 = v[i+1][j];\\n                var h1 = h[i][j]; // not j+1 because we have already picked jth element in vertical paths\\n                var v2 = new int[]{ v[r][j][0] - v[i][j][0], v[r][j][1] - v[i][j][1]};\\n                var h2 = new int[]{ h[i][c][0] - h[i][j+1][0], h[i][c][1]- h[i][j+1][1]}; // j+1 because we started from right and we have already picked jth element in vertical path\\n                \\n                // try all 4 combinations at this point\\n                result=Math.max(result, Math.min(v1[0]+h1[0], v1[1]+h1[1]));\\n                result=Math.max(result, Math.min(v1[0]+h2[0], v1[1]+h2[1]));\\n                result=Math.max(result, Math.min(v2[0]+h1[0], v2[1]+h1[1]));\\n                result=Math.max(result, Math.min(v2[0]+h2[0], v2[1]+h2[1]));\\n\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n    \\n    \\n    private int[] getCount25(int val){\\n        int count2=0, count5=0;\\n        while(val%2==0 && val!=0){\\n            val/=2;\\n            count2++;\\n        }\\n        while(val%5==0 && val!=0){\\n            val/=5;\\n            count5++;\\n        }\\n        return new int[]{count2, count5};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int r = grid.length, c= grid[0].length;\\n\\t\\t// the arrays below are used to store the total number of 2 and 5 till any point in grid on horizontal and vertical axis.\\n        int h[][][] = new int[r][c+1][2];\\n        int v[][][] = new int[r+1][c][2];\\n        \\n        v[0][0]=new int[]{0,0};\\n        h[0][0]=new int[]{0,0};\\n        for(int i=0; i<r; i++){\\n            for(int j=0; j<c; j++){\\n                var count2N5 = getCount25(grid[i][j]);\\n                v[i+1][j] = new int[]{v[i][j][0]+count2N5[0] , v[i][j][1]+count2N5[1]};\\n                h[i][j+1] = new int[]{h[i][j][0]+count2N5[0], h[i][j][1]+count2N5[1]};\\n            }\\n        }\\n        \\n        \\n        // now for each point in the grid, try to figure out all the 4 possibilities.\\n        \\n        // v1 -> top to bottom vertical till point i,j\\n        // v2 -> bottom to top till point i,j\\n        // h1 -> left to right till point i,j-1  (j will be covered by vertical path,  in code we will be picking up for j because h[i][j] represents total till j-1)\\n        // h2 -> right to left till point i,j+1  (j will be covered by vertical path so if we consider right to left, we need to consider till j+1 only)\\n        \\n        // try (v1,h1)  ( v1,h2)    (v2,h1)   (v2,h2)  as points of intersection\\n        var result =0;\\n        \\n        for(int i=0; i<r; i++){\\n            for(int j=0; j<c; j++){\\n                var v1 = v[i+1][j];\\n                var h1 = h[i][j]; // not j+1 because we have already picked jth element in vertical paths\\n                var v2 = new int[]{ v[r][j][0] - v[i][j][0], v[r][j][1] - v[i][j][1]};\\n                var h2 = new int[]{ h[i][c][0] - h[i][j+1][0], h[i][c][1]- h[i][j+1][1]}; // j+1 because we started from right and we have already picked jth element in vertical path\\n                \\n                // try all 4 combinations at this point\\n                result=Math.max(result, Math.min(v1[0]+h1[0], v1[1]+h1[1]));\\n                result=Math.max(result, Math.min(v1[0]+h2[0], v1[1]+h2[1]));\\n                result=Math.max(result, Math.min(v2[0]+h1[0], v2[1]+h1[1]));\\n                result=Math.max(result, Math.min(v2[0]+h2[0], v2[1]+h2[1]));\\n\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n    \\n    \\n    private int[] getCount25(int val){\\n        int count2=0, count5=0;\\n        while(val%2==0 && val!=0){\\n            val/=2;\\n            count2++;\\n        }\\n        while(val%5==0 && val!=0){\\n            val/=5;\\n            count5++;\\n        }\\n        return new int[]{count2, count5};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957027,
                "title": "how-ans-is-8-test-case-43-534-575-625-84-20-999-35-208-318-96-380-819-102-669",
                "content": "class Solution {  \\n    int power2(int n)\\n{\\n    int count = 0;\\n    while (n % 2 == 0 && n > 0)\\n    {\\n        count++;\\n        n /= 2;\\n    }\\n    return count;\\n}\\nint power5(int n)\\n{\\n    int count = 0;\\n    while (n % 5 == 0 && n > 0)\\n    {\\n        count++;\\n        n /= 5;\\n    }\\n    return count;\\n}\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    vector<vector<int>> v(n + 2, vector<int>(m + 2));\\n    for (int i = 1; i < n + 1; i++)\\n    {\\n        for (int j = 1; j < m + 1; j++)\\n        {\\n            v[i][j] = grid[i - 1][j - 1];\\n        }\\n    }\\n\\n     vector<vector<int>> dp1(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp2(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp3(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp4(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp5(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp6(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp7(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp8(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp9(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp10(n + 2, vector<int>(m + 2));\\n//// counting power of 2 and 5\\n    for (int i = 1; i < n + 1; i++)\\n    {\\n        for (int j = 1; j < m + 1; j++)\\n        {\\n            int cost1 = 0, cost2 = 0;\\n            cost1 = power2(v[i][j]);\\n            cost2 = power5(v[i][j]);\\n            dp1[i][j] = cost1;\\n            dp2[i][j] = cost2;\\n        }\\n    }\\n       //right sum for dp3__2 and dp4__5\\n    for (int i = 1; i < n + 1; i++)\\n    {\\n        for (int j = m; j >= 1; j--)\\n        {\\n            dp3[i][j] += dp3[i][j + 1] + dp1[i][j];\\n            dp4[i][j] += dp4[i][j + 1] + dp2[i][j];\\n        }\\n    }\\n         //left sum for dp7__2 and dp8__5\\n    for (int i = 1; i < n + 1; i++)\\n    {\\n        for (int j = 1; j <= m; j++)\\n        {\\n            dp7[i][j] += dp7[i][j-1] + dp1[i][j];\\n            dp8[i][j] += dp8[i][j-1] + dp2[i][j];\\n        }\\n    } \\n        //  down sum for dp9_2 and dp10_5\\n         for (int j = 1; j < m + 1; j++)\\n    {\\n        for (int i = n; i >= 1; i--)\\n        {\\n            dp9[i][j] += dp9[i][j + 1] + dp1[i][j];\\n            dp10[i][j] += dp10[i][j + 1] + dp2[i][j];\\n        }\\n    }\\n         //  up sum for dp5_2 and dp10_5\\n         for (int i = 1; i < m + 1; i++)\\n    {\\n        for (int j = 1; j <= n; j++)\\n        {\\n            dp5[j][i] += dp5[j - 1][i] + dp1[j][i];\\n            dp6[j][i] += dp6[j - 1][i] + dp2[j][i];\\n        }\\n    }\\n    int ans = 0;\\n\\n    for (int i = 1; i < n + 1; i++)\\n    {\\n        for (int j = 1; j < m + 1; j++)\\n        {\\n            // right and up sum\\n            ans = max(ans, min(dp3[i][j] + dp5[i][j] - dp1[i][j], dp4[i][j] + dp6[i][j] - dp2[i][j]));\\n            //left and up sum\\n             ans = max(ans, min(dp7[i][j] + dp5[i][j] - dp1[i][j], dp8[i][j] + dp6[i][j] - dp2[i][j]));\\n        }\\n    }\\n    for (int i = 1; i < n + 1; i++)\\n    {\\n        for (int j = 1; j < m + 1; j++)\\n        {\\n            //left and down sum\\n            ans = max(ans, min(dp7[i][j] + dp9[i][j] - dp1[i][j], dp8[i][j] + dp10[i][j] - dp2[i][j]));\\n            //right and down sum\\n            ans = max(ans, min(dp3[i][j] + dp9[i][j] - dp1[i][j], dp4[i][j] + dp10[i][j] - dp2[i][j]));\\n        }\\n    }\\n    return ans; \\n    }\\n};",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "class Solution {  \\n    int power2(int n)\\n{\\n    int count = 0;\\n    while (n % 2 == 0 && n > 0)\\n    {\\n        count++;\\n        n /= 2;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1956952,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: list[list[int]]) -> int:\\n\\n        def count2and5(num):\\n            c2, c5 = 0, 0\\n            while num % 2 == 0:\\n                num //= 2\\n                c2 += 1\\n            while num % 5 == 0:\\n                num //= 5\\n                c5 += 1\\n            return [c2, c5]\\n\\n        n, m = len(grid), len(grid[0])\\n\\n        for i in range(n):\\n            for j in range(m):\\n                grid[i][j] = count2and5(grid[i][j])\\n\\n        down = [[[0, 0] for _ in range(m)] for _ in range(n)]\\n        up = [[[0, 0] for _ in range(m)] for _ in range(n)]\\n        right = [[[0, 0] for _ in range(m)] for _ in range(n)]\\n        left = [[[0, 0] for _ in range(m)] for _ in range(n)]\\n\\n        for j in range(m):\\n            c2, c5 = 0, 0\\n            for i in range(n):\\n                c2 += grid[i][j][0]\\n                c5 += grid[i][j][1]\\n                down[i][j] = [c2, c5]\\n\\n        for j in range(m):\\n            c2, c5 = 0, 0\\n            for i in reversed(range(n)):\\n                c2 += grid[i][j][0]\\n                c5 += grid[i][j][1]\\n                up[i][j] = [c2, c5]\\n\\n        for i in range(n):\\n            c2, c5 = 0, 0\\n            for j in range(m):\\n                c2 += grid[i][j][0]\\n                c5 += grid[i][j][1]\\n                right[i][j] = [c2, c5]\\n\\n        for i in range(n):\\n            c2, c5 = 0, 0\\n            for j in reversed(range(m)):\\n                c2 += grid[i][j][0]\\n                c5 += grid[i][j][1]\\n                left[i][j] = [c2, c5]\\n\\n        ans = 0\\n        for i in range(n):\\n            for j in range(m):\\n                if j == m - 1:\\n                    c1_2, c1_5 = down[i][j][0], down[i][j][1]\\n                    c3_2, c3_5 = up[i][j][0], up[i][j][1]\\n                else:\\n                    c1_2, c1_5 = down[i][j][0] + left[i][j+1][0], down[i][j][1] + left[i][j+1][1]\\n                    c3_2, c3_5 = up[i][j][0] + left[i][j+1][0], up[i][j][1] + left[i][j+1][1]\\n                if j == 0:\\n                    c2_2, c2_5 = down[i][j][0], down[i][j][1]\\n                    c4_2, c4_5 = up[i][j][0], up[i][j][1]\\n                else:\\n                    c2_2, c2_5 = down[i][j][0] + right[i][j-1][0], down[i][j][1] + right[i][j-1][1]\\n                    c4_2, c4_5 = up[i][j][0] + right[i][j-1][0], up[i][j][1] + right[i][j-1][1]\\n\\n                k1 = min(c1_2, c1_5)\\n                k2 = min(c2_2, c2_5)\\n                k3 = min(c3_2, c3_5)\\n                k4 = min(c4_2, c4_5)\\n\\n                ans = max(ans, max(k1, k2, k3, k4))\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: list[list[int]]) -> int:\\n\\n        def count2and5(num):\\n            c2, c5 = 0, 0\\n            while num % 2 == 0:\\n                num //= 2\\n                c2 += 1\\n            while num % 5 == 0:\\n                num //= 5\\n                c5 += 1\\n            return [c2, c5]\\n\\n        n, m = len(grid), len(grid[0])\\n\\n        for i in range(n):\\n            for j in range(m):\\n                grid[i][j] = count2and5(grid[i][j])\\n\\n        down = [[[0, 0] for _ in range(m)] for _ in range(n)]\\n        up = [[[0, 0] for _ in range(m)] for _ in range(n)]\\n        right = [[[0, 0] for _ in range(m)] for _ in range(n)]\\n        left = [[[0, 0] for _ in range(m)] for _ in range(n)]\\n\\n        for j in range(m):\\n            c2, c5 = 0, 0\\n            for i in range(n):\\n                c2 += grid[i][j][0]\\n                c5 += grid[i][j][1]\\n                down[i][j] = [c2, c5]\\n\\n        for j in range(m):\\n            c2, c5 = 0, 0\\n            for i in reversed(range(n)):\\n                c2 += grid[i][j][0]\\n                c5 += grid[i][j][1]\\n                up[i][j] = [c2, c5]\\n\\n        for i in range(n):\\n            c2, c5 = 0, 0\\n            for j in range(m):\\n                c2 += grid[i][j][0]\\n                c5 += grid[i][j][1]\\n                right[i][j] = [c2, c5]\\n\\n        for i in range(n):\\n            c2, c5 = 0, 0\\n            for j in reversed(range(m)):\\n                c2 += grid[i][j][0]\\n                c5 += grid[i][j][1]\\n                left[i][j] = [c2, c5]\\n\\n        ans = 0\\n        for i in range(n):\\n            for j in range(m):\\n                if j == m - 1:\\n                    c1_2, c1_5 = down[i][j][0], down[i][j][1]\\n                    c3_2, c3_5 = up[i][j][0], up[i][j][1]\\n                else:\\n                    c1_2, c1_5 = down[i][j][0] + left[i][j+1][0], down[i][j][1] + left[i][j+1][1]\\n                    c3_2, c3_5 = up[i][j][0] + left[i][j+1][0], up[i][j][1] + left[i][j+1][1]\\n                if j == 0:\\n                    c2_2, c2_5 = down[i][j][0], down[i][j][1]\\n                    c4_2, c4_5 = up[i][j][0], up[i][j][1]\\n                else:\\n                    c2_2, c2_5 = down[i][j][0] + right[i][j-1][0], down[i][j][1] + right[i][j-1][1]\\n                    c4_2, c4_5 = up[i][j][0] + right[i][j-1][0], up[i][j][1] + right[i][j-1][1]\\n\\n                k1 = min(c1_2, c1_5)\\n                k2 = min(c2_2, c2_5)\\n                k3 = min(c3_2, c3_5)\\n                k4 = min(c4_2, c4_5)\\n\\n                ans = max(ans, max(k1, k2, k3, k4))\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956941,
                "title": "simple-easy-100-time-100-space-well-explained",
                "content": "There is a corner in the path so I have to take 2 matrix for horizontal and vertical purposes. For optimally checking for power of 10 for each path I have taken use of prefix sum approach. Hope you find it easy to understand. Rest is explained in the code.\\n\\n```\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    \\n    // Power of 10 = min (power of 2, power of 5)\\n    // Because 10 = 2 * 5\\n    \\n    int check(int i, int j, vector<vector<pair<int, int>>>& ver, vector<vector<pair<int, int>>>& hor){\\n        int ans = 0;\\n        int m = ver.size(), n = ver[0].size();\\n        // up - horizontally above current point\\n        // down - horizontally below current point\\n        // left and right are left and right part\\n        // of the path with current point as corner\\n        int up2, up5, down2, down5, left2, left5, right2, right5;\\n        \\n        up2 = ver[i][j].F;\\n        up5 = ver[i][j].S;\\n        if(j > 0){\\n            left2 = hor[i][j-1].F;\\n            left5 = hor[i][j-1].S;\\n        }\\n        else{\\n            left2 = left5 = 0;\\n        }\\n        \\n        if(i > 0){\\n            down2 = ver[m-1][j].F - ver[i-1][j].F;\\n            down5 = ver[m-1][j].S - ver[i-1][j].S;\\n        }\\n        else{\\n            down2 = ver[m-1][j].F;\\n            down5 = ver[m-1][j].S;\\n        }\\n        \\n        right2 = hor[i][n-1].F - hor[i][j].F;\\n        right5 = hor[i][n-1].S - hor[i][j].S;\\n        \\n        // Checking for all 4 possible cases of forming a corner path\\n        // at this corner point and taking the maximum of it\\n        ans = max(ans, min(up2 + left2, up5 + left5));\\n        ans = max(ans, min(up2 + right2, up5 + right5));\\n        ans = max(ans, min(down2 + left2, down5 + left5));\\n        ans = max(ans, min(down2 + right2, down5 + right5));\\n        \\n        return ans;\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        // Defined two matrix\\n        // hor - for presum in horizontal direction\\n        // ver - for presum in vertical direction\\n        vector<vector<pair<int, int>>> hor(m, vector<pair<int, int>> (n)), ver(m, vector<pair<int, int>> (n));\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                int num2 = 0, num5 = 0;\\n                \\n                while(grid[i][j]%2 == 0){\\n                    num2++;\\n                    grid[i][j] /= 2;\\n                }\\n                \\n                while(grid[i][j]%5 == 0){\\n                    num5++;\\n                    grid[i][j] /= 5;\\n                }\\n                \\n                // each cell = {pow of 2, pow of 5}\\n                hor[i][j].F = ver[i][j].F = num2;\\n                hor[i][j].S = ver[i][j].S = num5;\\n            }\\n        }\\n        \\n        // Precalculation for presum in horizontal direction\\n        for(int i=0; i<m; i++){\\n            for(int j=1; j<n; j++){\\n                hor[i][j].F += hor[i][j-1].F;\\n                hor[i][j].S += hor[i][j-1].S;\\n            }\\n        }\\n        \\n        // Precalculation for presum in vertical direction\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                ver[j][i].F += ver[j-1][i].F;\\n                ver[j][i].S += ver[j-1][i].S;\\n            }\\n        }\\n        \\n        // Now at each point I am considering it as a corner of the path\\n        // and finding the corner with maximum answer\\n        int maxN = 0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                maxN = max(maxN, check(i, j, ver, hor));\\n            }\\n        }\\n        \\n        return maxN;\\n    }\\n};\\n```\\nUpvote if you found my solution helpful :-)",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    \\n    // Power of 10 = min (power of 2, power of 5)\\n    // Because 10 = 2 * 5\\n    \\n    int check(int i, int j, vector<vector<pair<int, int>>>& ver, vector<vector<pair<int, int>>>& hor){\\n        int ans = 0;\\n        int m = ver.size(), n = ver[0].size();\\n        // up - horizontally above current point\\n        // down - horizontally below current point\\n        // left and right are left and right part\\n        // of the path with current point as corner\\n        int up2, up5, down2, down5, left2, left5, right2, right5;\\n        \\n        up2 = ver[i][j].F;\\n        up5 = ver[i][j].S;\\n        if(j > 0){\\n            left2 = hor[i][j-1].F;\\n            left5 = hor[i][j-1].S;\\n        }\\n        else{\\n            left2 = left5 = 0;\\n        }\\n        \\n        if(i > 0){\\n            down2 = ver[m-1][j].F - ver[i-1][j].F;\\n            down5 = ver[m-1][j].S - ver[i-1][j].S;\\n        }\\n        else{\\n            down2 = ver[m-1][j].F;\\n            down5 = ver[m-1][j].S;\\n        }\\n        \\n        right2 = hor[i][n-1].F - hor[i][j].F;\\n        right5 = hor[i][n-1].S - hor[i][j].S;\\n        \\n        // Checking for all 4 possible cases of forming a corner path\\n        // at this corner point and taking the maximum of it\\n        ans = max(ans, min(up2 + left2, up5 + left5));\\n        ans = max(ans, min(up2 + right2, up5 + right5));\\n        ans = max(ans, min(down2 + left2, down5 + left5));\\n        ans = max(ans, min(down2 + right2, down5 + right5));\\n        \\n        return ans;\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        // Defined two matrix\\n        // hor - for presum in horizontal direction\\n        // ver - for presum in vertical direction\\n        vector<vector<pair<int, int>>> hor(m, vector<pair<int, int>> (n)), ver(m, vector<pair<int, int>> (n));\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                int num2 = 0, num5 = 0;\\n                \\n                while(grid[i][j]%2 == 0){\\n                    num2++;\\n                    grid[i][j] /= 2;\\n                }\\n                \\n                while(grid[i][j]%5 == 0){\\n                    num5++;\\n                    grid[i][j] /= 5;\\n                }\\n                \\n                // each cell = {pow of 2, pow of 5}\\n                hor[i][j].F = ver[i][j].F = num2;\\n                hor[i][j].S = ver[i][j].S = num5;\\n            }\\n        }\\n        \\n        // Precalculation for presum in horizontal direction\\n        for(int i=0; i<m; i++){\\n            for(int j=1; j<n; j++){\\n                hor[i][j].F += hor[i][j-1].F;\\n                hor[i][j].S += hor[i][j-1].S;\\n            }\\n        }\\n        \\n        // Precalculation for presum in vertical direction\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                ver[j][i].F += ver[j-1][i].F;\\n                ver[j][i].S += ver[j-1][i].S;\\n            }\\n        }\\n        \\n        // Now at each point I am considering it as a corner of the path\\n        // and finding the corner with maximum answer\\n        int maxN = 0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                maxN = max(maxN, check(i, j, ver, hor));\\n            }\\n        }\\n        \\n        return maxN;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956893,
                "title": "clean-code-prefix-sum-of-factors-2-and-5-c-faster-than-100",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& a) {\\n        int n=a.size();\\n        int m=a[0].size();\\n        vector<vector<int>> pref_row2(n,vector<int> (m,0));\\n        vector<vector<int>> pref_row5(n,vector<int> (m,0));\\n        vector<vector<int>> pref_col2(n,vector<int> (m,0));\\n        vector<vector<int>> pref_col5(n,vector<int> (m,0));\\n\\n        vector<vector<int>> store2(n,vector<int> (m,0));\\n        vector<vector<int>> store5(n,vector<int> (m,0));\\n\\n        for (int i = 0; i < n; ++i)\\n        {\\n            for (int j = 0; j < m; ++j)\\n            {\\n                int temp=a[i][j];\\n                int five=0;\\n                while(temp%5==0 and temp>0)\\n                {\\n                    temp/=5;\\n                    five++;\\n                }\\n                int two=0;\\n                while(temp%2==0 and temp>0)\\n                {\\n                    temp/=2;\\n                    two++;\\n                }\\n                pref_row2[i][j]=two;\\n                pref_row5[i][j]=five;\\n\\n                pref_col2[i][j]=two;\\n                pref_col5[i][j]=five;\\n\\n                store2[i][j]=two;\\n                store5[i][j]=five;\\n            }\\n        }\\n        for (int i = 1; i < n; ++i)\\n        {\\n            for (int j = 0; j < m; ++j)\\n            {\\n                pref_row2[i][j]+=pref_row2[i-1][j];\\n                pref_row5[i][j]+=pref_row5[i-1][j];\\n            }\\n        }\\n\\n        for (int i = 0; i < n; ++i)\\n        {\\n            for (int j = 1; j < m; ++j)\\n            {\\n                pref_col2[i][j]+=pref_col2[i][j-1];\\n                pref_col5[i][j]+=pref_col5[i][j-1];\\n            }\\n        }\\n\\n        int ans=0;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            for (int j = 0; j < m; ++j)\\n            {\\n                int two=pref_row2[i][j]+pref_col2[i][j]-store2[i][j];\\n                int five=pref_row5[i][j]+pref_col5[i][j]-store5[i][j];\\n\\n                ans=max(ans,min(two,five));\\n\\n                two=pref_row2[i][j]+pref_col2[i][m-1]-pref_col2[i][j];\\n                five=pref_row5[i][j]+pref_col5[i][m-1]-pref_col5[i][j];\\n\\n                ans=max(ans,min(two,five));\\n\\n                two=pref_row2[n-1][j]-pref_row2[i][j]+pref_col2[i][j];\\n                five=pref_row5[n-1][j]-pref_row5[i][j]+pref_col5[i][j];\\n\\n                ans=max(ans,min(two,five));\\n\\n                two=pref_row2[n-1][j]-pref_row2[i][j]+pref_col2[i][m-1]-pref_col2[i][j]+store2[i][j];\\n                five=pref_row5[n-1][j]-pref_row5[i][j]+pref_col5[i][m-1]-pref_col5[i][j]+store5[i][j];\\n\\n                ans=max(ans,min(two,five));\\n            }\\n        }\\n        return ans;\\n     }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& a) {\\n        int n=a.size();\\n        int m=a[0].size();\\n        vector<vector<int>> pref_row2(n,vector<int> (m,0));\\n        vector<vector<int>> pref_row5(n,vector<int> (m,0));\\n        vector<vector<int>> pref_col2(n,vector<int> (m,0));\\n        vector<vector<int>> pref_col5(n,vector<int> (m,0));\\n\\n        vector<vector<int>> store2(n,vector<int> (m,0));\\n        vector<vector<int>> store5(n,vector<int> (m,0));\\n\\n        for (int i = 0; i < n; ++i)\\n        {\\n            for (int j = 0; j < m; ++j)\\n            {\\n                int temp=a[i][j];\\n                int five=0;\\n                while(temp%5==0 and temp>0)\\n                {\\n                    temp/=5;\\n                    five++;\\n                }\\n                int two=0;\\n                while(temp%2==0 and temp>0)\\n                {\\n                    temp/=2;\\n                    two++;\\n                }\\n                pref_row2[i][j]=two;\\n                pref_row5[i][j]=five;\\n\\n                pref_col2[i][j]=two;\\n                pref_col5[i][j]=five;\\n\\n                store2[i][j]=two;\\n                store5[i][j]=five;\\n            }\\n        }\\n        for (int i = 1; i < n; ++i)\\n        {\\n            for (int j = 0; j < m; ++j)\\n            {\\n                pref_row2[i][j]+=pref_row2[i-1][j];\\n                pref_row5[i][j]+=pref_row5[i-1][j];\\n            }\\n        }\\n\\n        for (int i = 0; i < n; ++i)\\n        {\\n            for (int j = 1; j < m; ++j)\\n            {\\n                pref_col2[i][j]+=pref_col2[i][j-1];\\n                pref_col5[i][j]+=pref_col5[i][j-1];\\n            }\\n        }\\n\\n        int ans=0;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            for (int j = 0; j < m; ++j)\\n            {\\n                int two=pref_row2[i][j]+pref_col2[i][j]-store2[i][j];\\n                int five=pref_row5[i][j]+pref_col5[i][j]-store5[i][j];\\n\\n                ans=max(ans,min(two,five));\\n\\n                two=pref_row2[i][j]+pref_col2[i][m-1]-pref_col2[i][j];\\n                five=pref_row5[i][j]+pref_col5[i][m-1]-pref_col5[i][j];\\n\\n                ans=max(ans,min(two,five));\\n\\n                two=pref_row2[n-1][j]-pref_row2[i][j]+pref_col2[i][j];\\n                five=pref_row5[n-1][j]-pref_row5[i][j]+pref_col5[i][j];\\n\\n                ans=max(ans,min(two,five));\\n\\n                two=pref_row2[n-1][j]-pref_row2[i][j]+pref_col2[i][m-1]-pref_col2[i][j]+store2[i][j];\\n                five=pref_row5[n-1][j]-pref_row5[i][j]+pref_col5[i][m-1]-pref_col5[i][j]+store5[i][j];\\n\\n                ans=max(ans,min(two,five));\\n            }\\n        }\\n        return ans;\\n     }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956780,
                "title": "can-anyone-tell-me-where-i-was-wrong-its-show-wrong-ans-on-test-case-37-54",
                "content": "class Solution {  \\n    int power2(int n)\\n{\\n    int count = 0;\\n    while (n % 2 == 0 && n > 0)\\n    {\\n        count++;\\n        n /= 2;\\n    }\\n    return count;\\n}\\nint power5(int n)\\n{\\n    int count = 0;\\n    while (n % 5 == 0 && n > 0)\\n    {\\n        count++;\\n        n /= 5;\\n    }\\n    return count;\\n}\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    vector<vector<int>> v(n + 2, vector<int>(m + 2));\\n    for (int i = 1; i < n + 1; i++)\\n    {\\n        for (int j = 1; j < m + 1; j++)\\n        {\\n            v[i][j] = grid[i - 1][j - 1];\\n        }\\n    }\\n\\n    vector<vector<int>> dp1(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp2(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp3(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp4(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp5(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp6(n + 2, vector<int>(m + 2));\\n\\n    for (int i = 1; i < n + 1; i++)\\n    {\\n        for (int j = 1; j < m + 1; j++)\\n        {\\n            int cost1 = 0, cost2 = 0;\\n            cost1 = power2(v[i][j]);\\n            cost2 = power5(v[i][j]);\\n            dp1[i][j] = cost1;\\n            dp2[i][j] = cost2;\\n        }\\n    }\\n    for (int i = 1; i < n + 1; i++)\\n    {\\n        for (int j = m; j >= 1; j--)\\n        {\\n            dp3[i][j] += dp3[i][j + 1] + dp1[i][j];\\n            dp4[i][j] += dp4[i][j + 1] + dp2[i][j];\\n        }\\n    }\\n    for (int i = 1; i < m + 1; i++)\\n    {\\n        for (int j = 1; j <= n; j++)\\n        {\\n            dp5[j][i] += dp5[j - 1][i] + dp1[j][i];\\n            dp6[j][i] += dp6[j - 1][i] + dp2[j][i];\\n        }\\n    }\\n    int ans = 0;\\n\\n    for (int i = 1; i < n + 1; i++)\\n    {\\n        ans = max(ans, min(dp3[i][1] + dp5[i][1] - dp1[i][1], dp4[i][1] + dp6[i][1] - dp2[i][1]));\\n    }\\n    int sum2 = 0, sum5 = 0;\\n    for (int i = 1; i < m + 1; i++)\\n    {\\n        sum2 += dp1[1][i];\\n        sum5 += dp2[1][i];\\n    }\\n    for (int i = 1; i < m + 1; i++)\\n    {\\n        ans = max(ans, min(sum2 - dp3[1][i] + dp5[n][i], sum5 - dp4[1][i] + dp6[n][i]));\\n    }\\n    for (int i = 1; i < n + 1; i++)\\n    {\\n        for (int j = 1; j < m + 1; j++)\\n        {\\n            ans = max(ans, min(dp3[i][j] + dp5[i][j] - dp1[i][j], dp4[i][j] + dp6[i][j] - dp2[i][j]));\\n        }\\n    }\\n    return ans; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {  \\n    int power2(int n)\\n{\\n    int count = 0;\\n    while (n % 2 == 0 && n > 0)\\n    {\\n        count++;\\n        n /= 2;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1956752,
                "title": "c-easy-to-understand-beat-100-prefix-sum-of-2-and-5-factors",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vetical2(n+1, vector<int>(m+1, 0));\\n        vector<vector<int>> vetical5 = vetical2;\\n        vector<vector<int>> horizontal2 = vetical2;\\n        vector<vector<int>> horizontal5 = horizontal2;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                int x = grid[i - 1][j - 1];\\n                int two = 0, five = 0;\\n                while (x % 2 == 0) {\\n                    two++;\\n                    x /= 2;\\n                }\\n                while (x % 5 == 0) {\\n                    five++;\\n                    x /= 5;\\n                }\\n                horizontal2[i][j] = horizontal2[i][j - 1] + two;\\n                vetical2[i][j] = vetical2[i - 1][j] + two;\\n                horizontal5[i][j] = horizontal5[i][j - 1] + five;\\n                vetical5[i][j] = vetical5[i - 1][j] + five;\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                //     |\\n                //     |\\n                // ----\\n                res = max(res, min(horizontal2[i][j] + vetical2[i - 1][j], \\\\\\n                                   horizontal5[i][j] + vetical5[i - 1][j]));\\n                // ----\\n                //     |\\n                //     |\\n                res = max(res, min(horizontal2[i][j] + vetical2[n][j] - vetical2[i][j], \\\\\\n                                   horizontal5[i][j] + vetical5[n][j] - vetical5[i][j]));\\n                // |\\n                // |\\n                //  ----\\n                res = max(res, min(horizontal2[i][m] - horizontal2[i][j] + vetical2[i][j], \\\\\\n                                   horizontal5[i][m] - horizontal5[i][j] + vetical5[i][j]));\\n                //  ----\\n                // |\\n                // |\\n                res = max(res, min(horizontal2[i][m] - horizontal2[i][j] + vetical2[n][j] - vetical2[i - 1][j], \\\\\\n                                   horizontal5[i][m] - horizontal5[i][j] + vetical5[n][j] - vetical5[i - 1][j]));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vetical2(n+1, vector<int>(m+1, 0));\\n        vector<vector<int>> vetical5 = vetical2;\\n        vector<vector<int>> horizontal2 = vetical2;\\n        vector<vector<int>> horizontal5 = horizontal2;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                int x = grid[i - 1][j - 1];\\n                int two = 0, five = 0;\\n                while (x % 2 == 0) {\\n                    two++;\\n                    x /= 2;\\n                }\\n                while (x % 5 == 0) {\\n                    five++;\\n                    x /= 5;\\n                }\\n                horizontal2[i][j] = horizontal2[i][j - 1] + two;\\n                vetical2[i][j] = vetical2[i - 1][j] + two;\\n                horizontal5[i][j] = horizontal5[i][j - 1] + five;\\n                vetical5[i][j] = vetical5[i - 1][j] + five;\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                //     |\\n                //     |\\n                // ----\\n                res = max(res, min(horizontal2[i][j] + vetical2[i - 1][j], \\\\\\n                                   horizontal5[i][j] + vetical5[i - 1][j]));\\n                // ----\\n                //     |\\n                //     |\\n                res = max(res, min(horizontal2[i][j] + vetical2[n][j] - vetical2[i][j], \\\\\\n                                   horizontal5[i][j] + vetical5[n][j] - vetical5[i][j]));\\n                // |\\n                // |\\n                //  ----\\n                res = max(res, min(horizontal2[i][m] - horizontal2[i][j] + vetical2[i][j], \\\\\\n                                   horizontal5[i][m] - horizontal5[i][j] + vetical5[i][j]));\\n                //  ----\\n                // |\\n                // |\\n                res = max(res, min(horizontal2[i][m] - horizontal2[i][j] + vetical2[n][j] - vetical2[i - 1][j], \\\\\\n                                   horizontal5[i][m] - horizontal5[i][j] + vetical5[n][j] - vetical5[i - 1][j]));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956749,
                "title": "brute-force-path-search-40-54-passed-before-tle",
                "content": "I know the prefix sum solutions are way faster, but I had fun trying to get this by actually searching paths!\\n\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        @functools.lru_cache(None)\\n        def factor(num):\\n            twos = fives = 0\\n            temp1 = temp2 = num\\n            while temp1 % 2 == 0:\\n                temp1 /= 2\\n                twos += 1\\n            while temp2 % 5 == 0:\\n                temp2 /= 5\\n                fives += 1\\n            return (twos, fives)\\n\\n        R, C = len(grid), len(grid[0])\\n        res = -float(\"inf\")\\n\\n        prune = defaultdict(int)\\n\\n        def helper(pos: Tuple, cur_dir: Tuple, cur_factors, turned):\\n            nonlocal R, C, res\\n\\n            if not (0 <= pos[0] < R and 0 <= pos[1] < C):\\n                return min(cur_factors)\\n            \\n            # Previously reached this state with Higher Factors\\n            prior = prune.get((pos, cur_dir, turned), None)\\n            if prior and prior >= min(cur_factors):\\n                return 0\\n            else:\\n                prune[(pos, cur_dir, turned)] = min(cur_factors)\\n\\n                \\n            f = factor(grid[pos[0]][pos[1]])\\n\\n            new_fac = (\\n                cur_factors[0] + f[0],\\n                cur_factors[1] + f[1],\\n            )\\n\\n            res = 0\\n\\n            # Case A: Explore turning at Pos\\n            if turned == False:\\n\\n                new_dir1 = tuple(reversed(cur_dir))\\n                new_dir2 = tuple([-1 * x for x in new_dir1])\\n\\n                for d in [new_dir1, new_dir2]:\\n                    new_pos = (\\n                        pos[0] + d[0],\\n                        pos[1] + d[1],\\n                    )\\n                    res = max(res, helper(new_pos, d, new_fac, True))\\n\\n            # Case B: No turning at Pos\\n            new_pos = (pos[0] + cur_dir[0], pos[1] + cur_dir[1])\\n\\n            res = max(res, helper(new_pos, cur_dir, new_fac, turned))\\n\\n            return res\\n\\n        ans = 0\\n        for r in range(R):\\n            ans = max(ans, helper((r, 0), (0, 1), (0, 0), False))\\n            ans = max(ans, helper((r, C - 1), (0, -1), (0, 0), False))\\n        for c in range(C):\\n            ans = max(ans, helper((0, c), (1, 0), (0, 0), False))\\n            ans = max(ans, helper((0, R - 1), (-1, 0), (0, 0), False))\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        @functools.lru_cache(None)\\n        def factor(num):\\n            twos = fives = 0\\n            temp1 = temp2 = num\\n            while temp1 % 2 == 0:\\n                temp1 /= 2\\n                twos += 1\\n            while temp2 % 5 == 0:\\n                temp2 /= 5\\n                fives += 1\\n            return (twos, fives)\\n\\n        R, C = len(grid), len(grid[0])\\n        res = -float(\"inf\")\\n\\n        prune = defaultdict(int)\\n\\n        def helper(pos: Tuple, cur_dir: Tuple, cur_factors, turned):\\n            nonlocal R, C, res\\n\\n            if not (0 <= pos[0] < R and 0 <= pos[1] < C):\\n                return min(cur_factors)\\n            \\n            # Previously reached this state with Higher Factors\\n            prior = prune.get((pos, cur_dir, turned), None)\\n            if prior and prior >= min(cur_factors):\\n                return 0\\n            else:\\n                prune[(pos, cur_dir, turned)] = min(cur_factors)\\n\\n                \\n            f = factor(grid[pos[0]][pos[1]])\\n\\n            new_fac = (\\n                cur_factors[0] + f[0],\\n                cur_factors[1] + f[1],\\n            )\\n\\n            res = 0\\n\\n            # Case A: Explore turning at Pos\\n            if turned == False:\\n\\n                new_dir1 = tuple(reversed(cur_dir))\\n                new_dir2 = tuple([-1 * x for x in new_dir1])\\n\\n                for d in [new_dir1, new_dir2]:\\n                    new_pos = (\\n                        pos[0] + d[0],\\n                        pos[1] + d[1],\\n                    )\\n                    res = max(res, helper(new_pos, d, new_fac, True))\\n\\n            # Case B: No turning at Pos\\n            new_pos = (pos[0] + cur_dir[0], pos[1] + cur_dir[1])\\n\\n            res = max(res, helper(new_pos, cur_dir, new_fac, turned))\\n\\n            return res\\n\\n        ans = 0\\n        for r in range(R):\\n            ans = max(ans, helper((r, 0), (0, 1), (0, 0), False))\\n            ans = max(ans, helper((r, C - 1), (0, -1), (0, 0), False))\\n        for c in range(C):\\n            ans = max(ans, helper((0, c), (1, 0), (0, 0), False))\\n            ans = max(ans, helper((0, R - 1), (-1, 0), (0, 0), False))\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956633,
                "title": "python3-math-prefix-sum-solution",
                "content": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        presum_row_mod_two = [[0] * m for _ in range(n)]\\n        presum_col_mod_two = [[0] * n for _ in range(m)]\\n        presum_row_mod_five = [[0] * m for _ in range(n)]\\n        presum_col_mod_five = [[0] * n for _ in range(m)]\\n        res = 0\\n        for i in range(n):\\n            for j in range(m):\\n                temp = grid[i][j]\\n                while temp % 2 == 0:\\n                    presum_row_mod_two[i][j] += 1\\n                    temp //= 2\\n                if j > 0:\\n                    presum_row_mod_two[i][j] += presum_row_mod_two[i][j - 1]\\n                temp = grid[i][j]\\n                while temp % 5 == 0:\\n                    presum_row_mod_five[i][j] += 1\\n                    temp //= 5\\n                if j > 0:\\n                    presum_row_mod_five[i][j] += presum_row_mod_five[i][j - 1]\\n        for i in range(m):\\n            for j in range(n):\\n                temp = grid[j][i]\\n                while temp % 2 == 0:\\n                    presum_col_mod_two[i][j] += 1\\n                    temp //= 2\\n                if j > 0:\\n                    presum_col_mod_two[i][j] += presum_col_mod_two[i][j - 1]\\n                temp = grid[j][i]\\n                while temp % 5 == 0:\\n                    presum_col_mod_five[i][j] += 1\\n                    temp //= 5\\n                if j > 0:\\n                    presum_col_mod_five[i][j] += presum_col_mod_five[i][j - 1]\\n        for i in range(n):\\n            for j in range(m):\\n                options = []\\n                options.append(presum_col_mod_two[j][i - 1] if i - 1 >= 0 else 0)\\n                options.append(presum_col_mod_two[j][n - 1] - presum_col_mod_two[j][i])\\n                options.append(presum_row_mod_two[i][j - 1] if j - 1 >= 0 else 0)\\n                options.append(presum_row_mod_two[i][m - 1] - presum_row_mod_two[i][j])\\n                options.append(presum_col_mod_five[j][i - 1] if i - 1 >= 0 else 0)\\n                options.append(presum_col_mod_five[j][n - 1] - presum_col_mod_five[j][i])\\n                options.append(presum_row_mod_five[i][j - 1] if j - 1 >= 0 else 0)\\n                options.append(presum_row_mod_five[i][m - 1] - presum_row_mod_five[i][j])\\n                cnt_two = 0\\n                cnt_five = 0\\n                temp = grid[i][j]\\n                while temp % 2 == 0:\\n                    cnt_two += 1\\n                    temp //= 2\\n                temp = grid[i][j]\\n                while temp % 5 == 0:\\n                    cnt_five += 1\\n                    temp //= 5\\n                for k in range(4):\\n                    for l in range(k + 1, 4):\\n                        cur = min(options[k] + options[l] + cnt_two, options[k + 4] + options[l + 4] + cnt_five)\\n                        res = max(cur, res)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        presum_row_mod_two = [[0] * m for _ in range(n)]\\n        presum_col_mod_two = [[0] * n for _ in range(m)]\\n        presum_row_mod_five = [[0] * m for _ in range(n)]\\n        presum_col_mod_five = [[0] * n for _ in range(m)]\\n        res = 0\\n        for i in range(n):\\n            for j in range(m):\\n                temp = grid[i][j]\\n                while temp % 2 == 0:\\n                    presum_row_mod_two[i][j] += 1\\n                    temp //= 2\\n                if j > 0:\\n                    presum_row_mod_two[i][j] += presum_row_mod_two[i][j - 1]\\n                temp = grid[i][j]\\n                while temp % 5 == 0:\\n                    presum_row_mod_five[i][j] += 1\\n                    temp //= 5\\n                if j > 0:\\n                    presum_row_mod_five[i][j] += presum_row_mod_five[i][j - 1]\\n        for i in range(m):\\n            for j in range(n):\\n                temp = grid[j][i]\\n                while temp % 2 == 0:\\n                    presum_col_mod_two[i][j] += 1\\n                    temp //= 2\\n                if j > 0:\\n                    presum_col_mod_two[i][j] += presum_col_mod_two[i][j - 1]\\n                temp = grid[j][i]\\n                while temp % 5 == 0:\\n                    presum_col_mod_five[i][j] += 1\\n                    temp //= 5\\n                if j > 0:\\n                    presum_col_mod_five[i][j] += presum_col_mod_five[i][j - 1]\\n        for i in range(n):\\n            for j in range(m):\\n                options = []\\n                options.append(presum_col_mod_two[j][i - 1] if i - 1 >= 0 else 0)\\n                options.append(presum_col_mod_two[j][n - 1] - presum_col_mod_two[j][i])\\n                options.append(presum_row_mod_two[i][j - 1] if j - 1 >= 0 else 0)\\n                options.append(presum_row_mod_two[i][m - 1] - presum_row_mod_two[i][j])\\n                options.append(presum_col_mod_five[j][i - 1] if i - 1 >= 0 else 0)\\n                options.append(presum_col_mod_five[j][n - 1] - presum_col_mod_five[j][i])\\n                options.append(presum_row_mod_five[i][j - 1] if j - 1 >= 0 else 0)\\n                options.append(presum_row_mod_five[i][m - 1] - presum_row_mod_five[i][j])\\n                cnt_two = 0\\n                cnt_five = 0\\n                temp = grid[i][j]\\n                while temp % 2 == 0:\\n                    cnt_two += 1\\n                    temp //= 2\\n                temp = grid[i][j]\\n                while temp % 5 == 0:\\n                    cnt_five += 1\\n                    temp //= 5\\n                for k in range(4):\\n                    for l in range(k + 1, 4):\\n                        cur = min(options[k] + options[l] + cnt_two, options[k + 4] + options[l + 4] + cnt_five)\\n                        res = max(cur, res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956595,
                "title": "c-beats-100-prefix-sum-in-matrix",
                "content": "```\\n/* \\n    Time: O(n*m)\\n    Space: O(n*m)\\n    Tag: Prefix Sum, Matrix, Implementation\\n    Difficulty: MH\\n*/\\n\\nclass Solution {\\npublic:\\n    int factOf5(int num) {\\n        int res = 0;\\n        while (num && num % 5 == 0) {\\n            res++;\\n            num /= 5;\\n        }\\n        return res;\\n    }\\n    int factOf2(int num) {\\n        int res = 0;\\n        while (num && num % 2 == 0) {\\n            res++;\\n            num /= 2;\\n        }\\n        return res;\\n    }\\n\\n    int maxTrailingZeros(vector<vector<int>> &grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> fives(n, vector<int>(m));\\n        vector<vector<int>> twos(n, vector<int>(m));\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                fives[i][j] = factOf5(grid[i][j]);\\n                twos[i][j] = factOf2(grid[i][j]);\\n            }\\n        }\\n        vector<vector<int>> prefvert5(n + 1, vector<int>(m + 1));\\n        vector<vector<int>> prefvert2(n + 1, vector<int>(m + 1));\\n        vector<vector<int>> prefhoriz5(n + 1, vector<int>(m + 1));\\n        vector<vector<int>> prefhoriz2(n + 1, vector<int>(m + 1));\\n\\n        for (int i = 0; i <= n; i++) {\\n            for (int j = 0; j <= m; j++) {\\n                if (i == 0 || j == 0) {\\n                    prefhoriz5[i][j] == 0;\\n                    prefhoriz2[i][j] == 0;\\n                } else {\\n                    prefhoriz5[i][j] = prefhoriz5[i][j - 1] + fives[i - 1][j - 1];\\n                    prefhoriz2[i][j] = prefhoriz2[i][j - 1] + twos[i - 1][j - 1];\\n                }\\n            }\\n        }\\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 0; j <= n; j++) {\\n                if (i == 0 || j == 0) {\\n                    prefvert5[j][i] == 0;\\n                    prefvert2[j][i] == 0;\\n                } else {\\n                    prefvert5[j][i] = prefvert5[j - 1][i] + fives[j - 1][i - 1];\\n                    prefvert2[j][i] = prefvert2[j - 1][i] + twos[j - 1][i - 1];\\n                }\\n            }\\n        }\\n\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int vertdown2 = prefvert2[n][j + 1] - prefvert2[i][j + 1];\\n                int vertdown5 = prefvert5[n][j + 1] - prefvert5[i][j + 1];\\n                int vertup2 = prefvert2[i + 1][j + 1];\\n                int vertup5 = prefvert5[i + 1][j + 1];\\n\\n                int horizleft2 = prefhoriz2[i + 1][j + 1];\\n                int horizleft5 = prefhoriz5[i + 1][j + 1];\\n                int horizRight2 = prefhoriz2[i + 1][m] - prefhoriz2[i + 1][j];\\n                int horizRight5 = prefhoriz5[i + 1][m] - prefhoriz5[i + 1][j];\\n\\n                int res1 = min(horizleft2 + vertup2 - twos[i][j], horizleft5 + vertup5 - fives[i][j]);\\n                int res2 = min(horizleft2 + vertdown2 - twos[i][j], horizleft5 + vertdown5 - fives[i][j]);\\n                int res3 = min(horizRight2 + vertup2 - twos[i][j], horizRight5 + vertup5 - fives[i][j]);\\n                int res4 = min(horizRight2 + vertdown2 - twos[i][j], horizRight5 + vertdown5 - fives[i][j]);\\n                res = max(res, max(res1, max(res2, max(res3, res4))));\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\n/* \\n    Time: O(n*m)\\n    Space: O(n*m)\\n    Tag: Prefix Sum, Matrix, Implementation\\n    Difficulty: MH\\n*/\\n\\nclass Solution {\\npublic:\\n    int factOf5(int num) {\\n        int res = 0;\\n        while (num && num % 5 == 0) {\\n            res++;\\n            num /= 5;\\n        }\\n        return res;\\n    }\\n    int factOf2(int num) {\\n        int res = 0;\\n        while (num && num % 2 == 0) {\\n            res++;\\n            num /= 2;\\n        }\\n        return res;\\n    }\\n\\n    int maxTrailingZeros(vector<vector<int>> &grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> fives(n, vector<int>(m));\\n        vector<vector<int>> twos(n, vector<int>(m));\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                fives[i][j] = factOf5(grid[i][j]);\\n                twos[i][j] = factOf2(grid[i][j]);\\n            }\\n        }\\n        vector<vector<int>> prefvert5(n + 1, vector<int>(m + 1));\\n        vector<vector<int>> prefvert2(n + 1, vector<int>(m + 1));\\n        vector<vector<int>> prefhoriz5(n + 1, vector<int>(m + 1));\\n        vector<vector<int>> prefhoriz2(n + 1, vector<int>(m + 1));\\n\\n        for (int i = 0; i <= n; i++) {\\n            for (int j = 0; j <= m; j++) {\\n                if (i == 0 || j == 0) {\\n                    prefhoriz5[i][j] == 0;\\n                    prefhoriz2[i][j] == 0;\\n                } else {\\n                    prefhoriz5[i][j] = prefhoriz5[i][j - 1] + fives[i - 1][j - 1];\\n                    prefhoriz2[i][j] = prefhoriz2[i][j - 1] + twos[i - 1][j - 1];\\n                }\\n            }\\n        }\\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 0; j <= n; j++) {\\n                if (i == 0 || j == 0) {\\n                    prefvert5[j][i] == 0;\\n                    prefvert2[j][i] == 0;\\n                } else {\\n                    prefvert5[j][i] = prefvert5[j - 1][i] + fives[j - 1][i - 1];\\n                    prefvert2[j][i] = prefvert2[j - 1][i] + twos[j - 1][i - 1];\\n                }\\n            }\\n        }\\n\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int vertdown2 = prefvert2[n][j + 1] - prefvert2[i][j + 1];\\n                int vertdown5 = prefvert5[n][j + 1] - prefvert5[i][j + 1];\\n                int vertup2 = prefvert2[i + 1][j + 1];\\n                int vertup5 = prefvert5[i + 1][j + 1];\\n\\n                int horizleft2 = prefhoriz2[i + 1][j + 1];\\n                int horizleft5 = prefhoriz5[i + 1][j + 1];\\n                int horizRight2 = prefhoriz2[i + 1][m] - prefhoriz2[i + 1][j];\\n                int horizRight5 = prefhoriz5[i + 1][m] - prefhoriz5[i + 1][j];\\n\\n                int res1 = min(horizleft2 + vertup2 - twos[i][j], horizleft5 + vertup5 - fives[i][j]);\\n                int res2 = min(horizleft2 + vertdown2 - twos[i][j], horizleft5 + vertdown5 - fives[i][j]);\\n                int res3 = min(horizRight2 + vertup2 - twos[i][j], horizRight5 + vertup5 - fives[i][j]);\\n                int res4 = min(horizRight2 + vertdown2 - twos[i][j], horizRight5 + vertdown5 - fives[i][j]);\\n                res = max(res, max(res1, max(res2, max(res3, res4))));\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956478,
                "title": "python-2d-prefix-sum-6-cases",
                "content": "Rather lengthy code...\\n\\n```python\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        @cache\\n        def count(x, k):\\n            ans = 0\\n            while x % k == 0:\\n                x = x // k\\n                ans += 1\\n            return ans\\n                \\n        R, C = len(grid), len(grid[0])\\n        PREFIX = [[[0, 0, 0, 0] for _ in range(C + 1)] for _ in range(R + 1)]\\n        for r in range(R):\\n            for c in range(C):\\n                #current counts\\n                count2 = count(grid[r][c], 2)\\n                count5 = count(grid[r][c], 5)  \\n                #how many 2\\'s from left\\n                PREFIX[r + 1][c + 1][0] = count2 + PREFIX[r + 1][c][0] \\n                #how many 2\\'s from up\\n                PREFIX[r + 1][c + 1][1] = count2 + PREFIX[r][c + 1][1]\\n                #how many 5\\'s from left\\n                PREFIX[r + 1][c + 1][2] = count5 + PREFIX[r + 1][c][2]\\n                #how many 5\\'s from up\\n                PREFIX[r + 1][c + 1][3] = count5 + PREFIX[r][c + 1][3]\\n                \\n        def left2(r, c):\\n            return PREFIX[r + 1][c][0]\\n        \\n        def right2(r, c):\\n            return PREFIX[r + 1][C][0] - PREFIX[r + 1][c + 1][0]\\n        \\n        def up2(r, c):\\n            return PREFIX[r][c + 1][1]\\n        \\n        def down2(r, c):\\n            return PREFIX[R][c + 1][1] - PREFIX[r + 1][c + 1][1]\\n        \\n        def left5(r, c):\\n            return PREFIX[r + 1][c][2]\\n        \\n        def right5(r, c):\\n            return PREFIX[r + 1][C][2] - PREFIX[r + 1][c + 1][2]\\n        \\n        def up5(r, c):\\n            return PREFIX[r][c + 1][3]\\n        \\n        def down5(r, c):\\n            return PREFIX[R][c + 1][3] - PREFIX[r + 1][c + 1][3]\\n        \\n        ans = 0\\n        for r in range(R):\\n            for c in range(C):\\n                x = grid[r][c]\\n                \\n                #case1\\n                count2, count5 = count(x, 2), count(x, 5)\\n                count2 += left2(r, c) + right2(r, c)\\n                count5 += left5(r, c) + right5(r, c)\\n                ans1 = min(count2, count5)\\n                \\n                #case2\\n                count2, count5 = count(x, 2), count(x, 5)\\n                count2 += up2(r, c) + down2(r, c)\\n                count5 += up5(r, c) + down5(r, c)\\n                ans2 = min(count2, count5)\\n                \\n                #case 3\\n                count2, count5 = count(x, 2), count(x, 5)\\n                count2 += left2(r, c) + up2(r, c)\\n                count5 += left5(r, c) + up5(r, c)\\n                ans3 = min(count2, count5)\\n\\n                #case 4\\n                count2, count5 = count(x, 2), count(x, 5)\\n                count2 += right2(r, c) + up2(r, c)\\n                count5 += right5(r, c) + up5(r, c)\\n                ans4 = min(count2, count5)\\n                \\n                #case 5\\n                count2, count5 = count(x, 2), count(x, 5)\\n                count2 += left2(r, c) + down2(r, c)\\n                count5 += left5(r, c) + down5(r, c)\\n                ans5 = min(count2, count5)\\n                \\n                #case 6\\n                count2, count5 = count(x, 2), count(x, 5)\\n                count2 += right2(r, c) + down2(r, c)\\n                count5 += right5(r, c) + down5(r, c)\\n                ans6 = min(count2, count5)\\n            \\n                ans = max(ans, ans1, ans2, ans3, ans4, ans5, ans6)\\n                        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        @cache\\n        def count(x, k):\\n            ans = 0\\n            while x % k == 0:\\n                x = x // k\\n                ans += 1\\n            return ans\\n                \\n        R, C = len(grid), len(grid[0])\\n        PREFIX = [[[0, 0, 0, 0] for _ in range(C + 1)] for _ in range(R + 1)]\\n        for r in range(R):\\n            for c in range(C):\\n                #current counts\\n                count2 = count(grid[r][c], 2)\\n                count5 = count(grid[r][c], 5)  \\n                #how many 2\\'s from left\\n                PREFIX[r + 1][c + 1][0] = count2 + PREFIX[r + 1][c][0] \\n                #how many 2\\'s from up\\n                PREFIX[r + 1][c + 1][1] = count2 + PREFIX[r][c + 1][1]\\n                #how many 5\\'s from left\\n                PREFIX[r + 1][c + 1][2] = count5 + PREFIX[r + 1][c][2]\\n                #how many 5\\'s from up\\n                PREFIX[r + 1][c + 1][3] = count5 + PREFIX[r][c + 1][3]\\n                \\n        def left2(r, c):\\n            return PREFIX[r + 1][c][0]\\n        \\n        def right2(r, c):\\n            return PREFIX[r + 1][C][0] - PREFIX[r + 1][c + 1][0]\\n        \\n        def up2(r, c):\\n            return PREFIX[r][c + 1][1]\\n        \\n        def down2(r, c):\\n            return PREFIX[R][c + 1][1] - PREFIX[r + 1][c + 1][1]\\n        \\n        def left5(r, c):\\n            return PREFIX[r + 1][c][2]\\n        \\n        def right5(r, c):\\n            return PREFIX[r + 1][C][2] - PREFIX[r + 1][c + 1][2]\\n        \\n        def up5(r, c):\\n            return PREFIX[r][c + 1][3]\\n        \\n        def down5(r, c):\\n            return PREFIX[R][c + 1][3] - PREFIX[r + 1][c + 1][3]\\n        \\n        ans = 0\\n        for r in range(R):\\n            for c in range(C):\\n                x = grid[r][c]\\n                \\n                #case1\\n                count2, count5 = count(x, 2), count(x, 5)\\n                count2 += left2(r, c) + right2(r, c)\\n                count5 += left5(r, c) + right5(r, c)\\n                ans1 = min(count2, count5)\\n                \\n                #case2\\n                count2, count5 = count(x, 2), count(x, 5)\\n                count2 += up2(r, c) + down2(r, c)\\n                count5 += up5(r, c) + down5(r, c)\\n                ans2 = min(count2, count5)\\n                \\n                #case 3\\n                count2, count5 = count(x, 2), count(x, 5)\\n                count2 += left2(r, c) + up2(r, c)\\n                count5 += left5(r, c) + up5(r, c)\\n                ans3 = min(count2, count5)\\n\\n                #case 4\\n                count2, count5 = count(x, 2), count(x, 5)\\n                count2 += right2(r, c) + up2(r, c)\\n                count5 += right5(r, c) + up5(r, c)\\n                ans4 = min(count2, count5)\\n                \\n                #case 5\\n                count2, count5 = count(x, 2), count(x, 5)\\n                count2 += left2(r, c) + down2(r, c)\\n                count5 += left5(r, c) + down5(r, c)\\n                ans5 = min(count2, count5)\\n                \\n                #case 6\\n                count2, count5 = count(x, 2), count(x, 5)\\n                count2 += right2(r, c) + down2(r, c)\\n                count5 += right5(r, c) + down5(r, c)\\n                ans6 = min(count2, count5)\\n            \\n                ans = max(ans, ans1, ans2, ans3, ans4, ans5, ans6)\\n                        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956461,
                "title": "java-prefix-suffix-solution",
                "content": "```\\nclass Solution \\n{\\n    //Hell of an implementation\\n    public int maxTrailingZeros(int[][] grid) \\n    {\\n        int n = grid.length; int m = grid[0].length;\\n        Pair[][] arr = new Pair[n][m];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int[] res = find(grid[i][j]);\\n                arr[i][j] = new Pair(res[0], res[1]);\\n            }\\n        }\\n        \\n        Pair[][] pre = new Pair[n][m];\\n        Pair[][] suff = new Pair[n][m];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(j == 0)\\n                    pre[i][j] = new Pair(arr[i][j].x, arr[i][j].y);\\n                else\\n                {\\n                    int x1 = pre[i][j-1].x + arr[i][j].x;\\n                    int y1 = pre[i][j-1].y + arr[i][j].y;\\n                    pre[i][j] = new Pair(x1, y1);\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                if(j == m-1)\\n                    suff[i][j] = new Pair(arr[i][j].x, arr[i][j].y);\\n                else\\n                {\\n                    int x1 = suff[i][j+1].x + arr[i][j].x;\\n                    int y1 = suff[i][j+1].y + arr[i][j].y;\\n                    suff[i][j] = new Pair(x1, y1);\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        int c2 = 0, c5 = 0;\\n        for(int j=0;j<m;j++)\\n        {\\n            c2 = 0; c5 = 0;\\n            for(int i=0;i<n;i++)\\n            {\\n                res = Math.max(res, Math.min(c2+pre[i][j].x, c5+pre[i][j].y));\\n                res = Math.max(res, Math.min(c2+suff[i][j].x, c5+suff[i][j].y));\\n                c2 += arr[i][j].x;\\n                c5 += arr[i][j].y;\\n            }\\n        }\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            c2 = 0; c5 = 0;\\n            for(int i=n-1;i>=0;i--)\\n            {\\n                res = Math.max(res, Math.min(c2+pre[i][j].x, c5+pre[i][j].y));\\n                res = Math.max(res, Math.min(c2+suff[i][j].x, c5+suff[i][j].y));\\n                c2 += arr[i][j].x;\\n                c5 += arr[i][j].y;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int[] find(int n)\\n    {\\n        int twos = 0, fives = 0;\\n        while(n%2 == 0)\\n        {\\n            twos++;\\n            n/=2;\\n        }\\n        while(n%5 == 0)\\n        {\\n            fives++;\\n            n/=5;\\n        }\\n        return new int[]{twos, fives};\\n    }\\n    \\n    class Pair\\n    {\\n        int x, y;\\n        Pair(int x, int y)\\n        {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution \\n{\\n    //Hell of an implementation\\n    public int maxTrailingZeros(int[][] grid) \\n    {\\n        int n = grid.length; int m = grid[0].length;\\n        Pair[][] arr = new Pair[n][m];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int[] res = find(grid[i][j]);\\n                arr[i][j] = new Pair(res[0], res[1]);\\n            }\\n        }\\n        \\n        Pair[][] pre = new Pair[n][m];\\n        Pair[][] suff = new Pair[n][m];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(j == 0)\\n                    pre[i][j] = new Pair(arr[i][j].x, arr[i][j].y);\\n                else\\n                {\\n                    int x1 = pre[i][j-1].x + arr[i][j].x;\\n                    int y1 = pre[i][j-1].y + arr[i][j].y;\\n                    pre[i][j] = new Pair(x1, y1);\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                if(j == m-1)\\n                    suff[i][j] = new Pair(arr[i][j].x, arr[i][j].y);\\n                else\\n                {\\n                    int x1 = suff[i][j+1].x + arr[i][j].x;\\n                    int y1 = suff[i][j+1].y + arr[i][j].y;\\n                    suff[i][j] = new Pair(x1, y1);\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        int c2 = 0, c5 = 0;\\n        for(int j=0;j<m;j++)\\n        {\\n            c2 = 0; c5 = 0;\\n            for(int i=0;i<n;i++)\\n            {\\n                res = Math.max(res, Math.min(c2+pre[i][j].x, c5+pre[i][j].y));\\n                res = Math.max(res, Math.min(c2+suff[i][j].x, c5+suff[i][j].y));\\n                c2 += arr[i][j].x;\\n                c5 += arr[i][j].y;\\n            }\\n        }\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            c2 = 0; c5 = 0;\\n            for(int i=n-1;i>=0;i--)\\n            {\\n                res = Math.max(res, Math.min(c2+pre[i][j].x, c5+pre[i][j].y));\\n                res = Math.max(res, Math.min(c2+suff[i][j].x, c5+suff[i][j].y));\\n                c2 += arr[i][j].x;\\n                c5 += arr[i][j].y;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int[] find(int n)\\n    {\\n        int twos = 0, fives = 0;\\n        while(n%2 == 0)\\n        {\\n            twos++;\\n            n/=2;\\n        }\\n        while(n%5 == 0)\\n        {\\n            fives++;\\n            n/=5;\\n        }\\n        return new int[]{twos, fives};\\n    }\\n    \\n    class Pair\\n    {\\n        int x, y;\\n        Pair(int x, int y)\\n        {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956401,
                "title": "22-lines-python3-solution",
                "content": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        def check(grid, row_order=1, col_order=1):\\n            above = [[0, 0] for i in range(len(grid[0]))]\\n            ans = 0\\n            for row in grid[::row_order]:\\n                this_row = [0, 0]\\n                for i, v in enumerate(row[::col_order]):\\n                    c2 = c5 = 0\\n                    while v % 2 == 0:\\n                        c2 += 1\\n                        v /= 2\\n                    while v % 5 == 0:\\n                        c5 += 1\\n                        v /= 5\\n                    this_row[0] += c2\\n                    this_row[1] += c5\\n                    ans = max(ans, min(this_row[0] + above[i][0], this_row[1] + above[i][1]))\\n                    above[i][0] += c2\\n                    above[i][1] += c5\\n            return ans\\n        return max(check(grid, ro, co) for ro in [-1, 1] for co in [-1, 1])\\n        \\n        \\n        \\n        \\n        \\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        def check(grid, row_order=1, col_order=1):\\n            above = [[0, 0] for i in range(len(grid[0]))]\\n            ans = 0\\n            for row in grid[::row_order]:\\n                this_row = [0, 0]\\n                for i, v in enumerate(row[::col_order]):\\n                    c2 = c5 = 0\\n                    while v % 2 == 0:\\n                        c2 += 1\\n                        v /= 2\\n                    while v % 5 == 0:\\n                        c5 += 1\\n                        v /= 5\\n                    this_row[0] += c2\\n                    this_row[1] += c5\\n                    ans = max(ans, min(this_row[0] + above[i][0], this_row[1] + above[i][1]))\\n                    above[i][0] += c2\\n                    above[i][1] += c5\\n            return ans\\n        return max(check(grid, ro, co) for ro in [-1, 1] for co in [-1, 1])\\n        \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956383,
                "title": "c-4-direction-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        const int m = grid.size(), n = grid[0].size();\\n        \\n        // horizontal_prefix_fives[i][j]: number of the factor 5 for grid[i][0...j].\\n        // horizontal_suffix_fives[i][j]: number of the factor 5 for grid[i][j...n-1].\\n        vector<vector<int>> horizontal_prefix_fives(m, vector<int>(n, 0)), horizontal_suffix_fives(m, vector<int>(n, 0));\\n        // horizontal_prefix_twos[i][j]: number of the factor 2 for grid[i][0...j].\\n        // horizontal_suffix_twos[i][j]: number of the factor 2 for grid[i][j...n-1].\\n        vector<vector<int>> horizontal_prefix_twos(m, vector<int>(n, 0)), horizontal_suffix_twos(m, vector<int>(n, 0));    \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                horizontal_prefix_fives[i][j] = (j > 0 ? horizontal_prefix_fives[i][j - 1] : 0) + GetFactorNum(grid[i][j], 5);\\n                horizontal_prefix_twos[i][j] = (j > 0 ? horizontal_prefix_twos[i][j - 1] : 0) + GetFactorNum(grid[i][j], 2);\\n            }\\n            for (int j = n - 1; j >= 0; --j) {\\n                horizontal_suffix_fives[i][j] = (j < n - 1 ? horizontal_suffix_fives[i][j + 1] : 0) + GetFactorNum(grid[i][j], 5);\\n                horizontal_suffix_twos[i][j] = (j < n - 1 ? horizontal_suffix_twos[i][j + 1] : 0) + GetFactorNum(grid[i][j], 2);\\n            }\\n        }\\n        int max_val = 0;\\n        // vertical_prefix_fives[j]: number of the factor 5 for grid[0...i][j].\\n        // vertical_prefix_twos: number of the factor 2 for grid[0...i][j].\\n        vector<int> vertical_prefix_fives(n), vertical_prefix_twos(n);\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                max_val = std::max(max_val, \\n                                   std::max(std::min(horizontal_prefix_fives[i][j] + vertical_prefix_fives[j], horizontal_prefix_twos[i][j] + vertical_prefix_twos[j]), \\n                                            std::min(horizontal_suffix_fives[i][j] + vertical_prefix_fives[j],  horizontal_suffix_twos[i][j] + vertical_prefix_twos[j])));\\n                vertical_prefix_fives[j] += GetFactorNum(grid[i][j], 5);\\n                vertical_prefix_twos[j] += GetFactorNum(grid[i][j], 2);\\n            }\\n        }\\n        \\n        vector<int> veritical_suffix_fives(n), vertical_suffix_twos(n);\\n        for (int i = m - 1; i >= 0; --i) {\\n            for (int j = 0; j < n; ++j) {\\n                max_val = std::max(max_val,\\n                                   std::max(std::min(horizontal_prefix_fives[i][j] + veritical_suffix_fives[j], horizontal_prefix_twos[i][j] + vertical_suffix_twos[j]),\\n                                            std::min(horizontal_suffix_fives[i][j] + veritical_suffix_fives[j],  horizontal_suffix_twos[i][j] + vertical_suffix_twos[j])));\\n                veritical_suffix_fives[j] += GetFactorNum(grid[i][j], 5);\\n                vertical_suffix_twos[j] += GetFactorNum(grid[i][j], 2);\\n            }\\n        }   \\n    \\n        return max_val;\\n    }\\n    \\nprivate:\\n    int GetFactorNum(int val, int factor) {\\n        int count = 0;\\n        while (val > 0 && val % factor == 0) {\\n            val /= factor;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        const int m = grid.size(), n = grid[0].size();\\n        \\n        // horizontal_prefix_fives[i][j]: number of the factor 5 for grid[i][0...j].\\n        // horizontal_suffix_fives[i][j]: number of the factor 5 for grid[i][j...n-1].\\n        vector<vector<int>> horizontal_prefix_fives(m, vector<int>(n, 0)), horizontal_suffix_fives(m, vector<int>(n, 0));\\n        // horizontal_prefix_twos[i][j]: number of the factor 2 for grid[i][0...j].\\n        // horizontal_suffix_twos[i][j]: number of the factor 2 for grid[i][j...n-1].\\n        vector<vector<int>> horizontal_prefix_twos(m, vector<int>(n, 0)), horizontal_suffix_twos(m, vector<int>(n, 0));    \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                horizontal_prefix_fives[i][j] = (j > 0 ? horizontal_prefix_fives[i][j - 1] : 0) + GetFactorNum(grid[i][j], 5);\\n                horizontal_prefix_twos[i][j] = (j > 0 ? horizontal_prefix_twos[i][j - 1] : 0) + GetFactorNum(grid[i][j], 2);\\n            }\\n            for (int j = n - 1; j >= 0; --j) {\\n                horizontal_suffix_fives[i][j] = (j < n - 1 ? horizontal_suffix_fives[i][j + 1] : 0) + GetFactorNum(grid[i][j], 5);\\n                horizontal_suffix_twos[i][j] = (j < n - 1 ? horizontal_suffix_twos[i][j + 1] : 0) + GetFactorNum(grid[i][j], 2);\\n            }\\n        }\\n        int max_val = 0;\\n        // vertical_prefix_fives[j]: number of the factor 5 for grid[0...i][j].\\n        // vertical_prefix_twos: number of the factor 2 for grid[0...i][j].\\n        vector<int> vertical_prefix_fives(n), vertical_prefix_twos(n);\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                max_val = std::max(max_val, \\n                                   std::max(std::min(horizontal_prefix_fives[i][j] + vertical_prefix_fives[j], horizontal_prefix_twos[i][j] + vertical_prefix_twos[j]), \\n                                            std::min(horizontal_suffix_fives[i][j] + vertical_prefix_fives[j],  horizontal_suffix_twos[i][j] + vertical_prefix_twos[j])));\\n                vertical_prefix_fives[j] += GetFactorNum(grid[i][j], 5);\\n                vertical_prefix_twos[j] += GetFactorNum(grid[i][j], 2);\\n            }\\n        }\\n        \\n        vector<int> veritical_suffix_fives(n), vertical_suffix_twos(n);\\n        for (int i = m - 1; i >= 0; --i) {\\n            for (int j = 0; j < n; ++j) {\\n                max_val = std::max(max_val,\\n                                   std::max(std::min(horizontal_prefix_fives[i][j] + veritical_suffix_fives[j], horizontal_prefix_twos[i][j] + vertical_suffix_twos[j]),\\n                                            std::min(horizontal_suffix_fives[i][j] + veritical_suffix_fives[j],  horizontal_suffix_twos[i][j] + vertical_suffix_twos[j])));\\n                veritical_suffix_fives[j] += GetFactorNum(grid[i][j], 5);\\n                vertical_suffix_twos[j] += GetFactorNum(grid[i][j], 2);\\n            }\\n        }   \\n    \\n        return max_val;\\n    }\\n    \\nprivate:\\n    int GetFactorNum(int val, int factor) {\\n        int count = 0;\\n        while (val > 0 && val % factor == 0) {\\n            val /= factor;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956369,
                "title": "prefix-and-suffix-sum-of-multiple-of-2-and-5-c",
                "content": "```\\nint maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<pair<int,int>>>p(n,vector<pair<int,int>>(m));\\n        vector<vector<pair<int,int>>>s(n,vector<pair<int,int>>(m));\\n        for(int i=0; i<n; i++)\\n        {\\n            int t=0,f=0;\\n            for(int j=0; j<m; j++)\\n            {\\n                int val = grid[i][j];\\n                while(val%2==0)\\n                {\\n                    t++;\\n                    val/=2;\\n                }\\n                while(val%5==0)\\n                {\\n                    f++;\\n                    val/=5;\\n                }\\n                p[i][j] = {t,f};\\n            }\\n            t=0,f=0;\\n            for(int j=m-1; j>=0; j--)\\n            {\\n                int val = grid[i][j];\\n                while(val%2==0)\\n                {\\n                    t++;\\n                    val/=2;\\n                }\\n                while(val%5==0)\\n                {\\n                    f++;\\n                    val/=5;\\n                }\\n                s[i][j] = {t,f};\\n            }\\n        }\\n        int ans = INT_MIN;\\n        for(int j=0; j<m; j++)\\n        {\\n            int f=0,t=0;\\n            for(int i=0; i<n; i++)\\n            {\\n                int val = grid[i][j];\\n                while(val%2==0)\\n                {\\n                    t++;\\n                    val/=2;\\n                }\\n                while(val%5==0)\\n                {\\n                    f++;\\n                    val/=5;\\n                }\\n                if(j)\\n                ans = max(ans,min(t+p[i][j-1].first,f+p[i][j-1].second));\\n                else\\n                ans = max(ans,min(t,f));\\n                if(j!=m-1)\\n                ans = max(ans,min(t+s[i][j+1].first,f+s[i][j+1].second));\\n                else\\n                ans = max(ans,min(t,f));\\n            }\\n        }\\n        for(int j=m-1; j>=0; j--)\\n        {\\n            int f=0,t=0;\\n            for(int i=n-1; i>=0; i--)\\n            {\\n                int val = grid[i][j];\\n                while(val%2==0)\\n                {\\n                    t++;\\n                    val/=2;\\n                }\\n                while(val%5==0)\\n                {\\n                    f++;\\n                    val/=5;\\n                }\\n                if(j)\\n                ans = max(ans,min(t+p[i][j-1].first,f+p[i][j-1].second));\\n                else\\n                ans = max(ans,min(t,f));\\n                if(j!=m-1)\\n                ans = max(ans,min(t+s[i][j+1].first,f+s[i][j+1].second));\\n                else\\n                ans = max(ans,min(t,f));\\n            }\\n        }\\n        return ans;\\n        \\n        return 0;\\n    }",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nint maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<pair<int,int>>>p(n,vector<pair<int,int>>(m));\\n        vector<vector<pair<int,int>>>s(n,vector<pair<int,int>>(m));\\n        for(int i=0; i<n; i++)\\n        {\\n            int t=0,f=0;\\n            for(int j=0; j<m; j++)\\n            {\\n                int val = grid[i][j];\\n                while(val%2==0)\\n                {\\n                    t++;\\n                    val/=2;\\n                }\\n                while(val%5==0)\\n                {\\n                    f++;\\n                    val/=5;\\n                }\\n                p[i][j] = {t,f};\\n            }\\n            t=0,f=0;\\n            for(int j=m-1; j>=0; j--)\\n            {\\n                int val = grid[i][j];\\n                while(val%2==0)\\n                {\\n                    t++;\\n                    val/=2;\\n                }\\n                while(val%5==0)\\n                {\\n                    f++;\\n                    val/=5;\\n                }\\n                s[i][j] = {t,f};\\n            }\\n        }\\n        int ans = INT_MIN;\\n        for(int j=0; j<m; j++)\\n        {\\n            int f=0,t=0;\\n            for(int i=0; i<n; i++)\\n            {\\n                int val = grid[i][j];\\n                while(val%2==0)\\n                {\\n                    t++;\\n                    val/=2;\\n                }\\n                while(val%5==0)\\n                {\\n                    f++;\\n                    val/=5;\\n                }\\n                if(j)\\n                ans = max(ans,min(t+p[i][j-1].first,f+p[i][j-1].second));\\n                else\\n                ans = max(ans,min(t,f));\\n                if(j!=m-1)\\n                ans = max(ans,min(t+s[i][j+1].first,f+s[i][j+1].second));\\n                else\\n                ans = max(ans,min(t,f));\\n            }\\n        }\\n        for(int j=m-1; j>=0; j--)\\n        {\\n            int f=0,t=0;\\n            for(int i=n-1; i>=0; i--)\\n            {\\n                int val = grid[i][j];\\n                while(val%2==0)\\n                {\\n                    t++;\\n                    val/=2;\\n                }\\n                while(val%5==0)\\n                {\\n                    f++;\\n                    val/=5;\\n                }\\n                if(j)\\n                ans = max(ans,min(t+p[i][j-1].first,f+p[i][j-1].second));\\n                else\\n                ans = max(ans,min(t,f));\\n                if(j!=m-1)\\n                ans = max(ans,min(t+s[i][j+1].first,f+s[i][j+1].second));\\n                else\\n                ans = max(ans,min(t,f));\\n            }\\n        }\\n        return ans;\\n        \\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1956253,
                "title": "prefix-sum-of-noof2s-and-noof5s-c-long-implementation-100-time-100-space",
                "content": "![image](https://assets.leetcode.com/users/images/291ab2e1-dcf6-4d3a-a203-3b2bd17561a1_1650178050.3047764.png)\\n\\n#### 1) `Count the noof 2\\'s and 5\\'s in each element of grid.`\\n#### 2) `Now maintain 4 matrices to calculate prefix sum of noof2\\'s and noof5\\'s.`\\n#### 3) `4 matrices are top2,down2,right2 and left2`\\n#### 4) `Now iterate through the Grid and get max of all possible paths like top-right,top-left,top-down..... for each possibility we need to find min(noof2\\'s, noof5\\'s);`\\n#### 5) `Now just store the max of all possible corner points... that is our ans.`\\n\\n#### *I have completed implementation of this just 7 min before the contest\\'s deadline \\uD83D\\uDE01*.\\n#### *And this is my first solution which beat 100% in both time and space complexity*.\\n\\n```\\nclass Solution {\\npublic:\\n    int ans;\\n    pair<int,int> trailZeros(int N){\\n        int count = 0;\\n        int twos = 0;\\n        int fives = 0;\\n        for (int i = 0; i < 1; i++){\\n          while(N%2==0 || N%5==0){\\n             if(N%2==0){\\n                N=N/2;\\n                twos++;\\n             }\\n             if(N%5==0){\\n                N=N/5;\\n                fives++;\\n             }\\n          }\\n       }\\n       // count=twos<fives?twos:fives;\\n       return {twos,fives};\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        ans=0;\\n        vector<vector<pair<int,int>>> Grid(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                Grid[i][j]=trailZeros(grid[i][j]);\\n            }\\n        }\\n        \\n        vector<vector<pair<int,int>>>top2(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n        vector<vector<pair<int,int>>>down2(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n        vector<vector<pair<int,int>>>left2(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n        vector<vector<pair<int,int>>>right2(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n        for(int i=0;i<grid.size();i++){\\n            pair<int,int> temp={0,0};\\n            for(int j=0;j<grid[0].size();j++){\\n                left2[i][j]=temp;\\n                temp.first+=Grid[i][j].first;\\n                temp.second+=Grid[i][j].second;\\n            }\\n        }\\n        for(int i=0;i<grid.size();i++){\\n            pair<int,int> temp={0,0};\\n            for(int j=grid[0].size()-1;j>=0;j--){\\n                right2[i][j]=temp;\\n                temp.first+=Grid[i][j].first;\\n                temp.second+=Grid[i][j].second;\\n            }\\n        }\\n        for(int j=0;j<grid[0].size();j++){\\n            pair<int,int> temp={0,0};\\n            for(int i=0;i<grid.size();i++){\\n                \\n                temp.first+=Grid[i][j].first;\\n                temp.second+=Grid[i][j].second;\\n                top2[i][j]=temp;\\n            }\\n        }\\n        \\n        for(int j=0;j<grid[0].size();j++){\\n            pair<int,int> temp={0,0};\\n            for(int i=grid.size()-1;i>=0;i--){\\n                down2[i][j]=temp;\\n                temp.first+=Grid[i][j].first;\\n                temp.second+=Grid[i][j].second;             \\n            }\\n        }\\n        \\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                pair<int,int> top;\\n                pair<int,int> left;\\n                pair<int,int> down;\\n                pair<int,int> right;\\n                int curr2=0;\\n                int curr5=0;\\n                \\n                curr2=top2[i][j].first;\\n                curr5=top2[i][j].second;\\n                top.first=curr2;\\n                top.second=curr5;\\n                curr2=0;\\n                curr5=0;\\n                \\n                curr2=down2[i][j].first;\\n                curr5=down2[i][j].second;\\n                down.first=curr2;\\n                down.second=curr5;\\n                curr2=0;\\n                curr5=0;\\n                \\n                curr2=left2[i][j].first;\\n                curr5=left2[i][j].second;\\n                left.first=curr2;\\n                left.second=curr5;\\n                curr2=0;\\n                curr5=0;\\n                \\n                curr2=right2[i][j].first;\\n                curr5=right2[i][j].second;\\n                right.first=curr2;\\n                right.second=curr5;\\n                \\n                ans=max(ans,max({min(top.first+down.first,top.second+down.second),min(top.first+right.first,top.second+right.second),min(top.first+left.first,top.second+left.second),min(left.first+right.first+Grid[i][j].first,left.second+right.second+Grid[i][j].second),min(left.first+down.first+Grid[i][j].first,left.second+down.second+Grid[i][j].second),min(down.first+right.first+Grid[i][j].first,down.second+right.second+Grid[i][j].second)}));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    pair<int,int> trailZeros(int N){\\n        int count = 0;\\n        int twos = 0;\\n        int fives = 0;\\n        for (int i = 0; i < 1; i++){\\n          while(N%2==0 || N%5==0){\\n             if(N%2==0){\\n                N=N/2;\\n                twos++;\\n             }\\n             if(N%5==0){\\n                N=N/5;\\n                fives++;\\n             }\\n          }\\n       }\\n       // count=twos<fives?twos:fives;\\n       return {twos,fives};\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        ans=0;\\n        vector<vector<pair<int,int>>> Grid(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                Grid[i][j]=trailZeros(grid[i][j]);\\n            }\\n        }\\n        \\n        vector<vector<pair<int,int>>>top2(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n        vector<vector<pair<int,int>>>down2(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n        vector<vector<pair<int,int>>>left2(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n        vector<vector<pair<int,int>>>right2(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n        for(int i=0;i<grid.size();i++){\\n            pair<int,int> temp={0,0};\\n            for(int j=0;j<grid[0].size();j++){\\n                left2[i][j]=temp;\\n                temp.first+=Grid[i][j].first;\\n                temp.second+=Grid[i][j].second;\\n            }\\n        }\\n        for(int i=0;i<grid.size();i++){\\n            pair<int,int> temp={0,0};\\n            for(int j=grid[0].size()-1;j>=0;j--){\\n                right2[i][j]=temp;\\n                temp.first+=Grid[i][j].first;\\n                temp.second+=Grid[i][j].second;\\n            }\\n        }\\n        for(int j=0;j<grid[0].size();j++){\\n            pair<int,int> temp={0,0};\\n            for(int i=0;i<grid.size();i++){\\n                \\n                temp.first+=Grid[i][j].first;\\n                temp.second+=Grid[i][j].second;\\n                top2[i][j]=temp;\\n            }\\n        }\\n        \\n        for(int j=0;j<grid[0].size();j++){\\n            pair<int,int> temp={0,0};\\n            for(int i=grid.size()-1;i>=0;i--){\\n                down2[i][j]=temp;\\n                temp.first+=Grid[i][j].first;\\n                temp.second+=Grid[i][j].second;             \\n            }\\n        }\\n        \\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                pair<int,int> top;\\n                pair<int,int> left;\\n                pair<int,int> down;\\n                pair<int,int> right;\\n                int curr2=0;\\n                int curr5=0;\\n                \\n                curr2=top2[i][j].first;\\n                curr5=top2[i][j].second;\\n                top.first=curr2;\\n                top.second=curr5;\\n                curr2=0;\\n                curr5=0;\\n                \\n                curr2=down2[i][j].first;\\n                curr5=down2[i][j].second;\\n                down.first=curr2;\\n                down.second=curr5;\\n                curr2=0;\\n                curr5=0;\\n                \\n                curr2=left2[i][j].first;\\n                curr5=left2[i][j].second;\\n                left.first=curr2;\\n                left.second=curr5;\\n                curr2=0;\\n                curr5=0;\\n                \\n                curr2=right2[i][j].first;\\n                curr5=right2[i][j].second;\\n                right.first=curr2;\\n                right.second=curr5;\\n                \\n                ans=max(ans,max({min(top.first+down.first,top.second+down.second),min(top.first+right.first,top.second+right.second),min(top.first+left.first,top.second+left.second),min(left.first+right.first+Grid[i][j].first,left.second+right.second+Grid[i][j].second),min(left.first+down.first+Grid[i][j].first,left.second+down.second+Grid[i][j].second),min(down.first+right.first+Grid[i][j].first,down.second+right.second+Grid[i][j].second)}));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956246,
                "title": "c-ac-solution-2d-perfix-sum",
                "content": "count factor 2 and 5 for each, ignore other factor\\ncalculate perfix sum in H and V\\n\\ntraverse answer in 2D matrix, try 4 directions top left, top right, bottom left, bottom right\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int p(int num,int k) {\\n        int ret = 0;\\n        \\n        while(num % k == 0) {\\n            num /=k;\\n            ret++;\\n        }\\n        \\n        return ret;\\n    }\\n\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = size(grid);\\n        int n = size(grid[0]);\\n\\n        int p2[m][n];\\n        int p5[m][n];\\n        int h2[m+1][n+1];\\n        int h5[m+1][n+1];\\n        int v2[m+1][n+1];\\n        int v5[m+1][n+1];\\n        \\n        h2[0][0] = 0;\\n        h5[0][0] = 0;\\n        v2[0][0] = 0;\\n        v5[0][0] = 0;\\n\\n        for (int i=0; i<m; i++) {\\n            int sum2 = 0;\\n            int sum5 = 0;\\n            h2[i+1][0] = 0;\\n            h5[i+1][0] = 0;\\n            v2[i+1][0] = 0;\\n            v5[i+1][0] = 0;\\n            for (int j=0; j<n; j++) {\\n                p2[i][j] =  p(grid[i][j], 2);\\n                p5[i][j] =  p(grid[i][j], 5);\\n                sum2 += p2[i][j];\\n                sum5 += p5[i][j];\\n                h2[i+1][j+1] = sum2;\\n                h5[i+1][j+1] = sum5;\\n            }\\n        }\\n\\n        for (int j=0; j<n; j++) {\\n            int sum2 = 0;\\n            int sum5 = 0;\\n            h2[0][j+1] = 0;\\n            h5[0][j+1] = 0;\\n            v2[0][j+1] = 0;\\n            v5[0][j+1] = 0;\\n            for (int i=0; i<m; i++) {\\n                sum2 += p2[i][j];\\n                sum5 += p5[i][j];\\n                v2[i+1][j+1] = sum2;\\n                v5[i+1][j+1] = sum5;\\n            }\\n        }\\n\\n        /*\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                cout << p2[i][j] <<\" \";\\n            }\\n            cout << \"\\\\n\";\\n        }\\n        cout << \"\\\\n\";\\n\\n        for (int i=0; i<=m; i++) {\\n            for (int j=0; j<=n; j++) {\\n                cout << h2[i][j] <<\" \";\\n            }\\n            cout << \"\\\\n\";\\n        }\\n        cout << \"\\\\n\";\\n\\n        for (int i=0; i<=m; i++) {\\n            for (int j=0; j<=n; j++) {\\n                cout << v2[i][j] <<\" \";\\n            }\\n            cout << \"\\\\n\";\\n        }\\n        cout << \"\\\\n\";\\n        */\\n        \\n        int ret = 0;\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                ret = max(ret, min(p2[i][j] + h2[i+1][j]                + v2[i][j+1]               , \\n                                   p5[i][j] + h5[i+1][j]                + v5[i][j+1]               ) );\\n                ret = max(ret, min(p2[i][j] + h2[i+1][n] - h2[i+1][j+1] + v2[i][j+1]               , \\n                                   p5[i][j] + h5[i+1][n] - h5[i+1][j+1] + v5[i][j+1]               ) );\\n                ret = max(ret, min(p2[i][j] + h2[i+1][j]                + v2[m][j+1] - v2[i+1][j+1], \\n                                   p5[i][j] + h5[i+1][j]                + v5[m][j+1] - v5[i+1][j+1]) );\\n                ret = max(ret, min(p2[i][j] + h2[i+1][n] - h2[i+1][j+1] + v2[m][j+1] - v2[i+1][j+1], \\n                                   p5[i][j] + h5[i+1][n] - h5[i+1][j+1] + v5[m][j+1] - v5[i+1][j+1]) );\\n            }\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int p(int num,int k) {\\n        int ret = 0;\\n        \\n        while(num % k == 0) {\\n            num /=k;\\n            ret++;\\n        }\\n        \\n        return ret;\\n    }\\n\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = size(grid);\\n        int n = size(grid[0]);\\n\\n        int p2[m][n];\\n        int p5[m][n];\\n        int h2[m+1][n+1];\\n        int h5[m+1][n+1];\\n        int v2[m+1][n+1];\\n        int v5[m+1][n+1];\\n        \\n        h2[0][0] = 0;\\n        h5[0][0] = 0;\\n        v2[0][0] = 0;\\n        v5[0][0] = 0;\\n\\n        for (int i=0; i<m; i++) {\\n            int sum2 = 0;\\n            int sum5 = 0;\\n            h2[i+1][0] = 0;\\n            h5[i+1][0] = 0;\\n            v2[i+1][0] = 0;\\n            v5[i+1][0] = 0;\\n            for (int j=0; j<n; j++) {\\n                p2[i][j] =  p(grid[i][j], 2);\\n                p5[i][j] =  p(grid[i][j], 5);\\n                sum2 += p2[i][j];\\n                sum5 += p5[i][j];\\n                h2[i+1][j+1] = sum2;\\n                h5[i+1][j+1] = sum5;\\n            }\\n        }\\n\\n        for (int j=0; j<n; j++) {\\n            int sum2 = 0;\\n            int sum5 = 0;\\n            h2[0][j+1] = 0;\\n            h5[0][j+1] = 0;\\n            v2[0][j+1] = 0;\\n            v5[0][j+1] = 0;\\n            for (int i=0; i<m; i++) {\\n                sum2 += p2[i][j];\\n                sum5 += p5[i][j];\\n                v2[i+1][j+1] = sum2;\\n                v5[i+1][j+1] = sum5;\\n            }\\n        }\\n\\n        /*\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                cout << p2[i][j] <<\" \";\\n            }\\n            cout << \"\\\\n\";\\n        }\\n        cout << \"\\\\n\";\\n\\n        for (int i=0; i<=m; i++) {\\n            for (int j=0; j<=n; j++) {\\n                cout << h2[i][j] <<\" \";\\n            }\\n            cout << \"\\\\n\";\\n        }\\n        cout << \"\\\\n\";\\n\\n        for (int i=0; i<=m; i++) {\\n            for (int j=0; j<=n; j++) {\\n                cout << v2[i][j] <<\" \";\\n            }\\n            cout << \"\\\\n\";\\n        }\\n        cout << \"\\\\n\";\\n        */\\n        \\n        int ret = 0;\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                ret = max(ret, min(p2[i][j] + h2[i+1][j]                + v2[i][j+1]               , \\n                                   p5[i][j] + h5[i+1][j]                + v5[i][j+1]               ) );\\n                ret = max(ret, min(p2[i][j] + h2[i+1][n] - h2[i+1][j+1] + v2[i][j+1]               , \\n                                   p5[i][j] + h5[i+1][n] - h5[i+1][j+1] + v5[i][j+1]               ) );\\n                ret = max(ret, min(p2[i][j] + h2[i+1][j]                + v2[m][j+1] - v2[i+1][j+1], \\n                                   p5[i][j] + h5[i+1][j]                + v5[m][j+1] - v5[i+1][j+1]) );\\n                ret = max(ret, min(p2[i][j] + h2[i+1][n] - h2[i+1][j+1] + v2[m][j+1] - v2[i+1][j+1], \\n                                   p5[i][j] + h5[i+1][n] - h5[i+1][j+1] + v5[m][j+1] - v5[i+1][j+1]) );\\n            }\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1956241,
                "title": "a-straight-forward-implementation-of-factors-2-and-5-and-prefix-sum",
                "content": "1. A good observation: any tailing 0 must come from a factor of 10, which in turn must come from a factor of 2 and a factor of 5.\\n   number of factor of 10 = min(number of factor of 2, number of factor of 5)\\n2. A *cornered path* is literally equal to a *vertical path* and a *horizontal path* jointed at some cell (*i*, *j*).\\n3. This code appears lengthy, but the logic is plain. I deliberatelly put it this way to make it easy to read.\\n\\n```\\nint maxTrailingZeros(vector<vector<int>>& grid) {\\n\\tint m = grid.size();\\n\\tint n = grid[0].size();\\n\\tvector<vector<int>> five(m, vector<int>(n));\\n\\tvector<vector<int>> two(m, vector<int>(n));\\n\\tvector<vector<int>> row_pre_two(m, vector<int>(n + 1));\\n\\tvector<vector<int>> col_pre_two(m + 1, vector<int>(n));\\n\\tvector<vector<int>> row_pre_five(m, vector<int>(n + 1));\\n\\tvector<vector<int>> col_pre_five(m + 1, vector<int>(n));\\n\\t\\n\\t// count the number of factors of 2 and 5.\\n\\tfor (int i = 0; i < m; ++i)\\n\\t\\tfor (int j = 0; j < n; ++j)\\n\\t\\t{\\n\\t\\t\\tint v = grid[i][j];\\n\\t\\t\\t\\n\\t\\t\\twhile (v && v % 5 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t++ five[i][j];\\n\\t\\t\\t\\tv /= 5;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\twhile (v && v % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t++ two[i][j];\\n\\t\\t\\t\\tv /= 2;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\n\\t// calculate prefix-sum in row-base.\\n\\tfor (int i = 0; i < m; ++i)\\n\\t\\tfor (int j = 0; j < n; ++j)\\n\\t\\t{\\n\\t\\t\\trow_pre_five[i][j + 1] = row_pre_five[i][j] + five[i][j];\\n\\t\\t\\trow_pre_two [i][j + 1] = row_pre_two [i][j] + two [i][j];\\n\\t\\t}\\n\\t\\n\\t// calculate prefix-sum in column-base.\\n\\tfor (int j = 0; j < n; ++j)\\n\\t\\tfor (int i = 0; i < m; ++i)\\n\\t\\t{\\n\\t\\t\\tcol_pre_five[i + 1][j] = col_pre_five[i][j] + five[i][j];\\n\\t\\t\\tcol_pre_two [i + 1][j] = col_pre_two [i][j] + two [i][j];\\n\\t\\t}\\n\\t\\n\\tint ret = 0;\\n\\t\\n\\t// for every cell,\\n\\tfor (int i = 0; i < m; ++i)\\n\\t\\tfor (int j = 0; j < n; ++j)\\n\\t\\t{\\n\\t\\t\\t// find how many factor of 5\\'s in n, s, w, e directions.\\n\\t\\t\\tint n_five = col_pre_five[i][j];\\n\\t\\t\\tint s_five = col_pre_five[m][j] - n_five - five[i][j];\\n\\t\\t\\tint w_five = row_pre_five[i][j];\\n\\t\\t\\tint e_five = row_pre_five[i][n] - w_five - five[i][j];\\n\\t\\t\\t\\n\\t\\t\\t// find how many factor of 2\\'s in 4 directions.\\n\\t\\t\\tint n_two = col_pre_two[i][j];\\n\\t\\t\\tint s_two = col_pre_two[m][j] - n_two - two[i][j];\\n\\t\\t\\tint w_two = row_pre_two[i][j];\\n\\t\\t\\tint e_two = row_pre_two[i][n] - w_two - two[i][j];\\n\\t\\t\\t\\n\\t\\t\\t// find how many factor of 10\\'s in any of the 2 allowable directions jointed in the current (i, j).\\n\\t\\t\\tint nw_ten = min(n_five + w_five + five[i][j], n_two + w_two + two[i][j]);\\n\\t\\t\\tint ne_ten = min(n_five + e_five + five[i][j], n_two + e_two + two[i][j]);\\n\\t\\t\\tint sw_ten = min(s_five + w_five + five[i][j], s_two + w_two + two[i][j]);\\n\\t\\t\\tint se_ten = min(s_five + e_five + five[i][j], s_two + e_two + two[i][j]);\\n\\t\\t\\t\\n\\t\\t\\t// update local max\\n\\t\\t\\tint max_ten = max(max(nw_ten, ne_ten), max(sw_ten, se_ten));\\n\\t\\t\\t\\n\\t\\t\\t// update global max\\n\\t\\t\\tret = max(ret, max_ten);\\n\\t\\t}\\n\\t\\n\\treturn ret;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nint maxTrailingZeros(vector<vector<int>>& grid) {\\n\\tint m = grid.size();\\n\\tint n = grid[0].size();\\n\\tvector<vector<int>> five(m, vector<int>(n));\\n\\tvector<vector<int>> two(m, vector<int>(n));\\n\\tvector<vector<int>> row_pre_two(m, vector<int>(n + 1));\\n\\tvector<vector<int>> col_pre_two(m + 1, vector<int>(n));\\n\\tvector<vector<int>> row_pre_five(m, vector<int>(n + 1));\\n\\tvector<vector<int>> col_pre_five(m + 1, vector<int>(n));\\n\\t\\n\\t// count the number of factors of 2 and 5.\\n\\tfor (int i = 0; i < m; ++i)\\n\\t\\tfor (int j = 0; j < n; ++j)\\n\\t\\t{\\n\\t\\t\\tint v = grid[i][j];\\n\\t\\t\\t\\n\\t\\t\\twhile (v && v % 5 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t++ five[i][j];\\n\\t\\t\\t\\tv /= 5;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\twhile (v && v % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t++ two[i][j];\\n\\t\\t\\t\\tv /= 2;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\n\\t// calculate prefix-sum in row-base.\\n\\tfor (int i = 0; i < m; ++i)\\n\\t\\tfor (int j = 0; j < n; ++j)\\n\\t\\t{\\n\\t\\t\\trow_pre_five[i][j + 1] = row_pre_five[i][j] + five[i][j];\\n\\t\\t\\trow_pre_two [i][j + 1] = row_pre_two [i][j] + two [i][j];\\n\\t\\t}\\n\\t\\n\\t// calculate prefix-sum in column-base.\\n\\tfor (int j = 0; j < n; ++j)\\n\\t\\tfor (int i = 0; i < m; ++i)\\n\\t\\t{\\n\\t\\t\\tcol_pre_five[i + 1][j] = col_pre_five[i][j] + five[i][j];\\n\\t\\t\\tcol_pre_two [i + 1][j] = col_pre_two [i][j] + two [i][j];\\n\\t\\t}\\n\\t\\n\\tint ret = 0;\\n\\t\\n\\t// for every cell,\\n\\tfor (int i = 0; i < m; ++i)\\n\\t\\tfor (int j = 0; j < n; ++j)\\n\\t\\t{\\n\\t\\t\\t// find how many factor of 5\\'s in n, s, w, e directions.\\n\\t\\t\\tint n_five = col_pre_five[i][j];\\n\\t\\t\\tint s_five = col_pre_five[m][j] - n_five - five[i][j];\\n\\t\\t\\tint w_five = row_pre_five[i][j];\\n\\t\\t\\tint e_five = row_pre_five[i][n] - w_five - five[i][j];\\n\\t\\t\\t\\n\\t\\t\\t// find how many factor of 2\\'s in 4 directions.\\n\\t\\t\\tint n_two = col_pre_two[i][j];\\n\\t\\t\\tint s_two = col_pre_two[m][j] - n_two - two[i][j];\\n\\t\\t\\tint w_two = row_pre_two[i][j];\\n\\t\\t\\tint e_two = row_pre_two[i][n] - w_two - two[i][j];\\n\\t\\t\\t\\n\\t\\t\\t// find how many factor of 10\\'s in any of the 2 allowable directions jointed in the current (i, j).\\n\\t\\t\\tint nw_ten = min(n_five + w_five + five[i][j], n_two + w_two + two[i][j]);\\n\\t\\t\\tint ne_ten = min(n_five + e_five + five[i][j], n_two + e_two + two[i][j]);\\n\\t\\t\\tint sw_ten = min(s_five + w_five + five[i][j], s_two + w_two + two[i][j]);\\n\\t\\t\\tint se_ten = min(s_five + e_five + five[i][j], s_two + e_two + two[i][j]);\\n\\t\\t\\t\\n\\t\\t\\t// update local max\\n\\t\\t\\tint max_ten = max(max(nw_ten, ne_ten), max(sw_ten, se_ten));\\n\\t\\t\\t\\n\\t\\t\\t// update global max\\n\\t\\t\\tret = max(ret, max_ten);\\n\\t\\t}\\n\\t\\n\\treturn ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1956164,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][][] fromLeft = new int[m + 1][n + 1][2];\\n        int[][][] fromTop = new int[m + 1][n + 1][2];\\n\\n        //prefix sum of 5s and 2s from left\\n        for (int i = 0; i < m; i++) {\\n            int numOf5s = 0;\\n            int numOf2s = 0;\\n            for (int j = 0; j < n; j++) {\\n                numOf5s += numOfNs(grid[i][j], 5);\\n                numOf2s += numOfNs(grid[i][j], 2);\\n                fromLeft[i + 1][j + 1][0] = numOf5s;\\n                fromLeft[i + 1][j + 1][1] = numOf2s;\\n            }\\n        }\\n        //prefix sum of 5s and 2s from top\\n        for (int i = 0; i < n; i++) {\\n            int numOf5s = 0;\\n            int numOf2s = 0;\\n            for (int j = 0; j < m; j++) {\\n                numOf5s += numOfNs(grid[j][i], 5);\\n                numOf2s += numOfNs(grid[j][i], 2);\\n                fromTop[j + 1][i + 1][0] = numOf5s;\\n                fromTop[j + 1][i + 1][1] = numOf2s;\\n            }\\n        }\\n        \\n        int max = 0;\\n        for (int i = 1; i < m + 1; i++) {\\n            for (int j = 1; j < n + 1; j++) {\\n                int topLeft = Math.min(\\n                        fromLeft[i][j][0] + fromTop[i - 1][j][0],\\n                        fromLeft[i][j][1] + fromTop[i - 1][j][1]);\\n                int topRight = Math.min(\\n                        fromLeft[i][n][0] - fromLeft[i][j][0] + fromTop[i][j][0],\\n                        fromLeft[i][n][1] - fromLeft[i][j][1] + fromTop[i][j][1]);\\n                int bottomLeft = Math.min(\\n                        fromLeft[i][j][0] + fromTop[m][j][0] - fromTop[i][j][0],\\n                        fromLeft[i][j][1] + fromTop[m][j][1] - fromTop[i][j][1]);\\n                int bottomRight = Math.min(\\n                        fromLeft[i][n][0] - fromLeft[i][j - 1][0] + fromTop[m][j][0] - fromTop[i][j][0],\\n                        fromLeft[i][n][1] - fromLeft[i][j - 1][1] + fromTop[m][j][1] - fromTop[i][j][1]);\\n\\n                max = Math.max(max, Math.max(Math.max(topLeft, topRight), Math.max(bottomLeft, bottomRight)));\\n            }\\n        }\\n        return max;\\n    }\\n    //count the number of 5s or 2s \\n    private int numOfNs(int a, int n) {\\n        int count = 0;\\n        while (a % n == 0) {\\n            count++;\\n            a /= n;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][][] fromLeft = new int[m + 1][n + 1][2];\\n        int[][][] fromTop = new int[m + 1][n + 1][2];\\n\\n        //prefix sum of 5s and 2s from left\\n        for (int i = 0; i < m; i++) {\\n            int numOf5s = 0;\\n            int numOf2s = 0;\\n            for (int j = 0; j < n; j++) {\\n                numOf5s += numOfNs(grid[i][j], 5);\\n                numOf2s += numOfNs(grid[i][j], 2);\\n                fromLeft[i + 1][j + 1][0] = numOf5s;\\n                fromLeft[i + 1][j + 1][1] = numOf2s;\\n            }\\n        }\\n        //prefix sum of 5s and 2s from top\\n        for (int i = 0; i < n; i++) {\\n            int numOf5s = 0;\\n            int numOf2s = 0;\\n            for (int j = 0; j < m; j++) {\\n                numOf5s += numOfNs(grid[j][i], 5);\\n                numOf2s += numOfNs(grid[j][i], 2);\\n                fromTop[j + 1][i + 1][0] = numOf5s;\\n                fromTop[j + 1][i + 1][1] = numOf2s;\\n            }\\n        }\\n        \\n        int max = 0;\\n        for (int i = 1; i < m + 1; i++) {\\n            for (int j = 1; j < n + 1; j++) {\\n                int topLeft = Math.min(\\n                        fromLeft[i][j][0] + fromTop[i - 1][j][0],\\n                        fromLeft[i][j][1] + fromTop[i - 1][j][1]);\\n                int topRight = Math.min(\\n                        fromLeft[i][n][0] - fromLeft[i][j][0] + fromTop[i][j][0],\\n                        fromLeft[i][n][1] - fromLeft[i][j][1] + fromTop[i][j][1]);\\n                int bottomLeft = Math.min(\\n                        fromLeft[i][j][0] + fromTop[m][j][0] - fromTop[i][j][0],\\n                        fromLeft[i][j][1] + fromTop[m][j][1] - fromTop[i][j][1]);\\n                int bottomRight = Math.min(\\n                        fromLeft[i][n][0] - fromLeft[i][j - 1][0] + fromTop[m][j][0] - fromTop[i][j][0],\\n                        fromLeft[i][n][1] - fromLeft[i][j - 1][1] + fromTop[m][j][1] - fromTop[i][j][1]);\\n\\n                max = Math.max(max, Math.max(Math.max(topLeft, topRight), Math.max(bottomLeft, bottomRight)));\\n            }\\n        }\\n        return max;\\n    }\\n    //count the number of 5s or 2s \\n    private int numOfNs(int a, int n) {\\n        int count = 0;\\n        while (a % n == 0) {\\n            count++;\\n            a /= n;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956160,
                "title": "java-faster-than-100-less-memory-than-100-o-m-n-space-time-complexity-solution",
                "content": "```\\nclass Solution {\\n    class Point {\\n        int powerOfTwo;\\n        int powerOfFive;\\n        \\n         public Point() {\\n            powerOfTwo = 0;\\n            powerOfFive = 0;\\n        }\\n\\n        public Point(int num) {\\n            powerOfTwo = 0;\\n            powerOfFive = 0;\\n            \\n            while(num%2 == 0) {\\n                powerOfTwo++;\\n                num /= 2;\\n            }\\n            \\n            while(num%5 == 0) {\\n                powerOfFive++;\\n                num /= 5;\\n            }\\n        }\\n        \\n        private Point add(Point point) {\\n            powerOfTwo += point.powerOfTwo;\\n            powerOfFive += point.powerOfFive;\\n            return this;\\n        }\\n        \\n                \\n        private Point subtract(Point point) {\\n            powerOfTwo -= point.powerOfTwo;\\n            powerOfFive -= point.powerOfFive;\\n            return this;\\n        }\\n        \\n        \\n        private int getNumberOfZeros() {\\n            return Math.min(powerOfTwo, powerOfFive);\\n        }\\n    }\\n    \\n    public int maxTrailingZeros(int[][] grid) {\\n        // Keeps track of power of 2 & 5 per entry in grid\\n        Point[][] values = new Point[grid.length][grid[0].length];\\n        \\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                values[i][j] = new Point(grid[i][j]);\\n            }\\n        }\\n        \\n        // Keeps track of power of 2 & 5 per entry in grid per row\\n        // calcH[i][j] => value for row i, col 0 to j\\n        Point[][] calcH = new Point[grid.length][grid[0].length];\\n        for(int i = 0;   i < grid.length; i++) {\\n            calcH[i][0] = values[i][0];\\n            for(int j = 1; j < grid[0].length; j++) {\\n                calcH[i][j] = new Point().add(calcH[i][j-1]).add(values[i][j]);\\n            }\\n        }\\n        \\n        // Keeps track of power of 2 & 5 per entry in grid per col\\n        Point[][] calcV = new Point[grid.length][grid[0].length];\\n        \\n        for(int j = 0;   j < grid[0].length; j++) {\\n            calcV[0][j] = values[0][j];\\n            for(int i = 1; i < grid.length; i++) {\\n                calcV[i][j] = new Point().add(calcV[i-1][j]).add(values[i][j]);\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                // _| => Vertical till i,j And then Horizontal till i,j\\n                ans = Math.max(ans, new Point().add(calcH[i][j])\\n                               .add(calcV[i][j])\\n                               .subtract(values[i][j]) // this has been added twice\\n                               .getNumberOfZeros());\\n                // |_ => Vertical till i,j And then Horizontal beyond i,j\\n                ans = Math.max(ans, new Point().add(calcH[i][grid[0].length-1])\\n                               .subtract(calcH[i][j])\\n                               .add(calcV[i][j])\\n                               .getNumberOfZeros());\\n                //   _  Horizontal till i,j And and then vertical below i,j\\n                //    |\\n                ans = Math.max(ans, new Point().add(calcH[i][j])\\n                               .add(calcV[grid.length-1][j])\\n                               .subtract(calcV[i][j])\\n                               .getNumberOfZeros());                           \\n                //     _  Horizontal beyond i,j And vertical below i,j\\n                //    |\\n                ans = Math.max(ans, new Point().add(calcH[i][grid[0].length-1])\\n                               .subtract(calcH[i][j])\\n                               .add(calcV[grid.length-1][j])\\n                               .subtract(calcV[i][j])\\n                               .add(values[i][j])\\n                               .getNumberOfZeros());  \\n\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Point {\\n        int powerOfTwo;\\n        int powerOfFive;\\n        \\n         public Point() {\\n            powerOfTwo = 0;\\n            powerOfFive = 0;\\n        }\\n\\n        public Point(int num) {\\n            powerOfTwo = 0;\\n            powerOfFive = 0;\\n            \\n            while(num%2 == 0) {\\n                powerOfTwo++;\\n                num /= 2;\\n            }\\n            \\n            while(num%5 == 0) {\\n                powerOfFive++;\\n                num /= 5;\\n            }\\n        }\\n        \\n        private Point add(Point point) {\\n            powerOfTwo += point.powerOfTwo;\\n            powerOfFive += point.powerOfFive;\\n            return this;\\n        }\\n        \\n                \\n        private Point subtract(Point point) {\\n            powerOfTwo -= point.powerOfTwo;\\n            powerOfFive -= point.powerOfFive;\\n            return this;\\n        }\\n        \\n        \\n        private int getNumberOfZeros() {\\n            return Math.min(powerOfTwo, powerOfFive);\\n        }\\n    }\\n    \\n    public int maxTrailingZeros(int[][] grid) {\\n        // Keeps track of power of 2 & 5 per entry in grid\\n        Point[][] values = new Point[grid.length][grid[0].length];\\n        \\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                values[i][j] = new Point(grid[i][j]);\\n            }\\n        }\\n        \\n        // Keeps track of power of 2 & 5 per entry in grid per row\\n        // calcH[i][j] => value for row i, col 0 to j\\n        Point[][] calcH = new Point[grid.length][grid[0].length];\\n        for(int i = 0;   i < grid.length; i++) {\\n            calcH[i][0] = values[i][0];\\n            for(int j = 1; j < grid[0].length; j++) {\\n                calcH[i][j] = new Point().add(calcH[i][j-1]).add(values[i][j]);\\n            }\\n        }\\n        \\n        // Keeps track of power of 2 & 5 per entry in grid per col\\n        Point[][] calcV = new Point[grid.length][grid[0].length];\\n        \\n        for(int j = 0;   j < grid[0].length; j++) {\\n            calcV[0][j] = values[0][j];\\n            for(int i = 1; i < grid.length; i++) {\\n                calcV[i][j] = new Point().add(calcV[i-1][j]).add(values[i][j]);\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                // _| => Vertical till i,j And then Horizontal till i,j\\n                ans = Math.max(ans, new Point().add(calcH[i][j])\\n                               .add(calcV[i][j])\\n                               .subtract(values[i][j]) // this has been added twice\\n                               .getNumberOfZeros());\\n                // |_ => Vertical till i,j And then Horizontal beyond i,j\\n                ans = Math.max(ans, new Point().add(calcH[i][grid[0].length-1])\\n                               .subtract(calcH[i][j])\\n                               .add(calcV[i][j])\\n                               .getNumberOfZeros());\\n                //   _  Horizontal till i,j And and then vertical below i,j\\n                //    |\\n                ans = Math.max(ans, new Point().add(calcH[i][j])\\n                               .add(calcV[grid.length-1][j])\\n                               .subtract(calcV[i][j])\\n                               .getNumberOfZeros());                           \\n                //     _  Horizontal beyond i,j And vertical below i,j\\n                //    |\\n                ans = Math.max(ans, new Point().add(calcH[i][grid[0].length-1])\\n                               .subtract(calcH[i][j])\\n                               .add(calcV[grid.length-1][j])\\n                               .subtract(calcV[i][j])\\n                               .add(values[i][j])\\n                               .getNumberOfZeros());  \\n\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956107,
                "title": "prefix-and-suffix-sums",
                "content": "Store all counts of 5s and 2s in a prefix and suffix arrays starting from left, right, up and down and add them while making a transition or if you choose to make no transition. Find max value from all such transitions.\\n```\\nclass Solution {\\n    \\n    int cnt2s(int n){\\n        int cnt = 0;\\n        while(n>0){\\n            if(n%2 == 0) cnt++;\\n            else return cnt;\\n            \\n            n/=2;\\n        }\\n        return cnt;\\n    }\\n    \\n    int cnt5s(int n){\\n        int cnt = 0;\\n        while(n>0){\\n            if(n%5 == 0) cnt++;\\n            else return cnt;\\n            \\n            n/=5;\\n        }\\n        return cnt;\\n    }\\n    \\n    int turn(vector<int>& a, vector<int>& b){\\n        return min(a[0]+b[0], a[1]+b[1]);\\n    }\\n    \\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>>dpl(n, vector<vector<int>>(m, vector<int>(2))),dpr(n, vector<vector<int>>(m, vector<int>(2))),dpu(n, vector<vector<int>>(m, vector<int>(2))),dpd(n, vector<vector<int>>(m, vector<int>(2)));\\n    \\n            \\n        // dpl\\n        for(int i=0;i<n;i++) {\\n            dpl[i][0][0] = cnt2s(grid[i][0]);\\n            dpl[i][0][1] = cnt5s(grid[i][0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                dpl[i][j][0] = cnt2s(grid[i][j]) + dpl[i][j-1][0];\\n                dpl[i][j][1] = cnt5s(grid[i][j]) + dpl[i][j-1][1];\\n            }\\n        }\\n\\n        // dpr\\n        for(int i=0;i<n;i++) {\\n            dpr[i][m-1][0] = cnt2s(grid[i][m-1]);\\n            dpr[i][m-1][1] = cnt5s(grid[i][m-1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=m-2;j>=0;j--){\\n                dpr[i][j][0] = cnt2s(grid[i][j]) + dpr[i][j+1][0];\\n                dpr[i][j][1] = cnt5s(grid[i][j]) + dpr[i][j+1][1];\\n            }\\n        }\\n        \\n        // dpu\\n        for(int j=0;j<m;j++) {\\n            dpu[0][j][0] = cnt2s(grid[0][j]);\\n            dpu[0][j][1] = cnt5s(grid[0][j]);\\n        }\\n        for(int j=0;j<m;j++){\\n            for(int i=1;i<n;i++){\\n                dpu[i][j][0] = cnt2s(grid[i][j]) + dpu[i-1][j][0];\\n                dpu[i][j][1] = cnt5s(grid[i][j]) + dpu[i-1][j][1];\\n            }\\n        }\\n        \\n        // dpd\\n        for(int j=0;j<m;j++) {\\n            dpd[n-1][j][0] = cnt2s(grid[n-1][j]);\\n            dpd[n-1][j][1] = cnt5s(grid[n-1][j]);\\n        }\\n        for(int j=0;j<m;j++){\\n            for(int i=n-2;i>=0;i--){\\n                dpd[i][j][0] = cnt2s(grid[i][j]) + dpd[i+1][j][0];\\n                dpd[i][j][1] = cnt5s(grid[i][j]) + dpd[i+1][j][1];\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                // l - r\\n                // l - u\\n                // l - d\\n                // u - d \\n                // u - r\\n                // r - d\\n                \\n                if(j+1 < m) ans = max(ans, turn(dpl[i][j], dpr[i][j+1]));\\n                if(i-1 >= 0)ans = max(ans, turn(dpl[i][j], dpu[i-1][j]));\\n                if(i+1 < n) ans = max(ans, turn(dpl[i][j], dpd[i+1][j]));\\n                if(i+1 < n) ans = max(ans, turn(dpu[i][j], dpd[i+1][j]));\\n                if(j+1 < m) ans = max(ans, turn(dpu[i][j], dpr[i][j+1]));\\n                if(i+1 < n) ans = max(ans, turn(dpr[i][j], dpd[i+1][j]));\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int cnt2s(int n){\\n        int cnt = 0;\\n        while(n>0){\\n            if(n%2 == 0) cnt++;\\n            else return cnt;\\n            \\n            n/=2;\\n        }\\n        return cnt;\\n    }\\n    \\n    int cnt5s(int n){\\n        int cnt = 0;\\n        while(n>0){\\n            if(n%5 == 0) cnt++;\\n            else return cnt;\\n            \\n            n/=5;\\n        }\\n        return cnt;\\n    }\\n    \\n    int turn(vector<int>& a, vector<int>& b){\\n        return min(a[0]+b[0], a[1]+b[1]);\\n    }\\n    \\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>>dpl(n, vector<vector<int>>(m, vector<int>(2))),dpr(n, vector<vector<int>>(m, vector<int>(2))),dpu(n, vector<vector<int>>(m, vector<int>(2))),dpd(n, vector<vector<int>>(m, vector<int>(2)));\\n    \\n            \\n        // dpl\\n        for(int i=0;i<n;i++) {\\n            dpl[i][0][0] = cnt2s(grid[i][0]);\\n            dpl[i][0][1] = cnt5s(grid[i][0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                dpl[i][j][0] = cnt2s(grid[i][j]) + dpl[i][j-1][0];\\n                dpl[i][j][1] = cnt5s(grid[i][j]) + dpl[i][j-1][1];\\n            }\\n        }\\n\\n        // dpr\\n        for(int i=0;i<n;i++) {\\n            dpr[i][m-1][0] = cnt2s(grid[i][m-1]);\\n            dpr[i][m-1][1] = cnt5s(grid[i][m-1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=m-2;j>=0;j--){\\n                dpr[i][j][0] = cnt2s(grid[i][j]) + dpr[i][j+1][0];\\n                dpr[i][j][1] = cnt5s(grid[i][j]) + dpr[i][j+1][1];\\n            }\\n        }\\n        \\n        // dpu\\n        for(int j=0;j<m;j++) {\\n            dpu[0][j][0] = cnt2s(grid[0][j]);\\n            dpu[0][j][1] = cnt5s(grid[0][j]);\\n        }\\n        for(int j=0;j<m;j++){\\n            for(int i=1;i<n;i++){\\n                dpu[i][j][0] = cnt2s(grid[i][j]) + dpu[i-1][j][0];\\n                dpu[i][j][1] = cnt5s(grid[i][j]) + dpu[i-1][j][1];\\n            }\\n        }\\n        \\n        // dpd\\n        for(int j=0;j<m;j++) {\\n            dpd[n-1][j][0] = cnt2s(grid[n-1][j]);\\n            dpd[n-1][j][1] = cnt5s(grid[n-1][j]);\\n        }\\n        for(int j=0;j<m;j++){\\n            for(int i=n-2;i>=0;i--){\\n                dpd[i][j][0] = cnt2s(grid[i][j]) + dpd[i+1][j][0];\\n                dpd[i][j][1] = cnt5s(grid[i][j]) + dpd[i+1][j][1];\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                // l - r\\n                // l - u\\n                // l - d\\n                // u - d \\n                // u - r\\n                // r - d\\n                \\n                if(j+1 < m) ans = max(ans, turn(dpl[i][j], dpr[i][j+1]));\\n                if(i-1 >= 0)ans = max(ans, turn(dpl[i][j], dpu[i-1][j]));\\n                if(i+1 < n) ans = max(ans, turn(dpl[i][j], dpd[i+1][j]));\\n                if(i+1 < n) ans = max(ans, turn(dpu[i][j], dpd[i+1][j]));\\n                if(j+1 < m) ans = max(ans, turn(dpu[i][j], dpr[i][j+1]));\\n                if(i+1 < n) ans = max(ans, turn(dpr[i][j], dpd[i+1][j]));\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956079,
                "title": "can-anyone-find-mistake-in-my-code-please",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<pair<int,int>>> v(m, vector<pair<int,int>>(n,{0,0})), h(m, vector<pair<int,int>>(n,{0,0}));\\n        \\n        for (int i = 0; i < m; i++) {\\n            int c5 = 0, c2 = 0;\\n            for (int j = 0; j < n; j++) {\\n                int val = grid[i][j];\\n                while(val%5 == 0) {\\n                    val /= 5;\\n                    c5++;\\n                }\\n                \\n                while(val%2 == 0) {\\n                    val /= 2;\\n                    c2++;\\n                }\\n                \\n                h[i][j] = {c2,c5};\\n                //cout << h[i][j].first << \"-\" << h[i][j].second << \" \";\\n            }\\n            \\n            //cout << endl;\\n        }\\n        \\n        for (int j = 0; j < n; j++) {\\n            int c5 = 0, c2 = 0;\\n            for (int i = 0; i < m; i++) {\\n                int val = grid[i][j];\\n                while(val%5 == 0) {\\n                    val /= 5;\\n                    c5++;\\n                }\\n                \\n                while(val%2 == 0) {\\n                    val /= 2;\\n                    c2++;\\n                }\\n                \\n                v[i][j] = {c2,c5};\\n                //cout << v[i][j].first << \"-\" << v[i][j].second << \" \";\\n            }\\n            \\n            //cout << endl;\\n        }\\n        \\n        int ma = 0;\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int l0 = 0, \\n                    r0 = min (h[i][n-1].first-h[i][j].first, h[i][n-1].second-h[i][j].second), \\n                    u0 = min (v[i][j].first, v[i][j].second), \\n                    d0 = min (v[m-1][j].first, v[m-1][j].second);\\n                \\n                if (i != 0) d0 = min (v[m-1][j].first-v[i-1][j].first, v[m-1][j].second-v[i-1][j].second);\\n                \\n                if (j > 0) l0 = min (h[i][j-1].first, h[i][j-1].second);\\n                \\n                int tma = max(max(u0+l0, u0+r0),max(d0+l0, d0+r0));\\n                //cout << tma << endl;\\n                ma = max(ma, tma);\\n            }\\n        }\\n        \\n        return ma;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<pair<int,int>>> v(m, vector<pair<int,int>>(n,{0,0})), h(m, vector<pair<int,int>>(n,{0,0}));\\n        \\n        for (int i = 0; i < m; i++) {\\n            int c5 = 0, c2 = 0;\\n            for (int j = 0; j < n; j++) {\\n                int val = grid[i][j];\\n                while(val%5 == 0) {\\n                    val /= 5;\\n                    c5++;\\n                }\\n                \\n                while(val%2 == 0) {\\n                    val /= 2;\\n                    c2++;\\n                }\\n                \\n                h[i][j] = {c2,c5};\\n                //cout << h[i][j].first << \"-\" << h[i][j].second << \" \";\\n            }\\n            \\n            //cout << endl;\\n        }\\n        \\n        for (int j = 0; j < n; j++) {\\n            int c5 = 0, c2 = 0;\\n            for (int i = 0; i < m; i++) {\\n                int val = grid[i][j];\\n                while(val%5 == 0) {\\n                    val /= 5;\\n                    c5++;\\n                }\\n                \\n                while(val%2 == 0) {\\n                    val /= 2;\\n                    c2++;\\n                }\\n                \\n                v[i][j] = {c2,c5};\\n                //cout << v[i][j].first << \"-\" << v[i][j].second << \" \";\\n            }\\n            \\n            //cout << endl;\\n        }\\n        \\n        int ma = 0;\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int l0 = 0, \\n                    r0 = min (h[i][n-1].first-h[i][j].first, h[i][n-1].second-h[i][j].second), \\n                    u0 = min (v[i][j].first, v[i][j].second), \\n                    d0 = min (v[m-1][j].first, v[m-1][j].second);\\n                \\n                if (i != 0) d0 = min (v[m-1][j].first-v[i-1][j].first, v[m-1][j].second-v[i-1][j].second);\\n                \\n                if (j > 0) l0 = min (h[i][j-1].first, h[i][j-1].second);\\n                \\n                int tma = max(max(u0+l0, u0+r0),max(d0+l0, d0+r0));\\n                //cout << tma << endl;\\n                ma = max(ma, tma);\\n            }\\n        }\\n        \\n        return ma;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1956077,
                "title": "c-o-m-n-time-space",
                "content": "```\\nstruct ten{\\n    int two, five;\\n    ten( int t, int f){\\n        two=t;\\n        five=f;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int max_ten=0, m=grid.size(), n=grid[0].size();\\n        ten init=ten( 0, 0);\\n        vector<vector<ten>> up( m, vector<ten> (n, init) ), down( m, vector<ten> (n, init) ),\\n            left( m, vector<ten> (n, init) ), right( m, vector<ten> (n, init) );\\n        \\n        for( int i=0; i<grid.size(); i++){\\n            // from left \\n            left[i][0]=calculateTen( grid[i][0], init);\\n            for( int j=1; j<grid[0].size(); j++){// left \\n                left[i][j]=calculateTen( grid[i][j], left[i][j-1]);\\n            }\\n            // from right \\n            right[i][n-1]=calculateTen( grid[i][n-1], init);\\n            for( int j=n-2; -1<j; j--){\\n                right[i][j]=calculateTen( grid[i][j], right[i][j+1]);\\n            }\\n        }\\n        \\n        for( int j=0; j<grid[0].size(); j++){\\n            // from up \\n            up[0][j]=calculateTen( grid[0][j], init);\\n            for( int i=1; i<grid.size(); i++){\\n                up[i][j]=calculateTen( grid[i][j], up[i-1][j]);\\n            }\\n            // from down \\n            down[m-1][j]=calculateTen( grid[m-1][j], init);\\n            for( int i=m-2; -1<i; i--){\\n                down[i][j]=calculateTen( grid[i][j], down[i+1][j]);\\n            }\\n        }\\n        \\n        for( int i=0; i<grid.size(); i++){\\n            for( int j=0; j<grid[0].size(); j++){\\n                calMaxTen( up[i][j], i+1<m?down[i+1][j]:init, max_ten);\\n                calMaxTen( up[i][j], 0<j?left[i][j-1]:init, max_ten);\\n                calMaxTen( up[i][j], j+1<n?right[i][j+1]:init, max_ten);\\n                calMaxTen( down[i][j], 0<j?left[i][j-1]:init, max_ten);\\n                calMaxTen( down[i][j], j+1<n?right[i][j+1]:init, max_ten);\\n                calMaxTen( left[i][j], j+1<n?right[i][j+1]:init, max_ten);\\n            }\\n        }\\n        \\n        return max_ten;\\n    }\\n    \\nprotected:\\n    ten calculateTen( int num, ten t){\\n        for( ; num%2==0; num=num/2, t.two++){}\\n        for( ; num%5==0; num=num/5, t.five++){}\\n        return t;\\n    }\\n    \\n    void calMaxTen( ten t1, ten t2, int & max_ten){\\n        int two=t1.two+t2.two, five=t1.five+t2.five, \\n            t=two<five?two:five;\\n        if(max_ten<t)\\n            max_ten=t;\\n        return ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct ten{\\n    int two, five;\\n    ten( int t, int f){\\n        two=t;\\n        five=f;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int max_ten=0, m=grid.size(), n=grid[0].size();\\n        ten init=ten( 0, 0);\\n        vector<vector<ten>> up( m, vector<ten> (n, init) ), down( m, vector<ten> (n, init) ),\\n            left( m, vector<ten> (n, init) ), right( m, vector<ten> (n, init) );\\n        \\n        for( int i=0; i<grid.size(); i++){\\n            // from left \\n            left[i][0]=calculateTen( grid[i][0], init);\\n            for( int j=1; j<grid[0].size(); j++){// left \\n                left[i][j]=calculateTen( grid[i][j], left[i][j-1]);\\n            }\\n            // from right \\n            right[i][n-1]=calculateTen( grid[i][n-1], init);\\n            for( int j=n-2; -1<j; j--){\\n                right[i][j]=calculateTen( grid[i][j], right[i][j+1]);\\n            }\\n        }\\n        \\n        for( int j=0; j<grid[0].size(); j++){\\n            // from up \\n            up[0][j]=calculateTen( grid[0][j], init);\\n            for( int i=1; i<grid.size(); i++){\\n                up[i][j]=calculateTen( grid[i][j], up[i-1][j]);\\n            }\\n            // from down \\n            down[m-1][j]=calculateTen( grid[m-1][j], init);\\n            for( int i=m-2; -1<i; i--){\\n                down[i][j]=calculateTen( grid[i][j], down[i+1][j]);\\n            }\\n        }\\n        \\n        for( int i=0; i<grid.size(); i++){\\n            for( int j=0; j<grid[0].size(); j++){\\n                calMaxTen( up[i][j], i+1<m?down[i+1][j]:init, max_ten);\\n                calMaxTen( up[i][j], 0<j?left[i][j-1]:init, max_ten);\\n                calMaxTen( up[i][j], j+1<n?right[i][j+1]:init, max_ten);\\n                calMaxTen( down[i][j], 0<j?left[i][j-1]:init, max_ten);\\n                calMaxTen( down[i][j], j+1<n?right[i][j+1]:init, max_ten);\\n                calMaxTen( left[i][j], j+1<n?right[i][j+1]:init, max_ten);\\n            }\\n        }\\n        \\n        return max_ten;\\n    }\\n    \\nprotected:\\n    ten calculateTen( int num, ten t){\\n        for( ; num%2==0; num=num/2, t.two++){}\\n        for( ; num%5==0; num=num/5, t.five++){}\\n        return t;\\n    }\\n    \\n    void calMaxTen( ten t1, ten t2, int & max_ten){\\n        int two=t1.two+t2.two, five=t1.five+t2.five, \\n            t=two<five?two:five;\\n        if(max_ten<t)\\n            max_ten=t;\\n        return ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956072,
                "title": "prefix-sum-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        /*\\n            \\u524D\\u7F00\\u548C\\n        */\\n        int m = grid.length, n = grid[0].length;\\n        int[][][] hP = new int[m][n][2]; // \\u6700\\u540E\\u7684 2 \\u4F4D\\u6570\\u7EC4\\u4EE3\\u8868 [\\u591A\\u5C11\\u4E2A 5, \\u591A\\u5C11\\u4E2A 2]\\n        int[][][] vP = new int[m][n][2];\\n        int res = 0;\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                 // \\u6C34\\u5E73\\n                if (j == 0) {\\n                    hP[i][j][0] = countFive(grid[i][j]);\\n                    hP[i][j][1] = countTwo(grid[i][j]);\\n                } else {\\n                    hP[i][j][0] = hP[i][j-1][0] + countFive(grid[i][j]);\\n                    hP[i][j][1] = hP[i][j-1][1] + countTwo(grid[i][j]);\\n                }\\n            }\\n        }\\n        for (int j=0; j<n; j++) {\\n            for (int i=0; i<m; i++) {\\n                 // \\u5782\\u76F4\\n                if (i == 0) {\\n                    vP[i][j][0] = countFive(grid[i][j]);\\n                    vP[i][j][1] = countTwo(grid[i][j]);\\n                } else {\\n                    vP[i][j][0] = vP[i-1][j][0] + countFive(grid[i][j]);\\n                    vP[i][j][1] = vP[i-1][j][1] + countTwo(grid[i][j]);\\n                }\\n            }\\n        }\\n        \\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                res = Math.max(res, Math.min(hP[i][j][0] - countFive(grid[i][j]) + vP[i][j][0], hP[i][j][1] - countTwo(grid[i][j]) + vP[i][j][1]));\\n                res = Math.max(res, Math.min(hP[i][n-1][0] - hP[i][j][0] + vP[i][j][0], hP[i][n-1][1] - hP[i][j][1] + vP[i][j][1]));\\n                res = Math.max(res, Math.min(hP[i][j][0] + vP[m-1][j][0] - vP[i][j][0], hP[i][j][1] + vP[m-1][j][1] - vP[i][j][1]));\\n                res = Math.max(res, Math.min(hP[i][n-1][0] - hP[i][j][0] + vP[m-1][j][0] - vP[i][j][0] + countFive(grid[i][j]), hP[i][n-1][1] - hP[i][j][1] + vP[m-1][j][1] - vP[i][j][1] + countTwo(grid[i][j])));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int countFive(int val) {\\n        int res = 0;\\n        while (val != 0 && val % 5 == 0) {\\n            val = val / 5;\\n            res++;\\n        }\\n        return res;\\n    }\\n    \\n    private int countTwo(int val) {\\n        int res = 0;\\n        while (val != 0 && val % 2 == 0) {\\n            val = val / 2;\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        /*\\n            \\u524D\\u7F00\\u548C\\n        */\\n        int m = grid.length, n = grid[0].length;\\n        int[][][] hP = new int[m][n][2]; // \\u6700\\u540E\\u7684 2 \\u4F4D\\u6570\\u7EC4\\u4EE3\\u8868 [\\u591A\\u5C11\\u4E2A 5, \\u591A\\u5C11\\u4E2A 2]\\n        int[][][] vP = new int[m][n][2];\\n        int res = 0;\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                 // \\u6C34\\u5E73\\n                if (j == 0) {\\n                    hP[i][j][0] = countFive(grid[i][j]);\\n                    hP[i][j][1] = countTwo(grid[i][j]);\\n                } else {\\n                    hP[i][j][0] = hP[i][j-1][0] + countFive(grid[i][j]);\\n                    hP[i][j][1] = hP[i][j-1][1] + countTwo(grid[i][j]);\\n                }\\n            }\\n        }\\n        for (int j=0; j<n; j++) {\\n            for (int i=0; i<m; i++) {\\n                 // \\u5782\\u76F4\\n                if (i == 0) {\\n                    vP[i][j][0] = countFive(grid[i][j]);\\n                    vP[i][j][1] = countTwo(grid[i][j]);\\n                } else {\\n                    vP[i][j][0] = vP[i-1][j][0] + countFive(grid[i][j]);\\n                    vP[i][j][1] = vP[i-1][j][1] + countTwo(grid[i][j]);\\n                }\\n            }\\n        }\\n        \\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                res = Math.max(res, Math.min(hP[i][j][0] - countFive(grid[i][j]) + vP[i][j][0], hP[i][j][1] - countTwo(grid[i][j]) + vP[i][j][1]));\\n                res = Math.max(res, Math.min(hP[i][n-1][0] - hP[i][j][0] + vP[i][j][0], hP[i][n-1][1] - hP[i][j][1] + vP[i][j][1]));\\n                res = Math.max(res, Math.min(hP[i][j][0] + vP[m-1][j][0] - vP[i][j][0], hP[i][j][1] + vP[m-1][j][1] - vP[i][j][1]));\\n                res = Math.max(res, Math.min(hP[i][n-1][0] - hP[i][j][0] + vP[m-1][j][0] - vP[i][j][0] + countFive(grid[i][j]), hP[i][n-1][1] - hP[i][j][1] + vP[m-1][j][1] - vP[i][j][1] + countTwo(grid[i][j])));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int countFive(int val) {\\n        int res = 0;\\n        while (val != 0 && val % 5 == 0) {\\n            val = val / 5;\\n            res++;\\n        }\\n        return res;\\n    }\\n    \\n    private int countTwo(int val) {\\n        int res = 0;\\n        while (val != 0 && val % 2 == 0) {\\n            val = val / 2;\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955993,
                "title": "c-prefix-sum-find-the-largest-2-directions-for-each-cell",
                "content": "**Thought process :**\\n* The way to form a trailing zero is by a 2 multiply by 5.\\n\\t* So the number of trailing zeros in a straight line is min(# of 2 in a straight line, # of 5 in a straight line).\\n* Since we only allow 1 turn, we can alternatively count the number of 2s and 5s for 4 directions for each cell, and choose the biggest 2 directions (C 4 to 2) to represent the maximum number of trailing zeros for this cell.\\n* Go through every cell and find the maximum number of each cell.\\n```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> fh(m, vector<int>(n, 0));  // Prefix sum of horizontal direction for 5\\n        vector<vector<int>> fv(m, vector<int>(n, 0));  // Prefix sum of vertical direction for 5\\n        vector<vector<int>> sh(m, vector<int>(n, 0));  // Prefix sum of horizontal direction for 2\\n        vector<vector<int>> sv(m, vector<int>(n, 0));  // Prefix sum of vertical direction for 2\\n        vector<vector<int>> f(m, vector<int>(n, 0));  // Number of 5 for each cell\\n        vector<vector<int>> s(m, vector<int>(n, 0));  // Number of 2 for each cell\\n        // [4 Directions] 0 : up, 1 : right, 2 : down, 3 : left\\n        vector<vector<vector<int>>> d(m*n, vector<vector<int>>(4, vector<int>(2,0)));\\n        \\n\\t\\t// Prefix sum\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] % 5 == 0) {\\n                    int temp = grid[i][j];\\n                    while (temp % 5 == 0) {\\n                        f[i][j]++;\\n                        temp /= 5;\\n                    }\\n                }\\n                if (grid[i][j] % 2 == 0) {\\n                    int temp = grid[i][j];\\n                    while (temp % 2 == 0) {\\n                        s[i][j]++;\\n                        temp /= 2;\\n                    }\\n                }\\n                if (j > 0) {\\n                    fh[i][j] = fh[i][j-1] + f[i][j];\\n                    sh[i][j] = sh[i][j-1] + s[i][j];\\n                }\\n                else {\\n                    fh[i][j] = f[i][j];\\n                    sh[i][j] = s[i][j];\\n                }\\n                if (i > 0) {\\n                    fv[i][j] = fv[i-1][j] + f[i][j];\\n                    sv[i][j] = sv[i-1][j] + s[i][j];\\n                }\\n                else {\\n                    fv[i][j] = f[i][j];\\n                    sv[i][j] = s[i][j];\\n                }\\n            }\\n        }\\n        \\n\\t\\t// Form the number of 2s and 5s for 4 directions of each cell\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                for (int k = 0; k < 4; k++) {\\n                    int fc = 0, sc = 0;\\n                    \\n                    if (k == 0) {\\n                        if (i > 0) {\\n                            fc = fv[i-1][j];\\n                            sc = sv[i-1][j];\\n                        }\\n                    }\\n                    else if (k == 1) {\\n                        fc = fh[i][n-1] - fh[i][j];\\n                        sc = sh[i][n-1] - sh[i][j];\\n                    }\\n                    else if (k == 2) {\\n                        fc = fv[m-1][j] - fv[i][j];\\n                        sc = sv[m-1][j] - sv[i][j];\\n                    }\\n                    else {\\n                        if (j > 0) {\\n                            fc = fh[i][j-1];\\n                            sc = sh[i][j-1];\\n                        }\\n                    }\\n                    d[i*n+j][k][0] = fc;\\n                    d[i*n+j][k][1] = sc;\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n\\t\\t// Go through each cell and possible combinations of every 2 directions\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                for (int k = 0; k < 4; k++) {\\n                    for (int l = k+1; l < 4; l++) {\\n                        int cur = min(d[i*n+j][k][0] + d[i*n+j][l][0] + f[i][j], d[i*n+j][k][1] + d[i*n+j][l][1] + s[i][j]);\\n                        ans = max(ans, cur);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> fh(m, vector<int>(n, 0));  // Prefix sum of horizontal direction for 5\\n        vector<vector<int>> fv(m, vector<int>(n, 0));  // Prefix sum of vertical direction for 5\\n        vector<vector<int>> sh(m, vector<int>(n, 0));  // Prefix sum of horizontal direction for 2\\n        vector<vector<int>> sv(m, vector<int>(n, 0));  // Prefix sum of vertical direction for 2\\n        vector<vector<int>> f(m, vector<int>(n, 0));  // Number of 5 for each cell\\n        vector<vector<int>> s(m, vector<int>(n, 0));  // Number of 2 for each cell\\n        // [4 Directions] 0 : up, 1 : right, 2 : down, 3 : left\\n        vector<vector<vector<int>>> d(m*n, vector<vector<int>>(4, vector<int>(2,0)));\\n        \\n\\t\\t// Prefix sum\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] % 5 == 0) {\\n                    int temp = grid[i][j];\\n                    while (temp % 5 == 0) {\\n                        f[i][j]++;\\n                        temp /= 5;\\n                    }\\n                }\\n                if (grid[i][j] % 2 == 0) {\\n                    int temp = grid[i][j];\\n                    while (temp % 2 == 0) {\\n                        s[i][j]++;\\n                        temp /= 2;\\n                    }\\n                }\\n                if (j > 0) {\\n                    fh[i][j] = fh[i][j-1] + f[i][j];\\n                    sh[i][j] = sh[i][j-1] + s[i][j];\\n                }\\n                else {\\n                    fh[i][j] = f[i][j];\\n                    sh[i][j] = s[i][j];\\n                }\\n                if (i > 0) {\\n                    fv[i][j] = fv[i-1][j] + f[i][j];\\n                    sv[i][j] = sv[i-1][j] + s[i][j];\\n                }\\n                else {\\n                    fv[i][j] = f[i][j];\\n                    sv[i][j] = s[i][j];\\n                }\\n            }\\n        }\\n        \\n\\t\\t// Form the number of 2s and 5s for 4 directions of each cell\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                for (int k = 0; k < 4; k++) {\\n                    int fc = 0, sc = 0;\\n                    \\n                    if (k == 0) {\\n                        if (i > 0) {\\n                            fc = fv[i-1][j];\\n                            sc = sv[i-1][j];\\n                        }\\n                    }\\n                    else if (k == 1) {\\n                        fc = fh[i][n-1] - fh[i][j];\\n                        sc = sh[i][n-1] - sh[i][j];\\n                    }\\n                    else if (k == 2) {\\n                        fc = fv[m-1][j] - fv[i][j];\\n                        sc = sv[m-1][j] - sv[i][j];\\n                    }\\n                    else {\\n                        if (j > 0) {\\n                            fc = fh[i][j-1];\\n                            sc = sh[i][j-1];\\n                        }\\n                    }\\n                    d[i*n+j][k][0] = fc;\\n                    d[i*n+j][k][1] = sc;\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n\\t\\t// Go through each cell and possible combinations of every 2 directions\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                for (int k = 0; k < 4; k++) {\\n                    for (int l = k+1; l < 4; l++) {\\n                        int cur = min(d[i*n+j][k][0] + d[i*n+j][l][0] + f[i][j], d[i*n+j][k][1] + d[i*n+j][l][1] + s[i][j]);\\n                        ans = max(ans, cur);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955959,
                "title": "java-prefix-sum-with-clear-explanation-and-code",
                "content": "**How to get trailing zeros of a number** :\\nWe need to find power of 10 i.e. power of (2\\\\*5) i.e. minimum of `(power of 2, power of 5)`\\nWe need to find power of 2 and 5 for each grid[i][j] that divides it(i.e. remainder = 0), then minimum of power of 2 and 5 is the number of trailing zeros\\nexample:\\n```\\n1200 = 2^4*5^2*3\\n```\\nthere are two trailing zeros because minimum power of 2 and 5 is 2\\n\\n**How to calculate trailling zeros of a turn**\\nTurn consists of two directions: horizontal and vertical, for every cell there are 4 options:\\n1. horizontal left and vertical up\\n2. horizontal left and vertical down\\n3. horizontal right and vertical up\\n4. horizontal right and vertical down\\n\\nif we keep prefix sum of horizontal and vertical rows we can easily calculate these 4 cases.\\nWe also need to make sure we are not counting power of one cell more than once while summing power of horizontal and vertical because current cell is common for both directions. \\nTherefore, in code below **horizontal directions are kept inclusive** and **vertical directions are kept exlusive**\\nThe comments in code shows what would have been the calculations if it\\'s not been exlusive for vertical directions\\n```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        int[][][] h = new int[n+1][m+1][2]; \\n        \\n        /*\\n        direction:\\n        ---o\\n        \\n        horSum from col h1 to h2 in ith row = h[i][h1+1]-h[i][h2]\\n        */\\n        for(int i = 0; i < n; i ++) {\\n             for(int j = 0; j < m; j ++) {\\n                h[i][j+1][0] = h[i][j][0] + power(grid[i][j], 2);\\n                h[i][j+1][1] = h[i][j][1] + power(grid[i][j], 5);\\n            }\\n        }\\n        int[][][] v = new int[n+1][m+1][2]; \\n        /*\\n        direction:\\n        |\\n        |\\n        o\\n        verSum from row v1 to v2 in jth col = v[v1+1][j]-v[v2][j]\\n        */\\n        for(int i = 0; i < n; i ++) {\\n             for(int j = 0; j < m; j ++) {\\n                v[i+1][j][0] = v[i][j][0] + power(grid[i][j], 2);\\n                v[i+1][j][1] = v[i][j][1] + power(grid[i][j], 5);\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < n; i ++) {\\n            for(int j = 0; j < m; j ++) {\\n                int l2 = h[i][j+1][0],              l5 = h[i][j+1][1];\\n                int r2 = h[i][m][0]-h[i][j][0],     r5 = h[i][m][1]-h[i][j][1];\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\tu and d directions are calculated exlusively of current cell\\n\\t\\t\\t\\ti.e. if we include current cell we would have u2 = v[i+1][j][0], d2 = v[n][j][0]-v[i][j][0]\\n\\t\\t\\t\\tbut we have to exlude cell (i,j) from up and down calculations because it was included in left and right calculations therefore it should be as following\\n\\t\\t\\t\\t*/\\n                int u2 = v[i][j][0],                u5 = v[i][j][1];\\n                int d2 = v[n][j][0]-v[i+1][j][0],   d5 = v[n][j][1]-v[i+1][j][1];\\n                \\n                int lu2 = l2+u2;\\n                int lu5 = l5+u5;\\n                int ld2 = l2+d2;\\n                int ld5 = l5+d5;\\n                int ru2 = r2+u2;\\n                int ru5 = r5+u5;\\n                int rd2 = r2+d2;\\n                int rd5 = r5+d5;\\n                \\n                res = Math.max(res, Math.min(lu2,lu5));\\n                res = Math.max(res, Math.min(ld2,ld5));\\n                res = Math.max(res, Math.min(ru2,ru5));\\n                res = Math.max(res, Math.min(rd2,rd5));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int power(int num, int x) {\\n        int p = x;\\n        int c = 0;\\n        while(num%p == 0) {\\n            p = p*x;\\n            c ++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\n1200 = 2^4*5^2*3\\n```\n```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        int[][][] h = new int[n+1][m+1][2]; \\n        \\n        /*\\n        direction:\\n        ---o\\n        \\n        horSum from col h1 to h2 in ith row = h[i][h1+1]-h[i][h2]\\n        */\\n        for(int i = 0; i < n; i ++) {\\n             for(int j = 0; j < m; j ++) {\\n                h[i][j+1][0] = h[i][j][0] + power(grid[i][j], 2);\\n                h[i][j+1][1] = h[i][j][1] + power(grid[i][j], 5);\\n            }\\n        }\\n        int[][][] v = new int[n+1][m+1][2]; \\n        /*\\n        direction:\\n        |\\n        |\\n        o\\n        verSum from row v1 to v2 in jth col = v[v1+1][j]-v[v2][j]\\n        */\\n        for(int i = 0; i < n; i ++) {\\n             for(int j = 0; j < m; j ++) {\\n                v[i+1][j][0] = v[i][j][0] + power(grid[i][j], 2);\\n                v[i+1][j][1] = v[i][j][1] + power(grid[i][j], 5);\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < n; i ++) {\\n            for(int j = 0; j < m; j ++) {\\n                int l2 = h[i][j+1][0],              l5 = h[i][j+1][1];\\n                int r2 = h[i][m][0]-h[i][j][0],     r5 = h[i][m][1]-h[i][j][1];\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\tu and d directions are calculated exlusively of current cell\\n\\t\\t\\t\\ti.e. if we include current cell we would have u2 = v[i+1][j][0], d2 = v[n][j][0]-v[i][j][0]\\n\\t\\t\\t\\tbut we have to exlude cell (i,j) from up and down calculations because it was included in left and right calculations therefore it should be as following\\n\\t\\t\\t\\t*/\\n                int u2 = v[i][j][0],                u5 = v[i][j][1];\\n                int d2 = v[n][j][0]-v[i+1][j][0],   d5 = v[n][j][1]-v[i+1][j][1];\\n                \\n                int lu2 = l2+u2;\\n                int lu5 = l5+u5;\\n                int ld2 = l2+d2;\\n                int ld5 = l5+d5;\\n                int ru2 = r2+u2;\\n                int ru5 = r5+u5;\\n                int rd2 = r2+d2;\\n                int rd5 = r5+d5;\\n                \\n                res = Math.max(res, Math.min(lu2,lu5));\\n                res = Math.max(res, Math.min(ld2,ld5));\\n                res = Math.max(res, Math.min(ru2,ru5));\\n                res = Math.max(res, Math.min(rd2,rd5));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int power(int num, int x) {\\n        int p = x;\\n        int c = 0;\\n        while(num%p == 0) {\\n            p = p*x;\\n            c ++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955929,
                "title": "java-not-concise-but-beats-100-solution",
                "content": "Idea is straightforward, just need to calculate the number of factor 2 and 5. But the code is, hmmm, not very simple.\\n\\n```\\n    /*\\n    Runtime: 148 ms, faster than 100.00% of Java online submissions for Maximum Trailing Zeros in a Cornered Path.\\n    Memory Usage: 83.5 MB, less than 100.00% of Java online submissions for Maximum Trailing Zeros in a Cornered Path.\\n     */\\n    public int maxTrailingZeros(int[][] grid) {\\n        // twoAndFives[i][j][0] is the number of factor 2 of grid[i][j]\\n        // twoAndFives[i][j][1] is the number of factor 5 of grid[i][j]\\n        int[][][] twoAndFives = new int[grid.length][grid[0].length][2];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                int num = grid[i][j];\\n                int twos = 0;\\n                int fives = 0;\\n                while (num % 2 == 0) {\\n                    num /= 2;\\n                    twos++;\\n                }\\n                while (num % 5 == 0) {\\n                    num /= 5;\\n                    fives++;\\n                }\\n                twoAndFives[i][j] = new int[] {twos, fives};\\n            }\\n        }\\n\\n        // prefix[i][j][0] is the number of factor 2 from left\\n        // prefix[i][j][1] is the number of factor 5 from left\\n        // prefix[i][j][2] is the number of factor 2 from right\\n        // prefix[i][j][3] is the number of factor 5 from right\\n        // prefix[i][j][4] is the number of factor 2 from top\\n        // prefix[i][j][5] is the number of factor 5 from top\\n        // prefix[i][j][6] is the number of factor 2 from bottom\\n        // prefix[i][j][7] is the number of factor 5 from bottom\\n        int[][][] prefix = new int[grid.length][grid[0].length][8];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (j == 0) {\\n                    prefix[i][j][0] = twoAndFives[i][j][0];\\n                    prefix[i][j][1] = twoAndFives[i][j][1];\\n                } else {\\n                    prefix[i][j][0] = prefix[i][j-1][0] + twoAndFives[i][j][0];\\n                    prefix[i][j][1] = prefix[i][j-1][1] + twoAndFives[i][j][1];\\n                }\\n\\n                if (i == 0) {\\n                    prefix[i][j][4] = twoAndFives[i][j][0];\\n                    prefix[i][j][5] = twoAndFives[i][j][1];\\n                } else {\\n                    prefix[i][j][4] = prefix[i-1][j][4] + twoAndFives[i][j][0];\\n                    prefix[i][j][5] = prefix[i-1][j][5] + twoAndFives[i][j][1];\\n                }\\n            }\\n        }\\n\\n        for (int i = grid.length - 1; i >= 0; i--) {\\n            for (int j = grid[0].length - 1; j >= 0; j--) {\\n                if (j == grid[0].length - 1) {\\n                    prefix[i][j][2] = twoAndFives[i][j][0];\\n                    prefix[i][j][3] = twoAndFives[i][j][1];\\n                } else {\\n                    prefix[i][j][2] = prefix[i][j+1][2] + twoAndFives[i][j][0];\\n                    prefix[i][j][3] = prefix[i][j+1][3] + twoAndFives[i][j][1];\\n                }\\n\\n                if (i == grid.length - 1) {\\n                    prefix[i][j][6] = twoAndFives[i][j][0];\\n                    prefix[i][j][7] = twoAndFives[i][j][1];\\n                } else {\\n                    prefix[i][j][6] = prefix[i+1][j][6] + twoAndFives[i][j][0];\\n                    prefix[i][j][7] = prefix[i+1][j][7] + twoAndFives[i][j][1];\\n                }\\n            }\\n        }\\n\\n        int max = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                max = Math.max(max, Math.min(prefix[i][j][0] + prefix[i][j][4] - twoAndFives[i][j][0], prefix[i][j][1] + prefix[i][j][5] - twoAndFives[i][j][1]));\\n                max = Math.max(max, Math.min(prefix[i][j][0] + prefix[i][j][6] - twoAndFives[i][j][0], prefix[i][j][1] + prefix[i][j][7] - twoAndFives[i][j][1]));\\n                max = Math.max(max, Math.min(prefix[i][j][2] + prefix[i][j][4] - twoAndFives[i][j][0], prefix[i][j][3] + prefix[i][j][5] - twoAndFives[i][j][1]));\\n                max = Math.max(max, Math.min(prefix[i][j][2] + prefix[i][j][6] - twoAndFives[i][j][0], prefix[i][j][3] + prefix[i][j][7] - twoAndFives[i][j][1]));\\n            }\\n        }\\n\\n        return max;\\n    }\\n```",
                "solutionTags": [
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\n    /*\\n    Runtime: 148 ms, faster than 100.00% of Java online submissions for Maximum Trailing Zeros in a Cornered Path.\\n    Memory Usage: 83.5 MB, less than 100.00% of Java online submissions for Maximum Trailing Zeros in a Cornered Path.\\n     */\\n    public int maxTrailingZeros(int[][] grid) {\\n        // twoAndFives[i][j][0] is the number of factor 2 of grid[i][j]\\n        // twoAndFives[i][j][1] is the number of factor 5 of grid[i][j]\\n        int[][][] twoAndFives = new int[grid.length][grid[0].length][2];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                int num = grid[i][j];\\n                int twos = 0;\\n                int fives = 0;\\n                while (num % 2 == 0) {\\n                    num /= 2;\\n                    twos++;\\n                }\\n                while (num % 5 == 0) {\\n                    num /= 5;\\n                    fives++;\\n                }\\n                twoAndFives[i][j] = new int[] {twos, fives};\\n            }\\n        }\\n\\n        // prefix[i][j][0] is the number of factor 2 from left\\n        // prefix[i][j][1] is the number of factor 5 from left\\n        // prefix[i][j][2] is the number of factor 2 from right\\n        // prefix[i][j][3] is the number of factor 5 from right\\n        // prefix[i][j][4] is the number of factor 2 from top\\n        // prefix[i][j][5] is the number of factor 5 from top\\n        // prefix[i][j][6] is the number of factor 2 from bottom\\n        // prefix[i][j][7] is the number of factor 5 from bottom\\n        int[][][] prefix = new int[grid.length][grid[0].length][8];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (j == 0) {\\n                    prefix[i][j][0] = twoAndFives[i][j][0];\\n                    prefix[i][j][1] = twoAndFives[i][j][1];\\n                } else {\\n                    prefix[i][j][0] = prefix[i][j-1][0] + twoAndFives[i][j][0];\\n                    prefix[i][j][1] = prefix[i][j-1][1] + twoAndFives[i][j][1];\\n                }\\n\\n                if (i == 0) {\\n                    prefix[i][j][4] = twoAndFives[i][j][0];\\n                    prefix[i][j][5] = twoAndFives[i][j][1];\\n                } else {\\n                    prefix[i][j][4] = prefix[i-1][j][4] + twoAndFives[i][j][0];\\n                    prefix[i][j][5] = prefix[i-1][j][5] + twoAndFives[i][j][1];\\n                }\\n            }\\n        }\\n\\n        for (int i = grid.length - 1; i >= 0; i--) {\\n            for (int j = grid[0].length - 1; j >= 0; j--) {\\n                if (j == grid[0].length - 1) {\\n                    prefix[i][j][2] = twoAndFives[i][j][0];\\n                    prefix[i][j][3] = twoAndFives[i][j][1];\\n                } else {\\n                    prefix[i][j][2] = prefix[i][j+1][2] + twoAndFives[i][j][0];\\n                    prefix[i][j][3] = prefix[i][j+1][3] + twoAndFives[i][j][1];\\n                }\\n\\n                if (i == grid.length - 1) {\\n                    prefix[i][j][6] = twoAndFives[i][j][0];\\n                    prefix[i][j][7] = twoAndFives[i][j][1];\\n                } else {\\n                    prefix[i][j][6] = prefix[i+1][j][6] + twoAndFives[i][j][0];\\n                    prefix[i][j][7] = prefix[i+1][j][7] + twoAndFives[i][j][1];\\n                }\\n            }\\n        }\\n\\n        int max = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                max = Math.max(max, Math.min(prefix[i][j][0] + prefix[i][j][4] - twoAndFives[i][j][0], prefix[i][j][1] + prefix[i][j][5] - twoAndFives[i][j][1]));\\n                max = Math.max(max, Math.min(prefix[i][j][0] + prefix[i][j][6] - twoAndFives[i][j][0], prefix[i][j][1] + prefix[i][j][7] - twoAndFives[i][j][1]));\\n                max = Math.max(max, Math.min(prefix[i][j][2] + prefix[i][j][4] - twoAndFives[i][j][0], prefix[i][j][3] + prefix[i][j][5] - twoAndFives[i][j][1]));\\n                max = Math.max(max, Math.min(prefix[i][j][2] + prefix[i][j][6] - twoAndFives[i][j][0], prefix[i][j][3] + prefix[i][j][7] - twoAndFives[i][j][1]));\\n            }\\n        }\\n\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955915,
                "title": "c-presum-factor-2-and-5-brute-force-beats-100-100",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<pair<int, int>>> fact(m, vector<pair<int, int>>(n, {0,0})); // grid[i][j] -> 2, 5\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                int two = 0;\\n                int five = 0;\\n                int num = grid[i][j];\\n                while(num % 2 == 0){\\n                    num /= 2;\\n                    two++;\\n                }\\n                num = grid[i][j];\\n                while(num % 5 == 0){\\n                    num /= 5;\\n                    five++;\\n                }\\n                fact[i][j] = {two, five};\\n            }\\n        }\\n        \\n        \\n        // \\u6BCF\\u4E2A\\u70B9\\u6709\\u6A2A\\u5411\\u3001\\u7EB5\\u5411\\u524D\\u7F00\\u548C\\uFF0C first\\u6A2A\\u5411,second\\u7EB5\\u5411\\n        // presum2[i][j]: \\u7B2Ci\\u884C\\uFF0C[0....j-1]\\u7684fact\\'s 2\\u7684\\u548C\\n        vector<vector<pair<int, int>>> presum2(m+1, vector<pair<int, int>>(n+1, {0, 0})), \\n        presum5(m+1, vector<pair<int, int>>(n+1, {0, 0}));\\n        for(int i = 0; i < m; i++){\\n            for(int j = 1; j <= n; j++){\\n                presum2[i][j].first = presum2[i][j-1].first + fact[i][j-1].first;\\n                presum5[i][j].first = presum5[i][j-1].first + fact[i][j-1].second;\\n            }\\n        }\\n        \\n        for(int j = 0; j < n; j++){\\n            for(int i = 1; i <= m; i++){\\n                presum2[i][j].second = presum2[i-1][j].second + fact[i-1][j].first;\\n                presum5[i][j].second = presum5[i-1][j].second + fact[i-1][j].second;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                // lf + up\\n                ans = max(ans, min(presum2[i][j+1].first + presum2[i+1][j].second - fact[i][j].first,\\n                                   presum5[i][j+1].first + presum5[i+1][j].second - fact[i][j].second));\\n                \\n                // rt + up\\n                ans = max(ans, min(presum2[i][n].first - presum2[i][j].first  +  presum2[i+1][j].second - fact[i][j].first,\\n                                   presum5[i][n].first - presum5[i][j].first  +  presum5[i+1][j].second - fact[i][j].second));\\n                \\n                // lf + down\\n                ans = max(ans, min(presum2[i][j+1].first  +  presum2[m][j].second - presum2[i][j].second - fact[i][j].first,\\n                                   presum5[i][j+1].first  +  presum5[m][j].second - presum5[i][j].second - fact[i][j].second));\\n                \\n                // down + rt                         \\n                ans = max(ans, min(presum2[i][n].first - presum2[i][j].first  +  presum2[m][j].second - presum2[i][j].second - fact[i][j].first,\\n                                 presum5[i][n].first - presum5[i][j].first  +  presum5[m][j].second - presum5[i][j].second - fact[i][j].second));\\n                \\n\\t\\t\\t\\t//  vertical and horizon\\n                ans = max(ans, max(min(presum2[i][n].first, presum5[i][n].first),\\n                                   min(presum2[m][j].second, presum5[m][j].second)));\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<pair<int, int>>> fact(m, vector<pair<int, int>>(n, {0,0})); // grid[i][j] -> 2, 5\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                int two = 0;\\n                int five = 0;\\n                int num = grid[i][j];\\n                while(num % 2 == 0){\\n                    num /= 2;\\n                    two++;\\n                }\\n                num = grid[i][j];\\n                while(num % 5 == 0){\\n                    num /= 5;\\n                    five++;\\n                }\\n                fact[i][j] = {two, five};\\n            }\\n        }\\n        \\n        \\n        // \\u6BCF\\u4E2A\\u70B9\\u6709\\u6A2A\\u5411\\u3001\\u7EB5\\u5411\\u524D\\u7F00\\u548C\\uFF0C first\\u6A2A\\u5411,second\\u7EB5\\u5411\\n        // presum2[i][j]: \\u7B2Ci\\u884C\\uFF0C[0....j-1]\\u7684fact\\'s 2\\u7684\\u548C\\n        vector<vector<pair<int, int>>> presum2(m+1, vector<pair<int, int>>(n+1, {0, 0})), \\n        presum5(m+1, vector<pair<int, int>>(n+1, {0, 0}));\\n        for(int i = 0; i < m; i++){\\n            for(int j = 1; j <= n; j++){\\n                presum2[i][j].first = presum2[i][j-1].first + fact[i][j-1].first;\\n                presum5[i][j].first = presum5[i][j-1].first + fact[i][j-1].second;\\n            }\\n        }\\n        \\n        for(int j = 0; j < n; j++){\\n            for(int i = 1; i <= m; i++){\\n                presum2[i][j].second = presum2[i-1][j].second + fact[i-1][j].first;\\n                presum5[i][j].second = presum5[i-1][j].second + fact[i-1][j].second;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                // lf + up\\n                ans = max(ans, min(presum2[i][j+1].first + presum2[i+1][j].second - fact[i][j].first,\\n                                   presum5[i][j+1].first + presum5[i+1][j].second - fact[i][j].second));\\n                \\n                // rt + up\\n                ans = max(ans, min(presum2[i][n].first - presum2[i][j].first  +  presum2[i+1][j].second - fact[i][j].first,\\n                                   presum5[i][n].first - presum5[i][j].first  +  presum5[i+1][j].second - fact[i][j].second));\\n                \\n                // lf + down\\n                ans = max(ans, min(presum2[i][j+1].first  +  presum2[m][j].second - presum2[i][j].second - fact[i][j].first,\\n                                   presum5[i][j+1].first  +  presum5[m][j].second - presum5[i][j].second - fact[i][j].second));\\n                \\n                // down + rt                         \\n                ans = max(ans, min(presum2[i][n].first - presum2[i][j].first  +  presum2[m][j].second - presum2[i][j].second - fact[i][j].first,\\n                                 presum5[i][n].first - presum5[i][j].first  +  presum5[m][j].second - presum5[i][j].second - fact[i][j].second));\\n                \\n\\t\\t\\t\\t//  vertical and horizon\\n                ans = max(ans, max(min(presum2[i][n].first, presum5[i][n].first),\\n                                   min(presum2[m][j].second, presum5[m][j].second)));\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955842,
                "title": "clean-java-solution-count-2-and-5-prime-factors-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][][] productGoingRight = new int[m][n][2];\\n        int[][][] productGoingLeft = new int[m][n][2];\\n        int[][][] productGoingUp = new int[m][n][2];\\n        int[][][] productGoingDown = new int[m][n][2];\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0, k = n-1; j < n; j++, k--) {\\n                int[] prevLeft = (j-1 >= 0 ? productGoingLeft[i][j-1] : new int[]{0,0});\\n                productGoingLeft[i][j][0] = prevLeft[0] + countPrimeFactor(grid[i][j],2);\\n                productGoingLeft[i][j][1] = prevLeft[1] + countPrimeFactor(grid[i][j],5);\\n                \\n                int[] prevRight = (k+1 < n ? productGoingRight[i][k+1] : new int[]{0,0});\\n                productGoingRight[i][k][0] = prevRight[0] + countPrimeFactor(grid[i][k],2);\\n                productGoingRight[i][k][1] = prevRight[1] + countPrimeFactor(grid[i][k],5);\\n            }\\n        }\\n        \\n        for(int j = 0; j < n; j++) {\\n            for(int i = 0, k = m-1; i < m; i++, k--) {\\n                int[] prevUp = (i-1 >= 0 ? productGoingUp[i-1][j] : new int[]{0,0});\\n                productGoingUp[i][j][0] = prevUp[0] + countPrimeFactor(grid[i][j],2);\\n                productGoingUp[i][j][1] = prevUp[1] + countPrimeFactor(grid[i][j],5);\\n                \\n                int[] prevDown = (k+1 < m ? productGoingDown[k+1][j] : new int[]{0,0});\\n                productGoingDown[k][j][0] = prevDown[0] + countPrimeFactor(grid[k][j],2);\\n                productGoingDown[k][j][1] = prevDown[1] + countPrimeFactor(grid[k][j],5);\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int[] right = (j+1 < n ? productGoingRight[i][j+1] : new int[]{0,0});\\n                int[] left = (j-1 >= 0 ? productGoingLeft[i][j-1] : new int[]{0,0});\\n                int[] up = productGoingUp[i][j];\\n                int[] down = productGoingDown[i][j];\\n                \\n                ans = Math.max(ans,Math.min(up[0]+right[0],up[1]+right[1]));\\n                ans = Math.max(ans,Math.min(up[0]+left[0],up[1]+left[1]));\\n                ans = Math.max(ans,Math.min(down[0]+right[0],down[1]+right[1]));\\n                ans = Math.max(ans,Math.min(down[0]+left[0],down[1]+left[1]));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int countPrimeFactor(int n, int prime) {\\n        int c = 0;\\n        while(n % prime == 0) {\\n            c++;\\n            n /= prime;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][][] productGoingRight = new int[m][n][2];\\n        int[][][] productGoingLeft = new int[m][n][2];\\n        int[][][] productGoingUp = new int[m][n][2];\\n        int[][][] productGoingDown = new int[m][n][2];\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0, k = n-1; j < n; j++, k--) {\\n                int[] prevLeft = (j-1 >= 0 ? productGoingLeft[i][j-1] : new int[]{0,0});\\n                productGoingLeft[i][j][0] = prevLeft[0] + countPrimeFactor(grid[i][j],2);\\n                productGoingLeft[i][j][1] = prevLeft[1] + countPrimeFactor(grid[i][j],5);\\n                \\n                int[] prevRight = (k+1 < n ? productGoingRight[i][k+1] : new int[]{0,0});\\n                productGoingRight[i][k][0] = prevRight[0] + countPrimeFactor(grid[i][k],2);\\n                productGoingRight[i][k][1] = prevRight[1] + countPrimeFactor(grid[i][k],5);\\n            }\\n        }\\n        \\n        for(int j = 0; j < n; j++) {\\n            for(int i = 0, k = m-1; i < m; i++, k--) {\\n                int[] prevUp = (i-1 >= 0 ? productGoingUp[i-1][j] : new int[]{0,0});\\n                productGoingUp[i][j][0] = prevUp[0] + countPrimeFactor(grid[i][j],2);\\n                productGoingUp[i][j][1] = prevUp[1] + countPrimeFactor(grid[i][j],5);\\n                \\n                int[] prevDown = (k+1 < m ? productGoingDown[k+1][j] : new int[]{0,0});\\n                productGoingDown[k][j][0] = prevDown[0] + countPrimeFactor(grid[k][j],2);\\n                productGoingDown[k][j][1] = prevDown[1] + countPrimeFactor(grid[k][j],5);\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int[] right = (j+1 < n ? productGoingRight[i][j+1] : new int[]{0,0});\\n                int[] left = (j-1 >= 0 ? productGoingLeft[i][j-1] : new int[]{0,0});\\n                int[] up = productGoingUp[i][j];\\n                int[] down = productGoingDown[i][j];\\n                \\n                ans = Math.max(ans,Math.min(up[0]+right[0],up[1]+right[1]));\\n                ans = Math.max(ans,Math.min(up[0]+left[0],up[1]+left[1]));\\n                ans = Math.max(ans,Math.min(down[0]+right[0],down[1]+right[1]));\\n                ans = Math.max(ans,Math.min(down[0]+left[0],down[1]+left[1]));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int countPrimeFactor(int n, int prime) {\\n        int c = 0;\\n        while(n % prime == 0) {\\n            c++;\\n            n /= prime;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955813,
                "title": "java-tried-my-best-to-give-this-shortest-code",
                "content": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int row = grid.length, col = grid[0].length;\\n        int[][][] ver = new int[row + 1][col + 1][2];\\n        int[][][] hir = new int[row + 1][col + 1][2];\\n        for (int i = 1; i <= row; i++) {\\n            for (int j = 1; j <= col; j++) {\\n                assign(hir[i][j], hir[i][j - 1], count(grid[i - 1][j - 1]));\\n            }\\n        }\\n        \\n        for (int j = 1; j <= col; j++) {\\n            for (int i = 1; i <= row; i++) {\\n                assign(ver[i][j], ver[i - 1][j], count(grid[i - 1][j - 1]));\\n            }\\n        }\\n        \\n        int max = 0;\\n        for (int i = 1; i <= row; i++) {\\n            for (int j = 1; j <= col; j++) {\\n                max = Math.max(max, helper(i, 0, i, j - 1, i, j, row, j, ver, hir, grid[i - 1][j - 1])); \\n                max = Math.max(max, helper(i, 0, i, j - 1, 0, j, i - 1, j, ver, hir, grid[i - 1][j - 1]));\\n                max = Math.max(max, helper(i, j, i, col, i, j, row, j, ver, hir, grid[i - 1][j - 1]));\\n                max = Math.max(max, helper(i, j, i, col, 0, j, i - 1, j, ver, hir, grid[i - 1][j - 1]));\\n            } \\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int helper(int row1, int col1, int row2, int col2, int row3, int col3, int row4, int col4, int[][][] ver, int[][][] hir, int turn){\\n        int[] sumArr = new int[2];\\n        int[] count = count(turn);\\n        for (int i = 0; i < 2; i++) {\\n            sumArr[i] = count[i] + hir[row2][col2][i] - hir[row1][col1][i] + ver[row4][col4][i] - ver[row3][col3][i];\\n        }\\n        return Math.min(sumArr[0], sumArr[1]);\\n    }\\n    \\n    private int[] count(int num) {\\n        int[] ret = new int[2];\\n        while (num % 5 == 0) {\\n            ret[1]++;\\n            num /= 5;\\n        }\\n        while (num % 2 == 0) {\\n            ret[0]++;\\n            num /= 2;\\n        }\\n        return ret;\\n    }\\n    \\n    \\n    private void assign(int[] cur, int[] pre, int[] carry) {\\n        cur[0] = pre[0] + carry[0];\\n        cur[1] = pre[1] + carry[1];\\n    }\\n}\\n```\\n\\nHope it helps",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int row = grid.length, col = grid[0].length;\\n        int[][][] ver = new int[row + 1][col + 1][2];\\n        int[][][] hir = new int[row + 1][col + 1][2];\\n        for (int i = 1; i <= row; i++) {\\n            for (int j = 1; j <= col; j++) {\\n                assign(hir[i][j], hir[i][j - 1], count(grid[i - 1][j - 1]));\\n            }\\n        }\\n        \\n        for (int j = 1; j <= col; j++) {\\n            for (int i = 1; i <= row; i++) {\\n                assign(ver[i][j], ver[i - 1][j], count(grid[i - 1][j - 1]));\\n            }\\n        }\\n        \\n        int max = 0;\\n        for (int i = 1; i <= row; i++) {\\n            for (int j = 1; j <= col; j++) {\\n                max = Math.max(max, helper(i, 0, i, j - 1, i, j, row, j, ver, hir, grid[i - 1][j - 1])); \\n                max = Math.max(max, helper(i, 0, i, j - 1, 0, j, i - 1, j, ver, hir, grid[i - 1][j - 1]));\\n                max = Math.max(max, helper(i, j, i, col, i, j, row, j, ver, hir, grid[i - 1][j - 1]));\\n                max = Math.max(max, helper(i, j, i, col, 0, j, i - 1, j, ver, hir, grid[i - 1][j - 1]));\\n            } \\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int helper(int row1, int col1, int row2, int col2, int row3, int col3, int row4, int col4, int[][][] ver, int[][][] hir, int turn){\\n        int[] sumArr = new int[2];\\n        int[] count = count(turn);\\n        for (int i = 0; i < 2; i++) {\\n            sumArr[i] = count[i] + hir[row2][col2][i] - hir[row1][col1][i] + ver[row4][col4][i] - ver[row3][col3][i];\\n        }\\n        return Math.min(sumArr[0], sumArr[1]);\\n    }\\n    \\n    private int[] count(int num) {\\n        int[] ret = new int[2];\\n        while (num % 5 == 0) {\\n            ret[1]++;\\n            num /= 5;\\n        }\\n        while (num % 2 == 0) {\\n            ret[0]++;\\n            num /= 2;\\n        }\\n        return ret;\\n    }\\n    \\n    \\n    private void assign(int[] cur, int[] pre, int[] carry) {\\n        cur[0] = pre[0] + carry[0];\\n        cur[1] = pre[1] + carry[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955780,
                "title": "c-accumulated-2-5-10-from-4-directions",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n        int r = grid.size();       \\n        int l = grid[0].size();\\n      \\n        vector<vector<int>> c(r * l, vector<int>());\\n        vector<vector<int>> up(r * l, vector<int>()), down(r * l, vector<int>()), left(r * l, vector<int>()), right (r * l, vector<int>());\\n \\n        for (int i = 0; i < r; i++)\\n        {\\n            for (int j = 0; j < l; j++)\\n            {\\n                int ind = i * l + j;\\n                if (c[ind].size() == 0)\\n                {\\n                    c[ind] = helper(grid[i][j]);\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < r; i++ )\\n        {\\n            int count5 = 0, count2 = 0, count10 = 0;\\n            for (int j = 0; j < l; j++)\\n            {\\n                    count5 += c[i * l + j][1];\\n                    count2 += c[i * l + j][0];\\n                    count10 += c[i * l + j][2];\\n                    left[i * l + j] = {count2, count5, count10};\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < r; i++ )\\n        {\\n            int count5 = 0, count2 = 0, count10 = 0;\\n            for (int j = l - 1; j >= 0; j--)\\n            {\\n                    count5 += c[i * l + j][1];\\n                    count2 += c[i * l + j][0];\\n                    count10 += c[i * l + j][2];\\n                    right[i * l + j] = {count2, count5, count10};\\n            }\\n        }\\n        \\n        for (int j = 0; j < l; j++)\\n        {\\n            int count5 = 0, count2 = 0, count10 = 0;\\n            for(int i = 0 ; i < r; i++ )\\n            {\\n                    count5 += c[i * l + j][1];\\n                    count2 += c[i * l + j][0];\\n                    count10 += c[i *l + j][2];\\n                    up[i * l + j] = {count2, count5, count10};   \\n            }\\n        }\\n        \\n        for (int j = 0; j < l; j++)\\n        {\\n            int count5 = 0, count2 = 0, count10 = 0;\\n            for(int i = r -1 ; i >= 0; i-- )\\n            {\\n                    count5 += c[i * l + j][1];\\n                    count2 += c[i * l + j][0];\\n                    count10 += c[i * l + j][2];\\n                    down[i * l + j] = {count2, count5, count10};\\n            }\\n        }\\n        \\n        int ret = 0;\\n        for (int i = 0; i < r; i ++)\\n        {\\n            for (int j = 0; j < l; j++)\\n            {\\n                int ind = i * l + j;\\n                {\\n                    int a2 = left[ind][0] + up[ind][0] - c[ind][0];\\n                    int a5 = left[ind][1] + up[ind][1] - c[ind][1];\\n                    int a10 = left[ind][2] + up[ind][2] - c[ind][2];\\n                    \\n                    ret = max(ret, min(a2, a5) + a10);\\n                }\\n                \\n                {\\n                    int a2 = left[ind][0] + down[ind][0] - c[ind][0];\\n                    int a5 = left[ind][1] + down[ind][1] - c[ind][1];\\n                    int a10 = left[ind][2] + down[ind][2] - c[ind][2];\\n                    \\n                    ret = max(ret, min(a2, a5) + a10);\\n                }\\n                \\n                {\\n                    int a2 = right[ind][0] + up[ind][0] - c[ind][0];\\n                    int a5 = right[ind][1] + up[ind][1] - c[ind][1];\\n                    int a10 = right[ind][2] + up[ind][2] - c[ind][2];\\n                    \\n                    ret = max(ret, min(a2, a5) + a10);\\n                }\\n                \\n                {\\n                    int a2 = right[ind][0] + down[ind][0] - c[ind][0];\\n                    int a5 = right[ind][1] + down[ind][1] - c[ind][1];\\n                    int a10 = right[ind][2] + down[ind][2] - c[ind][2];\\n                    \\n                    ret = max(ret, min(a2, a5) + a10);\\n                }\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    vector<int> helper(int inp)\\n    {  \\n        int count5 = 0, count2 = 0, count10 = 0;\\n\\n        int input = inp;\\n        while(input != 0 && input % 10 == 0)\\n        {\\n            count10++;\\n            input = input / 10;\\n        }\\n\\n\\n        input = inp;\\n        while (input != 0  && input % 2 == 0)\\n        {\\n            count2 ++;\\n            input = input / 2;\\n        }\\n\\n        input = inp;\\n        while (input != 0  && input % 5 == 0)\\n        {\\n            count5++;\\n            input = input / 5;\\n        }\\n\\n        count5 -= count10;\\n        count2 -= count10;\\n\\n        return {count2, count5, count10};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n        int r = grid.size();       \\n        int l = grid[0].size();\\n      \\n        vector<vector<int>> c(r * l, vector<int>());\\n        vector<vector<int>> up(r * l, vector<int>()), down(r * l, vector<int>()), left(r * l, vector<int>()), right (r * l, vector<int>());\\n \\n        for (int i = 0; i < r; i++)\\n        {\\n            for (int j = 0; j < l; j++)\\n            {\\n                int ind = i * l + j;\\n                if (c[ind].size() == 0)\\n                {\\n                    c[ind] = helper(grid[i][j]);\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < r; i++ )\\n        {\\n            int count5 = 0, count2 = 0, count10 = 0;\\n            for (int j = 0; j < l; j++)\\n            {\\n                    count5 += c[i * l + j][1];\\n                    count2 += c[i * l + j][0];\\n                    count10 += c[i * l + j][2];\\n                    left[i * l + j] = {count2, count5, count10};\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < r; i++ )\\n        {\\n            int count5 = 0, count2 = 0, count10 = 0;\\n            for (int j = l - 1; j >= 0; j--)\\n            {\\n                    count5 += c[i * l + j][1];\\n                    count2 += c[i * l + j][0];\\n                    count10 += c[i * l + j][2];\\n                    right[i * l + j] = {count2, count5, count10};\\n            }\\n        }\\n        \\n        for (int j = 0; j < l; j++)\\n        {\\n            int count5 = 0, count2 = 0, count10 = 0;\\n            for(int i = 0 ; i < r; i++ )\\n            {\\n                    count5 += c[i * l + j][1];\\n                    count2 += c[i * l + j][0];\\n                    count10 += c[i *l + j][2];\\n                    up[i * l + j] = {count2, count5, count10};   \\n            }\\n        }\\n        \\n        for (int j = 0; j < l; j++)\\n        {\\n            int count5 = 0, count2 = 0, count10 = 0;\\n            for(int i = r -1 ; i >= 0; i-- )\\n            {\\n                    count5 += c[i * l + j][1];\\n                    count2 += c[i * l + j][0];\\n                    count10 += c[i * l + j][2];\\n                    down[i * l + j] = {count2, count5, count10};\\n            }\\n        }\\n        \\n        int ret = 0;\\n        for (int i = 0; i < r; i ++)\\n        {\\n            for (int j = 0; j < l; j++)\\n            {\\n                int ind = i * l + j;\\n                {\\n                    int a2 = left[ind][0] + up[ind][0] - c[ind][0];\\n                    int a5 = left[ind][1] + up[ind][1] - c[ind][1];\\n                    int a10 = left[ind][2] + up[ind][2] - c[ind][2];\\n                    \\n                    ret = max(ret, min(a2, a5) + a10);\\n                }\\n                \\n                {\\n                    int a2 = left[ind][0] + down[ind][0] - c[ind][0];\\n                    int a5 = left[ind][1] + down[ind][1] - c[ind][1];\\n                    int a10 = left[ind][2] + down[ind][2] - c[ind][2];\\n                    \\n                    ret = max(ret, min(a2, a5) + a10);\\n                }\\n                \\n                {\\n                    int a2 = right[ind][0] + up[ind][0] - c[ind][0];\\n                    int a5 = right[ind][1] + up[ind][1] - c[ind][1];\\n                    int a10 = right[ind][2] + up[ind][2] - c[ind][2];\\n                    \\n                    ret = max(ret, min(a2, a5) + a10);\\n                }\\n                \\n                {\\n                    int a2 = right[ind][0] + down[ind][0] - c[ind][0];\\n                    int a5 = right[ind][1] + down[ind][1] - c[ind][1];\\n                    int a10 = right[ind][2] + down[ind][2] - c[ind][2];\\n                    \\n                    ret = max(ret, min(a2, a5) + a10);\\n                }\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    vector<int> helper(int inp)\\n    {  \\n        int count5 = 0, count2 = 0, count10 = 0;\\n\\n        int input = inp;\\n        while(input != 0 && input % 10 == 0)\\n        {\\n            count10++;\\n            input = input / 10;\\n        }\\n\\n\\n        input = inp;\\n        while (input != 0  && input % 2 == 0)\\n        {\\n            count2 ++;\\n            input = input / 2;\\n        }\\n\\n        input = inp;\\n        while (input != 0  && input % 5 == 0)\\n        {\\n            count5++;\\n            input = input / 5;\\n        }\\n\\n        count5 -= count10;\\n        count2 -= count10;\\n\\n        return {count2, count5, count10};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955769,
                "title": "java-neat-code-presum-for-2-and-5",
                "content": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int[][][] up = new int[grid.length+2][2+grid[0].length][2];\\n        int[][][] down = new int[grid.length+2][2+grid[0].length][2];\\n        int[][][] left = new int[grid.length+2][2+grid[0].length][2];\\n        int[][][] right = new int[grid.length+2][2+grid[0].length][2];\\n        int[] digits = {2, 5};\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n               for (int k = 0; k < digits.length; k++ ){\\n                int d = getDigitNum(grid[i][j], digits[k]);\\n                up[i + 1][j + 1][k] = up[i][j + 1][k] + d;\\n                left[i + 1][j + 1][k] = left[i + 1][j][k] + d;\\n               }\\n            }\\n        }\\n        for (int i = grid.length - 1; i >= 0; i--) {\\n            for (int j = grid[i].length - 1; j >= 0; j--) {\\n                for (int k = 0; k < digits.length; k++ ){\\n                  int d = getDigitNum(grid[i][j], digits[k]);\\n                  down[i + 1][j + 1][k] = down[i + 2][j + 1][k] + d;\\n                  right[i + 1][j + 1][k] = right[i + 1][j + 2][k] + d;\\n                }      \\n          }\\n        }\\n        int ans = 0;\\n        for (int i = 1; i <= grid.length; i++) {\\n            for (int j = 1; j <= grid[0].length; j++) {\\n                ans = Math.max(Math.min(up[i][j][0] + left[i][j - 1][0], up[i][j][1] + left[i][j - 1][1]), ans);\\n                ans = Math.max(Math.min(up[i][j][0] + right[i][j + 1][0], up[i][j][1] + right[i][j + 1][1]), ans);\\n                ans = Math.max(Math.min(down[i][j][0] + left[i][j - 1][0], down[i][j][1] + left[i][j - 1][1]), ans);\\n                ans = Math.max(Math.min(down[i][j][0] + right[i][j + 1][0], down[i][j][1] + right[i][j + 1][1]), ans);\\n            }\\n        }\\n        return ans;\\n    }\\n    int getDigitNum(int num, int d) {\\n        int ans = 0;\\n        while (num > 0 && num % d == 0) {\\n            num /= d;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int[][][] up = new int[grid.length+2][2+grid[0].length][2];\\n        int[][][] down = new int[grid.length+2][2+grid[0].length][2];\\n        int[][][] left = new int[grid.length+2][2+grid[0].length][2];\\n        int[][][] right = new int[grid.length+2][2+grid[0].length][2];\\n        int[] digits = {2, 5};\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n               for (int k = 0; k < digits.length; k++ ){\\n                int d = getDigitNum(grid[i][j], digits[k]);\\n                up[i + 1][j + 1][k] = up[i][j + 1][k] + d;\\n                left[i + 1][j + 1][k] = left[i + 1][j][k] + d;\\n               }\\n            }\\n        }\\n        for (int i = grid.length - 1; i >= 0; i--) {\\n            for (int j = grid[i].length - 1; j >= 0; j--) {\\n                for (int k = 0; k < digits.length; k++ ){\\n                  int d = getDigitNum(grid[i][j], digits[k]);\\n                  down[i + 1][j + 1][k] = down[i + 2][j + 1][k] + d;\\n                  right[i + 1][j + 1][k] = right[i + 1][j + 2][k] + d;\\n                }      \\n          }\\n        }\\n        int ans = 0;\\n        for (int i = 1; i <= grid.length; i++) {\\n            for (int j = 1; j <= grid[0].length; j++) {\\n                ans = Math.max(Math.min(up[i][j][0] + left[i][j - 1][0], up[i][j][1] + left[i][j - 1][1]), ans);\\n                ans = Math.max(Math.min(up[i][j][0] + right[i][j + 1][0], up[i][j][1] + right[i][j + 1][1]), ans);\\n                ans = Math.max(Math.min(down[i][j][0] + left[i][j - 1][0], down[i][j][1] + left[i][j - 1][1]), ans);\\n                ans = Math.max(Math.min(down[i][j][0] + right[i][j + 1][0], down[i][j][1] + right[i][j + 1][1]), ans);\\n            }\\n        }\\n        return ans;\\n    }\\n    int getDigitNum(int num, int d) {\\n        int ans = 0;\\n        while (num > 0 && num % d == 0) {\\n            num /= d;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955763,
                "title": "c-prefix-sum-no-of-zero-min-2s-5s-in-path",
                "content": "This problem needs patience and its too frustrating. \\n**Idea:** Max no. of zeros in a path is min(no. of 5, no. of 2).\\nCreate two prefix sum:\\n* **row**: stores no. of five and two from **0 to jth** col for each **ith** row\\n*  **row2**: stores no. of five and two from **j to m-1** col for each **ith** row\\n\\nThen to find max no. zero in each col, we will need to traverse each col twice, \\n1. from top to bottom\\n1. from bottom to top, keeping the record of no. of five and two\\n\\nwhile traversing each col, at every index `i` in jth col, we will have two option, either turn left or right. For both the cases we have calculated our prefix sum.\\nNow take the sum of two\\'s and five\\'s of prefix sum (one at a time, either row or row2) and curr five\\'s and two\\'s while traversing `jth` col, find max no. of zeros\\n```\\nclass Solution {\\npublic:\\n    void count(int n,int &five,int &two){\\n        while(n%5==0 && n){\\n            five++; n=n/5;\\n        }\\n        while(n%2==0 && n){\\n            two++; n=n/2;\\n        }\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& nums) {\\n        int n = nums.size(), m = nums[0].size();\\n        vector<vector<pair<int,int>>> row(n,vector<pair<int,int>>(m));\\n         vector<vector<pair<int,int>>> row2(n,vector<pair<int,int>>(m));\\n        for(int i = 0; i<nums.size();++i){\\n            int five=0,two=0;\\n            for(int j = m-1;j>=0;--j){\\n                if(nums[i][j]%10==0 || nums[i][j]%5==0 || nums[i][j]%2==0) count(nums[i][j],five,two);\\n                row[i][j] = {five,two};  // no. of 5 and 2 from jth col to m-1 col for ith row\\n            }\\n        }\\n        for(int i = 0; i<nums.size();++i){\\n            int five=0,two=0;\\n            for(int j = 0;j<m;++j){\\n                if(nums[i][j]%10==0 || nums[i][j]%5==0 || nums[i][j]%2==0) count(nums[i][j],five,two);\\n                row2[i][j] = {five,two};  // no. of 5 and 2 from 0th col to jth col for ith row\\n            }\\n        }\\n\\n        int re = 0;\\n        for(int j = 0;j<m;++j){  // traverse each col from top to bottom\\n            int five=0,two=0;\\n            for(int i = 0;i<n;++i){\\n                int x=five,y=two; // this does\\'nt include curr number (no. of five and two) as it will get repeat by prefix sum\\n                if(nums[i][j]%10==0 || nums[i][j]%5==0 || nums[i][j]%2==0) count(nums[i][j],five,two);\\n\\t\\t\\t\\t// consider both situations and find max no. of zero\\n                int t1 = x+row[i][j].first,t2=y+row[i][j].second;\\n                re = max(re,min(t1,t2));\\n                t1 = x+row2[i][j].first,t2=y+row2[i][j].second;\\n                re = max(re,min(t1,t2));\\n            }\\n        }\\n        for(int j = 0;j<m;++j){  // traverse each col from bottom to top\\n            int five=0,two=0;\\n            for(int i = n-1;i>=0;--i){\\n                int x=five,y=two; // this does\\'nt include curr number (no. of five and two) as it will get repeat by prefix sum\\n                if(nums[i][j]%10==0 || nums[i][j]%5==0 || nums[i][j]%2==0) count(nums[i][j],five,two);\\n                int t1 = x+row[i][j].first,t2=y+row[i][j].second;\\n                re = max(re,min(t1,t2));\\n                t1 = x+row2[i][j].first,t2=y+row2[i][j].second;\\n                re = max(re,min(t1,t2));\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```\\n**Time: O(m*n)**\\nupvote if it helps",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void count(int n,int &five,int &two){\\n        while(n%5==0 && n){\\n            five++; n=n/5;\\n        }\\n        while(n%2==0 && n){\\n            two++; n=n/2;\\n        }\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& nums) {\\n        int n = nums.size(), m = nums[0].size();\\n        vector<vector<pair<int,int>>> row(n,vector<pair<int,int>>(m));\\n         vector<vector<pair<int,int>>> row2(n,vector<pair<int,int>>(m));\\n        for(int i = 0; i<nums.size();++i){\\n            int five=0,two=0;\\n            for(int j = m-1;j>=0;--j){\\n                if(nums[i][j]%10==0 || nums[i][j]%5==0 || nums[i][j]%2==0) count(nums[i][j],five,two);\\n                row[i][j] = {five,two};  // no. of 5 and 2 from jth col to m-1 col for ith row\\n            }\\n        }\\n        for(int i = 0; i<nums.size();++i){\\n            int five=0,two=0;\\n            for(int j = 0;j<m;++j){\\n                if(nums[i][j]%10==0 || nums[i][j]%5==0 || nums[i][j]%2==0) count(nums[i][j],five,two);\\n                row2[i][j] = {five,two};  // no. of 5 and 2 from 0th col to jth col for ith row\\n            }\\n        }\\n\\n        int re = 0;\\n        for(int j = 0;j<m;++j){  // traverse each col from top to bottom\\n            int five=0,two=0;\\n            for(int i = 0;i<n;++i){\\n                int x=five,y=two; // this does\\'nt include curr number (no. of five and two) as it will get repeat by prefix sum\\n                if(nums[i][j]%10==0 || nums[i][j]%5==0 || nums[i][j]%2==0) count(nums[i][j],five,two);\\n\\t\\t\\t\\t// consider both situations and find max no. of zero\\n                int t1 = x+row[i][j].first,t2=y+row[i][j].second;\\n                re = max(re,min(t1,t2));\\n                t1 = x+row2[i][j].first,t2=y+row2[i][j].second;\\n                re = max(re,min(t1,t2));\\n            }\\n        }\\n        for(int j = 0;j<m;++j){  // traverse each col from bottom to top\\n            int five=0,two=0;\\n            for(int i = n-1;i>=0;--i){\\n                int x=five,y=two; // this does\\'nt include curr number (no. of five and two) as it will get repeat by prefix sum\\n                if(nums[i][j]%10==0 || nums[i][j]%5==0 || nums[i][j]%2==0) count(nums[i][j],five,two);\\n                int t1 = x+row[i][j].first,t2=y+row[i][j].second;\\n                re = max(re,min(t1,t2));\\n                t1 = x+row2[i][j].first,t2=y+row2[i][j].second;\\n                re = max(re,min(t1,t2));\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955704,
                "title": "c-solution-using-prefix-sum-for-4-directions",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    pair<int,int> get(int n)\\n    {\\n        pair<int,int> result={0,0};\\n        while(n%5==0) result.first++, n/=5;\\n        while(n%2==0) result.second++,n/=2;\\n        return result;\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& grid) \\n    {\\n        int result=0,m=grid.size(),n=grid[0].size();\\n        pair<int,int> total[m][n][4];\\n        memset(total,0,sizeof(total));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                pair<int,int> c1=get(grid[i][j]),c2=get(grid[i][n-j-1]);\\n                if(j==0)\\n                {\\n                    total[i][j][0]=c1;\\n                    total[i][n-j-1][2]=c2;\\n                }\\n                else\\n                {\\n                    total[i][j][0]={total[i][j-1][0].first+c1.first,total[i][j-1][0].second+c1.second};\\n                    total[i][n-j-1][2]={total[i][n-j][2].first+c2.first,total[i][n-j][2].second+c2.second};\\n                }\\n            }\\n        }\\n        for(int j=0;j<n;j++)\\n        {\\n            for(int i=0;i<m;i++)\\n            {\\n                pair<int,int> c1=get(grid[i][j]),c2=get(grid[m-i-1][j]);\\n                if(i==0)\\n                {\\n                    total[i][j][1]=c1;\\n                    total[m-i-1][j][3]=c2;\\n                }\\n                else\\n                {\\n                    total[i][j][1]={total[i-1][j][1].first+c1.first,total[i-1][j][1].second+c1.second};\\n                    total[m-i-1][j][3]={total[m-i][j][3].first+c2.first,total[m-i][j][3].second+c2.second};\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                for(int a=0;a<3;a++)\\n                {\\n                    for(int b=a+1;b<4;b++)\\n                    {\\n                        pair<int,int> t=get(grid[i][j]);\\n                        result=max(result,min(total[i][j][a].first+total[i][j][b].first-t.first,total[i][j][a].second+total[i][j][b].second-t.second));\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    pair<int,int> get(int n)\\n    {\\n        pair<int,int> result={0,0};\\n        while(n%5==0) result.first++, n/=5;\\n        while(n%2==0) result.second++,n/=2;\\n        return result;\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& grid) \\n    {\\n        int result=0,m=grid.size(),n=grid[0].size();\\n        pair<int,int> total[m][n][4];\\n        memset(total,0,sizeof(total));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                pair<int,int> c1=get(grid[i][j]),c2=get(grid[i][n-j-1]);\\n                if(j==0)\\n                {\\n                    total[i][j][0]=c1;\\n                    total[i][n-j-1][2]=c2;\\n                }\\n                else\\n                {\\n                    total[i][j][0]={total[i][j-1][0].first+c1.first,total[i][j-1][0].second+c1.second};\\n                    total[i][n-j-1][2]={total[i][n-j][2].first+c2.first,total[i][n-j][2].second+c2.second};\\n                }\\n            }\\n        }\\n        for(int j=0;j<n;j++)\\n        {\\n            for(int i=0;i<m;i++)\\n            {\\n                pair<int,int> c1=get(grid[i][j]),c2=get(grid[m-i-1][j]);\\n                if(i==0)\\n                {\\n                    total[i][j][1]=c1;\\n                    total[m-i-1][j][3]=c2;\\n                }\\n                else\\n                {\\n                    total[i][j][1]={total[i-1][j][1].first+c1.first,total[i-1][j][1].second+c1.second};\\n                    total[m-i-1][j][3]={total[m-i][j][3].first+c2.first,total[m-i][j][3].second+c2.second};\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                for(int a=0;a<3;a++)\\n                {\\n                    for(int b=a+1;b<4;b++)\\n                    {\\n                        pair<int,int> t=get(grid[i][j]);\\n                        result=max(result,min(total[i][j][a].first+total[i][j][b].first-t.first,total[i][j][a].second+total[i][j][b].second-t.second));\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955693,
                "title": "try-to-apply-dfs-to-search-qualified-path-but-failed",
                "content": "* General Idea: I plan to apply dfs starting from each cell to search the qualified path. For each path, I\\'ll the visiting flag and the number of turns in corner cases. For the non-visited cell in each path, I\\'ll compute the product of this path and update the max counting of trailing zeros so far. Then, I apply dfs to search its neighbors within the range of the grid.\\n\\nThe idea looks pretty simple but couldn\\'t get correct answer. Anyone has some suggestionns? Thanks in advance.\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        self.visited = [[set()]*len(grid[0]) for _ in range(len(grid))]\\n        self.dirs = [(-1, 0), (1, 0), (0, 1), (0, -1)]\\n        self.cnt_tz = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                self.dfs(grid, i, j, grid[i][j], 0, \"\") # apply dfs\\n        return self.cnt_tz\\n    \\n    def dfs(self, grid, i, j, path_product, n_turn, pre_dirs):\\n        #terminal cases:\\n        if (i, j) in self.visited[i][j]:\\n            return\\n        if n_turn > 2:\\n            return\\n        #general cases:\\n        # update the flag for visiting\\n        m, n = len(grid), len(grid[0])\\n        self.visited[i][j].add((i, j))\\n        # compute the path product and update the max trailing zeros\\n        path_product *= grid[i][j]\\n        print(i, j, grid[i][j], path_product)\\n        self.cnt_tz = max(self.cnt_tz, self.count_trailing_zeros(path_product))\\n        # apply dfs to search on neighbors\\n        for dx, dy in self.dirs:\\n            x, y = dx + i, dy + j\\n            if 0<=x<m and 0<=y<n:\\n                if (abs(y-j)>0 and abs(x-i)==0):\\n                    cur_dirs = \\'v\\'\\n                if (abs(y-j)==0 and abs(x-i)>0):\\n                    cur_dirs = \\'h\\'\\n                if pre_dirs != cur_dirs:\\n                    n_turn += 1\\n                self.dfs(grid, x, y, path_product, n_turn, cur_dirs)\\n            else:\\n                return\\n\\n    def count_trailing_zeros(self, path_product):\\n        cnt = 0\\n        for char in str(path_product)[::-1]:\\n            if int(char) == 0:\\n                cnt += 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        self.visited = [[set()]*len(grid[0]) for _ in range(len(grid))]\\n        self.dirs = [(-1, 0), (1, 0), (0, 1), (0, -1)]\\n        self.cnt_tz = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                self.dfs(grid, i, j, grid[i][j], 0, \"\") # apply dfs\\n        return self.cnt_tz\\n    \\n    def dfs(self, grid, i, j, path_product, n_turn, pre_dirs):\\n        #terminal cases:\\n        if (i, j) in self.visited[i][j]:\\n            return\\n        if n_turn > 2:\\n            return\\n        #general cases:\\n        # update the flag for visiting\\n        m, n = len(grid), len(grid[0])\\n        self.visited[i][j].add((i, j))\\n        # compute the path product and update the max trailing zeros\\n        path_product *= grid[i][j]\\n        print(i, j, grid[i][j], path_product)\\n        self.cnt_tz = max(self.cnt_tz, self.count_trailing_zeros(path_product))\\n        # apply dfs to search on neighbors\\n        for dx, dy in self.dirs:\\n            x, y = dx + i, dy + j\\n            if 0<=x<m and 0<=y<n:\\n                if (abs(y-j)>0 and abs(x-i)==0):\\n                    cur_dirs = \\'v\\'\\n                if (abs(y-j)==0 and abs(x-i)>0):\\n                    cur_dirs = \\'h\\'\\n                if pre_dirs != cur_dirs:\\n                    n_turn += 1\\n                self.dfs(grid, x, y, path_product, n_turn, cur_dirs)\\n            else:\\n                return\\n\\n    def count_trailing_zeros(self, path_product):\\n        cnt = 0\\n        for char in str(path_product)[::-1]:\\n            if int(char) == 0:\\n                cnt += 1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955684,
                "title": "just-finished-writing-my-novel-please-take-a-look",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        //dp?\\n        vector<vector<pair<int, int>>> dp(grid.size(), vector<pair<int, int>>(grid[0].size()));\\n        for(int i = 0; i < dp.size(); i++){\\n            for(int j = 0; j < dp[i].size(); j++){\\n                int two = 0, five = 0;\\n                while(grid[i][j] % 2 == 0){\\n                    grid[i][j] /= 2;\\n                    two++;\\n                }\\n                while(grid[i][j] % 5 == 0){\\n                    grid[i][j] /= 5;\\n                    five++;\\n                }\\n                dp[i][j] = make_pair(two, five);\\n            }\\n        }\\n        vector<vector<pair<int, int>>> up(dp.size() + 1, vector<pair<int, int>>(dp[0].size()));\\n        vector<vector<pair<int, int>>> left(dp.size(), vector<pair<int, int>>(dp[0].size() + 1));\\n        up[0][0].first = 0, up[0][0].second = 0;\\n        left[0][0].first = 0, left[0][0].second = 0;\\n        for(int i = 0; i < dp.size(); i++){\\n            int curtwo = 0, curfive = 0;\\n            for(int j = 0; j < dp[i].size(); j++){\\n                curtwo += dp[i][j].first, curfive += dp[i][j].second;\\n                left[i][j + 1].first = curtwo;\\n                left[i][j + 1].second = curfive;\\n            }\\n        }\\n        for(int j = 0; j < dp[0].size(); j++){\\n            int curtwo = 0, curfive = 0;\\n            for(int i = 0; i < dp.size(); i++){\\n                curtwo += dp[i][j].first, curfive += dp[i][j].second;\\n                up[i + 1][j].first = curtwo, up[i + 1][j].second = curfive;\\n            }\\n        }\\n        vector<pair<int, int>> rowsum, colsum;\\n        for(int i = 0; i < dp.size(); i++){\\n            int t = 0, f = 0;\\n            for(int j = 0; j < dp[i].size(); j++){\\n                t += dp[i][j].first;\\n                f += dp[i][j].second;\\n            }\\n            rowsum.push_back(make_pair(t, f));\\n        }\\n        for(int i = 0; i < dp[0].size(); i++){\\n            int t = 0, f = 0;\\n            for(int j = 0; j < dp.size(); j++){\\n                t += dp[j][i].first, f += dp[j][i].second;\\n            }\\n            colsum.push_back(make_pair(t, f));\\n        }\\n        int res = 0;\\n        for(int i = 0; i < dp.size(); i++){\\n            for(int j = 0; j < dp[i].size(); j++){\\n                int up2 = up[i][j].first, up5 = up[i][j].second, left2 = left[i][j].first, left5 = left[i][j].second;\\n                int down2 = colsum[j].first - up2 - dp[i][j].first;\\n                int down5 = colsum[j].second - up5 - dp[i][j].second;\\n                int right2 = rowsum[i].first - left[i][j + 1].first, right5 = rowsum[i].second - left[i][j + 1].second;\\n                int q2 = min(up2 + left2 + dp[i][j].first, up5 + left5 + dp[i][j].second), q4 = min(right2 + down2 + dp[i][j].first, right5 + down5 + dp[i][j].second), q1 = min(up2 + right2 + dp[i][j].first, up5 + right5 + dp[i][j].second), q3 = min(left2 + down2 + dp[i][j].first, left5 + down5 + dp[i][j].second);\\n                \\n                res = max({res, q1, q2, q3, q4});\\n                \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        //dp?\\n        vector<vector<pair<int, int>>> dp(grid.size(), vector<pair<int, int>>(grid[0].size()));\\n        for(int i = 0; i < dp.size(); i++){\\n            for(int j = 0; j < dp[i].size(); j++){\\n                int two = 0, five = 0;\\n                while(grid[i][j] % 2 == 0){\\n                    grid[i][j] /= 2;\\n                    two++;\\n                }\\n                while(grid[i][j] % 5 == 0){\\n                    grid[i][j] /= 5;\\n                    five++;\\n                }\\n                dp[i][j] = make_pair(two, five);\\n            }\\n        }\\n        vector<vector<pair<int, int>>> up(dp.size() + 1, vector<pair<int, int>>(dp[0].size()));\\n        vector<vector<pair<int, int>>> left(dp.size(), vector<pair<int, int>>(dp[0].size() + 1));\\n        up[0][0].first = 0, up[0][0].second = 0;\\n        left[0][0].first = 0, left[0][0].second = 0;\\n        for(int i = 0; i < dp.size(); i++){\\n            int curtwo = 0, curfive = 0;\\n            for(int j = 0; j < dp[i].size(); j++){\\n                curtwo += dp[i][j].first, curfive += dp[i][j].second;\\n                left[i][j + 1].first = curtwo;\\n                left[i][j + 1].second = curfive;\\n            }\\n        }\\n        for(int j = 0; j < dp[0].size(); j++){\\n            int curtwo = 0, curfive = 0;\\n            for(int i = 0; i < dp.size(); i++){\\n                curtwo += dp[i][j].first, curfive += dp[i][j].second;\\n                up[i + 1][j].first = curtwo, up[i + 1][j].second = curfive;\\n            }\\n        }\\n        vector<pair<int, int>> rowsum, colsum;\\n        for(int i = 0; i < dp.size(); i++){\\n            int t = 0, f = 0;\\n            for(int j = 0; j < dp[i].size(); j++){\\n                t += dp[i][j].first;\\n                f += dp[i][j].second;\\n            }\\n            rowsum.push_back(make_pair(t, f));\\n        }\\n        for(int i = 0; i < dp[0].size(); i++){\\n            int t = 0, f = 0;\\n            for(int j = 0; j < dp.size(); j++){\\n                t += dp[j][i].first, f += dp[j][i].second;\\n            }\\n            colsum.push_back(make_pair(t, f));\\n        }\\n        int res = 0;\\n        for(int i = 0; i < dp.size(); i++){\\n            for(int j = 0; j < dp[i].size(); j++){\\n                int up2 = up[i][j].first, up5 = up[i][j].second, left2 = left[i][j].first, left5 = left[i][j].second;\\n                int down2 = colsum[j].first - up2 - dp[i][j].first;\\n                int down5 = colsum[j].second - up5 - dp[i][j].second;\\n                int right2 = rowsum[i].first - left[i][j + 1].first, right5 = rowsum[i].second - left[i][j + 1].second;\\n                int q2 = min(up2 + left2 + dp[i][j].first, up5 + left5 + dp[i][j].second), q4 = min(right2 + down2 + dp[i][j].first, right5 + down5 + dp[i][j].second), q1 = min(up2 + right2 + dp[i][j].first, up5 + right5 + dp[i][j].second), q3 = min(left2 + down2 + dp[i][j].first, left5 + down5 + dp[i][j].second);\\n                \\n                res = max({res, q1, q2, q3, q4});\\n                \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955675,
                "title": "c-faster-than-100",
                "content": "Not optimized, did it for the weekly contest.\\nCreated left/right/up/down m x n matrices to track the number of 2\\'s and 5\\'s at each direction for each point in the matrix...\\nThen scan the matrix and pick the the max of 2\\'s and 5\\'s that each point can see from the six possible directions (left-right, left-up, up-right, ....) and then compare the number with the max seen so far...\\n\\n```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n    int m = grid.size(); int n = grid[0].size();\\n    vector<vector<int>> left2 (m, vector<int> (n, 0));  vector<vector<int>> left5 (m, vector<int> (n, 0));\\n    vector<vector<int>> right2 (m, vector<int> (n, 0)); vector<vector<int>> right5 (m, vector<int> (n, 0));\\n    vector<vector<int>> up2 (m, vector<int> (n, 0));    vector<vector<int>> up5 (m, vector<int> (n, 0));\\n    vector<vector<int>> down2 (m, vector<int> (n, 0));  vector<vector<int>> down5 (m, vector<int> (n, 0));\\n    vector<vector<int>> grid2 (m, vector<int> (n, 0));  vector<vector<int>> grid5 (m, vector<int> (n, 0));\\n        \\n    for(int i = 0; i < m; i++)\\n        for(int j = 0; j < n; j++) {\\n            int two = 0; int temp = grid[i][j];\\n            while(temp % 2 == 0) {two++; temp /= 2;}\\n            \\n            int five = 0; temp = grid[i][j];\\n            while(temp % 5 == 0) {five++; temp /= 5;}\\n            \\n            grid2[i][j] = two; grid5[i][j] = five;\\n            \\n            left2[i][j] =   up2[i][j]   = two;\\n            if(j > 0)       left2[i][j] += left2[i][j-1];\\n            if(i > 0)       up2[i][j]   += up2[i-1][j];\\n            \\n            left5[i][j] =   up5[i][j]   = five;\\n            if(j > 0)       left5[i][j] += left5[i][j-1];\\n            if(i > 0)       up5[i][j]   += up5[i-1][j];\\n        }\\n        \\n    for(int i = m-1; i >= 0; i--)\\n        for(int j = n-1; j >= 0; j--) {\\n            right2[i][j] =  down2[i][j]  = grid2[i][j];\\n            if(j < n-1)     right2[i][j] += right2[i][j+1];\\n            if(i < m-1)     down2[i][j]  += down2[i+1][j];\\n            \\n            right5[i][j] =  down5[i][j]  = grid5[i][j];\\n            if(j < n-1)     right5[i][j] += right5[i][j+1];\\n            if(i < m-1)     down5[i][j]  += down5[i+1][j];\\n        }\\n        \\n    int result = INT_MIN;\\n    for(int i = m-1; i >= 0; i--)\\n        for(int j = n-1; j >= 0; j--) {\\n            result = max(min(left2[i][j] + up2[i][j] - grid2[i][j], left5[i][j] + up5[i][j] - grid5[i][j]), result);        //left+up\\n            result = max(min(left2[i][j] + right2[i][j] - grid2[i][j], left5[i][j] + right5[i][j] - grid5[i][j]), result);  //left+right\\n            result = max(min(up2[i][j] + right2[i][j] - grid2[i][j], up5[i][j] + right5[i][j] - grid5[i][j]), result);      //up+right\\n            result = max(min(up2[i][j] + down2[i][j] - grid2[i][j], up5[i][j] + down5[i][j] - grid5[i][j]), result);        //up+down\\n            result = max(min(right2[i][j] + down2[i][j] - grid2[i][j], right5[i][j] + down5[i][j] - grid5[i][j]), result);  //right+down\\n            result = max(min(left2[i][j] + down2[i][j] - grid2[i][j], left5[i][j] + down5[i][j] - grid5[i][j]), result);    //left+down\\n        }  \\n    return result;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n    int m = grid.size(); int n = grid[0].size();\\n    vector<vector<int>> left2 (m, vector<int> (n, 0));  vector<vector<int>> left5 (m, vector<int> (n, 0));\\n    vector<vector<int>> right2 (m, vector<int> (n, 0)); vector<vector<int>> right5 (m, vector<int> (n, 0));\\n    vector<vector<int>> up2 (m, vector<int> (n, 0));    vector<vector<int>> up5 (m, vector<int> (n, 0));\\n    vector<vector<int>> down2 (m, vector<int> (n, 0));  vector<vector<int>> down5 (m, vector<int> (n, 0));\\n    vector<vector<int>> grid2 (m, vector<int> (n, 0));  vector<vector<int>> grid5 (m, vector<int> (n, 0));\\n        \\n    for(int i = 0; i < m; i++)\\n        for(int j = 0; j < n; j++) {\\n            int two = 0; int temp = grid[i][j];\\n            while(temp % 2 == 0) {two++; temp /= 2;}\\n            \\n            int five = 0; temp = grid[i][j];\\n            while(temp % 5 == 0) {five++; temp /= 5;}\\n            \\n            grid2[i][j] = two; grid5[i][j] = five;\\n            \\n            left2[i][j] =   up2[i][j]   = two;\\n            if(j > 0)       left2[i][j] += left2[i][j-1];\\n            if(i > 0)       up2[i][j]   += up2[i-1][j];\\n            \\n            left5[i][j] =   up5[i][j]   = five;\\n            if(j > 0)       left5[i][j] += left5[i][j-1];\\n            if(i > 0)       up5[i][j]   += up5[i-1][j];\\n        }\\n        \\n    for(int i = m-1; i >= 0; i--)\\n        for(int j = n-1; j >= 0; j--) {\\n            right2[i][j] =  down2[i][j]  = grid2[i][j];\\n            if(j < n-1)     right2[i][j] += right2[i][j+1];\\n            if(i < m-1)     down2[i][j]  += down2[i+1][j];\\n            \\n            right5[i][j] =  down5[i][j]  = grid5[i][j];\\n            if(j < n-1)     right5[i][j] += right5[i][j+1];\\n            if(i < m-1)     down5[i][j]  += down5[i+1][j];\\n        }\\n        \\n    int result = INT_MIN;\\n    for(int i = m-1; i >= 0; i--)\\n        for(int j = n-1; j >= 0; j--) {\\n            result = max(min(left2[i][j] + up2[i][j] - grid2[i][j], left5[i][j] + up5[i][j] - grid5[i][j]), result);        //left+up\\n            result = max(min(left2[i][j] + right2[i][j] - grid2[i][j], left5[i][j] + right5[i][j] - grid5[i][j]), result);  //left+right\\n            result = max(min(up2[i][j] + right2[i][j] - grid2[i][j], up5[i][j] + right5[i][j] - grid5[i][j]), result);      //up+right\\n            result = max(min(up2[i][j] + down2[i][j] - grid2[i][j], up5[i][j] + down5[i][j] - grid5[i][j]), result);        //up+down\\n            result = max(min(right2[i][j] + down2[i][j] - grid2[i][j], right5[i][j] + down5[i][j] - grid5[i][j]), result);  //right+down\\n            result = max(min(left2[i][j] + down2[i][j] - grid2[i][j], left5[i][j] + down5[i][j] - grid5[i][j]), result);    //left+down\\n        }  \\n    return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955659,
                "title": "c-o-m-n-solution",
                "content": "```\\npublic class Solution\\n{\\n    public int MaxTrailingZeros(int[][] grid)\\n    {\\n        int M = grid.Length; // total rows\\n        int N = grid[0].Length; // total columns\\n        // Create 8 memory grids\\n        int[,] twosUp = new int[M, N];\\n        int[,] twosDown = new int[M, N];\\n        int[,] twosLeft = new int[M, N];\\n        int[,] twosRight = new int[M, N];\\n        \\n        int[,] fivesUp = new int[M, N];\\n        int[,] fivesDown = new int[M, N];\\n        int[,] fivesLeft = new int[M, N];\\n        int[,] fivesRight = new int[M, N];\\n\\n        // Fill twosUp\\n        for (int j = 0; j < N; j++)\\n        {\\n            int twosCt = 0;\\n            for (int i = 0; i < M; i++)\\n            {\\n                twosCt += Get2FactorCtFrom(grid[i][j]);\\n                twosUp[i, j] = twosCt;\\n            }\\n        }\\n        // Fill twosDown\\n        for (int j = 0; j < N; j++)\\n        {\\n            int twosCt = 0;\\n            for (int i = M - 1; i >= 0; i--)\\n            {\\n                twosCt += Get2FactorCtFrom(grid[i][j]);\\n                twosDown[i, j] = twosCt;\\n            }\\n        }\\n        // Fill twosLeft \\n        for (int i = 0; i < M; i++)\\n        {\\n            int twosCt = 0;\\n            for (int j = 0; j < N; j++)\\n            {\\n                twosCt += Get2FactorCtFrom(grid[i][j]);\\n                twosLeft[i, j] = twosCt;\\n            }\\n        }\\n        // Fill twosRight\\n        for (int i = 0; i < M; i++)\\n        {\\n            int twosCt = 0;\\n            for (int j = N - 1; j >= 0; j--)\\n            {\\n                twosCt += Get2FactorCtFrom(grid[i][j]);\\n                twosRight[i, j] = twosCt;\\n            }\\n        }\\n\\n        // Fill fivesUp\\n        for (int j = 0; j < N; j++)\\n        {\\n            int fivesCt = 0;\\n            for (int i = 0; i < M; i++)\\n            {\\n                fivesCt += Get5FactorCtFrom(grid[i][j]);\\n                fivesUp[i, j] = fivesCt;\\n            }\\n        }\\n        // Fill fivesDown\\n        for (int j = 0; j < N; j++)\\n        {\\n            int fivesCt = 0;\\n            for (int i = M - 1; i >= 0; i--)\\n            {\\n                fivesCt += Get5FactorCtFrom(grid[i][j]);\\n                fivesDown[i, j] = fivesCt;\\n            }\\n        }\\n        // Fill fivesLeft \\n        for (int i = 0; i < M; i++)\\n        {\\n            int fivesCt = 0;\\n            for (int j = 0; j < N; j++)\\n            {\\n                fivesCt += Get5FactorCtFrom(grid[i][j]);\\n                fivesLeft[i, j] = fivesCt;\\n            }\\n        }\\n        // Fill fivesRight\\n        for (int i = 0; i < M; i++)\\n        {\\n            int fivesCt = 0;\\n            for (int j = N - 1; j >= 0; j--)\\n            {\\n                fivesCt += Get5FactorCtFrom(grid[i][j]);\\n                fivesRight[i, j] = fivesCt;\\n            }\\n        }\\n\\n        // traverse the grid, at each cell get the min of the 2s ct and 5s ct in any 2 right angle directions\\n        int max = 0;\\n        for (int i = 0; i < M; i++)\\n        {\\n            for (int j = 0; j < N; j++)\\n            {\\n                int option1twos = twosUp[i,j] + twosRight[i,j] - Get2FactorCtFrom(grid[i][j]);\\n                int option1fives = fivesUp[i, j] + fivesRight[i, j] - Get5FactorCtFrom(grid[i][j]);\\n                max = Math.Max(max, Math.Min(option1twos, option1fives));\\n\\n                int option2twos = twosUp[i, j] + twosLeft[i, j] - Get2FactorCtFrom(grid[i][j]);\\n                int option2fives = fivesUp[i, j] + fivesLeft[i, j] - Get5FactorCtFrom(grid[i][j]);\\n                max = Math.Max(max, Math.Min(option2twos, option2fives));\\n\\n                int option3twos = twosLeft[i, j] + twosDown[i, j] - Get2FactorCtFrom(grid[i][j]);\\n                int option3fives = fivesLeft[i, j] + fivesDown[i, j] - Get5FactorCtFrom(grid[i][j]);\\n                max = Math.Max(max, Math.Min(option3twos, option3fives));\\n\\n                int option4twos = twosRight[i, j] + twosDown[i, j] - Get2FactorCtFrom(grid[i][j]);\\n                int option4fives = fivesRight[i, j] + fivesDown[i, j] - Get5FactorCtFrom(grid[i][j]);\\n                max = Math.Max(max, Math.Min(option4twos, option4fives));\\n\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private int Get2FactorCtFrom(int n)\\n    {\\n        int result = 0;\\n        while (n % 2 == 0)\\n        {\\n            result++;\\n            n /= 2;\\n        }\\n        return result;\\n    }\\n\\n    private int Get5FactorCtFrom(int n)\\n    {\\n        int result = 0;\\n        while (n % 5 == 0)\\n        {\\n            result++;\\n            n /= 5;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int MaxTrailingZeros(int[][] grid)\\n    {\\n        int M = grid.Length; // total rows\\n        int N = grid[0].Length; // total columns\\n        // Create 8 memory grids\\n        int[,] twosUp = new int[M, N];\\n        int[,] twosDown = new int[M, N];\\n        int[,] twosLeft = new int[M, N];\\n        int[,] twosRight = new int[M, N];\\n        \\n        int[,] fivesUp = new int[M, N];\\n        int[,] fivesDown = new int[M, N];\\n        int[,] fivesLeft = new int[M, N];\\n        int[,] fivesRight = new int[M, N];\\n\\n        // Fill twosUp\\n        for (int j = 0; j < N; j++)\\n        {\\n            int twosCt = 0;\\n            for (int i = 0; i < M; i++)\\n            {\\n                twosCt += Get2FactorCtFrom(grid[i][j]);\\n                twosUp[i, j] = twosCt;\\n            }\\n        }\\n        // Fill twosDown\\n        for (int j = 0; j < N; j++)\\n        {\\n            int twosCt = 0;\\n            for (int i = M - 1; i >= 0; i--)\\n            {\\n                twosCt += Get2FactorCtFrom(grid[i][j]);\\n                twosDown[i, j] = twosCt;\\n            }\\n        }\\n        // Fill twosLeft \\n        for (int i = 0; i < M; i++)\\n        {\\n            int twosCt = 0;\\n            for (int j = 0; j < N; j++)\\n            {\\n                twosCt += Get2FactorCtFrom(grid[i][j]);\\n                twosLeft[i, j] = twosCt;\\n            }\\n        }\\n        // Fill twosRight\\n        for (int i = 0; i < M; i++)\\n        {\\n            int twosCt = 0;\\n            for (int j = N - 1; j >= 0; j--)\\n            {\\n                twosCt += Get2FactorCtFrom(grid[i][j]);\\n                twosRight[i, j] = twosCt;\\n            }\\n        }\\n\\n        // Fill fivesUp\\n        for (int j = 0; j < N; j++)\\n        {\\n            int fivesCt = 0;\\n            for (int i = 0; i < M; i++)\\n            {\\n                fivesCt += Get5FactorCtFrom(grid[i][j]);\\n                fivesUp[i, j] = fivesCt;\\n            }\\n        }\\n        // Fill fivesDown\\n        for (int j = 0; j < N; j++)\\n        {\\n            int fivesCt = 0;\\n            for (int i = M - 1; i >= 0; i--)\\n            {\\n                fivesCt += Get5FactorCtFrom(grid[i][j]);\\n                fivesDown[i, j] = fivesCt;\\n            }\\n        }\\n        // Fill fivesLeft \\n        for (int i = 0; i < M; i++)\\n        {\\n            int fivesCt = 0;\\n            for (int j = 0; j < N; j++)\\n            {\\n                fivesCt += Get5FactorCtFrom(grid[i][j]);\\n                fivesLeft[i, j] = fivesCt;\\n            }\\n        }\\n        // Fill fivesRight\\n        for (int i = 0; i < M; i++)\\n        {\\n            int fivesCt = 0;\\n            for (int j = N - 1; j >= 0; j--)\\n            {\\n                fivesCt += Get5FactorCtFrom(grid[i][j]);\\n                fivesRight[i, j] = fivesCt;\\n            }\\n        }\\n\\n        // traverse the grid, at each cell get the min of the 2s ct and 5s ct in any 2 right angle directions\\n        int max = 0;\\n        for (int i = 0; i < M; i++)\\n        {\\n            for (int j = 0; j < N; j++)\\n            {\\n                int option1twos = twosUp[i,j] + twosRight[i,j] - Get2FactorCtFrom(grid[i][j]);\\n                int option1fives = fivesUp[i, j] + fivesRight[i, j] - Get5FactorCtFrom(grid[i][j]);\\n                max = Math.Max(max, Math.Min(option1twos, option1fives));\\n\\n                int option2twos = twosUp[i, j] + twosLeft[i, j] - Get2FactorCtFrom(grid[i][j]);\\n                int option2fives = fivesUp[i, j] + fivesLeft[i, j] - Get5FactorCtFrom(grid[i][j]);\\n                max = Math.Max(max, Math.Min(option2twos, option2fives));\\n\\n                int option3twos = twosLeft[i, j] + twosDown[i, j] - Get2FactorCtFrom(grid[i][j]);\\n                int option3fives = fivesLeft[i, j] + fivesDown[i, j] - Get5FactorCtFrom(grid[i][j]);\\n                max = Math.Max(max, Math.Min(option3twos, option3fives));\\n\\n                int option4twos = twosRight[i, j] + twosDown[i, j] - Get2FactorCtFrom(grid[i][j]);\\n                int option4fives = fivesRight[i, j] + fivesDown[i, j] - Get5FactorCtFrom(grid[i][j]);\\n                max = Math.Max(max, Math.Min(option4twos, option4fives));\\n\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private int Get2FactorCtFrom(int n)\\n    {\\n        int result = 0;\\n        while (n % 2 == 0)\\n        {\\n            result++;\\n            n /= 2;\\n        }\\n        return result;\\n    }\\n\\n    private int Get5FactorCtFrom(int n)\\n    {\\n        int result = 0;\\n        while (n % 5 == 0)\\n        {\\n            result++;\\n            n /= 5;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955635,
                "title": "java-beat-100-straightforward-prefix-sum-solution-easy-to-understand",
                "content": "\\tclass Solution {\\n\\t\\t// Get the number of twos\\n\\t\\t//     the number of fives\\n\\t\\tpublic int[] getTwoFive(int n) {\\n\\t\\t\\tint twos = 0;\\n\\t\\t\\tint tmp = n;\\n\\n\\t\\t\\twhile(tmp > 0 && tmp % 2 == 0) {\\n\\t\\t\\t\\ttwos++;\\n\\t\\t\\t\\ttmp /= 2;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint fives = 0;\\n\\t\\t\\ttmp = n;\\n\\n\\t\\t\\twhile(tmp > 0 && tmp % 5 == 0) {\\n\\t\\t\\t\\tfives++;\\n\\t\\t\\t\\ttmp /= 5;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn new int[]{twos, fives};\\n\\t\\t}\\n\\n\\t\\tpublic int maxTrailingZeros(int[][] grid) {\\n\\t\\t\\tint R = grid.length;\\n\\t\\t\\tint C = grid[0].length;\\n\\n\\t\\t\\tint[][][] twoFiveGrid = new int[R][C][2];\\n\\n\\t\\t\\t// Save the number of twos and fives\\n\\t\\t\\t// twoFiveGrid[i][j][0] : twos\\n\\t\\t\\t// twoFiveGrid[i][j][1] : fives\\n\\n\\t\\t\\tfor(int i=0; i<R; ++i) {\\n\\t\\t\\t\\tfor(int j=0; j<C; ++j) {\\n\\t\\t\\t\\t\\tint[] twoFive = getTwoFive(grid[i][j]);\\n\\t\\t\\t\\t\\ttwoFiveGrid[i][j][0] = twoFive[0];\\n\\t\\t\\t\\t\\ttwoFiveGrid[i][j][1] = twoFive[1];   \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\t// prefix array from top to bottom.\\n\\t\\t\\tint[][][] downFix = new int[R][C][2];\\n\\n\\t\\t\\tfor(int j=0; j<C; ++j) {\\n\\t\\t\\t\\tdownFix[0][j][0] = twoFiveGrid[0][j][0];\\n\\t\\t\\t\\tdownFix[0][j][1] = twoFiveGrid[0][j][1];   \\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int j=0; j<C; ++j) {\\n\\t\\t\\t\\tfor(int i=1; i<R; ++i) {\\n\\t\\t\\t\\t\\tdownFix[i][j][0] = downFix[i-1][j][0] + twoFiveGrid[i][j][0];\\n\\t\\t\\t\\t\\tdownFix[i][j][1] = downFix[i-1][j][1] + twoFiveGrid[i][j][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// prefix array from bottom to top.\\n\\t\\t\\tint[][][] upFix = new int[R][C][2];\\n\\n\\t\\t\\tfor(int j=0; j<C; ++j) {\\n\\t\\t\\t\\tupFix[R-1][j][0] = twoFiveGrid[R-1][j][0];\\n\\t\\t\\t\\tupFix[R-1][j][1] = twoFiveGrid[R-1][j][1];   \\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int j=0; j<C; ++j) {\\n\\t\\t\\t\\tfor(int i=R-2; i>=0; --i) {\\n\\t\\t\\t\\t\\tupFix[i][j][0] += upFix[i+1][j][0] + twoFiveGrid[i][j][0];\\n\\t\\t\\t\\t\\tupFix[i][j][1] += upFix[i+1][j][1] + twoFiveGrid[i][j][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// prefix array from left to right.\\n\\t\\t\\tint[][][] lFix = new int[R][C][2];\\n\\n\\t\\t\\tfor(int i=0; i<R; ++i) {\\n\\t\\t\\t\\tlFix[i][0][0] = twoFiveGrid[i][0][0];\\n\\t\\t\\t\\tlFix[i][0][1] = twoFiveGrid[i][0][1];   \\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=0; i<R; ++i) {\\n\\t\\t\\t\\tfor(int j=1; j<C; ++j) {\\n\\t\\t\\t\\t\\tlFix[i][j][0] = lFix[i][j-1][0] + twoFiveGrid[i][j][0];\\n\\t\\t\\t\\t\\tlFix[i][j][1] = lFix[i][j-1][1] + twoFiveGrid[i][j][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// prefix array from right to left.\\n\\t\\t\\tint[][][] rFix = new int[R][C][2];\\n\\t\\t\\tfor(int i=0; i<R; ++i) {\\n\\t\\t\\t\\trFix[i][C-1][0] = twoFiveGrid[i][C-1][0];\\n\\t\\t\\t\\trFix[i][C-1][1] = twoFiveGrid[i][C-1][1];   \\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=0; i<R; ++i) {\\n\\t\\t\\t\\tfor(int j=C-2; j>=0; --j) {\\n\\t\\t\\t\\t\\trFix[i][j][0] = rFix[i][j+1][0] + twoFiveGrid[i][j][0];\\n\\t\\t\\t\\t\\trFix[i][j][1] = rFix[i][j+1][1] + twoFiveGrid[i][j][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint res = 0;\\n\\n\\t\\t\\tfor(int i=0; i<R; ++i) {\\n\\t\\t\\t\\tfor(int j=0; j<C; ++j) {\\n\\n\\t\\t\\t\\t\\t// \\u3134 case\\n\\t\\t\\t\\t\\tint two = downFix[i][j][0] + rFix[i][j][0];\\n\\t\\t\\t\\t\\tint five = downFix[i][j][1] + rFix[i][j][1];\\n\\t\\t\\t\\t\\ttwo -= twoFiveGrid[i][j][0];\\n\\t\\t\\t\\t\\tfive -= twoFiveGrid[i][j][1];\\n\\n\\t\\t\\t\\t\\tres = Math.max(res, Math.min(two, five));\\n\\n\\n\\t\\t\\t\\t\\t// \\u250C case\\n\\t\\t\\t\\t\\ttwo = upFix[i][j][0] + rFix[i][j][0];\\n\\t\\t\\t\\t\\tfive = upFix[i][j][1] + rFix[i][j][1];\\n\\t\\t\\t\\t\\ttwo -= twoFiveGrid[i][j][0];\\n\\t\\t\\t\\t\\tfive -= twoFiveGrid[i][j][1];\\n\\n\\t\\t\\t\\t\\tres = Math.max(res, Math.min(two, five));\\n\\n\\n\\t\\t\\t\\t\\t// \\u3131 case\\n\\t\\t\\t\\t\\ttwo = upFix[i][j][0] + lFix[i][j][0];\\n\\t\\t\\t\\t\\tfive = upFix[i][j][1] + lFix[i][j][1];\\n\\t\\t\\t\\t\\ttwo -= twoFiveGrid[i][j][0];\\n\\t\\t\\t\\t\\tfive -= twoFiveGrid[i][j][1];\\n\\n\\t\\t\\t\\t\\tres = Math.max(res, Math.min(two, five));\\n\\n\\n\\t\\t\\t\\t\\t// \\u2518 case\\n\\t\\t\\t\\t\\ttwo = downFix[i][j][0] + lFix[i][j][0];\\n\\t\\t\\t\\t\\tfive = downFix[i][j][1] + lFix[i][j][1];\\n\\t\\t\\t\\t\\ttwo -= twoFiveGrid[i][j][0];\\n\\t\\t\\t\\t\\tfive -= twoFiveGrid[i][j][1];\\n\\n\\t\\t\\t\\t\\tres = Math.max(res, Math.min(two, five));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn res;\\n\\n\\t\\t}\\n\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t// Get the number of twos\\n\\t\\t//     the number of fives\\n\\t\\tpublic int[] getTwoFive(int n) {\\n\\t\\t\\tint twos = 0;\\n\\t\\t\\tint tmp = n;\\n\\n\\t\\t\\twhile(tmp > 0 && tmp % 2 == 0) {\\n\\t\\t\\t\\ttwos++;\\n\\t\\t\\t\\ttmp /= 2;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1955634,
                "title": "java-prefix-sum-solution-count-5s-2s",
                "content": "Basically I find the sum of 2s and 5s from top to bottom, and from left to right and create prefix matrices.\\nThen find best possible solution at each index picking one of the 4, up down left or right and always include the current index\\n\\n```\\nclass Solution {\\n    \\n    Map<Integer, Integer> findTwoCache;\\n    Map<Integer, Integer> findFiveCache;\\n    public int maxTrailingZeros(int[][] grid) {\\n        findTwoCache = new HashMap<>();\\n        findFiveCache = new HashMap<>();\\n        int n= grid.length;\\n        int m = grid[0].length;\\n        int[][][] fromTop = new int[n][m][2];\\n        \\n        for (int i = 0; i < m;i++){\\n            int countTwo = 0;\\n            int countFive = 0;\\n            for (int j = 0;j < n;j++){\\n                int currVal = grid[j][i];\\n                countTwo += find(currVal, 2);\\n                countFive += find(currVal, 5);\\n                fromTop[j][i][0] = countTwo;\\n                fromTop[j][i][1] = countFive;\\n            }\\n        }\\n        \\n        int[][][] fromLeft = new int[n][m][2];\\n        \\n\\n        for (int i = 0;i < n;i++){\\n            int countTwo = 0;\\n            int countFive = 0;\\n            for (int j =0;j < m;j++){\\n                int currVal = grid[i][j];\\n                countTwo += find(currVal, 2);\\n                countFive += find(currVal, 5);\\n                fromLeft[i][j][0] = countTwo;\\n                fromLeft[i][j][1] = countFive;\\n            }\\n        }\\n\\n        \\n        int max = 0;\\n        \\n        for (int i = 0; i < n;i++){\\n            for (int j =0;j < m;j++){\\n\\n                // in each index we have 4 options, we can pick 2\\n                int currVal = grid[i][j];\\n                int currTwo = find(currVal, 2);\\n                int currFive = find(currVal, 5);\\n                \\n                int upTwo = 0;\\n                int upFive = 0;\\n                \\n                if (i - 1 >= 0){\\n                     upTwo = fromTop[i-1][j][0];\\n                 upFive = fromTop[i-1][j][1];\\n                }\\n                \\n                // down is basically the very bottom value - our current value\\n                int downTwo = fromTop[n-1][j][0] - fromTop[i][j][0];\\n                int downFive = fromTop[n-1][j][1] - fromTop[i][j][1];\\n                \\n                // left is just current from left - currentVal\\n                int leftTwo = 0;\\n                int leftFive = 0;\\n                if (j > 0){\\n                     leftTwo = fromLeft[i][j-1][0];\\n                    leftFive = fromLeft[i][j-1][1];\\n                }\\n                \\n                // right is very right - our current value and all left\\n                int rightTwo = fromLeft[i][m-1][0] - fromLeft[i][j][0];\\n                int rightFive = fromLeft[i][m-1][1] - fromLeft[i][j][1];\\n                \\n\\n                \\n                List<int[]> arr = new ArrayList<>();\\n                \\n                arr.add(new int[]{upTwo, upFive});\\n                arr.add(new int[]{downTwo, downFive});\\n                arr.add(new int[]{leftTwo, leftFive});\\n                arr.add(new int[]{rightTwo, rightFive});\\n                \\n                for (int a = 0; a < arr.size();a++){\\n                    for (int b = a+1;b < arr.size();b++){\\n                        int sumTwo = arr.get(a)[0] + arr.get(b)[0] + currTwo;\\n                        int sumFive = arr.get(a)[1] + arr.get(b)[1] + currFive;\\n                        int ans = Math.min(sumTwo, sumFive);\\n\\n                        max = Math.max(max, ans);\\n                    }\\n                }\\n                \\n                \\n            }\\n        }\\n        return max;\\n    }\\n    \\n\\n    \\n    public int find(int val, int divide){\\n        if (divide == 2){\\n            if (findTwoCache.containsKey(val)) return findTwoCache.get(val);\\n            int res = 0;\\n            int save = val;\\n            \\n            while (val > 0 && val % 2 == 0){\\n                val /= 2;\\n                res++;\\n            }\\n            findTwoCache.put(save, res);\\n            return res;\\n        }\\n        else {\\n            if (findFiveCache.containsKey(val)) return findFiveCache.get(val);\\n            int res = 0;\\n            int save = val;\\n            \\n            while (val > 0 && val % 5 == 0){\\n                val /= 5;\\n                res++;\\n            }\\n            findFiveCache.put(save, res);\\n            return res;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Map<Integer, Integer> findTwoCache;\\n    Map<Integer, Integer> findFiveCache;\\n    public int maxTrailingZeros(int[][] grid) {\\n        findTwoCache = new HashMap<>();\\n        findFiveCache = new HashMap<>();\\n        int n= grid.length;\\n        int m = grid[0].length;\\n        int[][][] fromTop = new int[n][m][2];\\n        \\n        for (int i = 0; i < m;i++){\\n            int countTwo = 0;\\n            int countFive = 0;\\n            for (int j = 0;j < n;j++){\\n                int currVal = grid[j][i];\\n                countTwo += find(currVal, 2);\\n                countFive += find(currVal, 5);\\n                fromTop[j][i][0] = countTwo;\\n                fromTop[j][i][1] = countFive;\\n            }\\n        }\\n        \\n        int[][][] fromLeft = new int[n][m][2];\\n        \\n\\n        for (int i = 0;i < n;i++){\\n            int countTwo = 0;\\n            int countFive = 0;\\n            for (int j =0;j < m;j++){\\n                int currVal = grid[i][j];\\n                countTwo += find(currVal, 2);\\n                countFive += find(currVal, 5);\\n                fromLeft[i][j][0] = countTwo;\\n                fromLeft[i][j][1] = countFive;\\n            }\\n        }\\n\\n        \\n        int max = 0;\\n        \\n        for (int i = 0; i < n;i++){\\n            for (int j =0;j < m;j++){\\n\\n                // in each index we have 4 options, we can pick 2\\n                int currVal = grid[i][j];\\n                int currTwo = find(currVal, 2);\\n                int currFive = find(currVal, 5);\\n                \\n                int upTwo = 0;\\n                int upFive = 0;\\n                \\n                if (i - 1 >= 0){\\n                     upTwo = fromTop[i-1][j][0];\\n                 upFive = fromTop[i-1][j][1];\\n                }\\n                \\n                // down is basically the very bottom value - our current value\\n                int downTwo = fromTop[n-1][j][0] - fromTop[i][j][0];\\n                int downFive = fromTop[n-1][j][1] - fromTop[i][j][1];\\n                \\n                // left is just current from left - currentVal\\n                int leftTwo = 0;\\n                int leftFive = 0;\\n                if (j > 0){\\n                     leftTwo = fromLeft[i][j-1][0];\\n                    leftFive = fromLeft[i][j-1][1];\\n                }\\n                \\n                // right is very right - our current value and all left\\n                int rightTwo = fromLeft[i][m-1][0] - fromLeft[i][j][0];\\n                int rightFive = fromLeft[i][m-1][1] - fromLeft[i][j][1];\\n                \\n\\n                \\n                List<int[]> arr = new ArrayList<>();\\n                \\n                arr.add(new int[]{upTwo, upFive});\\n                arr.add(new int[]{downTwo, downFive});\\n                arr.add(new int[]{leftTwo, leftFive});\\n                arr.add(new int[]{rightTwo, rightFive});\\n                \\n                for (int a = 0; a < arr.size();a++){\\n                    for (int b = a+1;b < arr.size();b++){\\n                        int sumTwo = arr.get(a)[0] + arr.get(b)[0] + currTwo;\\n                        int sumFive = arr.get(a)[1] + arr.get(b)[1] + currFive;\\n                        int ans = Math.min(sumTwo, sumFive);\\n\\n                        max = Math.max(max, ans);\\n                    }\\n                }\\n                \\n                \\n            }\\n        }\\n        return max;\\n    }\\n    \\n\\n    \\n    public int find(int val, int divide){\\n        if (divide == 2){\\n            if (findTwoCache.containsKey(val)) return findTwoCache.get(val);\\n            int res = 0;\\n            int save = val;\\n            \\n            while (val > 0 && val % 2 == 0){\\n                val /= 2;\\n                res++;\\n            }\\n            findTwoCache.put(save, res);\\n            return res;\\n        }\\n        else {\\n            if (findFiveCache.containsKey(val)) return findFiveCache.get(val);\\n            int res = 0;\\n            int save = val;\\n            \\n            while (val > 0 && val % 5 == 0){\\n                val /= 5;\\n                res++;\\n            }\\n            findFiveCache.put(save, res);\\n            return res;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955633,
                "title": "c-prefix-sum-for-4-directions-o-m-n-solution",
                "content": "Number of trailing zeroes = minimum ( 2s, 5s) in prime factorisation of that number.\\n**Steps**:\\n1. Convert the given array into pair ```{x,y} ``` where x = 2s, y = 5s\\n2. make prefix sum for all four directions.\\n3. Now iterate over all indices assuming that current index is the corner of our cornered path.\\n4. Compute the anser for all four directions and take maximum of those.\\n\\nThank You for reading :)\\n```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& g) {\\n        int n = g.size(),m = g[0].size();\\n        auto a = process(g);\\n        //prefix sums\\n        auto lef = Left(a);\\n        auto rig = Right(a);\\n        auto top = Top(a);\\n        auto bot = Bottom(a);\\n    \\n        int ans = 0;\\n        \\n        // If (i,j) is the corner of the cornered path\\n        for(int i =0;i<n;i++){\\n            for(int j =0;j<m;j++){\\n                //for an corner we have four differnt possiblilities\\n                ans = max ({ ans,\\n                           compute(a[i][j],lef[i][j],top[i][j]),\\n                           compute(a[i][j],lef[i][j],bot[i][j]),\\n                           compute(a[i][j],rig[i][j],top[i][j]),\\n                           compute(a[i][j],rig[i][j],bot[i][j])\\n                          });\\n            }\\n        }\\n        return ans;\\n    }\\n    //returns anser for a corner in cornerd path\\n    int compute(pair<int,int>& a,pair<int,int>& b,pair<int,int>& c){\\n        pair<int,int> res;\\n        res.first = a.first + b.first + c.first;\\n        res.second = a.second + b.second + c.second;\\n        //returns minimum because number of zeroes is min of {2s,5s}\\n        return min(res.first,res.second);\\n    }\\n    \\n    //Prefix sum from left to right\\n    vector<vector<pair<int,int>>> Left(vector<vector<pair<int,int>>>& a){\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<pair<int,int>>> res(n,vector<pair<int,int>>(m,{0,0}));\\n        for(int i =0;i<n;i++){\\n            //left to right\\n            for(int j = 1;j<m;j++){\\n                res[i][j]= add(res[i][j-1],a[i][j-1]);\\n            }\\n        }\\n        return res;\\n    }\\n     //Prefix sum from right to left\\n    vector<vector<pair<int,int>>> Right(vector<vector<pair<int,int>>>& a){\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<pair<int,int>>> res(n,vector<pair<int,int>>(m,{0,0}));\\n        for(int i =0;i<n;i++){\\n            // right to left\\n            pair<int,int> t = {0,0};\\n            for(int j = m-2;j>=0;j--){\\n                t = add(t,a[i][j+1]);\\n                res[i][j] = t;\\n            }\\n        }\\n        return res;\\n    }\\n    vector<vector<pair<int,int>>> Top(vector<vector<pair<int,int>>>& a){\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<pair<int,int>>> res(n,vector<pair<int,int>>(m,{0,0}));\\n        for(int j =0;j<m;j++){\\n            //top to bottom\\n            for(int i = 1;i<n;i++){\\n                res[i][j]= add(res[i-1][j],a[i-1][j]);\\n            }\\n        }\\n        return res;\\n    }\\n    vector<vector<pair<int,int>>> Bottom(vector<vector<pair<int,int>>>& a){\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<pair<int,int>>> res(n,vector<pair<int,int>>(m,{0,0}));\\n        for(int j =0;j<m;j++){\\n            pair<int,int> t = {0,0};\\n            for(int i = n-2;i>=0;i--){\\n                t = add(t,a[i+1][j]);\\n                res[i][j] = t;\\n            }\\n        }\\n        return res;\\n    } \\n    \\n    //return {a,b} where a is highest pow of 2, b of 5\\n    vector<vector<pair<int,int>>> process(vector<vector<int>>& g){\\n        vector<vector<pair<int,int>>> res(g.size());\\n        for(int i =0;i<g.size();i++){\\n            for(int j = 0;j<g[0].size();j++){\\n                int num = g[i][j];\\n                int x = highestPow(2,num);\\n                int y = highestPow(5,num);\\n                res[i].push_back({x,y});\\n            }\\n        }\\n        return res;\\n    }\\n    //pow of a in b\\n    int highestPow(int a,int b){\\n        if(b%a) return 0;\\n        return 1 + highestPow(a,b/a);\\n    }\\n    \\n\\n    pair<int,int> add(pair<int,int>& a,pair<int,int>& b){\\n        pair<int,int> res;\\n        res.first = a.first + b.first;\\n        res.second = a.second + b.second;\\n        return res;\\n    }\\n    pair<int,int> Max(pair<int,int>& a,pair<int,int>& b){\\n        pair<int,int> res;\\n        res.first = max(a.first ,b.first);\\n        res.second = max(a.second , b.second);\\n        return res;\\n    }\\n    \\n    void debug(vector<vector<pair<int,int>>>& a){\\n        for(int i =0;i<a.size();i++){\\n            for(int j =0;j<a[0].size();j++){\\n                cout<<a[i][j].first<<\",\"<<a[i][j].second<<\"  \";\\n            }\\n            cout<<endl;\\n        }\\n        cout<<endl;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```{x,y} ```\n```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& g) {\\n        int n = g.size(),m = g[0].size();\\n        auto a = process(g);\\n        //prefix sums\\n        auto lef = Left(a);\\n        auto rig = Right(a);\\n        auto top = Top(a);\\n        auto bot = Bottom(a);\\n    \\n        int ans = 0;\\n        \\n        // If (i,j) is the corner of the cornered path\\n        for(int i =0;i<n;i++){\\n            for(int j =0;j<m;j++){\\n                //for an corner we have four differnt possiblilities\\n                ans = max ({ ans,\\n                           compute(a[i][j],lef[i][j],top[i][j]),\\n                           compute(a[i][j],lef[i][j],bot[i][j]),\\n                           compute(a[i][j],rig[i][j],top[i][j]),\\n                           compute(a[i][j],rig[i][j],bot[i][j])\\n                          });\\n            }\\n        }\\n        return ans;\\n    }\\n    //returns anser for a corner in cornerd path\\n    int compute(pair<int,int>& a,pair<int,int>& b,pair<int,int>& c){\\n        pair<int,int> res;\\n        res.first = a.first + b.first + c.first;\\n        res.second = a.second + b.second + c.second;\\n        //returns minimum because number of zeroes is min of {2s,5s}\\n        return min(res.first,res.second);\\n    }\\n    \\n    //Prefix sum from left to right\\n    vector<vector<pair<int,int>>> Left(vector<vector<pair<int,int>>>& a){\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<pair<int,int>>> res(n,vector<pair<int,int>>(m,{0,0}));\\n        for(int i =0;i<n;i++){\\n            //left to right\\n            for(int j = 1;j<m;j++){\\n                res[i][j]= add(res[i][j-1],a[i][j-1]);\\n            }\\n        }\\n        return res;\\n    }\\n     //Prefix sum from right to left\\n    vector<vector<pair<int,int>>> Right(vector<vector<pair<int,int>>>& a){\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<pair<int,int>>> res(n,vector<pair<int,int>>(m,{0,0}));\\n        for(int i =0;i<n;i++){\\n            // right to left\\n            pair<int,int> t = {0,0};\\n            for(int j = m-2;j>=0;j--){\\n                t = add(t,a[i][j+1]);\\n                res[i][j] = t;\\n            }\\n        }\\n        return res;\\n    }\\n    vector<vector<pair<int,int>>> Top(vector<vector<pair<int,int>>>& a){\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<pair<int,int>>> res(n,vector<pair<int,int>>(m,{0,0}));\\n        for(int j =0;j<m;j++){\\n            //top to bottom\\n            for(int i = 1;i<n;i++){\\n                res[i][j]= add(res[i-1][j],a[i-1][j]);\\n            }\\n        }\\n        return res;\\n    }\\n    vector<vector<pair<int,int>>> Bottom(vector<vector<pair<int,int>>>& a){\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<pair<int,int>>> res(n,vector<pair<int,int>>(m,{0,0}));\\n        for(int j =0;j<m;j++){\\n            pair<int,int> t = {0,0};\\n            for(int i = n-2;i>=0;i--){\\n                t = add(t,a[i+1][j]);\\n                res[i][j] = t;\\n            }\\n        }\\n        return res;\\n    } \\n    \\n    //return {a,b} where a is highest pow of 2, b of 5\\n    vector<vector<pair<int,int>>> process(vector<vector<int>>& g){\\n        vector<vector<pair<int,int>>> res(g.size());\\n        for(int i =0;i<g.size();i++){\\n            for(int j = 0;j<g[0].size();j++){\\n                int num = g[i][j];\\n                int x = highestPow(2,num);\\n                int y = highestPow(5,num);\\n                res[i].push_back({x,y});\\n            }\\n        }\\n        return res;\\n    }\\n    //pow of a in b\\n    int highestPow(int a,int b){\\n        if(b%a) return 0;\\n        return 1 + highestPow(a,b/a);\\n    }\\n    \\n\\n    pair<int,int> add(pair<int,int>& a,pair<int,int>& b){\\n        pair<int,int> res;\\n        res.first = a.first + b.first;\\n        res.second = a.second + b.second;\\n        return res;\\n    }\\n    pair<int,int> Max(pair<int,int>& a,pair<int,int>& b){\\n        pair<int,int> res;\\n        res.first = max(a.first ,b.first);\\n        res.second = max(a.second , b.second);\\n        return res;\\n    }\\n    \\n    void debug(vector<vector<pair<int,int>>>& a){\\n        for(int i =0;i<a.size();i++){\\n            for(int j =0;j<a[0].size();j++){\\n                cout<<a[i][j].first<<\",\"<<a[i][j].second<<\"  \";\\n            }\\n            cout<<endl;\\n        }\\n        cout<<endl;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1955629,
                "title": "simple-kotlin-solution-prefix-sum",
                "content": "1. Create helper arrays with counts of factors 2 and 5 in the corner of the grid (0,0), (x, y)\\n2. Loop through all cells and assume it is our turning point, checking how many zeros we can have with different path configurations\\n3. return max\\n\\nThe tricky part here is to correctly code all the math. I was getting WA during the contest because of incorrect formulas. Creating helper functions fixed all issues, but it was too late).\\n\\n```kotlin\\nclass Solution {\\n    fun maxTrailingZeros(grid: Array<IntArray>): Int {\\n        val m = grid.size\\n        val n = grid[0].size\\n        \\n        // twos[x][y] = count of factors of 2 in a grid from (0,0) to (x-1, y-1) \\n        val twos = Array(m+1) {\\n            IntArray(n+1)\\n        }\\n        // twos[x][y] = count of factors of 5 in a grid from (0,0) to (x-1, y-1) \\n        val fives = Array(m+1) {\\n            IntArray(n+1)\\n        }\\n        \\n        // populate counts\\n        for (x in 1..m) {\\n            for (y in 1..n) {\\n                twos[x][y] = twos[x-1][y] + (twos[x][y-1] - twos[x-1][y-1]) + countFactors(grid[x-1][y-1], 2)\\n                fives[x][y] = fives[x-1][y] + (fives[x][y-1] - fives[x-1][y-1]) + countFactors(grid[x-1][y-1], 5)\\n            }\\n        }\\n        \\n        var result = 0\\n        \\n        for (x in 1..m) {\\n           for (y in 1..n) {\\n                // top-left corners \\n                var t = twos[x][y] - twos[x-1][y-1]\\n                var f = fives[x][y] - fives[x-1][y-1]\\n                result = maxOf(result, minOf(t, f))\\n                \\n                // top-right corners\\n                t = topRight(twos, x, y) - topRight(twos, x-1, y+1)\\n                f = topRight(fives, x, y) - topRight(fives, x-1, y+1)\\n                result = maxOf(result, minOf(t, f))\\n                \\n                // bottom-left corners\\n                t = bottomLeft(twos, x, y) - bottomLeft(twos, x+1, y-1)\\n                f = bottomLeft(fives, x, y) - bottomLeft(fives, x+1, y-1)\\n                result = maxOf(result, minOf(t, f))\\n                \\n                // bottom-right corners\\n                t = bottomRight(twos, x, y) - bottomRight(twos, x+1, y+1)\\n                f = bottomRight(fives, x, y) - bottomRight(fives, x+1, y+1)\\n                result = maxOf(result, minOf(t, f))\\n           } \\n        }\\n        \\n        return result\\n    }\\n    \\n    // returns count in a top-right rectangle (x, y)\\n    private fun topRight(a: Array<IntArray>, x: Int, y: Int): Int {\\n        val m = a.size-1\\n        val n = a[0].size-1\\n        return a[x][n] - a[x][y-1]\\n    }\\n    \\n    // returns count in a bottom-left rectangle (x, y)\\n    private fun bottomLeft(a: Array<IntArray>, x: Int, y: Int): Int {\\n        val m = a.size-1\\n        val n = a[0].size-1\\n        return a[m][y] - a[x-1][y]\\n    }\\n    \\n    // returns count in a bottom-right rectangle (x, y)\\n    private fun bottomRight(a: Array<IntArray>, x: Int, y: Int): Int {\\n        val m = a.size-1\\n        val n = a[0].size-1\\n        return a[m][n] - a[m][y-1] - a[x-1][n] + a[x-1][y-1]\\n    }\\n    \\n    private fun countFactors(x: Int, prime: Int): Int {\\n        var v = x\\n        var result = 0\\n        while (v > 0 && v % prime == 0) {\\n            result++\\n            v /= prime\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\nclass Solution {\\n    fun maxTrailingZeros(grid: Array<IntArray>): Int {\\n        val m = grid.size\\n        val n = grid[0].size\\n        \\n        // twos[x][y] = count of factors of 2 in a grid from (0,0) to (x-1, y-1) \\n        val twos = Array(m+1) {\\n            IntArray(n+1)\\n        }\\n        // twos[x][y] = count of factors of 5 in a grid from (0,0) to (x-1, y-1) \\n        val fives = Array(m+1) {\\n            IntArray(n+1)\\n        }\\n        \\n        // populate counts\\n        for (x in 1..m) {\\n            for (y in 1..n) {\\n                twos[x][y] = twos[x-1][y] + (twos[x][y-1] - twos[x-1][y-1]) + countFactors(grid[x-1][y-1], 2)\\n                fives[x][y] = fives[x-1][y] + (fives[x][y-1] - fives[x-1][y-1]) + countFactors(grid[x-1][y-1], 5)\\n            }\\n        }\\n        \\n        var result = 0\\n        \\n        for (x in 1..m) {\\n           for (y in 1..n) {\\n                // top-left corners \\n                var t = twos[x][y] - twos[x-1][y-1]\\n                var f = fives[x][y] - fives[x-1][y-1]\\n                result = maxOf(result, minOf(t, f))\\n                \\n                // top-right corners\\n                t = topRight(twos, x, y) - topRight(twos, x-1, y+1)\\n                f = topRight(fives, x, y) - topRight(fives, x-1, y+1)\\n                result = maxOf(result, minOf(t, f))\\n                \\n                // bottom-left corners\\n                t = bottomLeft(twos, x, y) - bottomLeft(twos, x+1, y-1)\\n                f = bottomLeft(fives, x, y) - bottomLeft(fives, x+1, y-1)\\n                result = maxOf(result, minOf(t, f))\\n                \\n                // bottom-right corners\\n                t = bottomRight(twos, x, y) - bottomRight(twos, x+1, y+1)\\n                f = bottomRight(fives, x, y) - bottomRight(fives, x+1, y+1)\\n                result = maxOf(result, minOf(t, f))\\n           } \\n        }\\n        \\n        return result\\n    }\\n    \\n    // returns count in a top-right rectangle (x, y)\\n    private fun topRight(a: Array<IntArray>, x: Int, y: Int): Int {\\n        val m = a.size-1\\n        val n = a[0].size-1\\n        return a[x][n] - a[x][y-1]\\n    }\\n    \\n    // returns count in a bottom-left rectangle (x, y)\\n    private fun bottomLeft(a: Array<IntArray>, x: Int, y: Int): Int {\\n        val m = a.size-1\\n        val n = a[0].size-1\\n        return a[m][y] - a[x-1][y]\\n    }\\n    \\n    // returns count in a bottom-right rectangle (x, y)\\n    private fun bottomRight(a: Array<IntArray>, x: Int, y: Int): Int {\\n        val m = a.size-1\\n        val n = a[0].size-1\\n        return a[m][n] - a[m][y-1] - a[x-1][n] + a[x-1][y-1]\\n    }\\n    \\n    private fun countFactors(x: Int, prime: Int): Int {\\n        var v = x\\n        var result = 0\\n        while (v > 0 && v % prime == 0) {\\n            result++\\n            v /= prime\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955610,
                "title": "python-prefix-sum-pre-compute-factors-of-2-and-5-beats-100-time",
                "content": "One trick is to notice that each entry is bound to be between 1 and 1000 so we can just pre-compute and lookup (seem to save significant amount of time):\\n\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        d = {}\\n        for i in range(1, 1001):\\n            n_2 = 0\\n            curr = i\\n            while curr % 2 == 0:\\n                curr //= 2\\n                n_2 += 1\\n            n_5 = 0\\n            curr = i\\n            while curr % 5 == 0:\\n                curr //= 5\\n                n_5 += 1\\n            d[i] = (n_2, n_5)\\n            \\n        grid_25 = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                grid_25[i][j] = d[grid[i][j]]\\n        \\n        # print(grid_25)\\n        grid_row_sum = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            n_2 = 0\\n            n_5 = 0\\n            for j in range(n):\\n                x, y = grid_25[i][j]\\n                n_2 += x\\n                n_5 += y\\n                grid_row_sum[i][j] = (n_2, n_5)\\n                \\n        grid_col_sum = [[0 for _ in range(n)] for _ in range(m)]\\n        for j in range(n):\\n            n_2 = 0\\n            n_5 = 0\\n            for i in range(m):\\n                x, y = grid_25[i][j]\\n                n_2 += x\\n                n_5 += y\\n                grid_col_sum[i][j] = (n_2, n_5)\\n        \\n        # rows_c = rows.copy()\\n        # cols_c = cols.copy()\\n        # print(grid_row_sum)\\n        # print(grid_col_sum)\\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                # there are 4 options:\\n                a0 = min(grid_row_sum[i][j][0] + grid_col_sum[i][j][0] - grid_25[i][j][0], \\n                         grid_row_sum[i][j][1] + grid_col_sum[i][j][1] - grid_25[i][j][1])\\n                a1 = min(grid_row_sum[i][j][0] + grid_col_sum[-1][j][0] - grid_col_sum[i][j][0], \\n                         grid_row_sum[i][j][1] + grid_col_sum[-1][j][1] - grid_col_sum[i][j][1])\\n                a2 = min(grid_row_sum[i][-1][0] - grid_row_sum[i][j][0] + grid_col_sum[i][j][0], \\n                         grid_row_sum[i][-1][1] - grid_row_sum[i][j][1] + grid_col_sum[i][j][1])\\n                a3 = min(grid_row_sum[i][-1][0] - grid_row_sum[i][j][0] + grid_col_sum[-1][j][0] - grid_col_sum[i][j][0] + grid_25[i][j][0], \\n                         grid_row_sum[i][-1][1] - grid_row_sum[i][j][1] + grid_col_sum[-1][j][1] - grid_col_sum[i][j][1] + grid_25[i][j][1])\\n                # print(a0, a1, a2, a3)\\n                ans = max(a0, a1, a2, a3, ans)\\n                # print(ans)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        d = {}\\n        for i in range(1, 1001):\\n            n_2 = 0\\n            curr = i\\n            while curr % 2 == 0:\\n                curr //= 2\\n                n_2 += 1\\n            n_5 = 0\\n            curr = i\\n            while curr % 5 == 0:\\n                curr //= 5\\n                n_5 += 1\\n            d[i] = (n_2, n_5)\\n            \\n        grid_25 = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                grid_25[i][j] = d[grid[i][j]]\\n        \\n        # print(grid_25)\\n        grid_row_sum = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            n_2 = 0\\n            n_5 = 0\\n            for j in range(n):\\n                x, y = grid_25[i][j]\\n                n_2 += x\\n                n_5 += y\\n                grid_row_sum[i][j] = (n_2, n_5)\\n                \\n        grid_col_sum = [[0 for _ in range(n)] for _ in range(m)]\\n        for j in range(n):\\n            n_2 = 0\\n            n_5 = 0\\n            for i in range(m):\\n                x, y = grid_25[i][j]\\n                n_2 += x\\n                n_5 += y\\n                grid_col_sum[i][j] = (n_2, n_5)\\n        \\n        # rows_c = rows.copy()\\n        # cols_c = cols.copy()\\n        # print(grid_row_sum)\\n        # print(grid_col_sum)\\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                # there are 4 options:\\n                a0 = min(grid_row_sum[i][j][0] + grid_col_sum[i][j][0] - grid_25[i][j][0], \\n                         grid_row_sum[i][j][1] + grid_col_sum[i][j][1] - grid_25[i][j][1])\\n                a1 = min(grid_row_sum[i][j][0] + grid_col_sum[-1][j][0] - grid_col_sum[i][j][0], \\n                         grid_row_sum[i][j][1] + grid_col_sum[-1][j][1] - grid_col_sum[i][j][1])\\n                a2 = min(grid_row_sum[i][-1][0] - grid_row_sum[i][j][0] + grid_col_sum[i][j][0], \\n                         grid_row_sum[i][-1][1] - grid_row_sum[i][j][1] + grid_col_sum[i][j][1])\\n                a3 = min(grid_row_sum[i][-1][0] - grid_row_sum[i][j][0] + grid_col_sum[-1][j][0] - grid_col_sum[i][j][0] + grid_25[i][j][0], \\n                         grid_row_sum[i][-1][1] - grid_row_sum[i][j][1] + grid_col_sum[-1][j][1] - grid_col_sum[i][j][1] + grid_25[i][j][1])\\n                # print(a0, a1, a2, a3)\\n                ans = max(a0, a1, a2, a3, ans)\\n                # print(ans)\\n        return ans\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564619,
                "content": [
                    {
                        "username": "a13r1",
                        "content": "![image](https://assets.leetcode.com/users/images/a5780313-467a-43eb-9732-d681f806ef71_1650170050.8714461.gif)\\n"
                    },
                    {
                        "username": "datle2802",
                        "content": "the fact that this is the only and most upvoted comment ;D"
                    },
                    {
                        "username": "archiegertsman",
                        "content": "I found LeetCode to be picky about runtime for this problem. My code was only accepted after I vectorized a computation in Python3. Imho, this problem should be categorized as \"hard\"."
                    },
                    {
                        "username": "2106_ayush_2003",
                        "content": "Skip this Question to avoid wasting time!!"
                    },
                    {
                        "username": "aryonbe",
                        "content": "At first sight, this problem seems very difficult!"
                    }
                ]
            },
            {
                "id": 1992342,
                "content": [
                    {
                        "username": "a13r1",
                        "content": "![image](https://assets.leetcode.com/users/images/a5780313-467a-43eb-9732-d681f806ef71_1650170050.8714461.gif)\\n"
                    },
                    {
                        "username": "datle2802",
                        "content": "the fact that this is the only and most upvoted comment ;D"
                    },
                    {
                        "username": "archiegertsman",
                        "content": "I found LeetCode to be picky about runtime for this problem. My code was only accepted after I vectorized a computation in Python3. Imho, this problem should be categorized as \"hard\"."
                    },
                    {
                        "username": "2106_ayush_2003",
                        "content": "Skip this Question to avoid wasting time!!"
                    },
                    {
                        "username": "aryonbe",
                        "content": "At first sight, this problem seems very difficult!"
                    }
                ]
            },
            {
                "id": 1844333,
                "content": [
                    {
                        "username": "a13r1",
                        "content": "![image](https://assets.leetcode.com/users/images/a5780313-467a-43eb-9732-d681f806ef71_1650170050.8714461.gif)\\n"
                    },
                    {
                        "username": "datle2802",
                        "content": "the fact that this is the only and most upvoted comment ;D"
                    },
                    {
                        "username": "archiegertsman",
                        "content": "I found LeetCode to be picky about runtime for this problem. My code was only accepted after I vectorized a computation in Python3. Imho, this problem should be categorized as \"hard\"."
                    },
                    {
                        "username": "2106_ayush_2003",
                        "content": "Skip this Question to avoid wasting time!!"
                    },
                    {
                        "username": "aryonbe",
                        "content": "At first sight, this problem seems very difficult!"
                    }
                ]
            },
            {
                "id": 1764055,
                "content": [
                    {
                        "username": "a13r1",
                        "content": "![image](https://assets.leetcode.com/users/images/a5780313-467a-43eb-9732-d681f806ef71_1650170050.8714461.gif)\\n"
                    },
                    {
                        "username": "datle2802",
                        "content": "the fact that this is the only and most upvoted comment ;D"
                    },
                    {
                        "username": "archiegertsman",
                        "content": "I found LeetCode to be picky about runtime for this problem. My code was only accepted after I vectorized a computation in Python3. Imho, this problem should be categorized as \"hard\"."
                    },
                    {
                        "username": "2106_ayush_2003",
                        "content": "Skip this Question to avoid wasting time!!"
                    },
                    {
                        "username": "aryonbe",
                        "content": "At first sight, this problem seems very difficult!"
                    }
                ]
            }
        ]
    }
]