[
    {
        "title": "Plus One",
        "question_content": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.\n&nbsp;\nExample 1:\n\nInput: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].\n\nExample 2:\n\nInput: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].\n\nExample 3:\n\nInput: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].\n\n&nbsp;\nConstraints:\n\n\t1 <= digits.length <= 100\n\t0 <= digits[i] <= 9\n\tdigits does not contain any leading 0's.",
        "solutions": [
            {
                "id": 24082,
                "title": "my-simple-java-solution",
                "content": "    public int[] plusOne(int[] digits) {\\n            \\n        int n = digits.length;\\n        for(int i=n-1; i>=0; i--) {\\n            if(digits[i] < 9) {\\n                digits[i]++;\\n                return digits;\\n            }\\n            \\n            digits[i] = 0;\\n        }\\n        \\n        int[] newNumber = new int [n+1];\\n        newNumber[0] = 1;\\n        \\n        return newNumber;\\n    }",
                "solutionTags": [],
                "code": "    public int[] plusOne(int[] digits) {\\n            \\n        int n = digits.length;\\n        for(int i=n-1; i>=0; i--) {\\n            if(digits[i] < 9) {\\n                digits[i]++;\\n                return digits;\\n            }\\n            \\n            digits[i] = 0;\\n        }\\n        \\n        int[] newNumber = new int [n+1];\\n        newNumber[0] = 1;\\n        \\n        return newNumber;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2706861,
                "title": "java-fastest-0ms-runtime-easy-and-elegant-solution",
                "content": "```\\nfor (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;\\n```\\n\\n\\nexplanation\\n\\n```\\nfor (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t\\t// starting from extreme right--> if array[i] is less than 9 means can be added with 1\\n\\t\\t// i.e. [ 5,8 ]-->[ 5,9 ] or\\n\\t\\t//      [ 9,4 ]-->[ 9,5 ] or\\n\\t\\t//      [ 6,0 ]-->[ 6,1 ]\\n\\t\\t// and will directly return array\\n\\t}\\n\\tdigits[i] = 0;\\n\\t// if array[i] is not less than 9, means it have to be 9 only then digit is changed to 0,\\n\\t// and we again revolve around loop to check for number if less than 9 or not\\n\\t// i.e. [ 5,9 ]-->[ 5,0 ]-loop->[ 6,0 ] or\\n\\t//      [ 1,9,9 ]-->[ 1,9,0 ]-loop->[ 1,0,0 ]-loop->[ 2,0,0 ]\\n\\t// and will directly return array\\n}\\n\\n// if all number inside array are 9\\n// i.e. [ 9,9,9,9 ] than according to above loop it will become [ 0,0,0,0 ]\\n// but we have to make it like this [ 9,9,9,9 ]-->[ 1,0,0,0,0 ]\\n\\n\\n// to make like above we need to make new array of length--> n+1\\n// by default new array values are set to -->0 only\\n// thus just changed first value of array to 1 and return the array\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;\\n```\\n\\n**TC O(n)\\nSC O(n)**\\n\\n\\n\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE !**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nfor (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;\\n```\n```\\nfor (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t\\t// starting from extreme right--> if array[i] is less than 9 means can be added with 1\\n\\t\\t// i.e. [ 5,8 ]-->[ 5,9 ] or\\n\\t\\t//      [ 9,4 ]-->[ 9,5 ] or\\n\\t\\t//      [ 6,0 ]-->[ 6,1 ]\\n\\t\\t// and will directly return array\\n\\t}\\n\\tdigits[i] = 0;\\n\\t// if array[i] is not less than 9, means it have to be 9 only then digit is changed to 0,\\n\\t// and we again revolve around loop to check for number if less than 9 or not\\n\\t// i.e. [ 5,9 ]-->[ 5,0 ]-loop->[ 6,0 ] or\\n\\t//      [ 1,9,9 ]-->[ 1,9,0 ]-loop->[ 1,0,0 ]-loop->[ 2,0,0 ]\\n\\t// and will directly return array\\n}\\n\\n// if all number inside array are 9\\n// i.e. [ 9,9,9,9 ] than according to above loop it will become [ 0,0,0,0 ]\\n// but we have to make it like this [ 9,9,9,9 ]-->[ 1,0,0,0,0 ]\\n\\n\\n// to make like above we need to make new array of length--> n+1\\n// by default new array values are set to -->0 only\\n// thus just changed first value of array to 1 and return the array\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3054321,
                "title": "simple-c-solution-with-good-explanation",
                "content": "# Intuition\\nIf we thought that all elements of the vector is a number we need to increase it by 1. The input can be 100 digits so we must handle that through digits.\\n\\n# Approach\\nFirst we increment the first digit (last element) by 1, if it becomes 10 we make it 0 ans add 1 to the second digit.. until the last digit (first element), if it becoms 10 we make it 1 and push_back a leading zero.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& v) {\\n        int n = v.size();\\n        for(int i = n-1; i >= 0; i--){\\n            if(i == n-1)\\n                v[i]++;\\n            if(v[i] == 10){\\n                v[i] = 0;\\n                if(i != 0){\\n                    v[i-1]++;\\n                }\\n                else{\\n                    v.push_back(0);\\n                    v[i] = 1;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nDon\\'t forget please :\\')\\n\\n![UPVOTE.jpg](https://assets.leetcode.com/users/images/a6b046f8-0b13-4de1-95f9-78327b0dccba_1673782056.4431267.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& v) {\\n        int n = v.size();\\n        for(int i = n-1; i >= 0; i--){\\n            if(i == n-1)\\n                v[i]++;\\n            if(v[i] == 10){\\n                v[i] = 0;\\n                if(i != 0){\\n                    v[i-1]++;\\n                }\\n                else{\\n                    v.push_back(0);\\n                    v[i] = 1;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723116,
                "title": "c-solution-with-intuitive-explanation",
                "content": "My solution is nothing special and isn\\'t clever at all.  I decided to post it since I thought the [\"official\" solution article from leetcode](https://leetcode.com/problems/plus-one/solution/) was very poorly written and confused me more, even after I solved it on my own.\\n\\nSo, I believe my comments below should explain the idea, but I want to add that it helps to test the more obscure test cases for this problem to understand the algorithm.  For example:\\n\\n- `[9]`\\n- `[9090]`\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n      int n = digits.size() - 1;\\n      \\n      for (int i = n; i >= 0; --i) { // traverse digits from the last element (least significant)\\n        // since we begin with the last digit, increasing that digit by one\\n        // results in overflow.  Therefore, all elements PRIOR to digits[0]\\n        // need to be considered since there may be additional nines between\\n        // digits[0], ... , digits[n].\\n        if (digits[i] == 9) {  \\n          digits[i] = 0;\\n        } else {  // current digit is not 9 so we can safely increment by one\\n          digits[i] += 1;\\n          return digits;\\n        }\\n      }\\n      // if the program runs to this point, each 9 is now a 0.\\n      // to get a correct solution, we need to add one more element with \\n      // a value of zero AND set digits[0] to 1 (in the most significant position)\\n      // to account for the carry digit.\\n      digits.push_back(0);\\n      digits[0] = 1;\\n      return digits;\\n    }\\n};\\n```\\n\\nAs always, I look forward to comments and feedback. :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n      int n = digits.size() - 1;\\n      \\n      for (int i = n; i >= 0; --i) { // traverse digits from the last element (least significant)\\n        // since we begin with the last digit, increasing that digit by one\\n        // results in overflow.  Therefore, all elements PRIOR to digits[0]\\n        // need to be considered since there may be additional nines between\\n        // digits[0], ... , digits[n].\\n        if (digits[i] == 9) {  \\n          digits[i] = 0;\\n        } else {  // current digit is not 9 so we can safely increment by one\\n          digits[i] += 1;\\n          return digits;\\n        }\\n      }\\n      // if the program runs to this point, each 9 is now a 0.\\n      // to get a correct solution, we need to add one more element with \\n      // a value of zero AND set digits[0] to 1 (in the most significant position)\\n      // to account for the carry digit.\\n      digits.push_back(0);\\n      digits[0] = 1;\\n      return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24139,
                "title": "simple-java-solution",
                "content": "\\n    public int[] plusOne(int[] digits) {\\n        for (int i = digits.length - 1; i >=0; i--) {\\n            if (digits[i] != 9) {\\n                digits[i]++;\\n                break;\\n            } else {\\n                digits[i] = 0;\\n            }\\n        }\\n        if (digits[0] == 0) {\\n            int[] res = new int[digits.length+1];\\n            res[0] = 1;\\n            return res;\\n        }\\n        return digits;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public int[] plusOne(int[] digits) {\\n        for (int i = digits.length - 1; i >=0; i--) {\\n            if (digits[i] != 9) {\\n                digits[i]++;\\n                break;\\n            } else {\\n                digits[i] = 0;\\n            }\\n        }\\n        if (digits[0] == 0) {\\n            int[] res = new int[digits.length+1];\\n            res[0] = 1;\\n            return res;\\n        }\\n        return digits;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24085,
                "title": "simple-python-solution-with-explanation-plus-one",
                "content": "    def plusOne(digits):\\n        num = 0\\n        for i in range(len(digits)):\\n        \\tnum += digits[i] * pow(10, (len(digits)-1-i))\\n        return [int(i) for i in str(num+1)]\\n\\nWe're given a list of digits, and the idea here is to convert that list to an integer, *num*. So each digit is multiplied by the proper place value and added to *num*. For example, if *digits* = [3, 8, 2, 5] then on the first iteration 3 is multiplied by 10 to the power of 4-1-0 = 3, so this results in 3000, which is added to *num*. Then 8 is multiplied by 10^2 and added to *num*, and so on.\\n\\nThe last step is to add 1 to *num*, convert it to a list and return that list.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def plusOne(digits):\\n        num = 0\\n        for i in range(len(digits)):\\n        \\tnum += digits[i] * pow(10, (len(digits)-1-i))\\n        return [int(i) for i in str(num+1)]\\n\\nWe're given a list of digits, and the idea here is to convert that list to an integer, *num*. So each digit is multiplied by the proper place value and added to *num*. For example, if *digits* = [3, 8, 2, 5] then on the first iteration 3 is multiplied by 10 to the power of 4-1-0 = 3, so this results in 3000, which is added to *num*. Then 8 is multiplied by 10^2 and added to *num*, and so on.\\n\\nThe last step is to add 1 to *num*, convert it to a list and return that list.",
                "codeTag": "Python3"
            },
            {
                "id": 24289,
                "title": "java-concise-solution-with-early-return",
                "content": "    \\n    public int[] plusOne(int[] digits) {\\n        int carry = 1;\\n        for (int i = digits.length-1; i>= 0; i--) {\\n            digits[i] += carry;\\n            if (digits[i] <= 9) // early return \\n                return digits;\\n            digits[i] = 0;\\n        }\\n        int[] ret = new int[digits.length+1];\\n        ret[0] = 1;\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    \\n    public int[] plusOne(int[] digits) {\\n        int carry = 1;\\n        for (int i = digits.length-1; i>= 0; i--) {\\n            digits[i] += carry;\\n            if (digits[i] <= 9) // early return \\n                return digits;\\n            digits[i] = 0;\\n        }\\n        int[] ret = new int[digits.length+1];\\n        ret[0] = 1;\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 438791,
                "title": "recursive-python-solution-98-87-speed-100-memory",
                "content": "While this can be solved with a one liner, I thought that it was also a good candidate for a simple little soliution that modfiies the values in the list without converting to different formats etc. Uses recursion to deal with adding 1 to 9.\\n```python\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        if digits[-1] < 9:\\n            digits[-1] += 1\\n            return digits\\n        elif len(digits) == 1 and digits[0] == 9:\\n            return [1, 0]\\n        else:\\n            digits[-1] = 0\\n            digits[0:-1] = self.plusOne(digits[0:-1])\\n            return digits\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        if digits[-1] < 9:\\n            digits[-1] += 1\\n            return digits\\n        elif len(digits) == 1 and digits[0] == 9:\\n            return [1, 0]\\n        else:\\n            digits[-1] = 0\\n            digits[0:-1] = self.plusOne(digits[0:-1])\\n            return digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24297,
                "title": "simple-direct-javascript-solution",
                "content": "    var plusOne = function(digits) {\\n    for(var i = digits.length - 1; i >= 0; i--){\\n         digits[i]++; \\n        if(digits[i] > 9){\\n            digits[i] = 0;\\n        }else{\\n            return digits;\\n        }\\n    }\\n    digits.unshift(1);\\n    return digits;\\n    };\\n\\n\\nFirst, I add 1 anyway. If there is a carry-over, the new digit will also add 1. If the current digit is less than 9 then return the array. \\n\\nLast, when running over for loop, I just put fill 1 in front of the array.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var plusOne = function(digits) {\\n    for(var i = digits.length - 1; i >= 0; i--){\\n         digits[i]++; \\n        if(digits[i] > 9){\\n            digits[i] = 0;\\n        }else{\\n            return digits;\\n        }\\n    }\\n    digits.unshift(1);\\n    return digits;\\n    };\\n\\n\\nFirst, I add 1 anyway. If there is a carry-over, the new digit will also add 1. If the current digit is less than 9 then return the array. \\n\\nLast, when running over for loop, I just put fill 1 in front of the array.",
                "codeTag": "Unknown"
            },
            {
                "id": 3090372,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n       int n = digits.size() - 1;\\n      \\n      for (int i = n; i >= 0; --i)\\n      { \\n        if (digits[i] == 9)\\n            digits[i] = 0;\\n      else\\n      {  \\n          digits[i] += 1;\\n          return digits;\\n        }\\n      }\\n      digits.push_back(0);\\n      digits[0] = 1;\\n      return digits;\\n    } \\n    \\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n       int n = digits.size() - 1;\\n      \\n      for (int i = n; i >= 0; --i)\\n      { \\n        if (digits[i] == 9)\\n            digits[i] = 0;\\n      else\\n      {  \\n          digits[i] += 1;\\n          return digits;\\n        }\\n      }\\n      digits.push_back(0);\\n      digits[0] = 1;\\n      return digits;\\n    } \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24122,
                "title": "my-c-solution-with-few-lines",
                "content": "    class Solution {\\n    public:\\n        vector<int> plusOne(vector<int> &digits) {\\n            bool carry = true;\\n            \\n            for(int i=digits.size()-1; i >= 0 && carry; i--) {\\n                carry = (++digits[i]%=10) == 0;\\n            }\\n    \\n            if(carry) {\\n                digits.insert(digits.begin(), 1);\\n            }\\n        \\n            return digits;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> plusOne(vector<int> &digits) {\\n            bool carry = true;\\n            \\n            for(int i=digits.size()-1; i >= 0 && carry; i--) {\\n                carry = (++digits[i]%=10) == 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 24353,
                "title": "simple-javascript-solution",
                "content": "    var plusOne = function(digits) {\\n      for(var i = digits.length - 1; i >= 0; i--){\\n        if(++digits[i] > 9) digits[i] = 0;\\n        else return digits;\\n      }\\n      digits.unshift(1);\\n      return digits;\\n    };",
                "solutionTags": [],
                "code": "    var plusOne = function(digits) {\\n      for(var i = digits.length - 1; i >= 0; i--){\\n        if(++digits[i] > 9) digits[i] = 0;\\n        else return digits;\\n      }\\n      digits.unshift(1);\\n      return digits;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 24091,
                "title": "easy-python-solution-o-n",
                "content": "\\n    def plusOne(digits):\\n        digits[-1] += 1\\n        for i in range(len(digits)-1, 0, -1):\\n            if digits[i] != 10:\\n                break\\n            digits[i] = 0\\n            digits[i-1] += 1\\n        \\n        if digits[0] == 10:\\n            digits[0] = 0\\n            return [1] + digits\\n        return digits",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n    def plusOne(digits):\\n        digits[-1] += 1\\n        for i in range(len(digits)-1, 0, -1):\\n            if digits[i] != 10:\\n                break\\n            digits[i] = 0\\n            digits[i-1] += 1\\n        \\n        if digits[0] == 10:\\n            digits[0] = 0\\n            return [1] + digits\\n        return digits",
                "codeTag": "Python3"
            },
            {
                "id": 24090,
                "title": "python-simple-solution-using-recursion",
                "content": "    def plusOne(self, digits):\\n        \"\"\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(digits) == 0:\\n            digits = [1]\\n        elif digits[-1] == 9:\\n            digits = self.plusOne(digits[:-1])\\n            digits.extend([0])\\n        else:\\n            digits[-1] += 1\\n        return digits",
                "solutionTags": [],
                "code": "    def plusOne(self, digits):\\n        \"\"\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(digits) == 0:\\n            digits = [1]\\n        elif digits[-1] == 9:\\n            digits = self.plusOne(digits[:-1])\\n            digits.extend([0])\\n        else:\\n            digits[-1] += 1\\n        return digits",
                "codeTag": "Python3"
            },
            {
                "id": 485912,
                "title": "c-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        for(int i = digits.size() - 1;i >= 0;i--){\\n            if(digits[i] != 9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            else\\n                digits[i] = 0;\\n        }\\n        digits.insert(digits.begin(),1);\\n        return digits;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        for(int i = digits.size() - 1;i >= 0;i--){\\n            if(digits[i] != 9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            else\\n                digits[i] = 0;\\n        }\\n        digits.insert(digits.begin(),1);\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 147127,
                "title": "javascript-simple-solution",
                "content": "```\\nvar plusOne = function(digits) {\\n  for(let i = digits.length - 1; i >= 0; i --){\\n    if(digits[i] === 9){\\n      digits[i] = 0;\\n    }\\n    else {\\n      digits[i] ++;\\n      return digits;\\n    }\\n  }\\n  return [1, ...digits];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar plusOne = function(digits) {\\n  for(let i = digits.length - 1; i >= 0; i --){\\n    if(digits[i] === 9){\\n      digits[i] = 0;\\n    }\\n    else {\\n      digits[i] ++;\\n      return digits;\\n    }\\n  }\\n  return [1, ...digits];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3129110,
                "title": "simplest-python-approach-beats-99-5",
                "content": "# Intuition\\nOften the obvious approach is among the best. If you just convert to an integer and add one, it beats 98% of solutions.\\n\\n# Approach\\nInstead of looping across the list and accounting for random 9s, just convert to an integer and add one.  Then convert back to a list.\\n\\n# Complexity\\nThe time complexity is O(n) because we have to traverse the list exactly once then convert back to a list.\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits):\\n        strings = \"\"\\n        for number in digits:\\n            strings += str(number)\\n\\n        temp = str(int(strings) +1)\\n\\n        return [int(temp[i]) for i in range(len(temp))]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits):\\n        strings = \"\"\\n        for number in digits:\\n            strings += str(number)\\n\\n        temp = str(int(strings) +1)\\n\\n        return [int(temp[i]) for i in range(len(temp))]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383696,
                "title": "super-simple-java-solution-explained-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int len = digits.length; // length of array;\\n        \\n        // start the loop from last index;\\n        for (int i = len-1; i>=0; i--) {\\n            // if ith index is 9, that means there will be an overflow if we add 1\\n            // adding 1 will make it 10, so we set it to 0. and continue the loop; \\n            if (digits[i] == 9) {\\n                digits[i] = 0;\\n            }else {\\n                // if ith value is not 9 we just add 1 to it and return;\\n                digits[i] += 1;\\n                return digits;\\n            }     \\n        }\\n        \\n        // if we are here, that means all the value of the array were 9;\\n        // and they are 0 now;\\n        // example: [9,9,9,9], after loop becomes [0,0,0,0];\\n        // so we have to create a new array of +1 length of the previous.\\n        // and place 1 at 0th index;\\n        int[] arr = new int[len+1];\\n        arr[0] = 1;\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int len = digits.length; // length of array;\\n        \\n        // start the loop from last index;\\n        for (int i = len-1; i>=0; i--) {\\n            // if ith index is 9, that means there will be an overflow if we add 1\\n            // adding 1 will make it 10, so we set it to 0. and continue the loop; \\n            if (digits[i] == 9) {\\n                digits[i] = 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3073756,
                "title": "one-line-js-solution-with-full-explanation-beginner-friendly",
                "content": "\\n# Approach\\nAs we are told we are given a large integer represented as an integer array. So we should use the BigInt type. Our first work is joining the numbers using join() method and of course we wrap it in BigInt and add BigInt(1). Because we can\\'t add regular number to bigInt, this is why we are using the bigInt type for 1 too. And we convert the BigInt to a string and split() it\\n\\n# Complexity\\n- Time complexity:\\nRuntime: 65 ms\\nBeats 74.99%\\n\\n\\n- Space complexity:\\nMemor: 41.7 MB\\nBeats 81.73%\\n\\n# Code\\n```\\n/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nvar plusOne = function(digits) {\\n    return (BigInt(digits.join(\"\")) + BigInt(1)).toString().split(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nvar plusOne = function(digits) {\\n    return (BigInt(digits.join(\"\")) + BigInt(1)).toString().split(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2674763,
                "title": "c-simple-solution",
                "content": "```\\n for(int i = digits.size()-1; i>=0; i--){\\n                    if(digits[i]<9){\\n                    digits[i]++;\\n                    return digits;\\n                    }\\n                    else\\n                            digits[i] = 0;\\n                    \\n            }\\n            digits.push_back(0);\\n            digits[0] = 1;\\n            return digits;\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n for(int i = digits.size()-1; i>=0; i--){\\n                    if(digits[i]<9){\\n                    digits[i]++;\\n                    return digits;\\n                    }\\n                    else\\n                            digits[i] = 0;\\n                    \\n            }\\n            digits.push_back(0);\\n            digits[0] = 1;\\n            return digits;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 468139,
                "title": "python-3-one-line-solution-explained",
                "content": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        return [x for x in str(int(\\'\\'.join(map(str, digits))) + 1)]\\n```\\n\\n1. `map(str, digits)` - applies funciton `str` to every element of the list, returning iterable object \\n2. `\\'\\'.join()` - joins all elements inside parentheses together, using empty separator, specified between `\\'\\'`\\n3. `int` converts joined string og digits to integer value\\n4. `+1` increases it\\n5. `str` converts new number into string\\n6. `[x for x in ...]` generates list of digits in string from step 5.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        return [x for x in str(int(\\'\\'.join(map(str, digits))) + 1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758992,
                "title": "c-solution-that-passed-all-test-cases",
                "content": "C# Solution that passed all test cases\\n\\n```\\n        public int[] PlusOne(int[] digits)\\n        {\\n            int n = digits.Length;\\n            for (int i = n - 1; i >= 0; i--)\\n            {\\n                if (digits[i] < 9)\\n                {\\n                    digits[i]++;\\n                    return digits;\\n                }\\n                digits[i] = 0;\\n            }\\n            int[] newNumber = new int[n + 1];\\n            newNumber[0] = 1;\\n\\n            return newNumber;\\n        }\\n\\t\\t\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n        public int[] PlusOne(int[] digits)\\n        {\\n            int n = digits.Length;\\n            for (int i = n - 1; i >= 0; i--)\\n            {\\n                if (digits[i] < 9)\\n                {\\n                    digits[i]++;\\n                    return digits;\\n                }\\n                digits[i] = 0;\\n            }\\n            int[] newNumber = new int[n + 1];\\n            newNumber[0] = 1;\\n\\n            return newNumber;\\n        }\\n\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 409531,
                "title": "javascript-easy-to-understand-solution",
                "content": "```/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nvar plusOne = function(digits) {\\n    for(let i = digits.length - 1; i>= 0; i--){\\n        if(digits[i] < 9){\\n            digits[i]++\\n            return digits\\n        }\\n        \\n        digits[i] = 0\\n    }\\n    digits.unshift(1)\\n    return digits\\n};```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nvar plusOne = function(digits) {\\n    for(let i = digits.length - 1; i>= 0; i--){\\n        if(digits[i] < 9){\\n            digits[i]++\\n            return digits\\n        }\\n        \\n        digits[i] = 0\\n    }\\n    digits.unshift(1)\\n    return digits\\n};```",
                "codeTag": "Unknown"
            },
            {
                "id": 24294,
                "title": "golang-go-solution",
                "content": "    func plusOne(digits []int) []int {\\n        var n int = len(digits)\\n        for i:= n-1; i>=0; i--{\\n            if digits[i] < 9 {\\n                digits[i]+=1\\n                return digits\\n            } else {\\n                digits[i] = 0\\n            }\\n        }\\n        var a = make([]int,n+1)\\n        a[0] = 1\\n        return a\\n    \\n    }",
                "solutionTags": [
                    "Go"
                ],
                "code": "    func plusOne(digits []int) []int {\\n        var n int = len(digits)\\n        for i:= n-1; i>=0; i--{\\n            if digits[i] < 9 {\\n                digits[i]+=1\\n                return digits\\n            } else {\\n                digits[i] = 0\\n            }\\n        }\\n        var a = make([]int,n+1)\\n        a[0] = 1\\n        return a\\n    \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1915685,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the digits.\\n    //   - space: O(n), where n is the length of the digits.\\n\\n    func plusOne(_ digits: [Int]) -> [Int] {\\n        var digits = digits\\n\\n        for i in (0..<digits.count).reversed() {\\n            guard digits[i] == 9 else {\\n                digits[i] += 1\\n                return digits\\n            }\\n\\n            digits[i] = 0\\n        }\\n\\n        digits.insert(1, at: 0)\\n        return digits\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the digits.\\n    //   - space: O(n), where n is the length of the digits.\\n\\n    func plusOne(_ digits: [Int]) -> [Int] {\\n        var digits = digits\\n\\n        for i in (0..<digits.count).reversed() {\\n            guard digits[i] == 9 else {\\n                digits[i] += 1\\n                return digits\\n            }\\n\\n            digits[i] = 0\\n        }\\n\\n        digits.insert(1, at: 0)\\n        return digits\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24320,
                "title": "java-recursion-solution",
                "content": "    public class Solution {\\n        public int[] plusOne(int[] digits) {\\n            return helper(digits,digits.length-1);\\n        }\\n        \\n        private int[] helper(int[] digits, int index){\\n            if(digits[index] < 9){\\n                digits[index]++;\\n                return digits;\\n            }else{\\n                if(index != 0){\\n                    digits[index] = 0;\\n                    return helper(digits,index-1);\\n                }else{\\n                    int[] res = new int[digits.length+1];\\n                    res[0] = 1;\\n                    return res;\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int[] plusOne(int[] digits) {\\n            return helper(digits,digits.length-1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 587672,
                "title": "javascript-simple-solution",
                "content": "Runtime: 52 ms, faster than 81.75% of JavaScript online submissions for Plus One.\\nMemory Usage: 33.8 MB, less than 55.32% of JavaScript online submissions for Plus One.\\n```\\nfunction plusOne(digits) {\\n  let co = true;\\n  for (let i = digits.length - 1; i >= 0 && co; i--) {\\n    digits[i]++;\\n    co = digits[i] >= 10;\\n    co && (digits[i] = 0);\\n  }\\n  co && digits.unshift(1);\\n  return digits;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunction plusOne(digits) {\\n  let co = true;\\n  for (let i = digits.length - 1; i >= 0 && co; i--) {\\n    digits[i]++;\\n    co = digits[i] >= 10;\\n    co && (digits[i] = 0);\\n  }\\n  co && digits.unshift(1);\\n  return digits;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3745099,
                "title": "one-for-loop-beats-93",
                "content": "# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n\\n        for i in range(len(digits)-1,-1,-1):\\n            if digits[i]==9:\\n                digits[i]=0\\n            else:\\n                digits[i]+=1\\n                return digits\\n        return [1]+digits\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n\\n        for i in range(len(digits)-1,-1,-1):\\n            if digits[i]==9:\\n                digits[i]=0\\n            else:\\n                digits[i]+=1\\n                return digits\\n        return [1]+digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727575,
                "title": "python-100-speed-one-liner-hardworking-way",
                "content": "**Python | 100% Speed | One Liner + Hardworking Way**\\n\\n**A) Python One-Liner**\\n\\nShameless Python One-Liner, O(n) solution.\\nDe-compressed Steps:\\n\\n1. The integer-array \"digits\" is first converted into a joined string: [1,2,3] -> \"123\".  ***Code:**   a = \\'\\'.join(map(str,digits))*\\n2. The joined string is then converted into an integer, and we add one.  ***Code:**   b = int(a)+1\\n3. Our new integer is re-converted into a string, and then into a list format. Finally, the INT operator is applied to each element of the list to obtain new integer digits ***Code:**   [ int(c) for c in str(b) ]  or  list(map(int,str(b)))\\n\\n```\\n# Version A: Outer Loop\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        return [int(x) for x in  str(int(\\'\\'.join(map(str,digits)))+1) ]\\n```\\n\\n```\\n# Version B: Pure Functions\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        return list(map(int,str(int(\\'\\'.join(map(str,digits)))+1)))\\n```\\n\\n**B) Hardworking Digit Processing - O(1) space**\\n```\\n# Hard-Working Version: Manual Digit Check\\n# O(1) space, and O(1) time for most cases as well (with few chained 9\\'s in the lower digits)\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        if not digits:\\n            return digits\\n        i = len(digits)-1\\n        digits[i] += 1\\n        while digits[i]==10:\\n            digits[i] = 0\\n            if i==0:\\n                digits.insert(0,1)\\n            else:\\n                digits[i-1] += 1\\n                i -= 1\\n        return digits\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Version A: Outer Loop\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        return [int(x) for x in  str(int(\\'\\'.join(map(str,digits)))+1) ]\\n```\n```\\n# Version B: Pure Functions\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        return list(map(int,str(int(\\'\\'.join(map(str,digits)))+1)))\\n```\n```\\n# Hard-Working Version: Manual Digit Check\\n# O(1) space, and O(1) time for most cases as well (with few chained 9\\'s in the lower digits)\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        if not digits:\\n            return digits\\n        i = len(digits)-1\\n        digits[i] += 1\\n        while digits[i]==10:\\n            digits[i] = 0\\n            if i==0:\\n                digits.insert(0,1)\\n            else:\\n                digits[i-1] += 1\\n                i -= 1\\n        return digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422298,
                "title": "python-solution-faster-than-97-02",
                "content": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        for idx in range(len(digits)-1, -1, -1):\\n            if digits[idx] != 9:\\n                digits[idx] += 1\\n                break\\n            else:\\n                digits[idx] = 0\\n        if digits[0] == 0:\\n            digits.insert(0, 1)\\n        return digits\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        for idx in range(len(digits)-1, -1, -1):\\n            if digits[idx] != 9:\\n                digits[idx] += 1\\n                break\\n            else:\\n                digits[idx] = 0\\n        if digits[0] == 0:\\n            digits.insert(0, 1)\\n        return digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322882,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn plus_one(mut digits: Vec<i32>) -> Vec<i32> {\\n        for x in digits.iter_mut().rev() {\\n            match *x == 9 {\\n                true => *x = 0,\\n                false => {\\n                    *x += 1;\\n                    return digits;\\n                }\\n            }\\n        }\\n        digits.insert(0, 1);\\n        digits\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn plus_one(mut digits: Vec<i32>) -> Vec<i32> {\\n        for x in digits.iter_mut().rev() {\\n            match *x == 9 {\\n                true => *x = 0,\\n                false => {\\n                    *x += 1;\\n                    return digits;\\n                }\\n            }\\n        }\\n        digits.insert(0, 1);\\n        digits\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3708232,
                "title": "easy-and-simplest-c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n= digits.size();\\n        for(int i=n-1; i>=0; i--){\\n            if(digits[i]<9){\\n                digits[i]+=1;\\n                return digits;\\n            }\\n            else{\\n                digits[i]=0;\\n            }\\n        }\\n        digits[0]=1;\\n        digits.push_back(0);\\n        return digits;        \\n    }\\n};\\n```\\n![4i5ri4f9.png](https://assets.leetcode.com/users/images/280cc0bf-e1b5-417b-a72d-4ba7e737f34f_1688448157.4485767.png)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n= digits.size();\\n        for(int i=n-1; i>=0; i--){\\n            if(digits[i]<9){\\n                digits[i]+=1;\\n                return digits;\\n            }\\n            else{\\n                digits[i]=0;\\n            }\\n        }\\n        digits[0]=1;\\n        digits.push_back(0);\\n        return digits;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722211,
                "title": "python-find-maximum-number-of-9-in-the-end-explained",
                "content": "How we can add `1` to given number? We need to find the biggest number of `9` in the end of our number, for example for number `5123521999235123999`, there will be three `9` in the end. `512352199923512`**3999**` + 1 = 512352199923512`**4000**: so we need to increase previous symbol by one and change all `9` after to `0`. Now, the steps of algorithm are to following:\\n\\n1. Let us add one `0` before our data to handle cases like `9`, `99`, `999`, ... \\n2. Find maximum number of `9`, starting from the end and moving to the left.\\n3. Change all found `9` in the end to `0` and previous digit increasy by `1`.\\n4. Handle border cases: if we have leading zero, remove it.\\n\\n**Complexity** time complexity is `O(n)`, where `n` is length of list. Additional space complexity is `O(1)`, because we edit input data directly.\\n\\n```\\nclass Solution:\\n    def plusOne(self, digits):\\n        digits = [0] + digits\\n        \\n        end = len(digits) - 1\\n        while digits[end] == 9:\\n            end -= 1\\n    \\n        digits[end] += 1\\n        digits[end+1:] = [0] * (len(digits)-1-end)\\n                   \\n        return digits if digits[0] != 0 else digits[1:]      \\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits):\\n        digits = [0] + digits\\n        \\n        end = len(digits) - 1\\n        while digits[end] == 9:\\n            end -= 1\\n    \\n        digits[end] += 1\\n        digits[end+1:] = [0] * (len(digits)-1-end)\\n                   \\n        return digits if digits[0] != 0 else digits[1:]      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954062,
                "title": "java-runtime-0-ms-beats-100",
                "content": "# Intuition\\nMy initial approach to solving this problem involves adding one to the given integer represented by an array of digits. I\\'ll iterate through the array of digits from right to left, simulating the process of adding one to the number.\\n\\n# Approach\\nI will iterate through the array of digits from right to left. For each digit, I\\'ll check if it\\'s 9. If it\\'s 9, I\\'ll set it to 0 and continue iterating. If it\\'s not 9, I\\'ll increment it by one and immediately return the modified array. This is because there\\'s no need to carry over to the next digit in this case.\\n\\nIf the loop completes without returning, it means all digits were 9, and we need to add a new leading digit. I\\'ll create a new array with a length one more than the original array, set the first element to 1, and return the new array.\\n\\n# Complexity\\n- Time complexity: O(n)\\n  The algorithm iterates through the array of digits once, where \\'n\\' is the length of the array.\\n\\n- Space complexity: O(n) or O(n+1)\\n  In the worst case, the algorithm creates a new array with a length one more than the original array. Thus, the space complexity can be considered O(n+1).\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        for (int i = digits.length - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                digits[i] = 0;\\n            } else {\\n                digits[i]++;\\n                return digits;\\n            }\\n        }\\n        \\n        int[] newDigits = new int[digits.length + 1];\\n        newDigits[0] = 1;\\n        return newDigits;\\n    }\\n        \\n\\n    }\\n\\n\\n\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/8a3b41d1-f0ca-472f-a9f7-8346b34a824e_1693297402.2918687.webp)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        for (int i = digits.length - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                digits[i] = 0;\\n            } else {\\n                digits[i]++;\\n                return digits;\\n            }\\n        }\\n        \\n        int[] newDigits = new int[digits.length + 1];\\n        newDigits[0] = 1;\\n        return newDigits;\\n    }\\n        \\n\\n    }\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568113,
                "title": "easy-c-solution-o-n-time-complexity-just-using-one-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will see the last element as we have to add 1 to it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Start traversing through end.\\n2. If last element is not 9, just add 1 to it and return the vector.\\n3. If last element is 9, make it zero, move ahead (reverse order).\\n4. Now if this element is not 9, add 1 to it and return vector, otherwise if it is also 9, make it zero and repeat the 3rd and 4th steps.\\n5. Now, if the number is 999, then we have to make it 1000 (999 + 1 = 1000). So, push 0 to the last of our vector (0,0,0) so that it becomes (0,0,0,0) and make first element \\'1\\' => 1000.\\n6. This is how we add 1 to the number!\\n7. Thank You, Don\\'t forget to upvote :)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& v) {\\n        int n = v.size();\\n\\n        for(int i=n-1; i>=0; i--){\\n            if(v[i]<9){\\n                ++v[i];\\n                return v;\\n            }else{\\n                v[i] = 0;\\n            }\\n        }\\n\\n        v.push_back(0);      // to handle \\'999\\' => 999 + 1 = 1000\\n        v[0] = 1;\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& v) {\\n        int n = v.size();\\n\\n        for(int i=n-1; i>=0; i--){\\n            if(v[i]<9){\\n                ++v[i];\\n                return v;\\n            }else{\\n                v[i] = 0;\\n            }\\n        }\\n\\n        v.push_back(0);      // to handle \\'999\\' => 999 + 1 = 1000\\n        v[0] = 1;\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455692,
                "title": "java-100-faster-step-by-step-explained-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/15360baf-39c0-45e7-b2e2-b8d6d07813d5_1682477226.014943.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n        // Starting from the least significant digit (i.e., the last element of the array)\\n        for (int i = n - 1; i >= 0; i--) {\\n            // If the current digit is less than 9, we can add 1 to it and return the updated array\\n            if (digits[i] < 9) {\\n                digits[i]++; // Add 1 to the current digit\\n                return digits; // Return the updated array\\n            }\\n            // If the current digit is 9, we set it to 0 and continue with the next digit\\n            else {\\n                digits[i] = 0; // Set the current digit to 0\\n            }\\n        }\\n        // If we reach here, it means all digits were 9, so we need to create a new array with one more element\\n        int[] result = new int[n + 1]; // Create a new array with length n + 1\\n        result[0] = 1; // Set the first element to 1, since all other elements are 0 by default\\n        return result; // Return the new array\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n        // Starting from the least significant digit (i.e., the last element of the array)\\n        for (int i = n - 1; i >= 0; i--) {\\n            // If the current digit is less than 9, we can add 1 to it and return the updated array\\n            if (digits[i] < 9) {\\n                digits[i]++; // Add 1 to the current digit\\n                return digits; // Return the updated array\\n            }\\n            // If the current digit is 9, we set it to 0 and continue with the next digit\\n            else {\\n                digits[i] = 0; // Set the current digit to 0\\n            }\\n        }\\n        // If we reach here, it means all digits were 9, so we need to create a new array with one more element\\n        int[] result = new int[n + 1]; // Create a new array with length n + 1\\n        result[0] = 1; // Set the first element to 1, since all other elements are 0 by default\\n        return result; // Return the new array\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1614101,
                "title": "c-simple-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        for(int i=digits.size()-1;i>=0;i--){\\n            if(digits[i]==9){\\n                digits[i]=0;\\n            }\\n            else{\\n                digits[i]++;\\n                return digits;\\n            }\\n        }\\n        digits[0]=1;\\n        digits.push_back(0);\\n        return digits;\\n    }\\n};\\n```\\n**Please upvote if you like the solution\\ncomment if have doubts**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        for(int i=digits.size()-1;i>=0;i--){\\n            if(digits[i]==9){\\n                digits[i]=0;\\n            }\\n            else{\\n                digits[i]++;\\n                return digits;\\n            }\\n        }\\n        digits[0]=1;\\n        digits.push_back(0);\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529365,
                "title": "java-tc-o-n-sc-o-1-optimized-math-addition-simulation",
                "content": "```java\\n/**\\n * Simulate Math Addition\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1) --> Excluding the result space\\n *\\n * N = Length of input digits array.\\n */\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        if (digits == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = digits.length;\\n        if (len == 0) {\\n            return new int[] { 1 };\\n        }\\n\\n        for (int i = len - 1; i >= 0; i--) {\\n            if (digits[i] != 9) {\\n                digits[i]++;\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n\\n        digits = new int[len + 1];\\n        digits[0] = 1;\\n        return digits;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```java\\n/**\\n * Simulate Math Addition\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1) --> Excluding the result space\\n *\\n * N = Length of input digits array.\\n */\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        if (digits == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = digits.length;\\n        if (len == 0) {\\n            return new int[] { 1 };\\n        }\\n\\n        for (int i = len - 1; i >= 0; i--) {\\n            if (digits[i] != 9) {\\n                digits[i]++;\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n\\n        digits = new int[len + 1];\\n        digits[0] = 1;\\n        return digits;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24310,
                "title": "python-solution-simple",
                "content": "\\n\\n    def plusOne(self, digits):\\n        for i in xrange(len(digits)-1, -1, -1):\\n            if digits[i] < 9:\\n                digits[i] += 1\\n                return digits\\n            digits[i] = 0\\n        return [1] + digits",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\n    def plusOne(self, digits):\\n        for i in xrange(len(digits)-1, -1, -1):\\n            if digits[i] < 9:\\n                digits[i] += 1\\n                return digits\\n            digits[i] = 0\\n        return [1] + digits",
                "codeTag": "Python3"
            },
            {
                "id": 1286610,
                "title": "javascript-simple-iterative-solution-faster-than-92-65-72ms",
                "content": "```\\nvar plusOne = function(digits) {    \\n    for (let i = digits.length - 1; i >= 0; i--) {\\n        if (digits[i] !== 9) {\\n            digits[i]++;\\n            return digits;\\n        }\\n        digits[i] = 0;\\n        if (i === 0) {\\n            digits.unshift(1);\\n            return digits;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar plusOne = function(digits) {    \\n    for (let i = digits.length - 1; i >= 0; i--) {\\n        if (digits[i] !== 9) {\\n            digits[i]++;\\n            return digits;\\n        }\\n        digits[i] = 0;\\n        if (i === 0) {\\n            digits.unshift(1);\\n            return digits;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2283271,
                "title": "100-fast-solution-in-golang-detailed-video-explanation-o-n",
                "content": "I have created a detailed video to explain the logic and the code for this problem you can have a look at it incase you want better understanding on how I came up with the approch\\n[Plus One| O(n) Solution by The Exception Handler](https://www.youtube.com/watch?v=mrYywKoIq-E&list=PL8-bdB4cHmXzuGvBnFmByq-4yyAy-ceaK&index=3)\\n\\n```\\nfunc plusOne(digits []int) []int {\\n    \\n\\tn := len(digits)\\n\\tfor i := n - 1; i >= 0; i-- {\\n\\t\\tif digits[i] < 9 {\\n\\t\\t\\tdigits[i]++\\n\\t\\t\\treturn digits\\n\\t\\t}\\n\\t\\tdigits[i] = 0\\n\\n\\t}\\n\\tdigits = append([]int{1}, digits...)\\n\\treturn digits\\n}\\n```\\n\\nPlease upvote this solution in case you like the explaniation",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc plusOne(digits []int) []int {\\n    \\n\\tn := len(digits)\\n\\tfor i := n - 1; i >= 0; i-- {\\n\\t\\tif digits[i] < 9 {\\n\\t\\t\\tdigits[i]++\\n\\t\\t\\treturn digits\\n\\t\\t}\\n\\t\\tdigits[i] = 0\\n\\n\\t}\\n\\tdigits = append([]int{1}, digits...)\\n\\treturn digits\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1022733,
                "title": "kotlin",
                "content": "```\\nfun plusOne(digits: IntArray): IntArray {\\n        for (i in digits.size - 1 downTo 0) {\\n            digits[i] += 1\\n            if (digits[i] <= 9) return digits\\n            digits[i] = 0\\n        }\\n        val arr = IntArray(digits.size + 1)\\n        arr[0] = 1\\n\\n        return arr\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun plusOne(digits: IntArray): IntArray {\\n        for (i in digits.size - 1 downTo 0) {\\n            digits[i] += 1\\n            if (digits[i] <= 9) return digits\\n            digits[i] = 0\\n        }\\n        val arr = IntArray(digits.size + 1)\\n        arr[0] = 1\\n\\n        return arr\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 832514,
                "title": "javascript-solution-66",
                "content": "```\\n/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nlet plusOne = function(digits) {\\n    for(let i=digits.length-1;i>=0;i--){\\n        digits[i]++;\\n        if(digits[i]>9){\\n            digits[i]=0;\\n        }\\n        else{\\n            return digits;\\n        }\\n    }\\n    digits.unshift(1);\\n    return digits;\\n};\\n```\\n**Runtime: 72 ms, faster than 83.48% of JavaScript online submissions for Plus One.**\\n\\n**Memory Usage: 37 MB, less than 9.82% of JavaScript online submissions for Plus One.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nlet plusOne = function(digits) {\\n    for(let i=digits.length-1;i>=0;i--){\\n        digits[i]++;\\n        if(digits[i]>9){\\n            digits[i]=0;\\n        }\\n        else{\\n            return digits;\\n        }\\n    }\\n    digits.unshift(1);\\n    return digits;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24086,
                "title": "recursive-c-solution-3ms",
                "content": "```\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        if (digits.back() == 9)\\n        {\\n            digits.pop_back();\\n            digits = plusOne(digits);\\n            digits.push_back(0);\\n        }\\n        \\n        else if (digits.empty())\\n            digits.push_back(1);\\n\\n        else\\n            digits.back()++;\\n        \\n        return digits;\\n    }\\n```\\nIf the last digit is ```9```, we remove that ```9``` from the vector and add ```1``` to the vector without ```9```; essentially carrying the ```1```. After adding the ```1``` we put``` 0``` at the end of the vector, which will take the place of the ```9 ```from this particular recursion. Since the input is described as non-empty, we can assume the vector will only be empty if it was composed solely of 9's. Thus, we simply push_back ```1``` and return the vector.\\nThis allows for ```plusOne([9,9,9])``` to return ```[1,0,0,0]```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        if (digits.back() == 9)\\n        {\\n            digits.pop_back();\\n            digits = plusOne(digits);\\n            digits.push_back(0);\\n        }\\n        \\n        else if (digits.empty())\\n            digits.push_back(1);\\n\\n        else\\n            digits.back()++;\\n        \\n        return digits;\\n    }\\n```\n```9```\n```9```\n```1```\n```9```\n```1```\n```1```\n``` 0```\n```9 ```\n```1```\n```plusOne([9,9,9])```\n```[1,0,0,0]```",
                "codeTag": "Unknown"
            },
            {
                "id": 24125,
                "title": "0ms-java-solution",
                "content": "    public int[] plusOne(int[] digits) {\\n        int i = digits.length - 1;\\n        while(i >= 0){\\n            if(digits[i] == 9)\\n                digits[i--] = 0;\\n            else{\\n                digits[i]++;\\n                return digits;\\n            }\\n        }\\n        int[] array = new int[digits.length+1];\\n        array[0] = 1;\\n        return array;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int[] plusOne(int[] digits) {\\n        int i = digits.length - 1;\\n        while(i >= 0){\\n            if(digits[i] == 9)\\n                digits[i--] = 0;\\n            else{\\n                digits[i]++;\\n                return digits;\\n            }\\n        }\\n        int[] array = new int[digits.length+1];\\n        array[0] = 1;\\n        return array;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24416,
                "title": "share-my-4ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> plusOne(vector<int> &digits) {   //\\u672a\\u8003\\u8651\\u524d\\u7f000\\u7684\\u60c5\\u51b5\\n            for(int i = digits.size() - 1; i >= 0; i--)   \\n            {\\n                if(digits[i] != 9)\\n                {\\n                    digits[i] ++;\\n                    break;\\n                }\\n                digits[i] = 0;\\n            }\\n            if(digits[0] == 0)\\n                digits.insert(digits.begin(), 1);\\n            return digits;\\n            \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> plusOne(vector<int> &digits) {   //\\u672a\\u8003\\u8651\\u524d\\u7f000\\u7684\\u60c5\\u51b5\\n            for(int i = digits.size() - 1; i >= 0; i--)   \\n            {\\n                if(digits[i] != 9)\\n                {\\n                    digits[i] ++;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3032275,
                "title": "beats-98-7-solutions-easy-to-understand-single-for-loop-o-n-tc-in-python-by-bolt-coding",
                "content": "# Explanation\\nWe are iterating from back to the list as we need to add at the end. We are checking if the current digit is 9. That means we have to replace 9 with 0 and have a carry of 1. If thats not the case then we don\\'t have to iterate through whole loop, we can simply return the list of digit from there.\\n\\nIn case its running until the loop ends, that means all the digits are 9. So inorder to insert a 1 at 0 position we appened with an additional 0 at the end and changed digit[0] to 1. Now there are various ways to do the same, we can use insert method as well.\\n# Complexity\\n- Time complexity: O(n) as we are using a single loop and worst case if all the digits are 9 we have to iterate through whole loop \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) as we haven\\'t used any additional variable to store the number.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digit: List[int]) -> List[int]:\\n        for i in range(len(digit)-1, -1, -1):\\n            if digit[i] == 9:\\n                digit[i] = 0\\n            else:\\n                digit[i]+=1\\n                return digit\\n    \\n        digit.append(0)            \\n        digit[0] = 1\\n        return digit\\n        \\n\\n        \\n```\\n# Learning\\nTo understand problems in simpler ways, need help with projects, want to learn coding from scratch, work on resume level projects, learn data science ...................\\n\\nSubscribe to Bolt Coding Channel - https://www.youtube.com/@boltcoding",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digit: List[int]) -> List[int]:\\n        for i in range(len(digit)-1, -1, -1):\\n            if digit[i] == 9:\\n                digit[i] = 0\\n            else:\\n                digit[i]+=1\\n                return digit\\n    \\n        digit.append(0)            \\n        digit[0] = 1\\n        return digit\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331911,
                "title": "javascript-easy-solution",
                "content": "Easy to understand solution I found, not the fastest around, but nice for beginners like me :) \\n\\n```\\nvar plusOne = function(digits) {\\n    const fromArray = digits.join(\\'\\'); // get Digits out of Array\\n    const toInt = BigInt(fromArray) ; //Dont use parseInt, use BigInt instead :) \\n    const addOne = toInt + 1n; // add one! \\n    const result =  Array.from(String(addOne), Number); // return digits to array\\n    return result\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar plusOne = function(digits) {\\n    const fromArray = digits.join(\\'\\'); // get Digits out of Array\\n    const toInt = BigInt(fromArray) ; //Dont use parseInt, use BigInt instead :) \\n    const addOne = toInt + 1n; // add one! \\n    const result =  Array.from(String(addOne), Number); // return digits to array\\n    return result\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24461,
                "title": "fastest-and-simplest-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> plusOne(vector<int> &digits) {\\n            int i,j,carry=1;\\n            // traditional long addition..\\n            for(i=digits.size()-1;i>=0&&carry;i--){\\n                int sum=carry+digits[i];\\n                carry=sum/10;\\n                digits[i]=sum%10;\\n            }\\n            if(carry){ // if carry is 1, then digits must be all 99..999\\n                digits[0]=1;\\n                digits.push_back(0);\\n            }\\n            return digits;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> plusOne(vector<int> &digits) {\\n            int i,j,carry=1;\\n            // traditional long addition..\\n            for(i=digits.size()-1;i>=0&&carry;i--){\\n                int sum=carry+digits[i];\\n                carry=sum/10;\\n                digits[i]=sum%10;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2314145,
                "title": "0ms-1liner-100-fastest-solution-explained-o-n-time-complexity-o-n-space-complexity",
                "content": "\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 3.27MB*** (beats 99.04% / 90.42%).\\n\\n```\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\n    int n = digits.length;\\n    for(int i=n-1; i>=0; i--) {\\n        if(digits[i] < 9) {\\n            digits[i]++;\\n            return digits;\\n        }\\n        \\n        digits[i] = 0;\\n    }\\n    \\n    int[] newNumber = new int [n+1];\\n    newNumber[0] = 1;\\n    \\n    return newNumber;\\n}\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Swift",
                    "Kotlin",
                    "PHP"
                ],
                "code": "```\\n```\n```\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\n    int n = digits.length;\\n    for(int i=n-1; i>=0; i--) {\\n        if(digits[i] < 9) {\\n            digits[i]++;\\n            return digits;\\n        }\\n        \\n        digits[i] = 0;\\n    }\\n    \\n    int[] newNumber = new int [n+1];\\n    newNumber[0] = 1;\\n    \\n    return newNumber;\\n}\\n}\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188812,
                "title": "java-0ms-easy-100",
                "content": "If it helps, do an Upvote \\u2B06\\uFE0F\\uD83C\\uDD99 So others can also find it helpful\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\n        for(int i = digits.length - 1; i >= 0; i--){\\n            if(++digits[i] != 10) return digits;\\n            digits[i] = 0;\\n        }\\n        int [] res = new int[digits.length + 1];\\n        \\n        res[0] = 1;\\n        return res;\\n    }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\n        for(int i = digits.length - 1; i >= 0; i--){\\n            if(++digits[i] != 10) return digits;\\n            digits[i] = 0;\\n        }\\n        int [] res = new int[digits.length + 1];\\n        \\n        res[0] = 1;\\n        return res;\\n    }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24174,
                "title": "simple-swift-solution",
                "content": "```\\nfunc plusOne(_ digits: [Int]) -> [Int] {\\n        var result = digits\\n        for i in (0..<result.count).reversed() {\\n            if result[i] != 9 {\\n                result[i] = result[i]+1\\n                return result\\n            } else {\\n                result[i] = 0\\n            }\\n        }\\n        if result.first == 0 {\\n            result.insert(1, at: 0)\\n        }\\n        return result\\n    }\\n```\\nExplanation: Loop from the end of the array to start. Just add 1 if the digit is not a 9, and return. If digit is a 9, replace it with a 0 and go to the previous digit - rinse an repeat. In the end, check if the first digit of the resulting array is a 0. If it is, that means that the number was of the form 9999... In this case, insert a 1 in the start.",
                "solutionTags": [],
                "code": "```\\nfunc plusOne(_ digits: [Int]) -> [Int] {\\n        var result = digits\\n        for i in (0..<result.count).reversed() {\\n            if result[i] != 9 {\\n                result[i] = result[i]+1\\n                return result\\n            } else {\\n                result[i] = 0\\n            }\\n        }\\n        if result.first == 0 {\\n            result.insert(1, at: 0)\\n        }\\n        return result\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24349,
                "title": "simple-python-o-n-solution-without-converting-to-a-number",
                "content": "The idea here is to start from the right side.  As soon as we find a number that isn't 9 we can add 1 to it and return.  If the number is 9, we change it to 0 and continue until we find a number that is not 9 to carry the 1 to.  If we reach the end of array with all 9's we then insert the 1 in front of array. \\n\\n\\n     def plusOne(self, digits):\\n        for i in range(len(digits)-1, -1, -1):\\n            digits[i] = digits[i] + 1 if digits[i] < 9 else 0\\n            if digits[i]: \\n                return digits\\n        digits.insert(0, 1)\\n        return digits",
                "solutionTags": [
                    "Python"
                ],
                "code": "The idea here is to start from the right side.  As soon as we find a number that isn't 9 we can add 1 to it and return.  If the number is 9, we change it to 0 and continue until we find a number that is not 9 to carry the 1 to.  If we reach the end of array with all 9's we then insert the 1 in front of array. \\n\\n\\n     def plusOne(self, digits):\\n        for i in range(len(digits)-1, -1, -1):\\n            digits[i] = digits[i] + 1 if digits[i] < 9 else 0\\n            if digits[i]: \\n                return digits\\n        digits.insert(0, 1)\\n        return digits",
                "codeTag": "Python3"
            },
            {
                "id": 3624231,
                "title": "easy-approach-0ms-cpp-0-n-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust iterate from back instead of from front. Then keep adding and handling carry variable.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust add as if adding a normal numbers\\nLike if you want to add 239 + 1 then first you do 9+1 = 10, then we take 0 and carry 1.\\nThis 0 above is 10%10 and 1 is 10/10. Thus, I have taken, digits[i] = add%10 and carry is add/10.\\n\\n\\nAt the end if the carry is not 0 --> Add an element in the vector at the frontend.\\nEx - 9 + 1 = 0 and carry 1\\nSo insert it at the beginning as 10 to make 9+1=10\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int carry = 1;\\n        for(int i=digits.size() - 1; i>=0; i--){\\n            int add = digits[i] + carry;\\n            digits[i] = add%10;\\n            carry = add/10;\\n        }\\n        if(carry > 0){\\n            digits.insert(digits.begin(), carry);\\n        }\\n\\n        return digits;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int carry = 1;\\n        for(int i=digits.size() - 1; i>=0; i--){\\n            int add = digits[i] + carry;\\n            digits[i] = add%10;\\n            carry = add/10;\\n        }\\n        if(carry > 0){\\n            digits.insert(digits.begin(), carry);\\n        }\\n\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159471,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def plusOne(self, digits):\\n        \"\"\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        carry = 1\\n        for i in range(len(digits)-1, -1, -1):\\n            carry, digits[i] = divmod(digits[i]+carry, 10)\\n            if carry == 0:\\n                return digits\\n        return [1]+digits\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits):\\n        \"\"\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        carry = 1\\n        for i in range(len(digits)-1, -1, -1):\\n            carry, digits[i] = divmod(digits[i]+carry, 10)\\n            if carry == 0:\\n                return digits\\n        return [1]+digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780735,
                "title": "java-solution-easy-to-undersatnd-explained-in-detail",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n * we started checking from back if last digit is less than 9 we simply add one one to the digit and return the digit.\\n *  otherwise the case will be last digit was 9 so we make the digit 0 as we know 9+1 = 10 so last digit in these cases need to be 0 so we do that.\\n *  here we create a new array of size input given to us +1 so that we can actually add 1 to beginning of our new array and we retuen the new array thats it.For ex:[9,9,9] = [1,0,0,0] in this case we need one more digit space as we need to carry 1 so in this way we do this.\\n\\n\\n**If it is helpful please do upvote,Happy coding!!\\n**\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n        for(int i=n-1;i>=0;i--){  \\n            if(digits[i]<9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            else{\\n                digits[i]=0;\\n            }\\n        }\\n        int [] arr = new int[n+1];\\n        arr[0]=1;\\n        return arr;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n        for(int i=n-1;i>=0;i--){  \\n            if(digits[i]<9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            else{\\n                digits[i]=0;\\n            }\\n        }\\n        int [] arr = new int[n+1];\\n        arr[0]=1;\\n        return arr;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557528,
                "title": "c-easy-solution",
                "content": "/// C# Code\\npublic int[] PlusOne(int[] digits) {\\n        for(int i=digits.Length-1;i>=0;i--)\\n        {\\n            if(digits[i]<9)\\n            {\\n                digits[i]++;\\n                return digits;\\n            }\\n            digits[i]=0;\\n        }\\n        int[] result=new int[digits.Length+1];\\n        result[0]=1;\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "/// C# Code\\npublic int[] PlusOne(int[] digits) {\\n        for(int i=digits.Length-1;i>=0;i--)\\n        {\\n            if(digits[i]<9)\\n            {\\n                digits[i]++;\\n                return digits;\\n            }\\n            digits[i]=0;\\n        }\\n        int[] result=new int[digits.Length+1];\\n        result[0]=1;\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 500774,
                "title": "simple-solution-faster-than-98-82",
                "content": "```\\n    public class Solution\\n    {\\n        public int[] PlusOne(int[] digits)\\n        {\\n            for (int i = digits.Length - 1; i >= 0; i--)\\n            {\\n                if (digits[i] == 9)\\n                {\\n                    digits[i] = 0;\\n                }\\n                else\\n                {\\n                    digits[i]++;\\n                    return digits;\\n                }\\n            }\\n            int[] newBigOne = new int[digits.Length + 1];\\n            newBigOne[0] = 1;\\n            return newBigOne;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        public int[] PlusOne(int[] digits)\\n        {\\n            for (int i = digits.Length - 1; i >= 0; i--)\\n            {\\n                if (digits[i] == 9)\\n                {\\n                    digits[i] = 0;\\n                }\\n                else\\n                {\\n                    digits[i]++;\\n                    return digits;\\n                }\\n            }\\n            int[] newBigOne = new int[digits.Length + 1];\\n            newBigOne[0] = 1;\\n            return newBigOne;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24333,
                "title": "accepted-easy-java-solution",
                "content": "    public static int[] plusOne(int[] digits) {\\n\\t        if(0==digits.length) return digits;\\n\\t\\t    for(int i=digits.length-1;i>=0;i--)\\n\\t\\t    {\\n\\t\\t        \\n\\t\\t       if(digits[i]!=9) {digits[i]++;return digits;}\\n\\t\\t   \\t   else\\tdigits[i]=0;\\n\\t\\t    }\\n\\t\\t  int[] result=new int[digits.length+1];\\n\\t\\t  result[0]=1; \\n\\t\\t  return result;   \\n\\t    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public static int[] plusOne(int[] digits) {\\n\\t        if(0==digits.length) return digits;\\n\\t\\t    for(int i=digits.length-1;i>=0;i--)\\n\\t\\t    {\\n\\t\\t        \\n\\t\\t       if(digits[i]!=9) {digits[i]++;return digits;}\\n\\t\\t   \\t   else\\tdigits[i]=0;\\n\\t\\t    }\\n\\t\\t  int[] result=new int[digits.length+1];\\n\\t\\t  result[0]=1; \\n\\t\\t  return result;   \\n\\t    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24346,
                "title": "c-solution-with-comments",
                "content": "    \\n    int* plusOne(int* digits, int digitsSize, int* returnSize) {\\n    int carry = 1, i = digitsSize;\\n    int* ret = (int*)malloc(sizeof(int)*(digitsSize+1));\\n    while (i > 0) {\\n        ret[i] = (digits[i-1]+carry)%10;\\n        carry = (digits[i-1]+carry)/10;\\n        i--;\\n    }\\n    if (!ret[1]) { \\n        // size increased 1, set the first digit\\n        ret[0] = 1;\\n        *returnSize = digitsSize+1;\\n        return ret;\\n    } else {\\n        *returnSize = digitsSize;\\n        return ret+1;\\n    }",
                "solutionTags": [],
                "code": "    \\n    int* plusOne(int* digits, int digitsSize, int* returnSize) {\\n    int carry = 1, i = digitsSize;\\n    int* ret = (int*)malloc(sizeof(int)*(digitsSize+1));\\n    while (i > 0) {\\n        ret[i] = (digits[i-1]+carry)%10;\\n        carry = (digits[i-1]+carry)/10;\\n        i--;\\n    }\\n    if (!ret[1]) { \\n        // size increased 1, set the first digit\\n        ret[0] = 1;\\n        *returnSize = digitsSize+1;\\n        return ret;\\n    } else {\\n        *returnSize = digitsSize;\\n        return ret+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3192789,
                "title": "easy-solution-javascript",
                "content": "```\\n/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nvar plusOne = function(arr) {\\n    for(let i=arr.length-1; i>=0; i--){\\n        if(arr[i]<9){\\n            arr[i]++;\\n            return arr;\\n        }\\n        arr[i] = 0;\\n    }\\n    arr.unshift(1);\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nvar plusOne = function(arr) {\\n    for(let i=arr.length-1; i>=0; i--){\\n        if(arr[i]<9){\\n            arr[i]++;\\n            return arr;\\n        }\\n        arr[i] = 0;\\n    }\\n    arr.unshift(1);\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3069349,
                "title": "python3-29ms-beats-95",
                "content": "![image.png](https://assets.leetcode.com/users/images/85217fc8-e205-4817-89aa-1d0fb37eae44_1675841089.4490588.png)\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        digits=digits[::-1]\\n        x=1\\n        ans=[]\\n        for i in range(len(digits)):\\n            ans+=[(digits[i]+x)%10]\\n            x=(digits[i]+x)//10\\n        if x:\\n            ans+=[x]\\n        return ans[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        digits=digits[::-1]\\n        x=1\\n        ans=[]\\n        for i in range(len(digits)):\\n            ans+=[(digits[i]+x)%10]\\n            x=(digits[i]+x)//10\\n        if x:\\n            ans+=[x]\\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2520098,
                "title": "easy-javascript-solution",
                "content": "```\\n    // first join the digits with no space and add 1  \\n    let str = digits.join(\"\");\\n    let num = BigInt(str)+ BigInt(1);\\n    // convert the num into array\\n    num = num.toString().split(\\'\\').map((num) => parseInt(num));\\n    return num;",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n    // first join the digits with no space and add 1  \\n    let str = digits.join(\"\");\\n    let num = BigInt(str)+ BigInt(1);\\n    // convert the num into array\\n    num = num.toString().split(\\'\\').map((num) => parseInt(num));\\n    return num;",
                "codeTag": "Unknown"
            },
            {
                "id": 1794804,
                "title": "python3-one-line-simple-and-fastest-using-str-int-and-line-comprehension",
                "content": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        a=[str(i) for i in digits]\\n        a=\\'\\'.join(a)\\n        a=str(int(a)+1)\\n        return [int(i) for i in a]\\n\\n```\\n\\n**compressed into one line**\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        return [int(i) for i in str(int(\\'\\'.join([str(i) for i in digits]))+1)]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        a=[str(i) for i in digits]\\n        a=\\'\\'.join(a)\\n        a=str(int(a)+1)\\n        return [int(i) for i in a]\\n\\n```\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        return [int(i) for i in str(int(\\'\\'.join([str(i) for i in digits]))+1)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232867,
                "title": "js-faster-than-93-o-n",
                "content": "First we add 1 to the last element. \\nThen, we iteratively check starting from least significant to most significant if the digit is a 10. \\nIf it is, we set it to 0 and to the digit before it we add 1.\\nOnce we are done with this, we update the first digit if it\\'s a 10, adding a digit of 1 in front of it.\\n```\\nconst plusOne = (digits) => {\\n  const last = digits.length - 1;\\n  digits[last]++;\\n  for (let i = last; i > 0 && digits[i] === 10; i--) {\\n    digits[i] = 0;\\n    digits[i - 1]++;\\n  }\\n  if (digits[0] === 10) {\\n    digits[0] = 0;\\n    digits.unshift(1);\\n  }\\n  return digits;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst plusOne = (digits) => {\\n  const last = digits.length - 1;\\n  digits[last]++;\\n  for (let i = last; i > 0 && digits[i] === 10; i--) {\\n    digits[i] = 0;\\n    digits[i - 1]++;\\n  }\\n  if (digits[0] === 10) {\\n    digits[0] = 0;\\n    digits.unshift(1);\\n  }\\n  return digits;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 167759,
                "title": "go-solution",
                "content": "```\\nfunc plusOne(digits []int) []int {\\n    for i := len(digits)-1; i >= 0; i-- {\\n        if digits[i] < 9 {\\n            digits[i] += 1\\n            return digits\\n        }\\n        digits[i] = 0\\n    }\\n    \\n    digits = append([]int{1}, digits...)\\n    \\n    return digits\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc plusOne(digits []int) []int {\\n    for i := len(digits)-1; i >= 0; i-- {\\n        if digits[i] < 9 {\\n            digits[i] += 1\\n            return digits\\n        }\\n        digits[i] = 0\\n    }\\n    \\n    digits = append([]int{1}, digits...)\\n    \\n    return digits\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24372,
                "title": "accepted-4ms-c-solution-easy-and-short",
                "content": "    class Solution {\\n    public:\\n        std::vector<int> plusOne(std::vector<int>& digits) {\\n            int pos = digits.size() - 1;\\n            while (pos >= 0 && digits[pos] == 9) {\\n                digits[pos] = 0;\\n                --pos;\\n            }\\n            if (pos == -1) {\\n                digits[0] = 1;\\n                digits.push_back(0);\\n            } else {\\n                ++digits[pos];\\n            }\\n            return digits;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        std::vector<int> plusOne(std::vector<int>& digits) {\\n            int pos = digits.size() - 1;\\n            while (pos >= 0 && digits[pos] == 9) {\\n                digits[pos] = 0;\\n                --pos;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3942526,
                "title": "java-simple-solution-runtime-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n         \\n        int i = 0;\\n        while (i <= digits.length - 1 && digits[digits.length - 1 - i] == 9) {\\n            i++;\\n        }\\n\\n        int[] output = (digits.length == i) ? new int[digits.length + 1] : new int[digits.length];\\n\\n        if (digits.length == i) {\\n            output[0] = 1;\\n        } else {\\n\\n            for (int j = 0; j <= digits.length - i - 1; j++) \\n            {\\n                output[j] = digits[j];\\n            }\\n\\n            output[digits.length - 1 - i] = digits[digits.length - i - 1] + 1;\\n        }\\n        return output;\\n    }\\n}\\n```\\n\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/f7abc399-3a52-4e17-850a-9fc8984ee6c9_1692645882.9655104.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n         \\n        int i = 0;\\n        while (i <= digits.length - 1 && digits[digits.length - 1 - i] == 9) {\\n            i++;\\n        }\\n\\n        int[] output = (digits.length == i) ? new int[digits.length + 1] : new int[digits.length];\\n\\n        if (digits.length == i) {\\n            output[0] = 1;\\n        } else {\\n\\n            for (int j = 0; j <= digits.length - i - 1; j++) \\n            {\\n                output[j] = digits[j];\\n            }\\n\\n            output[digits.length - 1 - i] = digits[digits.length - i - 1] + 1;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056619,
                "title": "c-properly-explained-with-comments",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n      int n = digits.size() - 1;\\n      \\n      for (int i = n; i >= 0; --i) { // traverse digits from the last element (least significant)\\n        // since we begin with the last digit, increasing that digit by one\\n        // results in overflow.  Therefore, all elements PRIOR to digits[0]\\n        // need to be considered since there may be additional nines between\\n        // digits[0], ... , digits[n].\\n        if (digits[i] == 9) {  \\n          digits[i] = 0;\\n        } else {  // current digit is not 9 so we can safely increment by one\\n          digits[i] += 1;\\n          return digits;\\n        }\\n      }\\n      // if the program runs to this point, each 9 is now a 0.\\n      // to get a correct solution, we need to add one more element with \\n      // a value of zero AND set digits[0] to 1 (in the most significant position)\\n      // to account for the carry digit.\\n      digits.push_back(0);\\n      digits[0] = 1;\\n      return digits;\\n    }\\n};\\n\\n```\\n**Please upvote if it helped. Happy Coding**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n      int n = digits.size() - 1;\\n      \\n      for (int i = n; i >= 0; --i) { // traverse digits from the last element (least significant)\\n        // since we begin with the last digit, increasing that digit by one\\n        // results in overflow.  Therefore, all elements PRIOR to digits[0]\\n        // need to be considered since there may be additional nines between\\n        // digits[0], ... , digits[n].\\n        if (digits[i] == 9) {  \\n          digits[i] = 0;\\n        } else {  // current digit is not 9 so we can safely increment by one\\n          digits[i] += 1;\\n          return digits;\\n        }\\n      }\\n      // if the program runs to this point, each 9 is now a 0.\\n      // to get a correct solution, we need to add one more element with \\n      // a value of zero AND set digits[0] to 1 (in the most significant position)\\n      // to account for the carry digit.\\n      digits.push_back(0);\\n      digits[0] = 1;\\n      return digits;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835091,
                "title": "c-most-optimal-solution-0ms-and-less-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s=digits.size()-1;    //Length of the vector \\n        while(s>=0){\\n            if(digits[s]<9){\\n                digits[s]+=1;\\n                return digits;\\n            }\\n            else{\\n                digits[s]=0;\\n                s--;\\n            }\\n        }\\n        vector<int> :: iterator iter=digits.begin();   //Inserting 1 if incase the number is [9],[9,9,9,9] etc\\n        digits.insert(iter,1);\\n        return digits;\\n    }\\n};\\n```\\n\\nPlease upvote if found useful!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s=digits.size()-1;    //Length of the vector \\n        while(s>=0){\\n            if(digits[s]<9){\\n                digits[s]+=1;\\n                return digits;\\n            }\\n            else{\\n                digits[s]=0;\\n                s--;\\n            }\\n        }\\n        vector<int> :: iterator iter=digits.begin();   //Inserting 1 if incase the number is [9],[9,9,9,9] etc\\n        digits.insert(iter,1);\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800794,
                "title": "fast-as-fuck-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> plusOne(vector<int>& digits) {\\n        for(int i = digits.size()-1; i>=0; i--){\\n                    if(digits[i]<9){\\n                    digits[i]++;\\n                    return digits;\\n                    }\\n                    else\\n                            digits[i] = 0;\\n                    \\n            }\\n            digits.push_back(0);\\n            digits[0] = 1;\\n            return digits;\\n    }\\n};\\n```\\nupvote if useful",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> plusOne(vector<int>& digits) {\\n        for(int i = digits.size()-1; i>=0; i--){\\n                    if(digits[i]<9){\\n                    digits[i]++;\\n                    return digits;\\n                    }\\n                    else\\n                            digits[i] = 0;\\n                    \\n            }\\n            digits.push_back(0);\\n            digits[0] = 1;\\n            return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257638,
                "title": "very-easy-java-solution-100-fully-explained-and-understandable",
                "content": "```\\nclass Solution {\\n\\n    public int[] plusOne(int[] digits) {\\n        \\n        //To solve this, we take digits one by one from end to start..\\n        for (int i = digits.length - 1; i >= 0; i--) {\\n            \\n            // If a digit is not equal to 9, we plus one directly and then quit the loop...\\n            if (digits[i] != 9) {\\n                digits[i]++;\\n                break;\\n                \\n            //if the digit is 9, we set it to 0, and continue the loop until\\n            //we encounter the number don\\'t equals to 9...\\n            } else {\\n                digits[i] = 0;\\n            }\\n        }\\n        if (digits[0] == 0) {      //it means, we need a bigger array to represent the number.\\n            int[] res = new int[digits.length + 1];    //so we create a new array res...\\n            res[0] = 1;                                //and set res[0] to 1...\\n            return res;\\n        }\\n        return digits;      //return the digits...\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[] plusOne(int[] digits) {\\n        \\n        //To solve this, we take digits one by one from end to start..\\n        for (int i = digits.length - 1; i >= 0; i--) {\\n            \\n            // If a digit is not equal to 9, we plus one directly and then quit the loop...\\n            if (digits[i] != 9) {\\n                digits[i]++;\\n                break;\\n                \\n            //if the digit is 9, we set it to 0, and continue the loop until\\n            //we encounter the number don\\'t equals to 9...\\n            } else {\\n                digits[i] = 0;\\n            }\\n        }\\n        if (digits[0] == 0) {      //it means, we need a bigger array to represent the number.\\n            int[] res = new int[digits.length + 1];    //so we create a new array res...\\n            res[0] = 1;                                //and set res[0] to 1...\\n            return res;\\n        }\\n        return digits;      //return the digits...\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117634,
                "title": "python-99-75-list-str-int-1-str-list",
                "content": "*Runtime: 20 ms, faster than 99.74% of Python3 online submissions for Plus One.\\nMemory Usage: 14 MB, less than 99.00% of Python3 online submissions for Plus One.*\\n\\nVariables named as writes are much faster than reads:\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        a = \\'\\'.join(map(str, digits))\\n        b = int(a) + 1\\n        c = str(b)\\n        return list(map(int, c))\\n```\\nhttps://leetcode.com/submissions/detail/469908019/",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        a = \\'\\'.join(map(str, digits))\\n        b = int(a) + 1\\n        c = str(b)\\n        return list(map(int, c))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627432,
                "title": "simple-java-code-easy-approach-0ms-runtime",
                "content": "# Intuition\\nAs per the question given we need to increment the array value by one and return the resultant array with ith digit at ith position of that array For example: digits=[1,2,3] after adding one to this array i.e, 123+1=124 ...gives digits=[1,2,4] \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we need to notice that the input maybe given any large integer value so we cannot convert our array into number and increemnt and convert it back as an array instead i followed this follwing logic by taking one place and comparing whether its less than 9 or equal to 9.\\nif its equal to 9 go and check for next ith digit else increment this digit by one and return the array\\nFor better undertanding please see these below steps:\\n1. As its already an int[] array given the last element of the array will be considered as the units place of the number we need to add 1 for last digit if its less than 9\\n2. if the last element is greater than 9 we need to check for before element and increment if its less than 9..\\n3. if all the elements are 9 we need add another element to the array\\nfor example: [9,9] --> [1,0,0]\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    StringBuilder s=new StringBuilder();\\n    public int[] plusOne(int[] digits) {\\n        for(int i=(digits.length)-1;i >= 0;i--){\\n            if(digits[i]<9){\\n                digits[i]=digits[i]+1;\\n                return digits;\\n            }else if(digits[i]==9){\\n                digits[i]=0;\\n            }   \\n        }\\n        int[] newarr=new int[digits.length+1];\\n        newarr[0]=1;\\n        return newarr;\\n    }\\n}\\n```\\n![upvote.png](https://assets.leetcode.com/users/images/239c196e-5f36-48cc-b148-20966d5a3f9f_1687449464.7053354.png)\\n\\n\\n\\n**Guys please upvote if you find my solution worthy!! Thanks!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    StringBuilder s=new StringBuilder();\\n    public int[] plusOne(int[] digits) {\\n        for(int i=(digits.length)-1;i >= 0;i--){\\n            if(digits[i]<9){\\n                digits[i]=digits[i]+1;\\n                return digits;\\n            }else if(digits[i]==9){\\n                digits[i]=0;\\n            }   \\n        }\\n        int[] newarr=new int[digits.length+1];\\n        newarr[0]=1;\\n        return newarr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946815,
                "title": "simple-backward-looping-with-c",
                "content": "# Intuition\\nThought about how we can minimize the amount of computation.\\n\\n# Approach\\nLoop backward. \\n\\n1. In case of 9, assign 0. That means we need to increment next digit.\\n2. The others increment and return the digits. \\n3. If the loop has been finished, that means, it requres additional digit. add it and return it.\\n\\nOnly the 3 cases requires additional Memory space and breaks before reach N.\\n\\n# Complexity\\n- Time complexity:\\nO(2N) = O(N).\\nNOTE: I don\\'t know the internal of Concat method. So that my guess.\\n\\n- Space complexity:\\nO(N): Probably, Linq might create a new List or equivalent.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] PlusOne(int[] digits) {\\n       for(int i = digits.Length - 1; i >= 0; i--) {\\n           if (digits[i] == 9) {\\n               digits[i] = 0;\\n           } else {\\n               digits[i]++;\\n               return digits;\\n           }\\n       } \\n       int[] firstOne = new int[] { 1 };\\n       return firstOne.Concat(digits).ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] PlusOne(int[] digits) {\\n       for(int i = digits.Length - 1; i >= 0; i--) {\\n           if (digits[i] == 9) {\\n               digits[i] = 0;\\n           } else {\\n               digits[i]++;\\n               return digits;\\n           }\\n       } \\n       int[] firstOne = new int[] { 1 };\\n       return firstOne.Concat(digits).ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711629,
                "title": "fastest-and-easiest-one-liner-faster-than-92-submissions",
                "content": "![image](https://assets.leetcode.com/users/images/5c6d1d55-0730-49d9-a4d8-2d838174d939_1666035771.7792413.png)\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        d=int(\"\".join(map(str, digits)))\\n        d+=1\\n        return list(str(d))\\n```\\nDo upvote if its helpful,Thanks.",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        d=int(\"\".join(map(str, digits)))\\n        d+=1\\n        return list(str(d))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543183,
                "title": "easy-java-solution-faster-than-100-users",
                "content": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n        for(int i =n-1;i>=0;i--){\\n            if(digits[i]<9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            digits[i]=0;\\n            \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n        for(int i =n-1;i>=0;i--){\\n            if(digits[i]<9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            digits[i]=0;\\n            \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1754490,
                "title": "c-solution-fastest-with-least-time-complexity-and-constant-space",
                "content": "```\\n        //storing given array\\'s size in n\\n        int n = digits.size();\\n        \\n        //taking flag for putting a condition further in code\\n        bool flag = 0;\\n        \\n        //traversing from the last for incrementing with a condition i.e. digit should be < 9.\\n        for(int i = n-1; i>=0; i--){\\n            //checking condition whether digit < 9\\n            if(digits[i]<9){\\n                digits[i] = digits[i] + 1;\\n                flag = 1;\\n                break;\\n            }else{\\n                //if digit is not < 9, then we have to make it 0(coz 9 + 1 = 10(0 in this case, as we are taking ones place))\\n                digits[i] = 0;\\n            }\\n        }\\n        //checking if flag is still 0, if it is 0 then we have to insert 1 at the beginning\\n        if(flag==0){\\n            digits.insert(digits.begin(), 1);\\n        }\\n        return digits;\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n        //storing given array\\'s size in n\\n        int n = digits.size();\\n        \\n        //taking flag for putting a condition further in code\\n        bool flag = 0;\\n        \\n        //traversing from the last for incrementing with a condition i.e. digit should be < 9.\\n        for(int i = n-1; i>=0; i--){\\n            //checking condition whether digit < 9\\n            if(digits[i]<9){\\n                digits[i] = digits[i] + 1;\\n                flag = 1;\\n                break;\\n            }else{\\n                //if digit is not < 9, then we have to make it 0(coz 9 + 1 = 10(0 in this case, as we are taking ones place))\\n                digits[i] = 0;\\n            }\\n        }\\n        //checking if flag is still 0, if it is 0 then we have to insert 1 at the beginning\\n        if(flag==0){\\n            digits.insert(digits.begin(), 1);\\n        }\\n        return digits;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 721895,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int[] PlusOne(int[] digits) {\\n        int carrier = 1;\\n        \\n        for (int i = digits.Length - 1; i >= 0; i--)\\n        {\\n            int temp = digits[i] + carrier;\\n            \\n            digits[i] = temp % 10;\\n            carrier = temp / 10;\\n        }\\n        \\n        if (carrier == 1)\\n        {\\n            List<int> temp = new List<int>();\\n            \\n            temp.Add(carrier);\\n            \\n            foreach (var n in digits)\\n                temp.Add(n);\\n            \\n            return temp.ToArray();\\n        }\\n        \\n        return digits;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] PlusOne(int[] digits) {\\n        int carrier = 1;\\n        \\n        for (int i = digits.Length - 1; i >= 0; i--)\\n        {\\n            int temp = digits[i] + carrier;\\n            \\n            digits[i] = temp % 10;\\n            carrier = temp / 10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 24150,
                "title": "a-few-lines-of-javascript",
                "content": "```\\nvar plusOne = function(digits) {\\n    for (let i = digits.length - 1; i >= 0; i--) {\\n        digits[i] = (digits[i] + 1) % 10;\\n        if (digits[i]) return digits;\\n    }\\n    digits.unshift(1);\\n    return digits;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar plusOne = function(digits) {\\n    for (let i = digits.length - 1; i >= 0; i--) {\\n        digits[i] = (digits[i] + 1) % 10;\\n        if (digits[i]) return digits;\\n    }\\n    digits.unshift(1);\\n    return digits;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24338,
                "title": "simple-java-solution-no-copying-arrays",
                "content": "Start from the end. If the current number is less than 9, we won't have a carry: increment the digit and return the array. If we have a 9, then set the current to 0 and simply repeat with the next digit.\\n\\nHere's the kicker: if we complete the loop and don't return, this means that the whole array was set to 0! The answer must therefore be an array that's one bigger with the first number being 1. There's no need to copy to the new array since all numbers are by default initialized to 0.\\n\\n    public int[] plusOne(int[] digits) {\\n        if(digits == null || digits.length == 0){\\n            return new int[0];\\n        }\\n        \\n        for(int i = digits.length - 1; i >= 0; i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{\\n                digits[i] = 0;\\n            }\\n        }\\n        \\n        int[] result = new int[digits.length + 1];\\n        result[0] = 1;\\n        \\n        return result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Start from the end. If the current number is less than 9, we won't have a carry: increment the digit and return the array. If we have a 9, then set the current to 0 and simply repeat with the next digit.\\n\\nHere's the kicker: if we complete the loop and don't return, this means that the whole array was set to 0! The answer must therefore be an array that's one bigger with the first number being 1. There's no need to copy to the new array since all numbers are by default initialized to 0.\\n\\n    public int[] plusOne(int[] digits) {\\n        if(digits == null || digits.length == 0){\\n            return new int[0];\\n        }\\n        \\n        for(int i = digits.length - 1; i >= 0; i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{\\n                digits[i] = 0;\\n            }\\n        }\\n        \\n        int[] result = new int[digits.length + 1];\\n        result[0] = 1;\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24386,
                "title": "short-4ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> plusOne(vector<int>& digits) {\\n            for (int k = digits.size() - 1; k >= 0; --k) {\\n                if (digits[k] < 9) { \\n                    digits[k]++; \\n                    return digits; \\n                } else {\\n                    digits[k] = 0;\\n                }\\n            }\\n            digits[0] = 1, digits.push_back(0);\\n            return digits;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> plusOne(vector<int>& digits) {\\n            for (int k = digits.size() - 1; k >= 0; --k) {\\n                if (digits[k] < 9) { \\n                    digits[k]++; \\n                    return digits; \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3138391,
                "title": "straightforward-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe initialize an empty string and fill it with the digits. Then we cast it to an integer and add one. we will then createa a new empty list and go through the characters of the typecasted number (so that its iterable) and append to the empty answer list. Finally, we return the list\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        string = \"\"\\n        for digit in digits:\\n            string += str(digit)\\n        number = int(string) + 1\\n        ans = []\\n        for digit in str(number):\\n            ans.append(int(digit))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        string = \"\"\\n        for digit in digits:\\n            string += str(digit)\\n        number = int(string) + 1\\n        ans = []\\n        for digit in str(number):\\n            ans.append(int(digit))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120632,
                "title": "python-simple-code-beat-100-explained",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def plusOne(self, digits):\\n        # Adjusting an array of digits into an integer\\n        digits_integer = int(\\'\\'.join(map(str,digits)))\\n        digits_integer +=1\\n        # Adjusting back an integer into an array of digits after plus 1\\n        return [int(x) for x in str(digits_integer)]\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def plusOne(self, digits):\\n        # Adjusting an array of digits into an integer\\n        digits_integer = int(\\'\\'.join(map(str,digits)))\\n        digits_integer +=1\\n        # Adjusting back an integer into an array of digits after plus 1\\n        return [int(x) for x in str(digits_integer)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065579,
                "title": "easiest-solution-c-with-0ms-beats-100-of-solutions",
                "content": "# Intuition\\nI mean intially I just thought of it being like any other number, just increasing the right will increase the left if it carries over.\\nThat\\'s about it.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        for(int i {(int)digits.size()-1}; i >= 0; i--){\\n            if(digits.at(i)!=9){\\n                digits.at(i)++;\\n                break;\\n            }else{digits.at(i)=0;}\\n        }\\n        if(digits.at(0)==0){digits.insert(digits.begin(),1);}\\n        return digits;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        for(int i {(int)digits.size()-1}; i >= 0; i--){\\n            if(digits.at(i)!=9){\\n                digits.at(i)++;\\n                break;\\n            }else{digits.at(i)=0;}\\n        }\\n        if(digits.at(0)==0){digits.insert(digits.begin(),1);}\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683252,
                "title": "1-line-python",
                "content": "```\\nreturn [int(x) for x in str(int(\"\".join([str(x) for x in digits]))+1)]",
                "solutionTags": [],
                "code": "```\\nreturn [int(x) for x in str(int(\"\".join([str(x) for x in digits]))+1)]",
                "codeTag": "Unknown"
            },
            {
                "id": 2490947,
                "title": "python-easy-solution",
                "content": "```\\ndef plusOne(self, digits: List[int]) -> List[int]: # digits = [4,3,2,1]\\n        st_digits_list = [str(dig) for dig in digits] # [\\'4\\', \\'3\\', \\'2\\', \\'1\\']\\n        st_digits = \"\".join(st_digits_list) # \"4321\"\\n        num = int(st_digits) + 1 # 4322\\n        output= [int(n) for n in str(num)] # [4, 3, 2, 2]\\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef plusOne(self, digits: List[int]) -> List[int]: # digits = [4,3,2,1]\\n        st_digits_list = [str(dig) for dig in digits] # [\\'4\\', \\'3\\', \\'2\\', \\'1\\']\\n        st_digits = \"\".join(st_digits_list) # \"4321\"\\n        num = int(st_digits) + 1 # 4322\\n        output= [int(n) for n in str(num)] # [4, 3, 2, 2]\\n        return output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2432426,
                "title": "java-script-using-only-for-loop-and-if-else-65-ms",
                "content": "//unshit is used to push 1 at front  of array//\\n//if you like it pls upvote//\\nvar plusOne = function(digits) {\\n   for(i=digits.length-1;i>=0;i--){\\n    if(digits[i]!==9){\\n        digits[i]=digits[i]+1;\\n      break;\\n  }\\n   else{\\ndigits[i]=0;\\nif(digits[0]==0){\\n    digits.unshift(1);\\n}\\n   }\\n}return digits;\\n};\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "//unshit is used to push 1 at front  of array//\\n//if you like it pls upvote//\\nvar plusOne = function(digits) {\\n   for(i=digits.length-1;i>=0;i--){\\n    if(digits[i]!==9){\\n        digits[i]=digits[i]+1;\\n      break;\\n  }\\n   else{\\ndigits[i]=0;\\nif(digits[0]==0){\\n    digits.unshift(1);\\n}\\n   }\\n}return digits;\\n};\\n\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2370411,
                "title": "0-ms-java-solution",
                "content": "```\\nclass Solution {\\n   public int[] plusOne(int[] digits) {\\n        \\n    int n = digits.length;\\n    for(int i=n-1; i>=0; i--) {\\n        if(digits[i] < 9) {\\n            digits[i]++;\\n            return digits;\\n        }\\n        \\n        digits[i] = 0;\\n    }\\n    \\n    int[] newNo = new int [n+1];\\n    newNo[0] = 1;\\n    \\n    return newNo;\\n   }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public int[] plusOne(int[] digits) {\\n        \\n    int n = digits.length;\\n    for(int i=n-1; i>=0; i--) {\\n        if(digits[i] < 9) {\\n            digits[i]++;\\n            return digits;\\n        }\\n        \\n        digits[i] = 0;\\n    }\\n    \\n    int[] newNo = new int [n+1];\\n    newNo[0] = 1;\\n    \\n    return newNo;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121244,
                "title": "python-concise-solution-with-divmod",
                "content": "```\\ndef plusOne(self, digits: List[int]) -> List[int]:\\n        \\n        carry = 1\\n        \\n        for i in range(len(digits) - 1,-1,-1):\\n            carry, digits[i] = divmod(digits[i] + carry, 10)\\n        \\n        return [carry] + digits if carry else digits\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef plusOne(self, digits: List[int]) -> List[int]:\\n        \\n        carry = 1\\n        \\n        for i in range(len(digits) - 1,-1,-1):\\n            carry, digits[i] = divmod(digits[i] + carry, 10)\\n        \\n        return [carry] + digits if carry else digits\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1463033,
                "title": "python-simple",
                "content": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n\\n        pointer = len(digits) - 1\\n        \\n        while digits[pointer] == 9:\\n            digits[pointer] = 0\\n            pointer -= 1\\n        \\n        if pointer == -1:\\n            digits.insert(0, 1)\\n        \\n        else:\\n            digits[pointer] += 1\\n        \\n        return digits\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n\\n        pointer = len(digits) - 1\\n        \\n        while digits[pointer] == 9:\\n            digits[pointer] = 0\\n            pointer -= 1\\n        \\n        if pointer == -1:\\n            digits.insert(0, 1)\\n        \\n        else:\\n            digits[pointer] += 1\\n        \\n        return digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808473,
                "title": "javascript",
                "content": "```\\nvar plusOne = function(digits) {\\n    for (let i = digits.length - 1; i != -1; i--) {\\n        if (digits[i] != 9) {\\n            digits[i] += 1\\n            return digits\\n        }\\n        digits[i] = 0\\n    }\\n    digits.unshift(1) //Getting here means everything was a 9, so it\\'s now all 0\\'s, meaning we should add a 1 in front.\\n    return digits\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar plusOne = function(digits) {\\n    for (let i = digits.length - 1; i != -1; i--) {\\n        if (digits[i] != 9) {\\n            digits[i] += 1\\n            return digits\\n        }\\n        digits[i] = 0\\n    }\\n    digits.unshift(1) //Getting here means everything was a 9, so it\\'s now all 0\\'s, meaning we should add a 1 in front.\\n    return digits\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24207,
                "title": "c-look-for-first-non-9-from-the-tail-backwards",
                "content": "    public int[] PlusOne(int[] digits) \\n    {\\n        int index = digits.Length - 1;\\n        while (index >= 0 && digits[index] == 9)\\n        {\\n            index--;\\n        }\\n        \\n        if (index < 0)\\n        {\\n            int[] res = new int[digits.Length + 1];\\n            res[0] = 1;\\n            return res;\\n        }\\n        else\\n        {\\n            digits[index++]++;\\n            while (index < digits.Length)\\n            {\\n                digits[index++] = 0;\\n            }\\n            return digits;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public int[] PlusOne(int[] digits) \\n    {\\n        int index = digits.Length - 1;\\n        while (index >= 0 && digits[index] == 9)\\n        {\\n            index--;\\n        }\\n        \\n        if (index < 0)\\n        {\\n            int[] res = new int[digits.Length + 1];\\n            res[0] = 1;\\n            return res;\\n        }\\n        else\\n        {\\n            digits[index++]++;\\n            while (index < digits.Length)\\n            {\\n                digits[index++] = 0;\\n            }\\n            return digits;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24109,
                "title": "my-c-code-accepted-with-2-ms",
                "content": "    int* plusOne(int* digits, int digitsSize, int* returnSize) {\\n        if (digits == NULL)\\n        {\\n            return NULL;\\n        }\\n        int n = digitsSize-1;\\n        while(n >= 0)\\n        {\\n            if(digits[n] < 9)\\n            {\\n                digits[n]++;\\n                *returnSize = digitsSize;\\n                return digits;\\n            }else\\n            {\\n                digits[n] = 0;\\n                n--;\\n            }\\n        }\\n        \\n        int* newdigit = (int*)malloc((digitsSize+1) * sizeof(int));\\n        newdigit[0] = 1;\\n        for(int i = 1; i < (digitsSize+1); i++)\\n        {\\n            newdigit[i] = digits[i-1];\\n        }\\n        *returnSize = digitsSize+1;\\n        return newdigit;\\n    }",
                "solutionTags": [],
                "code": "    int* plusOne(int* digits, int digitsSize, int* returnSize) {\\n        if (digits == NULL)\\n        {\\n            return NULL;\\n        }\\n        int n = digitsSize-1;\\n        while(n >= 0)\\n        {\\n            if(digits[n] < 9)\\n            {\\n                digits[n]++;\\n                *returnSize = digitsSize;\\n                return digits;\\n            }else\\n            {\\n                digits[n] = 0;\\n                n--;\\n            }\\n        }\\n        \\n        int* newdigit = (int*)malloc((digitsSize+1) * sizeof(int));\\n        newdigit[0] = 1;\\n        for(int i = 1; i < (digitsSize+1); i++)\\n        {\\n            newdigit[i] = digits[i-1];\\n        }\\n        *returnSize = digitsSize+1;\\n        return newdigit;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24458,
                "title": "my-accepted-java-solution",
                "content": "Hi everyone, this is my accepted Java solution. I used a while loop here so that I don't need to go through the entire array if it's not necessary. Basically, the code will start from the last index of the array and go backwards. if there is a carry-over value, then it will keep going, otherwise it will stop. After the traversing is done, it will check if the first digit is zero (9999 + 1 = 0000) and handle that case. Hope this helps :)\\n\\n    public int[] plusOne(int[] digits) {\\n        boolean carry = true;\\n        int index = digits.length - 1;\\n        while (carry && index > -1) {\\n            if (digits[index] == 9) {\\n                digits[index] = 0; // carry remains true\\n            } else {\\n                digits[index] += 1;\\n                carry = false;\\n            }\\n            index--;\\n        }\\n        if (digits[0] == 0) {\\n            int[] result = new int[digits.length + 1];\\n            result[0] = 1;\\n            for (int i = 1; i < digits.length; i++) {\\n                result[i] = digits[i - 1];\\n            }\\n            return result;\\n        }\\n        return digits;\\n    }",
                "solutionTags": [],
                "code": "Hi everyone, this is my accepted Java solution. I used a while loop here so that I don't need to go through the entire array if it's not necessary. Basically, the code will start from the last index of the array and go backwards. if there is a carry-over value, then it will keep going, otherwise it will stop. After the traversing is done, it will check if the first digit is zero (9999 + 1 = 0000) and handle that case. Hope this helps :)\\n\\n    public int[] plusOne(int[] digits) {\\n        boolean carry = true;\\n        int index = digits.length - 1;\\n        while (carry && index > -1) {\\n            if (digits[index] == 9) {\\n                digits[index] = 0; // carry remains true\\n            } else {\\n                digits[index] += 1;\\n                carry = false;\\n            }\\n            index--;\\n        }\\n        if (digits[0] == 0) {\\n            int[] result = new int[digits.length + 1];\\n            result[0] = 1;\\n            for (int i = 1; i < digits.length; i++) {\\n                result[i] = digits[i - 1];\\n            }\\n            return result;\\n        }\\n        return digits;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3795230,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitially wanted to make a function variable to keep track of wether we needed to carry and was attempting to handle the edge case for if we needed to increase the size of the array in an over complicated way.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLooping through the array starting at the last element, if a digit is a 9 we make it a zero and repeat. When we\\'re able to add 1 without going over 9 we should break there, because there is no more work left to do. If we dont\\'t find a number that isn\\'t 9 (meaning we never reach the else condition in the loop), we should then create a new array with 1 as the first element followed by the array digits that got turned to all 0\\'s.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) \\n\\n# Code\\n```\\n/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nvar plusOne = function(digits) {\\n\\n    for(let i = digits.length - 1; i >= 0; i--) {\\n        if(digits[i] === 9) {\\n            digits[i] = 0\\n        }\\n        else {\\n            digits[i] += 1\\n            return digits\\n        }\\n    }\\n\\n    return [1, ...digits]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nvar plusOne = function(digits) {\\n\\n    for(let i = digits.length - 1; i >= 0; i--) {\\n        if(digits[i] === 9) {\\n            digits[i] = 0\\n        }\\n        else {\\n            digits[i] += 1\\n            return digits\\n        }\\n    }\\n\\n    return [1, ...digits]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3394130,
                "title": "clear-c-solution-let-s-find-best-solution-together",
                "content": "**`If you have any thought feel free leave a comment below`**\\n\\n# Code\\n```\\n/** Note: The returned array must be malloced, assume     */\\n/** caller calls free().                                  */\\nint *plusOne(int *digits, int digitsSize, int *returnSize) {\\n    *returnSize = digitsSize;\\n    int *plusOne = malloc(digitsSize * sizeof(int));\\n    if (plusOne == NULL)\\n        return (NULL);\\n    for (int i = 0; i < digitsSize; i++)\\n        plusOne[i] = digits[i];\\n    \\n    plusOne[digitsSize - 1]++;\\n    for (int i = digitsSize - 1; i - 1 >= 0; i--)\\n        if (plusOne[i] == 10) {\\n            plusOne[i] = 0;\\n            plusOne[i - 1]++;\\n        }\\n\\n    if (plusOne[0] == 10) {\\n        (*returnSize)++;\\n        plusOne = realloc(plusOne, *returnSize * sizeof(int));\\n        if (plusOne == NULL)\\n            return (NULL);\\n        memmove(plusOne + 1, plusOne, digitsSize * sizeof(int));\\n        plusOne[0] = 1;\\n        plusOne[1] = 0;\\n    }\\n    return (plusOne);\\n}\\n\\n```\\n1) In the first part we just take memory for return array, and copy source array there\\n2) In the second part we add one to the last element. Go through elements of array from the end and on 10, we split it\\n3) In the last part we work with first element equal to 10. If it is so, we need to realloc memory and move an array by one element\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/** Note: The returned array must be malloced, assume     */\\n/** caller calls free().                                  */\\nint *plusOne(int *digits, int digitsSize, int *returnSize) {\\n    *returnSize = digitsSize;\\n    int *plusOne = malloc(digitsSize * sizeof(int));\\n    if (plusOne == NULL)\\n        return (NULL);\\n    for (int i = 0; i < digitsSize; i++)\\n        plusOne[i] = digits[i];\\n    \\n    plusOne[digitsSize - 1]++;\\n    for (int i = digitsSize - 1; i - 1 >= 0; i--)\\n        if (plusOne[i] == 10) {\\n            plusOne[i] = 0;\\n            plusOne[i - 1]++;\\n        }\\n\\n    if (plusOne[0] == 10) {\\n        (*returnSize)++;\\n        plusOne = realloc(plusOne, *returnSize * sizeof(int));\\n        if (plusOne == NULL)\\n            return (NULL);\\n        memmove(plusOne + 1, plusOne, digitsSize * sizeof(int));\\n        plusOne[0] = 1;\\n        plusOne[1] = 0;\\n    }\\n    return (plusOne);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2715491,
                "title": "javascript-solution",
                "content": "var plusOne = function (digits) {\\n    let arrToNumber =BigInt(digits.join(\\'\\'))\\n    let res = BigInt(arrToNumber + BigInt(1))\\n    let myFunc = res => Number(res);\\n\\n    var intArr = Array.from(String(res), myFunc);\\n    return intArr\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var plusOne = function (digits) {\\n    let arrToNumber =BigInt(digits.join(\\'\\'))\\n    let res = BigInt(arrToNumber + BigInt(1))\\n    let myFunc = res => Number(res);\\n\\n    var intArr = Array.from(String(res), myFunc);\\n    return intArr\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2526659,
                "title": "0-ms-java-solution-faster-than-100-simple-solution-within-20-lines",
                "content": "vote up if you like my solution or if it helps you !\\n\\n\\n```\\n    public static int[] plusOne (int[] digits) {\\n        int l = digits.length;\\n        if ( digits[l - 1] != 9 ) {\\n            digits[l - 1]++;\\n            return digits;\\n        } else {\\n            int[] temp = new int[l + 1];\\n            for ( int i = l - 1; i >= 0; i-- )\\n                if ( digits[i] == 9 ) {\\n                    digits[i] = i == 0 ? 1 : 0;\\n                    temp[i] = digits[i];\\n                } else {\\n                    digits[i]++;\\n                    return digits;\\n                }\\n            return temp;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public static int[] plusOne (int[] digits) {\\n        int l = digits.length;\\n        if ( digits[l - 1] != 9 ) {\\n            digits[l - 1]++;\\n            return digits;\\n        } else {\\n            int[] temp = new int[l + 1];\\n            for ( int i = l - 1; i >= 0; i-- )\\n                if ( digits[i] == 9 ) {\\n                    digits[i] = i == 0 ? 1 : 0;\\n                    temp[i] = digits[i];\\n                } else {\\n                    digits[i]++;\\n                    return digits;\\n                }\\n            return temp;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2474823,
                "title": "0ms-hacky-c-solution-tc-o-n-sc-o-1",
                "content": "![image](https://assets.leetcode.com/users/images/a35c611d-a1fa-4ec5-b0ce-135364134343_1661608674.9935284.png)\\n\\nDon\\'t feel confused by looking at the solution complexity. Take a book and go through it once. Then you will get to know how **easy** it really is.\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size()-1;\\n        if(digits[n]!=9){                                  //If last element is not 9, simply add 1 to it and return\\n            digits[n]++;\\n        }\\n        else{\\n            digits[n]=0;                                   //If you reach here, it means the element is 9. Then make it 0 and follow ahead.\\n            for(int i=n-1; i>=0; i--){                     //Now check the previous element (if exists)\\n                if(digits[i]==9 && i-1>=0){                //If (previous) element is 9 and there is still an element previous to it, then make it 0 and follow ahead.\\n                    digits[i]=0;\\n                }\\n                else if(digits[i]!=9){                     //If (previous) element is not 9, add 1 to it and return the vector.\\n                    digits[i]+=1;\\n                    return digits;\\n                }\\n            }\\n            digits[0]=0;                                   //If you reach here, that means all elements in the vector are 9. (Think about it a little bit!). We made the rest of the elements 0. Now make the first element 0 and insert 1 at the beginning.\\n            digits.insert(digits.begin(), 1);\\n        }\\n        return digits;                                     //Return the final vector!!\\n    }\\n};\\n```\\nPS: If you made it through the process, congrats, you just added a drop to your ocean of knowledge :)\\n**Plz Upvote if you find the solution helpful :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size()-1;\\n        if(digits[n]!=9){                                  //If last element is not 9, simply add 1 to it and return\\n            digits[n]++;\\n        }\\n        else{\\n            digits[n]=0;                                   //If you reach here, it means the element is 9. Then make it 0 and follow ahead.\\n            for(int i=n-1; i>=0; i--){                     //Now check the previous element (if exists)\\n                if(digits[i]==9 && i-1>=0){                //If (previous) element is 9 and there is still an element previous to it, then make it 0 and follow ahead.\\n                    digits[i]=0;\\n                }\\n                else if(digits[i]!=9){                     //If (previous) element is not 9, add 1 to it and return the vector.\\n                    digits[i]+=1;\\n                    return digits;\\n                }\\n            }\\n            digits[0]=0;                                   //If you reach here, that means all elements in the vector are 9. (Think about it a little bit!). We made the rest of the elements 0. Now make the first element 0 and insert 1 at the beginning.\\n            digits.insert(digits.begin(), 1);\\n        }\\n        return digits;                                     //Return the final vector!!\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257688,
                "title": "very-easy-c-solution-100-fully-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> plusOne(vector<int>& digits) {\\n        //To solve this, we take digits one by one from end to start..\\n        for (int i = digits.size() - 1; i >= 0; i--) {\\n            \\n            // If a digit is not equal to 9, we plus one directly and then quit the loop...\\n            if (digits[i] != 9) {\\n                digits[i]++;\\n                break;\\n                \\n            //if the digit is 9, we set it to 0, and continue the loop until\\n            //we encounter the number don\\'t equals to 9...\\n            } else {\\n                digits[i] = 0;\\n            }\\n        }\\n        if (digits[0] == 0) {      //it means, we need a bigger array to represent the number.\\n            vector<int>res(digits.size()+1,0);    //so we create a new array res...\\n            res[0] = 1;                                //and set res[0] to 1...\\n            return res;\\n        }\\n        return digits;      //return the digits...\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> plusOne(vector<int>& digits) {\\n        //To solve this, we take digits one by one from end to start..\\n        for (int i = digits.size() - 1; i >= 0; i--) {\\n            \\n            // If a digit is not equal to 9, we plus one directly and then quit the loop...\\n            if (digits[i] != 9) {\\n                digits[i]++;\\n                break;\\n                \\n            //if the digit is 9, we set it to 0, and continue the loop until\\n            //we encounter the number don\\'t equals to 9...\\n            } else {\\n                digits[i] = 0;\\n            }\\n        }\\n        if (digits[0] == 0) {      //it means, we need a bigger array to represent the number.\\n            vector<int>res(digits.size()+1,0);    //so we create a new array res...\\n            res[0] = 1;                                //and set res[0] to 1...\\n            return res;\\n        }\\n        return digits;      //return the digits...\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044309,
                "title": "java-simplest-soln-shortest-soln-with-explanation",
                "content": "***If you like the code, Kindly Upvote***\\n\\n```\\nclass Solution {\\npublic int[] plusOne(int[] digits) {\\n    \\n    int carry = 1;\\n    \\n    for (int i = digits.length-1; i>= 0; i--) {\\n        digits[i] += carry;\\n        if (digits[i] != 10) // early return \\n            return digits;\\n        digits[i] = 0;\\n    }\\n    \\n\\t//if upper return statement didn\\'t run, it means [9],[9,9] type of test case is present.\\n\\t\\n    int[] ans = new int[digits.length+1]; \\n    ans[0] = 1; //As other elements will be 0, therefore only updating the 0th element\\n    return ans;\\n    \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic int[] plusOne(int[] digits) {\\n    \\n    int carry = 1;\\n    \\n    for (int i = digits.length-1; i>= 0; i--) {\\n        digits[i] += carry;\\n        if (digits[i] != 10) // early return \\n            return digits;\\n        digits[i] = 0;\\n    }\\n    \\n\\t//if upper return statement didn\\'t run, it means [9],[9,9] type of test case is present.\\n\\t\\n    int[] ans = new int[digits.length+1]; \\n    ans[0] = 1; //As other elements will be 0, therefore only updating the 0th element\\n    return ans;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839674,
                "title": "very-easy-python-solution-faster-than-97-48",
                "content": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        for i, num in [*enumerate(digits)][::-1]:\\n            if num != 9:\\n                digits[i] += 1\\n                break\\n            digits[i] = 0\\n\\n        return [1] + digits if not digits[0] else digits\\n```\\n\\n\"Exploiting\" enumarte to iterate from end to start, and making one less check before returning a value.\\nIf the first number is ```0``` -> concatenate ```[1]``` to start of the list.\\nIf not -> just return digits.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        for i, num in [*enumerate(digits)][::-1]:\\n            if num != 9:\\n                digits[i] += 1\\n                break\\n            digits[i] = 0\\n\\n        return [1] + digits if not digits[0] else digits\\n```\n```0```\n```[1]```",
                "codeTag": "Java"
            },
            {
                "id": 1726820,
                "title": "simple-java-solution-with-explanation",
                "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\n        int n = digits.length; \\n        \\n        for(int i=n-1; i>=0; i--){\\n            if(digits[i] < 9){\\n                digits[i]++;    // if a digit is less than 9, just add 1 and return the new digit array\\n                return digits;\\n            }else{\\n                digits[i] = 0; // if digit is 9, make it zero and in the next iteration the next value will get increment\\n            }           \\n        }\\n        \\n        // if we are here means, every digit in array was 9. So create a new array with +1 size and make first digit Zero.\\n        // exp:  99 => create new array of size 3 => make its first digit 1 => return new array => 100;\\n        \\n        int[] newDigit = new int[n+1];\\n        newDigit[0] = 1;\\n        \\n        return newDigit;\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\n        int n = digits.length; \\n        \\n        for(int i=n-1; i>=0; i--){\\n            if(digits[i] < 9){\\n                digits[i]++;    // if a digit is less than 9, just add 1 and return the new digit array\\n                return digits;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1667209,
                "title": "js",
                "content": "```\\nvar plusOne = function(digits) {\\n    for (let i = digits.length -1; i >= 0; i--) {\\n        const curDigit = digits[i];\\n        if (curDigit < 9) {\\n            digits[i] = digits[i] + 1;\\n            return digits;\\n        }\\n        digits[i] = 0;\\n    }\\n    return [1, ...digits];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar plusOne = function(digits) {\\n    for (let i = digits.length -1; i >= 0; i--) {\\n        const curDigit = digits[i];\\n        if (curDigit < 9) {\\n            digits[i] = digits[i] + 1;\\n            return digits;\\n        }\\n        digits[i] = 0;\\n    }\\n    return [1, ...digits];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1428535,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size(),carry=1;\\n        for(int i=n-1;i>=0;--i){\\n            int x = digits[i]+carry;\\n            digits[i]=x%10;\\n            carry = x/10;\\n            if(carry==0) break;\\n        }\\n        if(carry>0) digits.insert(digits.begin()+0,carry);\\n        return digits;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size(),carry=1;\\n        for(int i=n-1;i>=0;--i){\\n            int x = digits[i]+carry;\\n            digits[i]=x%10;\\n            carry = x/10;\\n            if(carry==0) break;\\n        }\\n        if(carry>0) digits.insert(digits.begin()+0,carry);\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1379354,
                "title": "c-0ms-100-faster-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        \\n        \\n        //\\n        int n  = digits.size() ;\\n\\n        while(1)\\n        {  // if the digit is not nine then simply add it\\n            if(digits[n-1]!= 9)\\n            {\\n                digits[n-1]++;\\n                return digits;\\n            }\\n\\t\\t\\t// if 9 then 9+1 is 10 we need the 0 only \\n            else \\n            {\\n                digits[n-1] = 0 ;\\n                --n;\\n            }\\n           // if all nine then first digit will be zero add one in the begining\\n            if(digits[0] == 0)\\n            {\\n                digits.insert(digits.begin(),1);\\n                return digits;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        \\n        \\n        //\\n        int n  = digits.size() ;\\n\\n        while(1)\\n        {  // if the digit is not nine then simply add it\\n            if(digits[n-1]!= 9)\\n            {\\n                digits[n-1]++;\\n                return digits;\\n            }\\n\\t\\t\\t// if 9 then 9+1 is 10 we need the 0 only \\n            else \\n            {\\n                digits[n-1] = 0 ;\\n                --n;\\n            }\\n           // if all nine then first digit will be zero add one in the begining\\n            if(digits[0] == 0)\\n            {\\n                digits.insert(digits.begin(),1);\\n                return digits;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123616,
                "title": "rust-iterator-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Plus One.\\nMemory Usage: 1.9 MB, less than 95.31% of Rust online submissions for Plus One.\\n```\\nimpl Solution {\\n    pub fn plus_one(digits: Vec<i32>) -> Vec<i32> {\\n        let mut digits = digits;\\n        for v in digits.iter_mut().rev() {\\n            let sum = *v + 1;\\n            *v = sum % 10;\\n            if sum < 10 {\\n                return digits;\\n            }\\n        }\\n        [&vec![1], &digits[..]].concat()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn plus_one(digits: Vec<i32>) -> Vec<i32> {\\n        let mut digits = digits;\\n        for v in digits.iter_mut().rev() {\\n            let sum = *v + 1;\\n            *v = sum % 10;\\n            if sum < 10 {\\n                return digits;\\n            }\\n        }\\n        [&vec![1], &digits[..]].concat()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 722172,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        for i in reversed(range(len(digits))):\\n            if digits[i] < 9:\\n                digits[i] += 1\\n                return digits\\n            else:\\n                digits[i] = 0\\n        return [1]+digits\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        for i in reversed(range(len(digits))):\\n            if digits[i] < 9:\\n                digits[i] += 1\\n                return digits\\n            else:\\n                digits[i] = 0\\n        return [1]+digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142730,
                "title": "simple-javascript-solution-es6",
                "content": "```\\nconst plusOne = digits => {\\n    for (let i = digits.length - 1; i >= 0; i--) {\\n        if (digits[i] < 9) {\\n            digits[i]++\\n            return digits\\n        }\\n        digits[i] = 0\\n    }\\n    return [1, ...digits]\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst plusOne = digits => {\\n    for (let i = digits.length - 1; i >= 0; i--) {\\n        if (digits[i] < 9) {\\n            digits[i]++\\n            return digits\\n        }\\n        digits[i] = 0\\n    }\\n    return [1, ...digits]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24296,
                "title": "python-one-line-answer",
                "content": "    return list(map(int, str(int(''.join(map(str, digits)))+1)))",
                "solutionTags": [
                    "Python"
                ],
                "code": "    return list(map(int, str(int(''.join(map(str, digits)))+1)))",
                "codeTag": "Unknown"
            },
            {
                "id": 24363,
                "title": "javascript-solution-sharing",
                "content": "    /**\\n     * note: [9] plus one [1, 0] // digits[0]=10\\n     */\\n    var plusOne = function(digits) {\\n        var carry = 1;\\n        for(var i=digits.length-1; i>=0; i--){\\n            digits[i] = digits[i] + carry;\\n            digits[i] = (digits[i]>=10)?(carry=1, digits[i]-10):(carry=0, digits[i]);\\n        }\\n        if(carry){ digits.unshift(1); } // note\\n        return digits;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    /**\\n     * note: [9] plus one [1, 0] // digits[0]=10\\n     */\\n    var plusOne = function(digits) {\\n        var carry = 1;\\n        for(var i=digits.length-1; i>=0; i--){\\n            digits[i] = digits[i] + carry;\\n            digits[i] = (digits[i]>=10)?(carry=1, digits[i]-10):(carry=0, digits[i]);\\n        }\\n        if(carry){ digits.unshift(1); } // note\\n        return digits;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 24432,
                "title": "my-accepted-java-solution",
                "content": "Just plus one to the last element in the digits , and judge every element then return \\n\\n\\n    public class Solution {\\n        public int[] plusOne(int[] digits) {\\n            digits[digits.length-1]+=1;\\n            for(int i=digits.length-1;i>0;i--)\\n            {\\n                if(digits[i]==10)\\n                {\\n                    digits[i]=0;\\n                    digits[i-1]+=1;\\n                }\\n            }\\n            if(digits[0]==10)\\n            {\\n                int[] res=new int[digits.length+1];\\n                digits[0]=0;\\n                res[0]=1;\\n                for(int i=1;i<res.length;i++)\\n                {\\n                    res[i]=digits[i-1];\\n                }\\n                return res;\\n            }\\n            return digits;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int[] plusOne(int[] digits) {\\n            digits[digits.length-1]+=1;\\n            for(int i=digits.length-1;i>0;i--)\\n            {\\n                if(digits[i]==10)\\n                {\\n                    digits[i]=0;\\n                    digits[i-1]+=1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3792748,
                "title": "beats-100-explanation-optimized-c-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- This concept is great, and we can imagine it well enough.\\n- We always add the number to another at the end, Ex: 1002 + 2 = 100***4*** \\n- If we get any carry we pass it to the next number from right to left.\\n- Similarly it\\'s an easy version of that.\\n##### Let\\'s dive deep into it:\\n- We have to just add 1 to the number whose digit are represented in array format.\\n###### - There can be only two cases:\\n1. The number = 9 (need to pass one as carry, and number will be equals to zero)\\n2. If number !=9 , number++;\\n\\n###### - The Special Case:\\n1. Let\\'s say the number is in form of 999, after adding 1, number= 1000 (**Need to increase the size of vector**: (v.push_back(0))\\n2. If not then come out of loop.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Iterate over the vector: \\n 1. if i==n-1, v[i]++\\n 2. then check if v[i]==10\\n  - v[i]=0\\n  - if(i!=0) v[i-1]++\\n  - else push_back 0, and v[i]=1; \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& v) {\\n        int n = v.size();\\n        for(int i=n-1; i>=0; i--){\\n            if(i==n-1){\\n                v[i]++;\\n            }\\n            if(v[i]==10){\\n                v[i] = 0;\\n                if(i!=0){\\n                    v[i-1]++;\\n                }else{\\n                    v.push_back(0);\\n                    v[i] = 1;\\n                }\\n\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n##### We can more optimize it but it would have no effect on time complexity \\n# More optimized:\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& v) {\\n        int n = v.size();\\n        for(int i=n-1; i>=0; i--){\\n            if(i==n-1){\\n                v[i]++;\\n            }\\n            if(v[i]==10){\\n                v[i] = 0;\\n                if(i!=0){\\n                    v[i-1]++;\\n                }else{\\n                    v.push_back(0);\\n                    v[i] = 1;\\n                }\\n            }else{\\n                break;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& v) {\\n        int n = v.size();\\n        for(int i=n-1; i>=0; i--){\\n            if(i==n-1){\\n                v[i]++;\\n            }\\n            if(v[i]==10){\\n                v[i] = 0;\\n                if(i!=0){\\n                    v[i-1]++;\\n                }else{\\n                    v.push_back(0);\\n                    v[i] = 1;\\n                }\\n\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& v) {\\n        int n = v.size();\\n        for(int i=n-1; i>=0; i--){\\n            if(i==n-1){\\n                v[i]++;\\n            }\\n            if(v[i]==10){\\n                v[i] = 0;\\n                if(i!=0){\\n                    v[i-1]++;\\n                }else{\\n                    v.push_back(0);\\n                    v[i] = 1;\\n                }\\n            }else{\\n                break;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510251,
                "title": "c-quick-addition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your timecomplexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        short int i = digits.size() - 1;\\n        if (i >= 0) {\\n            while (i != -1) {\\n                digits[i] += 1;\\n                if (i == 0 && digits[i] == 10) {\\n                    digits[i] = 0;\\n                    digits.insert(digits.begin(), 1);\\n                }\\n                else if (digits[i] == 10) digits[i] = 0;\\n                else break;\\n                i--;\\n            }\\n        }\\n        return digits;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        short int i = digits.size() - 1;\\n        if (i >= 0) {\\n            while (i != -1) {\\n                digits[i] += 1;\\n                if (i == 0 && digits[i] == 10) {\\n                    digits[i] = 0;\\n                    digits.insert(digits.begin(), 1);\\n                }\\n                else if (digits[i] == 10) digits[i] = 0;\\n                else break;\\n                i--;\\n            }\\n        }\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473937,
                "title": "easy-to-understand-explained-part-by-part-without-reverse",
                "content": "\\n# Approach\\nwe have to add 1 at the last element ;\\nso we took a for loop which starts from the end;\\n\\nif the last digit is not 9 then we can easily add 1 with it .But for 9 we will get extra 1 carry. 9+0=10;\\nwe will handle that letter.\\n\\nfirst off all if our element is lesser then 9 .we will simply add 1 and break the loop and return .\\n \\n      if(digits[i]!=9){\\n                digits[i]=digits[i]+1;\\n                break;\\n            }\\nif the digit is 9 then the sum will 10 .we have to put 0 and 1 carry will be added with prvious number .\\nexample : [1,2,9] -> [1,3,0]\\n \\n    else { digits[i]=0;}\\nif all the array becomes 0 .for example [9,9,9]+1 the result should be [1,0,0,0]\\nso we inserted \\'1\\' at the begining of the array\\n    \\n    if(digits[0]==0){\\n            digits.insert(digits.begin(),1);\\n        }\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        \\n        for(int i=digits.size()-1;i>=0;i--){\\n            if(digits[i]!=9){\\n                digits[i]=digits[i]+1;\\n                break;\\n            }\\n            else { digits[i]=0;}\\n        }\\n        if(digits[0]==0){\\n            digits.insert(digits.begin(),1);\\n        }\\n        return digits;\\n    }\\n};\\n```\\n# please Upvote :(",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        \\n        for(int i=digits.size()-1;i>=0;i--){\\n            if(digits[i]!=9){\\n                digits[i]=digits[i]+1;\\n                break;\\n            }\\n            else { digits[i]=0;}\\n        }\\n        if(digits[0]==0){\\n            digits.insert(digits.begin(),1);\\n        }\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176624,
                "title": "java-best-solution-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int p=digits.length;\\n        for(int i=p-1;i>=0;i--){\\n            if(digits[i]<9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            else{\\n                digits[i]=0;\\n            }\\n        }\\n\\n        int arr[]=new int[p+1];\\n        arr[0]=1;\\n        \\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int p=digits.length;\\n        for(int i=p-1;i>=0;i--){\\n            if(digits[i]<9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            else{\\n                digits[i]=0;\\n            }\\n        }\\n\\n        int arr[]=new int[p+1];\\n        arr[0]=1;\\n        \\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994509,
                "title": "recursive-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSaw a lot of iterative solutions, so I tried to think of a recursive one. As can be quickly deduce, the difficulty of this problem is dealing with the \"9\" digits, not just the ones in the last digit but all of them. In order to simplify the work, we recursively solve for this specific case, so that it does not matter how many \"9\"s we have.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOur two base cases are when the **only** digit is \"9\" and when it is not \"9\". Otherwise, we recursively call this function for the rest of the digits, while accounting for our last digit.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        last = digits[-1]\\n        if last == 9:\\n            if len(digits) == 1:\\n                return [1,0]\\n            return self.plusOne(digits[:-1]) + [0]\\n        digits[-1] += 1\\n        return digits\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        last = digits[-1]\\n        if last == 9:\\n            if len(digits) == 1:\\n                return [1,0]\\n            return self.plusOne(digits[:-1]) + [0]\\n        digits[-1] += 1\\n        return digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765133,
                "title": "c-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n      int n = digits.size() - 1;\\n      \\n      for (int i = n; i >= 0; --i) { \\n        if (digits[i] == 9) {  \\n          digits[i] = 0;\\n        } else {  // current digit is not 9 so we can safely increment by one\\n          digits[i] += 1;\\n          return digits;\\n        }\\n      }\\n\\n      digits.push_back(0);\\n      digits[0] = 1;\\n      return digits;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n      int n = digits.size() - 1;\\n      \\n      for (int i = n; i >= 0; --i) { \\n        if (digits[i] == 9) {  \\n          digits[i] = 0;\\n        } else {  // current digit is not 9 so we can safely increment by one\\n          digits[i] += 1;\\n          return digits;\\n        }\\n      }\\n\\n      digits.push_back(0);\\n      digits[0] = 1;\\n      return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760321,
                "title": "golang-0ms-portugues-br-video",
                "content": "https://www.youtube.com/watch?v=Wx_dAxDFEZ4&ab_channel=Codando\\n\\n```\\nfunc plusOne(digits []int) []int {\\n    \\n    for i := len(digits) - 1; i >= 0; i--{\\n        \\n        if digits[i] < 9{\\n            digits[i]++\\n            return digits\\n        }\\n        \\n        digits[i] = 0\\n    }\\n    \\n    if digits[0] == 0{\\n        digits = append([]int{1}, digits...)\\n    }\\n    \\n    return digits\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc plusOne(digits []int) []int {\\n    \\n    for i := len(digits) - 1; i >= 0; i--{\\n        \\n        if digits[i] < 9{\\n            digits[i]++\\n            return digits\\n        }\\n        \\n        digits[i] = 0\\n    }\\n    \\n    if digits[0] == 0{\\n        digits = append([]int{1}, digits...)\\n    }\\n    \\n    return digits\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2710251,
                "title": "typescript-oneliner-solution",
                "content": "`return Array.from((BigInt(digits.join(\\'\\')) + BigInt(\\'1\\')).toString(), Number)`",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "`return Array.from((BigInt(digits.join(\\'\\')) + BigInt(\\'1\\')).toString(), Number)`",
                "codeTag": "Unknown"
            },
            {
                "id": 2687851,
                "title": "plus-one-java-100-fast-solution",
                "content": "Hi Everyone\\nHere is the easy solution for the Plus One Question with explanation as in commented code.\\n\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int carry = 1;\\n        int n = digits.length;\\n\\t\\t// loop to add the digits\\n        for(int i=n-1; i>=0; i--) {\\n            digits[i] += carry;   // add carry in every digit\\n            carry = digits[i] / 10;   // update carry for next digit\\n            digits[i] = digits[i] % 10;   //  put remainder in the digit\\n        }\\n        if(carry == 1) {   // in case of carry, we need to return n+1 length array\\n            int[] res = new int[n+1];\\n            res[0] = 1;\\n\\t\\t\\t// assinging values of digit in new array\\n            for(int i=1; i<=n;i++) {\\n                res[i] = digits[i-1];\\n            }\\n            return res;\\n        }\\n        return digits;   // not a carry, we can send updated digit array\\n    }\\n}\\n```\\n\\nThanks & Happy Coding!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int carry = 1;\\n        int n = digits.length;\\n\\t\\t// loop to add the digits\\n        for(int i=n-1; i>=0; i--) {\\n            digits[i] += carry;   // add carry in every digit\\n            carry = digits[i] / 10;   // update carry for next digit\\n            digits[i] = digits[i] % 10;   //  put remainder in the digit\\n        }\\n        if(carry == 1) {   // in case of carry, we need to return n+1 length array\\n            int[] res = new int[n+1];\\n            res[0] = 1;\\n\\t\\t\\t// assinging values of digit in new array\\n            for(int i=1; i<=n;i++) {\\n                res[i] = digits[i-1];\\n            }\\n            return res;\\n        }\\n        return digits;   // not a carry, we can send updated digit array\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680601,
                "title": "java-100-runtime-easy-understanding",
                "content": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n       int len=digits.length;\\n       for(int i=len-1;i>=0;i--){\\n           if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n           }\\n           digits[i]=0;\\n       }\\n        int[] newArr=new int[len+1];\\n        newArr[0]=1;\\n        return newArr;\\n    }\\n}\\n```\\n**please upvote if u like it**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n       int len=digits.length;\\n       for(int i=len-1;i>=0;i--){\\n           if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n           }\\n           digits[i]=0;\\n       }\\n        int[] newArr=new int[len+1];\\n        newArr[0]=1;\\n        return newArr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666984,
                "title": "c-clean-o-1-space-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        //same as add 1\\n        int carry = 1;\\n        \\n        // propagate carry\\n        for (int i = digits.size() - 1; i >= 0; --i) {\\n            digits[i] += carry;\\n            carry = digits[i] / 10;\\n            digits[i] = digits[i] % 10;\\n        }\\n        \\n        // handle the last carry if any\\n        if (carry) {\\n            digits.insert(digits.begin(), carry);\\n        }\\n\\n        return digits;\\n    }\\n};\\n\\n/*\\nif (you like this) {\\n\\tplease upvote;\\n}\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        //same as add 1\\n        int carry = 1;\\n        \\n        // propagate carry\\n        for (int i = digits.size() - 1; i >= 0; --i) {\\n            digits[i] += carry;\\n            carry = digits[i] / 10;\\n            digits[i] = digits[i] % 10;\\n        }\\n        \\n        // handle the last carry if any\\n        if (carry) {\\n            digits.insert(digits.begin(), carry);\\n        }\\n\\n        return digits;\\n    }\\n};\\n\\n/*\\nif (you like this) {\\n\\tplease upvote;\\n}\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574962,
                "title": "javascript-two-line-solution",
                "content": "```\\nvar plusOne = function (digits) {\\n  const arr = [...(BigInt(digits.join(\"\")) + BigInt(1)).toString()];\\n  return arr.map(Number);\\n};\\n```\\nWe have to use the **bigInt()**. <br>\\nBecause JS have a limited precision (2^53=9,007,199,254,740,992 for the biggest integer). And Test case `[6, 1, 4, 5, 3, 9, 0, 1, 9, 5, 1, 8, 6, 7, 0, 5, 5, 4, 3]` has passed that limit. As we cross the limit, we have to call the `bigInt()` function to to do precise calculation. And we can not add 1 directly to a `big-integer`. The number has to be the same type. Therefore, we have to add 1 like -  `bigInt(1)`. <br>",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar plusOne = function (digits) {\\n  const arr = [...(BigInt(digits.join(\"\")) + BigInt(1)).toString()];\\n  return arr.map(Number);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2377251,
                "title": "c-solution-easy-fast-than-96",
                "content": "```\\nvector<int> plusOne(vector<int>& digits) {\\n\\tint n = digits.size(), i; \\n\\tfor (i = n-1; i>=0; i--) {\\n\\t\\tif(digits[i]!=9) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tif(i==-1) {\\n\\t\\tvector<int> v(n+1, 0);\\n\\t\\tv[0]=1;\\n\\t\\treturn v;\\n\\t}\\n\\tdigits[i]++;\\n\\tfor(int j = i+1; j<n; j++) \\n\\t\\tdigits[j] = 0;\\n\\treturn digits;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> plusOne(vector<int>& digits) {\\n\\tint n = digits.size(), i; \\n\\tfor (i = n-1; i>=0; i--) {\\n\\t\\tif(digits[i]!=9) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tif(i==-1) {\\n\\t\\tvector<int> v(n+1, 0);\\n\\t\\tv[0]=1;\\n\\t\\treturn v;\\n\\t}\\n\\tdigits[i]++;\\n\\tfor(int j = i+1; j<n; j++) \\n\\t\\tdigits[j] = 0;\\n\\treturn digits;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2267126,
                "title": "go-easy-and-fast",
                "content": "```\\nfunc PlusOne(digits []int) []int {\\n\\tvar res int = 1\\n\\tfor i := len(digits) - 1; i >= 0; i-- {\\n\\t\\ts := digits[i]\\n\\t\\tif s+res <= 9 {\\n\\t\\t\\tdigits[i] += res\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tdigits[i] = 0\\n\\t\\tif i == 0 {\\n\\t\\t\\tdigits = append([]int{1}, digits...)\\n\\t\\t}\\n\\t}\\n\\treturn digits\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Math"
                ],
                "code": "```\\nfunc PlusOne(digits []int) []int {\\n\\tvar res int = 1\\n\\tfor i := len(digits) - 1; i >= 0; i-- {\\n\\t\\ts := digits[i]\\n\\t\\tif s+res <= 9 {\\n\\t\\t\\tdigits[i] += res\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tdigits[i] = 0\\n\\t\\tif i == 0 {\\n\\t\\t\\tdigits = append([]int{1}, digits...)\\n\\t\\t}\\n\\t}\\n\\treturn digits\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2090046,
                "title": "ruby-solutions-elegant-ruby-pointer-using-modulus-and-recursion",
                "content": "## Elegant Ruby solution\\n\\n```\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one(digits)\\n    digits.join.to_i.next.digits.reverse\\nend\\n```\\n\\n## Pointer with modulus solution\\n\\nThis is what a technical interview is looking for....\\n\\n```\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one(digits)\\n    carryover, pointer = 1, -1\\n    \\n    while carryover.positive?\\n        break digits.unshift(carryover) if digits[pointer].nil?\\n        \\n        sum = digits[pointer] + carryover\\n        carryover = sum / 10\\n        digits[pointer] = sum % 10\\n        pointer -= 1\\n    end\\n        \\n    digits\\nend\\n```\\n\\n## Recursiion of pointer with modulus solution\\n\\n```\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one(digits, pointer = -1, carryover = 1)\\n    return digits if carryover.zero?\\n    return digits.unshift(carryover) if digits[pointer].nil?\\n    \\n    sum = digits[pointer] + carryover\\n    digits[pointer] = sum % 10\\n    \\n    plus_one(digits, pointer - 1, sum / 10)\\nend\\n```\\n\\n## Benchmark\\n\\n```\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one_ruby_like(digits)\\n    digits.join.to_i.next.digits.reverse\\nend\\n\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one_pointer(digits)\\n    carryover, pointer = 1, -1\\n\\n    while carryover.positive?\\n        break digits.unshift(carryover) if digits[pointer].nil?\\n\\n        sum = digits[pointer] + carryover\\n        carryover = sum / 10\\n        digits[pointer] = sum % 10\\n        pointer -= 1\\n    end\\n\\n    digits\\nend\\n\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one_recursive(digits, pointer = -1, carryover = 1)\\n    return digits if carryover.zero?\\n    return digits.unshift(carryover) if digits[pointer].nil?\\n\\n    sum = digits[pointer] + carryover\\n    digits[pointer] = sum % 10\\n\\n    plus_one_recursive(digits, pointer - 1, sum / 10)\\nend\\n\\nrequire \\'benchmark\\'\\n\\nn = 1_000_000\\ntest_cases =\\n    [\\n        [1,2,3],\\n        [4,3,2,1],\\n        [9]\\n    ]\\n\\nBenchmark.bmbm do |x|\\n    x.report(\\'plus_one_ruby_like()\\') { n.times { |nth| plus_one_ruby_like(test_cases[nth % test_cases.length]) } }\\n    x.report(\\'plus_one_pointer()\\')  { n.times { |nth| plus_one_pointer(test_cases[nth % test_cases.length]) } }\\n    x.report(\\'plus_one_recursive()\\')  { n.times { |nth| plus_one_recursive(test_cases[nth % test_cases.length]) } }\\nend\\n```\\n\\nResult:\\n\\nRuby-like solution is slower due to the new object creations and transformation.\\n\\nThe pointer is faster since its updating the existing object, `digits`, in place.\\n\\nThis can be verified by calling `object_id` on the resulting object. The Ruby-like solution creates new objects, while the pointer solution result has the same `object_id` as the input.\\n\\n```\\nRehearsal --------------------------------------------------------\\nplus_one_ruby_like()   0.872726   0.003306   0.876032 (  0.876655)\\nplus_one_pointer()     0.176923   0.000899   0.177822 (  0.178070)\\nplus_one_recursive()   0.185491   0.000453   0.185944 (  0.185986)\\n----------------------------------------------- total: 1.239798sec\\n\\n                           user     system      total        real\\nplus_one_ruby_like()   1.449080   0.008460   1.457540 (  1.458386)\\nplus_one_pointer()     0.176361   0.001490   0.177851 (  0.178214)\\nplus_one_recursive()   0.188032   0.001648   0.189680 (  0.190059)\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one(digits)\\n    digits.join.to_i.next.digits.reverse\\nend\\n```\n```\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one(digits)\\n    carryover, pointer = 1, -1\\n    \\n    while carryover.positive?\\n        break digits.unshift(carryover) if digits[pointer].nil?\\n        \\n        sum = digits[pointer] + carryover\\n        carryover = sum / 10\\n        digits[pointer] = sum % 10\\n        pointer -= 1\\n    end\\n        \\n    digits\\nend\\n```\n```\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one(digits, pointer = -1, carryover = 1)\\n    return digits if carryover.zero?\\n    return digits.unshift(carryover) if digits[pointer].nil?\\n    \\n    sum = digits[pointer] + carryover\\n    digits[pointer] = sum % 10\\n    \\n    plus_one(digits, pointer - 1, sum / 10)\\nend\\n```\n```\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one_ruby_like(digits)\\n    digits.join.to_i.next.digits.reverse\\nend\\n\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one_pointer(digits)\\n    carryover, pointer = 1, -1\\n\\n    while carryover.positive?\\n        break digits.unshift(carryover) if digits[pointer].nil?\\n\\n        sum = digits[pointer] + carryover\\n        carryover = sum / 10\\n        digits[pointer] = sum % 10\\n        pointer -= 1\\n    end\\n\\n    digits\\nend\\n\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one_recursive(digits, pointer = -1, carryover = 1)\\n    return digits if carryover.zero?\\n    return digits.unshift(carryover) if digits[pointer].nil?\\n\\n    sum = digits[pointer] + carryover\\n    digits[pointer] = sum % 10\\n\\n    plus_one_recursive(digits, pointer - 1, sum / 10)\\nend\\n\\nrequire \\'benchmark\\'\\n\\nn = 1_000_000\\ntest_cases =\\n    [\\n        [1,2,3],\\n        [4,3,2,1],\\n        [9]\\n    ]\\n\\nBenchmark.bmbm do |x|\\n    x.report(\\'plus_one_ruby_like()\\') { n.times { |nth| plus_one_ruby_like(test_cases[nth % test_cases.length]) } }\\n    x.report(\\'plus_one_pointer()\\')  { n.times { |nth| plus_one_pointer(test_cases[nth % test_cases.length]) } }\\n    x.report(\\'plus_one_recursive()\\')  { n.times { |nth| plus_one_recursive(test_cases[nth % test_cases.length]) } }\\nend\\n```\n```\\nRehearsal --------------------------------------------------------\\nplus_one_ruby_like()   0.872726   0.003306   0.876032 (  0.876655)\\nplus_one_pointer()     0.176923   0.000899   0.177822 (  0.178070)\\nplus_one_recursive()   0.185491   0.000453   0.185944 (  0.185986)\\n----------------------------------------------- total: 1.239798sec\\n\\n                           user     system      total        real\\nplus_one_ruby_like()   1.449080   0.008460   1.457540 (  1.458386)\\nplus_one_pointer()     0.176361   0.001490   0.177851 (  0.178214)\\nplus_one_recursive()   0.188032   0.001648   0.189680 (  0.190059)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2057867,
                "title": "php-solutions-in-one-line",
                "content": "```\\nfunction plusOne($digits) {\\n        return str_split(bcadd(1,implode($digits)));\\n    }\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nfunction plusOne($digits) {\\n        return str_split(bcadd(1,implode($digits)));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2031771,
                "title": "c-solution-two-approaches-easy-to-understand",
                "content": "**Approach 1 :**\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int carry=1,size=digits.size();\\n        for(int i=size-1;i>=0;i--) {\\n            int sum=digits[i]+carry;\\n            digits[i]=sum%10;\\n            carry=sum/10;\\n        }\\n        if(carry>0) digits.insert(digits.begin(),carry);\\n        return digits;\\n    }\\n};\\n```\\n\\n\\n**Approach 2 :**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        for (int i=digits.size()-1;i>=0;i--){\\n            if (digits[i]==9){\\n                digits[i]=0;\\n            }\\n            else{\\n                digits[i]++;\\n                return digits;\\n            }\\n        }\\n        digits.push_back(0);\\n        digits[0]=1;\\n        return digits;\\n    }\\n};\\n```\\n\\nIf you liked the solution then, please upvote \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int carry=1,size=digits.size();\\n        for(int i=size-1;i>=0;i--) {\\n            int sum=digits[i]+carry;\\n            digits[i]=sum%10;\\n            carry=sum/10;\\n        }\\n        if(carry>0) digits.insert(digits.begin(),carry);\\n        return digits;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        for (int i=digits.size()-1;i>=0;i--){\\n            if (digits[i]==9){\\n                digits[i]=0;\\n            }\\n            else{\\n                digits[i]++;\\n                return digits;\\n            }\\n        }\\n        digits.push_back(0);\\n        digits[0]=1;\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478974,
                "title": "c-the-best-teacher-is-discussion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size()-1;\\n        for(int i=n;i>=0;i--)\\n        {\\n            if(digits[i]<9)\\n            {\\n                digits[i]++;\\n                return digits;\\n            }\\n            digits[i]=0;\\n        }\\n        digits[0]=1;\\n        digits.push_back(0);\\n        return digits;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size()-1;\\n        for(int i=n;i>=0;i--)\\n        {\\n            if(digits[i]<9)\\n            {\\n                digits[i]++;\\n                return digits;\\n            }\\n            digits[i]=0;\\n        }\\n        digits[0]=1;\\n        digits.push_back(0);\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368813,
                "title": "plus-one-easy-python-solution",
                "content": "If the last digit is any number from **0-8**, incrementing that by 1 will not cause any issue, making the case simple. In case the last digit is **9**, adding 1 will make it 10, so 9 will be replaced by 0 and addition of 1 to the previous number is to be done.\\n\\nConsider the example of 99 = [9,9] - adding 1 to last digit makes it 0 and 1 is added to previous digit and that again will become 0. Now since this is the first digit of the number (here in list format), 1 needs to be appended before it to finish the addition. This is done in the code blow. \\n\\n```\\ndef plusOne(self, digits: List[int]) -> List[int]:\\n        n = len(digits)\\n        \\n        while n>0:\\n            if digits[n-1]==9:\\n                if (n-1) == 0:\\n                    digits[n-1] = 0\\n                    temp = [1] + digits\\n                    return temp\\n                else:\\n                    digits[n-1] = 0\\n                    n = n-1\\n            else:\\n                digits[n-1] += 1\\n                return digits\\n        \\n        return digits\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef plusOne(self, digits: List[int]) -> List[int]:\\n        n = len(digits)\\n        \\n        while n>0:\\n            if digits[n-1]==9:\\n                if (n-1) == 0:\\n                    digits[n-1] = 0\\n                    temp = [1] + digits\\n                    return temp\\n                else:\\n                    digits[n-1] = 0\\n                    n = n-1\\n            else:\\n                digits[n-1] += 1\\n                return digits\\n        \\n        return digits\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1290715,
                "title": "java-simple-0ms-faster-than-100-pure-logic-clean-efficient-explained",
                "content": "# **Please Upvote if you got any help from the provided solution!!!**\\n\\nBasic Idea behind this implementation is:\\n* Increment the element by 1 if it is not equal to 9 and return it. \\neg: 35 + 1 = 16, so we will increment the element 5 by 1 to make it 6 and return it as no further manipulation is required on element 3(from 38).\\n\\n* But if element is 9, then make that element as 0(zero).\\neg: 59 + 1 = 60, here we will make the element 9 as 0(zero) and in the next iteration increment the element 5(from 59) by 1 to make it 6 and return it.\\n\\n* But for cases where all elements are 9, then we have to create a new array of 1 larger length than the original array so as to fit an extra element into it and return the newly created array.\\neg: If we have an array of length 4 and all elements consists of 9, then we need an array of length 5, so as to make the first element as 1(one) and remaining ones as 0\\'s(zeros).<br>\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9999  <-- here the number of digits are 4\\n<u>&nbsp;+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</u> \\n&nbsp;&nbsp;&nbsp;10000  <-- but after adding 1 to it the number of digits becomes 5 and for storing an extra element we need to create a new array of 1 length larger than the original one.\\n<hr><br>\\n\\n\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\n        final int len = digits.length;\\n        \\n        for(int index = len - 1; index >= 0; --index){\\n            if(digits[index] != 9){\\n                digits[index] += 1;  // if element is not equal to 9, then increment it by 1 and return it\\n                return digits; \\n            }\\n            digits[index] = 0; // else if element is 9, then make that element as 0(zero)\\n        }\\n        \\n        final int[] result = new int[len + 1]; //  for cases where all elements are 9, then we have to create a new array of 1 larger length than the original array\\n        result[0] = 1; // making the 1st element as 1 and rest will be 0 as the default value of int is 0, so all elements will be 0 except for 1st element which will be 1\\n        return result;\\n    }\\n}\\n```\\n\\n# **Please Upvote if you got any help from the provided solution!!!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\n        final int len = digits.length;\\n        \\n        for(int index = len - 1; index >= 0; --index){\\n            if(digits[index] != 9){\\n                digits[index] += 1;  // if element is not equal to 9, then increment it by 1 and return it\\n                return digits; \\n            }\\n            digits[index] = 0; // else if element is 9, then make that element as 0(zero)\\n        }\\n        \\n        final int[] result = new int[len + 1]; //  for cases where all elements are 9, then we have to create a new array of 1 larger length than the original array\\n        result[0] = 1; // making the 1st element as 1 and rest will be 0 as the default value of int is 0, so all elements will be 0 except for 1st element which will be 1\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207212,
                "title": "java-faster-than-100-easy-way",
                "content": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\t\\t\\n\\t\\tfor (int i = digits.length - 1; i >= 0; i--) {\\n\\t\\t\\tif (digits[i] < 9) { \\n\\t\\t\\t\\tdigits[i]++;\\n\\t\\t\\t\\treturn digits;\\n\\t\\t\\t} else { digits[i] = 0; }\\n\\t\\t}\\n        \\n        int[] temp = new int[digits.length + 1];\\n\\t\\ttemp[0] = 1;\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\t\\t\\n\\t\\tfor (int i = digits.length - 1; i >= 0; i--) {\\n\\t\\t\\tif (digits[i] < 9) { \\n\\t\\t\\t\\tdigits[i]++;\\n\\t\\t\\t\\treturn digits;\\n\\t\\t\\t} else { digits[i] = 0; }\\n\\t\\t}\\n        \\n        int[] temp = new int[digits.length + 1];\\n\\t\\ttemp[0] = 1;\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694574,
                "title": "java-with-comments-easy-to-understand-100-time",
                "content": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        for(int i=digits.length-1; i>=0; i--){\\n            if(digits[i]<9){\\n                //first non-9 will be incremented by 1 and then the result is returned\\n                digits[i] = digits[i] + 1;\\n                return digits;\\n            }\\n            //if it is 9, make it zero. we\\'re incrementing first non-9 above.\\n            digits[i] = 0;\\n        }\\n            \\n        //if we reached here that means we have a case where array consists of all nines.  \\n        //In that case, the array is all zeroes. we just need to make 0th position 1. \\n        int[] result = new int[digits.length + 1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        for(int i=digits.length-1; i>=0; i--){\\n            if(digits[i]<9){\\n                //first non-9 will be incremented by 1 and then the result is returned\\n                digits[i] = digits[i] + 1;\\n                return digits;\\n            }\\n            //if it is 9, make it zero. we\\'re incrementing first non-9 above.\\n            digits[i] = 0;\\n        }\\n            \\n        //if we reached here that means we have a case where array consists of all nines.  \\n        //In that case, the array is all zeroes. we just need to make 0th position 1. \\n        int[] result = new int[digits.length + 1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24438,
                "title": "my-c-code-check-9",
                "content": "    vector<int> plusOne(vector<int> &digits) {\\n        int i;\\n        for(i=digits.size()-1;i>=0;i--)\\n        {\\n            if(digits[i]!=9)\\n            {\\n                digits[i]++;\\n                break;\\n            }\\n            else\\n            {\\n                digits[i] = 0;\\n            }\\n        }\\n        if(!digits[0])\\n        {\\n            digits[0] = 1;\\n            digits.push_back(0);\\n        }\\n        return digits;\\n    }",
                "solutionTags": [],
                "code": "    vector<int> plusOne(vector<int> &digits) {\\n        int i;\\n        for(i=digits.size()-1;i>=0;i--)\\n        {\\n            if(digits[i]!=9)\\n            {\\n                digits[i]++;\\n                break;\\n            }\\n            else\\n            {\\n                digits[i] = 0;\\n            }\\n        }\\n        if(!digits[0])\\n        {\\n            digits[0] = 1;\\n            digits.push_back(0);\\n        }\\n        return digits;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4087841,
                "title": "python-98-30-beats-2-approachs-simple-code",
                "content": "**If you got help from this,... Plz Upvote .. it encourage me**\\n\\n# Code\\n# Approach 1 (Array) -> 98.30 % beats\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n\\n        for i in range(len(digits)-1, -1, -1):\\n            if digits[i] == 9:\\n                digits[i] = 0\\n            else:\\n                digits[i] = digits[i] + 1\\n                return digits\\n        return [1] + digits \\n\\n        \\n```\\n\\n# Approach 2 (Convert list -> Number :: -> Addition +1 :: -> Number  -> List\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        # List -> Number\\n        n = 0\\n        for ele in digits:\\n            n = (n*10) + ele\\n        \\n        n = n+1\\n        \\n        # Number -> List\\n        digits = []\\n        while n > 0:\\n            digits.insert(0, n % 10)  \\n            n //= 10 \\n        return digits\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n\\n        for i in range(len(digits)-1, -1, -1):\\n            if digits[i] == 9:\\n                digits[i] = 0\\n            else:\\n                digits[i] = digits[i] + 1\\n                return digits\\n        return [1] + digits \\n\\n        \\n```\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        # List -> Number\\n        n = 0\\n        for ele in digits:\\n            n = (n*10) + ele\\n        \\n        n = n+1\\n        \\n        # Number -> List\\n        digits = []\\n        while n > 0:\\n            digits.insert(0, n % 10)  \\n            n //= 10 \\n        return digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075521,
                "title": "simple-and-easy-approach-in-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n //you have to traverse array until the element is not equal to 9\\n//from last index and add one if element is not equal to 9\\n        for(int i=digits.size()-1;i>=0;i--){\\n            if(digits[i]!=9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            else{\\n                digits[i]=0;\\n            }\\n        }\\n//if whole array is nine the push_back one element and index[0]==1\\n        digits.push_back(0);\\n        digits[0]=1;\\n        return digits;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n //you have to traverse array until the element is not equal to 9\\n//from last index and add one if element is not equal to 9\\n        for(int i=digits.size()-1;i>=0;i--){\\n            if(digits[i]!=9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            else{\\n                digits[i]=0;\\n            }\\n        }\\n//if whole array is nine the push_back one element and index[0]==1\\n        digits.push_back(0);\\n        digits[0]=1;\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959120,
                "title": "java-code-easy-to-under-stand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n        for (int i = n - 1; i >= 0; i--) {\\n            digits[i]++;\\n            if (digits[i] < 10) {\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n       \\n        int[] result = new int[n + 1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n        for (int i = n - 1; i >= 0; i--) {\\n            digits[i]++;\\n            if (digits[i] < 10) {\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n       \\n        int[] result = new int[n + 1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3934362,
                "title": "simple-easy-solution-in-python3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        s= \\'\\'.join(map(str,digits))\\n        i=int(s)+1\\n        li=list(map(int,str(i)))  \\n        return li\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        s= \\'\\'.join(map(str,digits))\\n        i=int(s)+1\\n        li=list(map(int,str(i)))  \\n        return li\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668116,
                "title": "intuitive-recursive-solution-run-time-o-n-space-o-1",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the last element is smaller than 9. -> ** add 1 to the last element**\\n\\nIf the last element is equal to 9. --> **change the value of the element to 0 (as we can\\'t store the value 10 in one digit, we have to carry 1 to the next digit)\\n\\nDecrease i by 1 (to iterate backward as we are using i as index) and decrease length by 1 (we need length as a reference to stop the recursion)\\n$$note:$$ we don\\'t need a \"carry\" variable as in every scenario it is going to be 1\\nCall the function again.\\n\\nWhen we call the function again, if the next digit is smaller than 9 we can just +1 the value of the element we are on.\\n\\nIf the element is 9 we can call our function again.\\nIf there is no element left (but we still have to add the $$carry$$, we add 1 as a new element to the list)\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def plusOne(self, digits):\\n        \"\"\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        i = -1 #index to start from the end\\n        length = len(digits) \\n\\n        def Calculate(arr, i, length):\\n            if length != 0 and arr[i] != 9:\\n                arr[i] += 1 \\n            elif length > 0:\\n                arr[i] = 0\\n                length -= 1\\n                i -= 1\\n                Calculate(arr, i, length)\\n            else:\\n                arr.insert(0, 1) \\n        \\n        Calculate(digits, i, length)\\n        return digits\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def plusOne(self, digits):\\n        \"\"\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        i = -1 #index to start from the end\\n        length = len(digits) \\n\\n        def Calculate(arr, i, length):\\n            if length != 0 and arr[i] != 9:\\n                arr[i] += 1 \\n            elif length > 0:\\n                arr[i] = 0\\n                length -= 1\\n                i -= 1\\n                Calculate(arr, i, length)\\n            else:\\n                arr.insert(0, 1) \\n        \\n        Calculate(digits, i, length)\\n        return digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606996,
                "title": "optimized-solution-0ms-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size(); // Get the size of the digits array\\n        for (int i = n - 1; i >= 0; i--) { // Iterate over the digits array from right to left\\n            if (digits[i] < 9) { // Check if the current digit is less than 9\\n                digits[i]++; // If it is, increment the digit by 1\\n                return digits; // Return the modified array\\n            }\\n            digits[i] = 0; // Set the current digit to 0 since it was 9\\n        }\\n        digits.insert(digits.begin(), 1); // If all digits were 9, insert 1 at the beginning\\n        return digits; // Return the modified array\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE :)**",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size(); // Get the size of the digits array\\n        for (int i = n - 1; i >= 0; i--) { // Iterate over the digits array from right to left\\n            if (digits[i] < 9) { // Check if the current digit is less than 9\\n                digits[i]++; // If it is, increment the digit by 1\\n                return digits; // Return the modified array\\n            }\\n            digits[i] = 0; // Set the current digit to 0 since it was 9\\n        }\\n        digits.insert(digits.begin(), 1); // If all digits were 9, insert 1 at the beginning\\n        return digits; // Return the modified array\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462162,
                "title": "add-one-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& d) {\\n        int c=1;\\n        for(int i=d.size()-1;i>=0;i--)\\n        {\\n            int f=d[i]+c;\\n            d[i]=f%10;\\n            c=f/10;\\n        }\\n        if(c!=0)\\n        {\\n            reverse(d.begin(),d.end());\\n            d.push_back(c);\\n            reverse(d.begin(),d.end());\\n        }\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& d) {\\n        int c=1;\\n        for(int i=d.size()-1;i>=0;i--)\\n        {\\n            int f=d[i]+c;\\n            d[i]=f%10;\\n            c=f/10;\\n        }\\n        if(c!=0)\\n        {\\n            reverse(d.begin(),d.end());\\n            d.push_back(c);\\n            reverse(d.begin(),d.end());\\n        }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393850,
                "title": "increment-a-large-integer-represented-as-an-array-c-solution-easy-to-understand",
                "content": "# Intuition\\n![iages.jpeg](https://assets.leetcode.com/users/images/886eabe7-02a5-4004-a712-457c4c886152_1680957173.8068066.jpeg)\\n\\n\\n***We need to increment a large integer represented as an integer array by 1. One way to approach this problem is to iterate through the array from right to left and add 1 to each digit until we find a digit that is less than 10. If we reach the leftmost digit and it needs to be set to 0, we need to create a new array with one extra element and set the first element to 1.***\\n\\n# Approach\\n\\n***We will implement the approach mentioned in the intuition. We will start iterating through the array from right to left and increment each digit by 1. If the resulting digit is less than 10, we can return the modified array. Otherwise, we will set the current digit to 0 and continue with the next digit.If we reach the leftmost digit and it needs to be set to 0, we will create a new array with one extra element and set the first element to 1. We will return this new array as the result.***\\n\\n# Complexity\\n- Time complexity:\\n- \\n       O(N)\\n\\n- Space complexity:\\n- \\n       O(1)\\n       \\n\\n# Code\\n```\\nint* plusOne(int* digits, int digitsSize, int* returnSize) {\\n    for (int i = digitsSize - 1; i >= 0; i--) {\\n        digits[i]++;\\n        if (digits[i] < 10) {\\n            *returnSize = digitsSize;\\n            return digits;\\n        }\\n        digits[i] = 0;\\n    }\\n    int* result = (int*)malloc((digitsSize + 1) * sizeof(int));\\n    result[0] = 1;\\n    for (int i = 1; i <= digitsSize; i++) {\\n        result[i] = 0;\\n    }\\n    *returnSize = digitsSize + 1;\\n    return result;\\n}\\n\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nint* plusOne(int* digits, int digitsSize, int* returnSize) {\\n    for (int i = digitsSize - 1; i >= 0; i--) {\\n        digits[i]++;\\n        if (digits[i] < 10) {\\n            *returnSize = digitsSize;\\n            return digits;\\n        }\\n        digits[i] = 0;\\n    }\\n    int* result = (int*)malloc((digitsSize + 1) * sizeof(int));\\n    result[0] = 1;\\n    for (int i = 1; i <= digitsSize; i++) {\\n        result[i] = 0;\\n    }\\n    *returnSize = digitsSize + 1;\\n    return result;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3298844,
                "title": "python-easiest-approach-beating-90-25",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/cfd19bd3-25de-4601-b4c4-24885a9e2151_1678857572.4187334.png)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def plusOne(self, digits):\\n        \"\"\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        digits=[str(i) for i in digits]\\n        s=\\'\\'.join(digits)\\n        a=int(s)+1\\n        l=list(str(a))\\n        l=[int(i) for i in l]\\n        return l\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def plusOne(self, digits):\\n        \"\"\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        digits=[str(i) for i in digits]\\n        s=\\'\\'.join(digits)\\n        a=int(s)+1\\n        l=list(str(a))\\n        l=[int(i) for i in l]\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260726,
                "title": "python3-95-fast",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- MSB to LSB is gives so increment in reverse manner.\\n- maintan carry variable to map if we have any previous overflow.\\n- at last if we have any carry left insert it to front of list.\\n- return digits.\\n\\n\\n![Screenshot 2023-03-05 204834.png](https://assets.leetcode.com/users/images/c7e27b34-d600-40e9-b750-d26fb8a3e99c_1678029545.3783138.png)\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        carry = 0\\n        n = len(digits)\\n        for i in reversed(range(n)):\\n            val = digits[i] + carry + 1 if i == n-1 else digits[i] + carry\\n            if val <= 9:\\n                digits[i] = val\\n                carry = 0\\n            else:\\n                carry = val // 10\\n                val -= 10\\n                digits[i] = val\\n        if carry:\\n            digits.insert(0, carry)\\n        return digits\\n```\\n# Please like and Comment below \\uD83D\\uDC4B\\u2267\\u25C9\\u1D25\\u25C9\\u2266",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        carry = 0\\n        n = len(digits)\\n        for i in reversed(range(n)):\\n            val = digits[i] + carry + 1 if i == n-1 else digits[i] + carry\\n            if val <= 9:\\n                digits[i] = val\\n                carry = 0\\n            else:\\n                carry = val // 10\\n                val -= 10\\n                digits[i] = val\\n        if carry:\\n            digits.insert(0, carry)\\n        return digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137627,
                "title": "plus-one-o-n-time-complexity",
                "content": "# Intuition\\nTo not use Brute Force Approach and optimize the solution.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n* for numbers less than or equal to 8 - can directly be incremented by 1.\\n* eg: 786 + 1= 787\\n* for number which is equal to 9 - will be replaced with 0 and generate a carry\\n* That carry will be further added to the beginning. \\n* eg: 9 + 1 = 0 carry generated  \\n* Now 1 will be placed in the beginning. \\n* Final array will be 10 \\n \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        short i =0; // for smaller integers\\n        bool carry =0; // carry can be zero or one so used bool\\n        for(i=digits.size()-1;i>=0;--i){\\n            if(digits[i]<=8){ // for digits less than 8\\n                digits[i]++; // incremented by 1 directly\\n                carry =0; // no need of carry\\n                break; // increased the number by 1 and break\\n            }\\n            else{\\n                digits[i]=0; // else if the number is 9 , so replace the number by 0\\n                carry=1; // generate a carry 1\\n            }\\n        }\\n        if (carry) digits.insert(digits.begin(),1); // as number was increased by 1 there was 1 carry , carry will be placed in beginning \\n        return digits; // return the incremented digits as final output \\n    }\\nint main(){\\n    return 0;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        short i =0; // for smaller integers\\n        bool carry =0; // carry can be zero or one so used bool\\n        for(i=digits.size()-1;i>=0;--i){\\n            if(digits[i]<=8){ // for digits less than 8\\n                digits[i]++; // incremented by 1 directly\\n                carry =0; // no need of carry\\n                break; // increased the number by 1 and break\\n            }\\n            else{\\n                digits[i]=0; // else if the number is 9 , so replace the number by 0\\n                carry=1; // generate a carry 1\\n            }\\n        }\\n        if (carry) digits.insert(digits.begin(),1); // as number was increased by 1 there was 1 carry , carry will be placed in beginning \\n        return digits; // return the incremented digits as final output \\n    }\\nint main(){\\n    return 0;\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3122017,
                "title": "simple-way-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int idx=digits.size()-1;\\n        while(idx>=0)\\n        {\\n            if(digits[idx]==9)\\n            {\\n                digits[idx]=0;\\n            }\\n            else\\n            {\\n                digits[idx]+=1;\\n                return digits;\\n            }\\n            idx--;\\n        }\\n        digits.insert(digits.begin(),1);\\n        return digits;\\n        \\n        \\n\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int idx=digits.size()-1;\\n        while(idx>=0)\\n        {\\n            if(digits[idx]==9)\\n            {\\n                digits[idx]=0;\\n            }\\n            else\\n            {\\n                digits[idx]+=1;\\n                return digits;\\n            }\\n            idx--;\\n        }\\n        digits.insert(digits.begin(),1);\\n        return digits;\\n        \\n        \\n\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086740,
                "title": "beats-100-easy-beginner-friendly-c-solution",
                "content": "# Intuition\\n\\n\\n# Approach\\nHere,First we have to take two cases\\n1) if digit < 9\\n    casually increment digit[i];\\n2) if digit == 9\\n    here we find no of last occuring 9\\'s so,we increment just      before index of first 9 in given array order.\\n->apply for loop to get incrementing position\\ntwo cases\\n 1.if only one 9 i.e., {9} then we have update 9 to 1 and pushback 0;\\n 2. if no of 9\\'s > 1 (ex:499,87999)then we update the just before index of first consecutive 9 and update the remaining values 0f 9with for loop by 0\\n \\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        #for storing last consecutive 9\\'s location appearing from reverse\\n        int a = 0;\\n\\n        if(digits[n-1] < 9){\\n            digits[n-1]++;\\n            return digits;\\n        }\\n\\n        if(digits[n-1]==9){\\n            #for finding last consective 9 from reverse\\n            for(int i = n-1; i>=0;i--){\\n               \\n                if(digits[i] == 9){\\n                    a  =  i;                 \\n                }\\n                else if(digits[i]<9){\\n                    break;\\n\\n                }\\n              \\n            }\\n            #updating 9\\'s with 1\\n            if(a == 0){\\n                digits[0] = 1;\\n                for(int i = 1;i<n;i++){\\n                    digits[i] = 0;\\n                }\\n                digits.push_back(0);\\n            }\\n            #updating 9\\'s with 0\\n            if(a>0){\\n                 digits[a-1]++;\\n                for(int i = a; i<n; i++){\\n                    digits[i] = 0;\\n                }\\n            }   \\n        }\\n        \\n      return digits;\\n    }\\n    \\n};\\n\\n```\\n\\n\\n![{C6536750-B4F1-492E-9ED4-046628FB312E}.png](https://assets.leetcode.com/users/images/6ae85fce-a91d-408f-bb91-87d599ad888f_1674403258.8890588.png)\\n\\n\\nIf u find it useful please upvote this solution.\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        #for storing last consecutive 9\\'s location appearing from reverse\\n        int a = 0;\\n\\n        if(digits[n-1] < 9){\\n            digits[n-1]++;\\n            return digits;\\n        }\\n\\n        if(digits[n-1]==9){\\n            #for finding last consective 9 from reverse\\n            for(int i = n-1; i>=0;i--){\\n               \\n                if(digits[i] == 9){\\n                    a  =  i;                 \\n                }\\n                else if(digits[i]<9){\\n                    break;\\n\\n                }\\n              \\n            }\\n            #updating 9\\'s with 1\\n            if(a == 0){\\n                digits[0] = 1;\\n                for(int i = 1;i<n;i++){\\n                    digits[i] = 0;\\n                }\\n                digits.push_back(0);\\n            }\\n            #updating 9\\'s with 0\\n            if(a>0){\\n                 digits[a-1]++;\\n                for(int i = a; i<n; i++){\\n                    digits[i] = 0;\\n                }\\n            }   \\n        }\\n        \\n      return digits;\\n    }\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961997,
                "title": "100-beats-c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& d) {\\n        for(int i=d.size()-1;i>=0;i--)  {\\n          if(d[i]<9){\\n              d[i]++;\\n              return d;\\n          }\\n          else{\\n              d[i]=0;\\n          }\\n      }\\n        d.push_back(0);\\n        d[0]=1;\\n          \\n      \\n\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& d) {\\n        for(int i=d.size()-1;i>=0;i--)  {\\n          if(d[i]<9){\\n              d[i]++;\\n              return d;\\n          }\\n          else{\\n              d[i]=0;\\n          }\\n      }\\n        d.push_back(0);\\n        d[0]=1;\\n          \\n      \\n\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1572510,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1568525,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1663040,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1571826,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1779772,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1569392,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1568886,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1659327,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1568480,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1574979,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1572510,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1568525,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1663040,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1571826,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1779772,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1569392,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1568886,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1659327,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1568480,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1574979,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1945414,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1570218,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1953534,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1570820,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 2028655,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1729564,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1718343,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1625339,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1573484,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1568626,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1998273,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1996383,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1948881,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1772771,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1572288,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1572251,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1572202,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1575637,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1575354,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1575298,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1571908,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2075848,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2071032,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2069813,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2069121,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2067406,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2055166,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2054500,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2050421,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2047933,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2045323,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 2044544,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 2040611,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 2036252,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 2035844,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 2022155,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 2009432,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 2005275,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 2003887,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 1998898,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 1994941,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1986849,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1978507,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1972982,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1971507,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1966992,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1959180,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1956445,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1942942,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1941708,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1941687,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1934735,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1922431,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1918670,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1908466,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1907090,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1891365,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1884705,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1883693,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1858251,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1846145,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1841757,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1840067,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1839821,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1838736,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1835121,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1830114,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1827168,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1813842,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1808828,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1805046,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1800492,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1798573,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1796819,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1794579,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1789588,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1789139,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1785143,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1779515,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1774899,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1772541,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1772367,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1767978,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1767655,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1762112,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1760265,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1759374,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1758655,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1754118,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1751716,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1750926,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1750884,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1749795,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1749204,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1741891,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1738350,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1733046,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1729248,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1724878,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1723443,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1722518,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1721161,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1720584,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1718041,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1716171,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1715296,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1707595,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1706793,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1704307,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1701915,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1701808,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1699010,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1697006,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1690646,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1685423,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1685414,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1684055,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1682619,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1681229,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1676120,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            }
        ]
    },
    {
        "title": "Fraction to Recurring Decimal",
        "question_content": "<p>Given two integers representing the <code>numerator</code> and <code>denominator</code> of a fraction, return <em>the fraction in string format</em>.</p>\n\n<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>\n\n<p>If multiple answers are possible, return <strong>any of them</strong>.</p>\n\n<p>It is <strong>guaranteed</strong> that the length of the answer string is less than <code>10<sup>4</sup></code> for all the given inputs.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numerator = 1, denominator = 2\n<strong>Output:</strong> &quot;0.5&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numerator = 2, denominator = 1\n<strong>Output:</strong> &quot;2&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> numerator = 4, denominator = 333\n<strong>Output:</strong> &quot;0.(012)&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;=&nbsp;numerator, denominator &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>denominator != 0</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 51106,
                "title": "my-clean-java-solution",
                "content": "The important thing is to consider all edge cases while thinking this problem through, including: negative integer, possible overflow, etc.\\n\\nUse HashMap to store a remainder and its associated index while doing the division so that whenever a same remainder comes up, we know there is a repeating fractional part.\\n\\nPlease comment if you see something wrong or can be improved. Cheers!\\n\\n    public class Solution {\\n        public String fractionToDecimal(int numerator, int denominator) {\\n            if (numerator == 0) {\\n                return \"0\";\\n            }\\n            StringBuilder res = new StringBuilder();\\n            // \"+\" or \"-\"\\n            res.append(((numerator > 0) ^ (denominator > 0)) ? \"-\" : \"\");\\n            long num = Math.abs((long)numerator);\\n            long den = Math.abs((long)denominator);\\n            \\n            // integral part\\n            res.append(num / den);\\n            num %= den;\\n            if (num == 0) {\\n                return res.toString();\\n            }\\n            \\n            // fractional part\\n            res.append(\".\");\\n            HashMap<Long, Integer> map = new HashMap<Long, Integer>();\\n            map.put(num, res.length());\\n            while (num != 0) {\\n                num *= 10;\\n                res.append(num / den);\\n                num %= den;\\n                if (map.containsKey(num)) {\\n                    int index = map.get(num);\\n                    res.insert(index, \"(\");\\n                    res.append(\")\");\\n                    break;\\n                }\\n                else {\\n                    map.put(num, res.length());\\n                }\\n            }\\n            return res.toString();\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String fractionToDecimal(int numerator, int denominator) {\\n            if (numerator == 0) {\\n                return \"0\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 51109,
                "title": "accepted-cpp-solution-with-explainations",
                "content": "    // upgraded parameter types\\n    string fractionToDecimal(int64_t n, int64_t d) {\\n        // zero numerator\\n        if (n == 0) return \"0\";\\n    \\n        string res;\\n        // determine the sign\\n        if (n < 0 ^ d < 0) res += '-';\\n    \\n        // remove sign of operands\\n        n = abs(n), d = abs(d);\\n    \\n        // append integral part\\n        res += to_string(n / d);\\n    \\n        // in case no fractional part\\n        if (n % d == 0) return res;\\n    \\n        res += '.';\\n    \\n        unordered_map<int, int> map;\\n    \\n        // simulate the division process\\n        for (int64_t r = n % d; r; r %= d) {\\n    \\n            // meet a known remainder\\n            // so we reach the end of the repeating part\\n            if (map.count(r) > 0) {\\n                res.insert(map[r], 1, '(');\\n                res += ')';\\n                break;\\n            }\\n    \\n            // the remainder is first seen\\n            // remember the current position for it\\n            map[r] = res.size();\\n    \\n            r *= 10;\\n    \\n            // append the quotient digit\\n            res += to_string(r / d);\\n        }\\n    \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    // upgraded parameter types\\n    string fractionToDecimal(int64_t n, int64_t d) {\\n        // zero numerator\\n        if (n == 0) return \"0\";\\n    \\n        string res;\\n        // determine the sign\\n        if (n < 0 ^ d < 0) res += '-';\\n    \\n        // remove sign of operands\\n        n = abs(n), d = abs(d);\\n    \\n        // append integral part\\n        res += to_string(n / d);\\n    \\n        // in case no fractional part\\n        if (n % d == 0) return res;\\n    \\n        res += '.';\\n    \\n        unordered_map<int, int> map;\\n    \\n        // simulate the division process\\n        for (int64_t r = n % d; r; r %= d) {\\n    \\n            // meet a known remainder\\n            // so we reach the end of the repeating part\\n            if (map.count(r) > 0) {\\n                res.insert(map[r], 1, '(');\\n                res += ')';\\n                break;\\n            }\\n    \\n            // the remainder is first seen\\n            // remember the current position for it\\n            map[r] = res.size();\\n    \\n            r *= 10;\\n    \\n            // append the quotient digit\\n            res += to_string(r / d);\\n        }\\n    \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51160,
                "title": "c-unordered-map",
                "content": "For the decimal part to recur, **the remainder should recur**. So we maintain the remainders we have seen. Once we see an existing remainder, we have reached the end of the recurring part (enclose it with a `)`). Moreover, insert the `(` to the starting index of the recurring part by maintaining a mapping from each remainder to the index of the corresponding digit and using it to retrieve the starting index.\\n\\nFor those without fractional parts or with non-recursive fractional points, we may find them out by `%` or zero remainder. Some other problems that need to be considered include the sign and overflow (`-2147483648 / -1`).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if (!numerator) {\\n            return \"0\";\\n        }\\n        string ans;\\n        if (numerator > 0 ^ denominator > 0) {\\n            ans += \\'-\\';\\n        }\\n        long n = labs(numerator), d = labs(denominator), r = n % d;\\n        ans += to_string(n / d);\\n        if (!r) {\\n            return ans;\\n        }\\n        ans += \\'.\\';\\n        unordered_map<long, int> rs;\\n        while (r) {\\n            if (rs.find(r) != rs.end()) {\\n                ans.insert(rs[r], \"(\");\\n                ans += \\')\\';\\n                break;\\n            }\\n            rs[r] = ans.size();\\n            r *= 10;\\n            ans += to_string(r / d);\\n            r %= d;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if (!numerator) {\\n            return \"0\";\\n        }\\n        string ans;\\n        if (numerator > 0 ^ denominator > 0) {\\n            ans += \\'-\\';\\n        }\\n        long n = labs(numerator), d = labs(denominator), r = n % d;\\n        ans += to_string(n / d);\\n        if (!r) {\\n            return ans;\\n        }\\n        ans += \\'.\\';\\n        unordered_map<long, int> rs;\\n        while (r) {\\n            if (rs.find(r) != rs.end()) {\\n                ans.insert(rs[r], \"(\");\\n                ans += \\')\\';\\n                break;\\n            }\\n            rs[r] = ans.size();\\n            r *= 10;\\n            ans += to_string(r / d);\\n            r %= d;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51110,
                "title": "do-not-use-python-as-cpp-here-s-a-short-version-python-code",
                "content": "Though python is slow, It is easy to write\\n\\n    class Solution:\\n    # @return a string\\n    def fractionToDecimal(self, numerator, denominator):\\n        n, remainder = divmod(abs(numerator), abs(denominator))\\n        sign = '-' if numerator*denominator < 0 else ''\\n        result = [sign+str(n), '.']\\n        stack = []\\n        while remainder not in stack:\\n            stack.append(remainder)\\n            n, remainder = divmod(remainder*10, abs(denominator))\\n            result.append(str(n))\\n\\n        idx = stack.index(remainder)\\n        result.insert(idx+2, '(')\\n        result.append(')')\\n        return ''.join(result).replace('(0)', '').rstrip('.')\\n\\nand there's no overflow",
                "solutionTags": [
                    "Python"
                ],
                "code": "Though python is slow, It is easy to write\\n\\n    class Solution:\\n    # @return a string\\n    def fractionToDecimal(self, numerator, denominator):\\n        n, remainder = divmod(abs(numerator), abs(denominator))\\n        sign = '-' if numerator*denominator < 0 else ''\\n        result = [sign+str(n), '.']\\n        stack = []\\n        while remainder not in stack:\\n            stack.append(remainder)\\n            n, remainder = divmod(remainder*10, abs(denominator))\\n            result.append(str(n))\\n\\n        idx = stack.index(remainder)\\n        result.insert(idx+2, '(')\\n        result.append(')')\\n        return ''.join(result).replace('(0)', '').rstrip('.')\\n\\nand there's no overflow",
                "codeTag": "Java"
            },
            {
                "id": 51187,
                "title": "python-easy-to-understand-solution",
                "content": "```\\nclass Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        if numerator % denominator == 0:\\n            return str(numerator//denominator)\\n        sign = \\'\\' if numerator * denominator >= 0 else \\'-\\'\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        res = sign + str(numerator//denominator) + \\'.\\'\\n        numerator %= denominator\\n        i, part = 0, \\'\\'\\n        m = {numerator:i}\\n        while numerator % denominator:\\n            numerator *= 10\\n            i += 1\\n            rem = numerator % denominator\\n            part += str(numerator // denominator)\\n            if rem in m:\\n                part = part[:m[rem]]+\\'(\\'+part[m[rem]:]+\\')\\'\\n                return res + part\\n            m[rem] = i\\n            numerator = rem\\n        return res + part\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        if numerator % denominator == 0:\\n            return str(numerator//denominator)\\n        sign = \\'\\' if numerator * denominator >= 0 else \\'-\\'\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        res = sign + str(numerator//denominator) + \\'.\\'\\n        numerator %= denominator\\n        i, part = 0, \\'\\'\\n        m = {numerator:i}\\n        while numerator % denominator:\\n            numerator *= 10\\n            i += 1\\n            rem = numerator % denominator\\n            part += str(numerator // denominator)\\n            if rem in m:\\n                part = part[:m[rem]]+\\'(\\'+part[m[rem]:]+\\')\\'\\n                return res + part\\n            m[rem] = i\\n            numerator = rem\\n        return res + part\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51140,
                "title": "short-java-solution",
                "content": "    public String fractionToDecimal(int numerator, int denominator) {\\n        StringBuilder result = new StringBuilder();\\n        String sign = (numerator < 0 == denominator < 0 || numerator == 0) ? \"\" : \"-\";\\n        long num = Math.abs((long) numerator);\\n        long den = Math.abs((long) denominator);\\n        result.append(sign);\\n        result.append(num / den);\\n        long remainder = num % den;\\n        if (remainder == 0)\\n            return result.toString();\\n        result.append(\".\");\\n        HashMap<Long, Integer> hashMap = new HashMap<Long, Integer>();\\n        while (!hashMap.containsKey(remainder)) {\\n            hashMap.put(remainder, result.length());\\n            result.append(10 * remainder / den);\\n            remainder = 10 * remainder % den;\\n        }\\n        int index = hashMap.get(remainder);\\n        result.insert(index, \"(\");\\n        result.append(\")\");\\n        return result.toString().replace(\"(0)\", \"\");\\n    }",
                "solutionTags": [],
                "code": "    public String fractionToDecimal(int numerator, int denominator) {\\n        StringBuilder result = new StringBuilder();\\n        String sign = (numerator < 0 == denominator < 0 || numerator == 0) ? \"\" : \"-\";\\n        long num = Math.abs((long) numerator);\\n        long den = Math.abs((long) denominator);\\n        result.append(sign);\\n        result.append(num / den);\\n        long remainder = num % den;\\n        if (remainder == 0)\\n            return result.toString();\\n        result.append(\".\");\\n        HashMap<Long, Integer> hashMap = new HashMap<Long, Integer>();\\n        while (!hashMap.containsKey(remainder)) {\\n            hashMap.put(remainder, result.length());\\n            result.append(10 * remainder / den);\\n            remainder = 10 * remainder % den;\\n        }\\n        int index = hashMap.get(remainder);\\n        result.insert(index, \"(\");\\n        result.append(\")\");\\n        return result.toString().replace(\"(0)\", \"\");\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1669777,
                "title": "accepted-simple-solution-with-step-by-step-detailed-explaination",
                "content": "So we can divide this question in three parts :\\n1.\\tDivision with its own multiple for eg. 8 / 4 = 2\\n2.\\tDivision without repeating numbers after decimal for eg. 41 / 2 = 20.5\\n3.\\tDivision with repeating numbers after decimal for eg. 14 / 3 = 4.(6) or 47 / 18 = 2.6(1)\\nNote : Here the repeating part is in bracket.\\n\\nFor **1st Part** we can normally divide the numbers and add it to the ans string and return if the remainder is 0.\\n\\n```\\n//Code: \\nint q = num / den;\\nint r = num % den;\\nans += q;\\nif(r == 0) return ans;\\n```\\n\\nFor **2nd part** we need to add a \\u201C.\\u201D if remainder is not zero and then make the remainder 10 times everytime and append the quotient to the ans string.\\n```\\n//Code:\\nwhile(r != 0)\\n\\tr *= 10;\\n\\tq = r / den;\\n\\tr = r % den;\\n\\tans += q;\\n```\\n\\nFor the **3rd part** we need to use and unordered_map so that we can store the the position from where the repeating of number starts in front of the remainder. If the remainder is already in the map then we insert the \\u201C(\\u201D opening bracket at the position of that rem and lastly append a \\u201C)\\u201D closing bracket and break out of the loop and return the ans.\\n```\\n//Code :\\nunordered_map<int, int> mp;\\nwhile(r != 0)\\n\\tif(mp(r) is in map)\\n\\t\\tint pos = mp[r];\\n\\t\\tans.insert(pos, \"(\");\\n\\t\\tans += \\')\\';\\n\\t\\tbreak;\\n\\telse\\n\\t\\tmp[r] = ans.length();\\n\\t\\tr *= 10;\\n\\t\\tq = r / den;\\n\\t\\tr = r % den;\\n\\t\\tans += q;\\n```\\n\\nNow it will give runtime error for cases like -1 / -2147483648 so we need to change the int to long\\n```\\nlong num = labs(numerator), den = labs(denominator);\\nlong q = num / den;\\nlong r = num % den;\\n```\\nand \\n```\\nunordered_map<long, int> mp;\\n```\\nWe need to handle the case where there are negative numbers. So if numerator is negative and denominator is positive or numerator is positive and denominator is negative we need to add a \\u201C-\\u201C negative symbol in the ans.\\n```\\nif (numerator > 0 ^ denominator > 0) \\n\\tans += \\'-\\';\\n```\\n\\n**Final Code :**\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(!numerator) return \"0\";\\n        string ans = \"\";\\n        if (numerator > 0 ^ denominator > 0) ans += \\'-\\';\\n        long num = labs(numerator), den = labs(denominator);\\n        long q = num / den;\\n        long r = num % den;\\n        ans += to_string(q);\\n        \\n        if(r == 0) return ans;\\n        \\n        ans += \\'.\\';\\n        unordered_map<long, int> mp;\\n        while(r != 0){\\n            if(mp.find(r) != mp.end()){\\n                int pos = mp[r];\\n                ans.insert(pos, \"(\");\\n                ans += \\')\\';\\n                break;\\n            }\\n            else{\\n                mp[r] = ans.length();\\n                r *= 10;\\n                q = r / den;\\n                r = r % den;\\n                ans += to_string(q);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\n//Code: \\nint q = num / den;\\nint r = num % den;\\nans += q;\\nif(r == 0) return ans;\\n```\n```\\n//Code:\\nwhile(r != 0)\\n\\tr *= 10;\\n\\tq = r / den;\\n\\tr = r % den;\\n\\tans += q;\\n```\n```\\n//Code :\\nunordered_map<int, int> mp;\\nwhile(r != 0)\\n\\tif(mp(r) is in map)\\n\\t\\tint pos = mp[r];\\n\\t\\tans.insert(pos, \"(\");\\n\\t\\tans += \\')\\';\\n\\t\\tbreak;\\n\\telse\\n\\t\\tmp[r] = ans.length();\\n\\t\\tr *= 10;\\n\\t\\tq = r / den;\\n\\t\\tr = r % den;\\n\\t\\tans += q;\\n```\n```\\nlong num = labs(numerator), den = labs(denominator);\\nlong q = num / den;\\nlong r = num % den;\\n```\n```\\nunordered_map<long, int> mp;\\n```\n```\\nif (numerator > 0 ^ denominator > 0) \\n\\tans += \\'-\\';\\n```\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(!numerator) return \"0\";\\n        string ans = \"\";\\n        if (numerator > 0 ^ denominator > 0) ans += \\'-\\';\\n        long num = labs(numerator), den = labs(denominator);\\n        long q = num / den;\\n        long r = num % den;\\n        ans += to_string(q);\\n        \\n        if(r == 0) return ans;\\n        \\n        ans += \\'.\\';\\n        unordered_map<long, int> mp;\\n        while(r != 0){\\n            if(mp.find(r) != mp.end()){\\n                int pos = mp[r];\\n                ans.insert(pos, \"(\");\\n                ans += \\')\\';\\n                break;\\n            }\\n            else{\\n                mp[r] = ans.length();\\n                r *= 10;\\n                q = r / den;\\n                r = r % den;\\n                ans += to_string(q);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51107,
                "title": "accepted-clean-java-solution",
                "content": "I don't understand why so many people tends to write \"short\" java solutions over \"clear\" java solution when performance stays the same.\\nIn order to be a good teammate, one should always write clean code instead of hacky code if performance stays the same.\\n\\n        \\n      public String fractionToDecimal(int numerator, int denominator) {\\n            boolean isNegative = (numerator < 0 && denominator > 0 || numerator > 0 && denominator < 0) ? true : false;\\n            long numeratorL = Math.abs((long) numerator);\\n            long denominatorL = Math.abs((long) denominator);\\n            Map<Long, Integer> previousRemains = new HashMap<Long, Integer>();\\n            StringBuilder sb = new StringBuilder();\\n            long quotian = numeratorL / denominatorL;\\n            sb.append(quotian);\\n            \\n            numeratorL %= denominatorL;\\n        \\n            if (numeratorL != 0) {\\n                sb.append(\".\");\\n            }\\n            \\n            int quotianIndex = 0;\\n            while (numeratorL != 0) {\\n                numeratorL *= 10;\\n                quotian = Math.abs(numeratorL / denominatorL);\\n                if (!previousRemains.containsKey(numeratorL)) {\\n                    sb.append(quotian);\\n                    previousRemains.put(numeratorL, quotianIndex++);\\n                } else {\\n                    int firstIndex = 1 + previousRemains.get(numeratorL) + sb.indexOf(\".\");\\n                    sb.insert(firstIndex, '(');\\n                    sb.append(\")\");\\n                    break;\\n                }\\n                numeratorL %= denominatorL;\\n            }\\n            \\n            if (isNegative) {\\n                sb.insert(0, \"-\");\\n            }\\n            return sb.toString();\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "I don't understand why so many people tends to write \"short\" java solutions over \"clear\" java solution when performance stays the same.\\nIn order to be a good teammate, one should always write clean code instead of hacky code if performance stays the same.\\n\\n        \\n      public String fractionToDecimal(int numerator, int denominator) {\\n            boolean isNegative = (numerator < 0 && denominator > 0 || numerator > 0 && denominator < 0) ? true : false;\\n            long numeratorL = Math.abs((long) numerator);\\n            long denominatorL = Math.abs((long) denominator);\\n            Map<Long, Integer> previousRemains = new HashMap<Long, Integer>();\\n            StringBuilder sb = new StringBuilder();\\n            long quotian = numeratorL / denominatorL;\\n            sb.append(quotian);\\n            \\n            numeratorL %= denominatorL;\\n        \\n            if (numeratorL != 0) {\\n                sb.append(\".\");\\n            }\\n            \\n            int quotianIndex = 0;\\n            while (numeratorL != 0) {\\n                numeratorL *= 10;\\n                quotian = Math.abs(numeratorL / denominatorL);\\n                if (!previousRemains.containsKey(numeratorL)) {\\n                    sb.append(quotian);\\n                    previousRemains.put(numeratorL, quotianIndex++);\\n                } else {\\n                    int firstIndex = 1 + previousRemains.get(numeratorL) + sb.indexOf(\".\");\\n                    sb.insert(firstIndex, '(');\\n                    sb.append(\")\");\\n                    break;\\n                }\\n                numeratorL %= denominatorL;\\n            }\\n            \\n            if (isNegative) {\\n                sb.insert(0, \"-\");\\n            }\\n            return sb.toString();\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 51114,
                "title": "python-solution",
                "content": "    class Solution:\\n    # @return a string\\n    def fractionToDecimal(self, numerator, denominator):\\n        res=\"\"\\n        if numerator/denominator<0:\\n            res+=\"-\"\\n        if numerator%denominator==0:\\n            return str(numerator/denominator)\\n        numerator=abs(numerator)\\n        denominator=abs(denominator)\\n        res+=str(numerator/denominator)\\n        res+=\".\"\\n        numerator%=denominator\\n        i=len(res)\\n        table={}\\n        while numerator!=0:\\n            if numerator not in table.keys():\\n                table[numerator]=i\\n            else:\\n                i=table[numerator]\\n                res=res[:i]+\"(\"+res[i:]+\")\"\\n                return res\\n            numerator=numerator*10\\n            res+=str(numerator/denominator)\\n            numerator%=denominator\\n            i+=1\\n        return res\\n\\nIdea is to put every remainder into the hash table as a key, and the current length of the result string as the value. When the same remainder shows again, it's circulating from the index of the value in the table.",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    # @return a string\\n    def fractionToDecimal(self, numerator, denominator):\\n        res=\"\"\\n        if numerator/denominator<0:\\n            res+=\"-\"\\n        if numerator%denominator==0:\\n            return str(numerator/denominator)\\n        numerator=abs(numerator)\\n        denominator=abs(denominator)\\n        res+=str(numerator/denominator)\\n        res+=\".\"\\n        numerator%=denominator\\n        i=len(res)\\n        table={}",
                "codeTag": "Java"
            },
            {
                "id": 180004,
                "title": "python-4-lines-32ms-beats-100-with-explanation",
                "content": "LOLOLOL:\\n```python\\ndef fractionToDecimal(self, n, d): # 32ms, beats 100%\\n    if n % d == 0: return str(n // d)\\n    p, q, r, s, m = abs(n), abs(d), abs(n) % abs(d), \\'\\', {}\\n    while r and r not in m: m[r], r, s = len(s), r * 10 % q, s + str(r * 10 // q)\\n    return (\\'\\' if (n > 0) == (d > 0) else \\'-\\') + str(p // q) + \\'.\\' + (s[:m[r]] + \\'(\\' + s[m[r]:] + \\')\\' if r else s)\\n```\\n---\\n\\n### Explanation\\nMy original solution:\\n```python\\ndef fractionToDecimal(self, numerator, denominator):\\n    if numerator % denominator == 0: return str(numerator // denominator)\\n    p, q = map(abs, (numerator, denominator))\\n    prefix = (\\'\\' if (numerator > 0) == (denominator > 0) else \\'-\\') + str(p // q) + \\'.\\' # everything before the decimal point\\n    suffix = \\'\\' # everything after the decimal point\\n    remainder = p % q\\n    index = {}\\n    while remainder not in index: # search for recurrence\\n        index[remainder] = len(suffix)\\n        suffix += str(remainder * 10 // q)\\n        remainder = remainder * 10 % q\\n        if remainder == 0: return prefix + suffix # no recurring decimal\\n    return prefix + suffix[:index[remainder]] + \\'(\\' + suffix[index[remainder]:] + \\')\\'\\n```\\nThis is easy to understand by following an example. Consider the fraction `611/4950 == 0.12(34)`. If you work out the division, you\\'ll see that the remainders are `611`, `1160`, `1700`, `2150`, `1700`, `2150`, etc.\\n```\\n      0.123434...\\n    +---------\\n4950|611\\n       0\\n     ---------\\n     6110      <- remainder is 611\\n     4950\\n     ---------\\n     11600     <- remainder is 1160\\n      9900\\n     ---------\\n      17000    <- remainder is 1700\\n      14850\\n     ---------\\n       21500   <- remainder is 2150\\n       19800\\n     ---------\\n        17000  <- remainder is 1700\\n        14850\\n     ---------\\n         21500 <- remainder is 2150\\n         19800\\n     ---------\\n          1700 <- remainder is 1700\\n           ...\\n```\\nSo we just have to keep track of the remainders. The moment we see a repeated one (`1700` in this example), we stop and ask \"when was the first time I saw this remainder?\" For this particular example, the answer is \"when I was trying to find the `3rd` decimal place\". Therefore, the recurrence starts from the `3rd` decimal place. That\\'s it.",
                "solutionTags": [],
                "code": "```python\\ndef fractionToDecimal(self, n, d): # 32ms, beats 100%\\n    if n % d == 0: return str(n // d)\\n    p, q, r, s, m = abs(n), abs(d), abs(n) % abs(d), \\'\\', {}\\n    while r and r not in m: m[r], r, s = len(s), r * 10 % q, s + str(r * 10 // q)\\n    return (\\'\\' if (n > 0) == (d > 0) else \\'-\\') + str(p // q) + \\'.\\' + (s[:m[r]] + \\'(\\' + s[m[r]:] + \\')\\' if r else s)\\n```\n```python\\ndef fractionToDecimal(self, numerator, denominator):\\n    if numerator % denominator == 0: return str(numerator // denominator)\\n    p, q = map(abs, (numerator, denominator))\\n    prefix = (\\'\\' if (numerator > 0) == (denominator > 0) else \\'-\\') + str(p // q) + \\'.\\' # everything before the decimal point\\n    suffix = \\'\\' # everything after the decimal point\\n    remainder = p % q\\n    index = {}\\n    while remainder not in index: # search for recurrence\\n        index[remainder] = len(suffix)\\n        suffix += str(remainder * 10 // q)\\n        remainder = remainder * 10 % q\\n        if remainder == 0: return prefix + suffix # no recurring decimal\\n    return prefix + suffix[:index[remainder]] + \\'(\\' + suffix[index[remainder]:] + \\')\\'\\n```\n```\\n      0.123434...\\n    +---------\\n4950|611\\n       0\\n     ---------\\n     6110      <- remainder is 611\\n     4950\\n     ---------\\n     11600     <- remainder is 1160\\n      9900\\n     ---------\\n      17000    <- remainder is 1700\\n      14850\\n     ---------\\n       21500   <- remainder is 2150\\n       19800\\n     ---------\\n        17000  <- remainder is 1700\\n        14850\\n     ---------\\n         21500 <- remainder is 2150\\n         19800\\n     ---------\\n          1700 <- remainder is 1700\\n           ...\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 51128,
                "title": "simple-and-short-solution-in-java",
                "content": "    public String fractionToDecimal(int numerator, int denominator) {\\n        if (denominator == 0) return \"\";\\n        StringBuilder str = new StringBuilder();\\n        HashMap<Long, Integer> map = new HashMap<Long, Integer>();\\n        if (numerator < 0 && denominator > 0 || numerator > 0 && denominator < 0) {\\n            str.append('-');\\n        }\\n        long num = Math.abs((long)numerator);\\n        long den = Math.abs((long)denominator);\\n        long n = num/den;\\n        long reminder = num % den;\\n        str.append(n);\\n        if (reminder == 0) return str.toString();\\n        else str.append('.');\\n        while(!map.containsKey(reminder)) {\\n            map.put(reminder,str.length());\\n            n = reminder*10/den;\\n            reminder = reminder*10%den;\\n            if (reminder != 0 || reminder == 0 && !map.containsKey(reminder)) {\\n                str.append(n);\\n            }\\n        }\\n        if (reminder != 0) {\\n            str.insert(map.get(reminder),\"(\");\\n            str.append(')');            \\n        }\\n        return str.toString();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String fractionToDecimal(int numerator, int denominator) {\\n        if (denominator == 0) return \"\";\\n        StringBuilder str = new StringBuilder();\\n        HashMap<Long, Integer> map = new HashMap<Long, Integer>();\\n        if (numerator < 0 && denominator > 0 || numerator > 0 && denominator < 0) {\\n            str.append('-');\\n        }\\n        long num = Math.abs((long)numerator);\\n        long den = Math.abs((long)denominator);\\n        long n = num/den;\\n        long reminder = num % den;\\n        str.append(n);\\n        if (reminder == 0) return str.toString();\\n        else str.append('.');\\n        while(!map.containsKey(reminder)) {\\n            map.put(reminder,str.length());\\n            n = reminder*10/den;\\n            reminder = reminder*10%den;\\n            if (reminder != 0 || reminder == 0 && !map.containsKey(reminder)) {\\n                str.append(n);\\n            }\\n        }\\n        if (reminder != 0) {\\n            str.insert(map.get(reminder),\"(\");\\n            str.append(')');            \\n        }\\n        return str.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 457990,
                "title": "java-a-simple-solution-with-explanation",
                "content": "```\\npublic String fractionToDecimal(int num, int den) {\\n        \\n\\tif(num==0) return \"0\";\\n\\n\\tStringBuilder res = new StringBuilder();\\n\\n\\t// Negative sign is appended if either of num or den is negative\\n\\tres.append((num > 0) ^ (den > 0) ? \"-\" : \"\");\\n\\n\\t// Get rid of signs and convert to long to prevent overflow\\n\\tlong n = Math.abs((long) num);\\n\\tlong d = Math.abs((long) den);\\n\\n\\t// Append the integral part\\n\\tres.append(n/d);\\n\\n\\tn %= d;\\n\\tif(n==0) return res.toString();             // Cause there is no fraction\\n\\n\\t// Append the fraction\\n\\tres.append(\".\");\\n\\tHashMap<Long, Integer> hm = new HashMap();  // Map will store remainders and their positions\\n\\thm.put(n, res.length());\\n\\twhile(n!=0) {                               // We will break in case of recurring fraction\\n\\t\\tn *= 10;\\n\\t\\tres.append(n/d);\\n\\t\\tn %= d;\\n\\n\\t\\tInteger remainderIndex = hm.get(n);\\n\\t\\tif(remainderIndex!=null) {              // We have a recurrence\\n\\t\\t\\tres.insert(remainderIndex, \"(\");\\n\\t\\t\\tres.append(\")\");\\n\\t\\t\\treturn res.toString();\\n\\t\\t} else {\\n\\t\\t\\thm.put(n, res.length());            // Add for future checks\\n\\t\\t}\\n\\t}\\n\\treturn res.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String fractionToDecimal(int num, int den) {\\n        \\n\\tif(num==0) return \"0\";\\n\\n\\tStringBuilder res = new StringBuilder();\\n\\n\\t// Negative sign is appended if either of num or den is negative\\n\\tres.append((num > 0) ^ (den > 0) ? \"-\" : \"\");\\n\\n\\t// Get rid of signs and convert to long to prevent overflow\\n\\tlong n = Math.abs((long) num);\\n\\tlong d = Math.abs((long) den);\\n\\n\\t// Append the integral part\\n\\tres.append(n/d);\\n\\n\\tn %= d;\\n\\tif(n==0) return res.toString();             // Cause there is no fraction\\n\\n\\t// Append the fraction\\n\\tres.append(\".\");\\n\\tHashMap<Long, Integer> hm = new HashMap();  // Map will store remainders and their positions\\n\\thm.put(n, res.length());\\n\\twhile(n!=0) {                               // We will break in case of recurring fraction\\n\\t\\tn *= 10;\\n\\t\\tres.append(n/d);\\n\\t\\tn %= d;\\n\\n\\t\\tInteger remainderIndex = hm.get(n);\\n\\t\\tif(remainderIndex!=null) {              // We have a recurrence\\n\\t\\t\\tres.insert(remainderIndex, \"(\");\\n\\t\\t\\tres.append(\")\");\\n\\t\\t\\treturn res.toString();\\n\\t\\t} else {\\n\\t\\t\\thm.put(n, res.length());            // Add for future checks\\n\\t\\t}\\n\\t}\\n\\treturn res.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51186,
                "title": "fast-and-concise-python-solution-using-dictionary",
                "content": "    def fractionToDecimal(self, numerator, denominator):\\n        sign = '-' if numerator * denominator < 0 else ''\\n        head, remainder = divmod(abs(numerator), abs(denominator))\\n        tail, seen = '', {}\\n        while remainder != 0:\\n            if remainder in seen:\\n                tail = tail[: seen[remainder]] + '(' + tail[seen[remainder]:] + ')'\\n                break\\n            seen[remainder] = len(tail)\\n            digit, remainder = divmod( remainder*10, abs(denominator) )\\n            tail+=str(digit)\\n        return sign + str(head) + (tail and '.' + tail)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def fractionToDecimal(self, numerator, denominator):\\n        sign = '-' if numerator * denominator < 0 else ''\\n        head, remainder = divmod(abs(numerator), abs(denominator))\\n        tail, seen = '', {}\\n        while remainder != 0:\\n            if remainder in seen:\\n                tail = tail[: seen[remainder]] + '(' + tail[seen[remainder]:] + ')'\\n                break\\n            seen[remainder] = len(tail)\\n            digit, remainder = divmod( remainder*10, abs(denominator) )\\n            tail+=str(digit)\\n        return sign + str(head) + (tail and '.' + tail)",
                "codeTag": "Python3"
            },
            {
                "id": 157398,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator, denominator):\\n        if numerator == 0: \\n            return \\'0\\'\\n        neg = (numerator < 0) ^ (denominator < 0)\\n        w,r = divmod(abs(numerator),abs(denominator))\\n        s = str(w)\\n        if neg:\\n            s = \"-\" + s \\n        if r:\\n            s += \\'.\\'\\n        i = len(s)\\n        nums = { r: i }\\n        while r:\\n            q,r = divmod(r * 10, abs(denominator))\\n            s += str(q)\\n            if r in nums:\\n                s = s[:nums[r]] + \\'(\\' + s[nums[r]:] + \\')\\' \\n                return s\\n            i += 1\\n            nums[r] = i\\n        return s",
                "solutionTags": [],
                "code": "class Solution:\\n    def fractionToDecimal(self, numerator, denominator):\\n        if numerator == 0: \\n            return \\'0\\'\\n        neg = (numerator < 0) ^ (denominator < 0)\\n        w,r = divmod(abs(numerator),abs(denominator))\\n        s = str(w)\\n        if neg:\\n            s = \"-\" + s \\n        if r:\\n            s += \\'.\\'\\n        i = len(s)\\n        nums = { r: i }",
                "codeTag": "Java"
            },
            {
                "id": 2549071,
                "title": "c-handling-edge-cases-easily-with-full-explanation-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d) {\\n     \\n        string ans = \"\";\\n       \\n        \\n        // Handling Negative Case\\n        if((n<0 && d>0) || (n>0 && d<0 ))\\n            ans+= \\'-\\';\\n        \\n        // To avoid Edge Cases Mentioned Below store Numerator and Denominator\\n        // in Long long datatype ans remainder as well\\n        \\n        long long a = abs(n);\\n        long long b = abs(d);\\n        \\n        // Calculation Integral Part Of Answer\\n        long long num = abs(a/b);\\n        \\n        // Storing that to our ans string\\n        ans += to_string(num);\\n        \\n        // Calculate Remainder\\n        long long rem = abs(a%b);\\n        \\n        \\n        // IF remainder is zero , there wont be decimal part so return ans\\n        if(rem == 0)\\n            return ans;\\n        \\n        ans.push_back(\\'.\\');\\n        \\n        // Now We will calculate decimal part\\n        // we will store mapping of remainder with its appearing index \\n        // ex : 1/10 => rem = 1 its index will be 0\\n        \\n        string dec = \"\";\\n        unordered_map<int, int> mp;\\n       \\n        \\n        while(rem)\\n        {\\n            // iF We come across any remainder which is present in mapping \\n            // it means the recurring part start from that remainder and we will get its index \\n            // and process the result\\n            if(mp.find(rem) != mp.end())\\n            {\\n                int index  = mp[rem];\\n                string recurring = dec.substr(index);\\n                dec.erase(index);\\n                dec += \\'(\\' + recurring + \\')\\';\\n                break;\\n            }\\n            // If Remainder dont exist in map we will continue dividing and storing next remainder till it becomes zero\\n            else\\n            {\\n                mp[rem] = dec.size();\\n                dec += to_string(rem*10/b);\\n                rem = (rem*10)%b;\\n            }\\n        }\\n        \\n        ans += dec;\\n        return ans;\\n        \\n        \\n        // Pls Upvote If You Like It\\n    }\\n};\\n\\n// Some Good Test Cases\\n// 4\\n// 333\\n\\n// -1\\n// -2147483648\\n\\n// 1\\n// 17\\n\\n// 45\\n// 499\\n\\n// -2147483648\\n// -1\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d) {\\n     \\n        string ans = \"\";\\n       \\n        \\n        // Handling Negative Case\\n        if((n<0 && d>0) || (n>0 && d<0 ))\\n            ans+= \\'-\\';\\n        \\n        // To avoid Edge Cases Mentioned Below store Numerator and Denominator\\n        // in Long long datatype ans remainder as well\\n        \\n        long long a = abs(n);\\n        long long b = abs(d);\\n        \\n        // Calculation Integral Part Of Answer\\n        long long num = abs(a/b);\\n        \\n        // Storing that to our ans string\\n        ans += to_string(num);\\n        \\n        // Calculate Remainder\\n        long long rem = abs(a%b);\\n        \\n        \\n        // IF remainder is zero , there wont be decimal part so return ans\\n        if(rem == 0)\\n            return ans;\\n        \\n        ans.push_back(\\'.\\');\\n        \\n        // Now We will calculate decimal part\\n        // we will store mapping of remainder with its appearing index \\n        // ex : 1/10 => rem = 1 its index will be 0\\n        \\n        string dec = \"\";\\n        unordered_map<int, int> mp;\\n       \\n        \\n        while(rem)\\n        {\\n            // iF We come across any remainder which is present in mapping \\n            // it means the recurring part start from that remainder and we will get its index \\n            // and process the result\\n            if(mp.find(rem) != mp.end())\\n            {\\n                int index  = mp[rem];\\n                string recurring = dec.substr(index);\\n                dec.erase(index);\\n                dec += \\'(\\' + recurring + \\')\\';\\n                break;\\n            }\\n            // If Remainder dont exist in map we will continue dividing and storing next remainder till it becomes zero\\n            else\\n            {\\n                mp[rem] = dec.size();\\n                dec += to_string(rem*10/b);\\n                rem = (rem*10)%b;\\n            }\\n        }\\n        \\n        ans += dec;\\n        return ans;\\n        \\n        \\n        // Pls Upvote If You Like It\\n    }\\n};\\n\\n// Some Good Test Cases\\n// 4\\n// 333\\n\\n// -1\\n// -2147483648\\n\\n// 1\\n// 17\\n\\n// 45\\n// 499\\n\\n// -2147483648\\n// -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208837,
                "title": "166-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution also handles the edge cases of a zero numerator and a zero denominator, and also checks for the negative sign at the beginning. It then calculates the integer part of the result by doing an integer division of the numerator by the denominator, and checks if there is a fractional part by checking if the remainder of this division is zero. If there is a fractional part, it adds a decimal point to the result.\\n\\nThe main optimization in this solution is the use of a dictionary to store the position of each remainder in the result. This way, we can easily check if a remainder has already appeared in the result, and if it has, we know that we have found a repeating part. We can then insert the opening and closing parentheses at the appropriate positions in the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # Handle edge cases\\n        if numerator == 0:\\n            return \"0\"\\n        if denominator == 0:\\n            return \"\"\\n\\n        # Initialize result and check for negative sign\\n        result = \"\"\\n        if (numerator < 0) ^ (denominator < 0):\\n            result += \"-\"\\n        numerator, denominator = abs(numerator), abs(denominator)\\n\\n        # Integer part of the result\\n        result += str(numerator // denominator)\\n\\n        # Check if there is a fractional part\\n        if numerator % denominator == 0:\\n            return result\\n\\n        result += \".\"\\n\\n        # Use a dictionary to store the position of each remainder\\n        remainder_dict = {}\\n        remainder = numerator % denominator\\n\\n        # Keep adding the remainder to the result until it repeats or the remainder becomes 0\\n        while remainder != 0 and remainder not in remainder_dict:\\n            remainder_dict[remainder] = len(result)\\n            remainder *= 10\\n            result += str(remainder // denominator)\\n            remainder %= denominator\\n\\n        # Check if there is a repeating part\\n        if remainder in remainder_dict:\\n            result = result[:remainder_dict[remainder]] + \"(\" + result[remainder_dict[remainder]:] + \")\"\\n\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # Handle edge cases\\n        if numerator == 0:\\n            return \"0\"\\n        if denominator == 0:\\n            return \"\"\\n\\n        # Initialize result and check for negative sign\\n        result = \"\"\\n        if (numerator < 0) ^ (denominator < 0):\\n            result += \"-\"\\n        numerator, denominator = abs(numerator), abs(denominator)\\n\\n        # Integer part of the result\\n        result += str(numerator // denominator)\\n\\n        # Check if there is a fractional part\\n        if numerator % denominator == 0:\\n            return result\\n\\n        result += \".\"\\n\\n        # Use a dictionary to store the position of each remainder\\n        remainder_dict = {}\\n        remainder = numerator % denominator\\n\\n        # Keep adding the remainder to the result until it repeats or the remainder becomes 0\\n        while remainder != 0 and remainder not in remainder_dict:\\n            remainder_dict[remainder] = len(result)\\n            remainder *= 10\\n            result += str(remainder // denominator)\\n            remainder %= denominator\\n\\n        # Check if there is a repeating part\\n        if remainder in remainder_dict:\\n            result = result[:remainder_dict[remainder]] + \"(\" + result[remainder_dict[remainder]:] + \")\"\\n\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163728,
                "title": "swift-fraction-to-recurring-decimal",
                "content": "```swift\\nclass Solution {\\n    func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String {\\n        var num = numerator, den = denominator\\n        var result = [String]()\\n        \\n        guard num != 0 else { return \"0\" }\\n        \\n        if (num > 0 && den < 0) || (num < 0 && den > 0) {\\n            result.append(\"-\")\\n        }\\n        \\n        num = abs(num)\\n        den = abs(den)\\n        \\n        result.append(String(num/den))\\n        num %= den\\n        \\n        guard num != 0 else { return result.joined() }\\n        \\n        result.append(\".\")\\n        var map = [Int:Int]()\\n        map[num] = result.count\\n        \\n        while num != 0 {\\n            num *= 10\\n            result.append(String(num / den))\\n            num %= den\\n            if let value = map[num] {\\n                let index = value\\n                result.insert(\"(\", at: index)\\n                result.append(\")\")\\n                break\\n            } else {\\n                map[num] = result.count\\n            }\\n        }\\n        return result.joined()\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 5 tests, with 0 failures (0 unexpected) in 0.081 (0.083) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func testExample1() {\\n        XCTAssert(s.fractionToDecimal(1, 2) == \"0.5\") // success\\n    }\\n    func testExample2() {\\n        XCTAssert(s.fractionToDecimal(2, 1) == \"2\") // success\\n    }\\n    func testExample3() {\\n        XCTAssert(s.fractionToDecimal(2, 3) == \"0.(6)\") // success\\n    }\\n    func testExample4() {\\n        XCTAssert(s.fractionToDecimal(4, 333) == \"0.(012)\") // success\\n    }\\n    func testExample5() {\\n        XCTAssert(s.fractionToDecimal(1, 5) == \"0.2\") // success\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String {\\n        var num = numerator, den = denominator\\n        var result = [String]()\\n        \\n        guard num != 0 else { return \"0\" }\\n        \\n        if (num > 0 && den < 0) || (num < 0 && den > 0) {\\n            result.append(\"-\")\\n        }\\n        \\n        num = abs(num)\\n        den = abs(den)\\n        \\n        result.append(String(num/den))\\n        num %= den\\n        \\n        guard num != 0 else { return result.joined() }\\n        \\n        result.append(\".\")\\n        var map = [Int:Int]()\\n        map[num] = result.count\\n        \\n        while num != 0 {\\n            num *= 10\\n            result.append(String(num / den))\\n            num %= den\\n            if let value = map[num] {\\n                let index = value\\n                result.insert(\"(\", at: index)\\n                result.append(\")\")\\n                break\\n            } else {\\n                map[num] = result.count\\n            }\\n        }\\n        return result.joined()\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 5 tests, with 0 failures (0 unexpected) in 0.081 (0.083) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func testExample1() {\\n        XCTAssert(s.fractionToDecimal(1, 2) == \"0.5\") // success\\n    }\\n    func testExample2() {\\n        XCTAssert(s.fractionToDecimal(2, 1) == \"2\") // success\\n    }\\n    func testExample3() {\\n        XCTAssert(s.fractionToDecimal(2, 3) == \"0.(6)\") // success\\n    }\\n    func testExample4() {\\n        XCTAssert(s.fractionToDecimal(4, 333) == \"0.(012)\") // success\\n    }\\n    func testExample5() {\\n        XCTAssert(s.fractionToDecimal(1, 5) == \"0.2\") // success\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262401,
                "title": "c-very-easy-to-understand-100-beat",
                "content": "The problem is quiet straight forward except few cases.\\n*Steps:*\\n1. First decide the **sign** of output as (num/den) can be positive or negative as well.\\n2. Divide is **numerator** by **denominator**, check whether **remainder** exist or not\\n3. If *remainder* does exists and equal to ``0``, then simply return, as we have divided num by den.\\n4. Else divide till *remainder* is ``0`` and **repeat** exists.\\n\\t a. Check whether *remainder* will repeat after some time of division.\\n\\t b. If *remainder* repeats, then it\\'s guaranteed that next number will again repeat, then simply put braces at the end ``)`` and since we need to see previous tracked *remainders*, we have to use **hash-table** for *constant time operation*, then we also the **first** occurance of *remainder*, then simply get the position and insert the ``(`` bracket.\\n\\t c. Else if **remainder** do not repeat, then it has to converge to ``0``. Once it\\'s ``0`` we are out of loop and simply return the output.\\n\\t \\n\\t *Below is implementation of above algorithm*\\n\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int num, int den) {\\n        bool neg = (num<0)^(den<0) ? true: false;\\n        long long int n = num;\\n        long long int d = den;\\n        n = abs(n);\\n        d = abs(d);\\n        long long int tmp = n/d;\\n        string res = \"\";\\n        if(neg && n!=0)\\n         res += \"-\";\\n\\n        res += to_string(tmp);\\n        n %= d;\\n        if(n==0){\\n            return res;\\n        }\\n        res += \".\";\\n        // now before decimal, work is over now after decimal\\n        bool repeat = false;\\n        unordered_map<long long int, int> mp; // mapping from remainder to size of string\\n        while(n!=0 && !repeat){\\n            if(mp.find(n)==mp.end())\\n                mp[n] = res.size();\\n            else if(mp.find(n)!=mp.end()){\\n                // repeat found\\n                repeat = true; // no need of repeat variable as we are breaking explicitly\\n                res.push_back(\\')\\');\\n                res.insert(mp[n],\"(\");\\n                break;\\n            }\\n            n = n*10;\\n            res += to_string(n/d);\\n            n %= d;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nNote: pardon my English\\nHappy Coding.",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int num, int den) {\\n        bool neg = (num<0)^(den<0) ? true: false;\\n        long long int n = num;\\n        long long int d = den;\\n        n = abs(n);\\n        d = abs(d);\\n        long long int tmp = n/d;\\n        string res = \"\";\\n        if(neg && n!=0)\\n         res += \"-\";\\n\\n        res += to_string(tmp);\\n        n %= d;\\n        if(n==0){\\n            return res;\\n        }\\n        res += \".\";\\n        // now before decimal, work is over now after decimal\\n        bool repeat = false;\\n        unordered_map<long long int, int> mp; // mapping from remainder to size of string\\n        while(n!=0 && !repeat){\\n            if(mp.find(n)==mp.end())\\n                mp[n] = res.size();\\n            else if(mp.find(n)!=mp.end()){\\n                // repeat found\\n                repeat = true; // no need of repeat variable as we are breaking explicitly\\n                res.push_back(\\')\\');\\n                res.insert(mp[n],\"(\");\\n                break;\\n            }\\n            n = n*10;\\n            res += to_string(n/d);\\n            n %= d;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 411727,
                "title": "c-solution-0ms-beats-100-concise-code",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Fraction to Recurring Decimal.\\nMemory Usage: 9 MB, less than 73.33% of C++ online submissions for Fraction to Recurring Decimal.\\n\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int nu, int de) {\\n        \\n        if (nu == 0)  return \"0\";\\n        string res;\\n        unordered_map<long long int, int> mp;\\n        bool flag = ((nu < 0 && de >= 0) || (nu >= 0 && de < 0));\\n        long long numerator = nu;\\n        long long denominator = de;\\n        numerator = abs(numerator);\\n        denominator = abs(denominator);\\n        \\n        long long dividend = numerator/denominator;\\n        long long rem = numerator%denominator;\\n        res = std::to_string(dividend);\\n        \\n        if(rem == 0)\\n            return (flag ? \\'-\\' + res : res);\\n        \\n        res.push_back(\\'.\\');\\n        while(rem != 0)\\n        {\\n            numerator = rem*10;\\n            if(mp.find(numerator) != mp.end())\\n            {\\n                int p = mp[numerator];\\n                res = res.substr(0,p) + \\'(\\' + res.substr(p) + \\')\\';\\n                break;\\n            }\\n            \\n            mp[numerator] = res.size();\\n            dividend = numerator/denominator;\\n            res.push_back(dividend+\\'0\\');\\n            rem = numerator%denominator;\\n        }\\n        \\n        if(flag)\\n            res.insert(res.begin(), \\'-\\');\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    string fractionToDecimal(int nu, int de) {\\n        \\n        if (nu == 0)  return \"0\";\\n        string res;\\n        unordered_map<long long int, int> mp;\\n        bool flag = ((nu < 0 && de >= 0) || (nu >= 0 && de < 0));\\n        long long numerator = nu;\\n        long long denominator = de;\\n        numerator = abs(numerator);\\n        denominator = abs(denominator);\\n        \\n        long long dividend = numerator/denominator;\\n        long long rem = numerator%denominator;\\n        res = std::to_string(dividend);\\n        \\n        if(rem == 0)\\n            return (flag ? \\'-\\' + res : res);\\n        \\n        res.push_back(\\'.\\');\\n        while(rem != 0)\\n        {\\n            numerator = rem*10;\\n            if(mp.find(numerator) != mp.end())\\n            {\\n                int p = mp[numerator];\\n                res = res.substr(0,p) + \\'(\\' + res.substr(p) + \\')\\';\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 51165,
                "title": "easy-to-understand-c-solution",
                "content": "    class Solution {\\n    public:\\n        string fractionToDecimal(int numerator, int denominator) {\\n            if(denominator == 0) return \"\";\\n            if(numerator == 0) return \"0\"; \\n            unordered_map<long, int> appeared;\\n            string ans;\\n            \\n            long p_int = abs((long)numerator / (long)denominator);\\n            ans += string((numerator < 0) ^ (denominator < 0), '-'); \\n            ans += to_string(p_int);\\n            long rem = abs((long)numerator % (long)denominator);\\n            if(rem == 0) return ans;\\n            ans += \".\";\\n            \\n            while(rem){\\n                appeared[rem] = ans.size();\\n                rem *= 10;\\n                ans += to_string(rem / abs((long)denominator));\\n                rem %= abs((long)denominator);\\n                if(appeared.find(rem) != appeared.end()){\\n                    ans.insert(appeared[rem], \"(\");\\n                    ans += \")\";\\n                    break;\\n                }\\n            }\\n            \\n            return ans;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string fractionToDecimal(int numerator, int denominator) {\\n            if(denominator == 0) return \"\";\\n            if(numerator == 0) return \"0\"; \\n            unordered_map<long, int> appeared;\\n            string ans;\\n            \\n            long p_int = abs((long)numerator / (long)denominator);\\n            ans += string((numerator < 0) ^ (denominator < 0), '-'); \\n            ans += to_string(p_int);\\n            long rem = abs((long)numerator % (long)denominator);\\n            if(rem == 0) return ans;\\n            ans += \".\";\\n            \\n            while(rem){\\n                appeared[rem] = ans.size();\\n                rem *= 10;\\n                ans += to_string(rem / abs((long)denominator));\\n                rem %= abs((long)denominator);\\n                if(appeared.find(rem) != appeared.end()){\\n                    ans.insert(appeared[rem], \"(\");\\n                    ans += \")\";\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 495542,
                "title": "python-long-divsion-solution",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0: return \\'0\\'\\n        \\n        result = []\\n        if numerator < 0 and denominator > 0 or numerator >= 0 and denominator < 0:\\n            result.append(\\'-\\')\\n        \\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        result.append(str(numerator // denominator))\\n        \\n        remainder = numerator % denominator\\n        \\n        if remainder == 0: return \\'\\'.join(result)\\n        result.append(\\'.\\')\\n        \\n        d = {}\\n        while remainder != 0:\\n            if remainder in d:\\n                result.insert(d[remainder], \\'(\\')\\n                result.append(\\')\\')\\n                return \\'\\'.join(result)\\n            \\n            d[remainder] = len(result)\\n            \\n            remainder *= 10\\n            result += str(remainder // denominator)\\n            remainder = remainder % denominator\\n        \\n        return \\'\\'.join(result)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0: return \\'0\\'\\n        \\n        result = []\\n        if numerator < 0 and denominator > 0 or numerator >= 0 and denominator < 0:\\n            result.append(\\'-\\')\\n        \\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        result.append(str(numerator // denominator))\\n        \\n        remainder = numerator % denominator\\n        \\n        if remainder == 0: return \\'\\'.join(result)\\n        result.append(\\'.\\')\\n        \\n        d = {}\\n        while remainder != 0:\\n            if remainder in d:\\n                result.insert(d[remainder], \\'(\\')\\n                result.append(\\')\\')\\n                return \\'\\'.join(result)\\n            \\n            d[remainder] = len(result)\\n            \\n            remainder *= 10\\n            result += str(remainder // denominator)\\n            remainder = remainder % denominator\\n        \\n        return \\'\\'.join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51131,
                "title": "an-intuitive-solution-in-c-beating-100-submissions-well-explained",
                "content": "Beating 100% submission, why? no one ever submitted the C version so far. Here is my solution:\\n\\n - determine the sign of the result;\\n - retrieve the integer part of the result - numerator/denominator;\\n - get all the decimals by the remainder -> numerator%denominator just as we do division in mathematics; but along with it we should record the remainder value and the corresponding string index collecting string (once we find the same remainder, we will know that we will run in a circle since the denominator is always the same, so then we have to <font color=\"#ff0000\">bracket the inner digits up</font>) and return;\\n\\n> B.T.W. there is a customised hash-map structure to store the remainder and the string index\\n\\nBang! End of story.\\n\\n----------\\n    \\n    #define LEN 10000\\n    struct MyListNode\\n    {\\n        long long key;\\n        int val;\\n        struct MyListNode *next;\\n    };\\n    \\n    void push(struct MyListNode* head, long long key, int val)\\n    {\\n        struct MyListNode *p = head;\\n        while(p->next)\\n            p = p->next;\\n        struct MyListNode *t = (struct MyListNode*)malloc(sizeof(struct MyListNode));\\n        t->key = key;\\n        t->val = val;\\n        p->next = t;\\n    }\\n    \\n    int pop(struct MyListNode* head, long long key)\\n    {\\n        struct MyListNode *p = head->next;\\n        while(p)\\n        {\\n            if(p->key == key)\\n                return p->val;\\n            p = p->next;\\n        }\\n        return 0;\\n    }\\n    \\n    char* fractionToDecimal(int n, int d)\\n    {\\n        if(n == 0) return \"0\";\\n        char *s = (char*)malloc(sizeof(char)*LEN);\\n        int index = 0;\\n        if((n<0 && d>0) || (n>0 && d<0)) s[index++] = '-'; //get the sign part;\\n        long long numerator = (n==INT_MIN)? -1*(long long)n : abs(n); //get the positive format of numerator;\\n        long long denominator = (d==INT_MIN)? -1*(long long)d : abs(d); //get the positive format of denominator;\\n        long long integer = numerator/denominator; //collecting the integer part;\\n        if(integer == 0)\\n            s[index++] = '0';\\n        else\\n        {\\n            char *t = (char*)malloc(sizeof(char)*LEN); //used to store the integer part in reverse order;\\n            int index0 = 0;\\n            while(integer)\\n            {\\n                t[index0++] = integer%10+'0';\\n                integer /= 10;\\n            }\\n            for(int i = index0-1; i > -1; i--) //reverse it again, then s will store the integer part in normal sequence;\\n                s[index++] = t[i];\\n        }\\n        long long remainder = numerator%denominator; //get the remainder by mod operator;\\n        if(remainder == 0) \\n        {\\n            s[index] = '\\\\0';\\n            return s;\\n        }\\n        s[index++] = '.'; //there are decimals;\\n        struct MyListNode *head = (struct MyListNode*)malloc(sizeof(struct MyListNode)); //used to store the remainder digit index in string for recurring;\\n        while(remainder)\\n        {\\n            int pre = pop(head, remainder);\\n            if(pre) //check if this digit has already occurred, if so, add brackets;\\n            {\\n                for(int i = index; i > pre; i--)\\n                    s[i] = s[i-1];\\n                index++;\\n                s[pre] = '(';\\n                s[index++] = ')';\\n                break;\\n            }\\n            push(head, remainder, index);\\n            remainder *= 10; //imitating division process here, retrieving the high decimal digit;\\n            s[index++] = remainder/denominator+'0';\\n            remainder %= denominator;\\n        }\\n        s[index] = '\\\\0';\\n        return s;\\n    }",
                "solutionTags": [],
                "code": "Beating 100% submission, why? no one ever submitted the C version so far. Here is my solution:\\n\\n - determine the sign of the result;\\n - retrieve the integer part of the result - numerator/denominator;\\n - get all the decimals by the remainder -> numerator%denominator just as we do division in mathematics; but along with it we should record the remainder value and the corresponding string index collecting string (once we find the same remainder, we will know that we will run in a circle since the denominator is always the same, so then we have to <font color=\"#ff0000\">bracket the inner digits up</font>) and return;\\n\\n> B.T.W. there is a customised hash-map structure to store the remainder and the string index\\n\\nBang! End of story.\\n\\n----------\\n    \\n    #define LEN 10000\\n    struct MyListNode\\n    {\\n        long long key;\\n        int val;\\n        struct MyListNode *next;\\n    };\\n    \\n    void push(struct MyListNode* head, long long key, int val)\\n    {\\n        struct MyListNode *p = head;\\n        while(p->next)\\n            p = p->next;\\n        struct MyListNode *t = (struct MyListNode*)malloc(sizeof(struct MyListNode));\\n        t->key = key;\\n        t->val = val;\\n        p->next = t;\\n    }\\n    \\n    int pop(struct MyListNode* head, long long key)\\n    {\\n        struct MyListNode *p = head->next;\\n        while(p)\\n        {\\n            if(p->key == key)\\n                return p->val;\\n            p = p->next;\\n        }\\n        return 0;\\n    }\\n    \\n    char* fractionToDecimal(int n, int d)\\n    {\\n        if(n == 0) return \"0\";\\n        char *s = (char*)malloc(sizeof(char)*LEN);\\n        int index = 0;\\n        if((n<0 && d>0) || (n>0 && d<0)) s[index++] = '-'; //get the sign part;\\n        long long numerator = (n==INT_MIN)? -1*(long long)n : abs(n); //get the positive format of numerator;\\n        long long denominator = (d==INT_MIN)? -1*(long long)d : abs(d); //get the positive format of denominator;\\n        long long integer = numerator/denominator; //collecting the integer part;\\n        if(integer == 0)\\n            s[index++] = '0';\\n        else\\n        {\\n            char *t = (char*)malloc(sizeof(char)*LEN); //used to store the integer part in reverse order;\\n            int index0 = 0;\\n            while(integer)\\n            {\\n                t[index0++] = integer%10+'0';\\n                integer /= 10;\\n            }\\n            for(int i = index0-1; i > -1; i--) //reverse it again, then s will store the integer part in normal sequence;\\n                s[index++] = t[i];\\n        }\\n        long long remainder = numerator%denominator; //get the remainder by mod operator;\\n        if(remainder == 0) \\n        {\\n            s[index] = '\\\\0';\\n            return s;\\n        }\\n        s[index++] = '.'; //there are decimals;\\n        struct MyListNode *head = (struct MyListNode*)malloc(sizeof(struct MyListNode)); //used to store the remainder digit index in string for recurring;\\n        while(remainder)\\n        {\\n            int pre = pop(head, remainder);\\n            if(pre) //check if this digit has already occurred, if so, add brackets;\\n            {\\n                for(int i = index; i > pre; i--)\\n                    s[i] = s[i-1];\\n                index++;\\n                s[pre] = '(';\\n                s[index++] = ')';\\n                break;\\n            }\\n            push(head, remainder, index);\\n            remainder *= 10; //imitating division process here, retrieving the high decimal digit;\\n            s[index++] = remainder/denominator+'0';\\n            remainder %= denominator;\\n        }\\n        s[index] = '\\\\0';\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1029272,
                "title": "javascript-solution",
                "content": "```javascript\\nvar fractionToDecimal = function(numerator, denominator) {\\n    if(!numerator) return \\'0\\';\\n    \\n    let str = \\'\\';\\n    \\n    if(Math.sign(numerator) !== Math.sign(denominator)) str += \\'-\\';\\n    \\n    const numer = Math.abs(numerator)\\n    const denom = Math.abs(denominator)\\n    \\n    str += Math.floor(numer/denom);\\n    let rem = numer%denom;\\n    if(!rem) return str;\\n    str += \\'.\\'\\n    \\n    const map = new Map();\\n    \\n    while(rem !== 0) {\\n        map.set(rem, str.length);\\n        \\n        rem *= 10;\\n        str += Math.floor(rem/denom);\\n        rem %= denom\\n        \\n        if(map.has(rem)) {\\n            const idx = map.get(rem);\\n            return str.slice(0, idx) + `(${str.slice(idx)})`; \\n        }\\n    }\\n    return str;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar fractionToDecimal = function(numerator, denominator) {\\n    if(!numerator) return \\'0\\';\\n    \\n    let str = \\'\\';\\n    \\n    if(Math.sign(numerator) !== Math.sign(denominator)) str += \\'-\\';\\n    \\n    const numer = Math.abs(numerator)\\n    const denom = Math.abs(denominator)\\n    \\n    str += Math.floor(numer/denom);\\n    let rem = numer%denom;\\n    if(!rem) return str;\\n    str += \\'.\\'\\n    \\n    const map = new Map();\\n    \\n    while(rem !== 0) {\\n        map.set(rem, str.length);\\n        \\n        rem *= 10;\\n        str += Math.floor(rem/denom);\\n        rem %= denom\\n        \\n        if(map.has(rem)) {\\n            const idx = map.get(rem);\\n            return str.slice(0, idx) + `(${str.slice(idx)})`; \\n        }\\n    }\\n    return str;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1988279,
                "title": "python-optimal-and-easy-solution-faster-than-95",
                "content": "```\\nclass Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        if numerator % denominator == 0:\\n            return str(numerator//denominator)\\n        sign = \\'\\' if numerator * denominator >= 0 else \\'-\\'\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        res = sign + str(numerator//denominator) + \\'.\\'\\n        numerator %= denominator\\n        i, part = 0, \\'\\'\\n        m = {numerator:i}\\n        while numerator % denominator:\\n            numerator *= 10\\n            i += 1\\n            rem = numerator % denominator\\n            part += str(numerator // denominator)\\n            if rem in m:\\n                part = part[:m[rem]]+\\'(\\'+part[m[rem]:]+\\')\\'\\n                return res + part\\n            m[rem] = i\\n            numerator = rem\\n        return res + part\\n```\\n\\n**Guys give it an upvote if you liked it, so it can help others :)**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        if numerator % denominator == 0:\\n            return str(numerator//denominator)\\n        sign = \\'\\' if numerator * denominator >= 0 else \\'-\\'\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        res = sign + str(numerator//denominator) + \\'.\\'\\n        numerator %= denominator\\n        i, part = 0, \\'\\'\\n        m = {numerator:i}\\n        while numerator % denominator:\\n            numerator *= 10\\n            i += 1\\n            rem = numerator % denominator\\n            part += str(numerator // denominator)\\n            if rem in m:\\n                part = part[:m[rem]]+\\'(\\'+part[m[rem]:]+\\')\\'\\n                return res + part\\n            m[rem] = i\\n            numerator = rem\\n        return res + part\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51205,
                "title": "a-clean-c-solution-with-3ms",
                "content": "    class Solution\\n    {\\n    public:\\n    \\tstring fractionToDecimal(int numerator, int denominator)\\n    \\t{\\n    \\t\\tif(0 == numerator) return \"0\";// If the numerator is 0, the final result must be 0.\\n    \\n    \\t\\tlong long num = numerator;// One of the test case is denominator = 0x80000000, thus we must save its opposite\\n    \\t\\tlong long den = denominator; // number in a long long variable.\\n    \\n    \\t\\tbool b1 = num < 0;\\n    \\t\\tbool b2 = den < 0;\\n    \\n    \\t\\tif(b1) num = - num;\\t// We convert both numerator and denominator into positive numbers.\\n    \\t\\tif(b2) den = -den;\\n    \\n    \\t\\tstring res = \"\";\\n    \\t\\tif(b1^b2) res += \"-\"; // Add a \"-\" if the numerator is positive and the denominator is negative or vice versa.\\n    \\n    \\t\\tlong long quo = num/den;\\n    \\t\\tlong long rem = num%den;\\n    \\n    \\t\\t//Calculate the integral part of the final result.\\n    \\t\\tif(quo > 0)\\n    \\t\\t{\\n    \\t\\t\\tostringstream oss;\\n    \\t\\t\\toss << quo;\\n    \\t\\t\\tres += oss.str();\\n    \\t\\t}\\n    \\t\\telse \\n    \\t\\t{\\n    \\t\\t\\tres += \"0\";\\n    \\t\\t}\\n    \\n    \\t\\tif(0 == rem) return res; // That the remainder is 0 means there isn't a fractional part of the result, \\n    \\t\\t//so we return the integral part.\\n    \\n    \\t\\t/*\\n    \\t\\tIn the following, we record the numerator to be divided by the denominator and the length of the temporary result.\\n    \\t\\tIf a numerator has been met before, circulation happens, so we stop the computation and insert a parathesis, and return \\n    \\t\\tthe result.\\n    \\t\\t*/\\n    \\t\\tnum = rem;\\n    \\n    \\t\\tunordered_map<long long, int> m;\\n    \\t\\tm[num] = res.size();\\n    \\n    \\t\\tnum *= 10;\\n    \\t\\tres.append(\".\");\\n    \\t\\tm[num] = res.size();\\n    \\n    \\t\\twhile(num > 0)\\n    \\t\\t{\\n    \\t\\t\\tif(num < den)\\n    \\t\\t\\t{// If the numerator is less than the denominator, we multiply the numerator with 10, and append a 'o'\\n    \\t\\t\\t\\t// to the result. And we record the numerator and the temporary size of the result.\\n    \\t\\t\\t\\tnum *= 10;\\n    \\t\\t\\t\\tres.append(\"0\");\\n    \\t\\t\\t\\tm[num] = res.size();\\n    \\t\\t\\t}\\n    \\n    \\t\\t\\tif(num > den)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tchar ch = '0' + num/den; // Compute the quotient and push the quotient to the result.\\n    \\t\\t\\t\\tres.push_back(ch);\\n    \\t\\t\\t\\tnum %= den; // Compute the remainder; \\n    \\t\\t\\t\\tnum *= 10; // multiply the remainder with 10, and it will be the new numerator.\\n    \\t\\t\\t\\tif(m.end() == m.find(num)) // This numerator occurs for the first time, so we record it.\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tm[num] = res.size();\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse // Circulation happens, so we return the result.\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tstring temp = res.substr(0, m[num]) + \"(\" + res.substr(m[num], string::npos) + \")\";\\n    \\t\\t\\t\\t\\tres = temp;\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n    public:\\n    \\tstring fractionToDecimal(int numerator, int denominator)\\n    \\t{\\n    \\t\\tif(0 == numerator) return \"0\";// If the numerator is 0, the final result must be 0.\\n    \\n    \\t\\tlong long num = numerator;// One of the test case is denominator = 0x80000000, thus we must save its opposite\\n    \\t\\tlong long den = denominator; // number in a long long variable.\\n    \\n    \\t\\tbool b1 = num < 0;\\n    \\t\\tbool b2 = den < 0;\\n    \\n    \\t\\tif(b1) num = - num;\\t// We convert both numerator and denominator into positive numbers.\\n    \\t\\tif(b2) den = -den;\\n    \\n    \\t\\tstring res = \"\";\\n    \\t\\tif(b1^b2) res += \"-\"; // Add a \"-\" if the numerator is positive and the denominator is negative or vice versa.\\n    \\n    \\t\\tlong long quo = num/den;\\n    \\t\\tlong long rem = num%den;\\n    \\n    \\t\\t//Calculate the integral part of the final result.\\n    \\t\\tif(quo > 0)\\n    \\t\\t{\\n    \\t\\t\\tostringstream oss;\\n    \\t\\t\\toss << quo;\\n    \\t\\t\\tres += oss.str();\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 51235,
                "title": "online-judge-pass-java-version",
                "content": "     public class Solution {\\n            public String fractionToDecimal(int numerator, int denominator) {\\n                if (denominator == 0) {\\n                    throw new IllegalArgumentException(\" denominator can not be zero\");\\n                }\\n                \\n                // avoid overflow for minimum vlaue of interger\\n                long newNum = (long) numerator;\\n                long newDeNom = (long) denominator;\\n        \\t\\t\\n        \\t\\tStringBuilder sb = new StringBuilder();\\n                \\n                // detect sign\\n                if ((newNum > 0 && newDeNom < 0) || (newNum <0 && newDeNom > 0)) {\\n        \\t\\t    sb.append(\"-\");\\n        \\t\\t}\\n        \\t\\t// make sure it is postive value\\n        \\t\\tnewNum = Math.abs(newNum);\\n        \\t\\tnewDeNom = Math.abs(newDeNom);      \\n                       \\n                sb.append(newNum / newDeNom);\\n                \\n                long reminder = newNum % newDeNom;\\n                Map<Long, Integer> reminderMap = new HashMap<>();\\n                \\n                if (reminder != 0) {\\n                    sb.append(\".\");\\n                }\\n                \\n                while (reminder != 0 && !reminderMap.containsKey(reminder)) {\\n                    reminderMap.put(reminder, sb.length());\\n                    reminder *= 10;\\n                    sb.append(reminder / newDeNom);\\n                    reminder = reminder % newDeNom; \\n                }\\n                \\n                if (reminderMap.containsKey(reminder)) {\\n                    sb.insert(reminderMap.get(reminder), \"(\");\\n                    sb.append(\")\");\\n                }\\n                return sb.toString();\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public String fractionToDecimal(int numerator, int denominator) {\\n                if (denominator == 0) {\\n                    throw new IllegalArgumentException(\" denominator can not be zero\");\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3041777,
                "title": "100-fast-simple-c-implementation",
                "content": "## Code\\n```\\nclass Solution {\\npublic:\\n    string tostring(long long n){\\n        if (n==0)return \"0\";\\n        string ans;\\n        while (n>0){\\n            string dem;\\n            dem+= ((n%10)+\\'0\\');\\n            ans= dem+ans;\\n            n/=10;\\n        }\\n        return ans;\\n    }\\n    string fractionToDecimal(int num, int denom) {\\n        if (num==0)return \"0\";\\n        string ans;\\n        if ((num<0 && denom>0) || (num>0 && denom<0))ans.push_back(\\'-\\');\\n        num= abs(num); denom= abs(denom);\\n        long long quotient= num/denom;\\n        long long remainder= num%denom;\\n        ans= ans+tostring(quotient);\\n        if (remainder==0)return ans;\\n        ans+=\\'.\\';\\n        map<long long, int> mp;\\n        while (remainder != 0){\\n            if (mp.find(remainder)!= mp.end()){\\n                int pos= mp[remainder];\\n                ans.insert(pos,\"(\");\\n                ans+=\\')\\';\\n                break;\\n            }\\n            else {\\n                mp[remainder]= ans.length();\\n                remainder*= 10;\\n                quotient= remainder/denom;\\n                remainder= remainder%denom;\\n                ans+= tostring(quotient);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "String",
                    "Design"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string tostring(long long n){\\n        if (n==0)return \"0\";\\n        string ans;\\n        while (n>0){\\n            string dem;\\n            dem+= ((n%10)+\\'0\\');\\n            ans= dem+ans;\\n            n/=10;\\n        }\\n        return ans;\\n    }\\n    string fractionToDecimal(int num, int denom) {\\n        if (num==0)return \"0\";\\n        string ans;\\n        if ((num<0 && denom>0) || (num>0 && denom<0))ans.push_back(\\'-\\');\\n        num= abs(num); denom= abs(denom);\\n        long long quotient= num/denom;\\n        long long remainder= num%denom;\\n        ans= ans+tostring(quotient);\\n        if (remainder==0)return ans;\\n        ans+=\\'.\\';\\n        map<long long, int> mp;\\n        while (remainder != 0){\\n            if (mp.find(remainder)!= mp.end()){\\n                int pos= mp[remainder];\\n                ans.insert(pos,\"(\");\\n                ans+=\\')\\';\\n                break;\\n            }\\n            else {\\n                mp[remainder]= ans.length();\\n                remainder*= 10;\\n                quotient= remainder/denom;\\n                remainder= remainder%denom;\\n                ans+= tostring(quotient);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545296,
                "title": "c-faster-than-100-easy",
                "content": "![image](https://assets.leetcode.com/users/images/c81f470d-88e4-4e34-bea5-ff6256a539ee_1635417844.7527034.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n1, int d1) {\\n        string ans = \"\", temp = \"\";\\n        unordered_map<int, int> mp;\\n        \\n        if(!n1){\\n            return \"0\";\\n        }\\n        if(n1 > 0 and d1 < 0 or n1 < 0 and d1 > 0){\\n            temp += \\'-\\';\\n        }\\n        long n = abs(n1);\\n        long d = abs(d1);\\n        \\n        ans += to_string(n/d);\\n        n %= d;\\n        if(n){\\n            ans += \\'.\\';\\n            while(n and mp.find(n) == mp.end()){\\n                mp[n] = ans.size();\\n                n *= 10;\\n                ans += to_string(n/d);\\n                n %= d;\\n            }\\n            if(n){\\n                ans = ans.substr(0, mp[n]) + \\'(\\' + ans.substr(mp[n]) + \\')\\';\\n            }\\n        }\\n        return temp + ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n1, int d1) {\\n        string ans = \"\", temp = \"\";\\n        unordered_map<int, int> mp;\\n        \\n        if(!n1){\\n            return \"0\";\\n        }\\n        if(n1 > 0 and d1 < 0 or n1 < 0 and d1 > 0){\\n            temp += \\'-\\';\\n        }\\n        long n = abs(n1);\\n        long d = abs(d1);\\n        \\n        ans += to_string(n/d);\\n        n %= d;\\n        if(n){\\n            ans += \\'.\\';\\n            while(n and mp.find(n) == mp.end()){\\n                mp[n] = ans.size();\\n                n *= 10;\\n                ans += to_string(n/d);\\n                n %= d;\\n            }\\n            if(n){\\n                ans = ans.substr(0, mp[n]) + \\'(\\' + ans.substr(mp[n]) + \\')\\';\\n            }\\n        }\\n        return temp + ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496638,
                "title": "java-with-explanation-clean-and-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\n    public String fractionToDecimal(int num, int den) {\\n        //base case\\n        if(num==0)\\n            return \"0\";\\n        \\n        //converting all integers to num becuase we may multiply them with 10 also multiple time.\\n        long numerator=num;\\n        long denominator=den;\\n        \\n        //chekcing what sign our result should have \\n        boolean flag=false;\\n        \\n        if((numerator<0 && denominator>=0) || (numerator>=0 && denominator<0))\\n            flag=true;\\n        \\n        //and removing sign from den and num\\n        numerator=Math.abs(numerator);\\n        denominator=Math.abs(denominator);\\n        \\n        \\n        long divider=numerator/denominator;\\n        long rem=numerator%denominator;\\n        \\n        StringBuilder op;\\n        if(rem==0){//no need to move further ,just return the results..\\n            op=(new StringBuilder()).append(divider);\\n        }else{//we have to find fractional points\\n            //we always multiply rem by 10 once then move forwad in case of remainder\\n            op= (new StringBuilder()).append(divider).append(\".\").append(fraction(rem*10,denominator,new StringBuilder(),new HashMap<Long,Integer>()));\\n        }\\n        //System.out.println(op.toString());\\n        if(flag)\\n            op.insert(0,\\'-\\');\\n        return op.toString();\\n    }\\n                           \\n    //while finding fractionals numbers we keep track of waht we have found till now \\n    //so we can just stop if we have already found solution for current situation and append parenthises as asked in question.\\n    public StringBuilder fraction(long num,long den,StringBuilder sb,HashMap<Long,Integer> hm){\\n        \\n        //if we solved it before just append () at appropriate indices\\n        if(hm.containsKey(num)){\\n            int index=hm.get(num);\\n            sb.insert(index,\\'(\\');\\n            sb.append(\\')\\');\\n            return sb;\\n        }\\n        \\n        if(num<den){//we have to multiply num with 10.\\n            sb.append(0);//to do so we first have to append 0 in divider\\n            return fraction(num*10,den,sb,hm);\\n        }\\n        \\n        long divider=num/den;\\n        long rem=num%den;\\n        \\n        if(rem==0){\\n            return sb.append(divider);\\n        }else{\\n            hm.put(num,sb.length());\\n            sb.append(divider);\\n            return fraction(rem*10,den,sb,hm);\\n        }\\n    }\\n\\t//if you find this helpful then please up vote.\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String fractionToDecimal(int num, int den) {\\n        //base case\\n        if(num==0)\\n            return \"0\";\\n        \\n        //converting all integers to num becuase we may multiply them with 10 also multiple time.\\n        long numerator=num;\\n        long denominator=den;\\n        \\n        //chekcing what sign our result should have \\n        boolean flag=false;\\n        \\n        if((numerator<0 && denominator>=0) || (numerator>=0 && denominator<0))\\n            flag=true;\\n        \\n        //and removing sign from den and num\\n        numerator=Math.abs(numerator);\\n        denominator=Math.abs(denominator);\\n        \\n        \\n        long divider=numerator/denominator;\\n        long rem=numerator%denominator;\\n        \\n        StringBuilder op;\\n        if(rem==0){//no need to move further ,just return the results..\\n            op=(new StringBuilder()).append(divider);\\n        }else{//we have to find fractional points\\n            //we always multiply rem by 10 once then move forwad in case of remainder\\n            op= (new StringBuilder()).append(divider).append(\".\").append(fraction(rem*10,denominator,new StringBuilder(),new HashMap<Long,Integer>()));\\n        }\\n        //System.out.println(op.toString());\\n        if(flag)\\n            op.insert(0,\\'-\\');\\n        return op.toString();\\n    }\\n                           \\n    //while finding fractionals numbers we keep track of waht we have found till now \\n    //so we can just stop if we have already found solution for current situation and append parenthises as asked in question.\\n    public StringBuilder fraction(long num,long den,StringBuilder sb,HashMap<Long,Integer> hm){\\n        \\n        //if we solved it before just append () at appropriate indices\\n        if(hm.containsKey(num)){\\n            int index=hm.get(num);\\n            sb.insert(index,\\'(\\');\\n            sb.append(\\')\\');\\n            return sb;\\n        }\\n        \\n        if(num<den){//we have to multiply num with 10.\\n            sb.append(0);//to do so we first have to append 0 in divider\\n            return fraction(num*10,den,sb,hm);\\n        }\\n        \\n        long divider=num/den;\\n        long rem=num%den;\\n        \\n        if(rem==0){\\n            return sb.append(divider);\\n        }else{\\n            hm.put(num,sb.length());\\n            sb.append(divider);\\n            return fraction(rem*10,den,sb,hm);\\n        }\\n    }\\n\\t//if you find this helpful then please up vote.\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200334,
                "title": "c-100-faster-76-less-space-easy-to-understand",
                "content": "// Use a map to track repeating fraction.\\n// Need to handling int overflow, which caused me 90% of the time, and end up having to use\\n// long long, which I should have thought of much earlier.\\n\\n\\tstring fractionToDecimal(int numerator, int denominator)\\n\\t{\\n\\t\\tif (!numerator)\\n\\t\\t{\\n\\t\\t\\treturn \"0\";\\n\\t\\t}\\n\\n\\t\\tstring result;\\n\\t\\tlong long remainder = numerator;\\n\\t\\tunordered_map<long long, int> pattern;\\n\\n\\t\\t// Determine sign so that we don\\'t have to care about it later.\\n\\t\\tif ((remainder < 0 && denominator > 0) ||\\n\\t\\t\\t(remainder > 0 && denominator < 0))\\n\\t\\t{\\n\\t\\t\\tresult += \"-\";\\n\\t\\t}\\n\\n\\t\\twhile (remainder)\\n\\t\\t{\\n\\t\\t\\tresult += to_string(llabs(remainder / denominator));\\n\\t\\t\\tremainder = remainder % denominator;\\n\\n\\t\\t\\t// Each time we got a new remainder, check if it matches a repeat pattern. \\n\\t\\t\\tif (pattern.find(remainder) != pattern.end())\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult.insert(pattern[remainder], \"(\");\\n\\t\\t\\t\\tresult.append(\")\");\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If we are not done by dividing once, we need a \".\".\\n\\t\\t\\tif (remainder && result.find(\\'.\\') == result.npos)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult += \".\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Save the remainder and its correspounding position in the result.\\n\\t\\t\\tpattern[remainder] = result.length();\\n\\n\\t\\t\\tremainder *= 10;\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [],
                "code": "// Use a map to track repeating fraction.\\n// Need to handling int overflow, which caused me 90% of the time, and end up having to use\\n// long long, which I should have thought of much earlier.\\n\\n\\tstring fractionToDecimal(int numerator, int denominator)\\n\\t{\\n\\t\\tif (!numerator)\\n\\t\\t{\\n\\t\\t\\treturn \"0\";\\n\\t\\t}\\n\\n\\t\\tstring result;\\n\\t\\tlong long remainder = numerator;\\n\\t\\tunordered_map<long long, int> pattern;\\n\\n\\t\\t// Determine sign so that we don\\'t have to care about it later.\\n\\t\\tif ((remainder < 0 && denominator > 0) ||\\n\\t\\t\\t(remainder > 0 && denominator < 0))\\n\\t\\t{\\n\\t\\t\\tresult += \"-\";\\n\\t\\t}\\n\\n\\t\\twhile (remainder)\\n\\t\\t{\\n\\t\\t\\tresult += to_string(llabs(remainder / denominator));\\n\\t\\t\\tremainder = remainder % denominator;\\n\\n\\t\\t\\t// Each time we got a new remainder, check if it matches a repeat pattern. \\n\\t\\t\\tif (pattern.find(remainder) != pattern.end())\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult.insert(pattern[remainder], \"(\");\\n\\t\\t\\t\\tresult.append(\")\");\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If we are not done by dividing once, we need a \".\".\\n\\t\\t\\tif (remainder && result.find(\\'.\\') == result.npos)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult += \".\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Save the remainder and its correspounding position in the result.\\n\\t\\t\\tpattern[remainder] = result.length();\\n\\n\\t\\t\\tremainder *= 10;\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 673275,
                "title": "java-clean-code-easy-to-understand-1-ms-time-100-faster",
                "content": "```\\nclass Solution {\\n\\t\\n\\tpublic String fractionToDecimal(int numerator, int denominator) {\\n\\t\\n\\t\\tif(numerator == 0) return \"0\";\\n\\t\\tif(denominator == 0) return \"\";\\n\\t\\n\\t\\tboolean sign = (numerator < 0) ^ (denominator < 0);\\n \\n\\t\\tStringBuilder ans = new StringBuilder();\\n \\n\\t\\tlong num = Math.abs(new Long(numerator));\\n\\t\\tlong den = Math.abs(new Long(denominator));\\n\\t\\t\\n\\t\\tif(sign) ans.append(\"-\");\\n \\n\\t\\tans.append(num / den);\\n\\t\\tlong remainder = (num % den) * 10;\\n\\t\\t\\n\\t\\tif(remainder != 0) ans.append(\".\");\\n\\t\\t\\n\\t\\tMap<Long, Integer> map = new HashMap<>();\\n        \\n\\t\\twhile(remainder != 0) {\\n\\t\\t\\tif(map.containsKey(remainder)) {\\n\\t\\t\\t\\tans.insert(map.get(remainder), \"(\");\\n\\t\\t\\t\\tans.append(\")\");\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tmap.put(remainder, ans.length());\\n\\t\\t\\tans.append(remainder / den);\\n\\t\\t\\tremainder = (remainder % den) * 10;\\n\\t\\t}\\n \\n\\t\\treturn ans.toString();\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tpublic String fractionToDecimal(int numerator, int denominator) {\\n\\t\\n\\t\\tif(numerator == 0) return \"0\";\\n\\t\\tif(denominator == 0) return \"\";\\n\\t\\n\\t\\tboolean sign = (numerator < 0) ^ (denominator < 0);\\n \\n\\t\\tStringBuilder ans = new StringBuilder();\\n \\n\\t\\tlong num = Math.abs(new Long(numerator));\\n\\t\\tlong den = Math.abs(new Long(denominator));\\n\\t\\t\\n\\t\\tif(sign) ans.append(\"-\");\\n \\n\\t\\tans.append(num / den);\\n\\t\\tlong remainder = (num % den) * 10;\\n\\t\\t\\n\\t\\tif(remainder != 0) ans.append(\".\");\\n\\t\\t\\n\\t\\tMap<Long, Integer> map = new HashMap<>();\\n        \\n\\t\\twhile(remainder != 0) {\\n\\t\\t\\tif(map.containsKey(remainder)) {\\n\\t\\t\\t\\tans.insert(map.get(remainder), \"(\");\\n\\t\\t\\t\\tans.append(\")\");\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tmap.put(remainder, ans.length());\\n\\t\\t\\tans.append(remainder / den);\\n\\t\\t\\tremainder = (remainder % den) * 10;\\n\\t\\t}\\n \\n\\t\\treturn ans.toString();\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413293,
                "title": "clean-java-solution-1ms",
                "content": "This uses a map to detect a cycle.\\n\\n```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) return \"0\";\\n        StringBuilder builder = new StringBuilder();\\n        if ((numerator < 0) ^ (denominator < 0)) builder.append(\"-\");\\n\\t\\t\\n\\t\\t//converts to long to get rid of the pesky int overflow\\n        long n = Math.abs((long)numerator);\\n        long d = Math.abs((long)denominator);\\n\\n        builder.append((n/d));\\n        if ((n %= d) == 0) return builder.toString();\\n        builder.append(\".\");\\n        \\n\\t\\t//map stores the index in our  builder where we first encounter this numerator\\n        Map<Long, Integer> numerators = new HashMap<>();\\n        while(!numerators.containsKey(n)) {\\n            numerators.put(n, builder.length());\\n            n *= 10;\\n            builder.append(n/d);\\n            if ((n %= d) == 0) return builder.toString();\\n        }\\n\\t\\t//we use the index to insert our bracket\\n        return builder.insert(numerators.get(n),\"(\").append(\")\").toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) return \"0\";\\n        StringBuilder builder = new StringBuilder();\\n        if ((numerator < 0) ^ (denominator < 0)) builder.append(\"-\");\\n\\t\\t\\n\\t\\t//converts to long to get rid of the pesky int overflow\\n        long n = Math.abs((long)numerator);\\n        long d = Math.abs((long)denominator);\\n\\n        builder.append((n/d));\\n        if ((n %= d) == 0) return builder.toString();\\n        builder.append(\".\");\\n        \\n\\t\\t//map stores the index in our  builder where we first encounter this numerator\\n        Map<Long, Integer> numerators = new HashMap<>();\\n        while(!numerators.containsKey(n)) {\\n            numerators.put(n, builder.length());\\n            n *= 10;\\n            builder.append(n/d);\\n            if ((n %= d) == 0) return builder.toString();\\n        }\\n\\t\\t//we use the index to insert our bracket\\n        return builder.insert(numerators.get(n),\"(\").append(\")\").toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 228992,
                "title": "easy-to-read-javascript-solution-w-explanation-beats-100-68-ms",
                "content": "Idea: the core of this problem is identifying and handling repeating decimals correctly. Besides that, you just need to make sure that you\\'re handling edge cases appropriately. One way to think about identifying repeating decimals is to track the \"carry\" as if you\\'re doing long division by hand. If you\\'ve seen the \"carry\" before, then you\\'re in a loop that started at the index of the first time you saw that carry.\\n\\nFor example, with 2 / 3:\\n \\n![image](https://assets.leetcode.com/users/tadasant/image_1548851304.png)\\n\\n\\nEdge cases:\\n* Left side of decimal is >0, or >9 (i.e. multiple digits might throw off your idx counting)\\n* Numerator is zero\\n* Negative numbers (one or both numerator/denominator)\\n* Whole numbers (i.e. no need for decimal point)\\n* Non-repeating decimals\\n\\n```\\nvar fractionToDecimal = function(numerator, denominator) {\\n    // Handle zero edge case\\n    if (numerator === 0) {\\n        return \"0\";\\n    }\\n    \\n    // Handle negatives edge cases, work with positive numbers moving forward\\n    const isNegative = numerator < 0 ? denominator > 0 : denominator < 0;\\n    numerator = Math.abs(numerator);\\n    denominator = Math.abs(denominator);\\n    \\n    // Handle whole number edge case\\n    const leftSide = Math.floor(numerator / denominator);\\n    const hasDecimal = (numerator / denominator) % 1 !== 0;\\n    if (!hasDecimal) {\\n        return isNegative ? `-${leftSide.toString()}` : leftSide.toString();\\n    }\\n    \\n    // Invoke core algorithm\\n    const result = [leftSide.toString(), \\'.\\'];\\n    addDecimal(numerator, denominator, leftSide, result);\\n    \\n    // Finish handling negatives edge case\\n    if (isNegative) {\\n        result.unshift(\"-\");\\n    }\\n\\t\\n    return result.join(\\'\\');\\n};\\n\\nfunction addDecimal(numerator, denominator, leftSide, result) {\\n    // Account for whole number edge case; make numerator less than denominator\\n    numerator -= (leftSide * denominator);\\n    \\n    let idx = 0; // idx of the current digit\\n    const carries = {}; // carry values to index (within decimal digit chars) mapping\\n    \\n    // Loop dividing numerator by denominator and tracking carry at each step\\n    while (numerator !== 0 && !(numerator in carries)) {\\n        carries[numerator] = idx++;\\n        numerator *= 10;\\n        const nextDigit = Math.floor(numerator / denominator);\\n        result.push(nextDigit.toString());\\n        numerator %= denominator;\\n    }\\n    \\n    // If we detected a loop, add the repeating parentheses\\n    if (numerator in carries) {\\n        addParens(carries[numerator], result);\\n    }\\n}\\n\\nfunction addParens(decimalIdx, result) {\\n    result.splice(2 + decimalIdx, 0, \\'(\\'); // +2 because decimal point is at idx 1\\n    result.push(\\')\\');\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fractionToDecimal = function(numerator, denominator) {\\n    // Handle zero edge case\\n    if (numerator === 0) {\\n        return \"0\";\\n    }\\n    \\n    // Handle negatives edge cases, work with positive numbers moving forward\\n    const isNegative = numerator < 0 ? denominator > 0 : denominator < 0;\\n    numerator = Math.abs(numerator);\\n    denominator = Math.abs(denominator);\\n    \\n    // Handle whole number edge case\\n    const leftSide = Math.floor(numerator / denominator);\\n    const hasDecimal = (numerator / denominator) % 1 !== 0;\\n    if (!hasDecimal) {\\n        return isNegative ? `-${leftSide.toString()}` : leftSide.toString();\\n    }\\n    \\n    // Invoke core algorithm\\n    const result = [leftSide.toString(), \\'.\\'];\\n    addDecimal(numerator, denominator, leftSide, result);\\n    \\n    // Finish handling negatives edge case\\n    if (isNegative) {\\n        result.unshift(\"-\");\\n    }\\n\\t\\n    return result.join(\\'\\');\\n};\\n\\nfunction addDecimal(numerator, denominator, leftSide, result) {\\n    // Account for whole number edge case; make numerator less than denominator\\n    numerator -= (leftSide * denominator);\\n    \\n    let idx = 0; // idx of the current digit\\n    const carries = {}; // carry values to index (within decimal digit chars) mapping\\n    \\n    // Loop dividing numerator by denominator and tracking carry at each step\\n    while (numerator !== 0 && !(numerator in carries)) {\\n        carries[numerator] = idx++;\\n        numerator *= 10;\\n        const nextDigit = Math.floor(numerator / denominator);\\n        result.push(nextDigit.toString());\\n        numerator %= denominator;\\n    }\\n    \\n    // If we detected a loop, add the repeating parentheses\\n    if (numerator in carries) {\\n        addParens(carries[numerator], result);\\n    }\\n}\\n\\nfunction addParens(decimalIdx, result) {\\n    result.splice(2 + decimalIdx, 0, \\'(\\'); // +2 because decimal point is at idx 1\\n    result.push(\\')\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 137886,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        \"\"\"\\n        :type numerator: int\\n        :type denominator: int\\n        :rtype: str\\n        \"\"\"\\n        n, remainder = divmod(abs(numerator), abs(denominator))\\n        sign = \\'-\\' if numerator*denominator < 0 else \\'\\'\\n        fraction = [sign+str(n)]\\n        if remainder == 0:\\n            return \\'\\'.join(fraction)\\n\\n        fraction.append(\\'.\\')\\n        dic = {}\\n        while remainder != 0:\\n            if remainder in dic:\\n                fraction.insert(dic[remainder], \\'(\\')\\n                fraction.append(\\')\\')\\n                break\\n            dic[remainder] = len(fraction)\\n            n, remainder = divmod(remainder*10, abs(denominator))\\n            fraction.append(str(n))\\n        return \\'\\'.join(fraction)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        \"\"\"\\n        :type numerator: int\\n        :type denominator: int\\n        :rtype: str\\n        \"\"\"\\n        n, remainder = divmod(abs(numerator), abs(denominator))\\n        sign = \\'-\\' if numerator*denominator < 0 else \\'\\'\\n        fraction = [sign+str(n)]\\n        if remainder == 0:\\n            return \\'\\'.join(fraction)\\n\\n        fraction.append(\\'.\\')\\n        dic = {}\\n        while remainder != 0:\\n            if remainder in dic:\\n                fraction.insert(dic[remainder], \\'(\\')\\n                fraction.append(\\')\\')\\n                break\\n            dic[remainder] = len(fraction)\\n            n, remainder = divmod(remainder*10, abs(denominator))\\n            fraction.append(str(n))\\n        return \\'\\'.join(fraction)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51113,
                "title": "fastest-java-solution-1-ms-and-o-1-space",
                "content": "My algorithm base on the Floyd's cycle-finding algorithm. Instead of using hashMap to store the result of each step, It uses two pointer, fast (iterate twice each time) and slow (iterate once each time) to detect cycle. Then It finds out the non-cycle part and cycle part. Therefore, it's O(1) space and is faster than those of using hash.\\n```\\npublic class Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        // negative sign\\n        boolean negative = (numerator < 0) ^ (denominator < 0);\\n        long n = Math.abs((long)numerator);\\n        long d = Math.abs((long)denominator);\\n        long intPart = n / d;\\n        long rest = n - intPart * d;\\n        if (rest == 0) return negative ? String.valueOf(intPart * (-1)) : String.valueOf(intPart); // Integer result\\n        StringBuilder res = new StringBuilder();\\n        if (negative) res.append(\"-\");\\n        res.append(intPart);\\n        res.append(\".\");\\n        long slow;\\n        long fast;\\n        long[] temp = new long[2];\\n        slow = Decimal(rest*10, d)[1];\\n        fast = Decimal(Decimal(rest*10, d)[1], d)[1];\\n        while (slow != fast) {\\n            slow = Decimal(slow, d)[1];\\n            fast = Decimal(Decimal(fast, d)[1], d)[1];\\n        }\\n        slow = rest * 10;\\n        while (slow != fast && slow != 0) {\\n            temp = Decimal(slow, d);\\n            slow = temp[1];\\n            res.append(temp[0]);       // non-cycle part\\n            fast = Decimal(fast, d)[1];\\n        }\\n        if (slow == 0) return res.toString();  // return when result is finite decimal\\n        temp = Decimal(slow, d);\\n        fast = temp[1];\\n        res.append(\"(\");\\n        res.append(temp[0]);\\n        while (slow != fast) {\\n            temp = Decimal(fast, d);\\n            fast = temp[1];\\n            res.append(temp[0]);  // cycle part\\n        }\\n        res.append(\")\");\\n        return res.toString();\\n    }\\n    public long[] Decimal(long rest, long denominator) {\\n        // return the quotient and remainder (multiplied by 10)\\n        long r1;\\n        long r2;\\n        if (rest < denominator) {\\n            r1 = 0;\\n            r2 = rest * 10;\\n        }\\n        else {\\n            r1 = rest / denominator;\\n            r2 = (rest - denominator * r1) * 10;\\n        }\\n        return new long[]{r1, r2};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        // negative sign\\n        boolean negative = (numerator < 0) ^ (denominator < 0);\\n        long n = Math.abs((long)numerator);\\n        long d = Math.abs((long)denominator);\\n        long intPart = n / d;\\n        long rest = n - intPart * d;\\n        if (rest == 0) return negative ? String.valueOf(intPart * (-1)) : String.valueOf(intPart); // Integer result\\n        StringBuilder res = new StringBuilder();\\n        if (negative) res.append(\"-\");\\n        res.append(intPart);\\n        res.append(\".\");\\n        long slow;\\n        long fast;\\n        long[] temp = new long[2];\\n        slow = Decimal(rest*10, d)[1];\\n        fast = Decimal(Decimal(rest*10, d)[1], d)[1];\\n        while (slow != fast) {\\n            slow = Decimal(slow, d)[1];\\n            fast = Decimal(Decimal(fast, d)[1], d)[1];\\n        }\\n        slow = rest * 10;\\n        while (slow != fast && slow != 0) {\\n            temp = Decimal(slow, d);\\n            slow = temp[1];\\n            res.append(temp[0]);       // non-cycle part\\n            fast = Decimal(fast, d)[1];\\n        }\\n        if (slow == 0) return res.toString();  // return when result is finite decimal\\n        temp = Decimal(slow, d);\\n        fast = temp[1];\\n        res.append(\"(\");\\n        res.append(temp[0]);\\n        while (slow != fast) {\\n            temp = Decimal(fast, d);\\n            fast = temp[1];\\n            res.append(temp[0]);  // cycle part\\n        }\\n        res.append(\")\");\\n        return res.toString();\\n    }\\n    public long[] Decimal(long rest, long denominator) {\\n        // return the quotient and remainder (multiplied by 10)\\n        long r1;\\n        long r2;\\n        if (rest < denominator) {\\n            r1 = 0;\\n            r2 = rest * 10;\\n        }\\n        else {\\n            r1 = rest / denominator;\\n            r2 = (rest - denominator * r1) * 10;\\n        }\\n        return new long[]{r1, r2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881820,
                "title": "c-hashmap-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator == 0) return \"0\";\\n        \\n        string ans;\\n        ans = (numerator > 0)^(denominator > 0) ? \"-\":\"\";       //adding sign if either num or deno is -ve\\n        \\n        long n = abs(numerator);        //making both num and deno +ve\\n        long d = abs(denominator);\\n        ans += to_string(n/d);          \\n        \\n        n = n%d;\\n        if(!n) return ans;              //if we got remainder n = 0 then return ans else add \".\" to the ans\\n        \\n        ans += \".\";\\n        \\n        //If you find remainder again means ans from that point will start repeating from there so we map\\n        //remainder with the length pf answer at that point so that if it occur again then we can insert bracket there\\n        unordered_map<long, int> mp;\\n        \\n        while(n)        //repeat untill remainder != 0\\n        {   \\n            if(mp[n])   //if you find that this remainder has occurred before then  \\n            {\\n                ans.insert(mp[n], \"(\");    //Inserting ( at position when we first found that remainder\\n                ans += \")\";                //Inserting closing bracket at the last\\n                break;          \\n            }\\n            else{\\n                mp[n] = ans.size();     //storing when remainder n come then what is the size of ans\\n                n *= 10;\\n                ans += to_string(n/d);  \\n                n = n%d;                //calculating remainder\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator == 0) return \"0\";\\n        \\n        string ans;\\n        ans = (numerator > 0)^(denominator > 0) ? \"-\":\"\";       //adding sign if either num or deno is -ve\\n        \\n        long n = abs(numerator);        //making both num and deno +ve\\n        long d = abs(denominator);\\n        ans += to_string(n/d);          \\n        \\n        n = n%d;\\n        if(!n) return ans;              //if we got remainder n = 0 then return ans else add \".\" to the ans\\n        \\n        ans += \".\";\\n        \\n        //If you find remainder again means ans from that point will start repeating from there so we map\\n        //remainder with the length pf answer at that point so that if it occur again then we can insert bracket there\\n        unordered_map<long, int> mp;\\n        \\n        while(n)        //repeat untill remainder != 0\\n        {   \\n            if(mp[n])   //if you find that this remainder has occurred before then  \\n            {\\n                ans.insert(mp[n], \"(\");    //Inserting ( at position when we first found that remainder\\n                ans += \")\";                //Inserting closing bracket at the last\\n                break;          \\n            }\\n            else{\\n                mp[n] = ans.size();     //storing when remainder n come then what is the size of ans\\n                n *= 10;\\n                ans += to_string(n/d);  \\n                n = n%d;                //calculating remainder\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296174,
                "title": "java-100",
                "content": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if(numerator == 0){\\n            return  \"0\";\\n        }\\n        \\n        StringBuilder sb = new StringBuilder(\"\");\\n        if(numerator<0 && denominator>0 || numerator>0 && denominator<0){\\n            sb.append(\"-\");\\n        }\\n        \\n        long divisor = Math.abs((long)numerator);\\n        long dividend = Math.abs((long)denominator);\\n        long remainder = divisor % dividend;\\n        sb.append(divisor / dividend);\\n        \\n        if(remainder == 0){\\n            return sb.toString();\\n        }\\n        sb.append(\".\");\\n        HashMap<Long, Integer> map = new HashMap<Long, Integer>();\\n        while(remainder!=0){\\n            if(map.containsKey(remainder)){\\n                sb.insert(map.get(remainder), \"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n            map.put(remainder, sb.length());\\n            remainder*= 10;\\n            sb.append(remainder/dividend);\\n            remainder%= dividend;\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if(numerator == 0){\\n            return  \"0\";\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1017288,
                "title": "explained-python-3-time-complexity-o-len-frac-28-ms",
                "content": "The general idea is to keep a list of the decimal and all the remainders. If the remainder is 0, return the decimal, and if the remainder started repeating, add parenthesis to the part repeating and return it.\\n\\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        times = \\'\\'\\n        if numerator < 0 and denominator > 0 or numerator > 0 and denominator < 0:\\n            times = \\'-\\'\\n            numerator = abs(numerator)\\n            denominator = abs(denominator)\\n        if numerator < 0 and denominator < 0:\\n            numerator = -numerator\\n            denominator = -denominator\\n        decimal = []\\n        remainders = []\\n        while True:\\n            decimal.append(str(numerator // denominator))\\n            numerator %= denominator\\n            remainders.append(numerator)\\n            numerator *= 10\\n            \\n            if numerator == 0:\\n                if len(decimal) == 1:\\n                    return times + \\'\\'.join(decimal)\\n                return times + decimal[0] + \\'.\\' + \\'\\'.join(decimal[1:])\\n            \\n            if remainders.count(remainders[-1]) > 1:\\n                decimal.insert(remainders.index(remainders[-1]) + 1, \\'(\\')\\n                decimal.append(\\')\\')\\n                return times + decimal[0] + \\'.\\' + \\'\\'.join(decimal[1:])\\n```\\n\\t\\nthe first part is to deal with negatives (If one is negative, make a times variable to add to the start and make all the variables positive. If both are negative, just make all positive)\\nThe start of the while loop is just doing long division and adding the remainders to the remainder list.\\nThe middle of the while loop is dealing with if the denominator (numerator in this case) is 0, which I will then return the decimal because the fraction isn\\'t repeating.\\n\\nThe end part of the while part is the tricky part, and I admit it took me 15 minutes of constant submitting and bug-fixing. the if statement is checking is the remainder had the same value twice, which means the decimal is repeating. So, the demical.insert() is inserting a parenthesis at the start of when the repeating part started. For example, if decimal is \\'0.6\\' (\\'06\\' in the actual code but that doesn\\'t matter) and remainders is [2, 2] I know that the six is repeating, and insert a parenthesis right before \\'6\\'. Then i append a parenthesis at the end of the decimal to get \\'0.(6)\\', and then return it.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        times = \\'\\'\\n        if numerator < 0 and denominator > 0 or numerator > 0 and denominator < 0:\\n            times = \\'-\\'\\n            numerator = abs(numerator)\\n            denominator = abs(denominator)\\n        if numerator < 0 and denominator < 0:\\n            numerator = -numerator\\n            denominator = -denominator\\n        decimal = []\\n        remainders = []\\n        while True:\\n            decimal.append(str(numerator // denominator))\\n            numerator %= denominator\\n            remainders.append(numerator)\\n            numerator *= 10\\n            \\n            if numerator == 0:\\n                if len(decimal) == 1:\\n                    return times + \\'\\'.join(decimal)\\n                return times + decimal[0] + \\'.\\' + \\'\\'.join(decimal[1:])\\n            \\n            if remainders.count(remainders[-1]) > 1:\\n                decimal.insert(remainders.index(remainders[-1]) + 1, \\'(\\')\\n                decimal.append(\\')\\')\\n                return times + decimal[0] + \\'.\\' + \\'\\'.join(decimal[1:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922829,
                "title": "easyway-explanation-every-step",
                "content": "# ![image](https://assets.leetcode.com/users/images/3990a5fc-e26c-4b29-8268-5dce917a531d_1604464154.2853613.png)\\n\\n\\n# Quotient=numerator / denominator\\n# remainder=numerator % denominator\\n```\\nans=\"\"\\n         x,y=n,d\\n        n,d=abs(n),abs(d)\\n        q=n//d\\n        r=n%d\\n        ans+=str(q)\\n\\n```\\n\\n# at first make  negative number to positive for make to easy .at last when original result send than handle it.\\n\\n```\\nreturn ans if (x>0 and  y>0) or (x<0 and y<0) or x==0 else \"-\"+ ans\\n\\n\\n```\\n# there is two condition if remainder is zero then skip middle of the code and return this way\\n# here numerator(x) and denominator(y)\\n\\n# Main part of the code when not zero means fractional part is present\\n\\n```\\nif r!=0:\\n          ans+=\".\"\\n```\\n# so at first put into  \".\"  reason is  this is fractional part\\n```\\n          h={}\\n```\\n# we put remainder and what is the length of the output in hasmap . it helps what is the  position  when this remainder come\\n```\\n          while r!=0:\\n                if r in h:\\n              \\n                      l=h[r]\\n                      ans=ans[0:l]+\"(\"+ans[l:]+\")\"\\n                      break\\n  ```\\n  # if your remainder present in hasmsp then modify your answer according to leetcode wanted and break .if not put break then loop goes infinity\\n  \\n  \\n```\\n            h[r]=len(ans)\\n            r*=10\\n            q=r//d\\n            r=r%d\\n            \\n            ans+=str(q)\\n\\n\\n```\\n# if not present then put remainder as a key and length of output as data \\n# this is fractional part so multiple with 10 with remainder\\n# continue same process utill remaind is not zero\\n```\\n\\n\\nYour input\\n4\\n333\\n\\n\\noriginal output = 0.012012012012012012.......\\n\\n store new remainder(key) in hasmap= 4 when length of output (data)= 2 ( 0. ) hasmap= {4: 2}\\n\\n store new remainder(key) in hasmap= 40 when length of output (data)= 3 ( 0.0 ) hasmap= {4: 2, 40: 3}\\n\\n store new remainder(key) in hasmap= 67 when length of output (data)= 4 ( 0.01 ) hasmap= {4: 2, 40: 3, 67: 4}\\n\\n repeated remainder= 4 repeated position= 2\\n{4: 2, 40: 3, 67: 4}\\n\\nOutput\\n\"0.(012)\"\\nExpected\\n\\n```\\n```\\n\\nYour input\\n622\\n495\\noriginal output = 1.256565656565656......\\n\\n store new remainder(key) in hasmap= 127 when length of output (data)= 2 ( 1. ) hasmap= {127: 2}\\n\\n store new remainder(key) in hasmap= 280 when length of output (data)= 3 ( 1.2 ) hasmap= {127: 2, 280: 3}\\n\\n store new remainder(key) in hasmap= 325 when length of output (data)= 4 ( 1.25 ) hasmap= {127: 2, 280: 3, 325: 4}\\n\\n repeated remainder= 280 repeated position= 3\\n{127: 2, 280: 3, 325: 4}\\n\\nOutput\\n\"1.2(56)\"\\nExpected\\n\"1.2(56)\"\\n\\nRun Code\\n\\n\\n\\n\\n```\\n\\n```\\nclass Solution(object):\\n    def fractionToDecimal(self, n, d):\\n        \"\"\"\\n        :type numerator: int\\n        :type denominator: int\\n        :rtype: str\\n        \"\"\"\\n        ans=\"\"\\n        \\n        x,y=n,d\\n        n,d=abs(n),abs(d)\\n        q=n//d\\n        r=n%d\\n        ans+=str(q)\\n        \\n        if r!=0:\\n          ans+=\".\"\\n          h={}\\n          while r!=0:\\n            \\n            if r in h:\\n              \\n              l=h[r]\\n              ans=ans[0:l]+\"(\"+ans[l:]+\")\"\\n              break\\n              \\n            h[r]=len(ans)\\n            \\n            r*=10\\n            q=r//d\\n            r=r%d\\n            \\n            ans+=str(q)\\n        \\n        return ans if (x>0 and  y>0) or (x<0 and y<0) or x==0 else \"-\"+ ans\\n            \\n          \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nans=\"\"\\n         x,y=n,d\\n        n,d=abs(n),abs(d)\\n        q=n//d\\n        r=n%d\\n        ans+=str(q)\\n\\n```\n```\\nreturn ans if (x>0 and  y>0) or (x<0 and y<0) or x==0 else \"-\"+ ans\\n\\n\\n```\n```\\nif r!=0:\\n          ans+=\".\"\\n```\n```\\n          h={}\\n```\n```\\n          while r!=0:\\n                if r in h:\\n              \\n                      l=h[r]\\n                      ans=ans[0:l]+\"(\"+ans[l:]+\")\"\\n                      break\\n  ```\n```\\n            h[r]=len(ans)\\n            r*=10\\n            q=r//d\\n            r=r%d\\n            \\n            ans+=str(q)\\n\\n\\n```\n```\\n\\n\\nYour input\\n4\\n333\\n\\n\\noriginal output = 0.012012012012012012.......\\n\\n store new remainder(key) in hasmap= 4 when length of output (data)= 2 ( 0. ) hasmap= {4: 2}\\n\\n store new remainder(key) in hasmap= 40 when length of output (data)= 3 ( 0.0 ) hasmap= {4: 2, 40: 3}\\n\\n store new remainder(key) in hasmap= 67 when length of output (data)= 4 ( 0.01 ) hasmap= {4: 2, 40: 3, 67: 4}\\n\\n repeated remainder= 4 repeated position= 2\\n{4: 2, 40: 3, 67: 4}\\n\\nOutput\\n\"0.(012)\"\\nExpected\\n\\n```\n```\\n\\nYour input\\n622\\n495\\noriginal output = 1.256565656565656......\\n\\n store new remainder(key) in hasmap= 127 when length of output (data)= 2 ( 1. ) hasmap= {127: 2}\\n\\n store new remainder(key) in hasmap= 280 when length of output (data)= 3 ( 1.2 ) hasmap= {127: 2, 280: 3}\\n\\n store new remainder(key) in hasmap= 325 when length of output (data)= 4 ( 1.25 ) hasmap= {127: 2, 280: 3, 325: 4}\\n\\n repeated remainder= 280 repeated position= 3\\n{127: 2, 280: 3, 325: 4}\\n\\nOutput\\n\"1.2(56)\"\\nExpected\\n\"1.2(56)\"\\n\\nRun Code\\n\\n\\n\\n\\n```\n```\\nclass Solution(object):\\n    def fractionToDecimal(self, n, d):\\n        \"\"\"\\n        :type numerator: int\\n        :type denominator: int\\n        :rtype: str\\n        \"\"\"\\n        ans=\"\"\\n        \\n        x,y=n,d\\n        n,d=abs(n),abs(d)\\n        q=n//d\\n        r=n%d\\n        ans+=str(q)\\n        \\n        if r!=0:\\n          ans+=\".\"\\n          h={}\\n          while r!=0:\\n            \\n            if r in h:\\n              \\n              l=h[r]\\n              ans=ans[0:l]+\"(\"+ans[l:]+\")\"\\n              break\\n              \\n            h[r]=len(ans)\\n            \\n            r*=10\\n            q=r//d\\n            r=r%d\\n            \\n            ans+=str(q)\\n        \\n        return ans if (x>0 and  y>0) or (x<0 and y<0) or x==0 else \"-\"+ ans\\n            \\n          \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 292716,
                "title": "c-dictionary-and-while",
                "content": "```\\npublic class Solution {\\n    public string FractionToDecimal(int numerator, int denominator) {\\n        return FractionToDecimalLong((long)numerator, (long)denominator);\\n    }\\n\\n    private string FractionToDecimalLong(long numerator, long denominator) {\\n        var isNegative = false;\\n        if ((numerator > 0 && denominator < 0) || (numerator < 0 && denominator > 0)) {\\n            isNegative = true;\\n        }\\n\\n        numerator = Math.Abs(numerator);\\n        denominator = Math.Abs(denominator);\\n\\n        var integerPart = numerator / denominator;\\n\\n        var floatPart = \"\";\\n\\n        var remainderAndIndex = new Dictionary<long, int>();\\n        var remainder = numerator % denominator;\\n\\n        if (remainder == 0) return isNegative ? $\"-{integerPart}\" : $\"{integerPart}\";\\n\\n        var i = 0;\\n\\n        while (remainder != 0) {\\n            remainderAndIndex[remainder] = i;\\n            i++;\\n            remainder *= 10;\\n            floatPart = $\"{floatPart}{remainder / denominator}\";\\n            remainder = remainder % denominator;\\n            if (remainderAndIndex.ContainsKey(remainder)) {\\n                floatPart = floatPart.Insert(remainderAndIndex[remainder], \"(\");\\n                floatPart += \")\";\\n                break;\\n            }\\n        }\\n\\n        if (isNegative) {\\n            return $\"-{integerPart}.{floatPart}\";\\n        }\\n\\n        return $\"{integerPart}.{floatPart}\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string FractionToDecimal(int numerator, int denominator) {\\n        return FractionToDecimalLong((long)numerator, (long)denominator);\\n    }\\n\\n    private string FractionToDecimalLong(long numerator, long denominator) {\\n        var isNegative = false;\\n        if ((numerator > 0 && denominator < 0) || (numerator < 0 && denominator > 0)) {\\n            isNegative = true;\\n        }\\n\\n        numerator = Math.Abs(numerator);\\n        denominator = Math.Abs(denominator);\\n\\n        var integerPart = numerator / denominator;\\n\\n        var floatPart = \"\";\\n\\n        var remainderAndIndex = new Dictionary<long, int>();\\n        var remainder = numerator % denominator;\\n\\n        if (remainder == 0) return isNegative ? $\"-{integerPart}\" : $\"{integerPart}\";\\n\\n        var i = 0;\\n\\n        while (remainder != 0) {\\n            remainderAndIndex[remainder] = i;\\n            i++;\\n            remainder *= 10;\\n            floatPart = $\"{floatPart}{remainder / denominator}\";\\n            remainder = remainder % denominator;\\n            if (remainderAndIndex.ContainsKey(remainder)) {\\n                floatPart = floatPart.Insert(remainderAndIndex[remainder], \"(\");\\n                floatPart += \")\";\\n                break;\\n            }\\n        }\\n\\n        if (isNegative) {\\n            return $\"-{integerPart}.{floatPart}\";\\n        }\\n\\n        return $\"{integerPart}.{floatPart}\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51122,
                "title": "java-1ms-without-using-hash-table",
                "content": "  Actually there is no need to use a hash table.\\n\\n  I get this inspiration from the problem NO.142, Linked list Cycle II, imagine every remainder you take as a node when you perform the division. When you get the recurring decimals, the pattern will be the same as the pattern mentioned in Linked list Cydle II(Find the node which the cycle starts).\\n \\n  How to find that node we want? Suppose we have n nodes who are not in the cycle and m nodes who are in the cycle. We create two pointers. The first one moves one nodes per step, the second one moves two nodes per step. When the first one reaches the node that we want, the second one is n nodes ahead. For the second node, if it want to catch up the first node, it will have to move m-n steps ahead. So far the first node have moved for (m-n+n) = m steps and there are (m+n-m) = n steps left to reach the node which starts the cycle. The same thing is, it will take exactly n steps for the first node to reach that node. So we could use a pointer start from the beginning of the list and move all of them one nodes per step. When they reach the same node. That node is the node we want.\\n\\n  The actual code is as follows.\\n\\npublic class Solution {\\n\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        \\n        if(numerator==Integer.MIN_VALUE&&denominator==-1)\\n            return \"2147483648\";\\n        int dummy = numerator/denominator, lef = numerator%denominator;\\n        String str = dummy+\"\";\\n        if(dummy==0){\\n            if((numerator>0&&denominator<0)||(numerator<0&&denominator>0))\\n            str = \"-\" + str; // 0 does not have a negative mark in front of it, so we have to add that.\\n        }\\n        if(lef==0) return str; // this indicates the result is an integer.\\n        \\n        StringBuilder sb = new StringBuilder();\\n        sb.append(str);\\n        sb.append(\".\");\\n        long left = lef<0? -lef : lef;\\n        long denomin = denominator<0? -denominator : denominator;\\n        if(denominator==Integer.MIN_VALUE){\\n            denomin = Integer.MAX_VALUE;\\n            denomin++; // without this, when the denominator is -214748648, it will cause a overflow.\\n        }\\n        long slow = mod(left,denomin), fast = mod(mod(left,denomin),denomin);\\n        if(slow==0){ // no need to start the loop.\\n            left = extend(left,denomin,sb);\\n            return sb.toString();\\n        }\\n        \\n        while(slow!=fast){\\n            if(fast==0){  // this indicates there are no cycles.\\n                while(left!=0)\\n                    left = extend(left,denomin,sb);\\n                return sb.toString();\\n            }\\n            slow = mod(slow,denomin);\\n            fast = mod(mod(fast,denomin),denomin);\\n        }\\n        \\n        slow = left;\\n        while(slow!=fast){\\n            slow = mod(slow,denomin);\\n            fast = mod(fast,denomin);\\n        }\\n        while(left!=slow)\\n            left = extend(left,denomin,sb);\\n        sb.append(\"(\"); // the start of the cycle.\\n        left = extend(left,denomin,sb);\\n        while(left!=slow)\\n            left = extend(left,denomin,sb);\\n        sb.append(\")\");\\n        return sb.toString();\\n    }\\n    \\n    private long mod(long left, long denominator){\\n        left = left * 10;      \\n        return left%denominator;    \\n    }\\n    \\n    private long extend(long left, long denominator, StringBuilder sb){\\n        left = left * 10;      \\n        sb.append(left/denominator);\\n        return left%denominator;\\n    }\\n\\n }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        \\n        if(numerator==Integer.MIN_VALUE&&denominator==-1)\\n            return \"2147483648\";\\n        int dummy = numerator/denominator, lef = numerator%denominator;\\n        String str = dummy+\"\";\\n        if(dummy==0){\\n            if((numerator>0&&denominator<0)||(numerator<0&&denominator>0))\\n            str = \"-\" + str; // 0 does not have a negative mark in front of it, so we have to add that.\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2405774,
                "title": "c-unordered-map-0ms-time",
                "content": "**C++ Implementation**\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d) {\\n        int cnt = 0;\\n        if(n == 0) return \"0\";\\n        if(n < 0) cnt++;\\n        if(d < 0) cnt++;\\n        n = abs(n);\\n        d = abs(d);        \\n        long long rem = n%d;\\n        long long q = n/d;\\n        string ans = \"\";\\n        ans += to_string(q);\\n        if(rem == 0) {\\n            if(cnt == 1) return \"-\"+ans;\\n            else return ans;\\n        }\\n        unordered_map<int,int>mp;\\n        ans += \".\";\\n        while(rem != 0){\\n            if(mp.find(rem) != mp.end()){\\n                int len = mp[rem];\\n                string s1 = ans.substr(0,len);\\n                string s2 = ans.substr(len);\\n                ans = s1+\"(\"+s2+\")\";\\n                break;\\n            }\\n            else{\\n                mp[rem] = ans.size();\\n                rem *= 10;\\n                q = rem/d;\\n                rem = rem%d;\\n                ans += to_string(q);\\n            }\\n        }\\n        if(cnt == 1) return \"-\"+ans;\\n        return ans;\\n    }\\n};\\n```\\n\\n**Please like my solution**\\n**HAPPY CODING**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d) {\\n        int cnt = 0;\\n        if(n == 0) return \"0\";\\n        if(n < 0) cnt++;\\n        if(d < 0) cnt++;\\n        n = abs(n);\\n        d = abs(d);        \\n        long long rem = n%d;\\n        long long q = n/d;\\n        string ans = \"\";\\n        ans += to_string(q);\\n        if(rem == 0) {\\n            if(cnt == 1) return \"-\"+ans;\\n            else return ans;\\n        }\\n        unordered_map<int,int>mp;\\n        ans += \".\";\\n        while(rem != 0){\\n            if(mp.find(rem) != mp.end()){\\n                int len = mp[rem];\\n                string s1 = ans.substr(0,len);\\n                string s2 = ans.substr(len);\\n                ans = s1+\"(\"+s2+\")\";\\n                break;\\n            }\\n            else{\\n                mp[rem] = ans.size();\\n                rem *= 10;\\n                q = rem/d;\\n                rem = rem%d;\\n                ans += to_string(q);\\n            }\\n        }\\n        if(cnt == 1) return \"-\"+ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2209251,
                "title": "cpp-string-map",
                "content": "```\\nstring fractionToDecimal(int num, int den) {\\n\\t//WV recommended\\n\\tbool isNegative = false;\\n\\tint newNum = num;\\n\\tint newDen = den;\\n\\tif (num < 0 or den < 0) {\\n\\t\\tisNegative = true;\\n\\t\\tnewNum = abs(num);\\n\\t\\tnewDen = abs(den);\\n\\t}\\n\\tif (num < 0 and den < 0) {\\n\\t\\t//coz, dono - hai to ek doosre ko cancel kr dege\\n\\t\\tisNegative = false;\\n\\t}\\n\\n\\tstring ans = \"\";\\n\\tlong long quotent = newNum / newDen;\\n\\tlong long rem = newNum % newDen;\\n\\tans += to_string(abs(quotent));\\n\\n\\tif (rem == 0) {\\n\\t\\tif (isNegative and ans != \"0\") {\\n\\t\\t\\tans.insert(0, \"-\");\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\telse { //rem != 0\\n\\t\\tans += \".\"; // decimal lga dia\\n\\t\\tmap<long long, long long> mp; //rem,position(index)\\n\\t\\t// cout << \"test \" << ans << endl;\\n\\t\\twhile (rem != 0) {\\n\\t\\t\\tif (mp.find(rem) != mp.end()) { //found\\n\\t\\t\\t\\t//means remainder repeat hua h, recurring decimal exist(WV). so add \"(\" at position(from map) and \")\" at the end\\n\\t\\t\\t\\tlong long len = mp[rem];\\n\\t\\t\\t\\tans.insert(len, \"(\");\\n\\t\\t\\t\\tans += \")\";\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\telse { //not found\\n\\t\\t\\t\\tmp[rem] = ans.size();\\n\\t\\t\\t\\trem *= 10; //decimal lga hai toh zero add krte h, jaese actual divide krte time krte h(WV)\\n\\t\\t\\t\\tquotent = rem / newDen;\\n\\t\\t\\t\\trem = rem % newDen;\\n\\t\\t\\t\\tans += to_string(abs(quotent));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (isNegative) {\\n\\t\\tcout << \"test \" << ans << endl;\\n\\t\\tans.insert(0, \"-\");\\n\\t}\\n\\treturn ans;\\n}",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nstring fractionToDecimal(int num, int den) {\\n\\t//WV recommended\\n\\tbool isNegative = false;\\n\\tint newNum = num;\\n\\tint newDen = den;\\n\\tif (num < 0 or den < 0) {\\n\\t\\tisNegative = true;\\n\\t\\tnewNum = abs(num);\\n\\t\\tnewDen = abs(den);\\n\\t}\\n\\tif (num < 0 and den < 0) {\\n\\t\\t//coz, dono - hai to ek doosre ko cancel kr dege\\n\\t\\tisNegative = false;\\n\\t}\\n\\n\\tstring ans = \"\";\\n\\tlong long quotent = newNum / newDen;\\n\\tlong long rem = newNum % newDen;\\n\\tans += to_string(abs(quotent));\\n\\n\\tif (rem == 0) {\\n\\t\\tif (isNegative and ans != \"0\") {\\n\\t\\t\\tans.insert(0, \"-\");\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\telse { //rem != 0\\n\\t\\tans += \".\"; // decimal lga dia\\n\\t\\tmap<long long, long long> mp; //rem,position(index)\\n\\t\\t// cout << \"test \" << ans << endl;\\n\\t\\twhile (rem != 0) {\\n\\t\\t\\tif (mp.find(rem) != mp.end()) { //found\\n\\t\\t\\t\\t//means remainder repeat hua h, recurring decimal exist(WV). so add \"(\" at position(from map) and \")\" at the end\\n\\t\\t\\t\\tlong long len = mp[rem];\\n\\t\\t\\t\\tans.insert(len, \"(\");\\n\\t\\t\\t\\tans += \")\";\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\telse { //not found\\n\\t\\t\\t\\tmp[rem] = ans.size();\\n\\t\\t\\t\\trem *= 10; //decimal lga hai toh zero add krte h, jaese actual divide krte time krte h(WV)\\n\\t\\t\\t\\tquotent = rem / newDen;\\n\\t\\t\\t\\trem = rem % newDen;\\n\\t\\t\\t\\tans += to_string(abs(quotent));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (isNegative) {\\n\\t\\tcout << \"test \" << ans << endl;\\n\\t\\tans.insert(0, \"-\");\\n\\t}\\n\\treturn ans;\\n}",
                "codeTag": "C++"
            },
            {
                "id": 1387484,
                "title": "java-using-hashmap-faster-than-100",
                "content": "class Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        \\n        if (numerator==0) return \"0\";\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        //negative case\\n        if (numerator>0 && denominator<0 || numerator<0 && denominator>0) {\\n            sb.append(\"-\");\\n        }\\n        \\n        long x = Math.abs(Long.valueOf(numerator));\\n        long y = Math.abs(Long.valueOf(denominator));\\n        \\n        sb.append(String.valueOf(x/y));\\n        \\n        long remainder = x%y;\\n        if (remainder==0) {\\n            return sb.toString();\\n        }\\n        \\n        //decimal case\\n        sb.append(\".\");\\n\\t\\t\\n\\t\\t//store the remainder in a Hashmap because in the case of recurring decimal, the remainder repeats as dividend.\\n        Map<Long,Integer> map = new HashMap<>();\\n        while (remainder != 0) {\\n            if (map.containsKey(remainder)){\\n                sb.insert(map.get(remainder), \"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n\\t\\t\\t//store the remainder and the index of it\\'s occurence in the String\\n            map.put(remainder, sb.length());\\n            remainder *= 10;\\n            sb.append(String.valueOf(remainder/y));\\n            remainder %= y;\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        \\n        if (numerator==0) return \"0\";\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        //negative case\\n        if (numerator>0 && denominator<0 || numerator<0 && denominator>0) {\\n            sb.append(\"-\");\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1261844,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(long numerator, long denominator) {\\n        if (numerator == 0) return \"0\";\\n        \\n        bool negative = numerator<0 ^ denominator<0;\\n        numerator = abs(numerator);\\n        denominator = abs(denominator);\\n        \\n        string integer = (negative?\"-\":\"\") + to_string(numerator/denominator);\\n        numerator %= denominator;\\n        \\n        unordered_map<int, int> seen;\\n        string decimal = \".\";\\n        while (numerator != 0) {\\n            numerator *= 10;\\n            decimal += to_string(numerator/denominator);\\n            numerator %= denominator;\\n            if (seen[numerator]) {\\n                decimal.insert(seen[numerator], \"(\");\\n                decimal += \")\";\\n                break;\\n            }\\n            seen[numerator] = decimal.size();\\n        }\\n        \\n        if (decimal.size() == 1) return integer;\\n        else return integer + decimal;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(long numerator, long denominator) {\\n        if (numerator == 0) return \"0\";\\n        \\n        bool negative = numerator<0 ^ denominator<0;\\n        numerator = abs(numerator);\\n        denominator = abs(denominator);\\n        \\n        string integer = (negative?\"-\":\"\") + to_string(numerator/denominator);\\n        numerator %= denominator;\\n        \\n        unordered_map<int, int> seen;\\n        string decimal = \".\";\\n        while (numerator != 0) {\\n            numerator *= 10;\\n            decimal += to_string(numerator/denominator);\\n            numerator %= denominator;\\n            if (seen[numerator]) {\\n                decimal.insert(seen[numerator], \"(\");\\n                decimal += \")\";\\n                break;\\n            }\\n            seen[numerator] = decimal.size();\\n        }\\n        \\n        if (decimal.size() == 1) return integer;\\n        else return integer + decimal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833246,
                "title": "simple-java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        long num = numerator;\\n        long deno = denominator;\\n        boolean negtive = (double)num/deno < 0 ? true:false;\\n        num = Math.abs(num);\\n        deno = Math.abs(deno);\\n        String res = negtive? \"-\"+num/deno : num/deno+\"\";\\n        if(num % deno == 0) \\n            return res;\\n        String decimal = \"\";\\n        num = (num % deno) * 10;\\n        HashMap<Long, Integer> mods = new HashMap();\\n        int index = 0;\\n        while(!mods.containsKey(num) && num != 0){\\n            mods.put(num, index++);\\n            decimal += num/deno;\\n            num = (num % deno) * 10;\\n        }\\n        if(num == 0) return res+\".\"+decimal;\\n        int i = mods.get(num);\\n        res += \".\" + decimal.substring(0, i) + \"(\" + decimal.substring(i) + \")\";\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        long num = numerator;\\n        long deno = denominator;\\n        boolean negtive = (double)num/deno < 0 ? true:false;\\n        num = Math.abs(num);\\n        deno = Math.abs(deno);\\n        String res = negtive? \"-\"+num/deno : num/deno+\"\";\\n        if(num % deno == 0) \\n            return res;\\n        String decimal = \"\";\\n        num = (num % deno) * 10;\\n        HashMap<Long, Integer> mods = new HashMap();\\n        int index = 0;\\n        while(!mods.containsKey(num) && num != 0){\\n            mods.put(num, index++);\\n            decimal += num/deno;\\n            num = (num % deno) * 10;\\n        }\\n        if(num == 0) return res+\".\"+decimal;\\n        int i = mods.get(num);\\n        res += \".\" + decimal.substring(0, i) + \"(\" + decimal.substring(i) + \")\";\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793983,
                "title": "c-beats-100-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator == 0 || denominator == 0) {\\n            return \"0\";\\n        }\\n        \\n        long num = labs(numerator);\\n        long den = labs(denominator);\\n        \\n        string cur = \"\";\\n        \\n        if(numerator < 0 ^ denominator < 0) {\\n            cur += \"-\";\\n        }\\n        \\n        cur += to_string(num / den);\\n        \\n        if(num % den == 0) {\\n            return cur;\\n        }\\n        num %= den;\\n        \\n        cur += \".\";\\n        \\n        \\n        unordered_map<long, int> seen;\\n        \\n        while(num > 0) {\\n            if(seen.find(num) != seen.end()) {\\n                cur.insert(seen[num], 1, \\'(\\');\\n                cur += \")\";\\n                return cur;\\n            }\\n            \\n            seen[num] = cur.size();\\n            num *= 10;\\n            cur += to_string(num / den);\\n            num %= den;\\n        }\\n        \\n        return cur;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator == 0 || denominator == 0) {\\n            return \"0\";\\n        }\\n        \\n        long num = labs(numerator);\\n        long den = labs(denominator);\\n        \\n        string cur = \"\";\\n        \\n        if(numerator < 0 ^ denominator < 0) {\\n            cur += \"-\";\\n        }\\n        \\n        cur += to_string(num / den);\\n        \\n        if(num % den == 0) {\\n            return cur;\\n        }\\n        num %= den;\\n        \\n        cur += \".\";\\n        \\n        \\n        unordered_map<long, int> seen;\\n        \\n        while(num > 0) {\\n            if(seen.find(num) != seen.end()) {\\n                cur.insert(seen[num], 1, \\'(\\');\\n                cur += \")\";\\n                return cur;\\n            }\\n            \\n            seen[num] = cur.size();\\n            num *= 10;\\n            cur += to_string(num / den);\\n            num %= den;\\n        }\\n        \\n        return cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51200,
                "title": "my-python-code-without-using-extra-space",
                "content": "The idea is pretty simple, the question is essentially the same with \"Find the start point of a linked list cycle\". I used the fast pointer and slow pointer trick.\\nBelow is my code with some explanation:\\n\\n    def fractionToDecimal(self, numerator, denominator):\\n        n = numerator\\n        d = denominator\\n        if n % d == 0:\\n            return str(n//d)\\n        # Deal with negatives\\n        if (abs(n)/n) * (abs(d)/d) < 0:\\n            res = '-'\\n            n = abs(n)\\n            d = abs(d)\\n        else:\\n            res = ''\\n        # Integer part\\n        res = res + str(n//d) + '.'\\n        n = n % d\\n        # Start point of the \"list\"\\n        frem = n\\n        srem = n\\n        firstTime = True\\n        while frem != 0 and not (firstTime == False and frem == srem):\\n            firstTime = False\\n            srem = (srem * 10) % d\\n            frem = (frem * 10) % d\\n            if frem:\\n                frem = (frem * 10) % d\\n        # The fast pointer encounters a remainder of 0, so no cycle in the \"list\"\\n        if frem == 0:\\n            res += str((n * 10) // d)\\n            rem = (n * 10) % d\\n            while rem:\\n                res += str((rem * 10) // d)\\n                rem = (rem * 10) % d\\n            return res\\n        else:\\n            # Find the start point of the cycle, meanwhile, generate the non recurring part\\n            srem = n\\n            while frem != srem:\\n                res += str((srem * 10) // d)\\n                srem = (srem * 10) % d\\n                frem = (frem * 10) % d\\n            res += '('\\n            # Generate the recurring part\\n            firstTime = True\\n            while not (firstTime == False and srem == frem):\\n                firstTime = False\\n                res += str((srem * 10) // d)\\n                srem = (srem * 10) % d\\n            res += ')'\\n            return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "The idea is pretty simple, the question is essentially the same with \"Find the start point of a linked list cycle\". I used the fast pointer and slow pointer trick.\\nBelow is my code with some explanation:\\n\\n    def fractionToDecimal(self, numerator, denominator):\\n        n = numerator\\n        d = denominator\\n        if n % d == 0:\\n            return str(n//d)\\n        # Deal with negatives\\n        if (abs(n)/n) * (abs(d)/d) < 0:\\n            res = '-'\\n            n = abs(n)\\n            d = abs(d)\\n        else:\\n            res = ''\\n        # Integer part\\n        res = res + str(n//d) + '.'\\n        n = n % d\\n        # Start point of the \"list\"\\n        frem = n\\n        srem = n\\n        firstTime = True\\n        while frem != 0 and not (firstTime == False and frem == srem):\\n            firstTime = False\\n            srem = (srem * 10) % d\\n            frem = (frem * 10) % d\\n            if frem:\\n                frem = (frem * 10) % d\\n        # The fast pointer encounters a remainder of 0, so no cycle in the \"list\"\\n        if frem == 0:\\n            res += str((n * 10) // d)\\n            rem = (n * 10) % d\\n            while rem:\\n                res += str((rem * 10) // d)\\n                rem = (rem * 10) % d\\n            return res\\n        else:\\n            # Find the start point of the cycle, meanwhile, generate the non recurring part\\n            srem = n\\n            while frem != srem:\\n                res += str((srem * 10) // d)\\n                srem = (srem * 10) % d\\n                frem = (frem * 10) % d\\n            res += '('\\n            # Generate the recurring part\\n            firstTime = True\\n            while not (firstTime == False and srem == frem):\\n                firstTime = False\\n                res += str((srem * 10) // d)\\n                srem = (srem * 10) % d\\n            res += ')'\\n            return res",
                "codeTag": "Python3"
            },
            {
                "id": 51228,
                "title": "my-java-solution",
                "content": "basic idea:\\n\\n1. for the input integer: positive and negative number matters? => yes, so check the sign first\\n\\n2. can get integer part directly by a/b, then deal with decimal part\\n\\n3. get remainder by a%b. the problem is: how to check the decimal part is repeated (or not)?\\n\\n4. for each loop, we can get the digit by remainder*10/b and update new remainder=remainder*10%b, if we get the same remainder again, previous result is repeated\\n\\n5. so, use a set to store the remainder(s) that already appeared and use queue to store int sequence that need to append to res\\n\\n6. check remainder for each loop, if 0, poll all elem in queue, if set contains the remainder (q...)\\n\\n7. but... the question comes again: example, if result is 0.123454545 or 1/7 = 0.123454545, need a parameter to store which digit the res starts to repeat.. extra info is needed when we store the remainder to \"locate\" its position\\n\\n8. back to step 5, define the map instead of set to store <remainder, position> position=i (each loop i++)\\n\\t\\n9. at last, check the remainder to know whether it's belong to \"recurring\" result or not\\n\\n\\n        public static String fractionToDecimal(int numerator, int denominator) {\\n    \\t\\tString res = \"\";\\n    \\t\\tlong a = Math.abs((long) numerator);\\n    \\t\\tlong b = Math.abs((long) denominator);\\n    \\t\\tif ((denominator < 0 && numerator > 0) || (denominator > 0 && numerator < 0)) {\\n    \\t\\t\\tres += \"-\";\\n    \\t\\t}\\n    \\t\\tlong intPart= a / b;\\n    \\t\\tres += intPart;\\n    \\t\\tif (a % b == 0) {\\n    \\t\\t\\treturn res;\\n    \\t\\t}\\n    \\t\\tres += \".\";\\n    \\t\\tlong remainder = a % b;\\n    \\t\\tHashMap<Long, Integer> map = new HashMap<Long, Integer>();\\n    \\t\\tint i = 1;\\n    \\t\\tmap.put(remainder, 1);\\n    \\t\\tQueue<Long> queue = new LinkedList<Long>();\\n    \\t\\tint begin = -1;\\n    \\t\\twhile (remainder != 0) {\\n    \\t\\t\\ti++;\\n    \\t\\t\\tlong tmp = remainder * 10 / b;\\n    \\t\\t\\tremainder = remainder * 10 % b;\\n    \\t\\t\\tif (map.containsKey(remainder)) {\\n    \\t\\t\\t\\tbegin = map.get(remainder);\\n    \\t\\t\\t\\tqueue.offer(tmp);\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tmap.put(remainder, i);\\n    \\t\\t\\t\\tqueue.offer(tmp);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tif (remainder == 0) {\\n    \\t\\t\\twhile (!queue.isEmpty()) {\\n    \\t\\t\\t\\tres += queue.poll();\\n    \\t\\t\\t}\\n    \\t\\t} else {\\n    \\t\\t\\tint j = 1;\\n    \\t\\t\\twhile (!queue.isEmpty()) {\\n    \\t\\t\\t\\tlong cur = queue.poll();\\n    \\t\\t\\t\\tif (j != begin) {\\n    \\t\\t\\t\\t\\tres += cur;\\n    \\t\\t\\t\\t} else {\\n    \\t\\t\\t\\t\\tres = res + \"(\" + cur;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tj++;\\n    \\t\\t\\t}\\n    \\t\\t\\tres += \")\";\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\t}\\n\\na little optimization can be done: define stringbuilder as the result",
                "solutionTags": [
                    "Java"
                ],
                "code": "basic idea:\\n\\n1. for the input integer: positive and negative number matters? => yes, so check the sign first\\n\\n2. can get integer part directly by a/b, then deal with decimal part\\n\\n3. get remainder by a%b. the problem is: how to check the decimal part is repeated (or not)?\\n\\n4. for each loop, we can get the digit by remainder*10/b and update new remainder=remainder*10%b, if we get the same remainder again, previous result is repeated\\n\\n5. so, use a set to store the remainder(s) that already appeared and use queue to store int sequence that need to append to res\\n\\n6. check remainder for each loop, if 0, poll all elem in queue, if set contains the remainder (q...)\\n\\n7. but... the question comes again: example, if result is 0.123454545 or 1/7 = 0.123454545, need a parameter to store which digit the res starts to repeat.. extra info is needed when we store the remainder to \"locate\" its position\\n\\n8. back to step 5, define the map instead of set to store <remainder, position> position=i (each loop i++)\\n\\t\\n9. at last, check the remainder to know whether it's belong to \"recurring\" result or not\\n\\n\\n        public static String fractionToDecimal(int numerator, int denominator) {\\n    \\t\\tString res = \"\";\\n    \\t\\tlong a = Math.abs((long) numerator);\\n    \\t\\tlong b = Math.abs((long) denominator);\\n    \\t\\tif ((denominator < 0 && numerator > 0) || (denominator > 0 && numerator < 0)) {\\n    \\t\\t\\tres += \"-\";\\n    \\t\\t}\\n    \\t\\tlong intPart= a / b;\\n    \\t\\tres += intPart;\\n    \\t\\tif (a % b == 0) {\\n    \\t\\t\\treturn res;\\n    \\t\\t}\\n    \\t\\tres += \".\";\\n    \\t\\tlong remainder = a % b;\\n    \\t\\tHashMap<Long, Integer> map = new HashMap<Long, Integer>();\\n    \\t\\tint i = 1;\\n    \\t\\tmap.put(remainder, 1);\\n    \\t\\tQueue<Long> queue = new LinkedList<Long>();\\n    \\t\\tint begin = -1;\\n    \\t\\twhile (remainder != 0) {\\n    \\t\\t\\ti++;\\n    \\t\\t\\tlong tmp = remainder * 10 / b;\\n    \\t\\t\\tremainder = remainder * 10 % b;\\n    \\t\\t\\tif (map.containsKey(remainder)) {\\n    \\t\\t\\t\\tbegin = map.get(remainder);\\n    \\t\\t\\t\\tqueue.offer(tmp);\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tmap.put(remainder, i);\\n    \\t\\t\\t\\tqueue.offer(tmp);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tif (remainder == 0) {\\n    \\t\\t\\twhile (!queue.isEmpty()) {\\n    \\t\\t\\t\\tres += queue.poll();\\n    \\t\\t\\t}\\n    \\t\\t} else {\\n    \\t\\t\\tint j = 1;\\n    \\t\\t\\twhile (!queue.isEmpty()) {\\n    \\t\\t\\t\\tlong cur = queue.poll();\\n    \\t\\t\\t\\tif (j != begin) {\\n    \\t\\t\\t\\t\\tres += cur;\\n    \\t\\t\\t\\t} else {\\n    \\t\\t\\t\\t\\tres = res + \"(\" + cur;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tj++;\\n    \\t\\t\\t}\\n    \\t\\t\\tres += \")\";\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\t}\\n\\na little optimization can be done: define stringbuilder as the result",
                "codeTag": "Unknown"
            },
            {
                "id": 3472668,
                "title": "c-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires converting a fraction to a decimal representation. If the decimal representation is finite, then the output is simply the quotient of the numerator and denominator. Otherwise, we need to represent the repeating decimal with a set of parentheses. We can detect the repeating part by using a hash table to keep track of the remainders and the corresponding position of the quotient where the remainder appears.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start by checking if the numerator or denominator is negative. If both are negative, then we convert them to positive. We then calculate the quotient of the numerator and denominator using the integer division. If the remainder is 0, then the output is simply the quotient.\\n\\nIf the remainder is non-zero, we append a decimal point to the quotient and calculate the fractional part. We keep track of the remainders and corresponding positions of the quotient where the remainders appear. If we encounter a remainder that we have seen before, we know that the decimal expansion repeats. We can then insert the opening and closing parentheses around the repeating part of the quotient.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the algorithm is $$O(d)$$, where d is the number of digits in the repeating part of the decimal expansion. This is because we need to perform integer division and multiplication for each digit in the decimal expansion.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the algorithm is $$O(d)$$, where d is the number of digits in the repeating part of the decimal expansion. This is because we need to store the remainders and corresponding positions of the quotient where the remainders appear in a hash table.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) \\n    {\\n        unordered_map<long long,int>q;    \\n        long long ne = numerator,de = denominator;\\n        if(numerator <0 && denominator < 0)\\n        {\\n            ne = abs(numerator),de = abs(denominator);\\n        }\\n       \\n        string ans = to_string(ne/de);\\n        int pi = ans.size();\\n        ans += \\'.\\';\\n        if(ne%de == 0)\\n        {\\n            ans.pop_back();\\n            return ans;\\n        }\\n\\n        q[ne%de] = 1;\\n        long long temp = ne%de;\\n        int n = 0;\\n        while(q.size())\\n        {\\n            q[temp] = ++n;\\n            temp *= 10;\\n           ans += to_string(abs(temp/de));\\n           temp = temp % de;\\n\\n           if(temp == 0)\\n           {\\n               return ans;\\n           }\\n           else if(q.find(temp) != q.end())\\n           {\\n               ans.push_back(\\')\\');\\n               int ac = q[temp];\\n               ans =  ans.substr(0,pi+ac) + \\'(\\' + ans.substr(pi+ac);\\n               if(de < 0 || ne < 0)\\n               {\\n                   ans = \\'-\\'+ans;\\n               }\\n               return ans;\\n           }\\n        } \\n\\n        return \"\";                  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) \\n    {\\n        unordered_map<long long,int>q;    \\n        long long ne = numerator,de = denominator;\\n        if(numerator <0 && denominator < 0)\\n        {\\n            ne = abs(numerator),de = abs(denominator);\\n        }\\n       \\n        string ans = to_string(ne/de);\\n        int pi = ans.size();\\n        ans += \\'.\\';\\n        if(ne%de == 0)\\n        {\\n            ans.pop_back();\\n            return ans;\\n        }\\n\\n        q[ne%de] = 1;\\n        long long temp = ne%de;\\n        int n = 0;\\n        while(q.size())\\n        {\\n            q[temp] = ++n;\\n            temp *= 10;\\n           ans += to_string(abs(temp/de));\\n           temp = temp % de;\\n\\n           if(temp == 0)\\n           {\\n               return ans;\\n           }\\n           else if(q.find(temp) != q.end())\\n           {\\n               ans.push_back(\\')\\');\\n               int ac = q[temp];\\n               ans =  ans.substr(0,pi+ac) + \\'(\\' + ans.substr(pi+ac);\\n               if(de < 0 || ne < 0)\\n               {\\n                   ans = \\'-\\'+ans;\\n               }\\n               return ans;\\n           }\\n        } \\n\\n        return \"\";                  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111158,
                "title": "o-n-beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFractions are repeated due to recurring numerator and denominator\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSave the numerator encounterd along with its posistion in the remainder string when it was encountered. When the remainder is found in hash map. Just break and add brances to the string in beetween\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    10^4  (O(n))      *             O(1)             +     O(N)\\n    MAX_STR_LENGTH    *   HASH SEARCH FOR REMAINDER  +  STRING COPY\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n    O(N)          +    2 * O(N)       + c\\n    (HASH MAP)    +     STRINGS\\n\\nOne can optimize by using single string and soing string manipulations at the end\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        std::string ans;\\n        std::string final_ans; \\n        if((numerator<0&&denominator>0) ||(numerator>0&&denominator<0))\\n        {\\n        ans.append(\"-\");\\n        }\\n        long int d= abs(denominator);\\n        long int n=abs(numerator);\\n        \\n        ans = ans+std::to_string((long int)(n/d));\\n        std::unordered_map<long,int> m;\\n        long int remainder = n%d;\\n        if(remainder!=0)\\n        {\\n            ans.append(\".\");\\n            while(ans.size()<10001)\\n            {\\n                if(remainder ==0 ||m.find(remainder)!=m.end())\\n                {\\n                    break;\\n                }\\n                m[remainder] = ans.size();\\n                long int t= (remainder*10)/d;\\n                ans.append(std::to_string(t));\\n                remainder = (remainder*10)%d;\\n            }\\n            if(m.find(remainder)!=m.end())\\n            {\\n                final_ans = ans.substr(0,m[remainder]) \\n                + \"(\"+\\n                ans.substr(m[remainder])\\n                +\")\";\\n            }\\n            else{\\n                final_ans = ans;\\n            }\\n        }\\n        else\\n        final_ans = ans;\\n        return final_ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        std::string ans;\\n        std::string final_ans; \\n        if((numerator<0&&denominator>0) ||(numerator>0&&denominator<0))\\n        {\\n        ans.append(\"-\");\\n        }\\n        long int d= abs(denominator);\\n        long int n=abs(numerator);\\n        \\n        ans = ans+std::to_string((long int)(n/d));\\n        std::unordered_map<long,int> m;\\n        long int remainder = n%d;\\n        if(remainder!=0)\\n        {\\n            ans.append(\".\");\\n            while(ans.size()<10001)\\n            {\\n                if(remainder ==0 ||m.find(remainder)!=m.end())\\n                {\\n                    break;\\n                }\\n                m[remainder] = ans.size();\\n                long int t= (remainder*10)/d;\\n                ans.append(std::to_string(t));\\n                remainder = (remainder*10)%d;\\n            }\\n            if(m.find(remainder)!=m.end())\\n            {\\n                final_ans = ans.substr(0,m[remainder]) \\n                + \"(\"+\\n                ans.substr(m[remainder])\\n                +\")\";\\n            }\\n            else{\\n                final_ans = ans;\\n            }\\n        }\\n        else\\n        final_ans = ans;\\n        return final_ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746780,
                "title": "like-pen-paper-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, nu: int, de: int) -> str:\\n        cf=\"\"\\n        if(nu*de<0):\\n            cf=\"-\"\\n        nu=abs(nu)\\n        de=abs(de)\\n        st1=nu//de\\n        re=abs(nu%de)\\n        st1=str(st1)\\n        st2=\"\"\\n        i=0\\n        dc={}\\n        while(re>0):\\n            if(re<de):\\n                re*=10\\n            if((re,de) in dc):\\n                st2=st2[:dc[(re,de)]]+\"(\"+st2[dc[(re,de)]:]+\")\"\\n                break\\n            dc[(re,de)]=i\\n            i+=1\\n            st2+=str(re//de)\\n            re=re%de\\n        if(st2==\"\"):\\n            return cf+st1\\n        return(cf+st1+\".\"+st2)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, nu: int, de: int) -> str:\\n        cf=\"\"\\n        if(nu*de<0):\\n            cf=\"-\"\\n        nu=abs(nu)\\n        de=abs(de)\\n        st1=nu//de\\n        re=abs(nu%de)\\n        st1=str(st1)\\n        st2=\"\"\\n        i=0\\n        dc={}\\n        while(re>0):\\n            if(re<de):\\n                re*=10\\n            if((re,de) in dc):\\n                st2=st2[:dc[(re,de)]]+\"(\"+st2[dc[(re,de)]:]+\")\"\\n                break\\n            dc[(re,de)]=i\\n            i+=1\\n            st2+=str(re//de)\\n            re=re%de\\n        if(st2==\"\"):\\n            return cf+st1\\n        return(cf+st1+\".\"+st2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419439,
                "title": "c-taking-care-of-minor-edge-cases",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d) {\\n        if(n==0)    return \"0\";\\n        if(d==1)    return to_string(n);\\n        if(d==-1)    return to_string((long)fabs(n));\\n        string ans=\"\";\\n        if((n<0 && d>0) || (n>0 && d<0))    ans += \"-\";\\n        n = abs(n);\\n        d = abs(d);\\n        ans += to_string(n/d);\\n        long long rem = n%d;\\n        if(!rem)    return ans;\\n        else    ans += \".\";\\n        unordered_map<int,int>num;\\n        while(rem!=0)\\n        {\\n            if(num.find(rem)!=num.end())    \\n            {\\n                ans.insert(num[rem],\"(\");\\n                ans += \")\";\\n                return ans;\\n            }\\n            num[rem] = ans.length();\\n            rem *= 10;\\n            ans += to_string(rem/d);\\n            rem %= d;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d) {\\n        if(n==0)    return \"0\";\\n        if(d==1)    return to_string(n);\\n        if(d==-1)    return to_string((long)fabs(n));\\n        string ans=\"\";\\n        if((n<0 && d>0) || (n>0 && d<0))    ans += \"-\";\\n        n = abs(n);\\n        d = abs(d);\\n        ans += to_string(n/d);\\n        long long rem = n%d;\\n        if(!rem)    return ans;\\n        else    ans += \".\";\\n        unordered_map<int,int>num;\\n        while(rem!=0)\\n        {\\n            if(num.find(rem)!=num.end())    \\n            {\\n                ans.insert(num[rem],\"(\");\\n                ans += \")\";\\n                return ans;\\n            }\\n            num[rem] = ans.length();\\n            rem *= 10;\\n            ans += to_string(rem/d);\\n            rem %= d;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894376,
                "title": "26ms-python-efficient-easy-to-understand-solution",
                "content": "Please Upvote if you like it....\\n```\\nclass Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        \"\"\"\\n        :type numerator: int\\n        :type denominator: int\\n        :rtype: str\\n        \"\"\"\\n        ansmaker = \"\"\\n        if numerator == 0:\\n            return \"0\"\\n        if numerator<0 and denominator<0:\\n            numerator = -1*numerator\\n            denominator = -1*denominator\\n        elif numerator<0 and denominator>=0:\\n            numerator = -1*numerator\\n            ansmaker= \"-\"\\n        elif numerator>=0 and denominator<0:\\n            denominator = -1* denominator\\n            ansmaker = \"-\"\\n        dict1 = {}\\n        q = numerator//denominator\\n        r = numerator%denominator\\n        # print(q,r)\\n        if r == 0:\\n            return(ansmaker + str(q))\\n        else:\\n            ans = ansmaker+ str(q) + \".\"\\n        while True:\\n            if r == 0:\\n                return ans\\n            if r in dict1:\\n                sl = dict1[r]\\n                ans = ans[:sl] + \"(\" + ans[sl:] + \")\"\\n                return ans\\n            dict1[r] = len(ans)\\n            r = r*10\\n            q = r//denominator\\n            r = r%denominator\\n            ans = ans+str(q)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        \"\"\"\\n        :type numerator: int\\n        :type denominator: int\\n        :rtype: str\\n        \"\"\"\\n        ansmaker = \"\"\\n        if numerator == 0:\\n            return \"0\"\\n        if numerator<0 and denominator<0:\\n            numerator = -1*numerator\\n            denominator = -1*denominator\\n        elif numerator<0 and denominator>=0:\\n            numerator = -1*numerator\\n            ansmaker= \"-\"\\n        elif numerator>=0 and denominator<0:\\n            denominator = -1* denominator\\n            ansmaker = \"-\"\\n        dict1 = {}\\n        q = numerator//denominator\\n        r = numerator%denominator\\n        # print(q,r)\\n        if r == 0:\\n            return(ansmaker + str(q))\\n        else:\\n            ans = ansmaker+ str(q) + \".\"\\n        while True:\\n            if r == 0:\\n                return ans\\n            if r in dict1:\\n                sl = dict1[r]\\n                ans = ans[:sl] + \"(\" + ans[sl:] + \")\"\\n                return ans\\n            dict1[r] = len(ans)\\n            r = r*10\\n            q = r//denominator\\n            r = r%denominator\\n            ans = ans+str(q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856027,
                "title": "java-convert-to-long",
                "content": "Double is not precise enough to be used for this question, so we will have to resort to elementary school math division. \\n\\nTo handle annoying edge cases, just convert it to long before we do anything.\\n\\n```Java\\nclass Solution {\\n    public String fractionToDecimal(int n, int d) {\\n        long x = Math.abs(n*1L), y = Math.abs(d*1L);\\n        StringBuilder sb = new StringBuilder();\\n        if (n < 0 && d > 0 || n > 0 && d < 0){\\n            sb.append(\\'-\\'); // append \\'-\\' if one of n or d is negative.\\n        }\\n\\n        Map<Long, Integer> map = new HashMap<>();\\n        sb.append(x / y);\\n        x %= y;\\n        if (x > 0){ // only append \\'.\\' when we have reminder.\\n            sb.append(\\'.\\');\\n        }\\n        while(!map.containsKey(x)){ // keep doing division until we find a cycle\\n            map.put(x, map.size());\\n            x *= 10;\\n            if (x > 0){\\n                sb.append(x / y);\\n            }\\n            x %= y;\\n        }\\n\\n        if (x > 0){ // only append \\'()\\' when there is a cycle.\\n            sb.insert(sb.length() - (map.size() - map.get(x)), \\'(\\');\\n            sb.append(\\')\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public String fractionToDecimal(int n, int d) {\\n        long x = Math.abs(n*1L), y = Math.abs(d*1L);\\n        StringBuilder sb = new StringBuilder();\\n        if (n < 0 && d > 0 || n > 0 && d < 0){\\n            sb.append(\\'-\\'); // append \\'-\\' if one of n or d is negative.\\n        }\\n\\n        Map<Long, Integer> map = new HashMap<>();\\n        sb.append(x / y);\\n        x %= y;\\n        if (x > 0){ // only append \\'.\\' when we have reminder.\\n            sb.append(\\'.\\');\\n        }\\n        while(!map.containsKey(x)){ // keep doing division until we find a cycle\\n            map.put(x, map.size());\\n            x *= 10;\\n            if (x > 0){\\n                sb.append(x / y);\\n            }\\n            x %= y;\\n        }\\n\\n        if (x > 0){ // only append \\'()\\' when there is a cycle.\\n            sb.insert(sb.length() - (map.size() - map.get(x)), \\'(\\');\\n            sb.append(\\')\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774976,
                "title": "fraction-to-recurring-decimal-solution-java",
                "content": "class Solution {\\n  public String fractionToDecimal(int numerator, int denominator) {\\n    if (numerator == 0)\\n      return \"0\";\\n\\n    StringBuilder sb = new StringBuilder();\\n\\n    if (numerator < 0 ^ denominator < 0)\\n      sb.append(\"-\");\\n\\n    long n = Math.abs((long) numerator);\\n    long d = Math.abs((long) denominator);\\n    sb.append(n / d);\\n\\n    if (n % d == 0)\\n      return sb.toString();\\n\\n    sb.append(\".\");\\n    Map<Long, Integer> seen = new HashMap<>();\\n\\n    for (long r = n % d; r > 0; r %= d) {\\n      if (seen.containsKey(r)) {\\n        sb.insert(seen.get(r), \"(\");\\n        sb.append(\")\");\\n        break;\\n      }\\n      seen.put(r, sb.length());\\n      r *= 10;\\n      sb.append(r / d);\\n    }\\n\\n    return sb.toString();\\n  }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n  public String fractionToDecimal(int numerator, int denominator) {\\n    if (numerator == 0)\\n      return \"0\";\\n\\n    StringBuilder sb = new StringBuilder();\\n\\n    if (numerator < 0 ^ denominator < 0)\\n      sb.append(\"-\");\\n\\n    long n = Math.abs((long) numerator);\\n    long d = Math.abs((long) denominator);\\n    sb.append(n / d);\\n\\n    if (n % d == 0)\\n      return sb.toString();\\n\\n    sb.append(\".\");\\n    Map<Long, Integer> seen = new HashMap<>();\\n\\n    for (long r = n % d; r > 0; r %= d) {\\n      if (seen.containsKey(r)) {\\n        sb.insert(seen.get(r), \"(\");\\n        sb.append(\")\");\\n        break;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1744021,
                "title": "python-beginner-with-explanation",
                "content": "1. We get if the sign of answer we will return. if sign is true final answer will be positive else negative\\n2. then we do integer division of the given numerator with the given denominator \\n3. if the remainder is zero we return the answer using the sign we calculated\\n4. if remainder is not zero we append \".\" to the ans array and then keep trach of the remainder we will get each time we divide the coming remainder in a hashmap with the value of the place where we will need to insert the \"(\". \\n5. if we find such remainder value repeat we insert \"(\" at the required index and append \")\" at the last of the array and then return thr answer according to the sign we calculated\\nUPVOTE IF HELPFUL\\n```\\ndef fractionToDecimal(self, num: int, den: int) -> str:\\n        ans = []\\n        \\n        if (num >= 0 and den >= 0) or (num <= 0 and den <= 0):\\n            sign = True\\n        else:\\n            sign = False\\n        \\n        num = abs(num)\\n        den = abs(den)\\n        \\n        q = num // den\\n        r = num % den\\n        \\n        ans.append(q)\\n\\n        if r == 0:\\n            return \"\".join(map(str, ans)) if sign else \"-\" + \"\".join(map(str, ans))\\n        else:\\n            ans.append(\".\")\\n            map1 = {}\\n            while r != 0:\\n                if r in map1:\\n                    ans.insert(map1[r], \"(\")\\n                    ans.append(\")\")\\n                    break\\n                else:\\n                    map1[r] = len(ans)\\n                    r *= 10\\n                    q = r // den\\n                    r %= den\\n                    ans.append(q)\\n        \\n        \\n        return \"\".join(map(str, ans)) if sign else \"-\" + \"\".join(map(str, ans))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef fractionToDecimal(self, num: int, den: int) -> str:\\n        ans = []\\n        \\n        if (num >= 0 and den >= 0) or (num <= 0 and den <= 0):\\n            sign = True\\n        else:\\n            sign = False\\n        \\n        num = abs(num)\\n        den = abs(den)\\n        \\n        q = num // den\\n        r = num % den\\n        \\n        ans.append(q)\\n\\n        if r == 0:\\n            return \"\".join(map(str, ans)) if sign else \"-\" + \"\".join(map(str, ans))\\n        else:\\n            ans.append(\".\")\\n            map1 = {}\\n            while r != 0:\\n                if r in map1:\\n                    ans.insert(map1[r], \"(\")\\n                    ans.append(\")\")\\n                    break\\n                else:\\n                    map1[r] = len(ans)\\n                    r *= 10\\n                    q = r // den\\n                    r %= den\\n                    ans.append(q)\\n        \\n        \\n        return \"\".join(map(str, ans)) if sign else \"-\" + \"\".join(map(str, ans))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1535423,
                "title": "python-clean-solution",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0: return \"0\"\\n        sign = bool(numerator > 0) ^ bool(denominator > 0)\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        res = (\"-\" if sign else \"\") + str(numerator//denominator)\\n        remainder = numerator % denominator\\n        \\n        if remainder == 0: return res\\n\\n        res += \".\"\\n        pos = {}\\n        while remainder != 0:\\n            if remainder not in pos:\\n                pos[remainder] = len(res)\\n            else:\\n                res = res[:pos[remainder]] + \"(\" + res[pos[remainder]:] + \")\"\\n                return res\\n                \\n            res += str(remainder * 10 // denominator)\\n            remainder = (remainder * 10) % denominator\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0: return \"0\"\\n        sign = bool(numerator > 0) ^ bool(denominator > 0)\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        res = (\"-\" if sign else \"\") + str(numerator//denominator)\\n        remainder = numerator % denominator\\n        \\n        if remainder == 0: return res\\n\\n        res += \".\"\\n        pos = {}\\n        while remainder != 0:\\n            if remainder not in pos:\\n                pos[remainder] = len(res)\\n            else:\\n                res = res[:pos[remainder]] + \"(\" + res[pos[remainder]:] + \")\"\\n                return res\\n                \\n            res += str(remainder * 10 // denominator)\\n            remainder = (remainder * 10) % denominator\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401382,
                "title": "js-using-hashmap-with-explanation-in-the-comments",
                "content": "```\\nvar fractionToDecimal = function(numerator, denominator) {\\n    if(numerator === 0) {\\n        return \\'0\\';\\n    }\\n\\t// check if the result should be negative or not\\n    const isNeg = (numerator < 0 && denominator > 0) || (denominator < 0 && numerator > 0);\\n    numerator = Math.abs(numerator);\\n    denominator = Math.abs(denominator);\\n\\n\\t// this map will keep note of all the remainders occurences,\\n\\t// if a remainder appears again, that will repeat the same pattern\\n    const remaindersMap = new Map();\\n\\n\\t// add the negative sign to result if applicable\\n    let result = isNeg ? \\'-\\' : \\'\\';\\n    let quotient = numerator / denominator,\\n        remainder = numerator % denominator;\\n\\n\\t// add the quotient to the result -\\n\\t// if num > deno the it will be a positive integer, else it will be 0\\n    result += Math.floor(quotient);\\n\\t\\n\\t// if remainder is 0, that means the num is entirely divisible by deno, so we can return the result\\n    if(remainder === 0) {\\n        return result;\\n    } else {\\n\\t\\t// else there will be a floating value, so we add decimal to the resultant string\\n\\t\\t// set num to remainder\\n\\t\\t// add the remainder to map to check if it reappears\\n        result += \\'.\\';\\n        numerator = remainder;\\n        remaindersMap.set(remainder, 0);\\n    }\\n\\t// handling the floating point separately, `decimalStr` will store that string\\n\\t// `patternStartIdx` - to keep note of the index from where pattern will start\\n    let decimalStr = \\'\\',\\n        patternStartIdx = -1;\\n\\t\\t\\n\\t// 2 conditions for getting out of the loop\\n\\t// num > 0 - when num === 0 that means num is divisible by deno\\n\\t// patternStartIdx === -1 - it will change when a pattern  is found\\n    while(numerator > 0 && patternStartIdx === -1) {\\n        numerator *= 10;    // numerator < denominator\\n        \\n        quotient = numerator / denominator;\\n        remainder = numerator % denominator;\\n        \\n\\t\\t// add the quotient to the decimalStr\\n        decimalStr += Math.floor(quotient);\\n\\t\\t\\n\\t\\t// if remainder is reoccuring => pattern found\\n        if(remaindersMap.has(remainder)) {\\n\\t\\t\\t// get the start index from where the pattern begin - it will be the index the remainder had previous occured\\n\\t\\t\\t// we get the value and break from the loop\\n            patternStartIdx = remaindersMap.get(remainder);\\n            break;\\n        }\\n\\t\\t// else add the remainder to the map with index as `decimalStr.length`\\n\\t\\t// and set num as the remainder for next iteration\\n        remaindersMap.set(remainder, decimalStr.length);\\n        numerator = remainder;\\n    }\\n\\t// if pattern is found, add the decimal string along with brackets around the repeating pattern\\n\\t// else simply add the decimalStr\\n    if(patternStartIdx !== -1) {\\n        result += decimalStr.substring(0, patternStartIdx);\\n        result += \\'(\\' + decimalStr.substring(patternStartIdx) + \\')\\';    \\n    } else {\\n        result += decimalStr;\\n    }\\n    return result;\\n}\\n```\\nTime Complexity = O(denominator)\\nSpace Complexity = O(denominator)\\n\\nThe range of remainder can be from [0, denominator - 1]\\nWe loop till remainder reoccurs, max it can check for each remainder and we are storing remainder values in a map.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fractionToDecimal = function(numerator, denominator) {\\n    if(numerator === 0) {\\n        return \\'0\\';\\n    }\\n\\t// check if the result should be negative or not\\n    const isNeg = (numerator < 0 && denominator > 0) || (denominator < 0 && numerator > 0);\\n    numerator = Math.abs(numerator);\\n    denominator = Math.abs(denominator);\\n\\n\\t// this map will keep note of all the remainders occurences,\\n\\t// if a remainder appears again, that will repeat the same pattern\\n    const remaindersMap = new Map();\\n\\n\\t// add the negative sign to result if applicable\\n    let result = isNeg ? \\'-\\' : \\'\\';\\n    let quotient = numerator / denominator,\\n        remainder = numerator % denominator;\\n\\n\\t// add the quotient to the result -\\n\\t// if num > deno the it will be a positive integer, else it will be 0\\n    result += Math.floor(quotient);\\n\\t\\n\\t// if remainder is 0, that means the num is entirely divisible by deno, so we can return the result\\n    if(remainder === 0) {\\n        return result;\\n    } else {\\n\\t\\t// else there will be a floating value, so we add decimal to the resultant string\\n\\t\\t// set num to remainder\\n\\t\\t// add the remainder to map to check if it reappears\\n        result += \\'.\\';\\n        numerator = remainder;\\n        remaindersMap.set(remainder, 0);\\n    }\\n\\t// handling the floating point separately, `decimalStr` will store that string\\n\\t// `patternStartIdx` - to keep note of the index from where pattern will start\\n    let decimalStr = \\'\\',\\n        patternStartIdx = -1;\\n\\t\\t\\n\\t// 2 conditions for getting out of the loop\\n\\t// num > 0 - when num === 0 that means num is divisible by deno\\n\\t// patternStartIdx === -1 - it will change when a pattern  is found\\n    while(numerator > 0 && patternStartIdx === -1) {\\n        numerator *= 10;    // numerator < denominator\\n        \\n        quotient = numerator / denominator;\\n        remainder = numerator % denominator;\\n        \\n\\t\\t// add the quotient to the decimalStr\\n        decimalStr += Math.floor(quotient);\\n\\t\\t\\n\\t\\t// if remainder is reoccuring => pattern found\\n        if(remaindersMap.has(remainder)) {\\n\\t\\t\\t// get the start index from where the pattern begin - it will be the index the remainder had previous occured\\n\\t\\t\\t// we get the value and break from the loop\\n            patternStartIdx = remaindersMap.get(remainder);\\n            break;\\n        }\\n\\t\\t// else add the remainder to the map with index as `decimalStr.length`\\n\\t\\t// and set num as the remainder for next iteration\\n        remaindersMap.set(remainder, decimalStr.length);\\n        numerator = remainder;\\n    }\\n\\t// if pattern is found, add the decimal string along with brackets around the repeating pattern\\n\\t// else simply add the decimalStr\\n    if(patternStartIdx !== -1) {\\n        result += decimalStr.substring(0, patternStartIdx);\\n        result += \\'(\\' + decimalStr.substring(patternStartIdx) + \\')\\';    \\n    } else {\\n        result += decimalStr;\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 998707,
                "title": "python-solution-with-detail-explanation",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        \\n        if numerator % denominator == 0: \\n\\t\\t\\treturn str(numerator // denominator)\\n        \\n        prefix = \\'\\'\\n        if (numerator > 0) != (denominator > 0):\\n            prefix = \\'-\\'\\n        \\n        # Operation must be on positive values\\n        if numerator < 0:\\n            numerator = - numerator\\n        if denominator < 0:\\n            denominator = - denominator\\n\\n        digit, remainder = divmod(numerator, denominator)\\n            \\n        res = prefix + str(digit) + \\'.\\' # EVERYTHING BEFORE DECIMAL\\n        \\n        table = {}\\n        suffix = \\'\\'\\n        \\n        while remainder not in table.keys():\\n            \\n            # Store index of the reminder in the table\\n            table[remainder] = len(suffix)\\n            \\n            val, remainder = divmod(remainder*10, denominator)\\n            \\n            suffix += str(val)\\n            \\n            # No repeating\\n            if remainder == 0:\\n                return res + suffix\\n        \\n        indexOfRepeatingPart = table[remainder]\\n        \\n        decimalTillRepeatingPart = suffix[:indexOfRepeatingPart]\\n        \\n        repeatingPart = suffix[indexOfRepeatingPart:]\\n\\n        return res + decimalTillRepeatingPart + \\'(\\' + repeatingPart + \\')\\'\\n\\ns = Solution()\\n\\nprint(s.fractionToDecimal(2, 3))",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        \\n        if numerator % denominator == 0: \\n\\t\\t\\treturn str(numerator // denominator)\\n        \\n        prefix = \\'\\'\\n        if (numerator > 0) != (denominator > 0):\\n            prefix = \\'-\\'\\n        \\n        # Operation must be on positive values\\n        if numerator < 0:\\n            numerator = - numerator\\n        if denominator < 0:\\n            denominator = - denominator\\n\\n        digit, remainder = divmod(numerator, denominator)\\n            \\n        res = prefix + str(digit) + \\'.\\' # EVERYTHING BEFORE DECIMAL\\n        \\n        table = {}",
                "codeTag": "Java"
            },
            {
                "id": 806380,
                "title": "scala",
                "content": "```\\nimport scala.math.Integral.Implicits._\\nimport scala.math._\\n\\nobject Solution {\\n  def fractionToDecimal(numerator: Int, denominator: Int): String = {\\n    val sign = if (signum(numerator) * signum(denominator) == -1) \"-\" else \"\"\\n    s\"${sign}${fractionToDecimal(abs(numerator.toLong), abs(denominator.toLong))}\"\\n  }\\n\\n  private def fractionToDecimal(numerator: Long, denominator: Long): String = {\\n    numerator /% denominator match {\\n      case (quot, 0)   => quot.toString\\n      case (quot, rem) => s\"${quot}.${generateFractional(rem, denominator)}\"\\n    }\\n  }\\n\\n  @scala.annotation.tailrec\\n  private def generateFractional(numerator: Long,\\n                                 denominator: Long,\\n                                 numeratorToIndex: Map[Long, Int] = Map(),\\n                                 fractional: String = \"\"): String = {\\n    numeratorToIndex.get(numerator) match {\\n      case Some(index) => s\"${fractional.substring(0, index)}(${fractional.substring(index)})\"\\n      case _           => 10 * numerator /% denominator match {\\n        case (quot, 0)   => fractional + quot\\n        case (quot, rem) => generateFractional(rem, denominator, numeratorToIndex + (numerator -> fractional.length),\\n                                               fractional + quot)\\n      }\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Recursion"
                ],
                "code": "```\\nimport scala.math.Integral.Implicits._\\nimport scala.math._\\n\\nobject Solution {\\n  def fractionToDecimal(numerator: Int, denominator: Int): String = {\\n    val sign = if (signum(numerator) * signum(denominator) == -1) \"-\" else \"\"\\n    s\"${sign}${fractionToDecimal(abs(numerator.toLong), abs(denominator.toLong))}\"\\n  }\\n\\n  private def fractionToDecimal(numerator: Long, denominator: Long): String = {\\n    numerator /% denominator match {\\n      case (quot, 0)   => quot.toString\\n      case (quot, rem) => s\"${quot}.${generateFractional(rem, denominator)}\"\\n    }\\n  }\\n\\n  @scala.annotation.tailrec\\n  private def generateFractional(numerator: Long,\\n                                 denominator: Long,\\n                                 numeratorToIndex: Map[Long, Int] = Map(),\\n                                 fractional: String = \"\"): String = {\\n    numeratorToIndex.get(numerator) match {\\n      case Some(index) => s\"${fractional.substring(0, index)}(${fractional.substring(index)})\"\\n      case _           => 10 * numerator /% denominator match {\\n        case (quot, 0)   => fractional + quot\\n        case (quot, rem) => generateFractional(rem, denominator, numeratorToIndex + (numerator -> fractional.length),\\n                                               fractional + quot)\\n      }\\n    }\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 696535,
                "title": "c-hashmaps-100-runtime",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        long long num = numerator;\\n        long long deno = denominator;\\n        if(num==0) return \"0\";\\n        bool isNeg = false;\\n        if(num<0 && deno<0){\\n            num=abs(num);\\n            deno=abs(deno);\\n        }\\n        else if(num<0) {\\n            isNeg = true;\\n            num = abs(num);\\n        }\\n        else if(deno<0) {\\n            isNeg = true;\\n            deno = abs(deno);\\n        }\\n        long long q = num/deno;\\n        string ans = to_string(q);\\n        long long rem = num%deno;\\n        if(rem==0) {\\n            if(isNeg) return \"-\"+ans;\\n            return ans;\\n        }\\n        unordered_map<int,int> m;\\n        m[rem]=0;\\n        int count = 1;\\n        string str = \"\";\\n        while(rem!=0) {\\n            rem = rem* 10;\\n            q = rem/deno;\\n            str+=to_string(q);\\n            rem=rem%deno;\\n            if(m.find(rem)!=m.end()){\\n                str = str.substr(0,m[rem]) + \"(\" + str.substr(m[rem]) + \")\";\\n                break;\\n            }\\n            m[rem]=count;\\n            count++;\\n        }\\n        if(isNeg) return \"-\"+ans+\".\"+str;\\n        return ans+\".\"+str;\\n    }\\n}; \\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        long long num = numerator;\\n        long long deno = denominator;\\n        if(num==0) return \"0\";\\n        bool isNeg = false;\\n        if(num<0 && deno<0){\\n            num=abs(num);\\n            deno=abs(deno);\\n        }\\n        else if(num<0) {\\n            isNeg = true;\\n            num = abs(num);\\n        }\\n        else if(deno<0) {\\n            isNeg = true;\\n            deno = abs(deno);\\n        }\\n        long long q = num/deno;\\n        string ans = to_string(q);\\n        long long rem = num%deno;\\n        if(rem==0) {\\n            if(isNeg) return \"-\"+ans;\\n            return ans;\\n        }\\n        unordered_map<int,int> m;\\n        m[rem]=0;\\n        int count = 1;\\n        string str = \"\";\\n        while(rem!=0) {\\n            rem = rem* 10;\\n            q = rem/deno;\\n            str+=to_string(q);\\n            rem=rem%deno;\\n            if(m.find(rem)!=m.end()){\\n                str = str.substr(0,m[rem]) + \"(\" + str.substr(m[rem]) + \")\";\\n                break;\\n            }\\n            m[rem]=count;\\n            count++;\\n        }\\n        if(isNeg) return \"-\"+ans+\".\"+str;\\n        return ans+\".\"+str;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 489423,
                "title": "python3-very-clean-recursive-explained-solution",
                "content": "Let\\'s talk about how long division with decimals works. There\\'s no secret for this problem, it really is just the standard long division you learn when you\\'re 6 years old or whatever, unless you\\'re like me and day dreamed in your early days and learned it in college ;)\\n\\nBy the way, the `quotient` is the answer you get after completing division.\\n\\nIn general, the algorithm goes like this:\\n\\n```\\n\\t1. Perform a standard integer division with the numerator and denominator. \\n\\t2. If there is a remainder, we are now entering the realm of decimal division. Else, we are done and you can return your quotient.\\n\\t3. Assuming a remainder, while there exists a remainder, multiply it by 10 and perform long division, then set the remainder to the new remainder after the division.\\n\\t   Keep appending your quotients to your final answer\\n```\\n\\nOk, simple right! Knowing how to do this by hand is just these steps. It gets more complicated when dealing with a computer, though. Sometimes with the decimal division algorithm, you get caught in a cycle. This is where the problem really gets interesting. Consider the following division, `4/300`.\\n\\n```\\nnumerator = 4, denominator = 333\\n\\n4/333 = 0, r 4, final answer = 0\\n\\nlet numerator = 4*10 = 40\\n\\nnumerator = 40, denominator = 333\\n\\n40/333 = 0, r 40, final answer = 0.0\\n\\nlet numerator = 40*10 = 400\\n\\n400/333 = 1, r 67, final answer = 0.01\\n\\nlet numerator = 67*100 = 670\\n\\n670 / 333 = 2 r 4, final answer = 0.012\\n\\nlet numerator = 4*10 = 40 (*PAY ATTENTION NOW!!)\\n\\n40/333 = 0 r 40, final answer = 0.0120\\n\\nlet numerator = 40*10 = 400\\n\\n400/333 = 1, r 67, final answer = 0.01201\\n\\nlet numerator = 67*100 = 670\\n\\n670 / 333 = 2 r 4, final answer = 0.012012\\n\\nlet numerator = 4*10 = 40 \\n\\n40/300 = 0 r 40, final answer = 0.0120120\\n\\nlet numerator = 40*10 .........\\n\\nyou get the point\\n........\\n```\\n\\nBasically, we\\'re caught in a cycle. Decimal division is crude, and if you happen to get an irrational number from your division, you have a cycle in your division. So, the question wants you to observe this, and it wants you to wrap your cycle around with (`CYCLE HERE`). This is where the problem earns it\\'s worth. How do we, *find* and ***identify*** the cycle? Generally speaking, just knowing there\\'s a cycle is easy to detect, but being able to do something like pinpoint what/ where the cycle is, with these problems, is the difficult part (e.g., the critical connections problem).\\n\\nThe answer is what it always is, ***memoization***. Each time in your long division part, you see a new numerator, record it and where you first saw it. As demonstrated in the example above, if you run into the same numerator twice, you will start repeating the exact same sequence of numbers each time. If you happen to remember where that numerator took place in your current sequence, you could intervene and just wrap the start point and end point with a pair of parenthesis, and get your answer. In our example above, we would stop right where we saw the 40, and wrap the first occurance of it all the way to the end of our recorded sequence, and terminate the algorithm. So, we would\\'ve had the [\\'0\\',\\'1\\',\\'2\\'] sequence, then we see the 40 again, and intervene our sequence to be [\\'(0\\', \\'1\\', \\'2)\\'], and break out.\\n\\nThe reason I adore recursion for this problem, even though it\\'s not necesarry is because for one, it\\'s short, clear, and simple. Two, we are essentially treating this as a graph problem searching for a cycle. What do we do with most graph problems? DFS :D\\n\\n***NOTICE***:\\nBy the way, most examples you\\'ll see will have something like 5.13434134 == 5.(134), but it\\'s possible to have something like 4.232112316767676767 == 4.23211231(67). The cycle might not just happen when the decimal part starts. Also, negative numbers are a thing. The simple way to handle them like always is to just convert them into positives, and make the final answer negative if we have one of them is positive and the other negative.\\n\\nSo, here is our final algorithm:\\n\\n```\\n1. Convert the numbers to be positive, if they\\'re negative. Record if the division would\\'ve resulted in negative numbers or not.\\n2. Record the integer part of the division. If there is no remainder, jump to step 4, otherwise, begin the recording of a new sequence. Set the numerator equal to remainder * 10.\\n3. While the numerator is not zero and not seen before, perform long division. Mark this numerator as a numerator we\\'ve seen before in a hash table; memorizing the index we found it first. After each division, add the result to our new sequence, and perform long division again (i.e, repeat this step recursively) setting our new numerator to be the remainder of the division we just did multiplied by 10.\\nIf we end up seeing the same numerator, in our sequence, add a \\'(\\' on the index which corresponds to the numerator we\\'ve seen before, and the end of our sequence, also add a \\')\\' to that element\\n4. Join the integer part with the decimal part, if any.\\n5. Convert the result of 4. to a negative number by prepending a - in the front if we discovered at step 0 the result is supposed to be negative\\n```\\n\\n\\nAnd here\\'s my code. \\n\\n***Disclaimer***: I know recursion is not optimal for this problem. If the test cases were extreme, and made it so a lot of steps were needed to complete the algorithm, it wouldn\\'t be able to finish because Python would suffer stack overflow. But, this is an interview question and the important part is to get a nice working clean solution. If you were in an interview and decided to roll with a recursive solution, let the interviewer know you\\'re aware with the price you pay for using recursion. This isn\\'t just exclusive to this problem, it\\'s actually a general reason why general recursion should be avoided whenever possible. This is a problem where it\\'s easily avoidable, but just very clean to use it. As far as time complexity goes, I\\'m not sure. It\\'s not something I\\'d really expect the interviewers to ask you about unless you\\'re a math person. It\\'s not just a log number or something, there are some very complicated theorems that probably go into finding that out. This is something that is studied in a number theory course, so the scope is pretty high. Just make sure you do your job as a programmer to keep the complexity to the number of steps the long divison with decimals would take, i.e, not recreating lists or reconverting your sequences at each step.\\n\\nIf you have any questions or I said something wrong in here, please feel free to ask/ discuss in comments :D\\n\\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        def longDivision(numerator, denominator, seen, quotient):\\n            if numerator == 0:\\n                return\\n            elif numerator in seen:\\n                quotient[seen[numerator]] = \\'(\\' + quotient[seen[numerator]]\\n                quotient[-1] = quotient[-1] + \\')\\'\\n                return\\n            \\n            seen[numerator] = len(quotient)\\n            quotient.append(str(numerator//denominator))\\n            longDivision(numerator%denominator * 10, denominator, seen, quotient)\\n        \\n        #preprocess. Make negative positive.\\n        isNegative = (numerator < 0 and denominator > 0) or (numerator > 0 and denominator < 0)\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        #extract the integer portion of the quotient\\n        integerPart = str(numerator//denominator)\\n        \\n        #prepare, and perform longdevision on remiander*10, if any\\n        seen = {}\\n        decimalPart = []\\n        longDivision(numerator%denominator * 10, denominator, seen, decimalPart)\\n        \\n        #merge the integer part with the decimal part, if decimal exists\\n        decimalPart = \\'.\\' + \\'\\'.join(decimalPart) if decimalPart else \\'\\'\\n        quotient = integerPart + decimalPart\\n        \\n        return quotient if not isNegative else \\'-\\' + quotient\\n```",
                "solutionTags": [],
                "code": "```\\n\\t1. Perform a standard integer division with the numerator and denominator. \\n\\t2. If there is a remainder, we are now entering the realm of decimal division. Else, we are done and you can return your quotient.\\n\\t3. Assuming a remainder, while there exists a remainder, multiply it by 10 and perform long division, then set the remainder to the new remainder after the division.\\n\\t   Keep appending your quotients to your final answer\\n```\n```\\nnumerator = 4, denominator = 333\\n\\n4/333 = 0, r 4, final answer = 0\\n\\nlet numerator = 4*10 = 40\\n\\nnumerator = 40, denominator = 333\\n\\n40/333 = 0, r 40, final answer = 0.0\\n\\nlet numerator = 40*10 = 400\\n\\n400/333 = 1, r 67, final answer = 0.01\\n\\nlet numerator = 67*100 = 670\\n\\n670 / 333 = 2 r 4, final answer = 0.012\\n\\nlet numerator = 4*10 = 40 (*PAY ATTENTION NOW!!)\\n\\n40/333 = 0 r 40, final answer = 0.0120\\n\\nlet numerator = 40*10 = 400\\n\\n400/333 = 1, r 67, final answer = 0.01201\\n\\nlet numerator = 67*100 = 670\\n\\n670 / 333 = 2 r 4, final answer = 0.012012\\n\\nlet numerator = 4*10 = 40 \\n\\n40/300 = 0 r 40, final answer = 0.0120120\\n\\nlet numerator = 40*10 .........\\n\\nyou get the point\\n........\\n```\n```\\n1. Convert the numbers to be positive, if they\\'re negative. Record if the division would\\'ve resulted in negative numbers or not.\\n2. Record the integer part of the division. If there is no remainder, jump to step 4, otherwise, begin the recording of a new sequence. Set the numerator equal to remainder * 10.\\n3. While the numerator is not zero and not seen before, perform long division. Mark this numerator as a numerator we\\'ve seen before in a hash table; memorizing the index we found it first. After each division, add the result to our new sequence, and perform long division again (i.e, repeat this step recursively) setting our new numerator to be the remainder of the division we just did multiplied by 10.\\nIf we end up seeing the same numerator, in our sequence, add a \\'(\\' on the index which corresponds to the numerator we\\'ve seen before, and the end of our sequence, also add a \\')\\' to that element\\n4. Join the integer part with the decimal part, if any.\\n5. Convert the result of 4. to a negative number by prepending a - in the front if we discovered at step 0 the result is supposed to be negative\\n```\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        def longDivision(numerator, denominator, seen, quotient):\\n            if numerator == 0:\\n                return\\n            elif numerator in seen:\\n                quotient[seen[numerator]] = \\'(\\' + quotient[seen[numerator]]\\n                quotient[-1] = quotient[-1] + \\')\\'\\n                return\\n            \\n            seen[numerator] = len(quotient)\\n            quotient.append(str(numerator//denominator))\\n            longDivision(numerator%denominator * 10, denominator, seen, quotient)\\n        \\n        #preprocess. Make negative positive.\\n        isNegative = (numerator < 0 and denominator > 0) or (numerator > 0 and denominator < 0)\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        #extract the integer portion of the quotient\\n        integerPart = str(numerator//denominator)\\n        \\n        #prepare, and perform longdevision on remiander*10, if any\\n        seen = {}\\n        decimalPart = []\\n        longDivision(numerator%denominator * 10, denominator, seen, decimalPart)\\n        \\n        #merge the integer part with the decimal part, if decimal exists\\n        decimalPart = \\'.\\' + \\'\\'.join(decimalPart) if decimalPart else \\'\\'\\n        quotient = integerPart + decimalPart\\n        \\n        return quotient if not isNegative else \\'-\\' + quotient\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382877,
                "title": "straightforward-python-long-division-solution",
                "content": "```\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if denominator < 0:\\n            denominator *= -1\\n            numerator *= -1\\n        sign = 1\\n        if numerator < 0:\\n            sign = -1\\n            numerator *= -1\\n        inte = (\\'-\\' if sign == -1 else \\'\\') + str(numerator // denominator)\\n        rem = numerator % denominator\\n        frac, mp, i = [], dict(), 0\\n        while rem != 0 and rem not in mp:\\n            mp[rem] = i\\n            i += 1\\n            rem *= 10\\n            frac.append(str(rem // denominator))\\n            rem %= denominator\\n        if rem == 0:\\n            if frac == []:\\n                return inte\\n            else:\\n                return inte + \\'.\\' + \\'\\'.join(frac)\\n        else:\\n            j = mp[rem]\\n            return inte + \\'.\\' + \\'\\'.join(frac[:j]) + \\'(\\' + \\'\\'.join(frac[j:]) + \\')\\'\\n```",
                "solutionTags": [],
                "code": "```\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if denominator < 0:\\n            denominator *= -1\\n            numerator *= -1\\n        sign = 1\\n        if numerator < 0:\\n            sign = -1\\n            numerator *= -1\\n        inte = (\\'-\\' if sign == -1 else \\'\\') + str(numerator // denominator)\\n        rem = numerator % denominator\\n        frac, mp, i = [], dict(), 0\\n        while rem != 0 and rem not in mp:\\n            mp[rem] = i\\n            i += 1\\n            rem *= 10\\n            frac.append(str(rem // denominator))\\n            rem %= denominator\\n        if rem == 0:\\n            if frac == []:\\n                return inte\\n            else:\\n                return inte + \\'.\\' + \\'\\'.join(frac)\\n        else:\\n            j = mp[rem]\\n            return inte + \\'.\\' + \\'\\'.join(frac[:j]) + \\'(\\' + \\'\\'.join(frac[j:]) + \\')\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 359183,
                "title": "javascript-solution-best-time-here-best-solution",
                "content": "**If you don\\'t have a rought idea or understand the code below, please check out tadasant\\'s post for explanation by searching tadasant in discuss section.**\\n\\nThis post is for people who love to use {} instead of new Map() when needing a map like me.\\n\\nRecently after reading this article: https://medium.com/front-end-weekly/es6-map-vs-object-what-and-when-b80621932373 , I decided to do a performance test myself on this problem.\\n \\nSince leetcode has smaller amount of test cases, the run time beat % does not always mean the solution is optimal, you still have to think about run time complexity of your solution + any builtin function you used and data structure optimization.\\n\\n**NOTE:**\\nI\\'m new to performance testing and only did it on http://jsben.ch/ on chrome, please comment if you got something to offer or correct about my post.\\n\\n## Tests\\n**On LeetCode:** my solution with map was slower than obj with 37 test cases.\\n**On JSBEN: *code block 1* being obj {}, *code block 2* being new Map(), tests are [[nominator,denominator]......]**\\n\\n**1 test case [2,1] run 2000 times:** obj is only faster sometimes than map and not by much\\n![image](https://assets.leetcode.com/users/allanhsu8/image_1565868374.png)\\n\\nWith more tests cases it becomes apparent.\\n\\n\\n**[[1,2],[2,1],[1,998001],[-2147483648,1]] run 2000 times**\\n![image](https://assets.leetcode.com/users/allanhsu8/image_1565868996.png)\\n\\nLastly, to add more random test cases and at the same time not make the tab stop responding. I used the snippet here to generate 1 random test case and push it in.\\n```\\n//This block gets run 2000 times, to not explode I add onl 1 random element at the end.\\nconst tests = [[1,2],[2,1],[1,998001],[-2147483648,1]];\\n\\n\\nconst INT_MAX = Math.pow(2,32) - 1;\\nconst INT_MIN = -Math.pow(2,32);\\nconst range = INT_MAX-INT_MIN;\\ntests.push(Math.floor(Math.random()*(range)+INT_MIN),\\n           Math.floor(Math.random()*(range)+INT_MIN));\\n```\\n**[[1,2],[2,1],[1,998001],[-2147483648,1],[?,?]] run 2000 times**\\n![image](https://assets.leetcode.com/users/allanhsu8/image_1565869329.png)\\nWe can see map just beats object always. **Therefore use new Map() when you are using maps!** \\n\\nFor details of my code on JSBEN: http://jsben.ch/YeH2E , there are also plenty of map vs object tests on JSBEN you can search up and see for yourself of the getters and setters. Map is an object, but object is not a map.\\n\\n## Solution\\n```\\nconst fractionToDecimal = (numerator, denominator) => {\\n    if(numerator === 0) return \"0\";\\n    if(denominator === 0) return numerator < 0 ? Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY;\\n    \\n    let res = \"\";\\n    \\n    //Check result sign\\n    if(Math.sign(numerator) !== Math.sign(denominator)) res += \"-\";\\n    \\n    let n = Math.abs(numerator);\\n    const d = Math.abs(denominator);\\n    \\n    //don\\'t use n/d | 0 to floor since js bitwise operation is based on 32 bits\\n    //and large positive num could cause sign bit to flip into a neg num or overflow\\n    res += Math.floor(n/d); \\n    n = n%d;\\n    \\n    if(n === 0) return res;\\n    \\n    res += \".\";\\n    \\n    //key for remainder, value for pattern start index\\n    let map = new Map();   // USE MAP\\n    \\n    //we can use res.length as index since it keeps track of the growth\\n    //alwasy being the next index to insert so we don\\'t need another variable!\\n    while(n !== 0){\\n        //keep track of remainders\\n        map.set(n,res.length);\\n        \\n        n *= 10;\\n        res += Math.floor(n/d); //add quotient digit to the res.length index\\n        n %= d;\\n    \\n        if(map.has(n))\\n            return `${res.substring(0,map.get(n))}(${res.substr(map.get(n))})`;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//This block gets run 2000 times, to not explode I add onl 1 random element at the end.\\nconst tests = [[1,2],[2,1],[1,998001],[-2147483648,1]];\\n\\n\\nconst INT_MAX = Math.pow(2,32) - 1;\\nconst INT_MIN = -Math.pow(2,32);\\nconst range = INT_MAX-INT_MIN;\\ntests.push(Math.floor(Math.random()*(range)+INT_MIN),\\n           Math.floor(Math.random()*(range)+INT_MIN));\\n```\n```\\nconst fractionToDecimal = (numerator, denominator) => {\\n    if(numerator === 0) return \"0\";\\n    if(denominator === 0) return numerator < 0 ? Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY;\\n    \\n    let res = \"\";\\n    \\n    //Check result sign\\n    if(Math.sign(numerator) !== Math.sign(denominator)) res += \"-\";\\n    \\n    let n = Math.abs(numerator);\\n    const d = Math.abs(denominator);\\n    \\n    //don\\'t use n/d | 0 to floor since js bitwise operation is based on 32 bits\\n    //and large positive num could cause sign bit to flip into a neg num or overflow\\n    res += Math.floor(n/d); \\n    n = n%d;\\n    \\n    if(n === 0) return res;\\n    \\n    res += \".\";\\n    \\n    //key for remainder, value for pattern start index\\n    let map = new Map();   // USE MAP\\n    \\n    //we can use res.length as index since it keeps track of the growth\\n    //alwasy being the next index to insert so we don\\'t need another variable!\\n    while(n !== 0){\\n        //keep track of remainders\\n        map.set(n,res.length);\\n        \\n        n *= 10;\\n        res += Math.floor(n/d); //add quotient digit to the res.length index\\n        n %= d;\\n    \\n        if(map.has(n))\\n            return `${res.substring(0,map.get(n))}(${res.substr(map.get(n))})`;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208050,
                "title": "java-solution-20-lines",
                "content": "```\\n\\tpublic String fractionToDecimal(int numerator, int denominator) {\\n        long a = numerator, b = denominator, m = a % b;  //a\\u5206\\u5B50,b\\u5206\\u6BCD,m\\u4F59\\u6570\\n        Map<Long, Integer> map = new HashMap<>();\\n        if (m == 0)\\n            return a / b + \"\";\\n        StringBuilder sb = new StringBuilder();\\n        if (a * b < 0)\\n            sb.append(\\'-\\');\\n        a = Math.abs(a);\\n        b = Math.abs(b);\\n        sb.append(a / b).append(\\'.\\');\\n        m = a % b;\\n        map.put(m, sb.length());\\n        while (m != 0) {\\n            a = m * 10;\\n            sb.append(a / b);\\n            m = a % b;\\n            if (map.containsKey(m))\\n                return sb.insert((int) map.get(m), \\'(\\').append(\\')\\').toString();\\n            map.put(m, sb.length());\\n        }\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic String fractionToDecimal(int numerator, int denominator) {\\n        long a = numerator, b = denominator, m = a % b;  //a\\u5206\\u5B50,b\\u5206\\u6BCD,m\\u4F59\\u6570\\n        Map<Long, Integer> map = new HashMap<>();\\n        if (m == 0)\\n            return a / b + \"\";\\n        StringBuilder sb = new StringBuilder();\\n        if (a * b < 0)\\n            sb.append(\\'-\\');\\n        a = Math.abs(a);\\n        b = Math.abs(b);\\n        sb.append(a / b).append(\\'.\\');\\n        m = a % b;\\n        map.put(m, sb.length());\\n        while (m != 0) {\\n            a = m * 10;\\n            sb.append(a / b);\\n            m = a % b;\\n            if (map.containsKey(m))\\n                return sb.insert((int) map.get(m), \\'(\\').append(\\')\\').toString();\\n            map.put(m, sb.length());\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 205217,
                "title": "c-0-ms-with-example-explanation-complexity-discussion",
                "content": "Let\\'s divide the problem to two sections.\\n1. Calculating the decimal value \\n2. Calculating the fractional value.\\n \\n* Calculating the decimal value:\\nThis one is straight forward; we can get the decimal value by a single division operation and store it to a string variable.\\nIf the numerator is divisible to denumerator, then we are done and need to return the string value of the division result \\nFor example if we have   numerator =84 and denumerator =7 then we should return \"12\"\\n\\n* Calculating the fractional value:\\n This step could be tricky.\\n Here is an example to refresh your mind for division algorithm.\\n \\n 1 / 7 : 1/7 = 0 , 1%7 =1  => 1/7 = 0. **X**  \\n to find the value of **X** we need to multiply the remainder by 10 and then repeat the division like\\n 1\\\\*10 =10 then 10/ 7 : 10/7 =1 , 10%7 =3  => 1/7 = 0.1**X**\\n 3\\\\*10 =30 then 30/ 7 : 30/7 =4 , 30%7 =2  => 1/7 = 0.14**X**\\n 2\\\\*10 =20 then 20/ 7 : 20/7 =2 , 20%7 =6  => 1/7 = 0.142**X**\\n 6\\\\*10 =60 then 60/ 7 : 60/7 =8 , 60%7 =4  => 1/7 = 0.1428**X**\\n 4\\\\*10 =40 then 40/ 7 : 40/7 =5 , 40%7 =5  => 1/7 = 0.14285**X**\\n \\n 5*10 =50 then 50/ 7 ~ 50/7 =7 , 50%7 =1  => 1/7 = 0.142857   , at this stage you can see that we are reaching a same number we have already calculated. So we need to report like 1/ 7  ~ 0.(142857)\\n \\nThe idea to implement the elaborated example is here:\\nwe can keep track of each generated remainder in a hash as a key of hash. The value of the hash can be the location of them in generated string. For example in the given example we have the following values for the hash:\\n\\nkey   val\\n1        0\\n3        1\\n2        2\\n6        3\\n4        4\\n5        6\\n\\nSo, to finalize it we can insert the \"(\" at the position of previously visited h[val] and add the \")\" to the end of string\\n \\nOne more important point needs to be noticed is about the sign. To handle it we can decide about the sign at very beginning and add the \"-\" to the result if needed (when only one of the operators is negative) , then do the rest of algorithm by updating the input parameters with their absolutes values.\\n\\n \\n#  Complexity\\n*  The interesting or follow up question could be about the time complexity of this algorithm.\\n\\t*  Memory complexity:  for this approach is O(denominator), the reason is that we are hashing the remainder values, so the maximum required hash location is denominator-1.\\n\\t\\n\\t*  Time complexity:  Similarly the maximum division operation we need to do is equal to denominator, the readson is that the remainder can be any number from [0,denominator-1]. So we can say the time complexity of the algoritm is also O(denominator)\\n  \\n\\n```\\nstring fractionToDecimal(int num1, int num2) {\\n  string res =\"\";    \\n  if (num1==0) return \"0\";\\n  if (num2==0) return \"NaN\";  \\n  long int n1 = num1;\\n  long int n2 = num2;\\n  if (n1>0 ^ n2>0) res+=\\'-\\';\\n  n1 = abs(n1);\\n  n2 = abs (n2);\\n  res += to_string(n1/n2);  \\n  if (n1%n2==0)\\n      return res;\\n  res+=\\'.\\';   \\n  map <int, int> h;\\n  n1 = n1 %n2;\\n  n1*=10;\\n  int idx=0;\\n  string frac = \"\"; \\n  while (n1!= 0 )  {\\n      if (h.find(n1)!=h.end()) {\\n          frac.insert(h[n1], \"(\");\\n          frac.append(\")\");\\n          break;\\n      }\\n      frac+= to_string(n1/n2);     \\n      h[n1] = idx;  \\n      n1 = n1 %n2;\\n      n1*=10;\\n      idx++;\\n  }\\n  res+=frac;\\n  return res;    \\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nstring fractionToDecimal(int num1, int num2) {\\n  string res =\"\";    \\n  if (num1==0) return \"0\";\\n  if (num2==0) return \"NaN\";  \\n  long int n1 = num1;\\n  long int n2 = num2;\\n  if (n1>0 ^ n2>0) res+=\\'-\\';\\n  n1 = abs(n1);\\n  n2 = abs (n2);\\n  res += to_string(n1/n2);  \\n  if (n1%n2==0)\\n      return res;\\n  res+=\\'.\\';   \\n  map <int, int> h;\\n  n1 = n1 %n2;\\n  n1*=10;\\n  int idx=0;\\n  string frac = \"\"; \\n  while (n1!= 0 )  {\\n      if (h.find(n1)!=h.end()) {\\n          frac.insert(h[n1], \"(\");\\n          frac.append(\")\");\\n          break;\\n      }\\n      frac+= to_string(n1/n2);     \\n      h[n1] = idx;  \\n      n1 = n1 %n2;\\n      n1*=10;\\n      idx++;\\n  }\\n  res+=frac;\\n  return res;    \\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51134,
                "title": "simple-java-solution-with-explanation-for-all-key-points",
                "content": "```\\npublic String fractionToDecimal(int numerator, int denominator) {\\n        //1. Handle 3 special cases and return directly.\\n        //1) Zero divisor\\n        if (denominator == 0) return \"Error: 0 cannot be a denominator!\";\\n        //2) Zero dividend\\n        if (numerator == 0) return \"0\";\\n        //3) Exact division\\n        if (numerator % denominator == 0) return String.valueOf((long)numerator / (long)denominator);\\n        //NOTE: Convert to long before dividing to avoid overflow.\\n\\n        //2. Handle indivisible case\\n        StringBuilder sb = new StringBuilder();\\n\\n        //1) Add \"-\" sign for negative numbers\\n        long num = Math.abs((long)numerator);\\n        long den = Math.abs((long)denominator);\\n        //NOTE: MUST convert int to long before abs() since Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE.\\n\\n        if ( (long)numerator * (long)denominator < 0) sb.append(\"-\");\\n        //NOTE:\\n        // -- This is mandatory when num < den.\\n        // -- Convert to long before * to avoid overflow.\\n\\n        //2) Add integral part and \".\"\\n        sb.append(num / den).append(\".\");\\n        //NOTE: Use ABS() value to avoid double \"-\" sign when abs(num)>abs(den).\\n\\n        //3) Handle fraction part\\n        long remainder = num % den;\\n        Map<Long/*current reminder*/, Integer/* current stringBuilder.length()*/> map =\\n                new HashMap<Long, Integer>();\\n        //Assumption: a repeat remainder indicate a recursion of fraction.\\n        while (!map.containsKey(remainder)) {\\n            map.put(remainder, sb.length());\\n            sb.append(remainder * 10 / den);    //current fraction digit\\n            remainder = remainder * 10 % den;   //next reminder\\n        }\\n\\n        sb.insert(map.get(remainder), \"(\"); //Insert \"(\" before the start of recursion.\\n        sb.append(\")\"); //Append \")\" at the end.\\n        return sb.toString().replace(\"(0)\", \"\");    //Remove \"(0)\" when no recursion.\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String fractionToDecimal(int numerator, int denominator) {\\n        //1. Handle 3 special cases and return directly.\\n        //1) Zero divisor\\n        if (denominator == 0) return \"Error: 0 cannot be a denominator!\";\\n        //2) Zero dividend\\n        if (numerator == 0) return \"0\";\\n        //3) Exact division\\n        if (numerator % denominator == 0) return String.valueOf((long)numerator / (long)denominator);\\n        //NOTE: Convert to long before dividing to avoid overflow.\\n\\n        //2. Handle indivisible case\\n        StringBuilder sb = new StringBuilder();\\n\\n        //1) Add \"-\" sign for negative numbers\\n        long num = Math.abs((long)numerator);\\n        long den = Math.abs((long)denominator);\\n        //NOTE: MUST convert int to long before abs() since Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE.\\n\\n        if ( (long)numerator * (long)denominator < 0) sb.append(\"-\");\\n        //NOTE:\\n        // -- This is mandatory when num < den.\\n        // -- Convert to long before * to avoid overflow.\\n\\n        //2) Add integral part and \".\"\\n        sb.append(num / den).append(\".\");\\n        //NOTE: Use ABS() value to avoid double \"-\" sign when abs(num)>abs(den).\\n\\n        //3) Handle fraction part\\n        long remainder = num % den;\\n        Map<Long/*current reminder*/, Integer/* current stringBuilder.length()*/> map =\\n                new HashMap<Long, Integer>();\\n        //Assumption: a repeat remainder indicate a recursion of fraction.\\n        while (!map.containsKey(remainder)) {\\n            map.put(remainder, sb.length());\\n            sb.append(remainder * 10 / den);    //current fraction digit\\n            remainder = remainder * 10 % den;   //next reminder\\n        }\\n\\n        sb.insert(map.get(remainder), \"(\"); //Insert \"(\" before the start of recursion.\\n        sb.append(\")\"); //Append \")\" at the end.\\n        return sb.toString().replace(\"(0)\", \"\");    //Remove \"(0)\" when no recursion.\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51180,
                "title": "simple-java-solution-using-hashmap-and-stringbuilder",
                "content": "    public String fractionToDecimal(int numerator, int denominator) {\\n        long n=numerator;\\n\\t\\tlong d=denominator;\\n\\t\\tif(n==0)return \"0\";\\n        int sign=1;\\n        if(numerator<0){sign=-sign;n=-n;}\\n        if(denominator<0){sign=-sign;d=-d;}   \\n        \\n        StringBuilder sb=new StringBuilder();\\n        if(sign==-1)sb.append(\"-\");\\n        sb.append(n/d);\\n        n%=d;\\n        if(n==0)return sb.toString();\\n        sb.append(\".\");\\n        \\n        HashMap<Long,Integer>map=new HashMap();\\n        List<Long>list=new ArrayList();\\n        int index=0;\\n        while(n!=0&&!map.containsKey(n)){\\n            map.put(n,index++);\\n            n*=10;\\n            list.add(n/d);\\n            n%=d;\\n        }\\n        //Divide process finished\\n        if(n==0){ //No repeat\\n            for(int i=0;i<list.size();i++){\\n                sb.append(list.get(i));\\n            }\\n            return sb.toString();\\n        }else{ //Has repeat\\n            int startIndex=map.get(n);    \\n            for(int i=0;i<startIndex;i++){\\n                sb.append(list.get(i));\\n            }\\n            sb.append(\"(\");\\n            for(int i=startIndex;i<list.size();i++){\\n                sb.append(list.get(i));\\n            }\\n            sb.append(\")\");\\n            return sb.toString();\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public String fractionToDecimal(int numerator, int denominator) {\\n        long n=numerator;\\n\\t\\tlong d=denominator;\\n\\t\\tif(n==0)return \"0\";\\n        int sign=1;\\n        if(numerator<0){sign=-sign;n=-n;}\\n        if(denominator<0){sign=-sign;d=-d;}   \\n        \\n        StringBuilder sb=new StringBuilder();\\n        if(sign==-1)sb.append(\"-\");\\n        sb.append(n/d);\\n        n%=d;\\n        if(n==0)return sb.toString();\\n        sb.append(\".\");\\n        \\n        HashMap<Long,Integer>map=new HashMap();\\n        List<Long>list=new ArrayList();\\n        int index=0;\\n        while(n!=0&&!map.containsKey(n)){\\n            map.put(n,index++);\\n            n*=10;\\n            list.add(n/d);\\n            n%=d;\\n        }\\n        //Divide process finished\\n        if(n==0){ //No repeat\\n            for(int i=0;i<list.size();i++){\\n                sb.append(list.get(i));\\n            }\\n            return sb.toString();\\n        }else{ //Has repeat\\n            int startIndex=map.get(n);    \\n            for(int i=0;i<startIndex;i++){\\n                sb.append(list.get(i));\\n            }\\n            sb.append(\"(\");\\n            for(int i=startIndex;i<list.size();i++){\\n                sb.append(list.get(i));\\n            }\\n            sb.append(\")\");\\n            return sb.toString();\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51196,
                "title": "clean-ruby-solution-with-comments-72-ms",
                "content": "    def fraction_to_decimal(n, d)\\n    \\n    \\t# Get +/-\\n    \\tresult = n*d >= 0 ? '' : '-'\\n    \\n    \\t# Get whole number\\n    \\tn = n.abs\\n    \\td = d.abs\\n    \\tresult << (n/d).to_s\\n    \\tn %= d\\n    \\n    \\t# Check whole number\\n    \\treturn result if n == 0\\n    \\n    \\t# Get decimal\\n    \\tresult << '.'\\n    \\tcheck = Hash.new\\n    \\n    \\t# Division\\n    \\twhile not n.zero? and check[n].nil?\\n    \\t\\tcheck[n] = result.length\\n    \\t\\tn *= 10\\n    \\t\\tresult << (n/d).to_s\\n    \\t\\tn %= d\\n    \\tend\\n    \\n    \\t# Check repeating\\n    \\tresult.insert(check[n], '(') << ')' if check[n]\\n    \\n    \\treturn result\\n    end",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "    def fraction_to_decimal(n, d)\\n    \\n    \\t# Get +/-\\n    \\tresult = n*d >= 0 ? '' : '-'\\n    \\n    \\t# Get whole number\\n    \\tn = n.abs\\n    \\td = d.abs\\n    \\tresult << (n/d).to_s\\n    \\tn %= d\\n    \\n    \\t# Check whole number\\n    \\treturn result if n == 0\\n    \\n    \\t# Get decimal\\n    \\tresult << '.'\\n    \\tcheck = Hash.new\\n    \\n    \\t# Division\\n    \\twhile not n.zero? and check[n].nil?\\n    \\t\\tcheck[n] = result.length\\n    \\t\\tn *= 10\\n    \\t\\tresult << (n/d).to_s\\n    \\t\\tn %= d\\n    \\tend\\n    \\n    \\t# Check repeating\\n    \\tresult.insert(check[n], '(') << ')' if check[n]\\n    \\n    \\treturn result\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 51236,
                "title": "my-java-solution-with-explanation-second-version",
                "content": "my trick:\\n1. use long to avoid overflow<br>\\n2. use StringBuffer to build String<br>\\n3.use class pair to keep track of numerator and denominator,if I find the same pair in the map,it means the fractional part is repeating.<br>\\n4.  using `res=numeratorl/denominatorl;numeratorl=(numeratorl%denominatorl)*10;` to simulate division,`res` is the value to append to buffer.\\n\\n   \\n     public class Solution {\\n            public String fractionToDecimal(int numerator, int denominator) {\\n\\t    \\t//to avoid overflow\\n\\t    \\tlong numeratorl=numerator, denominatorl=denominator;\\n\\t        StringBuffer buffer=new StringBuffer();\\n\\t        //handle negatives \\n\\t        if(numeratorl<0&&denominatorl>0)buffer.append('-');\\n\\t        else if(numeratorl>0&&denominatorl<0)buffer.append('-');\\n\\t        numeratorl=Math.abs(numeratorl);denominatorl=Math.abs(denominatorl);\\n\\t        //map,key:pair to hold numerator and denominator;value:position of numerator/denominator \\n\\t        HashMap<pair, Integer>map=new HashMap<>();\\n\\t        //handle integer part\\n\\t        long res=numeratorl/denominatorl;\\n\\t        numeratorl=(numeratorl%denominatorl)*10;\\n\\t\\t\\tbuffer.append(res);\\n\\t\\t\\tif(numeratorl!=0)buffer.append('.');\\n\\t\\t\\t//handle float part\\n\\t\\t\\twhile(numeratorl != 0){\\n\\t\\t\\t\\tres=numeratorl/denominatorl;\\n\\t\\t\\t\\tpair p=new pair(denominatorl,numeratorl);\\n\\t\\t\\t\\tif(map.get(p)!=null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t//handle repaeting part\\n\\t\\t\\t\\t\\tbuffer.insert(map.get(p).intValue(), '(');\\n\\t\\t\\t\\t\\tbuffer.append(')');\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmap.put(p, buffer.length());\\n\\t\\t\\t\\tnumeratorl=(numeratorl%denominatorl)*10;\\n\\t\\t        buffer.append(res);\\n\\t\\t\\t}\\n\\t        return buffer.toString();\\n\\t    }\\n\\t    //this class is used to hold numerator and denominator,override hashcode\\\\equals\\n\\t    private static class pair{\\n\\t    \\tpublic long d;\\n\\t    \\tpublic long n;\\n\\t    \\tpublic pair(long d,long n) {\\n\\t    \\t\\tthis.d=d;this.n=n;\\n\\t\\t\\t}\\n\\t    \\t@Override\\n\\t    \\tpublic int hashCode() {\\n\\t    \\t\\treturn Arrays.hashCode(new long[]{d,n});\\n\\t    \\t}\\n\\t    \\t@Override\\n\\t    \\tpublic boolean equals(Object obj) {\\n\\t    \\t\\tpair p = (pair) obj;\\n\\t    \\t\\treturn p.d==d&&p.n==n;\\n\\t    \\t}\\n\\t     }\\n        }\\n\\nI make this problem complicated,because if numerator repeating,the fractional part is repeating.so class `pair` is not needed.I give my second version\\n \\n\\n    public class Solution {\\n    \\t    public String fractionToDecimal(int numerator, int denominator) {\\n    \\t    \\t//to avoid overflow\\n    \\t    \\tlong numeratorl=numerator, denominatorl=denominator;\\n    \\t        StringBuffer buffer=new StringBuffer();\\n    \\t        //handle negetives \\n    \\t        if(numeratorl<0&&denominatorl>0)buffer.append('-');\\n    \\t        else if(numeratorl>0&&denominatorl<0)buffer.append('-');\\n    \\t        numeratorl=Math.abs(numeratorl);denominatorl=Math.abs(denominatorl);\\n    \\t        //map,key:  numerator ,because denominator never changes;value:position of numerator/denominator \\n    \\t        HashMap<Long, Integer>map=new HashMap<>();\\n    \\t        //handle integer part\\n    \\t        long res=numeratorl/denominatorl;\\n    \\t        numeratorl=(numeratorl%denominatorl)*10;\\n    \\t\\t\\tbuffer.append(res);\\n    \\t\\t\\tif(numeratorl!=0)buffer.append('.');\\n    \\t\\t\\t//handle flaot part\\n    \\t\\t\\twhile(numeratorl != 0){\\n    \\t\\t\\t\\tres=numeratorl/denominatorl;\\n    \\t\\t\\t\\tif(map.get(numeratorl)!=null)\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\t//handle repaeting part\\n    \\t\\t\\t\\t\\tbuffer.insert(map.get(numeratorl).intValue(), '(');\\n    \\t\\t\\t\\t\\tbuffer.append(')');\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tmap.put(numeratorl, buffer.length());\\n    \\t\\t\\t\\tnumeratorl=(numeratorl%denominatorl)*10;\\n    \\t\\t        buffer.append(res);\\n    \\t\\t\\t}\\n    \\t        return buffer.toString();\\n    \\t    }\\n    \\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            public String fractionToDecimal(int numerator, int denominator) {\\n\\t    \\t//to avoid overflow\\n\\t    \\tlong numeratorl=numerator, denominatorl=denominator;\\n\\t        StringBuffer buffer=new StringBuffer();\\n\\t        //handle negatives \\n\\t        if(numeratorl<0&&denominatorl>0)buffer.append('-');\\n\\t        else if(numeratorl>0&&denominatorl<0)buffer.append('-');\\n\\t        numeratorl=Math.abs(numeratorl);denominatorl=Math.abs(denominatorl);\\n\\t        //map,key:pair to hold numerator and denominator;value:position of numerator/denominator \\n\\t        HashMap<pair, Integer>map=new HashMap<>();\\n\\t        //handle integer part\\n\\t        long res=numeratorl/denominatorl;\\n\\t        numeratorl=(numeratorl%denominatorl)*10;\\n\\t\\t\\tbuffer.append(res);\\n\\t\\t\\tif(numeratorl!=0)buffer.append('.');\\n\\t\\t\\t//handle float part\\n\\t\\t\\twhile(numeratorl != 0){\\n\\t\\t\\t\\tres=numeratorl/denominatorl;\\n\\t\\t\\t\\tpair p=new pair(denominatorl,numeratorl);\\n\\t\\t\\t\\tif(map.get(p)!=null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t//handle repaeting part\\n\\t\\t\\t\\t\\tbuffer.insert(map.get(p).intValue(), '(');\\n\\t\\t\\t\\t\\tbuffer.append(')');\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3791144,
                "title": "easy-to-understand-c-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d) {\\n        long long a = labs(n), b = labs(d);\\n        string ans = \"\";\\n        if( (n < 0 && d > 0) || (n > 0 && d < 0) ) ans += \"-\";\\n        long long res = a/b; ans += to_string(res);\\n        long long r = a%b;\\n        if(r == 0) return ans;\\n        ans += \".\";\\n        unordered_map<int,int>mp;\\n        mp[r] = ans.length();\\n\\n        while(r != 0){\\n            r *= 10;\\n            res = r/b; ans+= to_string(res);\\n            r = r%b;\\n            if(mp.find(r) != mp.end()){\\n                ans.insert(ans.begin()+mp[r],\\'(\\');\\n                ans += \")\";\\n                return ans;\\n            }\\n            mp[r] = ans.length();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d) {\\n        long long a = labs(n), b = labs(d);\\n        string ans = \"\";\\n        if( (n < 0 && d > 0) || (n > 0 && d < 0) ) ans += \"-\";\\n        long long res = a/b; ans += to_string(res);\\n        long long r = a%b;\\n        if(r == 0) return ans;\\n        ans += \".\";\\n        unordered_map<int,int>mp;\\n        mp[r] = ans.length();\\n\\n        while(r != 0){\\n            r *= 10;\\n            res = r/b; ans+= to_string(res);\\n            r = r%b;\\n            if(mp.find(r) != mp.end()){\\n                ans.insert(ans.begin()+mp[r],\\'(\\');\\n                ans += \")\";\\n                return ans;\\n            }\\n            mp[r] = ans.length();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051470,
                "title": "100-fast-fully-commented-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d)\\n    {\\n        string ans;\\n        if((n<0 && d>0) || (n>0 && d<0))\\n            ans+=\\'-\\';\\n        n=abs(n);\\n        d=abs(d);\\n        long long q=n/d;//initial quotient\\n        long long rem=n%d;//initial remainder\\n        ans+=to_string(q);\\n        if(rem==0) return ans;//there is no decimal part\\n        ans+=\\'.\\';\\n        int fl=0;//flag variable to determine if theb decimal is recurring\\n        int ind_start=-1;//starting index of the recurring part of the decimal\\n        int index=0;//to store the index of all the numbers after point\\n        unordered_map<int,unordered_map<int,int>>mp;//quotient-->remainder-->index of number\\n        string after_pt;//string to store all the numbers after point\\n        while(rem!=0)\\n        {\\n            rem*=10;\\n            long long q2=rem/d;\\n            rem=rem%d;\\n            if(mp[q2][rem])//means the quotient-->remainder already exists thus the decimal part is recurring\\n            {\\n                fl=1;\\n                ind_start=mp[q2][rem];//the index of the start of the recuuring part of the decimal\\n                break;\\n            }\\n            else\\n            {\\n                after_pt+=to_string(q2);\\n                mp[q2][rem]=index++;\\n            }\\n        }\\n        if(fl==0)//contains no recurring number just concatenate the strings\\n            ans+=after_pt;\\n        else\\n        {\\n            //contains a recurring part\\n            for(int i=0;i<after_pt.length();i++)\\n            {\\n                if(i==ind_start)//this is the start of the recurring part of the decimal nos\\n                    ans+=\\'(\\';\\n                ans+=after_pt[i];\\n            }\\n            ans+=\\')\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d)\\n    {\\n        string ans;\\n        if((n<0 && d>0) || (n>0 && d<0))\\n            ans+=\\'-\\';\\n        n=abs(n);\\n        d=abs(d);\\n        long long q=n/d;//initial quotient\\n        long long rem=n%d;//initial remainder\\n        ans+=to_string(q);\\n        if(rem==0) return ans;//there is no decimal part\\n        ans+=\\'.\\';\\n        int fl=0;//flag variable to determine if theb decimal is recurring\\n        int ind_start=-1;//starting index of the recurring part of the decimal\\n        int index=0;//to store the index of all the numbers after point\\n        unordered_map<int,unordered_map<int,int>>mp;//quotient-->remainder-->index of number\\n        string after_pt;//string to store all the numbers after point\\n        while(rem!=0)\\n        {\\n            rem*=10;\\n            long long q2=rem/d;\\n            rem=rem%d;\\n            if(mp[q2][rem])//means the quotient-->remainder already exists thus the decimal part is recurring\\n            {\\n                fl=1;\\n                ind_start=mp[q2][rem];//the index of the start of the recuuring part of the decimal\\n                break;\\n            }\\n            else\\n            {\\n                after_pt+=to_string(q2);\\n                mp[q2][rem]=index++;\\n            }\\n        }\\n        if(fl==0)//contains no recurring number just concatenate the strings\\n            ans+=after_pt;\\n        else\\n        {\\n            //contains a recurring part\\n            for(int i=0;i<after_pt.length();i++)\\n            {\\n                if(i==ind_start)//this is the start of the recurring part of the decimal nos\\n                    ans+=\\'(\\';\\n                ans+=after_pt[i];\\n            }\\n            ans+=\\')\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001970,
                "title": "java-solution",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    StringBuilder sb;\\n    public String fractionToDecimal(int numerator, int denominator) {\\n\\n        if(numerator == 0){\\n            return \"0\";\\n        }   \\n        sb = new StringBuilder();\\n        \\n        addSign(numerator,denominator);\\n        divideNumbers(numerator,denominator);\\n\\n        return sb.toString();\\n    }\\n    private void addSign(int a , int b){\\n        \\n        if((a > 0 && b > 0) || (a < 0 && b < 0)){\\n            return;\\n        }    \\n        sb.append(\"-\");\\n    }\\n    private void divideNumbers(int a,int b){\\n        \\n        long num = Math.abs((long)a);\\n        long den = Math.abs((long)b);\\n\\n        sb.append(num/den);\\n        num %= den;\\n        if(num == 0){\\n            return;\\n        } \\n        appendDecimalPart(num,den);\\n    }\\n    private void appendDecimalPart(long num, long den){\\n\\n        HashMap<Long,Integer> map = new HashMap<>();\\n        sb.append(\".\");\\n        while(num !=0){\\n\\n            num *= 10;\\n            sb.append(num/den);\\n            num %= den;\\n\\n            if(map.containsKey(num)){\\n                sb.insert(map.get(num),\"(\");\\n                sb.append(\")\");\\n                return;\\n            }\\n            else{\\n                map.put(num,sb.length());\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    StringBuilder sb;\\n    public String fractionToDecimal(int numerator, int denominator) {\\n\\n        if(numerator == 0){\\n            return \"0\";\\n        }   \\n        sb = new StringBuilder();\\n        \\n        addSign(numerator,denominator);\\n        divideNumbers(numerator,denominator);\\n\\n        return sb.toString();\\n    }\\n    private void addSign(int a , int b){\\n        \\n        if((a > 0 && b > 0) || (a < 0 && b < 0)){\\n            return;\\n        }    \\n        sb.append(\"-\");\\n    }\\n    private void divideNumbers(int a,int b){\\n        \\n        long num = Math.abs((long)a);\\n        long den = Math.abs((long)b);\\n\\n        sb.append(num/den);\\n        num %= den;\\n        if(num == 0){\\n            return;\\n        } \\n        appendDecimalPart(num,den);\\n    }\\n    private void appendDecimalPart(long num, long den){\\n\\n        HashMap<Long,Integer> map = new HashMap<>();\\n        sb.append(\".\");\\n        while(num !=0){\\n\\n            num *= 10;\\n            sb.append(num/den);\\n            num %= den;\\n\\n            if(map.containsKey(num)){\\n                sb.insert(map.get(num),\"(\");\\n                sb.append(\")\");\\n                return;\\n            }\\n            else{\\n                map.put(num,sb.length());\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816835,
                "title": "simple-java-solution-beats-99",
                "content": "```\\nclass Solution {\\n    public String fractionToDecimal(int n, int d) \\n    {\\n        long a = Math.abs((long)n);\\n        long b = Math.abs((long)d);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        if( (n<0 && d>0) || (n>0 && d<0))\\n            sb.append(\\'-\\');\\n        \\n        sb.append(a/b);\\n        a = a%b;\\n        \\n        if(a > 0)\\n            sb.append(\\'.\\');\\n        \\n        HashMap<Long,Integer> map = new HashMap<>();\\n        \\n        while(!map.containsKey(a))\\n        {\\n            map.put(a , map.size());\\n            a = a*10;\\n            \\n            if(a > 0)\\n                sb.append(a/b);\\n            \\n            a = a%b;\\n        }\\n        \\n        if(a > 0)\\n        {\\n            sb.insert(sb.length()-(map.size()-map.get(a)) , \\'(\\');\\n            sb.append(\\')\\');\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int n, int d) \\n    {\\n        long a = Math.abs((long)n);\\n        long b = Math.abs((long)d);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        if( (n<0 && d>0) || (n>0 && d<0))\\n            sb.append(\\'-\\');\\n        \\n        sb.append(a/b);\\n        a = a%b;\\n        \\n        if(a > 0)\\n            sb.append(\\'.\\');\\n        \\n        HashMap<Long,Integer> map = new HashMap<>();\\n        \\n        while(!map.containsKey(a))\\n        {\\n            map.put(a , map.size());\\n            a = a*10;\\n            \\n            if(a > 0)\\n                sb.append(a/b);\\n            \\n            a = a%b;\\n        }\\n        \\n        if(a > 0)\\n        {\\n            sb.insert(sb.length()-(map.size()-map.get(a)) , \\'(\\');\\n            sb.append(\\')\\');\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174526,
                "title": "simple-to-understand",
                "content": "\\n    string fractionToDecimal(int a, int d) \\n    {\\n        long long n=a;\\n        if(n%d==0)\\n            return to_string(n/d);\\n        \\n        string ans;\\n        if(n<0^d<0)\\n            ans+=\\'-\\';\\n        \\n        n=abs(n),d=abs(d);\\n        \\n        ans+=to_string((n/d));\\n        ans+=\\'.\\';\\n        n%=d;\\n        n*=10;\\n        \\n        unordered_map<long long,int>mp;\\n        \\n        \\n        while(n)\\n        {\\n            if(mp.count(n))\\n            {\\n                ans.insert(mp[n],\"(\");\\n                ans+=\")\";\\n                break;\\n            }\\n            mp[n]=ans.size();\\n            ans+=(n/d)+\\'0\\';  \\n            n%=d;\\n            n*=10;\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\n**upvode only when you understand this.**",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n    string fractionToDecimal(int a, int d) \\n    {\\n        long long n=a;\\n        if(n%d==0)\\n            return to_string(n/d);\\n        \\n        string ans;\\n        if(n<0^d<0)\\n            ans+=\\'-\\';\\n        \\n        n=abs(n),d=abs(d);\\n        \\n        ans+=to_string((n/d));\\n        ans+=\\'.\\';\\n        n%=d;\\n        n*=10;\\n        \\n        unordered_map<long long,int>mp;\\n        \\n        \\n        while(n)\\n        {\\n            if(mp.count(n))\\n            {\\n                ans.insert(mp[n],\"(\");\\n                ans+=\")\";\\n                break;\\n            }\\n            mp[n]=ans.size();\\n            ans+=(n/d)+\\'0\\';  \\n            n%=d;\\n            n*=10;\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\n**upvode only when you understand this.**",
                "codeTag": "Unknown"
            },
            {
                "id": 1828185,
                "title": "java-1ms-100",
                "content": "class Solution {\\n\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        \\n        if(numerator == 0)\\n            return \"0\";\\n        \\n        StringBuilder res = new StringBuilder();\\n        \\n        if(numerator < 0 ^ denominator < 0)\\n            res.append(\"-\");\\n        \\n        long n = Math.abs((long) numerator);\\n        long d = Math.abs((long) denominator);\\n        \\n        long q = n / d;\\n        long r = n % d;\\n        res.append(q);\\n        \\n        if(r == 0)\\n            return res.toString();\\n        else{\\n            res.append(\".\");\\n            \\n            HashMap<Long, Integer> map = new HashMap<>();\\n            \\n            while(r != 0) {\\n                if(map.containsKey(r)){\\n                    int len = map.get(r);\\n                    res.insert(len,\"(\");\\n                    res.append(\")\");\\n                    break;\\n                }else{\\n                    map.put(r,res.length());\\n                    r = r * 10;\\n                    q = r / d;\\n                    r = r % d;\\n                    res.append(q);\\n                }\\n            }\\n        }\\n            \\n        return res.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        \\n        if(numerator == 0)\\n            return \"0\";\\n        \\n        StringBuilder res = new StringBuilder();\\n        \\n        if(numerator < 0 ^ denominator < 0)\\n            res.append(\"-\");\\n        \\n        long n = Math.abs((long) numerator);\\n        long d = Math.abs((long) denominator);\\n        \\n        long q = n / d;\\n        long r = n % d;\\n        res.append(q);\\n        \\n        if(r == 0)\\n            return res.toString();\\n        else{\\n            res.append(\".\");\\n            \\n            HashMap<Long, Integer> map = new HashMap<>();\\n            \\n            while(r != 0) {\\n                if(map.containsKey(r)){\\n                    int len = map.get(r);\\n                    res.insert(len,\"(\");\\n                    res.append(\")\");\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1764668,
                "title": "c-solution-in-0-ms-unordered-map-clean-commented-code",
                "content": "\\tstring fractionToDecimal(long a, long b) {\\n\\t\\t//base case\\n        if(a==0) return \"0\";\\n        string res;\\n\\t\\t//checking if either of the numerator or denominator is negitive\\n        if(a<0 ^ b<0) res=\\'-\\'+res;\\n        a=abs(a);\\n        b=abs(b);\\n\\t\\t//append the result of a/b to string\\n        res+=to_string(a/b);\\n\\t\\t//If there is remainder for a/b then decimal point exists\\n        if(a%b==0) return res;\\n        res+=\".\";\\n        long rem=a%b;\\n\\t\\t//map to store the index of occurance particular remainder\\n\\t\\t//If the same remainder is seen again we will use the first occuarance of that remainder and put in paranthesis indicating that sequence is repeating\\n        unordered_map<long,long> m;\\n        while(rem){\\n            if(m.find(rem)!=m.end()){\\n                res.insert(res.begin()+m[rem],\\'(\\');\\n                res.push_back(\\')\\');\\n                break;\\n            }\\n            m[rem]=res.size();\\n            rem*=10;\\n            res+=to_string(rem/b);\\n            rem=rem%b;\\n        }\\n        return res;\\n    }\\n\\nPlease upvote : )",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tstring fractionToDecimal(long a, long b) {\\n\\t\\t//base case\\n        if(a==0) return \"0\";\\n        string res;\\n\\t\\t//checking if either of the numerator or denominator is negitive\\n        if(a<0 ^ b<0) res=\\'-\\'+res;\\n        a=abs(a);\\n        b=abs(b);\\n\\t\\t//append the result of a/b to string\\n        res+=to_string(a/b);\\n\\t\\t//If there is remainder for a/b then decimal point exists\\n        if(a%b==0) return res;\\n        res+=\".\";\\n        long rem=a%b;\\n\\t\\t//map to store the index of occurance particular remainder\\n\\t\\t//If the same remainder is seen again we will use the first occuarance of that remainder and put in paranthesis indicating that sequence is repeating\\n        unordered_map<long,long> m;\\n        while(rem){\\n            if(m.find(rem)!=m.end()){\\n                res.insert(res.begin()+m[rem],\\'(\\');\\n                res.push_back(\\')\\');\\n                break;\\n            }\\n            m[rem]=res.size();\\n            rem*=10;\\n            res+=to_string(rem/b);\\n            rem=rem%b;\\n        }\\n        return res;\\n    }\\n\\nPlease upvote : )",
                "codeTag": "Unknown"
            },
            {
                "id": 1668331,
                "title": "python3-with-explanation-runtime-around-40ms-65ms",
                "content": "Although this is not the most perfect solution, I would like to share this with you and please feel free to comment below!\\n### Logic\\n* I handle this problem with memorization. As shown in the code, there are 2 arrays, the remainders and the quotients records the values of each round of division respectively.\\n* During the while loop, we check the current numerator value.\\n\\t* If the numerator is 0, which means the original numerator does not have recurring decimal, we can break the loop.\\n\\t* Otherwise, we will power the current numerator by 10 and start the next division.\\n\\t\\t* If the new numerator is already stored in the remainders, which means the following division operations will lead to recurring decimal, we can break the loop and return the answer.\\n\\t\\t* Otherwise, record the remainder and quotient, and update the numerator to its remainder.\\n* Finally, we will add the negative sign if necessary.\\n\\n### Code\\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        neg = True if numerator/denominator < 0 else False\\n        numerator = -numerator if numerator < 0 else numerator\\n        denominator = -denominator if denominator < 0 else denominator\\n        out = str(numerator//denominator)\\n        if numerator % denominator:\\n            out += \".\"\\n        remainders = []\\n        quotients = []\\n        numerator %= denominator\\n        while numerator:\\n            numerator *= 10\\n            if str(numerator) in remainders:\\n                duplicateStart = remainders.index(str(numerator))\\n                out += \"\".join(quotients[:duplicateStart])\\n                out += \"(\"+\"\".join(quotients[duplicateStart:])+\")\"\\n                return \"-\"+out if neg else out\\n            else:\\n                remainders.append(str(numerator))\\n                quotients.append(str(numerator // denominator))\\n                numerator %= denominator\\n        out += \"\".join(quotients)\\n        return \"-\"+out if neg else out\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        neg = True if numerator/denominator < 0 else False\\n        numerator = -numerator if numerator < 0 else numerator\\n        denominator = -denominator if denominator < 0 else denominator\\n        out = str(numerator//denominator)\\n        if numerator % denominator:\\n            out += \".\"\\n        remainders = []\\n        quotients = []\\n        numerator %= denominator\\n        while numerator:\\n            numerator *= 10\\n            if str(numerator) in remainders:\\n                duplicateStart = remainders.index(str(numerator))\\n                out += \"\".join(quotients[:duplicateStart])\\n                out += \"(\"+\"\".join(quotients[duplicateStart:])+\")\"\\n                return \"-\"+out if neg else out\\n            else:\\n                remainders.append(str(numerator))\\n                quotients.append(str(numerator // denominator))\\n                numerator %= denominator\\n        out += \"\".join(quotients)\\n        return \"-\"+out if neg else out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651060,
                "title": "python-solution-with-a-bit-of-explanation",
                "content": "The time complexity of this method is O(1) because the resulting array cannot be longer than 10000, which means the loop doesn\\'t go beyond 10000 iterations. The space complexity is also O(1) for the same reason, which might not depend on either numerator or the denominator.\\n\\nLet us list the possible test cases that this problem might need to deal with later.\\n\\tA) 1/90                 => 0.0(1)\\n\\tB) -1/90               =>-0.0(1)\\n\\tC) 0/-10               =>0\\n\\tD)4/2                    =>2\\n\\tE)2565/100000  =>0.02565\\n\\t\\nNow, let us go through the solution below.\\n1) First, we will return if the numerator is 0 because the answer will always be 0.\\n2) Second, we will check the sign of the resulting number. If both are positive or negative, then the resulting number will be positive; otherwise, it will be negative.\\n3) Third, we will divide the numerator by the denominator, add that value to the result, and keep track of the reminder.\\n4) Forth, if the remainder is 0, the denominator perfectly divides the numerator, which means we can return the result.\\n5) Fifth, if there is a remainder, we will add \".\" to the result because we will further divide the remainder to get results after the decimal place.\\n6) Sixth, this is the central part because most of the portion before this is relatively straightforward. We will keep track of the remainder and the length of the resulting array in a hash map. If we have previously seen that remainder, the result will have recurring numbers in decimal. And by keeping track of the length of the resulting array, we will know where to place the start bracket in the result. So, if we have already seen the reminder earlier, we will return here by placing the start bracket and end bracket in the result. We will need to multiply the remainder by 10 in each step. If we want to do the following division 1/90, then the remainder will be 1 before the for loop begins. Then we will need to multiply it by 10, and the new remainder will be 10, and then we will multiply it by 10 again, and the new val will be 1 and the remainder will be 10 again.\\n7) Seventh, when the remainder becomes 0, like in the case 1/1000000000000000 where it might take a while, we will break the while loop and return the result.\\n(Sorry for the bad English)\\n\\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0:\\n            return \"0\"\\n        negative_sign = (numerator < 0) ^ (denominator < 0)\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        result = [\"-\"] if negative_sign else []\\n        result.append(str(numerator // denominator))\\n        remainder = numerator % denominator\\n        \\n        seen_numerator = {}\\n        if remainder == 0:\\n            return \"\".join(result)\\n        \\n        result.append(\".\")\\n        while remainder != 0:\\n            if remainder in seen_numerator:\\n                result.append(\")\")\\n                small_pos = seen_numerator[remainder]\\n                return \"\".join(result[:small_pos]) + \"(\"+\"\".join(result[small_pos:])\\n            seen_numerator[remainder] = len(result)\\n            remainder *= 10\\n            val = remainder // denominator\\n            remainder %= denominator\\n            result.append(str(val))\\n        return \"\".join(result)\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0:\\n            return \"0\"\\n        negative_sign = (numerator < 0) ^ (denominator < 0)\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        result = [\"-\"] if negative_sign else []\\n        result.append(str(numerator // denominator))\\n        remainder = numerator % denominator\\n        \\n        seen_numerator = {}\\n        if remainder == 0:\\n            return \"\".join(result)\\n        \\n        result.append(\".\")\\n        while remainder != 0:\\n            if remainder in seen_numerator:\\n                result.append(\")\")\\n                small_pos = seen_numerator[remainder]\\n                return \"\".join(result[:small_pos]) + \"(\"+\"\".join(result[small_pos:])\\n            seen_numerator[remainder] = len(result)\\n            remainder *= 10\\n            val = remainder // denominator\\n            remainder %= denominator\\n            result.append(str(val))\\n        return \"\".join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639085,
                "title": "clean-java-with-comment",
                "content": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) return \"0\";\\n        \\n        StringBuilder builder = new StringBuilder();\\n        \\n        // if negative, append -\\n        if(numerator < 0 && denominator > 0 || numerator > 0 && denominator < 0) builder.append(\"-\");\\n        \\n        // avoid integer overflow by converting to long\\n        long divisor = Math.abs((long) numerator);\\n        long dividend = Math.abs((long) denominator);\\n        \\n        long remainder = divisor % dividend;\\n        builder.append(divisor / dividend);\\n        \\n        // no decimal \\n        if(remainder == 0) return builder.toString();\\n        \\n        builder.append(\".\");\\n        \\n        // key is the remainder, value is the position in the result string\\n        Map<Long, Integer> map = new HashMap<>();\\n        \\n        while(remainder != 0) {\\n            // check if remainder is repeating\\n            if(map.containsKey(remainder)) {\\n                //insert ( before the repeating num\\n                builder.insert(map.get(remainder), \"(\");\\n                //insert ) after the repeatingn num\\n                builder.append(\")\");\\n                break;\\n            }\\n            \\n            // first time seeing the remainder\\n            // position is the end of the string\\n            map.put(remainder, builder.length());\\n            // continue to divide the dividend so we should *= 10 as per normal long division\\n            remainder *= 10;\\n            builder.append(remainder / dividend);\\n            remainder %= dividend;\\n        }\\n        \\n        return builder.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) return \"0\";\\n        \\n        StringBuilder builder = new StringBuilder();\\n        \\n        // if negative, append -\\n        if(numerator < 0 && denominator > 0 || numerator > 0 && denominator < 0) builder.append(\"-\");\\n        \\n        // avoid integer overflow by converting to long\\n        long divisor = Math.abs((long) numerator);\\n        long dividend = Math.abs((long) denominator);\\n        \\n        long remainder = divisor % dividend;\\n        builder.append(divisor / dividend);\\n        \\n        // no decimal \\n        if(remainder == 0) return builder.toString();\\n        \\n        builder.append(\".\");\\n        \\n        // key is the remainder, value is the position in the result string\\n        Map<Long, Integer> map = new HashMap<>();\\n        \\n        while(remainder != 0) {\\n            // check if remainder is repeating\\n            if(map.containsKey(remainder)) {\\n                //insert ( before the repeating num\\n                builder.insert(map.get(remainder), \"(\");\\n                //insert ) after the repeatingn num\\n                builder.append(\")\");\\n                break;\\n            }\\n            \\n            // first time seeing the remainder\\n            // position is the end of the string\\n            map.put(remainder, builder.length());\\n            // continue to divide the dividend so we should *= 10 as per normal long division\\n            remainder *= 10;\\n            builder.append(remainder / dividend);\\n            remainder %= dividend;\\n        }\\n        \\n        return builder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618999,
                "title": "a-fast-simple-and-easy-to-follow-python-solution",
                "content": "A lot of solutions out there are way too much for me. The following is a simplied python solution with explanation in plain language. I hope that helps. \\n\\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        \\n        # base case\\n        if numerator == 0:\\n            return \\'0\\'\\n        \\n        # result\\n        res = \\'\\'\\n        \\n        # positive and negative\\n        if (numerator > 0 and denominator < 0) or \\\\\\n            (numerator < 0 and denominator > 0):\\n            res += \\'-\\'\\n        \\n        # absolute value\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        # remainder as zero\\n        res += str(numerator//denominator)\\n        numerator %= denominator\\n        if numerator == 0:\\n            return res\\n        \\n        # add a dot .\\n        res += \\'.\\'\\n        \\n        # hashmap to write down the starting index of a repeated remainder\\n        hashmap = {}\\n        hashmap[numerator] = len(res)\\n        while numerator != 0:\\n            \\n            # continue to mutiply by 10\\n            numerator *= 10\\n            res += str(numerator//denominator)\\n            numerator %= denominator\\n            \\n            # check if it finds a repeated pattern\\n            if numerator in hashmap:\\n                index = hashmap[numerator]\\n                res = res[:index] + \\'(\\' + res[index:]\\n                res += \\')\\'\\n                break\\n            else:\\n                hashmap[numerator] = len(res)\\n                 \\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        \\n        # base case\\n        if numerator == 0:\\n            return \\'0\\'\\n        \\n        # result\\n        res = \\'\\'\\n        \\n        # positive and negative\\n        if (numerator > 0 and denominator < 0) or \\\\\\n            (numerator < 0 and denominator > 0):\\n            res += \\'-\\'\\n        \\n        # absolute value\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        # remainder as zero\\n        res += str(numerator//denominator)\\n        numerator %= denominator\\n        if numerator == 0:\\n            return res\\n        \\n        # add a dot .\\n        res += \\'.\\'\\n        \\n        # hashmap to write down the starting index of a repeated remainder\\n        hashmap = {}\\n        hashmap[numerator] = len(res)\\n        while numerator != 0:\\n            \\n            # continue to mutiply by 10\\n            numerator *= 10\\n            res += str(numerator//denominator)\\n            numerator %= denominator\\n            \\n            # check if it finds a repeated pattern\\n            if numerator in hashmap:\\n                index = hashmap[numerator]\\n                res = res[:index] + \\'(\\' + res[index:]\\n                res += \\')\\'\\n                break\\n            else:\\n                hashmap[numerator] = len(res)\\n                 \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501693,
                "title": "accepted-java-solution-through-long-division-using-a-string-builder-and-a-hash-map",
                "content": "```\\nclass Solution {\\n    private static final String MINUS = \"-\";\\n    private static final String DECIMAL_POINT = \".\";\\n    private static final String OPENING_BRACKET = \"(\";\\n    private static final String CLOSING_BRACKET = \")\";\\n    \\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if(0==numerator){\\n            return \"0\";\\n        }\\n        \\n        StringBuilder formattedFraction = new StringBuilder();\\n        \\n        if(numerator<0 ^ denominator<0){\\n            formattedFraction.append(MINUS);\\n        }\\n        \\n        long dividend = Math.abs(Long.valueOf(numerator));\\n        long divisor = Math.abs(Long.valueOf(denominator));\\n        \\n        formattedFraction.append(String.valueOf(dividend/divisor));\\n        long remainder = dividend%divisor;\\n        \\n        if(0==remainder){\\n            return formattedFraction.toString();\\n        }\\n        \\n        formattedFraction.append(DECIMAL_POINT);\\n        \\n        //Structure to Hash and Store all the Remainder Sequences we have encountered so far\\n        Map<Long,Integer> seqeuences = new HashMap<Long,Integer>();\\n        \\n        while(0!=remainder){\\n            if(seqeuences.containsKey(remainder)){\\n                formattedFraction.insert(seqeuences.get(remainder),OPENING_BRACKET);\\n                formattedFraction.append(CLOSING_BRACKET);\\n                break;\\n            }\\n            \\n            seqeuences.put(remainder,formattedFraction.length());\\n            remainder*=10;\\n            formattedFraction.append(String.valueOf(remainder/divisor));\\n            remainder %= divisor; \\n        }\\n        \\n        return formattedFraction.toString();\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    private static final String MINUS = \"-\";\\n    private static final String DECIMAL_POINT = \".\";\\n    private static final String OPENING_BRACKET = \"(\";\\n    private static final String CLOSING_BRACKET = \")\";\\n    \\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if(0==numerator){\\n            return \"0\";\\n        }\\n        \\n        StringBuilder formattedFraction = new StringBuilder();\\n        \\n        if(numerator<0 ^ denominator<0){\\n            formattedFraction.append(MINUS);\\n        }\\n        \\n        long dividend = Math.abs(Long.valueOf(numerator));\\n        long divisor = Math.abs(Long.valueOf(denominator));\\n        \\n        formattedFraction.append(String.valueOf(dividend/divisor));\\n        long remainder = dividend%divisor;\\n        \\n        if(0==remainder){\\n            return formattedFraction.toString();\\n        }\\n        \\n        formattedFraction.append(DECIMAL_POINT);\\n        \\n        //Structure to Hash and Store all the Remainder Sequences we have encountered so far\\n        Map<Long,Integer> seqeuences = new HashMap<Long,Integer>();\\n        \\n        while(0!=remainder){\\n            if(seqeuences.containsKey(remainder)){\\n                formattedFraction.insert(seqeuences.get(remainder),OPENING_BRACKET);\\n                formattedFraction.append(CLOSING_BRACKET);\\n                break;\\n            }\\n            \\n            seqeuences.put(remainder,formattedFraction.length());\\n            remainder*=10;\\n            formattedFraction.append(String.valueOf(remainder/divisor));\\n            remainder %= divisor; \\n        }\\n        \\n        return formattedFraction.toString();\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427700,
                "title": "python-3-solution-using-hashmap",
                "content": "```\\ndef fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\tneg = (numerator<0 and denominator>0) or (numerator>0 and denominator<0)\\n\\tnumerator = abs(numerator) \\n\\tdenominator = abs(denominator)\\n\\n\\tres = [str(numerator//denominator)]\\n\\tindex = 1\\n\\tnumerator%=denominator\\n\\tif numerator!=0:\\n\\t\\tres.append(\".\")\\n\\t\\tindex+=1\\n\\tdic = {}\\n\\n\\twhile numerator!=0:\\n\\t\\tif numerator in dic:\\n\\t\\t\\tres = res[:dic[numerator]] + [\"(\"] + res[dic[numerator]:] + [\")\"]\\n\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\tdic[numerator] = index\\n\\t\\tnumerator*=10\\n\\t\\tres.append(str(numerator//denominator))\\n\\t\\tindex+=1\\n\\t\\tnumerator%=denominator\\n\\treturn \"\".join(res) if not neg else \"-\"+\"\".join(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\tneg = (numerator<0 and denominator>0) or (numerator>0 and denominator<0)\\n\\tnumerator = abs(numerator) \\n\\tdenominator = abs(denominator)\\n\\n\\tres = [str(numerator//denominator)]\\n\\tindex = 1\\n\\tnumerator%=denominator\\n\\tif numerator!=0:\\n\\t\\tres.append(\".\")\\n\\t\\tindex+=1\\n\\tdic = {}\\n\\n\\twhile numerator!=0:\\n\\t\\tif numerator in dic:\\n\\t\\t\\tres = res[:dic[numerator]] + [\"(\"] + res[dic[numerator]:] + [\")\"]\\n\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\tdic[numerator] = index\\n\\t\\tnumerator*=10\\n\\t\\tres.append(str(numerator//denominator))\\n\\t\\tindex+=1\\n\\t\\tnumerator%=denominator\\n\\treturn \"\".join(res) if not neg else \"-\"+\"\".join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1402927,
                "title": "c-4ms-explained-easy-to-understand",
                "content": "1. Calculate the decimal part and add to ans.\\n2. Run loop till remainder is 0 or remainder is seen already in the calculation.\\n3. Add the decimal part of remainder/denominator to the ans.\\n**Note:**\\n1. Using index because we need to insert \"(\" at the start of the remainder that is repeating.\\nFor ex: consider 2/30 = 0.0666..., so answer should be 0.0(6) not 0.(06).\\nFor the same reason, map is used instead of set.\\n2. Using long and labs for INT_MIN.\\n\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n    if(numerator==0) return \"0\";\\n    string ans;\\n    unordered_map<long int,int> mp;\\n    if((numerator<0 && denominator>0) || (numerator>0 && denominator<0)) ans=ans+\"-\";\\n    long int num=labs(numerator),den=labs(denominator);    \\n    long int remainder,decimal=num/den;\\n    int curdigit,index;\\n    remainder=num%den,\\n    ans=ans+to_string(decimal);\\n    if(remainder!=0) ans=ans+\".\";\\n    index=ans.size();\\n    while(remainder!=0)\\n    {\\n        if(mp.find(remainder)!=mp.end())\\n        {\\n            ans.insert(mp[remainder],\"(\");\\n            ans=ans+\")\";\\n            break;\\n        }\\n        mp[remainder]=index;\\n        remainder=remainder*10 ;\\n        curdigit=remainder/den;\\n        ans=ans+to_string(curdigit);\\n        remainder=remainder%den;\\n        index++;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n    if(numerator==0) return \"0\";\\n    string ans;\\n    unordered_map<long int,int> mp;\\n    if((numerator<0 && denominator>0) || (numerator>0 && denominator<0)) ans=ans+\"-\";\\n    long int num=labs(numerator),den=labs(denominator);    \\n    long int remainder,decimal=num/den;\\n    int curdigit,index;\\n    remainder=num%den,\\n    ans=ans+to_string(decimal);\\n    if(remainder!=0) ans=ans+\".\";\\n    index=ans.size();\\n    while(remainder!=0)\\n    {\\n        if(mp.find(remainder)!=mp.end())\\n        {\\n            ans.insert(mp[remainder],\"(\");\\n            ans=ans+\")\";\\n            break;\\n        }\\n        mp[remainder]=index;\\n        remainder=remainder*10 ;\\n        curdigit=remainder/den;\\n        ans=ans+to_string(curdigit);\\n        remainder=remainder%den;\\n        index++;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087090,
                "title": "easy-python-solution",
                "content": "```python\\nclass Solution:\\n    def fractionToDecimal(self, N: int, D: int) -> str:\\n        neg = True\\n        if (N < 0 and D < 0) or (N >= 0 and D >= 0): neg = False\\n        N = abs(N)\\n        D = abs(D)\\n        rem = N % D\\n        q = N // D\\n        res = [(\"-\" if neg else \"\") + str(q)]                \\n        maps = {}        \\n        if rem == 0:\\n            return str((-1 if neg else 1) * q)\\n        else:\\n            res.append(\\'.\\')\\n            while rem != 0:        \\n                if rem in maps:\\n                    res.append(\\')\\')\\n                    res.insert(maps[rem] , \\'(\\')\\n                    break;\\n                else:\\n                    maps[rem] = len(res)\\n                    rem *= 10\\n                    res.append(str(rem // D))\\n                    rem %= D\\n        return \"\".join(res)\\n        \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def fractionToDecimal(self, N: int, D: int) -> str:\\n        neg = True\\n        if (N < 0 and D < 0) or (N >= 0 and D >= 0): neg = False\\n        N = abs(N)\\n        D = abs(D)\\n        rem = N % D\\n        q = N // D\\n        res = [(\"-\" if neg else \"\") + str(q)]                \\n        maps = {}        \\n        if rem == 0:\\n            return str((-1 if neg else 1) * q)\\n        else:\\n            res.append(\\'.\\')\\n            while rem != 0:        \\n                if rem in maps:\\n                    res.append(\\')\\')\\n                    res.insert(maps[rem] , \\'(\\')\\n                    break;\\n                else:\\n                    maps[rem] = len(res)\\n                    rem *= 10\\n                    res.append(str(rem // D))\\n                    rem %= D\\n        return \"\".join(res)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083481,
                "title": "very-clear-solution-with-python-with-detailed-comment",
                "content": "```python\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # the key idea of solving this problem is how to detect repeating\\n        # and locate where to add parentheses\\n        # the answer is generate the decimal part with mod operation and recalculate\\n        # the remainer time by time. When meeting same remainer, there have repeating\\n        # and the begining of the repeating is the index where you first meet\\n        # the same remainer\\n        res = \"\"\\n        # determinate symbol with xor, remeber 0 have not negative one\\n        if numerator ^ denominator < 0 and numerator != 0:\\n            res += \"-\"\\n        numerator = abs(numerator)\\n        denominator = abs(denominator)\\n        # calculate the integral part\\n        res += str(int(numerator / denominator))\\n        remainder_index = {}\\n        remainder = numerator % denominator\\n        # calculate the decimal part\\n        if remainder != 0:\\n            res += \".\"\\n        while remainder:\\n            # detect same remainer, so we can locate the repeating part\\n            if remainder in remainder_index:\\n                res = res[0:remainder_index[remainder]] + \\'(\\' + res[remainder_index[remainder]:] + \\')\\'\\n                # please notice that the rest calculate is repeating, so break now\\n                break\\n            \\n            remainder_index[remainder] = len(res)\\n            remainder *= 10\\n            res += str(int(remainder / denominator))\\n            remainder %= denominator\\n            \\n        return res",
                "solutionTags": [],
                "code": "class Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # the key idea of solving this problem is how to detect repeating\\n        # and locate where to add parentheses\\n        # the answer is generate the decimal part with mod operation and recalculate\\n        # the remainer time by time. When meeting same remainer, there have repeating\\n        # and the begining of the repeating is the index where you first meet\\n        # the same remainer\\n        res = \"\"\\n        # determinate symbol with xor, remeber 0 have not negative one\\n        if numerator ^ denominator < 0 and numerator != 0:\\n            res += \"-\"\\n        numerator = abs(numerator)\\n        denominator = abs(denominator)\\n        # calculate the integral part\\n        res += str(int(numerator / denominator))\\n        remainder_index = {}",
                "codeTag": "Java"
            },
            {
                "id": 907216,
                "title": "java-1-ms-faster-than-99-91-36-4-mb-less-than-20-75",
                "content": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) {\\n            return \"0\";\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        if (numerator < 0 ^ denominator < 0) {\\n            sb.append(\"-\");\\n        }\\n        long up = Math.abs((long) numerator);\\n        long down = Math.abs((long) denominator);\\n        sb.append(up / down);\\n        long rem = up % down;\\n        if (rem == 0) {\\n            return sb.toString();\\n        }\\n        sb.append(\".\");\\n        Map<Long, Integer> idxs = new HashMap<>();\\n        while (rem != 0) {\\n            if (idxs.containsKey(rem)) {\\n                sb.insert(idxs.get(rem), \"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n            idxs.put(rem, sb.length());\\n            rem *= 10;\\n            sb.append(rem / down);\\n            rem %= down;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) {\\n            return \"0\";\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        if (numerator < 0 ^ denominator < 0) {\\n            sb.append(\"-\");\\n        }\\n        long up = Math.abs((long) numerator);\\n        long down = Math.abs((long) denominator);\\n        sb.append(up / down);\\n        long rem = up % down;\\n        if (rem == 0) {\\n            return sb.toString();\\n        }\\n        sb.append(\".\");\\n        Map<Long, Integer> idxs = new HashMap<>();\\n        while (rem != 0) {\\n            if (idxs.containsKey(rem)) {\\n                sb.insert(idxs.get(rem), \"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n            idxs.put(rem, sb.length());\\n            rem *= 10;\\n            sb.append(rem / down);\\n            rem %= down;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 837008,
                "title": "python-solution-with-intuition",
                "content": "Intuition: First we handle the special case where numerator is zero. We build our final output in an array, and at the end we return this array. We take into account the signs initially so that we can do our division dealing with only positive numbers. XOR operation enables us to quickly determine if exactly one of numerator or denominator is negative. We separate our solution into two parts, the integral part and the decimal part.\\n\\nFor the integral part, we need to use integer division to see how many times denominator goes into numerator. This will be zero if denominator > numerator. This makes sense because if a denominator is bigger than a numerator, then the integral portion of our decimal will be zero. Once we handle the integral portion, we then move onto the decimal part. \\n\\nFor the decimal part, we are looking for the point at which remainders begin to repeat, in our long division. At the point in which we see a repeat remainder, we know that we have a cycle and that there will be repeats from here onward. If remainder gets to zero, that means the decimal part does not have a cycle, and we exit the while loop accordingly. \\n\\nWithin the while loop we handle the long division for the decimal part. At the same time, we maintain a dictionary of remainders we\\'ve seen so far, as well as the index we saw this remainder. The while loop has two ways of exiting:\\n- Case 1: We see a remainder we saw in the past, which indicates a cycle. So we insert parentheses where needed and we exit.\\n- Case 2: remainder makes it down to zero, which indicates that the decimal portion has no cycle. So we return.\\n\\n**Time complexity**: Similar to the space complexity analysis done below, this problem does not have a traditionally well defined large input, since if we consider an input like numerator = 9000, denominator = 1, Time complexity is constant, even though numerator is large. Time complexity really only depends on the size of the cycle. But size of cycle does not depend on the \"size\" of either numerator or denominator. So time complexity is not well defined here either. \\n**Space complexity**: This will depend on how much space our output array uses. Our output array uses as much space as the longest cycle. This does not directly depend on numerator, denominator, at least in the traditional way we do space complexity analyses. Because large inputs are not well defined in this case. Because a large input could be numerator = 9000, denominator = 1, but that has a constant time for output. So space complexity is not well defined, since we don\\'t have a traditonally well defined large input, with which our space complexity grows alongside. \\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0: return \"0\"\\n        output = []\\n        \\n        if (numerator < 0) ^ (denominator < 0): \\n            output.append(\\'-\\')\\n            \\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        # integral part\\n        quotient = numerator // denominator\\n        output.append(str(quotient)) # do i need str here?\\n        remainder = numerator % denominator\\n        \\n        if remainder == 0: return \\'\\'.join(output)\\n        \\n        # decimal part\\n        output.append(\\'.\\')\\n        remainderToIndexSeen={}\\n        \\n        while remainder != 0:\\n            if remainder in remainderToIndexSeen:\\n                output.insert(remainderToIndexSeen[remainder], \"(\")\\n                output.append(\")\")\\n                break\\n            remainderToIndexSeen[remainder] = len(output)\\n            \\n            # Next 3 lines of code simulate 3 steps of long division:\\n            \\n            # 1) bring down the zero\\n            remainder *= 10 \\n            \\n            # 2) find the next part of quotient\\n            output.append(str(remainder // denominator)) \\n            \\n            # 3) subtract to find the new remainder\\n            remainder %= denominator \\n        \\n        return \\'\\'.join(output)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0: return \"0\"\\n        output = []\\n        \\n        if (numerator < 0) ^ (denominator < 0): \\n            output.append(\\'-\\')\\n            \\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        # integral part\\n        quotient = numerator // denominator\\n        output.append(str(quotient)) # do i need str here?\\n        remainder = numerator % denominator\\n        \\n        if remainder == 0: return \\'\\'.join(output)\\n        \\n        # decimal part\\n        output.append(\\'.\\')\\n        remainderToIndexSeen={}\\n        \\n        while remainder != 0:\\n            if remainder in remainderToIndexSeen:\\n                output.insert(remainderToIndexSeen[remainder], \"(\")\\n                output.append(\")\")\\n                break\\n            remainderToIndexSeen[remainder] = len(output)\\n            \\n            # Next 3 lines of code simulate 3 steps of long division:\\n            \\n            # 1) bring down the zero\\n            remainder *= 10 \\n            \\n            # 2) find the next part of quotient\\n            output.append(str(remainder // denominator)) \\n            \\n            # 3) subtract to find the new remainder\\n            remainder %= denominator \\n        \\n        return \\'\\'.join(output)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827938,
                "title": "solution-without-storing-all-remainders-o-1-space-python",
                "content": "Explanations added in the code as comments\\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0:\\n            return \"0\"\\n        \\n        # Find sign of result\\n        sign = 1\\n        if numerator < 0:\\n            numerator = -numerator\\n            sign *= -1\\n        if denominator < 0:\\n            denominator = -denominator\\n            sign *= -1\\n        \\n        # Calculate integer part before the decimal\\n        intPart = int(numerator / denominator)\\n        numerator %= denominator\\n        numerator = numerator = numerator\\n        \\n        # Ensure that the numerator and denominator do not have 2 or 5\\n        # as a common factor\\n        while numerator % 2 == 0 and denominator % 2 == 0:\\n            numerator /= 2\\n            denominator /= 2\\n        while numerator % 5 == 5 and denominator % 5 == 0:\\n            numerator /= 5\\n            denominator /= 5\\n            \\n        # At this point the number of non recurring digits after the decimal\\n        # point will be:\\n        # Max(m,n)\\n        # where m is the highest number for which 2^m divides denominator\\n        # and n is the highest number for which 5^n divides denominator\\n        num = denominator\\n        num2Factors = 0\\n        while num % (2 ** (num2Factors + 1)) == 0:\\n            num2Factors += 1\\n        num5Factors = 0\\n        while num % (5 ** (num5Factors + 1)) == 0:\\n            num5Factors += 1\\n        nonRecc = max(num2Factors, num5Factors)\\n        \\n        # Calculate the non recurring decimal part of the result\\n        decPart = \\'\\'\\n        while nonRecc and numerator:\\n            numerator *= 10\\n            decPart += str(int(numerator / denominator))\\n            numerator %= denominator\\n            nonRecc -= 1\\n            \\n        # firstNum is the numerator which will be repeated in the recurring part\\n        # of the result.\\n        # Calculate the recurring decimal part of the result by dividing until\\n        # we get firstNum again.\\n        firstNum = numerator\\n        reccPart = \\'\\'\\n        while numerator:\\n            numerator *= 10\\n            reccPart += str(int(numerator / denominator))\\n            numerator %= denominator\\n            if numerator == firstNum:\\n                break\\n        \\n        # Construct the result from the individual parts\\n        res = \\'\\' if sign == 1 else \\'-\\'\\n        res += str(intPart)\\n        if decPart or reccPart:\\n            res += \\'.\\'\\n        res += decPart\\n        if reccPart:\\n            res += \\'(\\' + reccPart + \\')\\'\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0:\\n            return \"0\"\\n        \\n        # Find sign of result\\n        sign = 1\\n        if numerator < 0:\\n            numerator = -numerator\\n            sign *= -1\\n        if denominator < 0:\\n            denominator = -denominator\\n            sign *= -1\\n        \\n        # Calculate integer part before the decimal\\n        intPart = int(numerator / denominator)\\n        numerator %= denominator\\n        numerator = numerator = numerator\\n        \\n        # Ensure that the numerator and denominator do not have 2 or 5\\n        # as a common factor\\n        while numerator % 2 == 0 and denominator % 2 == 0:\\n            numerator /= 2\\n            denominator /= 2\\n        while numerator % 5 == 5 and denominator % 5 == 0:\\n            numerator /= 5\\n            denominator /= 5\\n            \\n        # At this point the number of non recurring digits after the decimal\\n        # point will be:\\n        # Max(m,n)\\n        # where m is the highest number for which 2^m divides denominator\\n        # and n is the highest number for which 5^n divides denominator\\n        num = denominator\\n        num2Factors = 0\\n        while num % (2 ** (num2Factors + 1)) == 0:\\n            num2Factors += 1\\n        num5Factors = 0\\n        while num % (5 ** (num5Factors + 1)) == 0:\\n            num5Factors += 1\\n        nonRecc = max(num2Factors, num5Factors)\\n        \\n        # Calculate the non recurring decimal part of the result\\n        decPart = \\'\\'\\n        while nonRecc and numerator:\\n            numerator *= 10\\n            decPart += str(int(numerator / denominator))\\n            numerator %= denominator\\n            nonRecc -= 1\\n            \\n        # firstNum is the numerator which will be repeated in the recurring part\\n        # of the result.\\n        # Calculate the recurring decimal part of the result by dividing until\\n        # we get firstNum again.\\n        firstNum = numerator\\n        reccPart = \\'\\'\\n        while numerator:\\n            numerator *= 10\\n            reccPart += str(int(numerator / denominator))\\n            numerator %= denominator\\n            if numerator == firstNum:\\n                break\\n        \\n        # Construct the result from the individual parts\\n        res = \\'\\' if sign == 1 else \\'-\\'\\n        res += str(intPart)\\n        if decPart or reccPart:\\n            res += \\'.\\'\\n        res += decPart\\n        if reccPart:\\n            res += \\'(\\' + reccPart + \\')\\'\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 777285,
                "title": "accepted-c-stringstream-with-unordered-set-faster-than-100-00",
                "content": "```\\nclass Solution {\\npublic:\\n    // Updated the signature to int64_t to handle specific cases like abs(INT_MIN)\\n    string fractionToDecimal(int64_t numerator, int64_t denominator) {\\n        // special case\\n        if (numerator == 0) return \"0\";\\n        // we will use string stream to store the result\\n        stringstream res;        \\n        // if negative, we will add \"-\"\\n        if (numerator > 0 ^ denominator > 0) \\n            res << \"-\";\\n        \\n\\t\\t// working now with absolute values\\n        numerator = abs(numerator);\\n        denominator = abs(denominator);\\n        \\n        // add the int result.\\n        res << (numerator/denominator);\\n        \\n        // working with the remainder \\n        numerator = numerator % denominator;\\n        \\n        // if we have a fraction, we need to add a \".\"\\n        if (numerator > 0) \\n            res << \".\";\\n        \\n        unordered_set<int> dups;        \\n        bool re = false;\\n        stringstream reStream;\\n        while (numerator != 0) {\\n            if (dups.count(numerator) > 0) {\\n\\t\\t\\t\\t// we have a repeat, let\\'s identify the repeated fraction or break if have already found it.\\n                if (!re) {\\n\\t\\t\\t\\t\\t// let\\'s find out the repeated fraction\\n\\t\\t\\t\\t\\tre = true;\\n\\t\\t\\t\\t\\t// clear the map for the next repeated segment.\\n                    dups.clear();\\n                } else { \\n                    break; \\n                }\\n            }\\n\\t\\t\\t// keep track of numerator values to detect the next duplicated fraction if it exists\\n            dups.insert(numerator);\\n            \\n            numerator *= 10;\\n            if (!re) {\\n                // non repeated fraction stream\\n                res << (numerator / denominator);\\n            } else {\\n                // repeated fraction stream.\\n                reStream << (numerator / denominator);\\n            }\\n            // working with the remainder of numerator\\n            numerator = numerator % denominator;\\n        }\\n        \\n        // in case we have a repeated fraction\\n        string repeatedFraction = reStream.str();\\n        if (!repeatedFraction.empty()) {\\n            string ans = res.str();\\n            // find the start position of the repeat\\n            auto repeat = ans.find(repeatedFraction);\\n            // reset the stream\\n            res.str(std::string());\\n            res << ans.substr(0, repeat) << \"(\" << ans.substr(repeat) << \")\";\\n        }\\n        return res.str();\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Updated the signature to int64_t to handle specific cases like abs(INT_MIN)\\n    string fractionToDecimal(int64_t numerator, int64_t denominator) {\\n        // special case\\n        if (numerator == 0) return \"0\";\\n        // we will use string stream to store the result\\n        stringstream res;        \\n        // if negative, we will add \"-\"\\n        if (numerator > 0 ^ denominator > 0) \\n            res << \"-\";\\n        \\n\\t\\t// working now with absolute values\\n        numerator = abs(numerator);\\n        denominator = abs(denominator);\\n        \\n        // add the int result.\\n        res << (numerator/denominator);\\n        \\n        // working with the remainder \\n        numerator = numerator % denominator;\\n        \\n        // if we have a fraction, we need to add a \".\"\\n        if (numerator > 0) \\n            res << \".\";\\n        \\n        unordered_set<int> dups;        \\n        bool re = false;\\n        stringstream reStream;\\n        while (numerator != 0) {\\n            if (dups.count(numerator) > 0) {\\n\\t\\t\\t\\t// we have a repeat, let\\'s identify the repeated fraction or break if have already found it.\\n                if (!re) {\\n\\t\\t\\t\\t\\t// let\\'s find out the repeated fraction\\n\\t\\t\\t\\t\\tre = true;\\n\\t\\t\\t\\t\\t// clear the map for the next repeated segment.\\n                    dups.clear();\\n                } else { \\n                    break; \\n                }\\n            }\\n\\t\\t\\t// keep track of numerator values to detect the next duplicated fraction if it exists\\n            dups.insert(numerator);\\n            \\n            numerator *= 10;\\n            if (!re) {\\n                // non repeated fraction stream\\n                res << (numerator / denominator);\\n            } else {\\n                // repeated fraction stream.\\n                reStream << (numerator / denominator);\\n            }\\n            // working with the remainder of numerator\\n            numerator = numerator % denominator;\\n        }\\n        \\n        // in case we have a repeated fraction\\n        string repeatedFraction = reStream.str();\\n        if (!repeatedFraction.empty()) {\\n            string ans = res.str();\\n            // find the start position of the repeat\\n            auto repeat = ans.find(repeatedFraction);\\n            // reset the stream\\n            res.str(std::string());\\n            res << ans.substr(0, repeat) << \"(\" << ans.substr(repeat) << \")\";\\n        }\\n        return res.str();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703787,
                "title": "python3-32ms-intuitive",
                "content": "\\tclass Solution:\\n\\t\\tdef fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\t\\t\\tif denominator  == 0 : return \\'\\'\\n\\t\\t\\tif numerator == 0: return \\'0\\'\\n\\n\\t\\t\\t# sign part\\n\\t\\t\\tsign = \\'\\' if numerator*denominator >= 0 else \\'-\\'\\n\\n\\t\\t\\t# to non-negative vals\\n\\t\\t\\tnumerator = abs(numerator)\\n\\t\\t\\tdenominator = abs(denominator)\\n\\n\\t\\t\\t# int part\\n\\t\\t\\tint_part = str(numerator//denominator)\\n\\t\\t\\tif numerator%denominator == 0:\\n\\t\\t\\t\\treturn sign + int_part\\n\\n\\t\\t\\t# fractional part\\n\\t\\t\\tnumerator= numerator % denominator\\n\\t\\t\\tfrac = []\\n\\t\\t\\tcnt = 0\\n\\t\\t\\tvisited = dict()\\n\\t\\t\\twhile True:\\n\\t\\t\\t\\tif numerator in visited: break # save numerator\\n\\t\\t\\t\\tvisited[numerator] = cnt\\n\\t\\t\\t\\tnumerator *= 10\\n\\t\\t\\t\\tif numerator < denominator:\\n\\t\\t\\t\\t\\tfrac.append(\\'0\\')\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tfrac.append(str(numerator//denominator))\\n\\t\\t\\t\\t\\tnumerator= numerator % denominator\\n\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t# repeat part\\n\\t\\t\\ttail = \\'\\'.join(frac[visited[numerator]:cnt])\\n\\t\\t\\ttail = \\'(\\' + tail + \\')\\' if tail and tail != \\'0\\' else \\'\\'  \\n\\t\\t\\t# sign + int + dot + frac + repeat\\n\\t\\t\\treturn sign + int_part + \\'.\\' + \\'\\'.join(frac[:visited[numerator]]) + tail\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\t\\t\\tif denominator  == 0 : return \\'\\'\\n\\t\\t\\tif numerator == 0: return \\'0\\'\\n\\n\\t\\t\\t# sign part\\n\\t\\t\\tsign = \\'\\' if numerator*denominator >= 0 else \\'-\\'\\n\\n\\t\\t\\t# to non-negative vals\\n\\t\\t\\tnumerator = abs(numerator)\\n\\t\\t\\tdenominator = abs(denominator)\\n\\n\\t\\t\\t# int part\\n\\t\\t\\tint_part = str(numerator//denominator)\\n\\t\\t\\tif numerator%denominator == 0:\\n\\t\\t\\t\\treturn sign + int_part\\n\\n\\t\\t\\t# fractional part\\n\\t\\t\\tnumerator= numerator % denominator\\n\\t\\t\\tfrac = []\\n\\t\\t\\tcnt = 0\\n\\t\\t\\tvisited = dict()\\n\\t\\t\\twhile True:\\n\\t\\t\\t\\tif numerator in visited: break # save numerator\\n\\t\\t\\t\\tvisited[numerator] = cnt\\n\\t\\t\\t\\tnumerator *= 10\\n\\t\\t\\t\\tif numerator < denominator:\\n\\t\\t\\t\\t\\tfrac.append(\\'0\\')\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tfrac.append(str(numerator//denominator))\\n\\t\\t\\t\\t\\tnumerator= numerator % denominator\\n\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t# repeat part\\n\\t\\t\\ttail = \\'\\'.join(frac[visited[numerator]:cnt])\\n\\t\\t\\ttail = \\'(\\' + tail + \\')\\' if tail and tail != \\'0\\' else \\'\\'  \\n\\t\\t\\t# sign + int + dot + frac + repeat\\n\\t\\t\\treturn sign + int_part + \\'.\\' + \\'\\'.join(frac[:visited[numerator]]) + tail\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 691856,
                "title": "c-easy-to-understand-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        \\n        long long  n = numerator;\\n        long long  d = denominator;\\n        \\n        if(!n)return \"0\";\\n        \\n        string sign = ((n/abs(n)) != (d/abs(d)))?\"-\":\"\";\\n        \\n        n = abs(n);\\n        d = abs(d);\\n        \\n        \\n        string ans = to_string(n/d);\\n        \\n        if(!(n%d))return sign + ans;\\n\\n        ans+=\\'.\\';\\n        \\n        n = n%d;\\n        \\n        unordered_map<int,int>mp;\\n        mp[n]=ans.size();\\n     \\n        \\n        while(n){\\n            n*=10;\\n            while(n<d){\\n                n*=10;\\n                ans+=\\'0\\';\\n            }\\n            \\n            ans += to_string(n/d);\\n            n = n%d;\\n            if(mp[n]){\\n                string s1 = ans.substr(0,mp[n]);\\n                string s2 =\"(\" + ans.substr(mp[n]) + \")\";\\n                return sign + s1 + s2;\\n            }\\n            \\n            mp[n] = ans.size();\\n        }\\n        \\n        return sign + ans;\\n        \\n        \\n     \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        \\n        long long  n = numerator;\\n        long long  d = denominator;\\n        \\n        if(!n)return \"0\";\\n        \\n        string sign = ((n/abs(n)) != (d/abs(d)))?\"-\":\"\";\\n        \\n        n = abs(n);\\n        d = abs(d);\\n        \\n        \\n        string ans = to_string(n/d);\\n        \\n        if(!(n%d))return sign + ans;\\n\\n        ans+=\\'.\\';\\n        \\n        n = n%d;\\n        \\n        unordered_map<int,int>mp;\\n        mp[n]=ans.size();\\n     \\n        \\n        while(n){\\n            n*=10;\\n            while(n<d){\\n                n*=10;\\n                ans+=\\'0\\';\\n            }\\n            \\n            ans += to_string(n/d);\\n            n = n%d;\\n            if(mp[n]){\\n                string s1 = ans.substr(0,mp[n]);\\n                string s2 =\"(\" + ans.substr(mp[n]) + \")\";\\n                return sign + s1 + s2;\\n            }\\n            \\n            mp[n] = ans.size();\\n        }\\n        \\n        return sign + ans;\\n        \\n        \\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 626411,
                "title": "c-solution",
                "content": "```\\n    string fractionToDecimal(int numerator, int denominator) {\\n        \\n        bool minus =false;\\n        long den = denominator;\\n        long num= numerator;\\n        if(den<0)\\n        {\\n            den = abs((long long)den);\\n            minus= !minus;\\n        }\\n        if(num<0)\\n        {\\n            num= abs((long long)num);\\n            minus= !minus;\\n        }\\n        \\n        long int rem = num%den;\\n        long int r = num/den;\\n        string result = to_string(r);\\n        if(minus && (r>0 || rem>0))\\n        {\\n            result =\"-\"+result;\\n        }\\n        if(rem==0)\\n        {\\n            return result;\\n        }\\n        int start=0;\\n        \\n        map<long,int> rem_res;\\n        string repeat=\"\";\\n        while(rem!=0 && rem_res.find(rem)==rem_res.end())\\n        {\\n            rem_res[rem]=start++;\\n            rem=rem*10;\\n            long temp = rem/den;\\n            \\n            repeat+=to_string(temp);\\n            \\n            rem = rem%den;\\n        }\\n        \\n        if(rem!=0)\\n        {\\n            int pos=rem_res[rem];\\n            if(pos > 0)\\n            {\\n                result+= \".\"+repeat.substr(0,pos)+\"(\"+ repeat.substr(pos)+\")\";\\n            }\\n            else \\n            {\\n                result+= \".(\"+ repeat.substr(pos)+\")\";\\n            }\\n            \\n        }\\n        else\\n        {\\n            result += \".\"+repeat;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    string fractionToDecimal(int numerator, int denominator) {\\n        \\n        bool minus =false;\\n        long den = denominator;\\n        long num= numerator;\\n        if(den<0)\\n        {\\n            den = abs((long long)den);\\n            minus= !minus;\\n        }\\n        if(num<0)\\n        {\\n            num= abs((long long)num);\\n            minus= !minus;\\n        }\\n        \\n        long int rem = num%den;\\n        long int r = num/den;\\n        string result = to_string(r);\\n        if(minus && (r>0 || rem>0))\\n        {\\n            result =\"-\"+result;\\n        }\\n        if(rem==0)\\n        {\\n            return result;\\n        }\\n        int start=0;\\n        \\n        map<long,int> rem_res;\\n        string repeat=\"\";\\n        while(rem!=0 && rem_res.find(rem)==rem_res.end())\\n        {\\n            rem_res[rem]=start++;\\n            rem=rem*10;\\n            long temp = rem/den;\\n            \\n            repeat+=to_string(temp);\\n            \\n            rem = rem%den;\\n        }\\n        \\n        if(rem!=0)\\n        {\\n            int pos=rem_res[rem];\\n            if(pos > 0)\\n            {\\n                result+= \".\"+repeat.substr(0,pos)+\"(\"+ repeat.substr(pos)+\")\";\\n            }\\n            else \\n            {\\n                result+= \".(\"+ repeat.substr(pos)+\")\";\\n            }\\n            \\n        }\\n        else\\n        {\\n            result += \".\"+repeat;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 617207,
                "title": "java-using-hash-map",
                "content": "Using long to avoid corner case;\\nconvert to long before get abs value to avoid overflow.\\n\\nusing map to remember last remainder, for period.\\n\\n```\\n    public String fractionToDecimal(int nm, int dm) {\\n        if (dm == 0 || nm == 0) return \"0\";\\n        StringBuilder sb = new StringBuilder();\\n        sb.append((dm > 0) ^ (nm > 0) ? \"-\" : \"\");\\n        long d = Math.abs((long)dm), n = Math.abs((long)nm);  // must use (long)dm for -1, -2147483648\\n        sb.append(n / d);\\n        long rem = n % d;\\n        if (rem == 0) return sb.toString();\\n        sb.append(\".\");\\n        Map<Long, Integer> map = new HashMap<>();\\n        while(rem != 0) {\\n            if (map.containsKey(rem)){\\n                sb.insert(map.get(rem), \"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n            map.put(rem, sb.length());\\n            rem *= 10;\\n            sb.append(rem / d);\\n            rem = rem % d;\\n        }\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String fractionToDecimal(int nm, int dm) {\\n        if (dm == 0 || nm == 0) return \"0\";\\n        StringBuilder sb = new StringBuilder();\\n        sb.append((dm > 0) ^ (nm > 0) ? \"-\" : \"\");\\n        long d = Math.abs((long)dm), n = Math.abs((long)nm);  // must use (long)dm for -1, -2147483648\\n        sb.append(n / d);\\n        long rem = n % d;\\n        if (rem == 0) return sb.toString();\\n        sb.append(\".\");\\n        Map<Long, Integer> map = new HashMap<>();\\n        while(rem != 0) {\\n            if (map.containsKey(rem)){\\n                sb.insert(map.get(rem), \"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n            map.put(rem, sb.length());\\n            rem *= 10;\\n            sb.append(rem / d);\\n            rem = rem % d;\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 611572,
                "title": "concise-java-solution-intuition-explained-important-to-understand-the-edge-cases",
                "content": "Intution is that if repeation occurs in the remainder than something needs to done and something can be done only with help of memory as how will we know if same case has occurred. Intutition is same as that of happy number with a lot of edge cases. It is fun learning this problem #happycoding\\n```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        /* we need to take care of \\n        a) sign\\n        b) overflow case of -ve case of Integer.MAX_VALUE;\\n        c) memory overflow\\n        */\\n        if(numerator==0)\\n            return new String(\"0\");\\n        StringBuilder result = new StringBuilder();\\n        /* handle the sign */\\n        if(numerator <0 ^ denominator <0)\\n            result.append(\"-\");\\n        \\n        /* converting to long other wise -ve case of Integer.MAX_VALUE will\\n        overflow */\\n        long num = Math.abs(Long.valueOf(numerator));\\n        long denom = Math.abs(Long.valueOf(denominator));\\n        result.append(num/denom);\\n        long remainder = num % denom;\\n        if(remainder == 0)\\n            return result.toString();\\n        result.append(\".\");\\n        Map<Long,Integer> store = new HashMap<>(); \\n        while(remainder!=0){\\n            \\n            /* if the same remainder comes then we know that everything will\\n            repeat */\\n            if(store.containsKey(remainder)){\\n                result.insert(store.get(remainder),\"(\");\\n                result.append(\")\");\\n                break;\\n            }\\n            \\n            store.put(remainder,result.length());\\n            remainder*=10;\\n            result.append(String.valueOf(remainder/denom));\\n            remainder = remainder % denominator;\\n        }\\n        return result.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        /* we need to take care of \\n        a) sign\\n        b) overflow case of -ve case of Integer.MAX_VALUE;\\n        c) memory overflow\\n        */\\n        if(numerator==0)\\n            return new String(\"0\");\\n        StringBuilder result = new StringBuilder();\\n        /* handle the sign */\\n        if(numerator <0 ^ denominator <0)\\n            result.append(\"-\");\\n        \\n        /* converting to long other wise -ve case of Integer.MAX_VALUE will\\n        overflow */\\n        long num = Math.abs(Long.valueOf(numerator));\\n        long denom = Math.abs(Long.valueOf(denominator));\\n        result.append(num/denom);\\n        long remainder = num % denom;\\n        if(remainder == 0)\\n            return result.toString();\\n        result.append(\".\");\\n        Map<Long,Integer> store = new HashMap<>(); \\n        while(remainder!=0){\\n            \\n            /* if the same remainder comes then we know that everything will\\n            repeat */\\n            if(store.containsKey(remainder)){\\n                result.insert(store.get(remainder),\"(\");\\n                result.append(\")\");\\n                break;\\n            }\\n            \\n            store.put(remainder,result.length());\\n            remainder*=10;\\n            result.append(String.valueOf(remainder/denom));\\n            remainder = remainder % denominator;\\n        }\\n        return result.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515772,
                "title": "accepted-c-solution-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public string FractionToDecimal(int numerator, int denominator)\\n    {\\n        if (denominator == 0)\\n        {\\n            //throw new IllegalArgumentException(\" denominator can not be zero\");\\n            throw new ArgumentException(\" denominator can not be zero\");\\n        }\\n\\n        // avoid overflow for minimum value of integer\\n        long newNum = (long)numerator;\\n        long newDeNom = (long)denominator;\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        // detect sign\\n        if ((newNum > 0 && newDeNom < 0) || (newNum < 0 && newDeNom > 0))\\n            sb.Append(\"-\");\\n        \\n        // make sure it is postive value\\n        newNum = Math.Abs(newNum);\\n        newDeNom = Math.Abs(newDeNom);      \\n\\n        sb.Append(newNum / newDeNom);\\n\\n        long remainder = newNum % newDeNom;\\n        Dictionary<long, int> remainderMap = new Dictionary<long, int>();\\n\\n        if (remainder != 0)\\n            sb.Append(\".\");\\n\\n        while (remainder != 0 && !remainderMap.ContainsKey(remainder))\\n        {\\n            remainderMap.Add(remainder, sb.Length);\\n            remainder *= 10;\\n            sb.Append(remainder / newDeNom);\\n            remainder = remainder % newDeNom; \\n        }\\n\\n        if (remainderMap.ContainsKey(remainder))\\n        {\\n            sb.Insert(remainderMap[remainder], \"(\");\\n            sb.Append(\")\");\\n        }\\n        return sb.ToString();\\n    }    \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string FractionToDecimal(int numerator, int denominator)\\n    {\\n        if (denominator == 0)\\n        {\\n            //throw new IllegalArgumentException(\" denominator can not be zero\");\\n            throw new ArgumentException(\" denominator can not be zero\");\\n        }\\n\\n        // avoid overflow for minimum value of integer\\n        long newNum = (long)numerator;\\n        long newDeNom = (long)denominator;\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        // detect sign\\n        if ((newNum > 0 && newDeNom < 0) || (newNum < 0 && newDeNom > 0))\\n            sb.Append(\"-\");\\n        \\n        // make sure it is postive value\\n        newNum = Math.Abs(newNum);\\n        newDeNom = Math.Abs(newDeNom);      \\n\\n        sb.Append(newNum / newDeNom);\\n\\n        long remainder = newNum % newDeNom;\\n        Dictionary<long, int> remainderMap = new Dictionary<long, int>();\\n\\n        if (remainder != 0)\\n            sb.Append(\".\");\\n\\n        while (remainder != 0 && !remainderMap.ContainsKey(remainder))\\n        {\\n            remainderMap.Add(remainder, sb.Length);\\n            remainder *= 10;\\n            sb.Append(remainder / newDeNom);\\n            remainder = remainder % newDeNom; \\n        }\\n\\n        if (remainderMap.ContainsKey(remainder))\\n        {\\n            sb.Insert(remainderMap[remainder], \"(\");\\n            sb.Append(\")\");\\n        }\\n        return sb.ToString();\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425909,
                "title": "python3-two-100-clear-workflow",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        res = \\'\\'\\n        # sign\\n        if numerator*denominator<0:\\n            res+=\\'-\\'\\n        numerator = abs(numerator)\\n        denominator = abs(denominator)\\n        \\n        # before point\\n        res+= str(numerator//denominator)\\n        carrier = numerator%denominator\\n        \\n        # after point\\n        if carrier>0:\\n            res+=\\'.\\'\\n        memo = {}\\n        while carrier>0:\\n            if carrier in memo:\\n                index = memo[carrier]\\n                res = res[:index]+\\'(\\'+res[index:] +\\')\\'\\n                return res\\n            else:\\n                memo[carrier]=len(res)\\n                res+=str((carrier*10)//denominator)\\n                carrier = ((carrier*10)%denominator)\\n                \\n        return res\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        res = \\'\\'\\n        # sign\\n        if numerator*denominator<0:\\n            res+=\\'-\\'\\n        numerator = abs(numerator)\\n        denominator = abs(denominator)\\n        \\n        # before point\\n        res+= str(numerator//denominator)\\n        carrier = numerator%denominator\\n        \\n        # after point\\n        if carrier>0:\\n            res+=\\'.\\'\\n        memo = {}\\n        while carrier>0:\\n            if carrier in memo:\\n                index = memo[carrier]\\n                res = res[:index]+\\'(\\'+res[index:] +\\')\\'\\n                return res\\n            else:\\n                memo[carrier]=len(res)\\n                res+=str((carrier*10)//denominator)\\n                carrier = ((carrier*10)%denominator)\\n                \\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 405994,
                "title": "python-easy-understanding",
                "content": "```python\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # if this can be divided completely\\n        if numerator % denominator == 0: return str(numerator // denominator)\\n        \\n        # extract the symbol of negative or positive number of the result\\n        sign = \\'-\\' if numerator * denominator < 0 else \\'\\'\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        ans = \\'\\'\\n        rem_pos = {} # store recurring number\\n        i = numerator // denominator # integer part\\n        rem = numerator % denominator\\n        \\n        while rem != 0 and rem not in rem_pos:\\n            rem_pos[rem] = len(rem_pos) # {remainder : position}\\n            numerator = rem * 10\\n            \\n            dec_part = numerator // denominator\\n            ans += str(dec_part)\\n            \\n            rem = numerator % denominator\\n        \\n        if rem == 0: return sign + str(i) + \\'.\\' + ans # no recurring\\n        return sign + str(i) + \\'.\\' + ans[:rem_pos[rem]] + \\'(\\' + ans[rem_pos[rem]:] + \\')\\' # recurring\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # if this can be divided completely\\n        if numerator % denominator == 0: return str(numerator // denominator)\\n        \\n        # extract the symbol of negative or positive number of the result\\n        sign = \\'-\\' if numerator * denominator < 0 else \\'\\'\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        ans = \\'\\'\\n        rem_pos = {} # store recurring number\\n        i = numerator // denominator # integer part\\n        rem = numerator % denominator\\n        \\n        while rem != 0 and rem not in rem_pos:\\n            rem_pos[rem] = len(rem_pos) # {remainder : position}\\n            numerator = rem * 10\\n            \\n            dec_part = numerator // denominator\\n            ans += str(dec_part)\\n            \\n            rem = numerator % denominator\\n        \\n        if rem == 0: return sign + str(i) + \\'.\\' + ans # no recurring\\n        return sign + str(i) + \\'.\\' + ans[:rem_pos[rem]] + \\'(\\' + ans[rem_pos[rem]:] + \\')\\' # recurring\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330668,
                "title": "c-100-beat-o-1-run-time-koderz-kamp-l33t-solution-kool",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        \\n        bool aNegative = (numerator < 0) != (denominator < 0);\\n        long long aNum = numerator, aDen = denominator;\\n        \\n        aNum = abs(aNum);\\n        aDen = abs(aDen);\\n        \\n        long long aDigit = aNum / aDen;\\n        string aResult = to_string(aDigit);\\n        \\n        long long aRemainder = (aNum % aDen) * 10;\\n        \\n        if (aNegative && (aDigit != 0 || aRemainder != 0)) {\\n            aResult = string(\"-\") + aResult;\\n        }\\n        \\n        if (aRemainder != 0) { \\n            \\n            aResult.append(\".\");\\n            unordered_map<int, int> aRepeatMap(64);\\n            \\n            while (aRemainder != 0) {\\n                if (aRepeatMap[aRemainder] != 0) {\\n                    aResult.insert(aRepeatMap[aRemainder], \"(\");\\n                    aResult.append(\")\");\\n                    break;\\n                } else {\\n                    aRepeatMap[aRemainder] = aResult.size();\\n                    aResult.append(to_string(aRemainder / aDen));\\n                    aRemainder = (aRemainder % aDen) * 10;\\n                }   \\n            }\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```\\n\\nFor some reason, I kept thinking the numerator had to be in the loop? I was doing it by hand, translating into code makes me rip out hairs. Ahh!!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        \\n        bool aNegative = (numerator < 0) != (denominator < 0);\\n        long long aNum = numerator, aDen = denominator;\\n        \\n        aNum = abs(aNum);\\n        aDen = abs(aDen);\\n        \\n        long long aDigit = aNum / aDen;\\n        string aResult = to_string(aDigit);\\n        \\n        long long aRemainder = (aNum % aDen) * 10;\\n        \\n        if (aNegative && (aDigit != 0 || aRemainder != 0)) {\\n            aResult = string(\"-\") + aResult;\\n        }\\n        \\n        if (aRemainder != 0) { \\n            \\n            aResult.append(\".\");\\n            unordered_map<int, int> aRepeatMap(64);\\n            \\n            while (aRemainder != 0) {\\n                if (aRepeatMap[aRemainder] != 0) {\\n                    aResult.insert(aRepeatMap[aRemainder], \"(\");\\n                    aResult.append(\")\");\\n                    break;\\n                } else {\\n                    aRepeatMap[aRemainder] = aResult.size();\\n                    aResult.append(to_string(aRemainder / aDen));\\n                    aRemainder = (aRemainder % aDen) * 10;\\n                }   \\n            }\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 314537,
                "title": "use-python-to-resolve-o-n",
                "content": "class Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        \"\"\"\\n        :type numerator: int\\n        :type denominator: int\\n        :rtype: str\\n        \"\"\"\\n\\n\\n        tag = -1 if numerator * denominator < 0 else 1 #\\u5224\\u65AD\\u662F\\u5426\\u6709\\u6B63\\u8D1F\\u53F7\\uFF0C\\u4EE3\\u7801\\u4E2D\\u7528\\u6B63\\u6570\\u8FDB\\u884C\\u76F8\\u9664\\uFF0C\\u82E5\\u6709\\u8D1F\\u53F7\\u6700\\u540E\\u52A0\\u4E0A\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        re_num = \\'\\'\\n        dictionary = {}\\n        while 1:\\n            if not re_num:#\\u9996\\u6B21\\u8FDB\\u884C\\u8BA1\\u7B97\\n                value = numerator // denominator\\n                numerator = numerator % denominator\\n                # print(value,numerator)\\n                if numerator == 0:#\\u65E0\\u5FAA\\u73AF\\n                    re_num += str(value)\\n                    return re_num if tag == 1 else \\'-\\' + re_num\\n                else:\\n                    re_num = str(value) + \\'.\\'\\n            else: #\\u540E\\u7EED\\u8BA1\\u7B97\\uFF0C\\u5373\\u5BFB\\u627E\\u5FAA\\u73AF\\u9879\\uFF0C\\u82E5\\u6CA1\\u6709\\uFF0C\\u76F4\\u63A5return\\n                numerator *= 10\\n                value = numerator // denominator\\n                numerator = numerator % denominator\\n\\n                if numerator == 0:#\\u65E0\\u5FAA\\u73AF\\n                    re_num += str(value)\\n                    return re_num if tag == 1 else \\'-\\' + re_num\\n                else:#\\u6709\\u5FAA\\u73AF\\u65F6\\u8FD4\\u56DE\\n                    if str(value) + \\' \\' + str(numerator) in dictionary:\\n                        re_num = re_num[:dictionary[str(value) + \\' \\' + str(numerator)]] + \\'(\\' + re_num[dictionary[str(\\n                            value) + \\' \\' + str(numerator)]:] + \\')\\'\\n                        return re_num if tag == 1 else \\'-\\' + re_num\\n                    else:\\n                        dictionary[str(value) + \\' \\' + str(numerator)] = len(re_num)\\n                        re_num += str(value)",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        \"\"\"\\n        :type numerator: int\\n        :type denominator: int\\n        :rtype: str\\n        \"\"\"\\n\\n\\n        tag = -1 if numerator * denominator < 0 else 1 #\\u5224\\u65AD\\u662F\\u5426\\u6709\\u6B63\\u8D1F\\u53F7\\uFF0C\\u4EE3\\u7801\\u4E2D\\u7528\\u6B63\\u6570\\u8FDB\\u884C\\u76F8\\u9664\\uFF0C\\u82E5\\u6709\\u8D1F\\u53F7\\u6700\\u540E\\u52A0\\u4E0A\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        re_num = \\'\\'\\n        dictionary = {}",
                "codeTag": "Java"
            },
            {
                "id": 239616,
                "title": "java-solution",
                "content": "**Solution 1:**\\n\\n- After the decimal point, we need to record all the remainders and the corresponding position to insert `(`. \\n - When we get a new remainder which is not present in `HashMap`, then add it to the `HashMap` along with its position. This position will be helpful later in order to insert `(` in case when the remainder gets repeated.\\n - When the remainder is already in the `HashMap`, then it means the fractional part is repeating, so insert `(` to the corresponding position, then append `)` and break the loop.\\n\\nTime complexity : `O(k)` - where `k` is the number of times we get the distinct non-zero `remainder` during the fractional part division.\\nSpace complexity : `O(k)` - space required for `HashMap` to store distinct non-zero `remainders`.\\n\\n```\\nclass Solution\\n{\\n    public String fractionToDecimal(int numerator, int denominator)\\n\\t{\\n        Map<Long, Integer> map = new HashMap<>();\\n\\t\\tStringBuilder sb = new StringBuilder();\\n        long n = Math.abs((long)numerator);\\n        long d = Math.abs((long)denominator);\\n\\t\\tlong r = n % d;\\n\\t\\t\\n        if(numerator != 0 && numerator > 0 ^ denominator > 0) \\n            sb.append(\"-\");\\n\\t\\t\\n        sb.append(n / d);                       // Integral part\\n\\n        if(r > 0)\\n\\t\\t\\tsb.append(\".\");\\t\\t\\t\\t\\t\\t// Fractional part\\n\\t\\t\\n        while(r > 0)\\n\\t\\t{\\n            if(map.containsKey(r))\\n\\t\\t\\t{\\n                int index = map.get(r);\\n                sb.insert(index, \"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n            else\\n\\t\\t\\t{\\n                map.put(r, sb.length());\\n                r = r * 10;\\n                sb.append(r / d);\\n                r = r % d;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public String fractionToDecimal(int numerator, int denominator)\\n\\t{\\n        Map<Long, Integer> map = new HashMap<>();\\n\\t\\tStringBuilder sb = new StringBuilder();\\n        long n = Math.abs((long)numerator);\\n        long d = Math.abs((long)denominator);\\n\\t\\tlong r = n % d;\\n\\t\\t\\n        if(numerator != 0 && numerator > 0 ^ denominator > 0) \\n            sb.append(\"-\");\\n\\t\\t\\n        sb.append(n / d);                       // Integral part\\n\\n        if(r > 0)\\n\\t\\t\\tsb.append(\".\");\\t\\t\\t\\t\\t\\t// Fractional part\\n\\t\\t\\n        while(r > 0)\\n\\t\\t{\\n            if(map.containsKey(r))\\n\\t\\t\\t{\\n                int index = map.get(r);\\n                sb.insert(index, \"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n            else\\n\\t\\t\\t{\\n                map.put(r, sb.length());\\n                r = r * 10;\\n                sb.append(r / d);\\n                r = r % d;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 183567,
                "title": "concise-python-solution",
                "content": "```\\ndef fractionToDecimal(self, a, b):\\n        sg = \\'-\\'*int(a*b < 0)\\n        a, b = abs(a), abs(b)\\n        d, a = str(a//b), a % b        \\n        \\n        vis, s = [], []\\n        a *= 10\\n        while a not in vis and a != 0:                        \\n            vis.append(a)            \\n            s.append(str(a//b))\\n            a = 10*(a % b)\\n                      \\n        i = 0 if a == 0 else vis.index(a)        \\n        return \\'\\'.join([sg, d, \\'.\\'* (len(s)>0)] + s[:i] + [\\'(\\'*(a>0)] + s[i:] + [\\')\\'*(a>0)]) ",
                "solutionTags": [],
                "code": "```\\ndef fractionToDecimal(self, a, b):\\n        sg = \\'-\\'*int(a*b < 0)\\n        a, b = abs(a), abs(b)\\n        d, a = str(a//b), a % b        \\n        \\n        vis, s = [], []\\n        a *= 10\\n        while a not in vis and a != 0:                        \\n            vis.append(a)            \\n            s.append(str(a//b))\\n            a = 10*(a % b)\\n                      \\n        i = 0 if a == 0 else vis.index(a)        \\n        return \\'\\'.join([sg, d, \\'.\\'* (len(s)>0)] + s[:i] + [\\'(\\'*(a>0)] + s[i:] + [\\')\\'*(a>0)]) ",
                "codeTag": "Python3"
            },
            {
                "id": 170235,
                "title": "c-neat",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if (!numerator) \\n            return \"0\"; // For example 0/m\\n        \\n        string ans;\\n        if (numerator < 0 ^ denominator < 0) \\n            ans += \\'-\\'; // -n/m, or n/-m\\n        \\n        long n, d, r; // numerator, denominator, and remainder\\n        n = labs((long)numerator);\\n        d = labs((long)denominator);\\n        \\n        ans += to_string(n/d);\\n        r = n % d;\\n        if (!r)\\n            return ans;    // n/m where n is multiple of m\\n        \\n        // Here we know that, we should calculate the fraction part.\\n        unordered_map<long, int> m; // map for remainder to quotient index\\n        long                     q; // quotient;\\n        ans += \\'.\\';\\n        r *= 10;\\n        while(r) {\\n            q = r / d;\\n            if (m.count(r)) {\\n                // Here we know that remainder is repeating, \\n                // hence fraction part will repeat, but what is the starting position\\n                // of repeating fraction part? its the index of the quotient when\\n                // we last saw this remainder. That is m[r]!\\n                ans.insert(m[r], 1, \\'(\\');\\n                ans += \\')\\';\\n                return ans;\\n            }\\n            m[r] = ans.size();\\n            ans += to_string(q);\\n            r = (r % d) * 10;       \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if (!numerator) \\n            return \"0\"; // For example 0/m\\n        \\n        string ans;\\n        if (numerator < 0 ^ denominator < 0) \\n            ans += \\'-\\'; // -n/m, or n/-m\\n        \\n        long n, d, r; // numerator, denominator, and remainder\\n        n = labs((long)numerator);\\n        d = labs((long)denominator);\\n        \\n        ans += to_string(n/d);\\n        r = n % d;\\n        if (!r)\\n            return ans;    // n/m where n is multiple of m\\n        \\n        // Here we know that, we should calculate the fraction part.\\n        unordered_map<long, int> m; // map for remainder to quotient index\\n        long                     q; // quotient;\\n        ans += \\'.\\';\\n        r *= 10;\\n        while(r) {\\n            q = r / d;\\n            if (m.count(r)) {\\n                // Here we know that remainder is repeating, \\n                // hence fraction part will repeat, but what is the starting position\\n                // of repeating fraction part? its the index of the quotient when\\n                // we last saw this remainder. That is m[r]!\\n                ans.insert(m[r], 1, \\'(\\');\\n                ans += \\')\\';\\n                return ans;\\n            }\\n            m[r] = ans.size();\\n            ans += to_string(q);\\n            r = (r % d) * 10;       \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51119,
                "title": "golang-solution-using-math",
                "content": "Basic analysis can be borrowed from here:\\nhttp://yucoding.blogspot.com/2015/03/leetcode-question-fraction-to-recurring.html\\nBut the code can be simplified a bit.\\n\\n```\\nfunc fractionToDecimal(numerator int, denominator int) string {\\n\\tflag := \"\"\\n\\tswitch {\\n\\tcase numerator < 0 && denominator < 0:\\n\\t\\tnumerator, denominator = -numerator, -denominator\\n\\tcase numerator > 0 && denominator < 0:\\n\\t\\tdenominator, flag = -denominator, \"-\"\\n\\tcase numerator < 0 && denominator > 0:\\n\\t\\tnumerator, flag = -numerator, \"-\"\\n\\t}\\n\\n\\tqua, rem := numerator/denominator, numerator%denominator\\n\\tres := []byte(strconv.FormatInt(int64(qua), 10))\\n\\tif rem == 0 {\\n\\t\\treturn flag + string(res)\\n\\t}\\n\\n\\tres = append(res, '.')\\n\\tm, curIndex := make(map[int]int), len(res)-1\\n\\tfor rem != 0 {\\n\\t\\tnumerator = rem * 10\\n\\t\\tqua, rem = numerator/denominator, numerator%denominator\\n\\n\\t\\tif index, ok := m[numerator]; ok {\\n\\t\\t\\tres = append(res, ')', ' ')\\n\\t\\t\\tcopy(res[index+1:], res[index:])\\n\\t\\t\\tres[index] = '('\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tres = append(res, digitToByte(qua))\\n\\t\\tcurIndex++\\n\\t\\tm[numerator] = curIndex\\n\\t}\\n\\treturn flag + string(res)\\n}\\n\\nfunc digitToByte(digit int) byte {\\n\\treturn byte('0' + digit)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc fractionToDecimal(numerator int, denominator int) string {\\n\\tflag := \"\"\\n\\tswitch {\\n\\tcase numerator < 0 && denominator < 0:\\n\\t\\tnumerator, denominator = -numerator, -denominator\\n\\tcase numerator > 0 && denominator < 0:\\n\\t\\tdenominator, flag = -denominator, \"-\"\\n\\tcase numerator < 0 && denominator > 0:\\n\\t\\tnumerator, flag = -numerator, \"-\"\\n\\t}\\n\\n\\tqua, rem := numerator/denominator, numerator%denominator\\n\\tres := []byte(strconv.FormatInt(int64(qua), 10))\\n\\tif rem == 0 {\\n\\t\\treturn flag + string(res)\\n\\t}\\n\\n\\tres = append(res, '.')\\n\\tm, curIndex := make(map[int]int), len(res)-1\\n\\tfor rem != 0 {\\n\\t\\tnumerator = rem * 10\\n\\t\\tqua, rem = numerator/denominator, numerator%denominator\\n\\n\\t\\tif index, ok := m[numerator]; ok {\\n\\t\\t\\tres = append(res, ')', ' ')\\n\\t\\t\\tcopy(res[index+1:], res[index:])\\n\\t\\t\\tres[index] = '('\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tres = append(res, digitToByte(qua))\\n\\t\\tcurIndex++\\n\\t\\tm[numerator] = curIndex\\n\\t}\\n\\treturn flag + string(res)\\n}\\n\\nfunc digitToByte(digit int) byte {\\n\\treturn byte('0' + digit)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51154,
                "title": "easy-understanding",
                "content": "public class Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        \\n        if (numerator == 0) return \"0\";\\n        if (denominator == 0) return \"\";\\n\\n        \\n        StringBuffer sb = new StringBuffer();\\n        boolean flag = (numerator < 0) ^ (denominator < 0);\\n        \\n        long num = Math.abs(numerator);\\n        long den = Math.abs(denominator);\\n        num = Math.abs(num);\\n        den = Math.abs(den);\\n\\n        long n = num / den;\\n        long remainder = (num % den) * 10;\\n        \\n        sb.append(flag ? \"-\" : \"\");\\n        sb.append(n);\\n        sb.append(remainder!=0?\".\":\"\");\\n\\n        HashMap<Long, Integer> hashMap = new HashMap<>();\\n        \\n        while (remainder != 0) {\\n\\n            if (hashMap.containsKey(remainder)) {\\n                int len = hashMap.get(remainder);\\n                sb.insert(len,'(');\\n                sb.append(')');\\n                break;\\n            } \\n\\n            hashMap.put(remainder, sb.length());\\n            n = remainder / den;\\n            sb.append(n);\\n            remainder = (remainder % den) * 10;\\n        }\\n\\n\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        \\n        if (numerator == 0) return \"0\";\\n        if (denominator == 0) return \"\";\\n\\n        \\n        StringBuffer sb = new StringBuffer();\\n        boolean flag = (numerator < 0) ^ (denominator < 0);\\n        \\n        long num = Math.abs(numerator);\\n        long den = Math.abs(denominator);\\n        num = Math.abs(num);\\n        den = Math.abs(den);\\n\\n        long n = num / den;\\n        long remainder = (num % den) * 10;\\n        \\n        sb.append(flag ? \"-\" : \"\");\\n        sb.append(n);\\n        sb.append(remainder!=0?\".\":\"\");\\n\\n        HashMap<Long, Integer> hashMap = new HashMap<>();\\n        \\n        while (remainder != 0) {\\n\\n            if (hashMap.containsKey(remainder)) {\\n                int len = hashMap.get(remainder);\\n                sb.insert(len,'(');\\n                sb.append(')');\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 51188,
                "title": "python-solution-with-map",
                "content": "    class Solution:\\n    # @param {integer} numerator\\n    # @param {integer} denominator\\n    # @return {string}\\n    def fractionToDecimal(self, numerator, denominator):\\n        neg = False\\n        if numerator<0 and denominator>0 or numerator>0 and denominator<0:\\n            neg = True\\n            \\n        numerator = abs(numerator)\\n        denominator = abs(denominator)\\n        ans = str(numerator/denominator)\\n        if neg:\\n            ans = '-' + ans\\n            \\n        if numerator%denominator == 0:\\n            return ans\\n            \\n        dic = {}\\n        ans += '.'\\n        count = len(ans)\\n        \\n        \\n        tmp = numerator%denominator\\n        while True:\\n            if tmp not in dic:\\n                dic[tmp] = len(ans)\\n            else:\\n                ans = ans[:dic[tmp]] + '(' + ans[dic[tmp]:] + ')'\\n                break\\n            \\n            tmp *= 10\\n            if tmp < denominator:\\n                ans += '0'\\n                continue\\n            if tmp%denominator == 0:\\n                ans += str(tmp/denominator)\\n                break\\n            else:\\n                tmpans = tmp/denominator\\n                tmp = tmp%denominator\\n                ans += str(tmpans)\\n            \\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 51210,
                "title": "2ms-c-solution-share-a-poor-coding-style",
                "content": "    class Solution {\\n    public:\\n    \\tstring fractionToDecimal(int numerator, int denominator) {\\n    \\t\\tostringstream os;\\n                //dealing with denominator == 0\\n    \\t\\tif (denominator == 0){\\n    \\t\\t\\tos << INT_MAX;\\n    \\t\\t\\treturn os.str();\\n    \\t\\t}\\n                //dealing with numerator == 0\\n    \\t\\tif(numerator==0)\\n    \\t\\t    return \"0\";\\n                //others\\n    \\t\\tif ((numerator<0) ^ (denominator < 0))\\n    \\t\\t\\tos << '-';\\n    \\t\\tlong long x = abs((long long)numerator), y = abs((long long)denominator);\\n    \\t\\tos << x / y;\\n    \\t\\tif ((x %= y) == 0)\\n    \\t\\t\\treturn os.str();\\n    \\t\\tos << '.';\\n\\n    \\t    long long ax = x, ay = y;\\n    \\t\\tint i = 0, j = 0;\\n               //find the count of non_repeating part,it depends on how many 2 or 5 factor \\n               // are there in denominator\\n    \\t\\twhile (y % 2 == 0){\\n    \\t\\t\\ty /= 2;\\n    \\t\\t\\t++i;\\n    \\t\\t}\\n    \\t\\twhile (y % 5 == 0){\\n    \\t\\t\\ty /= 5;\\n    \\t\\t\\t++j;\\n    \\t\\t}\\n    \\t\\tint k = max(i, j);\\n                //non_repeating part\\n    \\t\\twhile (k != 0 && ax != 0){\\n    \\t\\t\\tax = ax * 10;\\n    \\t\\t\\tos << ax / ay;\\n    \\t\\t\\tax %= ay;\\n    \\t\\t\\t--k;\\n    \\t\\t}\\n    \\t\\tif (ax == 0)\\n    \\t\\t\\treturn os.str();\\n    \\t\\tlong long m = ax;\\n    \\t\\tos << '(';\\n                //repeating part\\n                //to find the repeating part ,we need to find when the denominator(here it is ax) repeats,\\n                //then we stop;\\n    \\t\\twhile (true){\\n    \\t\\t\\tax = ax * 10;\\n    \\t\\t\\tos << ax / ay;\\n    \\t\\t\\tif ((ax %= ay) == m)\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t}\\n    \\t\\tos << ')';\\n    \\t\\treturn os.str();\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    \\tstring fractionToDecimal(int numerator, int denominator) {\\n    \\t\\tostringstream os;\\n                //dealing with denominator == 0\\n    \\t\\tif (denominator == 0){\\n    \\t\\t\\tos << INT_MAX;\\n    \\t\\t\\treturn os.str();\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 51214,
                "title": "4ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        string fractionToDecimal(int num, int den) {\\n            if (den == 0 || num == 0) {\\n                return \"0\";\\n            }\\n            string res = ((num < 0) ^ (den < 0)) == 1 ? \"-\" : \"\";\\n            // store as long since INT_MAX might come\\n            // also no overflow needed since string for INT_MIN/-1\\n            long a = abs((long)num);\\n            long b = abs((long)den);\\n            ostringstream os;\\n            os << a/b;\\n            res += os.str();\\n            if (a%b == 0) {\\n                return res;\\n            }\\n            \\n            res += \".\";\\n            unordered_map<int, int> pos_map;\\n            long x = a%b;\\n            string frac = \"\";\\n            while(x) {\\n                long d = (x*10)/b;\\n                ostringstream os;\\n                os << d;\\n                frac += os.str();\\n                pos_map[x] = frac.size()-1;\\n                x = (x*10)%b;\\n                if (pos_map.find(x) != pos_map.end()) {\\n                    int i = pos_map[x];\\n                    res += string(frac, 0, i) + \"(\" + string(frac, i, frac.size()-i) + \")\";\\n                    return res;\\n                }\\n            }\\n            \\n            return (res +  frac);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string fractionToDecimal(int num, int den) {\\n            if (den == 0 || num == 0) {\\n                return \"0\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3604036,
                "title": "most-efficient-js-solution-with-easy-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. The function takes two parameters: numerator and denominator, representing the fraction to be converted.\\n\\n2. The code first checks if the numerator is zero. If it is, it returns \"0\" as the decimal representation of the fraction.\\n\\n3. A variable named result is initialized as an empty string. This variable will store the decimal representation of the fraction.\\n\\n4. The code handles the sign of the resulting decimal by checking if the signs of the numerator and denominator are the same. If they are not, a \"-\" sign is added to the result.\\n\\n5. The numerator and denominator are converted to their absolute values using the Math.abs() function. This ensures that the calculations are performed correctly regardless of the sign.\\n\\n6. The integer part of the fraction is determined by dividing the absolute numerator by the absolute denominator and using Math.floor() to round down the division result. The integer part is added to the result.\\n\\n7. The code calculates the remainder of the division using the modulus operator (%). If the remainder is zero, it means there is no fractional part, so the result is returned.\\n\\n8. If there is a fractional part, a decimal point is added to the result.\\n\\n9. The code uses a Map called map to track the remainders and their positions. This is done to detect repeating patterns in the decimal representation of the fraction.\\n\\n10. The code enters a loop that continues until the remainder becomes zero. In each iteration, it checks if the remainder is already in the map. If it is, it means a repeating pattern is detected. The code retrieves the position of the previous occurrence of the remainder and adds parentheses around the repeating pattern in the result.\\n\\n11. If the remainder is not in the map, it is added to the map with its current position.\\n\\n12. The remainder is then multiplied by 10 and divided by the denominator. The floor value of this division is added to the result.\\n\\n13. The remainder is updated by taking the modulus of the division result with the denominator.\\n\\n14. Once the loop ends, the final result is returned.\\n\\n# Complexity\\n- Time complexity:\\nO(denominator)\\nwhere the denominator represents the size of the input denominator. This is because the loop iterates until the remainder becomes zero, and in the worst case, the remainder can take values from 1 to the denominator.\\n\\n- Space complexity:\\n O(denominator)\\nas the map can store up to denominator number of entries in the worst case scenario where there is a repeating pattern of length denominator.\\n\\n# Code\\n```\\n/**\\n * @param {number} numerator\\n * @param {number} denominator\\n * @return {string}\\n */\\nvar fractionToDecimal = function(numerator, denominator) {\\n  if (numerator === 0) {\\n    return \"0\"; // Special case for numerator equal to zero\\n  }\\n\\n  let result = \"\";\\n\\n  // Handle sign\\n  if (Math.sign(numerator) !== Math.sign(denominator)) {\\n    result += \"-\";\\n  }\\n\\n  // Convert to positive values\\n  const numer = Math.abs(numerator);\\n  const denom = Math.abs(denominator);\\n\\n  // Integer part\\n  result += Math.floor(numer / denom);\\n\\n  let remainder = numer % denom;\\n  if (remainder === 0) {\\n    return result; // No fractional part, return result\\n  }\\n\\n  result += \".\";\\n\\n  const map = new Map(); // To track remainders and their positions\\n\\n  while (remainder !== 0) {\\n    if (map.has(remainder)) {\\n      // Repeating pattern detected\\n      const index = map.get(remainder);\\n      result = result.slice(0, index) + \"(\" + result.slice(index) + \")\";\\n      break;\\n    }\\n\\n    map.set(remainder, result.length); // Store remainder and position\\n\\n    remainder *= 10;\\n    result += Math.floor(remainder / denom);\\n    remainder %= denom;\\n  }\\n\\n  return result;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} numerator\\n * @param {number} denominator\\n * @return {string}\\n */\\nvar fractionToDecimal = function(numerator, denominator) {\\n  if (numerator === 0) {\\n    return \"0\"; // Special case for numerator equal to zero\\n  }\\n\\n  let result = \"\";\\n\\n  // Handle sign\\n  if (Math.sign(numerator) !== Math.sign(denominator)) {\\n    result += \"-\";\\n  }\\n\\n  // Convert to positive values\\n  const numer = Math.abs(numerator);\\n  const denom = Math.abs(denominator);\\n\\n  // Integer part\\n  result += Math.floor(numer / denom);\\n\\n  let remainder = numer % denom;\\n  if (remainder === 0) {\\n    return result; // No fractional part, return result\\n  }\\n\\n  result += \".\";\\n\\n  const map = new Map(); // To track remainders and their positions\\n\\n  while (remainder !== 0) {\\n    if (map.has(remainder)) {\\n      // Repeating pattern detected\\n      const index = map.get(remainder);\\n      result = result.slice(0, index) + \"(\" + result.slice(index) + \")\";\\n      break;\\n    }\\n\\n    map.set(remainder, result.length); // Store remainder and position\\n\\n    remainder *= 10;\\n    result += Math.floor(remainder / denom);\\n    remainder %= denom;\\n  }\\n\\n  return result;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591102,
                "title": "python-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def fractionToDecimal(self, n: int, d: int) -> str:\\n        sol = \"\"\\n        if n == 0:\\n            return \"0\"\\n        negative = (n < 0) ^ (d < 0)\\n        n = abs(n)\\n        d = abs(d)\\n        sol+=str(n // d)\\n\\n        dec = \"\"\\n        if n % d:\\n            nums = {}\\n            sol += \".\"\\n            n = n % d\\n            while n:\\n                if n in nums:\\n                    dec += \")\"\\n                    pos = nums[n]\\n                    dec = dec[:pos] + \"(\" + dec[pos:]\\n                    break\\n\\n                nums[n] = len(dec)\\n                n *= 10\\n                dec += str(n // d)\\n                n = n % d\\n                \\n        sign = \"-\" if negative else \"\"\\n        return sign + sol + dec\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, n: int, d: int) -> str:\\n        sol = \"\"\\n        if n == 0:\\n            return \"0\"\\n        negative = (n < 0) ^ (d < 0)\\n        n = abs(n)\\n        d = abs(d)\\n        sol+=str(n // d)\\n\\n        dec = \"\"\\n        if n % d:\\n            nums = {}\\n            sol += \".\"\\n            n = n % d\\n            while n:\\n                if n in nums:\\n                    dec += \")\"\\n                    pos = nums[n]\\n                    dec = dec[:pos] + \"(\" + dec[pos:]\\n                    break\\n\\n                nums[n] = len(dec)\\n                n *= 10\\n                dec += str(n // d)\\n                n = n % d\\n                \\n        sign = \"-\" if negative else \"\"\\n        return sign + sol + dec\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549719,
                "title": "166-fraction-to-recurring-decimal",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) \\n    {\\n        unordered_map<long long,int>q;    \\n        long long ne = numerator,de = denominator;\\n        if(numerator <0 && denominator < 0)\\n        {\\n            ne = abs(numerator),de = abs(denominator);\\n        }\\n       \\n        string ans = to_string(ne/de);\\n        int pi = ans.size();\\n        ans += \\'.\\';\\n        if(ne%de == 0)\\n        {\\n            ans.pop_back();\\n            return ans;\\n        }\\n\\n        q[ne%de] = 1;\\n        long long temp = ne%de;\\n        int n = 0;\\n        while(q.size())\\n        {\\n            q[temp] = ++n;\\n            temp *= 10;\\n           ans += to_string(abs(temp/de));\\n           temp = temp % de;\\n\\n           if(temp == 0)\\n           {\\n               return ans;\\n           }\\n           else if(q.find(temp) != q.end())\\n           {\\n               ans.push_back(\\')\\');\\n               int ac = q[temp];\\n               ans =  ans.substr(0,pi+ac) + \\'(\\' + ans.substr(pi+ac);\\n               if(de < 0 || ne < 0)\\n               {\\n                   ans = \\'-\\'+ans;\\n               }\\n               return ans;\\n           }\\n        } \\n\\n        return \"\";                  \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) \\n    {\\n        unordered_map<long long,int>q;    \\n        long long ne = numerator,de = denominator;\\n        if(numerator <0 && denominator < 0)\\n        {\\n            ne = abs(numerator),de = abs(denominator);\\n        }\\n       \\n        string ans = to_string(ne/de);\\n        int pi = ans.size();\\n        ans += \\'.\\';\\n        if(ne%de == 0)\\n        {\\n            ans.pop_back();\\n            return ans;\\n        }\\n\\n        q[ne%de] = 1;\\n        long long temp = ne%de;\\n        int n = 0;\\n        while(q.size())\\n        {\\n            q[temp] = ++n;\\n            temp *= 10;\\n           ans += to_string(abs(temp/de));\\n           temp = temp % de;\\n\\n           if(temp == 0)\\n           {\\n               return ans;\\n           }\\n           else if(q.find(temp) != q.end())\\n           {\\n               ans.push_back(\\')\\');\\n               int ac = q[temp];\\n               ans =  ans.substr(0,pi+ac) + \\'(\\' + ans.substr(pi+ac);\\n               if(de < 0 || ne < 0)\\n               {\\n                   ans = \\'-\\'+ans;\\n               }\\n               return ans;\\n           }\\n        } \\n\\n        return \"\";                  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173413,
                "title": "java-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public String fractionToDecimal(int num,int deno) {\\n        boolean isNegative = false;\\n        StringBuilder ans = new StringBuilder();\\n\\n        if(num<0 && deno>0 || num>0 && deno<0){\\n            ans.append(\\'-\\');\\n        } \\n        \\n        long quo = num/deno,rem =num%deno;\\n       \\n        ans.append(Math.abs(quo));\\n        if(rem==0){\\n            return ans.toString();\\n        }else{\\n            ans.append(\".\");\\n\\n            HashMap<Long,Integer> map = new HashMap<>();\\n            while(rem!=0){\\n                if(map.containsKey(rem)){\\n                    int pos = map.get(rem);\\n                    ans.insert(pos,\\'(\\');\\n                    ans.append(\\')\\');\\n                    break;\\n                }else{\\n                    map.put(rem,ans.length());\\n                    rem*=10;\\n                    quo=rem/deno;\\n                    rem=rem%deno;\\n                    ans.append(Math.abs(quo)); \\n                }\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int num,int deno) {\\n        boolean isNegative = false;\\n        StringBuilder ans = new StringBuilder();\\n\\n        if(num<0 && deno>0 || num>0 && deno<0){\\n            ans.append(\\'-\\');\\n        } \\n        \\n        long quo = num/deno,rem =num%deno;\\n       \\n        ans.append(Math.abs(quo));\\n        if(rem==0){\\n            return ans.toString();\\n        }else{\\n            ans.append(\".\");\\n\\n            HashMap<Long,Integer> map = new HashMap<>();\\n            while(rem!=0){\\n                if(map.containsKey(rem)){\\n                    int pos = map.get(rem);\\n                    ans.insert(pos,\\'(\\');\\n                    ans.append(\\')\\');\\n                    break;\\n                }else{\\n                    map.put(rem,ans.length());\\n                    rem*=10;\\n                    quo=rem/deno;\\n                    rem=rem%deno;\\n                    ans.append(Math.abs(quo)); \\n                }\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153685,
                "title": "c-straight-ward-solution-64ms-97",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public string FractionToDecimal(int numerator, int denominator)\\n    {\\n        var sb = new StringBuilder();\\n\\n        if (numerator < 0 ^ denominator < 0 && numerator != 0) \\n            sb.Append(\\'-\\');\\n\\n        long n = Math.Abs((long)numerator);\\n        long d = Math.Abs((long)denominator);            \\n\\n        sb.Append(n / d);\\n\\n        n = n % d;\\n\\n        if (n != 0)\\n        {\\n            sb.Append(\\'.\\');\\n\\n            var f2Pos = new Dictionary<long, int>();\\n\\n            while (n != 0 && !f2Pos.ContainsKey(n))\\n            {\\n                f2Pos.Add(n,  sb.Length);\\n\\n                n = n * 10;\\n\\n                sb.Append(n / d);\\n\\n                n = n % d;\\n            }\\n\\n            if (f2Pos.ContainsKey(n))\\n            {\\n                sb.Insert(f2Pos[n], \\'(\\').Append(\\')\\');\\n            }\\n        }\\n\\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public string FractionToDecimal(int numerator, int denominator)\\n    {\\n        var sb = new StringBuilder();\\n\\n        if (numerator < 0 ^ denominator < 0 && numerator != 0) \\n            sb.Append(\\'-\\');\\n\\n        long n = Math.Abs((long)numerator);\\n        long d = Math.Abs((long)denominator);            \\n\\n        sb.Append(n / d);\\n\\n        n = n % d;\\n\\n        if (n != 0)\\n        {\\n            sb.Append(\\'.\\');\\n\\n            var f2Pos = new Dictionary<long, int>();\\n\\n            while (n != 0 && !f2Pos.ContainsKey(n))\\n            {\\n                f2Pos.Add(n,  sb.Length);\\n\\n                n = n * 10;\\n\\n                sb.Append(n / d);\\n\\n                n = n % d;\\n            }\\n\\n            if (f2Pos.ContainsKey(n))\\n            {\\n                sb.Insert(f2Pos[n], \\'(\\').Append(\\')\\');\\n            }\\n        }\\n\\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033967,
                "title": "easy-c-solution-with-explanation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        // If numerator is zero then return 0;\\n        if (numerator == 0) \\n            return \"0\";\\n\\n        string res = \"\";\\n\\n        // Maybe numerator & denominator can be negative\\n        if ((numerator < 0) ^ (denominator < 0)) \\n            res += \\'-\\';\\n        \\n        /*\\n        // Also you can check for negative like\\n        if((numerator < 0 && denominator > 0) || (numerator > 0 && denominator < 0))\\n            res += \\'-\\';\\n        */   \\n\\n        // Remove the negative sign from the numerator | denominator\\n        long dividend = abs((long) numerator);\\n        long divisor = abs((long) denominator);\\n\\n        // Find the remainder\\n        long rem = dividend % divisor;\\n\\n        // Add the numeric result\\n        res += to_string(dividend / divisor);\\n\\n        // in case no fractional part\\n        if (rem == 0)\\n            return res;\\n\\n        // If remainder is not 0 then they having fractional part so add the point for fraction\\n        res += \\'.\\';\\n\\n        unordered_map<long, int> map;\\n\\n        // Calculate division\\n        while(rem != 0) {\\n\\n            // Check for repeating part, If exist then insert in ();\\n            if (map.count(rem) > 0) {\\n                res.insert(map[rem], 1, \\'(\\');\\n                res += \\')\\';\\n                break;\\n            }\\n\\n            map[rem] = res.size();\\n\\n            rem *= 10;\\n\\n            // Add the quotient in result\\n            res += to_string(rem / divisor);\\n            rem %= divisor;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n# Upvote if it is useful",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        // If numerator is zero then return 0;\\n        if (numerator == 0) \\n            return \"0\";\\n\\n        string res = \"\";\\n\\n        // Maybe numerator & denominator can be negative\\n        if ((numerator < 0) ^ (denominator < 0)) \\n            res += \\'-\\';\\n        \\n        /*\\n        // Also you can check for negative like\\n        if((numerator < 0 && denominator > 0) || (numerator > 0 && denominator < 0))\\n            res += \\'-\\';\\n        */   \\n\\n        // Remove the negative sign from the numerator | denominator\\n        long dividend = abs((long) numerator);\\n        long divisor = abs((long) denominator);\\n\\n        // Find the remainder\\n        long rem = dividend % divisor;\\n\\n        // Add the numeric result\\n        res += to_string(dividend / divisor);\\n\\n        // in case no fractional part\\n        if (rem == 0)\\n            return res;\\n\\n        // If remainder is not 0 then they having fractional part so add the point for fraction\\n        res += \\'.\\';\\n\\n        unordered_map<long, int> map;\\n\\n        // Calculate division\\n        while(rem != 0) {\\n\\n            // Check for repeating part, If exist then insert in ();\\n            if (map.count(rem) > 0) {\\n                res.insert(map[rem], 1, \\'(\\');\\n                res += \\')\\';\\n                break;\\n            }\\n\\n            map[rem] = res.size();\\n\\n            rem *= 10;\\n\\n            // Add the quotient in result\\n            res += to_string(rem / divisor);\\n            rem %= divisor;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830411,
                "title": "0-ms-faster-than-100",
                "content": "\\n```\\nfunc fractionToDecimal(numerator int, denominator int) string {\\n\\tif numerator == 0 {\\n\\t\\treturn \"0\"\\n\\t}\\n\\tvar res bytes.Buffer\\n\\tif ((numerator < 0) && (denominator > 0)) || ((numerator > 0) && (denominator < 0)) {\\n\\t\\tres.WriteString(\"-\")\\n\\t}\\n\\tnum := int(math.Abs(float64(numerator)))\\n\\tden := int(math.Abs(float64(denominator)))\\n\\tres.WriteString(fmt.Sprintf(\"%d\", num/den))\\n\\tnum %= den\\n\\tif num == 0 {\\n\\t\\treturn res.String()\\n\\t}\\n\\tres.WriteString(\".\")\\n\\tremainder := make(map[int]int)\\n\\tremainder[num] = res.Len()\\n\\tfor num != 0 {\\n\\t\\tnum *= 10\\n\\t\\tres.WriteString(fmt.Sprintf(\"%d\", num/den))\\n\\t\\tnum %= den\\n\\t\\tif index, ok := remainder[num]; ok {\\n\\t\\t\\tresult := res.String()\\n\\t\\t\\treturn result[:index] + \"(\" + result[index:] + \")\"\\n\\t\\t}\\n\\t\\tremainder[num] = res.Len()\\n\\t}\\n\\treturn res.String()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc fractionToDecimal(numerator int, denominator int) string {\\n\\tif numerator == 0 {\\n\\t\\treturn \"0\"\\n\\t}\\n\\tvar res bytes.Buffer\\n\\tif ((numerator < 0) && (denominator > 0)) || ((numerator > 0) && (denominator < 0)) {\\n\\t\\tres.WriteString(\"-\")\\n\\t}\\n\\tnum := int(math.Abs(float64(numerator)))\\n\\tden := int(math.Abs(float64(denominator)))\\n\\tres.WriteString(fmt.Sprintf(\"%d\", num/den))\\n\\tnum %= den\\n\\tif num == 0 {\\n\\t\\treturn res.String()\\n\\t}\\n\\tres.WriteString(\".\")\\n\\tremainder := make(map[int]int)\\n\\tremainder[num] = res.Len()\\n\\tfor num != 0 {\\n\\t\\tnum *= 10\\n\\t\\tres.WriteString(fmt.Sprintf(\"%d\", num/den))\\n\\t\\tnum %= den\\n\\t\\tif index, ok := remainder[num]; ok {\\n\\t\\t\\tresult := res.String()\\n\\t\\t\\treturn result[:index] + \"(\" + result[index:] + \")\"\\n\\t\\t}\\n\\t\\tremainder[num] = res.Len()\\n\\t}\\n\\treturn res.String()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2549434,
                "title": "best-explanation-clean-crisp-hashmap",
                "content": "Lets simulate the process of converting fraction to decimal. Lets look at the part where we have already figured out the integer part which is floor(numerator / denominator).\\nNow you are left with ( remainder = numerator%denominator ) / denominator.\\nIf you remember the process of converting to decimal, at each step you do the following :\\n\\n1) multiply the remainder by 10,\\n2) append remainder / denominator to your decimals\\n3) remainder = remainder % denominator.\\n\\nAt any moment, if your remainder becomes 0, you are done.\\n\\nHowever, there is a problem with recurring decimals. For example if you look at 1/3, the remainder never becomes 0.\\n\\nNotice one more important thing.\\nIf you start with remainder = R at any point with denominator d, you will always get the same sequence of digits.\\nSo, if your remainder repeats at any point of time, you know that the digits between the last occurrence of R will keep repeating.\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) {\\n        return \"0\";\\n        }\\n        if (denominator == 0) {\\n            return \"\";\\n        }\\n        string result = \"\";\\n        //std::cout << numerator << \" \" << denominator << endl;\\n        if ((numerator < 0) ^ (denominator < 0)) {\\n            //std::cout << \"True\" << endl;\\n            result += \"-\";\\n        }\\n        //numerator = abs(numerator);\\n        //denominator = abs(denominator);\\n        long num = numerator, den = denominator;\\n        num = abs(num);\\n        den = abs(den);\\n        long res = num/den;\\n        result += to_string(res);\\n    \\n        long rem = (num%den)*10;\\n        if (rem == 0) {\\n            return result;\\n        }\\n    \\n        std::map<long, int> mp;\\n        result += \".\";\\n        while (rem != 0) {\\n            if (mp.find(rem) != mp.end()) {\\n                int beg = mp[rem];\\n                string part1 = result.substr(0,beg);\\n                string part2 = result.substr(beg, result.length()-beg);\\n                result = part1 + \"(\"+part2+\")\";\\n                return result;\\n            }\\n            mp[rem] = result.length();\\n            res = rem/den;\\n            result += to_string(res);\\n            rem = (rem%den) *10;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) {\\n        return \"0\";\\n        }\\n        if (denominator == 0) {\\n            return \"\";\\n        }\\n        string result = \"\";\\n        //std::cout << numerator << \" \" << denominator << endl;\\n        if ((numerator < 0) ^ (denominator < 0)) {\\n            //std::cout << \"True\" << endl;\\n            result += \"-\";\\n        }\\n        //numerator = abs(numerator);\\n        //denominator = abs(denominator);\\n        long num = numerator, den = denominator;\\n        num = abs(num);\\n        den = abs(den);\\n        long res = num/den;\\n        result += to_string(res);\\n    \\n        long rem = (num%den)*10;\\n        if (rem == 0) {\\n            return result;\\n        }\\n    \\n        std::map<long, int> mp;\\n        result += \".\";\\n        while (rem != 0) {\\n            if (mp.find(rem) != mp.end()) {\\n                int beg = mp[rem];\\n                string part1 = result.substr(0,beg);\\n                string part2 = result.substr(beg, result.length()-beg);\\n                result = part1 + \"(\"+part2+\")\";\\n                return result;\\n            }\\n            mp[rem] = result.length();\\n            res = rem/den;\\n            result += to_string(res);\\n            rem = (rem%den) *10;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2511125,
                "title": "java-solution",
                "content": "Calculation of the Integral part is simple. Its basic division. \\nAfter that we need to multply the remainder by 10 and make it the new numerator and keep calculating the decimal part.\\nWe will save the states of the numerator and if the states get repeated again, this would mean that we have recurring part. Then we can just insert are brackets around the recurring part.\\n\\nIts basically the division algorithm with just a hashmap to check if there exists a recurrence in the fractional part of the number.\\n\\n```\\nclass Solution {\\n    HashMap<Long, Integer> visited = new HashMap<>(); \\n    // Stores states(numerators) and indices where the \\'(\\' would come if this is the state that starts the recurrence.\\n\\t\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        long n = numerator;\\n        long d = denominator;\\n        boolean negative = false;\\n\\t\\t\\n\\t\\t// We calculate the answer as positive numbers and then add the signs at the end.\\n        if(n < 0){\\n            n*=-1;\\n            negative = true;\\n        }\\n        if(d < 0){\\n            d*=-1;\\n            negative = !negative;\\n        }\\n        \\n        String sign = \"\";\\n\\t\\t\\n        if(negative && n != 0){\\n            sign =\"-\";\\n        }\\n\\t\\t\\n\\t\\t//Preprocessing. We get the part before the decimal first. Then check if there exists a remainder.\\n\\t\\t// Only then do we preoceed ahead with the fractional part.\\n\\t\\t\\n        long q = n/d;\\n        long r = n%d;\\n        StringBuilder str = new StringBuilder(sign);\\n        str.append(q);\\n        if(r == 0){\\n            return str.toString();\\n        }\\n        str.append(\\'.\\');\\n        n = 10 * r;\\n        while(n > 0){\\n            if(visited.containsKey(n)){\\n                str.append(\\')\\');\\n                break;\\n            }\\n            visited.put(n, str.length());\\n            q = n/d;\\n            r = n %d;\\n            str.append(q);\\n            n = 10 * r;\\n        }\\n        if(visited.containsKey(n)){\\n            str.insert(visited.get(n), \"(\");\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Long, Integer> visited = new HashMap<>(); \\n    // Stores states(numerators) and indices where the \\'(\\' would come if this is the state that starts the recurrence.\\n\\t\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        long n = numerator;\\n        long d = denominator;\\n        boolean negative = false;\\n\\t\\t\\n\\t\\t// We calculate the answer as positive numbers and then add the signs at the end.\\n        if(n < 0){\\n            n*=-1;\\n            negative = true;\\n        }\\n        if(d < 0){\\n            d*=-1;\\n            negative = !negative;\\n        }\\n        \\n        String sign = \"\";\\n\\t\\t\\n        if(negative && n != 0){\\n            sign =\"-\";\\n        }\\n\\t\\t\\n\\t\\t//Preprocessing. We get the part before the decimal first. Then check if there exists a remainder.\\n\\t\\t// Only then do we preoceed ahead with the fractional part.\\n\\t\\t\\n        long q = n/d;\\n        long r = n%d;\\n        StringBuilder str = new StringBuilder(sign);\\n        str.append(q);\\n        if(r == 0){\\n            return str.toString();\\n        }\\n        str.append(\\'.\\');\\n        n = 10 * r;\\n        while(n > 0){\\n            if(visited.containsKey(n)){\\n                str.append(\\')\\');\\n                break;\\n            }\\n            visited.put(n, str.length());\\n            q = n/d;\\n            r = n %d;\\n            str.append(q);\\n            n = 10 * r;\\n        }\\n        if(visited.containsKey(n)){\\n            str.insert(visited.get(n), \"(\");\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357200,
                "title": "37ms-python-solution-with-comments-using-dictionary",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # Get sign\\n        negative = numerator * denominator < 0\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        # First division\\n        quotient, remainder = divmod(numerator, denominator)\\n        remainders = {}\\n        res = [str(quotient)]\\n        \\n        # If not divided exactly, repeat until remainder is zero or loop\\n        i = 0\\n        while remainder != 0 and remainder not in remainders:\\n            remainders[remainder] = i\\n            quotient, remainder = divmod(remainder * 10, denominator)\\n            res.append(str(quotient))\\n            i += 1\\n        \\n        # Add sign\\n        if negative:\\n            res[0] = \\'-\\' + res[0]\\n        \\n        # Return result\\n        if remainder == 0:\\n            if len(res) == 1:\\n                return res[0]\\n            else:\\n                return res[0] + \\'.\\' + \\'\\'.join(res[1:])\\n\\n        return res[0] + \\'.\\' + \\'\\'.join(res[1:remainders[remainder] + 1]) + \\'(\\' + \\'\\'.join(res[remainders[remainder] + 1:]) + \\')\\'\\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # Get sign\\n        negative = numerator * denominator < 0\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        # First division\\n        quotient, remainder = divmod(numerator, denominator)\\n        remainders = {}\\n        res = [str(quotient)]\\n        \\n        # If not divided exactly, repeat until remainder is zero or loop\\n        i = 0\\n        while remainder != 0 and remainder not in remainders:\\n            remainders[remainder] = i\\n            quotient, remainder = divmod(remainder * 10, denominator)\\n            res.append(str(quotient))\\n            i += 1\\n        \\n        # Add sign\\n        if negative:\\n            res[0] = \\'-\\' + res[0]\\n        \\n        # Return result\\n        if remainder == 0:\\n            if len(res) == 1:\\n                return res[0]\\n            else:\\n                return res[0] + \\'.\\' + \\'\\'.join(res[1:])\\n\\n        return res[0] + \\'.\\' + \\'\\'.join(res[1:remainders[remainder] + 1]) + \\'(\\' + \\'\\'.join(res[remainders[remainder] + 1:]) + \\')\\'\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2303120,
                "title": "easy-c-with-comments-code",
                "content": "\\tstring fractionToDecimal(int num, int den) {\\n\\t\\t\\tbool neg = (num<0)^(den<0) ? true: false;\\n\\t\\t\\tlong long int n = num;\\n\\t\\t\\tlong long int d = den;\\n\\t\\t\\tn = abs(n);\\n\\t\\t\\td = abs(d);\\n\\t\\t\\tlong long int tmp = n/d;\\n\\t\\t\\tstring res = \"\";\\n\\t\\t\\tif(neg && n!=0)\\n\\t\\t\\t res += \"-\";\\n\\n\\t\\t\\tres += to_string(tmp);\\n\\t\\t\\tn %= d;\\n\\t\\t\\tif(n==0){\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n\\t\\t\\tres += \".\";\\n\\t\\t\\t// now before decimal, work is over now after decimal\\n\\t\\t\\tbool repeat = false;\\n\\t\\t\\tunordered_map<long long int, int> mp; // mapping from remainder to size of string\\n\\t\\t\\twhile(n!=0 && !repeat){\\n\\t\\t\\t\\tif(mp.find(n)==mp.end())\\n\\t\\t\\t\\t\\tmp[n] = res.size();\\n\\t\\t\\t\\telse if(mp.find(n)!=mp.end()){\\n\\t\\t\\t\\t\\t// repeat found\\n\\t\\t\\t\\t\\trepeat = true; // no need of repeat variable as we are breaking explicitly\\n\\t\\t\\t\\t\\tres.push_back(\\')\\');\\n\\t\\t\\t\\t\\tres.insert(mp[n],\"(\");\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn = n*10;\\n\\t\\t\\t\\tres += to_string(n/d);\\n\\t\\t\\t\\tn %= d;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\tstring fractionToDecimal(int num, int den) {\\n\\t\\t\\tbool neg = (num<0)^(den<0) ? true: false;\\n\\t\\t\\tlong long int n = num;\\n\\t\\t\\tlong long int d = den;\\n\\t\\t\\tn = abs(n);\\n\\t\\t\\td = abs(d);\\n\\t\\t\\tlong long int tmp = n/d;\\n\\t\\t\\tstring res = \"\";\\n\\t\\t\\tif(neg && n!=0)\\n\\t\\t\\t res += \"-\";\\n\\n\\t\\t\\tres += to_string(tmp);\\n\\t\\t\\tn %= d;\\n\\t\\t\\tif(n==0){\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n\\t\\t\\tres += \".\";\\n\\t\\t\\t// now before decimal, work is over now after decimal\\n\\t\\t\\tbool repeat = false;\\n\\t\\t\\tunordered_map<long long int, int> mp; // mapping from remainder to size of string\\n\\t\\t\\twhile(n!=0 && !repeat){\\n\\t\\t\\t\\tif(mp.find(n)==mp.end())\\n\\t\\t\\t\\t\\tmp[n] = res.size();\\n\\t\\t\\t\\telse if(mp.find(n)!=mp.end()){\\n\\t\\t\\t\\t\\t// repeat found\\n\\t\\t\\t\\t\\trepeat = true; // no need of repeat variable as we are breaking explicitly\\n\\t\\t\\t\\t\\tres.push_back(\\')\\');\\n\\t\\t\\t\\t\\tres.insert(mp[n],\"(\");\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn = n*10;\\n\\t\\t\\t\\tres += to_string(n/d);\\n\\t\\t\\t\\tn %= d;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2296524,
                "title": "easy-java-solution-with-explanations-run-time-2ms",
                "content": "\\n* Check for base conditions\\n*  If numerator ==0 return \"0\"\\n* if denominator==0 return \"\"\\n* check for the sign => if true then append a negative sign to the string builder\\n* append num/den to the string builder\\n* check for the remainder if remainder == 0 return the stringbuilder formed so far\\n* append \".\" to the final answer\\n* create a  Map<Long,Integer>map  to store remainder\\n* lopp till remainder!=0\\n* if map already contains remainder insert \"(\" and the position of map.get(rem)\\n* append \")\"  then break\\n* if not => map.put(rem ,currentlength of stringbuilder)\\n* multiply rem *10 append  rem/den to string Builder \\n* remainder = reminder%den\\n\\n```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if(numerator==0)return \"0\";\\n        if(denominator==0)return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        if(numerator<0 && denominator>0 || numerator>0 && denominator<0)\\n            sb.append(\"-\");\\n        long nume = Math.abs((long)numerator);\\n        long den = Math.abs((long)denominator);\\n        long rem = nume%den;\\n        sb.append(nume/den);\\n        if(rem==0)return sb.toString();\\n        sb.append(\".\");\\n        Map<Long,Integer>map = new HashMap<>();\\n        while(rem!=0){\\n            if(map.containsKey(rem)){\\n                sb.insert(map.get(rem),\"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n           map.put(rem,sb.length());\\n           rem*=10;\\n           sb.append(rem/den);\\n           rem %= den; \\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n***IF YOU LIKED THE APPROACH PLEASE UPVOTE !!***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if(numerator==0)return \"0\";\\n        if(denominator==0)return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        if(numerator<0 && denominator>0 || numerator>0 && denominator<0)\\n            sb.append(\"-\");\\n        long nume = Math.abs((long)numerator);\\n        long den = Math.abs((long)denominator);\\n        long rem = nume%den;\\n        sb.append(nume/den);\\n        if(rem==0)return sb.toString();\\n        sb.append(\".\");\\n        Map<Long,Integer>map = new HashMap<>();\\n        while(rem!=0){\\n            if(map.containsKey(rem)){\\n                sb.insert(map.get(rem),\"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n           map.put(rem,sb.length());\\n           rem*=10;\\n           sb.append(rem/den);\\n           rem %= den; \\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098202,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        pre = \"-\" if numerator * denominator < 0 else \"\"\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        q, r = divmod(numerator, denominator)\\n        q = str(q)\\n        if r == 0:\\n            return pre + q\\n        res = pre + q + \".\"\\n        dic = {}\\n        idx = len(res)\\n        r *= 10\\n        while r > 0:\\n            if r in dic:\\n                return res[:dic[r]] + f\"({res[dic[r]:]})\"\\n            dic[r] = idx\\n            q, r = divmod(r, denominator)\\n            res += (q := str(q))\\n            if r == 0:\\n                return res\\n            idx += len(q)\\n            r *= 10\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        pre = \"-\" if numerator * denominator < 0 else \"\"\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        q, r = divmod(numerator, denominator)\\n        q = str(q)\\n        if r == 0:\\n            return pre + q\\n        res = pre + q + \".\"\\n        dic = {}\\n        idx = len(res)\\n        r *= 10\\n        while r > 0:\\n            if r in dic:\\n                return res[:dic[r]] + f\"({res[dic[r]:]})\"\\n            dic[r] = idx\\n            q, r = divmod(r, denominator)\\n            res += (q := str(q))\\n            if r == 0:\\n                return res\\n            idx += len(q)\\n            r *= 10\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085538,
                "title": "c-easy-approach-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        string ans = \"\";\\n        \\n        int sign = 0;\\n        \\n        if(numerator < 0 and denominator < 0)\\n            sign = 0;\\n        else if(numerator < 0 and denominator > 0 || numerator > 0 and denominator < 0 )\\n            sign = 1;\\n        \\n        long n = abs(numerator);\\n        long d = abs(denominator);\\n        \\n        long q = (n / d);\\n        long r = (n % d);\\n        ans += to_string(q);\\n        \\n        if(r == 0){\\n            if(sign == 1)\\n                ans.insert(ans.begin(),\\'-\\');\\n            return ans;\\n        }\\n        else{\\n            ans += \\'.\\';\\n            unordered_map<long, int> mp; \\n            while(r != 0){\\n                if(mp.find(r) != mp.end()){\\n                    int len = mp[r];\\n                    ans.insert(ans.begin()+len, \\'(\\');\\n                    ans.push_back(\\')\\');\\n                    break;\\n                }\\n                else{\\n                    mp.insert({r,ans.length()});\\n                }\\n                r = r * 10;\\n                q = (r/d);\\n                r = r % d;\\n                ans += to_string(q);\\n            }\\n        }\\n        if(sign == 1)\\n            ans.insert(ans.begin(),\\'-\\');\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        string ans = \"\";\\n        \\n        int sign = 0;\\n        \\n        if(numerator < 0 and denominator < 0)\\n            sign = 0;\\n        else if(numerator < 0 and denominator > 0 || numerator > 0 and denominator < 0 )\\n            sign = 1;\\n        \\n        long n = abs(numerator);\\n        long d = abs(denominator);\\n        \\n        long q = (n / d);\\n        long r = (n % d);\\n        ans += to_string(q);\\n        \\n        if(r == 0){\\n            if(sign == 1)\\n                ans.insert(ans.begin(),\\'-\\');\\n            return ans;\\n        }\\n        else{\\n            ans += \\'.\\';\\n            unordered_map<long, int> mp; \\n            while(r != 0){\\n                if(mp.find(r) != mp.end()){\\n                    int len = mp[r];\\n                    ans.insert(ans.begin()+len, \\'(\\');\\n                    ans.push_back(\\')\\');\\n                    break;\\n                }\\n                else{\\n                    mp.insert({r,ans.length()});\\n                }\\n                r = r * 10;\\n                q = (r/d);\\n                r = r % d;\\n                ans += to_string(q);\\n            }\\n        }\\n        if(sign == 1)\\n            ans.insert(ans.begin(),\\'-\\');\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072354,
                "title": "clean-python-solution",
                "content": "```\\nclass Solution(object):\\n  def fractionToDecimal(self, n, d):\\n    if n%d==0: return str(n // d)\\n    \\n    rdict, ds= {0:-1}, []\\n    \\n    sign, n, d = \\'-\\' if bool(n<0) ^ bool(d<0) else \\'\\', abs(n), abs(d)\\n    I, r = sign + str(n // d), n % d\\n    \\n    while r not in rdict:\\n      rdict[r] = len(ds)\\n      ds.append(str(r * 10 // d))\\n      r = r * 10 % d\\n    \\n    if r:\\n      i = rdict[r]\\n      return \\'{}.{}({})\\'.format(I, \\'\\'.join(ds[:i]),\\'\\'.join(ds[i:]))\\n    else:\\n      return \\'{}.{}\\'.format(I, \\'\\'.join(ds))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n  def fractionToDecimal(self, n, d):\\n    if n%d==0: return str(n // d)\\n    \\n    rdict, ds= {0:-1}, []\\n    \\n    sign, n, d = \\'-\\' if bool(n<0) ^ bool(d<0) else \\'\\', abs(n), abs(d)\\n    I, r = sign + str(n // d), n % d\\n    \\n    while r not in rdict:\\n      rdict[r] = len(ds)\\n      ds.append(str(r * 10 // d))\\n      r = r * 10 % d\\n    \\n    if r:\\n      i = rdict[r]\\n      return \\'{}.{}({})\\'.format(I, \\'\\'.join(ds[:i]),\\'\\'.join(ds[i:]))\\n    else:\\n      return \\'{}.{}\\'.format(I, \\'\\'.join(ds))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985646,
                "title": "javascript-hashmap",
                "content": "```\\n/**\\n * @param {number} numerator\\n * @param {number} denominator\\n * @return {string}\\n */\\nvar fractionToDecimal = function(n, d) {\\n    if (n === 0) {\\n        return \"0\";\\n    }\\n    const sign = n > 0 && d > 0 || n < 0 && d < 0 ? \"\" : \"-\";\\n    n = Math.abs(n);\\n    d = Math.abs(d);\\n    let r = String(Math.trunc(n / d));\\n    let rem = n % d;\\n    if (rem === 0) {\\n        return sign + r;\\n    }\\n    \\n    r += \".\";\\n    const map = new Map();\\n    map.set(rem, r.length);\\n    while (rem > 0) {\\n        rem *= 10;\\n        r += String(Math.trunc(rem/d));\\n        rem = rem % d;\\n        const ex = map.get(rem);\\n        if (ex !== undefined) {\\n            return sign + r.substring(0, ex) + \"(\" + r.substring(ex) + \")\";\\n        }\\n        map.set(rem, r.length);\\n    }\\n    \\n    return sign + r;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} numerator\\n * @param {number} denominator\\n * @return {string}\\n */\\nvar fractionToDecimal = function(n, d) {\\n    if (n === 0) {\\n        return \"0\";\\n    }\\n    const sign = n > 0 && d > 0 || n < 0 && d < 0 ? \"\" : \"-\";\\n    n = Math.abs(n);\\n    d = Math.abs(d);\\n    let r = String(Math.trunc(n / d));\\n    let rem = n % d;\\n    if (rem === 0) {\\n        return sign + r;\\n    }\\n    \\n    r += \".\";\\n    const map = new Map();\\n    map.set(rem, r.length);\\n    while (rem > 0) {\\n        rem *= 10;\\n        r += String(Math.trunc(rem/d));\\n        rem = rem % d;\\n        const ex = map.get(rem);\\n        if (ex !== undefined) {\\n            return sign + r.substring(0, ex) + \"(\" + r.substring(ex) + \")\";\\n        }\\n        map.set(rem, r.length);\\n    }\\n    \\n    return sign + r;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1898401,
                "title": "my-cpp-solution",
                "content": "Implementation\\n\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        \\n        if(!numerator) return \"0\";\\n        \\n        string ans;\\n        \\n        if((numerator > 0) ^ (denominator > 0)){\\n            ans += \"-\";\\n        }\\n        \\n\\t\\t// basically converting into the long abs value\\n        long num = labs(numerator), den = labs(denominator);\\n        \\n        long quotient = num / den;\\n        long remainder = num % den;\\n        if(!remainder){\\n            ans += to_string(quotient);\\n            return ans;\\n        }\\n        ans += to_string(quotient) + \\'.\\';\\n        unordered_map<long, int> freq;\\n        \\n        while(remainder){\\n            if(freq.find(remainder) != freq.end()){\\n                ans.insert(freq[remainder], \"(\");\\n                ans += \\')\\';\\n                break;\\n            }\\n            else{\\n                freq[remainder] = ans.size();\\n                remainder *= 10;\\n                quotient = remainder / den;\\n                remainder = remainder % den;\\n                ans += to_string(quotient);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        \\n        if(!numerator) return \"0\";\\n        \\n        string ans;\\n        \\n        if((numerator > 0) ^ (denominator > 0)){\\n            ans += \"-\";\\n        }\\n        \\n\\t\\t// basically converting into the long abs value\\n        long num = labs(numerator), den = labs(denominator);\\n        \\n        long quotient = num / den;\\n        long remainder = num % den;\\n        if(!remainder){\\n            ans += to_string(quotient);\\n            return ans;\\n        }\\n        ans += to_string(quotient) + \\'.\\';\\n        unordered_map<long, int> freq;\\n        \\n        while(remainder){\\n            if(freq.find(remainder) != freq.end()){\\n                ans.insert(freq[remainder], \"(\");\\n                ans += \\')\\';\\n                break;\\n            }\\n            else{\\n                freq[remainder] = ans.size();\\n                remainder *= 10;\\n                quotient = remainder / den;\\n                remainder = remainder % den;\\n                ans += to_string(quotient);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850961,
                "title": "plain-c-no-additional-memory-floyd-s-cycle-detection-algorithm",
                "content": "```\\n\\ntypedef long long i64;\\n\\nvoid next(i64* r, i64* n, i64 b) {\\n    *n = (*r*10) / b;\\n    *r = (*r*10) % b;\\n}\\n\\nchar * fractionToDecimal(int numerator, int denominator){\\n    char* ret = malloc(20000);\\n    char* p = ret;\\n    i64 a = numerator;\\n    i64 b = denominator;\\n    i64 r1, r2;\\n    i64 n1, n2;\\n    int i;\\n    int point = 0;\\n       \\n    a = labs(a);\\n    b = labs(b);\\n    \\n    r1 = r2 = a%b;\\n\\n    next(&r1, &n1, b);\\n\\n    next(&r2, &n2, b);\\n    next(&r2, &n2, b);\\n\\n    // has cycle\\n    while (r1 != r2) {\\n        next(&r1, &n1, b);\\n\\n        next(&r2, &n2, b);\\n        next(&r2, &n2, b);\\n    }\\n\\n    int start = 0;\\n    int len = 1;\\n\\n    r1 = a%b;\\n    \\n    // cycle start\\n    while (r1 != r2) {\\n        next(&r1, &n1, b);\\n        next(&r2, &n2, b);\\n        start ++;\\n    }\\n\\n    // cycle len\\n    next(&r1, &n1, b);\\n    while (r1 != r2) {\\n        next(&r1, &n1, b);\\n        len ++;\\n    }\\n\\n    if ((i64)numerator*(i64)denominator < 0) {\\n        sprintf(ret, \"-%lld\", a/b);\\n    } else {\\n        sprintf(ret, \"%lld\", a/b);\\n    }\\n    p += strlen(ret);\\n    \\n    r1 = a%b;\\n    next(&r1, &n1, b);\\n    for (i = 0; i < start; i++) {\\n        if (!point) {\\n            *p++ = \\'.\\'; point = 1;\\n        }\\n\\n        *p++ = n1 + \\'0\\';\\n        next(&r1, &n1, b);\\n    }\\n    if (len > 1 || n1 != 0) {\\n        if (!point) {\\n            *p++ = \\'.\\'; point = 1;\\n        }\\n\\n        *p++= \\'(\\';\\n        for (i = 0; i < len; i++) {\\n            *p++ = n1 + \\'0\\';\\n            next(&r1, &n1, b);\\n        }\\n        *p++= \\')\\';\\n    }\\n    *p++= 0;\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\ntypedef long long i64;\\n\\nvoid next(i64* r, i64* n, i64 b) {\\n    *n = (*r*10) / b;\\n    *r = (*r*10) % b;\\n}\\n\\nchar * fractionToDecimal(int numerator, int denominator){\\n    char* ret = malloc(20000);\\n    char* p = ret;\\n    i64 a = numerator;\\n    i64 b = denominator;\\n    i64 r1, r2;\\n    i64 n1, n2;\\n    int i;\\n    int point = 0;\\n       \\n    a = labs(a);\\n    b = labs(b);\\n    \\n    r1 = r2 = a%b;\\n\\n    next(&r1, &n1, b);\\n\\n    next(&r2, &n2, b);\\n    next(&r2, &n2, b);\\n\\n    // has cycle\\n    while (r1 != r2) {\\n        next(&r1, &n1, b);\\n\\n        next(&r2, &n2, b);\\n        next(&r2, &n2, b);\\n    }\\n\\n    int start = 0;\\n    int len = 1;\\n\\n    r1 = a%b;\\n    \\n    // cycle start\\n    while (r1 != r2) {\\n        next(&r1, &n1, b);\\n        next(&r2, &n2, b);\\n        start ++;\\n    }\\n\\n    // cycle len\\n    next(&r1, &n1, b);\\n    while (r1 != r2) {\\n        next(&r1, &n1, b);\\n        len ++;\\n    }\\n\\n    if ((i64)numerator*(i64)denominator < 0) {\\n        sprintf(ret, \"-%lld\", a/b);\\n    } else {\\n        sprintf(ret, \"%lld\", a/b);\\n    }\\n    p += strlen(ret);\\n    \\n    r1 = a%b;\\n    next(&r1, &n1, b);\\n    for (i = 0; i < start; i++) {\\n        if (!point) {\\n            *p++ = \\'.\\'; point = 1;\\n        }\\n\\n        *p++ = n1 + \\'0\\';\\n        next(&r1, &n1, b);\\n    }\\n    if (len > 1 || n1 != 0) {\\n        if (!point) {\\n            *p++ = \\'.\\'; point = 1;\\n        }\\n\\n        *p++= \\'(\\';\\n        for (i = 0; i < len; i++) {\\n            *p++ = n1 + \\'0\\';\\n            next(&r1, &n1, b);\\n        }\\n        *p++= \\')\\';\\n    }\\n    *p++= 0;\\n    return ret;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1782737,
                "title": "c-100-2ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator  == 0) return \"0\";\\n        string ans ;\\n        ans+=((numerator>0)^(denominator>0))?\"-\":\"\";\\n        long n=abs(numerator),d=abs(denominator);\\n        ans+=to_string(n/d);\\n        n=n%d;\\n        if(!n) return ans;\\n        ans+=\".\";\\n        unordered_map<long ,int> mp;\\n        mp[n]=ans.size();\\n        while(n)\\n        {\\n            n*=10;\\n            ans+=to_string(n/d);\\n            n=n%d;\\n            if(mp[n])\\n            {\\n                ans.insert(mp[n],\"(\");\\n                ans+=\")\";\\n                break;\\n           }\\n            mp[n]=ans.size();\\n        }\\n        return ans ;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator  == 0) return \"0\";\\n        string ans ;\\n        ans+=((numerator>0)^(denominator>0))?\"-\":\"\";\\n        long n=abs(numerator),d=abs(denominator);\\n        ans+=to_string(n/d);\\n        n=n%d;\\n        if(!n) return ans;\\n        ans+=\".\";\\n        unordered_map<long ,int> mp;\\n        mp[n]=ans.size();\\n        while(n)\\n        {\\n            n*=10;\\n            ans+=to_string(n/d);\\n            n=n%d;\\n            if(mp[n])\\n            {\\n                ans.insert(mp[n],\"(\");\\n                ans+=\")\";\\n                break;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 1732890,
                "title": "easy-to-understand-c",
                "content": "\\n\\n\\nclass Solution {\\npublic:\\n\\n    unordered_map<int,int>mp;\\n    string fractionToDecimal(long num, long d) {\\n        long e1=num; long e2=d;\\n         num=abs(num); d=abs(d);// Here I am converting to positive numbers bcz I will face with modulo operator later\\n        mp={};\\n        int n=1e4; string ans;\\n          if((e1<0&&e2>0)||(e1>0&&e2<0))  ans=\\'-\\'+ans;\\n            long p=num/d; num=num%d;              \\n         ans+=to_string(p);\\n        if(num==0) return ans;\\n       ans+=\\'.\\';\\n        int r=0;         \\n        int u=ans.size();\\n        while(n--&&num){\\n            int z=0;\\n            num=num*10;\\n            int t=num/d;          \\n\\n            if(mp[num]==0)mp[num]=u;\\n            else {r=mp[num];break;}\\n                 u++;\\n            ans+=(t+\\'0\\');    num=num%d;        \\n        }\\n        if(r){\\n            ans.insert(ans.begin()+r,\\'(\\');\\n            ans.push_back(\\')\\');\\n        }           \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Math",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n\\n    unordered_map<int,int>mp;\\n    string fractionToDecimal(long num, long d) {\\n        long e1=num; long e2=d;\\n         num=abs(num); d=abs(d);// Here I am converting to positive numbers bcz I will face with modulo operator later\\n        mp={}",
                "codeTag": "Java"
            },
            {
                "id": 1722894,
                "title": "c-unordered-map-easy",
                "content": "```\\nstring fractionToDecimal(int numerator, int denominator) \\n    {\\n        string res=\"\";\\n        if(numerator==0)\\n            return \"0\";\\n        if(numerator>0^denominator>0)\\n            res+=\\'-\\';\\n        long num=abs(numerator);\\n        long den=abs(denominator);\\n        unordered_map<long, int> mp;\\n        \\n        res+=to_string(num/den);\\n        if(num%den==0)\\n            return res;\\n        res+=\\'.\\';\\n        \\n        long rem=num%den;\\n        \\n        while(rem)\\n        {\\n            if(mp.find(rem)!=mp.end())\\n            {\\n                res.insert(mp[rem], \"(\");\\n                res+=\\')\\';\\n                break;\\n            }\\n            \\n            mp[rem]=res.size();\\n            rem*=10;\\n            res+=to_string(rem/den);\\n            rem%=den;\\n        }\\n        \\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring fractionToDecimal(int numerator, int denominator) \\n    {\\n        string res=\"\";\\n        if(numerator==0)\\n            return \"0\";\\n        if(numerator>0^denominator>0)\\n            res+=\\'-\\';\\n        long num=abs(numerator);\\n        long den=abs(denominator);\\n        unordered_map<long, int> mp;\\n        \\n        res+=to_string(num/den);\\n        if(num%den==0)\\n            return res;\\n        res+=\\'.\\';\\n        \\n        long rem=num%den;\\n        \\n        while(rem)\\n        {\\n            if(mp.find(rem)!=mp.end())\\n            {\\n                res.insert(mp[rem], \"(\");\\n                res+=\\')\\';\\n                break;\\n            }\\n            \\n            mp[rem]=res.size();\\n            rem*=10;\\n            res+=to_string(rem/den);\\n            rem%=den;\\n        }\\n        \\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1694135,
                "title": "unordered-map-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        unordered_map<long, int> mp;\\n        \\n        if(numerator == 0) return \"0\";\\n        string ans = (numerator < 0) ^ (denominator < 0)? \"-\": \"\";\\n        \\n        long n = abs(numerator);\\n        long d = abs(denominator);\\n        \\n        ans += to_string(n/d);\\n        n %= d;\\n        \\n        if(n){\\n            ans += \".\";\\n            while(n and mp.find(n) == mp.end()){\\n                mp[n] = ans.size();\\n                n = n*10;\\n                ans += to_string(n/d);\\n                n %= d;\\n            }\\n            if(n){\\n                ans = ans.substr(0,mp[n]) + \"(\" + ans.substr(mp[n]) + \")\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        unordered_map<long, int> mp;\\n        \\n        if(numerator == 0) return \"0\";\\n        string ans = (numerator < 0) ^ (denominator < 0)? \"-\": \"\";\\n        \\n        long n = abs(numerator);\\n        long d = abs(denominator);\\n        \\n        ans += to_string(n/d);\\n        n %= d;\\n        \\n        if(n){\\n            ans += \".\";\\n            while(n and mp.find(n) == mp.end()){\\n                mp[n] = ans.size();\\n                n = n*10;\\n                ans += to_string(n/d);\\n                n %= d;\\n            }\\n            if(n){\\n                ans = ans.substr(0,mp[n]) + \"(\" + ans.substr(mp[n]) + \")\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690553,
                "title": "two-python-solutions-using-either-dictionary-get-or-list-index-in-try-except",
                "content": "Both of these solutions run in about the same amount of time, but with multiple submissions it appears the dictionary method is faster (fastest run was 28 ms), while the list method consistently uses less memory (14.2 MB vs 14.6 for the dict method). This makes sense since the dict has to store twice as much data (keys and values).\\nThe try/except block for the list will be a little slower, although I think that dict.get uses a try/except internally to return None when the key isn\\'t found.\\n\\nBoth solutions are using the same algorithm for long division.  A modulo operation is run to get the remainder, while int division (//) is used to get the next digit of the quotient.  Multiply the remainder by 10 for the next pass. We track all of the remainders we have seen in a dictionary or list. \\n  If the remainder ever equals 0, then the decimal is non repeating and we have finished division.\\n  If the remainder is one we have seen before, than the decimal is starting to repeat, and we can stop division after constructing the repeating portion, and also extracting any non-repeating leading portion.\\n  \\nSome key test cases to run in your testing:\\nnumerator = 0, denominator < 0  (I failed this edge case once, with output \\'-0\\')\\nnumerator = 1 denominator = 6 (or 12).  Repeating decimals, but the first few digits don\\'t repeat.\\nnumerator = 1, denominator = 9967.  Repeating decimal with 9966 digits in the repeating portion.\\n### Solution using List.index with Try/Except:\\n```python\\n  class Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\n        sign = True  # True == output is POSITIVE\\n        \\n        # Handle edge case of 0, and check for final negative sign.\\n        if numerator == 0:\\n            return \"0\"\\n        elif numerator < 0:\\n            numerator = -numerator\\n            sign = not sign\\n        if denominator < 0:\\n            denominator = -denominator\\n            sign = not sign\\n        \\n        # Get the whole number part of the quotient, and the initial remainder\\n        remainder = numerator % denominator\\n        quot = numerator // denominator\\n        \\n        # Initialize the output string\\n        ans = \\'\\' if sign else \\'-\\'\\n        ans += str(quot) + (\\'.\\' if remainder else \\'\\')\\n        \\n        # Use a list to track remainders we have seen\\n        seen_remainders = [remainder]\\n        decimal = \\'\\'   # Constructed string of the decimal portion\\n        \\n        while remainder > 0:\\n            remainder *= 10   # Carry down a 0\\n            quot = remainder // denominator   \\n            decimal += str(quot)\\n            remainder %= denominator  # Get the new remainder\\n            \\n            # Check if we have seen this remainder before\\n            try:\\n                pattern_start = seen_remainders.index(remainder)\\n            except ValueError:\\n                # If not, add it to remainders we have seen\\n                seen_remainders.append(remainder)\\n            else:\\n                # If we have seen the remainder before, we can construct the answer string\\n                # decimal[:pattern_start] is the non-repeating part of the decimal\\n                # decimal[pattern_start:] is the repeating portion\\n                ans += decimal[:pattern_start] + \\'(\\' + decimal[pattern_start:]+ \\')\\'\\n                break\\n            \\n            # If the remainder is 0, division is complete, and there was no repeating decimal.\\n            if remainder == 0:\\n                ans += decimal\\n        \\n        return ans\\n```\\n\\n### Solution using a dictionary to track remainders seen\\n```python\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\n        sign = True  # True == output is POSITIVE\\n        \\n        # Handle edge case of 0, and check for final negative sign.\\n        if numerator == 0:\\n            return \"0\"\\n        elif numerator < 0:\\n            numerator = -numerator\\n            sign = not sign\\n        if denominator < 0:\\n            denominator = -denominator\\n            sign = not sign\\n        \\n        # Get the whole number part of the quotient, and the initial remainder\\n        remainder = numerator % denominator\\n        quot = numerator // denominator\\n        \\n        # Initialize the output string\\n        ans = \\'\\' if sign else \\'-\\'\\n        ans += str(quot) + (\\'.\\' if remainder else \\'\\')\\n        \\n        # Use a dict to track remainders we have seen, where\\n        # key = remainder, value = index in the string decimal where remainder was seen.\\n        seen_remainders = {}\\n        idx = 0\\n        seen_remainders[remainder] = idx\\n        decimal = \\'\\' # Constructed string of the decimal portion\\n        \\n        while remainder > 0:\\n            remainder *= 10   # Carry down a 0\\n            quot = remainder // denominator   \\n            decimal += str(quot)\\n            remainder %= denominator  # Get the new remainder\\n            idx += 1  # Increment the tracking index for the dictionary\\n            \\n            # Use dict.get to check our our remainder has already been seen\\n            pattern_start = seen_remainders.get(remainder)\\n            \\n            if pattern_start is None:\\n                # If not, add it to remainders we have seen\\n                seen_remainders[remainder] = idx\\n            else:\\n                # If we have seen the remainder before, we can construct the answer string\\n                # decimal[:pattern_start] is the non-repeating part of the decimal\\n                # decimal[pattern_start:] is the repeating portion\\n                ans += decimal[:pattern_start] + \\'(\\' + decimal[pattern_start:]+ \\')\\'\\n                break\\n            \\n            # If the remainder is 0, division is complete, and there was no repeating decimal.\\n            if remainder == 0:\\n                ans += decimal\\n        \\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n  class Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\n        sign = True  # True == output is POSITIVE\\n        \\n        # Handle edge case of 0, and check for final negative sign.\\n        if numerator == 0:\\n            return \"0\"\\n        elif numerator < 0:\\n            numerator = -numerator\\n            sign = not sign\\n        if denominator < 0:\\n            denominator = -denominator\\n            sign = not sign\\n        \\n        # Get the whole number part of the quotient, and the initial remainder\\n        remainder = numerator % denominator\\n        quot = numerator // denominator\\n        \\n        # Initialize the output string\\n        ans = \\'\\' if sign else \\'-\\'\\n        ans += str(quot) + (\\'.\\' if remainder else \\'\\')\\n        \\n        # Use a list to track remainders we have seen\\n        seen_remainders = [remainder]\\n        decimal = \\'\\'   # Constructed string of the decimal portion\\n        \\n        while remainder > 0:\\n            remainder *= 10   # Carry down a 0\\n            quot = remainder // denominator   \\n            decimal += str(quot)\\n            remainder %= denominator  # Get the new remainder\\n            \\n            # Check if we have seen this remainder before\\n            try:\\n                pattern_start = seen_remainders.index(remainder)\\n            except ValueError:\\n                # If not, add it to remainders we have seen\\n                seen_remainders.append(remainder)\\n            else:\\n                # If we have seen the remainder before, we can construct the answer string\\n                # decimal[:pattern_start] is the non-repeating part of the decimal\\n                # decimal[pattern_start:] is the repeating portion\\n                ans += decimal[:pattern_start] + \\'(\\' + decimal[pattern_start:]+ \\')\\'\\n                break\\n            \\n            # If the remainder is 0, division is complete, and there was no repeating decimal.\\n            if remainder == 0:\\n                ans += decimal\\n        \\n        return ans\\n```\n```python\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\n        sign = True  # True == output is POSITIVE\\n        \\n        # Handle edge case of 0, and check for final negative sign.\\n        if numerator == 0:\\n            return \"0\"\\n        elif numerator < 0:\\n            numerator = -numerator\\n            sign = not sign\\n        if denominator < 0:\\n            denominator = -denominator\\n            sign = not sign\\n        \\n        # Get the whole number part of the quotient, and the initial remainder\\n        remainder = numerator % denominator\\n        quot = numerator // denominator\\n        \\n        # Initialize the output string\\n        ans = \\'\\' if sign else \\'-\\'\\n        ans += str(quot) + (\\'.\\' if remainder else \\'\\')\\n        \\n        # Use a dict to track remainders we have seen, where\\n        # key = remainder, value = index in the string decimal where remainder was seen.\\n        seen_remainders = {}\\n        idx = 0\\n        seen_remainders[remainder] = idx\\n        decimal = \\'\\' # Constructed string of the decimal portion\\n        \\n        while remainder > 0:\\n            remainder *= 10   # Carry down a 0\\n            quot = remainder // denominator   \\n            decimal += str(quot)\\n            remainder %= denominator  # Get the new remainder\\n            idx += 1  # Increment the tracking index for the dictionary\\n            \\n            # Use dict.get to check our our remainder has already been seen\\n            pattern_start = seen_remainders.get(remainder)\\n            \\n            if pattern_start is None:\\n                # If not, add it to remainders we have seen\\n                seen_remainders[remainder] = idx\\n            else:\\n                # If we have seen the remainder before, we can construct the answer string\\n                # decimal[:pattern_start] is the non-repeating part of the decimal\\n                # decimal[pattern_start:] is the repeating portion\\n                ans += decimal[:pattern_start] + \\'(\\' + decimal[pattern_start:]+ \\')\\'\\n                break\\n            \\n            # If the remainder is 0, division is complete, and there was no repeating decimal.\\n            if remainder == 0:\\n                ans += decimal\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630639,
                "title": "easy-fast-c-solution",
                "content": "\\t\\tstring ans;\\n        long n, d, r;\\n        unorderedmap<long, int> m;\\n        long q;\\n        \\n        if(numerator ==0) return \"0\"; // for n/m = 0/m\\n        if(numerator<0 ^ denominator<0) ans +=\\'-\\'; // for -n/m or n/-m\\n        n = labs((long)numerator);\\n        d = labs((long)denominator);\\n        ans += tostring(n/d);\\n        r = n % d;\\n        if(r == 0) return ans; // absolute value with no remainder\\n        ans += \".\";\\n        r = 10;\\n        while(r){\\n            q = r / d;\\n            if(m.count(r)){\\n                ans.insert(m[r],1,\\'(\\');\\n                ans += \\')\\';\\n                return ans;\\n            }\\n            m[r] = ans.size();\\n            ans += tostring(q);\\n            r = (r%d) 10;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\t\\tstring ans;\\n        long n, d, r;\\n        unorderedmap<long, int> m;\\n        long q;\\n        \\n        if(numerator ==0) return \"0\"; // for n/m = 0/m\\n        if(numerator<0 ^ denominator<0) ans +=\\'-\\'; // for -n/m or n/-m\\n        n = labs((long)numerator);\\n        d = labs((long)denominator);\\n        ans += tostring(n/d);\\n        r = n % d;\\n        if(r == 0) return ans; // absolute value with no remainder\\n        ans += \".\";\\n        r = 10;\\n        while(r){\\n            q = r / d;\\n            if(m.count(r)){\\n                ans.insert(m[r],1,\\'(\\');\\n                ans += \\')\\';\\n                return ans;\\n            }\\n            m[r] = ans.size();\\n            ans += tostring(q);\\n            r = (r%d) 10;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1605510,
                "title": "go-solution-faster-than-100",
                "content": "```\\nfunc fractionToDecimal(numerator int, denominator int) string {\\n res := \"\"\\n\\tif numerator == 0 {\\n\\t\\treturn \"0\"\\n\\t}\\n\\tif numerator < 0 && denominator < 0 {\\n\\t\\tnumerator = -numerator\\n\\t\\tdenominator = -denominator\\n\\t}\\n\\tif numerator < 0 {\\n\\t\\tres += \"-\"\\n\\t\\tnumerator = -numerator\\n\\t}\\n\\tif denominator < 0 {\\n\\t\\tres += \"-\"\\n\\t\\tdenominator = -denominator\\n\\t}\\n\\tres += strconv.Itoa(numerator / denominator)\\n\\tnumerator = numerator % denominator\\n\\tif numerator == 0 {\\n\\t\\treturn res\\n\\t}\\n\\tres += \".\"\\n\\tm := map[int]int{}\\n\\tfor numerator != 0 {\\n\\t\\tif i, ok := m[numerator]; ok {\\n\\t\\t\\tres = res[:i] + \"(\" + res[i:] + \")\"\\n\\t\\t\\treturn res\\n\\t\\t}\\n\\t\\tm[numerator] = len(res)\\n\\t\\tnumerator *= 10\\n\\t\\tres += strconv.Itoa(numerator / denominator)\\n\\t\\tnumerator = numerator % denominator\\n\\t}\\n\\treturn res\\n}\\n",
                "solutionTags": [],
                "code": "```\\nfunc fractionToDecimal(numerator int, denominator int) string {\\n res := \"\"\\n\\tif numerator == 0 {\\n\\t\\treturn \"0\"\\n\\t}\\n\\tif numerator < 0 && denominator < 0 {\\n\\t\\tnumerator = -numerator\\n\\t\\tdenominator = -denominator\\n\\t}\\n\\tif numerator < 0 {\\n\\t\\tres += \"-\"\\n\\t\\tnumerator = -numerator\\n\\t}\\n\\tif denominator < 0 {\\n\\t\\tres += \"-\"\\n\\t\\tdenominator = -denominator\\n\\t}\\n\\tres += strconv.Itoa(numerator / denominator)\\n\\tnumerator = numerator % denominator\\n\\tif numerator == 0 {\\n\\t\\treturn res\\n\\t}\\n\\tres += \".\"\\n\\tm := map[int]int{}\\n\\tfor numerator != 0 {\\n\\t\\tif i, ok := m[numerator]; ok {\\n\\t\\t\\tres = res[:i] + \"(\" + res[i:] + \")\"\\n\\t\\t\\treturn res\\n\\t\\t}\\n\\t\\tm[numerator] = len(res)\\n\\t\\tnumerator *= 10\\n\\t\\tres += strconv.Itoa(numerator / denominator)\\n\\t\\tnumerator = numerator % denominator\\n\\t}\\n\\treturn res\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1584325,
                "title": "straightforward-java-solution-w-explanation",
                "content": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) return \"0\";\\n        StringBuilder sb = new StringBuilder();\\n        String sign = (numerator < 0 && denominator < 0 || numerator >= 0 && denominator >= 0) ? \"\" : \"-\";\\n        long n = Math.abs(Long.valueOf(numerator));\\n        long d = Math.abs(Long.valueOf(denominator));\\n        sb.append(sign);\\n        // integral part\\n        sb.append(n / d);\\n        if (n % d == 0) return sb.toString();\\n        sb.append(\".\");\\n        // fractional part\\n        // keeps track of seen numerators and the length of sb\\n        Map<Long, Integer> m = new HashMap<>();\\n        while (n % d != 0) {\\n            n %= d;\\n            if (m.containsKey(n)) {\\n                // found a cycle\\n                sb.insert(m.get(n), \"(\");\\n                sb.append(\")\");\\n                return sb.toString();\\n            }\\n            m.put(n, sb.length());\\n            n *= 10;\\n            sb.append(n / d);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) return \"0\";\\n        StringBuilder sb = new StringBuilder();\\n        String sign = (numerator < 0 && denominator < 0 || numerator >= 0 && denominator >= 0) ? \"\" : \"-\";\\n        long n = Math.abs(Long.valueOf(numerator));\\n        long d = Math.abs(Long.valueOf(denominator));\\n        sb.append(sign);\\n        // integral part\\n        sb.append(n / d);\\n        if (n % d == 0) return sb.toString();\\n        sb.append(\".\");\\n        // fractional part\\n        // keeps track of seen numerators and the length of sb\\n        Map<Long, Integer> m = new HashMap<>();\\n        while (n % d != 0) {\\n            n %= d;\\n            if (m.containsKey(n)) {\\n                // found a cycle\\n                sb.insert(m.get(n), \"(\");\\n                sb.append(\")\");\\n                return sb.toString();\\n            }\\n            m.put(n, sb.length());\\n            n *= 10;\\n            sb.append(n / d);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584088,
                "title": "java-solution-explanation",
                "content": "**Idea:**\\n1. In order to have a recurring decimal, 2 conditions MUST satisfy\\n\\t1. remainders MUST match\\n\\t2. the quotient digit where remainders are same MUST also match\\n2. We store the indexes of remainders in a `Map` \\n3. Wenever we find a repeating remainder, \\nwe check whether the quotients are also matching or not. \\nTo find the quotient digit, `ans[map[remainder]]`, where ans is our fraction part\\n4. Also, we need to deal with -ve numbers, so we do\\n\\t1. Widening Conversion (int -> long)\\n\\t2. explicitly check whether if exactly one input is -ve or not. \\n\\tIf yes, then `ans` will also be -ve\\n\\nBelow is the implementation of above approach\\n\\n\\n\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public String fractionToDecimal(int num, int den) {\\n\\n        String ans = \"\";\\n        \\n        // widening conversion to handle INT_MIN/INT_MAX\\n        long numerator = num; \\n        long denominator = den;\\n\\n        // ans will be -ve; if exactly one is -ve\\n        if ((numerator < 0 && denominator > 0) || (numerator > 0 && denominator < 0)) {\\n            ans += \"-\";\\n        }\\n\\n        numerator = Math.abs(numerator);\\n        denominator = Math.abs(denominator);\\n        \\n        // does not have fraction part\\n        if (numerator % denominator == 0) {\\n            return ans + (numerator / denominator);\\n        }\\n\\n        long quotient = numerator / denominator;\\n        long remainder = numerator % denominator;\\n\\n        // real part\\n        ans += quotient + \".\";\\n\\n        ans += findFractionPart(remainder * 10, denominator);\\n\\n        return ans;\\n    }\\n\\n    String findFractionPart(long numerator, long denominator) {\\n\\n        StringBuilder ans = new StringBuilder();\\n        Map<Long, Integer> remIdx = new HashMap<>(); // holds indexes of remainders\\n        int idx = 0;\\n\\n        while (true) {\\n\\n            long quotient = numerator / denominator;\\n            long remainder = numerator % denominator;\\n\\n            if (remainder == 0) { // no recurring part present\\n                ans.append(quotient);\\n                break;\\n            }\\n\\n            \\n            /*\\n                in order to have a recurring decimal, 2 conditions must satisfy\\n                1. remainder is repeating\\n                2. the quotients of repeating remainder positions MUST also match  \\n            */\\n            \\n            if (remIdx.containsKey(remainder) && \\n                ans.charAt(remIdx.get(remainder)) == (quotient + \\'0\\')) { // same quotient\\n                \\n                // found recurring\\n                ans.insert(remIdx.get(remainder), \"(\");\\n                ans.append(\")\");\\n                break;\\n            } else {\\n\\t\\t\\t\\t// no recurring\\n                ans.append(quotient);\\n                remIdx.put(remainder, idx);\\n            }\\n\\n            // continue checking for next iteration\\n            idx++;\\n            numerator = remainder * 10;\\n\\n        }\\n\\n        return ans.toString();\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public String fractionToDecimal(int num, int den) {\\n\\n        String ans = \"\";\\n        \\n        // widening conversion to handle INT_MIN/INT_MAX\\n        long numerator = num; \\n        long denominator = den;\\n\\n        // ans will be -ve; if exactly one is -ve\\n        if ((numerator < 0 && denominator > 0) || (numerator > 0 && denominator < 0)) {\\n            ans += \"-\";\\n        }\\n\\n        numerator = Math.abs(numerator);\\n        denominator = Math.abs(denominator);\\n        \\n        // does not have fraction part\\n        if (numerator % denominator == 0) {\\n            return ans + (numerator / denominator);\\n        }\\n\\n        long quotient = numerator / denominator;\\n        long remainder = numerator % denominator;\\n\\n        // real part\\n        ans += quotient + \".\";\\n\\n        ans += findFractionPart(remainder * 10, denominator);\\n\\n        return ans;\\n    }\\n\\n    String findFractionPart(long numerator, long denominator) {\\n\\n        StringBuilder ans = new StringBuilder();\\n        Map<Long, Integer> remIdx = new HashMap<>(); // holds indexes of remainders\\n        int idx = 0;\\n\\n        while (true) {\\n\\n            long quotient = numerator / denominator;\\n            long remainder = numerator % denominator;\\n\\n            if (remainder == 0) { // no recurring part present\\n                ans.append(quotient);\\n                break;\\n            }\\n\\n            \\n            /*\\n                in order to have a recurring decimal, 2 conditions must satisfy\\n                1. remainder is repeating\\n                2. the quotients of repeating remainder positions MUST also match  \\n            */\\n            \\n            if (remIdx.containsKey(remainder) && \\n                ans.charAt(remIdx.get(remainder)) == (quotient + \\'0\\')) { // same quotient\\n                \\n                // found recurring\\n                ans.insert(remIdx.get(remainder), \"(\");\\n                ans.append(\")\");\\n                break;\\n            } else {\\n\\t\\t\\t\\t// no recurring\\n                ans.append(quotient);\\n                remIdx.put(remainder, idx);\\n            }\\n\\n            // continue checking for next iteration\\n            idx++;\\n            numerator = remainder * 10;\\n\\n        }\\n\\n        return ans.toString();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562827,
                "title": "short-python-with-line-by-line-explanation-faster-than-100",
                "content": "The idea is to just follow what you would do by hand.\\n\\n* Keep dividing and take the remainder * 10 to be the new dividend.\\n* If remainder is 0, the decimal terminates, i.e., no repeating pattern.\\n* If remainder has already been encountered before, the decimal repeats from there.\\n\\n\\n```python\\n# One corner case.\\nif numerator == 0:\\n\\treturn \\'0\\'\\n\\n# Sign character is either \\'\\' (positive) or \\'-\\' (negative)\\nsign = \\'\\' if numerator * denominator > 0 else \\'-\\'\\n\\n# Sign is now taken care of, no need to worry about signs anymore.\\nn, d = abs(numerator), abs(denominator)\\n\\n# Prepare result string (to be returned).\\ninteger, remainder = divmod(n, d)  # n // d, n % d\\nresult = sign + str(integer) + (\\'.\\' if remainder else \\'\\')\\n\\n# Save remainder and its corresponding position to this dict:\\nr2p = {}  # remainder -> position in result string.\\n\\n# Stop when either remainder == 0 or remainder existed in r2p\\nwhile remainder and remainder not in r2p:\\n\\tr2p[remainder] = len(result)  # remainder position is just current length\\n\\tdigit, remainder = divmod(remainder * 10, d)\\n\\tresult += str(digit)  # add the digit to result string.\\n\\nif remainder == 0:  # i.e. no repeating decimals.\\n\\treturn result\\n\\np = r2p[remainder]  # the point at which decimal starts repeating.\\nreturn result[:p] + \\'(\\' + result[p:] + \\')\\'  # add parenthesis around it.\\n```",
                "solutionTags": [],
                "code": "```python\\n# One corner case.\\nif numerator == 0:\\n\\treturn \\'0\\'\\n\\n# Sign character is either \\'\\' (positive) or \\'-\\' (negative)\\nsign = \\'\\' if numerator * denominator > 0 else \\'-\\'\\n\\n# Sign is now taken care of, no need to worry about signs anymore.\\nn, d = abs(numerator), abs(denominator)\\n\\n# Prepare result string (to be returned).\\ninteger, remainder = divmod(n, d)  # n // d, n % d\\nresult = sign + str(integer) + (\\'.\\' if remainder else \\'\\')\\n\\n# Save remainder and its corresponding position to this dict:\\nr2p = {}  # remainder -> position in result string.\\n\\n# Stop when either remainder == 0 or remainder existed in r2p\\nwhile remainder and remainder not in r2p:\\n\\tr2p[remainder] = len(result)  # remainder position is just current length\\n\\tdigit, remainder = divmod(remainder * 10, d)\\n\\tresult += str(digit)  # add the digit to result string.\\n\\nif remainder == 0:  # i.e. no repeating decimals.\\n\\treturn result\\n\\np = r2p[remainder]  # the point at which decimal starts repeating.\\nreturn result[:p] + \\'(\\' + result[p:] + \\')\\'  # add parenthesis around it.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1525698,
                "title": "using-hashmap-easy-to-understand-commented-solution-100-faster-c",
                "content": "```\\nclass Solution {\\n    \\n    void ComputeAfterDecimal(long num , long den , string &res){\\n        unordered_map<long , long>history;\\n        long q , r;\\n        \\n        while(num){\\n            q = num/den;\\n            r = num%den;\\n            \\n            //i have seen q for first time\\n            if(history.find(num) == history.end()){\\n                history[num] = res.size();\\n                res+=to_string(q);\\n                num =r*10;\\n            }\\n            //found a recurring event\\n            else{\\n                //insert brackets\\n                res = res.substr(0 , history[num]) + \"(\" + res.substr(history[num] ,res.size() -history[num] ) + \")\";\\n                break;\\n            }\\n        }\\n    }\\n    \\n    \\n    \\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator == 0) return \"0\";\\n        \\n        string res = \"\";\\n        //for negative numbers division\\n        if(( numerator >0 && denominator < 0) || (numerator <0 && denominator > 0) )\\n            res +=\"-\";\\n        \\n        //absolute divison\\n        long num = (long)abs(numerator);\\n        long den = (long)abs(denominator);\\n        \\n        //part before decimal point\\n        long q = num/den;\\n        long rem = num % den;\\n        \\n        res+=to_string(q);\\n        \\n        if(rem == 0)\\n            return res;\\n        \\n        //non-zero remainder which means i need a decimal point\\n        res+=\".\";\\n        \\n        ComputeAfterDecimal(rem*10 , den , res);\\n        \\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    void ComputeAfterDecimal(long num , long den , string &res){\\n        unordered_map<long , long>history;\\n        long q , r;\\n        \\n        while(num){\\n            q = num/den;\\n            r = num%den;\\n            \\n            //i have seen q for first time\\n            if(history.find(num) == history.end()){\\n                history[num] = res.size();\\n                res+=to_string(q);\\n                num =r*10;\\n            }\\n            //found a recurring event\\n            else{\\n                //insert brackets\\n                res = res.substr(0 , history[num]) + \"(\" + res.substr(history[num] ,res.size() -history[num] ) + \")\";\\n                break;\\n            }\\n        }\\n    }\\n    \\n    \\n    \\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator == 0) return \"0\";\\n        \\n        string res = \"\";\\n        //for negative numbers division\\n        if(( numerator >0 && denominator < 0) || (numerator <0 && denominator > 0) )\\n            res +=\"-\";\\n        \\n        //absolute divison\\n        long num = (long)abs(numerator);\\n        long den = (long)abs(denominator);\\n        \\n        //part before decimal point\\n        long q = num/den;\\n        long rem = num % den;\\n        \\n        res+=to_string(q);\\n        \\n        if(rem == 0)\\n            return res;\\n        \\n        //non-zero remainder which means i need a decimal point\\n        res+=\".\";\\n        \\n        ComputeAfterDecimal(rem*10 , den , res);\\n        \\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523395,
                "title": "c-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator2, int denominator2) {\\n        if(!numerator2)\\n            return \"0\";\\n        string ans = (numerator2 < 0) ^ (denominator2 < 0)? \"-\": \"\", tmp = \"\";\\n        long long numerator = labs(numerator2);\\n        long long denominator = labs(denominator2);\\n        ans += to_string(numerator / denominator);\\n        numerator %= denominator;\\n        if(numerator){\\n            ans += \\'.\\';\\n            unordered_map<int, int> mp;\\n            while(numerator && mp.find(numerator) == mp.end()){\\n                mp[numerator] = tmp.size();\\n                numerator *= 10;\\n                tmp += to_string(numerator / denominator);\\n                numerator %= denominator;\\n            }\\n            //has loop, handle speically\\n            if(numerator)\\n                tmp = tmp.substr(0, mp[numerator]) + \"(\" + tmp.substr(mp[numerator]) + \")\";\\n        }\\n        return ans + tmp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator2, int denominator2) {\\n        if(!numerator2)\\n            return \"0\";\\n        string ans = (numerator2 < 0) ^ (denominator2 < 0)? \"-\": \"\", tmp = \"\";\\n        long long numerator = labs(numerator2);\\n        long long denominator = labs(denominator2);\\n        ans += to_string(numerator / denominator);\\n        numerator %= denominator;\\n        if(numerator){\\n            ans += \\'.\\';\\n            unordered_map<int, int> mp;\\n            while(numerator && mp.find(numerator) == mp.end()){\\n                mp[numerator] = tmp.size();\\n                numerator *= 10;\\n                tmp += to_string(numerator / denominator);\\n                numerator %= denominator;\\n            }\\n            //has loop, handle speically\\n            if(numerator)\\n                tmp = tmp.substr(0, mp[numerator]) + \"(\" + tmp.substr(mp[numerator]) + \")\";\\n        }\\n        return ans + tmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498058,
                "title": "c-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator==0) return \"0\";\\n        bool numNegative=0, denNegative=0;\\n        long long int num=long(numerator), den=long(denominator);\\n        string ans=\"\";\\n        if(numerator<0) {\\n            numNegative=1;\\n            num=-num;\\n        }\\n        if(denominator<0){\\n            denNegative=1;\\n            den=-den;\\n        }\\n        long long int q=num/den;\\n        long long int r=num%den;\\n        ans+=to_string(q);\\n        if(r==0) ans=ans;\\n        else{\\n            ans+=\".\";\\n            unordered_map<long long int, long long int> mp;\\n            while(r){\\n                if(mp.find(r)!=mp.end()){\\n                    long long int len=mp[r];\\n                    ans.insert(len, \"(\");\\n                    ans+=\")\";\\n                    break;\\n                }\\n                else{\\n                    mp[r]=ans.size();\\n                    r*=10;\\n                    q=r/den;\\n                    r=r%den;\\n                    ans+=to_string(q);\\n                }\\n            }\\n        }\\n        if(numNegative && denNegative) ans=ans;\\n        else if(numNegative || denNegative) ans.insert(0,\"-\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator==0) return \"0\";\\n        bool numNegative=0, denNegative=0;\\n        long long int num=long(numerator), den=long(denominator);\\n        string ans=\"\";\\n        if(numerator<0) {\\n            numNegative=1;\\n            num=-num;\\n        }\\n        if(denominator<0){\\n            denNegative=1;\\n            den=-den;\\n        }\\n        long long int q=num/den;\\n        long long int r=num%den;\\n        ans+=to_string(q);\\n        if(r==0) ans=ans;\\n        else{\\n            ans+=\".\";\\n            unordered_map<long long int, long long int> mp;\\n            while(r){\\n                if(mp.find(r)!=mp.end()){\\n                    long long int len=mp[r];\\n                    ans.insert(len, \"(\");\\n                    ans+=\")\";\\n                    break;\\n                }\\n                else{\\n                    mp[r]=ans.size();\\n                    r*=10;\\n                    q=r/den;\\n                    r=r%den;\\n                    ans+=to_string(q);\\n                }\\n            }\\n        }\\n        if(numNegative && denNegative) ans=ans;\\n        else if(numNegative || denNegative) ans.insert(0,\"-\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1479774,
                "title": "c-solution",
                "content": "```\\nlong abs1(long a){\\n    return a < 0 ? -a : a;\\n}\\n\\nlong repIndex(long* arr, long len, long num){\\n    for(int i = 0; i < len; i++){\\n        if(arr[i] == num)\\n            return i;\\n    }\\n    return -1;\\n}\\n\\nint length(int num){\\n    int len = num == 0 ? 1 : 0;\\n    while(num != 0){\\n        num /= 10;\\n        len ++;\\n    }\\n    return len;\\n}\\n\\nchar * fractionToDecimal(int numerator, int denominator){   //Assume: 1  6  Result: 0.1(6)\\n    long num = numerator, den = denominator;                //cast to long                    \\n    long integer = num / den;  //0\\n    \\n    int sign = 0;\\n    int iLen = length(integer);                             //1\\n    \\n    // Set positive for all\\n    if((long)num * den < 0){\\n        sign = 1;\\n        integer = -integer;\\n        num = abs1(num);\\n        den = abs1(den);\\n    }\\n    \\n//=========================================================================================\\n    bool repeat = 0;\\n    int fLen = 0, index = -1;                               //fLen: Fraction length, index: repeat at index (0.16666 -> index = 1)\\n    if(num % den){                                          //mod is not 0\\n        fLen ++;                                            //if mod is not 0, it has dot.\\n        int maxUnrepeated = length(den) + 1 /*2*/, realUnrepeated = 0;\\n        long *mods = malloc(maxUnrepeated * sizeof(long));  //Store unrepeated mods * 10. In the case of 1/6, it would be 1 * 10 and 4 * 10.\\n        long n = num % den * 10;                            //0.16666 -> n = 10\\n        do{\\n            if(realUnrepeated < maxUnrepeated){\\n                mods[realUnrepeated] = n;\\n                realUnrepeated ++;\\n            }\\n            fLen ++;\\n            n = n % den * 10;\\n            index = repIndex(mods, realUnrepeated, n);      //0.16666 -> index = 1\\n            if(index != -1){                                //if index != -1, n is found in mods[] \\n                repeat = 1;\\n                fLen += 2;                                  //()\\n                break;\\n            }\\n        }while(n);\\n    }\\n//=========================================================================================\\n    int len = sign + iLen + fLen;                           //0.1(6) -> 0 + 1 + 5\\n    char* r = malloc((len + 1) * sizeof(char)), *p = r;\\n\\n    //copy sign\\n    if(sign) *p++ = \\'-\\';\\n    \\n    //copy integer\\n    for(int i = iLen - 1; i >= 0; i--){\\n        p[i] = (integer % 10) + \\'0\\';\\n        integer /= 10;\\n    }\\n    \\n    if(fLen){\\n        p += iLen;                                         //move the pointer to the fractional part\\n        *p++ = \\'.\\';\\n    }\\n\\n    if(repeat){\\n        p[index] = \\'(\\';\\n        r[len - 1] = \\')\\';\\n        fLen -= 3;\\n    }\\n    \\n    //copy fraction\\n    long n = num, mod;\\n    for(int i = 0; i < fLen; i++){\\n        mod = n % den; //4\\n        n = mod * 10;\\n        if(p[i]==\\'(\\')p++;\\n        p[i] = n / den + \\'0\\';\\n    }\\n    \\n    r[len] = \\'\\\\0\\';\\n    return r;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong abs1(long a){\\n    return a < 0 ? -a : a;\\n}\\n\\nlong repIndex(long* arr, long len, long num){\\n    for(int i = 0; i < len; i++){\\n        if(arr[i] == num)\\n            return i;\\n    }\\n    return -1;\\n}\\n\\nint length(int num){\\n    int len = num == 0 ? 1 : 0;\\n    while(num != 0){\\n        num /= 10;\\n        len ++;\\n    }\\n    return len;\\n}\\n\\nchar * fractionToDecimal(int numerator, int denominator){   //Assume: 1  6  Result: 0.1(6)\\n    long num = numerator, den = denominator;                //cast to long                    \\n    long integer = num / den;  //0\\n    \\n    int sign = 0;\\n    int iLen = length(integer);                             //1\\n    \\n    // Set positive for all\\n    if((long)num * den < 0){\\n        sign = 1;\\n        integer = -integer;\\n        num = abs1(num);\\n        den = abs1(den);\\n    }\\n    \\n//=========================================================================================\\n    bool repeat = 0;\\n    int fLen = 0, index = -1;                               //fLen: Fraction length, index: repeat at index (0.16666 -> index = 1)\\n    if(num % den){                                          //mod is not 0\\n        fLen ++;                                            //if mod is not 0, it has dot.\\n        int maxUnrepeated = length(den) + 1 /*2*/, realUnrepeated = 0;\\n        long *mods = malloc(maxUnrepeated * sizeof(long));  //Store unrepeated mods * 10. In the case of 1/6, it would be 1 * 10 and 4 * 10.\\n        long n = num % den * 10;                            //0.16666 -> n = 10\\n        do{\\n            if(realUnrepeated < maxUnrepeated){\\n                mods[realUnrepeated] = n;\\n                realUnrepeated ++;\\n            }\\n            fLen ++;\\n            n = n % den * 10;\\n            index = repIndex(mods, realUnrepeated, n);      //0.16666 -> index = 1\\n            if(index != -1){                                //if index != -1, n is found in mods[] \\n                repeat = 1;\\n                fLen += 2;                                  //()\\n                break;\\n            }\\n        }while(n);\\n    }\\n//=========================================================================================\\n    int len = sign + iLen + fLen;                           //0.1(6) -> 0 + 1 + 5\\n    char* r = malloc((len + 1) * sizeof(char)), *p = r;\\n\\n    //copy sign\\n    if(sign) *p++ = \\'-\\';\\n    \\n    //copy integer\\n    for(int i = iLen - 1; i >= 0; i--){\\n        p[i] = (integer % 10) + \\'0\\';\\n        integer /= 10;\\n    }\\n    \\n    if(fLen){\\n        p += iLen;                                         //move the pointer to the fractional part\\n        *p++ = \\'.\\';\\n    }\\n\\n    if(repeat){\\n        p[index] = \\'(\\';\\n        r[len - 1] = \\')\\';\\n        fLen -= 3;\\n    }\\n    \\n    //copy fraction\\n    long n = num, mod;\\n    for(int i = 0; i < fLen; i++){\\n        mod = n % den; //4\\n        n = mod * 10;\\n        if(p[i]==\\'(\\')p++;\\n        p[i] = n / den + \\'0\\';\\n    }\\n    \\n    r[len] = \\'\\\\0\\';\\n    return r;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1463059,
                "title": "easy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    string fractionToDecimal(int num, int den) {\\n        string res=\"\";\\n        bool isNeg=false;\\n        if((num>0&&den<0)||(num<0&&den>0)){\\n            isNeg=true;\\n        }\\n        ll n=(ll)abs(num);\\n        ll d=(ll)abs(den);\\n        if(n%d==0){\\n            res=to_string(n/d);\\n        }\\n        else{\\n            ll rem=n%d;\\n            res=to_string(n/d);\\n            res+=\".\";\\n            string temp=\"\";\\n            unordered_map<ll,string> mp;\\n            mp[rem]=\"\";\\n            while(rem!=0){\\n                rem=rem*10;\\n                if(rem<d){\\n                    temp+=\"0\";\\n                }\\n                else{\\n                    temp+=to_string(rem/d);\\n                    rem=rem%d;\\n                    if(mp.find(rem)!=mp.end()){\\n                        temp=mp[rem]+\"(\"+ temp.substr(mp[rem].size()) +\")\";\\n                        break;\\n                    }\\n                    else{\\n                        mp[rem]=temp;\\n                    }\\n                }\\n            }\\n            \\n            res=res+temp;\\n            \\n        }\\n        \\n        \\n        if(isNeg) return \"-\"+res;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    string fractionToDecimal(int num, int den) {\\n        string res=\"\";\\n        bool isNeg=false;\\n        if((num>0&&den<0)||(num<0&&den>0)){\\n            isNeg=true;\\n        }\\n        ll n=(ll)abs(num);\\n        ll d=(ll)abs(den);\\n        if(n%d==0){\\n            res=to_string(n/d);\\n        }\\n        else{\\n            ll rem=n%d;\\n            res=to_string(n/d);\\n            res+=\".\";\\n            string temp=\"\";\\n            unordered_map<ll,string> mp;\\n            mp[rem]=\"\";\\n            while(rem!=0){\\n                rem=rem*10;\\n                if(rem<d){\\n                    temp+=\"0\";\\n                }\\n                else{\\n                    temp+=to_string(rem/d);\\n                    rem=rem%d;\\n                    if(mp.find(rem)!=mp.end()){\\n                        temp=mp[rem]+\"(\"+ temp.substr(mp[rem].size()) +\")\";\\n                        break;\\n                    }\\n                    else{\\n                        mp[rem]=temp;\\n                    }\\n                }\\n            }\\n            \\n            res=res+temp;\\n            \\n        }\\n        \\n        \\n        if(isNeg) return \"-\"+res;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1413300,
                "title": "c-easy-to-understand-0ms-faster-than-100",
                "content": "```\\nstring fractionToDecimal(int numerator, int denominator) {\\n    long long int num = numerator;\\n    long long int den = denominator;\\n    if(num == 0)\\n        return \"0\";\\n    string res;\\n    int sign = 1;\\n    sign *= num > 0?1:-1;\\n    sign *= den >= 0 ? 1: -1;\\n    num = abs(num);\\n    den = abs(den);\\n    long long int quotient = num / den;\\n    num = num % den;\\n    if(num == 0)\\n        res += to_string(quotient);\\n    else\\n        res += to_string(quotient) + \".\";\\n    int every;\\n    vector<int> m_v;\\n    int x = res.size();\\n    int st = 0;\\n    while(num!=0){\\n        m_v.push_back(num);\\n        num *= 10;\\n        every = num / den;\\n        res += to_string(every);\\n        num %= den;\\n        auto it = std::find(m_v.begin(), m_v.end(), num);\\n        if(it != m_v.end()){\\n            st = it - m_v.begin() + x;\\n            res = res.substr(0, st) + \"(\" + res.substr(st) + \")\";\\n            break;\\n        }\\n    }\\n    if(sign == -1)\\n        res = \"-\" + res;\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring fractionToDecimal(int numerator, int denominator) {\\n    long long int num = numerator;\\n    long long int den = denominator;\\n    if(num == 0)\\n        return \"0\";\\n    string res;\\n    int sign = 1;\\n    sign *= num > 0?1:-1;\\n    sign *= den >= 0 ? 1: -1;\\n    num = abs(num);\\n    den = abs(den);\\n    long long int quotient = num / den;\\n    num = num % den;\\n    if(num == 0)\\n        res += to_string(quotient);\\n    else\\n        res += to_string(quotient) + \".\";\\n    int every;\\n    vector<int> m_v;\\n    int x = res.size();\\n    int st = 0;\\n    while(num!=0){\\n        m_v.push_back(num);\\n        num *= 10;\\n        every = num / den;\\n        res += to_string(every);\\n        num %= den;\\n        auto it = std::find(m_v.begin(), m_v.end(), num);\\n        if(it != m_v.end()){\\n            st = it - m_v.begin() + x;\\n            res = res.substr(0, st) + \"(\" + res.substr(st) + \")\";\\n            break;\\n        }\\n    }\\n    if(sign == -1)\\n        res = \"-\" + res;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1400356,
                "title": "intuitive-python-solution",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator < 0 and denominator > 0:\\n            return \\'-\\'+self.fractionToDecimal(-numerator, denominator)\\n        elif numerator < 0 and denominator < 0:\\n            return self.fractionToDecimal(-numerator, -denominator)\\n        elif numerator > 0 and denominator < 0:\\n            return \\'-\\'+self.fractionToDecimal(numerator, -denominator)\\n        first, residual = numerator // denominator, numerator % denominator\\n        if not residual:\\n            return str(first)\\n        cur = list(str(first))+[\\'.\\']\\n        digit_map = {}\\n        ind = len(cur)\\n        while residual:\\n            new_numerator = residual * 10\\n            if new_numerator  in digit_map:\\n                cur.insert(digit_map[new_numerator ],\\'(\\')\\n                cur.append(\\')\\')\\n                break\\n            \\n            new_digit, residual = new_numerator//denominator, new_numerator%denominator\\n            cur.append(str(new_digit))\\n            digit_map[new_numerator] = ind \\n            ind += 1\\n            \\n        return \\'\\'.join(cur)\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator < 0 and denominator > 0:\\n            return \\'-\\'+self.fractionToDecimal(-numerator, denominator)\\n        elif numerator < 0 and denominator < 0:\\n            return self.fractionToDecimal(-numerator, -denominator)\\n        elif numerator > 0 and denominator < 0:\\n            return \\'-\\'+self.fractionToDecimal(numerator, -denominator)\\n        first, residual = numerator // denominator, numerator % denominator\\n        if not residual:\\n            return str(first)\\n        cur = list(str(first))+[\\'.\\']\\n        digit_map = {}\\n        ind = len(cur)\\n        while residual:\\n            new_numerator = residual * 10\\n            if new_numerator  in digit_map:\\n                cur.insert(digit_map[new_numerator ],\\'(\\')\\n                cur.append(\\')\\')\\n                break\\n            \\n            new_digit, residual = new_numerator//denominator, new_numerator%denominator\\n            cur.append(str(new_digit))\\n            digit_map[new_numerator] = ind \\n            ind += 1\\n            \\n        return \\'\\'.join(cur)\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397685,
                "title": "c-solution-with-explanation-faster-than-100",
                "content": "The basic idea is when you divide the numerator by the denominator, if there are recurring digits, then it is the result of **recurring remainders** when you repeat the process of adding 0 to the end of remainders and keep dividing. \\n\\nIn order to save those remainder for checking later, a `map<int, int>` is used here: the keys are previous remainders and the values are the position. You need to keep the position for duplicate checkings; the first duplicated position is also **the start of recurring part** (for example: 1/6 = 0.1(6) in which the recurring part start at 6, not 1)\\n\\nSolution:\\n\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        bool sign = (numerator <= 0 && denominator < 0) || (numerator >= 0 && denominator > 0);\\n        long long num = numerator; \\n        long long den = denominator;\\n        num = abs(num); \\n        den = abs(den); \\n        string real = to_string(num/den);\\n        if (!sign) \\n            real = \\'-\\' + real;\\n        string decimal = \".\";\\n        map<int, int> mp;\\n        mp.clear();\\n        long long rem = num % den;\\n        if (rem == 0) \\n            return real;\\n        while (rem != 0 && (mp.find(rem) == mp.end())) {\\n            mp[rem] = decimal.length();\\n            rem = rem * 10;\\n            decimal += (char)(\\'0\\' + rem/den);\\n            rem = rem % den;\\n        }\\n        if (rem == 0)\\n            return real + decimal;\\n        return real + decimal.substr(0, mp[rem]) + \\'(\\' + decimal.substr(mp[rem]) + \\')\\';\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        bool sign = (numerator <= 0 && denominator < 0) || (numerator >= 0 && denominator > 0);\\n        long long num = numerator; \\n        long long den = denominator;\\n        num = abs(num); \\n        den = abs(den); \\n        string real = to_string(num/den);\\n        if (!sign) \\n            real = \\'-\\' + real;\\n        string decimal = \".\";\\n        map<int, int> mp;\\n        mp.clear();\\n        long long rem = num % den;\\n        if (rem == 0) \\n            return real;\\n        while (rem != 0 && (mp.find(rem) == mp.end())) {\\n            mp[rem] = decimal.length();\\n            rem = rem * 10;\\n            decimal += (char)(\\'0\\' + rem/den);\\n            rem = rem % den;\\n        }\\n        if (rem == 0)\\n            return real + decimal;\\n        return real + decimal.substr(0, mp[rem]) + \\'(\\' + decimal.substr(mp[rem]) + \\')\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383933,
                "title": "clean-and-understandable-typescript-solution",
                "content": "```\\nfunction fractionToDecimal(numerator: number, denominator: number): string {\\n  if (numerator === 0) {\\n    return \"0\";\\n  }\\n\\n  /*\\n    If either the numerator or denominator is negative but not both, \\n    the fraction will be negative as well.\\n  */\\n  const sign = numerator > 0 === denominator > 0 ? \"\" : \"-\";\\n\\n  numerator = Math.abs(numerator);\\n  denominator = Math.abs(denominator);\\n\\n  const wholeNumber = Math.floor(numerator / denominator);\\n\\n  return sign + wholeNumber + fraction(numerator % denominator, denominator);\\n}\\n\\nconst fraction = (remainder: number, denominator: number): string => {\\n  /*\\n    remainder will be 0 when there is no fractional part\\n  */\\n  if (remainder === 0) {\\n    return \"\";\\n  }\\n\\n  let fraction = \".\";\\n  const map = new Map<number, number>();\\n\\n  while (remainder !== 0) {\\n    /*\\n      We use remainder as the key for the index as it is unique for\\n      non-repeating fractions. It also handles the case where we have\\n      a final string of \"0.02301\" where the 0 repeats twice. However,\\n      the 0s have different remainders at calculation and as such\\n      don\\'t trigger the repeating sequence logic we have below.\\n\\n      For repeating fractions like \"0.012012\", the remainders for the \\n      0s are the same at calculation. From a logical standpoint, it has\\n      to be the same in order for the 2nd \"012\" sequence to be calculated\\n      the same.\\n    */\\n    map.set(remainder, fraction.length);\\n\\n    /*\\n      Step the remainder once to the right so we can keep filling out\\n      the fraction.\\n      \"0.0_\" -> \"0.01_\"\\n\\n      Fill the blank spot with the integer result of how many times\\n      denominator goes into remainder.\\n\\n      Remainder is then reset to the remainder of that division operation.\\n    */\\n    remainder *= 10;\\n    fraction += Math.floor(remainder / denominator);\\n    remainder %= denominator;\\n\\n    const remainderIndex = map.get(remainder);\\n    if (remainderIndex !== undefined) {\\n      return (\\n        fraction.slice(0, remainderIndex) +\\n        \"(\" +\\n        fraction.slice(remainderIndex) +\\n        \")\"\\n      );\\n    }\\n  }\\n\\n  return fraction;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction fractionToDecimal(numerator: number, denominator: number): string {\\n  if (numerator === 0) {\\n    return \"0\";\\n  }\\n\\n  /*\\n    If either the numerator or denominator is negative but not both, \\n    the fraction will be negative as well.\\n  */\\n  const sign = numerator > 0 === denominator > 0 ? \"\" : \"-\";\\n\\n  numerator = Math.abs(numerator);\\n  denominator = Math.abs(denominator);\\n\\n  const wholeNumber = Math.floor(numerator / denominator);\\n\\n  return sign + wholeNumber + fraction(numerator % denominator, denominator);\\n}\\n\\nconst fraction = (remainder: number, denominator: number): string => {\\n  /*\\n    remainder will be 0 when there is no fractional part\\n  */\\n  if (remainder === 0) {\\n    return \"\";\\n  }\\n\\n  let fraction = \".\";\\n  const map = new Map<number, number>();\\n\\n  while (remainder !== 0) {\\n    /*\\n      We use remainder as the key for the index as it is unique for\\n      non-repeating fractions. It also handles the case where we have\\n      a final string of \"0.02301\" where the 0 repeats twice. However,\\n      the 0s have different remainders at calculation and as such\\n      don\\'t trigger the repeating sequence logic we have below.\\n\\n      For repeating fractions like \"0.012012\", the remainders for the \\n      0s are the same at calculation. From a logical standpoint, it has\\n      to be the same in order for the 2nd \"012\" sequence to be calculated\\n      the same.\\n    */\\n    map.set(remainder, fraction.length);\\n\\n    /*\\n      Step the remainder once to the right so we can keep filling out\\n      the fraction.\\n      \"0.0_\" -> \"0.01_\"\\n\\n      Fill the blank spot with the integer result of how many times\\n      denominator goes into remainder.\\n\\n      Remainder is then reset to the remainder of that division operation.\\n    */\\n    remainder *= 10;\\n    fraction += Math.floor(remainder / denominator);\\n    remainder %= denominator;\\n\\n    const remainderIndex = map.get(remainder);\\n    if (remainderIndex !== undefined) {\\n      return (\\n        fraction.slice(0, remainderIndex) +\\n        \"(\" +\\n        fraction.slice(remainderIndex) +\\n        \")\"\\n      );\\n    }\\n  }\\n\\n  return fraction;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352484,
                "title": "c-faster-solution-with-comments",
                "content": "```cpp\\n\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n     \\n        // Output string to store the answer\\n        string result = \"\";\\n \\n        // Ensure numerator is non-zero,\\n        // if numerator is zero , then return \"0\"\\n        if (numerator == 0){\\n            return \"0\";\\n        }\\n        \\n        if((numerator < 0 && denominator > 0) || (numerator > 0 && denominator < 0)){\\n            result.append(\"-\");\\n        }\\n            \\n        // getting the absolute value of the numerator and denominator\\n        long long int n = abs(numerator);\\n        long long int d = abs(denominator);\\n        \\n        // Calculate the absolute part\\n        // (before decimal point), which is quotitent\\n        long long int quotitent = n / d;\\n            \\n        // Append the quotitent\\n        result += to_string(abs(quotitent));\\n        \\n        // If completely divisible, return answer.\\n        if (n % d == 0){\\n            return result;\\n        }\\n        \\n        // append the decimal \".\" dot\\n        result += \".\";\\n        \\n        // Initialize Remainder\\n        long remainder = n % d;\\n        \\n        // create the map to store the remainder\\n        map<int, int> remMap;\\n     \\n        // Position at which fraction starts repeating, if it exists\\n        int index;\\n        \\n        \\n        // run the loop till remainder becomes \"0\" and repeathing becomes \"true\"\\n        while (remainder > 0) {\\n            \\n            // If the remainder is already seen,\\n            // then there exists a repeating fraction.\\n            // break the loop and print the result, after appending the remainder\\n            if (remMap.find(remainder) != remMap.end()) {\\n     \\n                result.insert( remMap[remainder], \"(\");\\n                \\n                result.append(\")\");\\n                \\n                break;\\n            }\\n            // if no remainder found\\n            // add the remainder to the map \\n            // with key as remainder and value as size of the result\\n            else{\\n                remMap[remainder] = result.size();\\n            }\\n            \\n            remainder = remainder * 10;\\n \\n            // Calculate quotient, append it to result and\\n            // calculate next remainder\\n            long long int temp = remainder / d;\\n            \\n            remainder = remainder % denominatr;\\n            \\n            result += to_string(temp);\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```cpp\\n\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n     \\n        // Output string to store the answer\\n        string result = \"\";\\n \\n        // Ensure numerator is non-zero,\\n        // if numerator is zero , then return \"0\"\\n        if (numerator == 0){\\n            return \"0\";\\n        }\\n        \\n        if((numerator < 0 && denominator > 0) || (numerator > 0 && denominator < 0)){\\n            result.append(\"-\");\\n        }\\n            \\n        // getting the absolute value of the numerator and denominator\\n        long long int n = abs(numerator);\\n        long long int d = abs(denominator);\\n        \\n        // Calculate the absolute part\\n        // (before decimal point), which is quotitent\\n        long long int quotitent = n / d;\\n            \\n        // Append the quotitent\\n        result += to_string(abs(quotitent));\\n        \\n        // If completely divisible, return answer.\\n        if (n % d == 0){\\n            return result;\\n        }\\n        \\n        // append the decimal \".\" dot\\n        result += \".\";\\n        \\n        // Initialize Remainder\\n        long remainder = n % d;\\n        \\n        // create the map to store the remainder\\n        map<int, int> remMap;\\n     \\n        // Position at which fraction starts repeating, if it exists\\n        int index;\\n        \\n        \\n        // run the loop till remainder becomes \"0\" and repeathing becomes \"true\"\\n        while (remainder > 0) {\\n            \\n            // If the remainder is already seen,\\n            // then there exists a repeating fraction.\\n            // break the loop and print the result, after appending the remainder\\n            if (remMap.find(remainder) != remMap.end()) {\\n     \\n                result.insert( remMap[remainder], \"(\");\\n                \\n                result.append(\")\");\\n                \\n                break;\\n            }\\n            // if no remainder found\\n            // add the remainder to the map \\n            // with key as remainder and value as size of the result\\n            else{\\n                remMap[remainder] = result.size();\\n            }\\n            \\n            remainder = remainder * 10;\\n \\n            // Calculate quotient, append it to result and\\n            // calculate next remainder\\n            long long int temp = remainder / d;\\n            \\n            remainder = remainder % denominatr;\\n            \\n            result += to_string(temp);\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310874,
                "title": "100-faster-and-easier-c-solution",
                "content": "What you need to crack this is a hashmap and your childhood memories that you have with you of dividing numbers\\uD83E\\uDD17!\\nNote : Do check for sign as well.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(denominator == 0)\\n            return \"\";\\n        \\n        if(numerator == 0) \\n            return \"0\"; \\n        \\n        unordered_map<long, int> ump;\\n        string res;\\n        \\n        long quo = abs((long)numerator / (long)denominator);\\n        int sgn = 1;\\n\\n        if(numerator < 0 )\\n        sgn = -1*sgn;\\n\\n        if(denominator < 0 )\\n        sgn = -1*sgn;\\n\\n        if(sgn == -1)\\n        res+=\\'-\\';\\n\\n        res += to_string(quo);\\n\\n        long rem = abs((long)numerator % (long)denominator);\\n\\n        if(rem == 0) \\n        return res;\\n        res += \".\";\\n        \\n        while(rem)\\n        {\\n            ump[rem] = res.size();\\n            rem *= 10;\\n            res += to_string(rem / abs((long)denominator));\\n            rem %= abs((long)denominator);\\n            if(ump.find(rem) != ump.end())\\n            {\\n                res.insert(ump[rem], \"(\");\\n                res += \")\";\\n                break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(denominator == 0)\\n            return \"\";\\n        \\n        if(numerator == 0) \\n            return \"0\"; \\n        \\n        unordered_map<long, int> ump;\\n        string res;\\n        \\n        long quo = abs((long)numerator / (long)denominator);\\n        int sgn = 1;\\n\\n        if(numerator < 0 )\\n        sgn = -1*sgn;\\n\\n        if(denominator < 0 )\\n        sgn = -1*sgn;\\n\\n        if(sgn == -1)\\n        res+=\\'-\\';\\n\\n        res += to_string(quo);\\n\\n        long rem = abs((long)numerator % (long)denominator);\\n\\n        if(rem == 0) \\n        return res;\\n        res += \".\";\\n        \\n        while(rem)\\n        {\\n            ump[rem] = res.size();\\n            rem *= 10;\\n            res += to_string(rem / abs((long)denominator));\\n            rem %= abs((long)denominator);\\n            if(ump.find(rem) != ump.end())\\n            {\\n                res.insert(ump[rem], \"(\");\\n                res += \")\";\\n                break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263033,
                "title": "one-imp-thing-to-learn-regarding-the-integers",
                "content": "Must notice that for nume=-2147483648. \\nnume=abs(nume) will be same as nume and not the positive equivalent of it.\\nSo whenenver the input constraint is INT_MIN<=nume<=INT_MAX then always always, recieve the numbers in the funciton signature only in long long format or cast the number into higher data type and then perform the operations on it. \\nEg: \\n```\\n#include <iostream>\\nusing namespace std;\\nint main() {\\n    int n1=-2147483648;\\n    long long n=n1;\\n    n*=-1;\\n    cout<<n<<endl;\\n}\\n\\nO/P=> 2147483648\\n```\\n\\nand notice this : \\n```\\n#include <iostream>\\nusing namespace std;\\nint main() {\\n    int n1=-2147483648;\\n    long long n=-1*n1;\\n    cout<<n<<endl;\\n}\\n\\nO/P=> -2147483648\\n```\\n\\nHere is the solution : \\n\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    string fractionToDecimal(ll nume, ll deno) {\\n        if(nume==0) return \"0\";\\n        string ans=\"\";\\n        if((nume<0 or deno<0)and not(nume<0 and deno<0))\\n            ans+=\"-\";\\n        nume=abs(nume);\\n        deno=abs(deno);\\n        \\n        ans+=to_string(nume/deno);\\n        ll rem=nume%deno;\\n        if(rem==0){\\n            return ans;\\n        }\\n        //dealing with after float value\\n        ans+=\".\";\\n        map<ll,ll> mm;\\n        while(rem){\\n            if(mm.find(rem)!=mm.end()){\\n                auto it=mm.find(rem);\\n                int pos=it->second;\\n                string str1=ans.substr(0,pos);\\n                string str2=ans.substr(pos);\\n                ans=str1+\"(\"+str2+\")\";\\n                break;\\n            }\\n            else{\\n                mm.insert(make_pair(rem,ans.length()));\\n                rem*=10;\\n                int q=rem/deno;\\n                ans+=to_string(q);\\n                rem%=deno;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <iostream>\\nusing namespace std;\\nint main() {\\n    int n1=-2147483648;\\n    long long n=n1;\\n    n*=-1;\\n    cout<<n<<endl;\\n}\\n\\nO/P=> 2147483648\\n```\n```\\n#include <iostream>\\nusing namespace std;\\nint main() {\\n    int n1=-2147483648;\\n    long long n=-1*n1;\\n    cout<<n<<endl;\\n}\\n\\nO/P=> -2147483648\\n```\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    string fractionToDecimal(ll nume, ll deno) {\\n        if(nume==0) return \"0\";\\n        string ans=\"\";\\n        if((nume<0 or deno<0)and not(nume<0 and deno<0))\\n            ans+=\"-\";\\n        nume=abs(nume);\\n        deno=abs(deno);\\n        \\n        ans+=to_string(nume/deno);\\n        ll rem=nume%deno;\\n        if(rem==0){\\n            return ans;\\n        }\\n        //dealing with after float value\\n        ans+=\".\";\\n        map<ll,ll> mm;\\n        while(rem){\\n            if(mm.find(rem)!=mm.end()){\\n                auto it=mm.find(rem);\\n                int pos=it->second;\\n                string str1=ans.substr(0,pos);\\n                string str2=ans.substr(pos);\\n                ans=str1+\"(\"+str2+\")\";\\n                break;\\n            }\\n            else{\\n                mm.insert(make_pair(rem,ans.length()));\\n                rem*=10;\\n                int q=rem/deno;\\n                ans+=to_string(q);\\n                rem%=deno;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1257265,
                "title": "python-solution-annoying-to-get-every-little-piece-right",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\n        ans = \\'-\\' if numerator // denominator < 0 else \\'\\'\\n        numerator = abs(numerator)\\n        denominator = abs(denominator)\\n        prefrac = numerator // denominator\\n        ans += str(prefrac) \\n        \\n        rem = numerator % denominator\\n        if not rem:\\n            return ans\\n        ans += \\'.\\'\\n        remainder = \\'\\'\\n        seen = {}\\n        \\n        while rem not in seen:\\n            if rem == 0:\\n                return ans + remainder\\n            \\n            seen[rem] = len(remainder)\\n            rem *= 10\\n            remainder += str(rem//denominator)\\n            rem %= denominator\\n            \\n        return ans + remainder[:seen[rem]] + \\'(\\' + remainder[seen[rem]:] + \\')\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\n        ans = \\'-\\' if numerator // denominator < 0 else \\'\\'\\n        numerator = abs(numerator)\\n        denominator = abs(denominator)\\n        prefrac = numerator // denominator\\n        ans += str(prefrac) \\n        \\n        rem = numerator % denominator\\n        if not rem:\\n            return ans\\n        ans += \\'.\\'\\n        remainder = \\'\\'\\n        seen = {}\\n        \\n        while rem not in seen:\\n            if rem == 0:\\n                return ans + remainder\\n            \\n            seen[rem] = len(remainder)\\n            rem *= 10\\n            remainder += str(rem//denominator)\\n            rem %= denominator\\n            \\n        return ans + remainder[:seen[rem]] + \\'(\\' + remainder[seen[rem]:] + \\')\\'\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566944,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1566482,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1573920,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1567896,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1567897,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1570001,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1573343,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1680418,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1573302,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1573002,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1566944,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1566482,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1573920,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1567896,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1567897,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1570001,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1573343,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1680418,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1573302,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1573002,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1571365,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1568993,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1572225,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1571364,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 2048998,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 2031528,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1967412,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1852823,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1796595,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1769745,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            }
        ]
    },
    {
        "title": "Palindrome Permutation",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1725956,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try to think about the frequency of each letter. What if all characters appear with even times? What if some characters appear with odd times? :)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\nEvery letter in the word must be matched, except for possibly the middle one"
                    },
                    {
                        "username": "LethalQ",
                        "content": "appreciate it man, this one helped a lot, I mean it."
                    }
                ]
            },
            {
                "id": 1797677,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try to think about the frequency of each letter. What if all characters appear with even times? What if some characters appear with odd times? :)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\nEvery letter in the word must be matched, except for possibly the middle one"
                    },
                    {
                        "username": "LethalQ",
                        "content": "appreciate it man, this one helped a lot, I mean it."
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Leaves of Binary Tree",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1570684,
                "content": [
                    {
                        "username": "kaaustubh",
                        "content": "I was asked the same question in the interview at Google, I think I came up with a good solution to return the leaves on the same level. But somehow the inteviewer was very keen not only to get the sequence but also to remove the leaves from the tree. I struggled a bit with that. And he really wanted the leaves to be remove from the root. But when I checked Leetcode later, I found none of the solutions are actually removing leaves."
                    },
                    {
                        "username": "laichbr",
                        "content": "Also removed nodes in my implementation. Did iterative DFS with a passed list and gathered the leaves each run. Check here -> https://leetcode.com/problems/find-leaves-of-binary-tree/solutions/3178081/iterative-dfs-trimming-simple-python-implementation/?envType=study-plan&id=data-structure-iii"
                    },
                    {
                        "username": "mchim",
                        "content": "Here, removing nodes: https://leetcode.com/problems/find-leaves-of-binary-tree/solutions/83811/simple-java-recursive-1ms-solution/?orderBy=most_votes"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I know how to remove children - set the parent's `left` or `right` to `null`. But how can I remove the root?"
                    },
                    {
                        "username": "bhagwataditya226",
                        "content": "While using recursion for DFS use another extra parameter as parent and pass it along, if the node\\'s left and right are empty: check if the parent\\'s left == node or parent.right == node: then set the child(node) to null. This way you eliminate all the node. now when the recursion arrives at root: it won\\'t have a parent, so check if parent is null:-> then just add the root.val to result and set it to null."
                    },
                    {
                        "username": "Yuhua-Wang",
                        "content": "[@mdesmond](/mdesmond) In that sense we don't even need to delete left and right for Java implementation. We can just return the dummy root at the end."
                    },
                    {
                        "username": "mdesmond",
                        "content": "Use a dummy root, and keep deleting leaves until the tree contains only the dummy root"
                    },
                    {
                        "username": "laichbr",
                        "content": "If you think of it as repeated DFS for the leaves and the trimming at the occurrence of a leaf node per repeated attempt with the node value added to the current iterations list values, you will get the list for this dfs removal. If you add the resulting list to the final list each time and go until you\\'ve nulled the root, you get it! "
                    }
                ]
            },
            {
                "id": 1567965,
                "content": [
                    {
                        "username": "kaaustubh",
                        "content": "I was asked the same question in the interview at Google, I think I came up with a good solution to return the leaves on the same level. But somehow the inteviewer was very keen not only to get the sequence but also to remove the leaves from the tree. I struggled a bit with that. And he really wanted the leaves to be remove from the root. But when I checked Leetcode later, I found none of the solutions are actually removing leaves."
                    },
                    {
                        "username": "laichbr",
                        "content": "Also removed nodes in my implementation. Did iterative DFS with a passed list and gathered the leaves each run. Check here -> https://leetcode.com/problems/find-leaves-of-binary-tree/solutions/3178081/iterative-dfs-trimming-simple-python-implementation/?envType=study-plan&id=data-structure-iii"
                    },
                    {
                        "username": "mchim",
                        "content": "Here, removing nodes: https://leetcode.com/problems/find-leaves-of-binary-tree/solutions/83811/simple-java-recursive-1ms-solution/?orderBy=most_votes"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I know how to remove children - set the parent's `left` or `right` to `null`. But how can I remove the root?"
                    },
                    {
                        "username": "bhagwataditya226",
                        "content": "While using recursion for DFS use another extra parameter as parent and pass it along, if the node\\'s left and right are empty: check if the parent\\'s left == node or parent.right == node: then set the child(node) to null. This way you eliminate all the node. now when the recursion arrives at root: it won\\'t have a parent, so check if parent is null:-> then just add the root.val to result and set it to null."
                    },
                    {
                        "username": "Yuhua-Wang",
                        "content": "[@mdesmond](/mdesmond) In that sense we don't even need to delete left and right for Java implementation. We can just return the dummy root at the end."
                    },
                    {
                        "username": "mdesmond",
                        "content": "Use a dummy root, and keep deleting leaves until the tree contains only the dummy root"
                    },
                    {
                        "username": "laichbr",
                        "content": "If you think of it as repeated DFS for the leaves and the trimming at the occurrence of a leaf node per repeated attempt with the node value added to the current iterations list values, you will get the list for this dfs removal. If you add the resulting list to the final list each time and go until you\\'ve nulled the root, you get it! "
                    }
                ]
            },
            {
                "id": 1798850,
                "content": [
                    {
                        "username": "kaaustubh",
                        "content": "I was asked the same question in the interview at Google, I think I came up with a good solution to return the leaves on the same level. But somehow the inteviewer was very keen not only to get the sequence but also to remove the leaves from the tree. I struggled a bit with that. And he really wanted the leaves to be remove from the root. But when I checked Leetcode later, I found none of the solutions are actually removing leaves."
                    },
                    {
                        "username": "laichbr",
                        "content": "Also removed nodes in my implementation. Did iterative DFS with a passed list and gathered the leaves each run. Check here -> https://leetcode.com/problems/find-leaves-of-binary-tree/solutions/3178081/iterative-dfs-trimming-simple-python-implementation/?envType=study-plan&id=data-structure-iii"
                    },
                    {
                        "username": "mchim",
                        "content": "Here, removing nodes: https://leetcode.com/problems/find-leaves-of-binary-tree/solutions/83811/simple-java-recursive-1ms-solution/?orderBy=most_votes"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I know how to remove children - set the parent's `left` or `right` to `null`. But how can I remove the root?"
                    },
                    {
                        "username": "bhagwataditya226",
                        "content": "While using recursion for DFS use another extra parameter as parent and pass it along, if the node\\'s left and right are empty: check if the parent\\'s left == node or parent.right == node: then set the child(node) to null. This way you eliminate all the node. now when the recursion arrives at root: it won\\'t have a parent, so check if parent is null:-> then just add the root.val to result and set it to null."
                    },
                    {
                        "username": "Yuhua-Wang",
                        "content": "[@mdesmond](/mdesmond) In that sense we don't even need to delete left and right for Java implementation. We can just return the dummy root at the end."
                    },
                    {
                        "username": "mdesmond",
                        "content": "Use a dummy root, and keep deleting leaves until the tree contains only the dummy root"
                    },
                    {
                        "username": "laichbr",
                        "content": "If you think of it as repeated DFS for the leaves and the trimming at the occurrence of a leaf node per repeated attempt with the node value added to the current iterations list values, you will get the list for this dfs removal. If you add the resulting list to the final list each time and go until you\\'ve nulled the root, you get it! "
                    }
                ]
            }
        ]
    },
    {
        "title": "Count The Repetitions",
        "question_content": "<p>We define <code>str = [s, n]</code> as the string <code>str</code> which consists of the string <code>s</code> concatenated <code>n</code> times.</p>\n\n<ul>\n\t<li>For example, <code>str == [&quot;abc&quot;, 3] ==&quot;abcabcabc&quot;</code>.</li>\n</ul>\n\n<p>We define that string <code>s1</code> can be obtained from string <code>s2</code> if we can remove some characters from <code>s2</code> such that it becomes <code>s1</code>.</p>\n\n<ul>\n\t<li>For example, <code>s1 = &quot;abc&quot;</code> can be obtained from <code>s2 = &quot;ab<strong><u>dbe</u></strong>c&quot;</code> based on our definition by removing the bolded underlined characters.</li>\n</ul>\n\n<p>You are given two strings <code>s1</code> and <code>s2</code> and two integers <code>n1</code> and <code>n2</code>. You have the two strings <code>str1 = [s1, n1]</code> and <code>str2 = [s2, n2]</code>.</p>\n\n<p>Return <em>the maximum integer </em><code>m</code><em> such that </em><code>str = [str2, m]</code><em> can be obtained from </em><code>str1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\n<strong>Output:</strong> 2\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\n<strong>Output:</strong> 1\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 100</code></li>\n\t<li><code>s1</code> and <code>s2</code> consist of lowercase English letters.</li>\n\t<li><code>1 &lt;= n1, n2 &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2997580,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            for(int k=0;k<i;k++){\\n                if(posRest==rest[k]){b=k;last=i;break;}\\n            }\\n            rapport[i]=rap;rest[i]=posRest;\\n            if(b>=0)break;\\n        }\\n        int interval=last-b;\\n        if(b>=n1)return rapport[n1]/n2;\\n        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        start = {}\\n        s1_round, s2_round, s2_idx = 0, 0, 0\\n        while s1_round < n1:\\n            s1_round += 1\\n            for ch in s1:\\n                if ch == s2[s2_idx]:\\n                    s2_idx += 1\\n                    if s2_idx == len(s2):\\n                        s2_round += 1\\n                        s2_idx = 0\\n            if s2_idx in start:\\n                prev_s1_round, prev_s2_round = start[s2_idx]\\n                circle_s1_round, circle_s2_round = s1_round - prev_s1_round, s2_round - prev_s2_round\\n                res = (n1 - prev_s1_round)\\n                left_s1_round = (n1 - prev_s1_round) % circle_s1_round + prev_s1_round\\n                for key in start:\\n                    val = start[key]\\n                    if val[0] == left_s1_round:\\n                        res += val[1]\\n                        break\\n                return res \\n            else:\\n                start[s2_idx] = (s1_round, s2_round)\\n        return s2_round\\n```\\n\\n```Java []\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n         int l1 = s1.length(), l2 = s2.length();\\n        int[] next = new int[l2 + 1];\\n        int[] count = new int[l2 + 1];\\n        int cnt = 0, p = 0;\\n        for (int i = 0; i < n1; i++) {\\n            for (int j = 0; j < l1; j++) {\\n                if (s1.charAt(j) == s2.charAt(p)) {\\n                    p++;\\n                }\\n                if (p == l2) {\\n                    cnt++;\\n                    p = 0;\\n                }\\n            }\\n            count[i] = cnt;\\n            next[i] = p;\\n            for (int j = 0; j < i; j++) {\\n                if (next[j] == p) {\\n                    int prev_count = count[j];\\n                    int pattern_count = (count[i] - count[j]) * ((n1 - j - 1) / (i - j));\\n                    int remain_count = count[j + (n1 - j - 1) % (i - j)] - count[j];\\n                    return (prev_count + pattern_count + remain_count) / n2;\\n                }\\n            }\\n        }\\n        return count[n1 - 1] / n2;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            for(int k=0;k<i;k++){\\n                if(posRest==rest[k]){b=k;last=i;break;}\\n            }\\n            rapport[i]=rap;rest[i]=posRest;\\n            if(b>=0)break;\\n        }\\n        int interval=last-b;\\n        if(b>=n1)return rapport[n1]/n2;\\n        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;  }\\n};\\n```\n```Python3 []\\nclass Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        start = {}\\n        s1_round, s2_round, s2_idx = 0, 0, 0\\n        while s1_round < n1:\\n            s1_round += 1\\n            for ch in s1:\\n                if ch == s2[s2_idx]:\\n                    s2_idx += 1\\n                    if s2_idx == len(s2):\\n                        s2_round += 1\\n                        s2_idx = 0\\n            if s2_idx in start:\\n                prev_s1_round, prev_s2_round = start[s2_idx]\\n                circle_s1_round, circle_s2_round = s1_round - prev_s1_round, s2_round - prev_s2_round\\n                res = (n1 - prev_s1_round)\\n                left_s1_round = (n1 - prev_s1_round) % circle_s1_round + prev_s1_round\\n                for key in start:\\n                    val = start[key]\\n                    if val[0] == left_s1_round:\\n                        res += val[1]\\n                        break\\n                return res \\n            else:\\n                start[s2_idx] = (s1_round, s2_round)\\n        return s2_round\\n```\n```Java []\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n         int l1 = s1.length(), l2 = s2.length();\\n        int[] next = new int[l2 + 1];\\n        int[] count = new int[l2 + 1];\\n        int cnt = 0, p = 0;\\n        for (int i = 0; i < n1; i++) {\\n            for (int j = 0; j < l1; j++) {\\n                if (s1.charAt(j) == s2.charAt(p)) {\\n                    p++;\\n                }\\n                if (p == l2) {\\n                    cnt++;\\n                    p = 0;\\n                }\\n            }\\n            count[i] = cnt;\\n            next[i] = p;\\n            for (int j = 0; j < i; j++) {\\n                if (next[j] == p) {\\n                    int prev_count = count[j];\\n                    int pattern_count = (count[i] - count[j]) * ((n1 - j - 1) / (i - j));\\n                    int remain_count = count[j + (n1 - j - 1) % (i - j)] - count[j];\\n                    return (prev_count + pattern_count + remain_count) / n2;\\n                }\\n            }\\n        }\\n        return count[n1 - 1] / n2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95401,
                "title": "ugly-java-brute-force-solution-but-accepted-1088ms",
                "content": "I didn't come up with any good solution so I tried brute force. Key points:\\n1. How do we know \"string s2 can be obtained from string s1\"? Easy, use two pointers iterate through s2 and s1. If chars are equal, move both. Otherwise only move pointer1.\\n2. We repeat step 1 and go through s1 for n1 times and count how many times can we go through s2.\\n3. Answer to this problem is times go through s2 divide by n2.\\n\\n```\\npublic class Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        char[] array1 = s1.toCharArray(), array2 = s2.toCharArray();\\n        int count1 = 0, count2 = 0, i = 0, j = 0;\\n        \\n        while (count1 < n1) {\\n            if (array1[i] == array2[j]) {\\n                j++;\\n                if (j == array2.length) {\\n                    j = 0;\\n                    count2++;\\n                }\\n            }\\n            i++;\\n            if (i == array1.length) {\\n                i = 0;\\n                count1++;\\n            }\\n        }\\n        \\n        return count2 / n2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        char[] array1 = s1.toCharArray(), array2 = s2.toCharArray();\\n        int count1 = 0, count2 = 0, i = 0, j = 0;\\n        \\n        while (count1 < n1) {\\n            if (array1[i] == array2[j]) {\\n                j++;\\n                if (j == array2.length) {\\n                    j = 0;\\n                    count2++;\\n                }\\n            }\\n            i++;\\n            if (i == array1.length) {\\n                i = 0;\\n                count1++;\\n            }\\n        }\\n        \\n        return count2 / n2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95398,
                "title": "c-solution-inspired-by-70664914-with-organized-explanation",
                "content": "*You can find more of my code/explanations in my github repo [lzl124631x/LeetCode](https://github.com/lzl124631x/LeetCode)*\\n\\nIt\\'s easy to come up with a brute force solution and to find that there will be a **repetitive pattern** when matching `S2` through `S1`. The only problem is how to use the repetitive pattern to save computation.\\n\\n**Fact:**\\nIf `s2` repeats in `S1` `R` times, then `S2` must repeats in `S1` `R / n2` times.\\n**Conclusion:**\\nWe can simply count the repetition of `s2` and then divide the count by `n2`.\\n\\n**How to denote repetition:**\\nWe need to scan `s1` `n1` times. Denote each scanning of `s1` as an `s1` segment.\\nAfter each scanning of `i`-th `s1` segment, we will have\\n1. The accumulative count of `s2` repeated in this `s1` segment.  \\n2. A `nextIndex` that `s2[nextIndex]` is the first letter you\\'ll be looking for in the next `s1` segment.\\n> Suppose `s1=\"abc\"`, `s2=\"bac\"`, `nextIndex` will be `1`; `s1=\"abca\"`, `s2=\"bac\"`, `nextIndex` will be `2`\\n\\nIt is the `nextIndex` that is the denotation of the repetitive pattern.\\n\\n**Example:**\\n```\\nInput:\\ns1=\"abacb\", n1=6\\ns2=\"bcaa\", n2=1\\n\\nReturn:\\n3\\n```\\n```\\n                    0 1    2 3 0      1    2 3 0      1    2 3 0  \\nS1 --------------> abacb | abacb | abacb | abacb | abacb | abacb \\n\\nrepeatCount ----->    0  |   1   |   1   |   2   |   2   |   3\\n\\nIncrement of \\nrepeatCount     ->    0  |   1   |   0   |   1   |   0   |   1\\n\\nnextIndex ------->    2  |   1   |   2   |   1   |   2   |   1\\n                                     ^\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t |\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t repetitive pattern found here (we\\'ve met 2 before)!\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t The pattern repeated 3 times\\n```\\n\\nThe `nextIndex` has `s2.size()` possible values, ranging from `0` to `s2.size() - 1`. Due to PigeonHole principle, you must find two same `nextIndex` after scanning `s2.size() + 1` `s1` segments.\\n\\nOnce you meet a `nextIndex` you\\'ve met before, you\\'ll know that the following `nextIndex`s and increments of `repeatCount` will repeat a pattern.\\n\\nSo let\\'s separate the `s1` segments into 3 parts:\\n1. the prefix part before repetitive pattern\\n2. the repetitive part\\n3. the suffix part after repetitive pattern (incomplete repetitive pattern remnant)\\n\\nAll you have to do is add up the repeat counts of the 3 parts.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/count-the-repetitions/\\n// Author: github.com/lzl124631x\\n// Time: O(|s1| * n1) where |s1| is the length of s1\\n// Space: O(n1)\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> repeatCount(n1 + 1, 0);\\n        vector<int> nextIndex(n1 + 1, 0);\\n        int j = 0, cnt = 0;\\n        for (int k = 1; k <= n1; ++k) {\\n            for (int i = 0; i < s1.size(); ++i) {\\n                if (s1[i] == s2[j]) {\\n                    ++j;\\n                    if (j == s2.size()) {\\n                        j = 0;\\n                        ++cnt;\\n                    }\\n                }\\n            }\\n            repeatCount[k] = cnt;\\n            nextIndex[k] = j;\\n            for (int start = 0; start < k; ++start) {\\n                if (nextIndex[start] == j) { // see if you have met this nextIndex before\\n                    // if found, you can calculate the 3 parts\\n                    int prefixCount = repeatCount[start]; // prefixCount is the start-th repeatCount\\n                    // (repeatCount[k] - prefixCount) is the repeatCount of one occurrance of the pattern\\n                    // There are (n1 - start) / (k - start) occurrances of the pattern\\n                    // So (n1 - start) / (k - start) * (repeatCount[k] - prefixCount) is the repeatCount of the repetitive part\\n                    int patternCount = (n1 - start) / (k - start) * (repeatCount[k] - prefixCount);\\n                    // The suffix contains the incomplete repetitive remnant (if any)\\n                    // Its length is (n1 - start) % (k - start)\\n                    // So the suffix repeatCount should be repeatCount[start + (n1 - start) % (k - start)] - prefixCount\\n                    int suffixCount = repeatCount[start + (n1 - start) % (k - start)] - prefixCount;\\n                    return (prefixCount + patternCount + suffixCount) / n2;\\n                }\\n            }\\n        }\\n        return repeatCount[n1] / n2;\\n    }\\n};\\n```\\n\\n---\\n\\nUpdate 12/31/2018\\n* `int patternCount = (repeatCount[k] - repeatCount[start]) * (n1 - start) / (k - start);` to \\n`int patternCount = (repeatCount[k] - repeatCount[start]) * ((n1 - start) / (k - start));` since `a * b / c` doesn\\'t necessarily equal `a * (b / c)`. (the old test cases didn\\'t cover this case)\\n* The size of `repeatCount` and `nextIndex` should be `n1 + 1`.\\nThanks for comments from @wxd_sjtu, @rjtsdl, @Rongch\\n\\nAnother version using `unordered_map` to save computation. Reduce runtime from ~80ms to ~4ms.\\n```cpp\\n// OJ: https://leetcode.com/problems/count-the-repetitions/\\n// Author: github.com/lzl124631x\\n// Time: O(|s1| * n1) where |s1| is the length of s1\\n// Space: O(n1)\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        unordered_map<int, int> kToRepeatCount;\\n        unordered_map<int, int> nextIndexToK;\\n        kToRepeatCount[0] = 0;\\n        nextIndexToK[0] = 0;\\n        int j = 0, cnt = 0;\\n        for (int k = 1; k <= n1; ++k) {\\n            for (int i = 0; i < s1.size(); ++i) {\\n                if (s1[i] == s2[j]) {\\n                    ++j;\\n                    if (j == s2.size()) {\\n                        j = 0;\\n                        ++cnt;\\n                    }\\n                }\\n            }\\n            if (nextIndexToK.find(j) != nextIndexToK.end()) {\\n                int start = nextIndexToK[j];\\n                int prefixCount = kToRepeatCount[start];\\n                int patternCount = (n1 - start) / (k - start) * (cnt - prefixCount);\\n                int suffixCount = kToRepeatCount[start + (n1 - start) % (k - start)] - prefixCount;\\n                return (prefixCount + patternCount + suffixCount) / n2;\\n            }\\n            kToRepeatCount[k] = cnt;\\n            nextIndexToK[j] = k;\\n        }\\n        return kToRepeatCount[n1] / n2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nInput:\\ns1=\"abacb\", n1=6\\ns2=\"bcaa\", n2=1\\n\\nReturn:\\n3\\n```\n```\\n                    0 1    2 3 0      1    2 3 0      1    2 3 0  \\nS1 --------------> abacb | abacb | abacb | abacb | abacb | abacb \\n\\nrepeatCount ----->    0  |   1   |   1   |   2   |   2   |   3\\n\\nIncrement of \\nrepeatCount     ->    0  |   1   |   0   |   1   |   0   |   1\\n\\nnextIndex ------->    2  |   1   |   2   |   1   |   2   |   1\\n                                     ^\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t |\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t repetitive pattern found here (we\\'ve met 2 before)!\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t The pattern repeated 3 times\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/count-the-repetitions/\\n// Author: github.com/lzl124631x\\n// Time: O(|s1| * n1) where |s1| is the length of s1\\n// Space: O(n1)\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> repeatCount(n1 + 1, 0);\\n        vector<int> nextIndex(n1 + 1, 0);\\n        int j = 0, cnt = 0;\\n        for (int k = 1; k <= n1; ++k) {\\n            for (int i = 0; i < s1.size(); ++i) {\\n                if (s1[i] == s2[j]) {\\n                    ++j;\\n                    if (j == s2.size()) {\\n                        j = 0;\\n                        ++cnt;\\n                    }\\n                }\\n            }\\n            repeatCount[k] = cnt;\\n            nextIndex[k] = j;\\n            for (int start = 0; start < k; ++start) {\\n                if (nextIndex[start] == j) { // see if you have met this nextIndex before\\n                    // if found, you can calculate the 3 parts\\n                    int prefixCount = repeatCount[start]; // prefixCount is the start-th repeatCount\\n                    // (repeatCount[k] - prefixCount) is the repeatCount of one occurrance of the pattern\\n                    // There are (n1 - start) / (k - start) occurrances of the pattern\\n                    // So (n1 - start) / (k - start) * (repeatCount[k] - prefixCount) is the repeatCount of the repetitive part\\n                    int patternCount = (n1 - start) / (k - start) * (repeatCount[k] - prefixCount);\\n                    // The suffix contains the incomplete repetitive remnant (if any)\\n                    // Its length is (n1 - start) % (k - start)\\n                    // So the suffix repeatCount should be repeatCount[start + (n1 - start) % (k - start)] - prefixCount\\n                    int suffixCount = repeatCount[start + (n1 - start) % (k - start)] - prefixCount;\\n                    return (prefixCount + patternCount + suffixCount) / n2;\\n                }\\n            }\\n        }\\n        return repeatCount[n1] / n2;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/count-the-repetitions/\\n// Author: github.com/lzl124631x\\n// Time: O(|s1| * n1) where |s1| is the length of s1\\n// Space: O(n1)\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        unordered_map<int, int> kToRepeatCount;\\n        unordered_map<int, int> nextIndexToK;\\n        kToRepeatCount[0] = 0;\\n        nextIndexToK[0] = 0;\\n        int j = 0, cnt = 0;\\n        for (int k = 1; k <= n1; ++k) {\\n            for (int i = 0; i < s1.size(); ++i) {\\n                if (s1[i] == s2[j]) {\\n                    ++j;\\n                    if (j == s2.size()) {\\n                        j = 0;\\n                        ++cnt;\\n                    }\\n                }\\n            }\\n            if (nextIndexToK.find(j) != nextIndexToK.end()) {\\n                int start = nextIndexToK[j];\\n                int prefixCount = kToRepeatCount[start];\\n                int patternCount = (n1 - start) / (k - start) * (cnt - prefixCount);\\n                int suffixCount = kToRepeatCount[start + (n1 - start) % (k - start)] - prefixCount;\\n                return (prefixCount + patternCount + suffixCount) / n2;\\n            }\\n            kToRepeatCount[k] = cnt;\\n            nextIndexToK[j] = k;\\n        }\\n        return kToRepeatCount[n1] / n2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372230,
                "title": "python-don-t-look-at-words-look-at-chars-in-two-virtual-repeating-strings-detailed-explanation",
                "content": "Words repetition like [s1, n1] are distracting. What actually matters is the chars. \\nImagine both s1 and s2 as \"virtual\" string that repeats forever. Let i1 and i2 be the index of the two virtual strings, not the index of the original short strings. That means i1 and i2 can be infinitely big. Use mod only when getting char value at i1 and i2, but don\\'t change i1 and i2 by \"mod\" operation.\\nMatch the two virtual s1 with s2, until the s1 index reach it\\'s limit length, which by definition is n1\\\\*len(s1). Then the i2 position at this point will be the final result in terms of char length.\\nThe rest is just converting i2 to the number of words, where word length is len(s2)\\\\*n2.\\n\\nTo improve performance, we use dictionary to store previously matched indexes in original s1 and s2, if the same matched index comes again, that means we are in a repeating pattern, in which case we increase i1 and i2 by the length of their repeating circle until there is not enough chars left in virtual s1.\\n\\n```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        d={}\\n        l1,l2=len(s1),len(s2)\\n        total1=l1*n1\\n        i1=i2=0\\n        while i1<total1:\\n            if s1[i1%l1]==s2[i2%l2]:\\n                if (i1%l1,i2%l2) in d:\\n                    prevI1,prevI2=d[(i1%l1,i2%l2)]\\n                    circle1=i1-prevI1\\n                    circle2=i2-prevI2\\n                    circle1Cnt=(total1-i1)//circle1\\n                    i1+=circle1Cnt*circle1\\n                    i2+=circle1Cnt*circle2\\n                    if i1>=total1:\\n                        break\\n                else:\\n                    d[(i1%l1,i2%l2)]=[i1,i2]\\n                i2+=1\\n            i1+=1\\n        return i2//l2//n2\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        d={}\\n        l1,l2=len(s1),len(s2)\\n        total1=l1*n1\\n        i1=i2=0\\n        while i1<total1:\\n            if s1[i1%l1]==s2[i2%l2]:\\n                if (i1%l1,i2%l2) in d:\\n                    prevI1,prevI2=d[(i1%l1,i2%l2)]\\n                    circle1=i1-prevI1\\n                    circle2=i2-prevI2\\n                    circle1Cnt=(total1-i1)//circle1\\n                    i1+=circle1Cnt*circle1\\n                    i2+=circle1Cnt*circle2\\n                    if i1>=total1:\\n                        break\\n                else:\\n                    d[(i1%l1,i2%l2)]=[i1,i2]\\n                i2+=1\\n            i1+=1\\n        return i2//l2//n2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95408,
                "title": "easy-understanding-java-solution-with-detailed-explanation-21ms",
                "content": "The key is, we just need to calculate ***what will remain after s1 obtains s2***.\\n\\nThat is, `(s1, s2) -> (sRemain, matchCnt)`; for example,\\n`(abcd, ab) -> (cd, 1)`\\n`(ababa, ab) -> (a, 2)`\\n`(a, aaaa) -> (a, 0)`\\n`(aabaabaab, aba) -> (ab, 2)` as `aabaaba` exactly matches `aba` twice.\\n\\n\\nAnd, each time we append `s1` to the `remain string`, to make a sequence: (Using `[]` to mark the `remain string`)\\n`(abcd, ab): abcd -> [cd]abcd -> [cd]abcd -> [cd]abcd -> ...`\\n`(ababa, ab): ababa -> [a]ababa -> [a]ababa -> [a]ababa -> ...`\\n`(a, aaaa): a -> [a]a -> [aa]a -> [aaa]a -> a -> [a]a -> [aa]a -> ...`\\n`(aabaabaab, aba): aabaabaab -> [ab]aabaabaab -> [ab]aabaabaab -> ...`\\n\\nObviously, there will be a loop in the sequence, assume the length of loop is `loop`, and the length before the loop is `k`.\\n`(abcd, ab): loop=1, k=1`\\n`(a, aaaa): loop=4, k=0`\\n`(aabaabaab, aba): loop=1, k=1`\\n\\nSo, we just need to calculate `the count of each loop`, and `the count before entering the loop`, and calculate the total.\\n\\nHere is the code with detailed comment, 21ms.\\n\\n```\\npublic class Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if (!ableToObtain(s1, s2)) return 0; // check if [s1. \\u221e] obtains s2\\n        int cnt=0, k=-1;\\n        String s=s1;\\n        StringBuilder remainBuilder; // record `remain string`\\n        ArrayList<String> stringList=new ArrayList<>(); // record all the `remain string`\\n        ArrayList<Integer> countList=new ArrayList<>(); // record matching count from start to the current remain string \\n        stringList.add(\"\"); // record empty string\\n        countList.add(0);\\n        for (int i=0;i<=n1;i++) {\\n            remainBuilder=new StringBuilder();\\n            cnt+=getRemain(s, s2, remainBuilder); // get the next remain string, returns the count of matching\\n            String remain=remainBuilder.toString();\\n            if ((k=stringList.indexOf(remain))!=-1) break; // if there is a loop, break\\n            stringList.add(remain); // record the remain string into arraylist \\n            countList.add(cnt);\\n            s=remain+s1; // append s1 to make a new string\\n        }\\n        // here, k is the beginning of the loop\\n        if (k==-1) return cnt/n2; // if there is no loop\\n        int countOfLoop=cnt-countList.get(k), loopLength=stringList.size()-k; // get matching count in the loop, and loop length\\n        cnt=countList.get(k);\\n        n1-=k;\\n        cnt+=countOfLoop*(n1/loopLength);\\n        n1%=loopLength; \\n        cnt+=countList.get(k+n1)-countList.get(k);\\n        return cnt/n2;\\n    }\\n\\n    // check if [s1. \\u221e] obtains s2\\n    private boolean ableToObtain(String s1, String s2) {\\n        boolean[] cnt=new boolean[26];\\n        for (char c: s1.toCharArray()) cnt[c-'a']=true;\\n        for (char c: s2.toCharArray()) {\\n            if (!cnt[c-'a']) return false;\\n        }\\n        return true;\\n    }\\n\\n    // get remain string after s1 obtains s2, return the matching count\\n    private int getRemain(String s1, String s2, StringBuilder remain) {\\n        int cnt=0, lastMatch=-1, p2=0;\\n        for (int p1=0;p1<s1.length();p1++) {\\n            if (s1.charAt(p1)==s2.charAt(p2)) {\\n                if (++p2==s2.length()) {\\n                    p2=0;\\n                    cnt++;\\n                    lastMatch=p1;\\n                }\\n            }\\n        }\\n        remain.append(s1.substring(lastMatch+1));\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if (!ableToObtain(s1, s2)) return 0; // check if [s1. \\u221e] obtains s2\\n        int cnt=0, k=-1;\\n        String s=s1;\\n        StringBuilder remainBuilder; // record `remain string`\\n        ArrayList<String> stringList=new ArrayList<>(); // record all the `remain string`\\n        ArrayList<Integer> countList=new ArrayList<>(); // record matching count from start to the current remain string \\n        stringList.add(\"\"); // record empty string\\n        countList.add(0);\\n        for (int i=0;i<=n1;i++) {\\n            remainBuilder=new StringBuilder();\\n            cnt+=getRemain(s, s2, remainBuilder); // get the next remain string, returns the count of matching\\n            String remain=remainBuilder.toString();\\n            if ((k=stringList.indexOf(remain))!=-1) break; // if there is a loop, break\\n            stringList.add(remain); // record the remain string into arraylist \\n            countList.add(cnt);\\n            s=remain+s1; // append s1 to make a new string\\n        }\\n        // here, k is the beginning of the loop\\n        if (k==-1) return cnt/n2; // if there is no loop\\n        int countOfLoop=cnt-countList.get(k), loopLength=stringList.size()-k; // get matching count in the loop, and loop length\\n        cnt=countList.get(k);\\n        n1-=k;\\n        cnt+=countOfLoop*(n1/loopLength);\\n        n1%=loopLength; \\n        cnt+=countList.get(k+n1)-countList.get(k);\\n        return cnt/n2;\\n    }\\n\\n    // check if [s1. \\u221e] obtains s2\\n    private boolean ableToObtain(String s1, String s2) {\\n        boolean[] cnt=new boolean[26];\\n        for (char c: s1.toCharArray()) cnt[c-'a']=true;\\n        for (char c: s2.toCharArray()) {\\n            if (!cnt[c-'a']) return false;\\n        }\\n        return true;\\n    }\\n\\n    // get remain string after s1 obtains s2, return the matching count\\n    private int getRemain(String s1, String s2, StringBuilder remain) {\\n        int cnt=0, lastMatch=-1, p2=0;\\n        for (int p1=0;p1<s1.length();p1++) {\\n            if (s1.charAt(p1)==s2.charAt(p2)) {\\n                if (++p2==s2.length()) {\\n                    p2=0;\\n                    cnt++;\\n                    lastMatch=p1;\\n                }\\n            }\\n        }\\n        remain.append(s1.substring(lastMatch+1));\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95397,
                "title": "c-0ms-o-str1-length-str2-length",
                "content": "IDEA: \\n\\n**Given a str2, for each str, we can give a value v to this str such that, after greedily looking through str, our imaginary next step is to find str2[v].**\\nIn our problem, str is always (str1,n), with a given str1, so, we can take one more step and say that for each n, there is a unique v associated to n(i.e t0 (str,n)).\\n\\ndefine a division and a modulo between two strings as follow: \\n\\nstr/str2=argmax{i, (str2,i) can be obtained by str}\\nstr%str2=the v mentioned above associated with str.\\n\\nAll possible values of v is less than str2.size(), \\nso (str1,n)%str2 will begin to **repeat a pattern** after a certain n less than str2.size(). \\n(the pattern is the same because in the cases with the same v, our situations are exactly the same), \\nso is (str1,n)/str2-(str1,n+1)/str2 for the same reason. \\nWe can therefore precompute a table for all these values with O(str1.length*str2.length).\\n\\n(str1,n) can be divided in three parts:\\n\\nsth before pattern(A)    +    pattern parts(B)    +    sth after pattern(C)\\n\\nThe pattern does not necessarily begin in the first str1, we shall see if n is great enough so that there can be a pattern.\\n\\nThe last pattern(C) is not necessarily complete, we need to calculate it separately.\\n\\nWe can finish in just looking to the precomputed table and doing some simple maths. \\n\\n\\n```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;//case when n=0\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            for(int k=0;k<i;k++){\\n                if(posRest==rest[k]){b=k;last=i;break;}\\n            }\\n            rapport[i]=rap;rest[i]=posRest;\\n            if(b>=0)break;\\n        }\\n        int interval=last-b;\\n        if(b>=n1)return rapport[n1]/n2;\\n        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;\\n//corrected thanks to @zhiqing_xiao and @iaming \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;//case when n=0\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            for(int k=0;k<i;k++){\\n                if(posRest==rest[k]){b=k;last=i;break;}\\n            }\\n            rapport[i]=rap;rest[i]=posRest;\\n            if(b>=0)break;\\n        }\\n        int interval=last-b;\\n        if(b>=n1)return rapport[n1]/n2;\\n        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;\\n//corrected thanks to @zhiqing_xiao and @iaming \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95407,
                "title": "simple-c-code-16-lines-but-slow-179ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int len=s2.size();\\n        vector<int> dp(len);\\n        for(int i=0;i<len;i++){\\n            int start=i;\\n            for(char ch : s1)if(ch==s2[start%len])start++;\\n            if(start==i)return 0;\\n            dp[i]=start-i;\\n        }\\n        int idx=0;\\n        for(int i=0;i<n1;i++)idx+=dp[idx%len];\\n        return idx/len/n2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int len=s2.size();\\n        vector<int> dp(len);\\n        for(int i=0;i<len;i++){\\n            int start=i;\\n            for(char ch : s1)if(ch==s2[start%len])start++;\\n            if(start==i)return 0;\\n            dp[i]=start-i;\\n        }\\n        int idx=0;\\n        for(int i=0;i<n1;i++)idx+=dp[idx%len];\\n        return idx/len/n2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95429,
                "title": "python-69ms-solution",
                "content": "The main idea is to find a circle. A `circle` means m rounds of s1 has a subarray of n rounds of s2, and at the meantime starting from the same point of s1. \\n```\\nclass Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        start = {} # s2_idx : s1_round, s2_round\\n        s1_round, s2_round, s2_idx = 0, 0, 0\\n        while s1_round < n1:\\n            s1_round += 1\\n            for ch in s1:\\n                if ch == s2[s2_idx]:\\n                    s2_idx += 1\\n                    if s2_idx == len(s2):\\n                        s2_round += 1\\n                        s2_idx = 0\\n            if s2_idx in start:\\n                prev_s1_round, prev_s2_round = start[s2_idx]\\n                circle_s1_round, circle_s2_round = s1_round - prev_s1_round, s2_round - prev_s2_round\\n                res = (n1 - prev_s1_round) / circle_s1_round * circle_s2_round\\n                left_s1_round = (n1 - prev_s1_round) % circle_s1_round + prev_s1_round\\n                for key, val in start.iteritems():\\n                    if val[0] == left_s1_round:\\n                        res += val[1]\\n                        break\\n                return res / n2\\n            else:\\n                start[s2_idx] = (s1_round, s2_round)\\n        return s2_round / n2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        start = {} # s2_idx : s1_round, s2_round\\n        s1_round, s2_round, s2_idx = 0, 0, 0\\n        while s1_round < n1:\\n            s1_round += 1\\n            for ch in s1:\\n                if ch == s2[s2_idx]:\\n                    s2_idx += 1\\n                    if s2_idx == len(s2):\\n                        s2_round += 1\\n                        s2_idx = 0\\n            if s2_idx in start:\\n                prev_s1_round, prev_s2_round = start[s2_idx]\\n                circle_s1_round, circle_s2_round = s1_round - prev_s1_round, s2_round - prev_s2_round\\n                res = (n1 - prev_s1_round) / circle_s1_round * circle_s2_round\\n                left_s1_round = (n1 - prev_s1_round) % circle_s1_round + prev_s1_round\\n                for key, val in start.iteritems():\\n                    if val[0] == left_s1_round:\\n                        res += val[1]\\n                        break\\n                return res / n2\\n            else:\\n                start[s2_idx] = (s1_round, s2_round)\\n        return s2_round / n2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95426,
                "title": "accepted-8ms-java-solution-with-explanation",
                "content": "**IDEA:** \\nImagine s1 and s2 repeat inifinite times as below (for example s1 = \"abcd\" and \\ns2 = \"ab\") \\nabcdabcdabcd... \\nababab... \\nsay <i, j> are pairs of pointers to s1 and s2 in greedy matched characters, \\nin above example will be \\n<0, 0>, <1, 1>, <4, 2>, <5, 3>, <8, 4>, <9, 5>... \\nIn a brute force solution we can keep increasing i and j until i exceeds s1 x n1.\\n\\nSay the lengths of s1 and s2 are m1 and m2. It's easy to prove that: \\nIf there are two pairs <i1, j1>, <i2, j2> satisfying: \\n(i2 - i1) % m1 == 0 && (j2 - j1) % m2 == 0, \\nlet d1 = i2 - i1 and d2 = j2 - j1, \\nthen for all positive integer k, <i1 + d1 * k, j1 + d2 * k> will be pairs too.\\n\\nSo without brute force matching, my trick is to use above conclusion to push <i,\\nj> quickly to near the end of the expanded string s1 x n1, after the first <i1,\\nj1> and <i2, j2> pair is found. Here's the solution:\\n\\n```\\npublic class Solution {\\n\\tpublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n\\t\\tint m1 = s1.length();\\n\\t\\tint m2 = s2.length();\\n\\t\\tif (m1 == 0 || m2 == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tint i, j;\\n\\t\\t// extra code to remove unnecessary characters in s1\\n\\t\\tStringBuffer sb = new StringBuffer();\\n\\t\\tboolean[] used = new boolean[26];\\n\\t\\tint[] counts = new int[26]; // count of each character in s1\\n\\t\\tfor (i = 0; i < m2; i++) {\\n\\t\\t\\tj = s2.charAt(i) - 'a';\\n\\t\\t\\tused[j] = true;\\n\\t\\t}\\n\\t\\tfor (i = 0; i < m1; i++) {\\n\\t\\t\\tj = s1.charAt(i) - 'a';\\n\\t\\t\\tif (used[j])\\n\\t\\t\\t\\tsb.append(s1.charAt(i));\\n\\t\\t\\tcounts[j]++;\\n\\t\\t}\\n\\t\\tfor (i = 0; i < 26; i++) {\\n\\t\\t\\tif (used[i] && counts[i] == 0) // character in s2 not in s1\\n\\t\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\ts1 = sb.toString();\\n\\t\\tm1 = s1.length();\\n\\n\\t\\t// extra code to reduce s1 and s2 if it contains repeating pattern\\n\\t\\tfor (i = 1; i <= m1 / 2; i++) {\\n\\t\\t\\tif (m1 % i != 0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif (repeatAtK(s1, i)) {\\n\\t\\t\\t\\ts1 = s1.substring(0, i);\\n\\t\\t\\t\\tn1 *= m1 / i;\\n\\t\\t\\t\\tm1 = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (i = 1; i <= m2 / 2; i++) {\\n\\t\\t\\tif (m2 % i != 0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif (repeatAtK(s2, i)) {\\n\\t\\t\\t\\ts2 = s2.substring(0, i);\\n\\t\\t\\t\\tn2 *= m2 / i;\\n\\t\\t\\t\\tm2 = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint[][] ocs = new int[26][m1]; // occurrences of each character in s1\\n\\t\\tArrays.fill(counts, 0);\\n\\t\\tfor (i = 0; i < m1; i++) {\\n\\t\\t\\tj = s1.charAt(i) - 'a';\\n\\t\\t\\tocs[j][counts[j]] = i;\\n\\t\\t\\tcounts[j]++;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// simple case\\n\\t\\tif (m2 == 1) {\\n\\t\\t\\tj = s2.charAt(0) - 'a';\\n\\t\\t\\treturn counts[j]*n1/n2;\\n\\t\\t}\\n\\n\\t\\treturn getMaxRepetitionsProcessed(counts, ocs, n1, s2.toCharArray(), n2);\\n\\t}\\n\\n\\tpublic int getMaxRepetitionsProcessed(int[] counts, int[][] ocs, int n1, char[] ca2, int n2) {\\n\\t\\tint m1 = ocs[0].length;\\n\\t\\tint m2 = ca2.length;\\n\\t\\t// <i, j> pairs in slot mod m1/m2\\n\\t\\tint[][][] r = new int[m1][m2][2];\\n\\t\\t// pos[c][0] is the current index of character c in i, \\n\\t\\t// pos[c][1] is which occurrence in s1\\n\\t\\tint[][] pos = new int[26][2]; \\n\\t\\tint i, j, k, r1 = 0, r2 = 0;\\n\\t\\tboolean found = false;\\n\\t\\tfor (i = 0; i < 26; i++) {\\n\\t\\t\\tpos[i][0] = ocs[i][0];\\n\\t\\t}\\n\\t\\tfor (i = 0; i < m1; i++) {\\n\\t\\t\\tfor (j = 0; j < m2; j++) {\\n\\t\\t\\t\\tr[i][j][0] = -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (i = 0, j = 0; i < m1 * n1; i++, j++) {\\n\\t\\t\\tk = ca2[j % m2] - 'a';\\n\\t\\t\\t// move pos[k] to a position equal or after i by iterating k's occurrences\\n\\t\\t\\twhile (pos[k][0] < i) {\\n\\t\\t\\t\\tpos[k][1]++;\\n\\t\\t\\t\\tif (pos[k][1] < counts[k]) {\\n\\t\\t\\t\\t\\tpos[k][0] += ocs[k][pos[k][1]] - ocs[k][pos[k][1] - 1];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpos[k][1] = 0;\\n\\t\\t\\t\\t\\tpos[k][0] += ocs[k][0] + m1 - ocs[k][counts[k] - 1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ti = pos[k][0];\\n\\t\\t\\tif (i >= m1 * n1) {\\n\\t\\t\\t\\treturn j / m2 / n2;\\n\\t\\t\\t}\\n\\t\\t\\tr1 = i % m1;\\n\\t\\t\\tr2 = j % m2;\\n\\t\\t\\tif (!found && r[r1][r2][0] < 0) {\\n\\t\\t\\t\\tr[r1][r2][0] = i;\\n\\t\\t\\t\\tr[r1][r2][1] = j;\\n\\t\\t\\t} else if (!found) { // push by mod trick here\\n\\t\\t\\t\\tint d1 = i - r[r1][r2][0];\\n\\t\\t\\t\\tint d2 = j - r[r1][r2][1];\\n\\t\\t\\t\\tk = (m1 * n1 - i) / d1;\\n\\t\\t\\t\\ti += k * d1;\\n\\t\\t\\t\\tj += k * d2;\\n\\t\\t\\t\\tfor (r1 = 0; r1 < 26; r1++) { // update all pos[c] the same way as i\\n\\t\\t\\t\\t\\tpos[r1][0] += k * d1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfound = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn j / m2 / n2;\\n\\t}\\n\\n\\tpublic boolean repeatAtK(String s, int k) { // check if s is repeated every k characters\\n\\t\\tint m = s.length();\\n\\t\\tint x = m / k;\\n\\t\\tfor (int i = 0; i < k; i++) {\\n\\t\\t\\tfor (int j = 0; j < x; j++) {\\n\\t\\t\\t\\tif (s.charAt(i) != s.charAt(j * k + i))\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```\\n\\nRegarding the time complexity, the for loop should be less than 2 * m1 * m2\\ntimes according to pigeonhole theorem, and the while loop inside should be less\\nthant m1 (actually can be amortized to d1/d2), so the overall time complexity\\nshould be less than O(m1 * m1 * m2). I believe in reality it should be much less. \\n\\nUgly coding because I'm not good at it, just want to share this idea to see if \\nit makes sense. Any improvement is most welcome.",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\tpublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n\\t\\tint m1 = s1.length();\\n\\t\\tint m2 = s2.length();\\n\\t\\tif (m1 == 0 || m2 == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tint i, j;\\n\\t\\t// extra code to remove unnecessary characters in s1\\n\\t\\tStringBuffer sb = new StringBuffer();\\n\\t\\tboolean[] used = new boolean[26];\\n\\t\\tint[] counts = new int[26]; // count of each character in s1\\n\\t\\tfor (i = 0; i < m2; i++) {\\n\\t\\t\\tj = s2.charAt(i) - 'a';\\n\\t\\t\\tused[j] = true;\\n\\t\\t}\\n\\t\\tfor (i = 0; i < m1; i++) {\\n\\t\\t\\tj = s1.charAt(i) - 'a';\\n\\t\\t\\tif (used[j])\\n\\t\\t\\t\\tsb.append(s1.charAt(i));\\n\\t\\t\\tcounts[j]++;\\n\\t\\t}\\n\\t\\tfor (i = 0; i < 26; i++) {\\n\\t\\t\\tif (used[i] && counts[i] == 0) // character in s2 not in s1\\n\\t\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\ts1 = sb.toString();\\n\\t\\tm1 = s1.length();\\n\\n\\t\\t// extra code to reduce s1 and s2 if it contains repeating pattern\\n\\t\\tfor (i = 1; i <= m1 / 2; i++) {\\n\\t\\t\\tif (m1 % i != 0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif (repeatAtK(s1, i)) {\\n\\t\\t\\t\\ts1 = s1.substring(0, i);\\n\\t\\t\\t\\tn1 *= m1 / i;\\n\\t\\t\\t\\tm1 = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (i = 1; i <= m2 / 2; i++) {\\n\\t\\t\\tif (m2 % i != 0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif (repeatAtK(s2, i)) {\\n\\t\\t\\t\\ts2 = s2.substring(0, i);\\n\\t\\t\\t\\tn2 *= m2 / i;\\n\\t\\t\\t\\tm2 = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint[][] ocs = new int[26][m1]; // occurrences of each character in s1\\n\\t\\tArrays.fill(counts, 0);\\n\\t\\tfor (i = 0; i < m1; i++) {\\n\\t\\t\\tj = s1.charAt(i) - 'a';\\n\\t\\t\\tocs[j][counts[j]] = i;\\n\\t\\t\\tcounts[j]++;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// simple case\\n\\t\\tif (m2 == 1) {\\n\\t\\t\\tj = s2.charAt(0) - 'a';\\n\\t\\t\\treturn counts[j]*n1/n2;\\n\\t\\t}\\n\\n\\t\\treturn getMaxRepetitionsProcessed(counts, ocs, n1, s2.toCharArray(), n2);\\n\\t}\\n\\n\\tpublic int getMaxRepetitionsProcessed(int[] counts, int[][] ocs, int n1, char[] ca2, int n2) {\\n\\t\\tint m1 = ocs[0].length;\\n\\t\\tint m2 = ca2.length;\\n\\t\\t// <i, j> pairs in slot mod m1/m2\\n\\t\\tint[][][] r = new int[m1][m2][2];\\n\\t\\t// pos[c][0] is the current index of character c in i, \\n\\t\\t// pos[c][1] is which occurrence in s1\\n\\t\\tint[][] pos = new int[26][2]; \\n\\t\\tint i, j, k, r1 = 0, r2 = 0;\\n\\t\\tboolean found = false;\\n\\t\\tfor (i = 0; i < 26; i++) {\\n\\t\\t\\tpos[i][0] = ocs[i][0];\\n\\t\\t}\\n\\t\\tfor (i = 0; i < m1; i++) {\\n\\t\\t\\tfor (j = 0; j < m2; j++) {\\n\\t\\t\\t\\tr[i][j][0] = -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (i = 0, j = 0; i < m1 * n1; i++, j++) {\\n\\t\\t\\tk = ca2[j % m2] - 'a';\\n\\t\\t\\t// move pos[k] to a position equal or after i by iterating k's occurrences\\n\\t\\t\\twhile (pos[k][0] < i) {\\n\\t\\t\\t\\tpos[k][1]++;\\n\\t\\t\\t\\tif (pos[k][1] < counts[k]) {\\n\\t\\t\\t\\t\\tpos[k][0] += ocs[k][pos[k][1]] - ocs[k][pos[k][1] - 1];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpos[k][1] = 0;\\n\\t\\t\\t\\t\\tpos[k][0] += ocs[k][0] + m1 - ocs[k][counts[k] - 1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ti = pos[k][0];\\n\\t\\t\\tif (i >= m1 * n1) {\\n\\t\\t\\t\\treturn j / m2 / n2;\\n\\t\\t\\t}\\n\\t\\t\\tr1 = i % m1;\\n\\t\\t\\tr2 = j % m2;\\n\\t\\t\\tif (!found && r[r1][r2][0] < 0) {\\n\\t\\t\\t\\tr[r1][r2][0] = i;\\n\\t\\t\\t\\tr[r1][r2][1] = j;\\n\\t\\t\\t} else if (!found) { // push by mod trick here\\n\\t\\t\\t\\tint d1 = i - r[r1][r2][0];\\n\\t\\t\\t\\tint d2 = j - r[r1][r2][1];\\n\\t\\t\\t\\tk = (m1 * n1 - i) / d1;\\n\\t\\t\\t\\ti += k * d1;\\n\\t\\t\\t\\tj += k * d2;\\n\\t\\t\\t\\tfor (r1 = 0; r1 < 26; r1++) { // update all pos[c] the same way as i\\n\\t\\t\\t\\t\\tpos[r1][0] += k * d1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfound = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn j / m2 / n2;\\n\\t}\\n\\n\\tpublic boolean repeatAtK(String s, int k) { // check if s is repeated every k characters\\n\\t\\tint m = s.length();\\n\\t\\tint x = m / k;\\n\\t\\tfor (int i = 0; i < k; i++) {\\n\\t\\t\\tfor (int j = 0; j < x; j++) {\\n\\t\\t\\t\\tif (s.charAt(i) != s.charAt(j * k + i))\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95402,
                "title": "very-clean-and-short-7ms-java-solution-based-on-70664914-s-idea",
                "content": "Based on idea here: https://discuss.leetcode.com/topic/70667/c-0ms-o-str1-length-str2-length\\nThanks to @70664914 \\nAdded some early stop\\n```Java\\npublic class Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int[] reps = new int[102];\\n        int[] rests = new int[102];\\n        int posRest=0, repTime=0;\\n        int i=0, k=0;\\n        if(n1 <= 0) return 0;\\n        while(k==i) {\\n            i++;\\n            for(int j=0; j<s1.length(); j++) {\\n                if(s2.charAt(posRest) == s1.charAt(j)) {\\n                    posRest++;\\n                    if(posRest == s2.length()) {\\n                        repTime++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            if(i >= n1)\\n                return repTime / n2;\\n            for(k=0; k<i; k++){\\n                if(posRest == rests[k])\\n                    break;\\n            }\\n            reps[i] = repTime;\\n            rests[i] = posRest;\\n        }\\n        int interval = i-k;\\n        int repeatCount = (n1-k) / interval;\\n        int repeatTimes = repeatCount * (reps[i]-reps[k]);\\n        int remainTimes = reps[(n1-k) % interval + k];\\n        return (repeatTimes + remainTimes) / n2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\npublic class Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int[] reps = new int[102];\\n        int[] rests = new int[102];\\n        int posRest=0, repTime=0;\\n        int i=0, k=0;\\n        if(n1 <= 0) return 0;\\n        while(k==i) {\\n            i++;\\n            for(int j=0; j<s1.length(); j++) {\\n                if(s2.charAt(posRest) == s1.charAt(j)) {\\n                    posRest++;\\n                    if(posRest == s2.length()) {\\n                        repTime++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            if(i >= n1)\\n                return repTime / n2;\\n            for(k=0; k<i; k++){\\n                if(posRest == rests[k])\\n                    break;\\n            }\\n            reps[i] = repTime;\\n            rests[i] = posRest;\\n        }\\n        int interval = i-k;\\n        int repeatCount = (n1-k) / interval;\\n        int repeatTimes = repeatCount * (reps[i]-reps[k]);\\n        int remainTimes = reps[(n1-k) % interval + k];\\n        return (repeatTimes + remainTimes) / n2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 119679,
                "title": "brutal-force-optimization-easy-understanding-c",
                "content": "brutal force is simple. What we need to do is to find the repeating cycle and move the pointers forward. When the s2 ends and the s1 pointer is on the previous positions, then you get the repeating things.\\n\\nLet\\'s say s1 = \"abab\", s2= \"aabb\".\\n\\n```\\nabab abab abab abab abab\\na ab  ba  ab b a ab  b\\n      |      |       |\\np1:   1      3       1\\n```\\nIn the above chart, when string 2 ends, p1 positions are 1, 3, 1. Here we can find the repeating cycle, which consists of 3 s1 and 2 s2. Then we can calculate how many round are there to go and then easily move the points to the very end part.\\n```\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        for(auto c : s2) {\\n            // preventive checkings, it could be O(n), but who cares.\\n            if (s1.find(c) == string::npos) return 0;\\n        }\\n        int p1 = 0, p2 = 0, mark = 0;\\n        while(p1 < s1.length() * n1) {\\n            char c = s2[p2 % s2.length()];\\n            while(s1[p1 % s1.length()] != c && p1 < s1.length() * n1) p1 ++;\\n            p2++;\\n            p1++;\\n            // optimization part below\\n            if (p2 % s2.length() == 0) {\\n                if (p2 == s2.length()) {\\n                    mark = p1; // mark the position in s1, when the first s2 ends\\n                } else if (p1 % s1.length() == mark % s1.length()) {\\n                    // s1 reaches the same position, which means the repeating cycle found. \\n                    //Then we can leap forward.\\n                    int round = (s1.length() * n1 - p1) / (p1 - mark);\\n                    p1 += round * (p1 - mark);\\n                    p2 += round * (p2 - s2.length());\\n                }\\n            }\\n        }\\n        return p2 / s2.length() / n2;\\n    }\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nabab abab abab abab abab\\na ab  ba  ab b a ab  b\\n      |      |       |\\np1:   1      3       1\\n```\n```\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        for(auto c : s2) {\\n            // preventive checkings, it could be O(n), but who cares.\\n            if (s1.find(c) == string::npos) return 0;\\n        }\\n        int p1 = 0, p2 = 0, mark = 0;\\n        while(p1 < s1.length() * n1) {\\n            char c = s2[p2 % s2.length()];\\n            while(s1[p1 % s1.length()] != c && p1 < s1.length() * n1) p1 ++;\\n            p2++;\\n            p1++;\\n            // optimization part below\\n            if (p2 % s2.length() == 0) {\\n                if (p2 == s2.length()) {\\n                    mark = p1; // mark the position in s1, when the first s2 ends\\n                } else if (p1 % s1.length() == mark % s1.length()) {\\n                    // s1 reaches the same position, which means the repeating cycle found. \\n                    //Then we can leap forward.\\n                    int round = (s1.length() * n1 - p1) / (p1 - mark);\\n                    p1 += round * (p1 - mark);\\n                    p2 += round * (p2 - s2.length());\\n                }\\n            }\\n        }\\n        return p2 / s2.length() / n2;\\n    }\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 95420,
                "title": "c-3ms-find-reoccurence-and-skip",
                "content": "Every time we find a complete s2 in n1\\\\*s1, we record three things using a map:\\n* key: current position in s1\\n* value: current position in n\\\\*s1 and how many s2 have been found.\\n\\nLater, we check if current position in s1 has been recorded before, and if so, we can skip reoccurrence of all s1[i0:i](see what i0 and i mean in code below) in n1\\\\*s1.\\n\\n```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        unordered_map<int, pair<int, int>> r;\\n        \\n        int k = 0;\\n        for(int i = 0; i < s1.length()*n1;) {\\n            \\n            int rr = i % s1.length();\\n            if(r.find(rr) == r.end()) {\\n                r[rr] = make_pair(i, k);\\n                // cout << \"setup: \" << rr << ',' << i << ',' << k << endl;\\n            }\\n            else {\\n                // cout << rr << ',' << i << ',' << k << endl;\\n                auto i0 = r[rr].first;\\n                auto k0 = r[rr].second; // now, i - i0 == (k - k0) * s2.length()\\n                \\n                int n = (s1.length()*n1 - i0) / (i - i0); // we have n*(k - k0) complete s2 left\\n                \\n                // skip repeated patterns\\n                i = i0 + n*(i - i0);\\n                k = k0 + n*(k - k0);\\n            }\\n            \\n            for(int j = 0; i < s1.length()*n1 && j < s2.length(); ++ i, ++ j) {\\n                while(i < s1.length()*n1 && s1[i%s1.length()] != s2[j]) ++ i;\\n            }\\n            \\n            if(i >= s1.length()*n1) {\\n                break;\\n            }\\n            \\n            ++ k;\\n        }\\n        \\n        // cout << k << endl;\\n        return k / n2;\\n    }\\n    \\n    inline string repeat(string &s, int n) {\\n        string S;\\n        S.reserve(s.size()*n);\\n        while(n -- > 0) {\\n            S += s;\\n        }\\n        return S;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        unordered_map<int, pair<int, int>> r;\\n        \\n        int k = 0;\\n        for(int i = 0; i < s1.length()*n1;) {\\n            \\n            int rr = i % s1.length();\\n            if(r.find(rr) == r.end()) {\\n                r[rr] = make_pair(i, k);\\n                // cout << \"setup: \" << rr << ',' << i << ',' << k << endl;\\n            }\\n            else {\\n                // cout << rr << ',' << i << ',' << k << endl;\\n                auto i0 = r[rr].first;\\n                auto k0 = r[rr].second; // now, i - i0 == (k - k0) * s2.length()\\n                \\n                int n = (s1.length()*n1 - i0) / (i - i0); // we have n*(k - k0) complete s2 left\\n                \\n                // skip repeated patterns\\n                i = i0 + n*(i - i0);\\n                k = k0 + n*(k - k0);\\n            }\\n            \\n            for(int j = 0; i < s1.length()*n1 && j < s2.length(); ++ i, ++ j) {\\n                while(i < s1.length()*n1 && s1[i%s1.length()] != s2[j]) ++ i;\\n            }\\n            \\n            if(i >= s1.length()*n1) {\\n                break;\\n            }\\n            \\n            ++ k;\\n        }\\n        \\n        // cout << k << endl;\\n        return k / n2;\\n    }\\n    \\n    inline string repeat(string &s, int n) {\\n        string S;\\n        S.reserve(s.size()*n);\\n        while(n -- > 0) {\\n            S += s;\\n        }\\n        return S;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 496150,
                "title": "java-dp-like-solution",
                "content": "* iterate through S1 again and again, track the pointer position of S2 at the end of each S1 iteration\\n* continue until the S2 pointer comes back to previous position, which means we\\'ve found a cycle\\n\\t* break up into 3 parts: pre-cycle, in-cycle, post-cycle\\n\\t\\t* calculate loop count for the in-cycle part\\n\\t\\t* snitch pre-cycle and post-cycle together, and calculate the loop count for this combined parts\\n```\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int nn1 = s1.length();\\n        int nn2 = s2.length();\\n        \\n        int[][] records = new int[2][n1+1];\\n        Arrays.fill(records[0], -1);\\n        int index2 = 0, count = 0;\\n        int cycleStart = -1, cycleEnd = -1, cycleCount = -1;\\n        for (int i = 1; i <= n1; i++) {\\n            for (int j = 0; j < nn1; j++) {\\n                if (s1.charAt(j) == s2.charAt(index2)) {\\n                    index2++;\\n                }\\n                if (index2 == nn2) {\\n                    index2 = 0;\\n                    count++;\\n                }\\n            }\\n            for (int k = 1; k < i; k++) {\\n                if (records[0][k] == index2) { \\n                    // we find the cycle, record start/end/count and then quit the loop\\n                    cycleStart = k;\\n                    cycleEnd = i;\\n                    cycleCount = count - records[1][k];\\n                }\\n            }\\n            if (cycleStart != -1) {\\n                break;\\n            }\\n            records[0][i] = index2;\\n            records[1][i] = count;\\n        }\\n        \\n        if (cycleStart == -1) {\\n            return count / n2;\\n        }\\n        \\n        int res = 0;\\n        // calculate cycle\\n        int cycleN = (n1 - cycleStart) / (cycleEnd - cycleStart);\\n        res = cycleN * cycleCount;\\n        // snitich pre-cycle and post-cycle parts\\n        res += records[1][n1 - cycleN * (cycleEnd - cycleStart)];\\n        \\n        return res / n2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int nn1 = s1.length();\\n        int nn2 = s2.length();\\n        \\n        int[][] records = new int[2][n1+1];\\n        Arrays.fill(records[0], -1);\\n        int index2 = 0, count = 0;\\n        int cycleStart = -1, cycleEnd = -1, cycleCount = -1;\\n        for (int i = 1; i <= n1; i++) {\\n            for (int j = 0; j < nn1; j++) {\\n                if (s1.charAt(j) == s2.charAt(index2)) {\\n                    index2++;\\n                }\\n                if (index2 == nn2) {\\n                    index2 = 0;\\n                    count++;\\n                }\\n            }\\n            for (int k = 1; k < i; k++) {\\n                if (records[0][k] == index2) { \\n                    // we find the cycle, record start/end/count and then quit the loop\\n                    cycleStart = k;\\n                    cycleEnd = i;\\n                    cycleCount = count - records[1][k];\\n                }\\n            }\\n            if (cycleStart != -1) {\\n                break;\\n            }\\n            records[0][i] = index2;\\n            records[1][i] = count;\\n        }\\n        \\n        if (cycleStart == -1) {\\n            return count / n2;\\n        }\\n        \\n        int res = 0;\\n        // calculate cycle\\n        int cycleN = (n1 - cycleStart) / (cycleEnd - cycleStart);\\n        res = cycleN * cycleCount;\\n        // snitich pre-cycle and post-cycle parts\\n        res += records[1][n1 - cycleN * (cycleEnd - cycleStart)];\\n        \\n        return res / n2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947084,
                "title": "python-3-count-the-repetitions-t-m-34-ms-13-9-mb-100-96",
                "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720776,
                "title": "python-3-solution-with-clear-comments",
                "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        # hashtable to store the patterns\\n        patterns = {}\\n\\n        # pointers on s1 and s2\\n        p1, p2 = 0, 0\\n\\n        # number of occurance of s1 and s2 so far\\n        c1, c2 = 1, 0\\n\\n        # execute the loop when number of occurance of s1 has not been used up\\n        while c1 <= n1:\\n\\n            # if a character match is found, move p2 forward\\n            if s1[p1] == s2[p2]:\\n                p2 += 1\\n\\n                # p2 reaches the end of s2, meaning 1 occurance of s2\\n            if p2 == len(s2):\\n                c2 += 1\\n                p2 = 0\\n\\n                # store the pattern if not exists\\n                if p1 not in patterns:\\n                    patterns[p1] = (c1, c2)\\n\\n                # a repeat has been found, handle the repeat\\n                else:\\n                    # previous occurance of s1 and s2\\n                    prev_c1, prev_c2 = patterns[p1]\\n\\n                    # number of occurance of s1 and s2 in a single repeat\\n                    n_s1_repeat, n_s2_repeat = c1 - prev_c1, c2 - prev_c2\\n\\n                    # number of repeats\\n                    n_repeats = (n1 - prev_c1) // n_s1_repeat\\n\\n                    # number of s2 occurances in the repeats\\n                    c2_repeats = n_repeats * n_s2_repeat\\n\\n                    # the remain available occurances of s1\\n                    remain_c1 = (n1 - prev_c1) % n_s1_repeat\\n\\n                    # update c1 and c2\\n                    c1 = n1 - remain_c1\\n                    c2 = c2_repeats + prev_c2\\n\\n            # move forward p1 every iteration\\n            p1 += 1\\n\\n            # p1 reaches the end of s1, move it back to 0 and mark 1 occurance of s1\\n            if p1 == len(s1):\\n                c1 += 1\\n                p1 = 0\\n\\n        # divide c2 by n2 to get the result\\n        return c2 // n2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        # hashtable to store the patterns\\n        patterns = {}\\n\\n        # pointers on s1 and s2\\n        p1, p2 = 0, 0\\n\\n        # number of occurance of s1 and s2 so far\\n        c1, c2 = 1, 0\\n\\n        # execute the loop when number of occurance of s1 has not been used up\\n        while c1 <= n1:\\n\\n            # if a character match is found, move p2 forward\\n            if s1[p1] == s2[p2]:\\n                p2 += 1\\n\\n                # p2 reaches the end of s2, meaning 1 occurance of s2\\n            if p2 == len(s2):\\n                c2 += 1\\n                p2 = 0\\n\\n                # store the pattern if not exists\\n                if p1 not in patterns:\\n                    patterns[p1] = (c1, c2)\\n\\n                # a repeat has been found, handle the repeat\\n                else:\\n                    # previous occurance of s1 and s2\\n                    prev_c1, prev_c2 = patterns[p1]\\n\\n                    # number of occurance of s1 and s2 in a single repeat\\n                    n_s1_repeat, n_s2_repeat = c1 - prev_c1, c2 - prev_c2\\n\\n                    # number of repeats\\n                    n_repeats = (n1 - prev_c1) // n_s1_repeat\\n\\n                    # number of s2 occurances in the repeats\\n                    c2_repeats = n_repeats * n_s2_repeat\\n\\n                    # the remain available occurances of s1\\n                    remain_c1 = (n1 - prev_c1) % n_s1_repeat\\n\\n                    # update c1 and c2\\n                    c1 = n1 - remain_c1\\n                    c2 = c2_repeats + prev_c2\\n\\n            # move forward p1 every iteration\\n            p1 += 1\\n\\n            # p1 reaches the end of s1, move it back to 0 and mark 1 occurance of s1\\n            if p1 == len(s1):\\n                c1 += 1\\n                p1 = 0\\n\\n        # divide c2 by n2 to get the result\\n        return c2 // n2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95405,
                "title": "find-the-cycle-python-fast-with-explanation",
                "content": "This is a difficult problem (for me anyway). I kept thinking that there had to be a trick\\n\\nFirstly, if there is any character in `s2` that is not in `s1` then we can never obtain `[S2, M]` from `S1`.\\n\\nThen I step through `s1`, incrementing an index pointer in `s2` whenever characters match :\\n* When I reach the end of `s2`, go back to the start and increment the counter `s2_reps` that tells me how many complete copies of `s2` I have used.\\n* Similarly when I reach the end of `s1`, go back to the start and increment `s1_reps`.\\n* At then end of `s1` record in a dictionary a mapping from the next index to be matched in `s2` as key and the pair of `(s1_reps, s2_reps)` as value.\\n* If the key has been seen before then we are in a loop, every time we go through `s1` we are at the same position in `s2`. So we can break from stepping through the strings and work out how many loops we can go through for all of `[s1, n1]`.\\n\\n(Potentially we never find a loop and have reached `n1` repetitions of `s1` already so can just return `s2_reps // n2`)\\n\\nHaving found how many repetitions of `s1` and `s2` there are in a loop, we use as many loops as possible to go through `n1` copies of `s1`. Bear in mind that there may be some repetitions before the loop is entered.\\nThen all that remains is if we have not seen `n1` copies of `s1` after the final loop, step through the strings again until we reach `n1`.\\n\\nI suspect the code below could be made a little more efficient. Comments welcome! \\n```\\nclass Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n\\n        if any(c for c in set(s2) if c not in set(s1)):   # early return if impossible\\n            return 0\\n\\n        s2_index_to_reps = {0 : (0, 0)}   # mapping from index in s2 to numbers of repetitions of s1 and s2\\n        i, j = 0, 0\\n        s1_reps, s2_reps = 0, 0\\n\\n        while s1_reps < n1:\\n\\n            if s1[i] == s2[j]:\\n                j += 1     # move s2 pointer if chars match\\n            i += 1\\n\\n            if j == len(s2):\\n                j = 0\\n                s2_reps += 1\\n\\n            if i == len(s1):\\n                i = 0\\n                s1_reps += 1\\n                if j in s2_index_to_reps:   # loop found, same index in s2 as seen before\\n                    break\\n                s2_index_to_reps[j] = (s1_reps, s2_reps)\\n\\n        if s1_reps == n1:    # already used n1 copies of s1\\n            return s2_reps // n2\\n\\n        initial_s1_reps, initial_s2_reps = s2_index_to_reps[j]    # repetitions before loop starts\\n        loop_s1_reps = s1_reps - initial_s1_reps\\n        loop_s2_reps = s2_reps - initial_s2_reps\\n        loops = (n1 - initial_s1_reps) // loop_s1_reps\\n\\n        s2_reps = initial_s2_reps + loops * loop_s2_reps\\n        s1_reps = initial_s1_reps + loops * loop_s1_reps\\n\\n        while s1_reps < n1:   # if loop does not end with n1 copies of s1, keep going\\n\\n            if s1[i] == s2[j]:\\n                j += 1\\n            i += 1\\n\\n            if i == len(s1):\\n                i = 0\\n                s1_reps += 1\\n\\n            if j == len(s2):\\n                j = 0\\n                s2_reps += 1\\n\\n        return s2_reps // n2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n\\n        if any(c for c in set(s2) if c not in set(s1)):   # early return if impossible\\n            return 0\\n\\n        s2_index_to_reps = {0 : (0, 0)}   # mapping from index in s2 to numbers of repetitions of s1 and s2\\n        i, j = 0, 0\\n        s1_reps, s2_reps = 0, 0\\n\\n        while s1_reps < n1:\\n\\n            if s1[i] == s2[j]:\\n                j += 1     # move s2 pointer if chars match\\n            i += 1\\n\\n            if j == len(s2):\\n                j = 0\\n                s2_reps += 1\\n\\n            if i == len(s1):\\n                i = 0\\n                s1_reps += 1\\n                if j in s2_index_to_reps:   # loop found, same index in s2 as seen before\\n                    break\\n                s2_index_to_reps[j] = (s1_reps, s2_reps)\\n\\n        if s1_reps == n1:    # already used n1 copies of s1\\n            return s2_reps // n2\\n\\n        initial_s1_reps, initial_s2_reps = s2_index_to_reps[j]    # repetitions before loop starts\\n        loop_s1_reps = s1_reps - initial_s1_reps\\n        loop_s2_reps = s2_reps - initial_s2_reps\\n        loops = (n1 - initial_s1_reps) // loop_s1_reps\\n\\n        s2_reps = initial_s2_reps + loops * loop_s2_reps\\n        s1_reps = initial_s1_reps + loops * loop_s1_reps\\n\\n        while s1_reps < n1:   # if loop does not end with n1 copies of s1, keep going\\n\\n            if s1[i] == s2[j]:\\n                j += 1\\n            i += 1\\n\\n            if i == len(s1):\\n                i = 0\\n                s1_reps += 1\\n\\n            if j == len(s2):\\n                j = 0\\n                s2_reps += 1\\n\\n        return s2_reps // n2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95422,
                "title": "java-solution-with-explanation",
                "content": "Took reference from https://discuss.leetcode.com/topic/71256/easy-understanding-java-solution-with-detailed-explanation-21ms but tried to give more detailed explanation about the pattern math.\\n\\n```\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if (!verifyInput(s1, s2)) {\\n            return 0;\\n        }\\n\\n        int totalOccurrence = 0;\\n        String remaining = \"\", str = s1;\\n        boolean loopFound = false;\\n        Map<String, Integer> cycleIndex = new HashMap<String, Integer>();\\n        ArrayList<Integer> occurenceCountAtEachCycle = new ArrayList<Integer>(); \\n        \\n        for (int i = 0; i <= n1; i++) {\\n            StringBuilder sb = new StringBuilder();\\n            totalOccurrence += getRemaining(str, s2, sb);\\n            remaining = sb.toString();\\n\\n            if (cycleIndex.containsKey(remaining)) {\\n                loopFound = true;\\n                break;\\n            }\\n\\n            cycleIndex.put(remaining, i);\\n            \\n            occurenceCountAtEachCycle.add(totalOccurrence);\\n            \\n            str = remaining + s1; // append s1 to make a new string\\n        }\\n\\n        if (!loopFound) {\\n            return totalOccurrence / n2; // if there is no loop\\n        }\\n\\n        int indexBeforeLoop = cycleIndex.get(remaining);\\n        \\n        int occurrenceCountInLoopCycle = totalOccurrence - occurenceCountAtEachCycle.get(indexBeforeLoop);\\n       \\n       // represents the number of cycles required to complete a loop\\n        int loopCycleLength = occurenceCountAtEachCycle.size() - indexBeforeLoop;\\n        \\n        // resetting the total occurrence to cycle before loop happened\\n        totalOccurrence = occurenceCountAtEachCycle.get(indexBeforeLoop);\\n        \\n        // removing cycles from n1 before loop started. Adding 1 as n1 is 1 based and other index are 0 based\\n        n1 -= (indexBeforeLoop + 1);\\n        \\n        // total occurrence is number of occurrence before loop + number of occurrence in loops for the rest of n1\\n        totalOccurrence += occurrenceCountInLoopCycle * (n1 / loopCycleLength);\\n        \\n        // if loop cycle terminated prematurely then the remaining cycles should be accounted\\n        n1 %= loopCycleLength;\\n\\n        if(n1 != 0){\\n            // occurenceCountAtEachCycle.get(indexBeforeLoop) is required because we just want to add the left over cycles of incomplete loop.\\n            totalOccurrence += occurenceCountAtEachCycle.get(indexBeforeLoop + n1) - occurenceCountAtEachCycle.get(indexBeforeLoop);\\n        }\\n\\n        return totalOccurrence / n2;\\n    }\\n\\n    // check if s1 contains all s2 characters\\n    private boolean verifyInput(String s1, String s2) {\\n        boolean[] arr = new boolean[26];\\n\\n        for (char ch : s1.toCharArray()) {\\n            arr[ch - 'a'] = true;\\n        }\\n\\n        for (char ch : s2.toCharArray()) {\\n            if (!arr[ch - 'a']){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n\\n    // get remain string after s1 obtains s2, return the matching count\\n    private int getRemaining(String s1, String s2, StringBuilder remaining) {\\n        int count = 0, lastMatchIdx = -1, s2Idx = 0;\\n        for (int i = 0; i < s1.length(); i++) {\\n            if (s1.charAt(i) == s2.charAt(s2Idx)) {\\n                if (++s2Idx == s2.length()) {\\n                    s2Idx = 0;\\n                    count++;\\n                    lastMatchIdx = i;\\n                }\\n            }\\n        }\\n        remaining.append(s1.substring(lastMatchIdx + 1));\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if (!verifyInput(s1, s2)) {\\n            return 0;\\n        }\\n\\n        int totalOccurrence = 0;\\n        String remaining = \"\", str = s1;\\n        boolean loopFound = false;\\n        Map<String, Integer> cycleIndex = new HashMap<String, Integer>();\\n        ArrayList<Integer> occurenceCountAtEachCycle = new ArrayList<Integer>(); \\n        \\n        for (int i = 0; i <= n1; i++) {\\n            StringBuilder sb = new StringBuilder();\\n            totalOccurrence += getRemaining(str, s2, sb);\\n            remaining = sb.toString();\\n\\n            if (cycleIndex.containsKey(remaining)) {\\n                loopFound = true;\\n                break;\\n            }\\n\\n            cycleIndex.put(remaining, i);\\n            \\n            occurenceCountAtEachCycle.add(totalOccurrence);\\n            \\n            str = remaining + s1; // append s1 to make a new string\\n        }\\n\\n        if (!loopFound) {\\n            return totalOccurrence / n2; // if there is no loop\\n        }\\n\\n        int indexBeforeLoop = cycleIndex.get(remaining);\\n        \\n        int occurrenceCountInLoopCycle = totalOccurrence - occurenceCountAtEachCycle.get(indexBeforeLoop);\\n       \\n       // represents the number of cycles required to complete a loop\\n        int loopCycleLength = occurenceCountAtEachCycle.size() - indexBeforeLoop;\\n        \\n        // resetting the total occurrence to cycle before loop happened\\n        totalOccurrence = occurenceCountAtEachCycle.get(indexBeforeLoop);\\n        \\n        // removing cycles from n1 before loop started. Adding 1 as n1 is 1 based and other index are 0 based\\n        n1 -= (indexBeforeLoop + 1);\\n        \\n        // total occurrence is number of occurrence before loop + number of occurrence in loops for the rest of n1\\n        totalOccurrence += occurrenceCountInLoopCycle * (n1 / loopCycleLength);\\n        \\n        // if loop cycle terminated prematurely then the remaining cycles should be accounted\\n        n1 %= loopCycleLength;\\n\\n        if(n1 != 0){\\n            // occurenceCountAtEachCycle.get(indexBeforeLoop) is required because we just want to add the left over cycles of incomplete loop.\\n            totalOccurrence += occurenceCountAtEachCycle.get(indexBeforeLoop + n1) - occurenceCountAtEachCycle.get(indexBeforeLoop);\\n        }\\n\\n        return totalOccurrence / n2;\\n    }\\n\\n    // check if s1 contains all s2 characters\\n    private boolean verifyInput(String s1, String s2) {\\n        boolean[] arr = new boolean[26];\\n\\n        for (char ch : s1.toCharArray()) {\\n            arr[ch - 'a'] = true;\\n        }\\n\\n        for (char ch : s2.toCharArray()) {\\n            if (!arr[ch - 'a']){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n\\n    // get remain string after s1 obtains s2, return the matching count\\n    private int getRemaining(String s1, String s2, StringBuilder remaining) {\\n        int count = 0, lastMatchIdx = -1, s2Idx = 0;\\n        for (int i = 0; i < s1.length(); i++) {\\n            if (s1.charAt(i) == s2.charAt(s2Idx)) {\\n                if (++s2Idx == s2.length()) {\\n                    s2Idx = 0;\\n                    count++;\\n                    lastMatchIdx = i;\\n                }\\n            }\\n        }\\n        remaining.append(s1.substring(lastMatchIdx + 1));\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2777287,
                "title": "java-solution-4ms-runtime-with-brief-explanation",
                "content": "## Code \\u2615\\uFE0F\\n\\n```\\n// Count the repetitions\\n// LeetCode: https://leetcode.com/problems/count-the-repetitions/\\n\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int[] next = new int[s2.length() + 1];\\n        int[] count = new int[s2.length() + 1];\\n        int j = 0, cnt = 0;\\n        for (int k = 1; k <= n1; k++) {\\n            for (int i = 0; i < s1.length(); i++) {\\n                if (s1.charAt(i) == s2.charAt(j)) {\\n                    j++;\\n                    if (j == s2.length()) {\\n                        j = 0;\\n                        cnt++;\\n                    }\\n                }\\n            }\\n            count[k] = cnt;\\n            next[k] = j;\\n            for (int start = 0; start < k; start++) {\\n                if (next[start] == j) {\\n                    int prefixCount = count[start];\\n                    int patternCount = (count[k] - count[start]) * ((n1 - start) / (k - start));\\n                    int suffixCount = count[start + (n1 - start) % (k - start)] - count[start];\\n                    return (prefixCount + patternCount + suffixCount) / n2;\\n                }\\n            }\\n        }\\n        return count[n1] / n2;\\n    }\\n}\\n```\\n\\n## Explanation ..\\n\\n. For each repetition of s1, count the number of times we see s2\\n. Store the seen count for each repetition of s1\\n. Store the index of s2 where we stopped after each repetition of s1\\n. For each repetition of s1, check if we\\'ve seen this index of s2 before\\n. If we have, then we\\'ve found a repeating pattern\\n. The number of times we see s2 in the pattern is (count[k] - count[start])\\n. The number of times we see s2 outside the pattern is (count[start + (n1 - start) % (k - start)] - count[start])\\n. The number of times we see s2 in total is (prefixCount + patternCount + suffixCount)\\n. The number of times we see s2 in total divided by n2 is the answer\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Count the repetitions\\n// LeetCode: https://leetcode.com/problems/count-the-repetitions/\\n\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int[] next = new int[s2.length() + 1];\\n        int[] count = new int[s2.length() + 1];\\n        int j = 0, cnt = 0;\\n        for (int k = 1; k <= n1; k++) {\\n            for (int i = 0; i < s1.length(); i++) {\\n                if (s1.charAt(i) == s2.charAt(j)) {\\n                    j++;\\n                    if (j == s2.length()) {\\n                        j = 0;\\n                        cnt++;\\n                    }\\n                }\\n            }\\n            count[k] = cnt;\\n            next[k] = j;\\n            for (int start = 0; start < k; start++) {\\n                if (next[start] == j) {\\n                    int prefixCount = count[start];\\n                    int patternCount = (count[k] - count[start]) * ((n1 - start) / (k - start));\\n                    int suffixCount = count[start + (n1 - start) % (k - start)] - count[start];\\n                    return (prefixCount + patternCount + suffixCount) / n2;\\n                }\\n            }\\n        }\\n        return count[n1] / n2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589114,
                "title": "python-3-short-simple-solution",
                "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        dp = []\\n        for i in range(len(s2)):\\n            start = i\\n            cnt = 0\\n            for j in range(len(s1)):\\n                if s1[j] == s2[start]:\\n                    start += 1\\n                    if start == len(s2):\\n                        start = 0\\n                        cnt += 1\\n            dp.append((start,cnt))\\n        res = 0\\n        next = 0\\n        for _ in range(n1):\\n            res += dp[next][1]\\n            next = dp[next][0]\\n        return res // n2\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        dp = []\\n        for i in range(len(s2)):\\n            start = i\\n            cnt = 0\\n            for j in range(len(s1)):\\n                if s1[j] == s2[start]:\\n                    start += 1\\n                    if start == len(s2):\\n                        start = 0\\n                        cnt += 1\\n            dp.append((start,cnt))\\n        res = 0\\n        next = 0\\n        for _ in range(n1):\\n            res += dp[next][1]\\n            next = dp[next][0]\\n        return res // n2\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95424,
                "title": "java-solution-with-o-s1-length-2-s2-length",
                "content": "To determine if a string `str2` is contained in another string `str1`, there is a naive `O(n)` solution with `n = str1.length`: from start to end, simply match each character in `str2` greedily with those in `str1`. If there is a such match for all characters in `str2`, we conclude `str2` is contained in `str1`, otherwise it is not.\\n\\nTo find the number of `str2` contained in `str1`, we can proceed similarly except now we need to keep track of the number of matches found for `str2`. Still this can be done in `O(n)` time.\\n\\nSo for our problem, \"**to find the maximum number of `S2=[s2,n2]` contained in `S1=[s1,n1]`**\", we have the following naive solution:\\n\\n```\\npublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n    int M = 0, p = 0, q = 0;\\n    \\t\\n    for (int i = 0; i < n1; i++) {\\n    \\tfor (int j = 0; j < s1.length(); j++) {\\n    \\t    if (s1.charAt(j) == s2.charAt(q)) {\\n    \\t\\tq++;\\n    \\t\\t\\t\\t\\n    \\t\\tif (q == s2.length()) {\\n    \\t\\t    p++;\\n    \\t\\t    q = 0;\\n    \\t\\t}\\n    \\t\\t\\t\\n    \\t\\tif (p == n2) {\\n    \\t\\t    M++;\\n    \\t\\t    p = 0;\\n    \\t\\t}\\n    \\t    }\\n    \\t}\\n    }\\n    \\t\\n    return M;\\n}\\n```\\nAnd as you would expect, this failed the extreme case when `s1.length = 100` and `n1 = 10^6` (i.e., `S1.length = 10^8`). So let's see how we can do better.\\n\\nThe key idea here is to take advantage of the fact that `S1` consists of repeating strings (i.e. `s1`). The naive solution ignored this information and did a blind scan for the whole string, which led to the poor time performance.\\n\\nFirst we will assume `s1` contains at least once of each distinct character in `s2`, otherwise no `S2` can be contained in `S1`. Second, instead of finding the number of `S2` contained in `S1`, we will find the number of `s2` contained in `S1`. The former can be obtained by dividing the latter by `n2`.\\n\\nTo implement the above idea, here are some observations:\\n1. Each character with index `i` (`0 <= i < N1`) in string `S1` will correspond to some index `j` in string `s1`, with `j = i % s1.length` and `N1 = S1.length`.\\n\\n2. Each match of the whole string `s2` in `S1` will end at some index in `S1`. Starting from the first match, let's label the end index for each match in `S1` as `i1, i2, i3 ...`, and the corresponding indices in `s1` as `j1, j2, j3 ...`.\\n\\n3. Let `ip` and `iq` be the end indices in `S1` of the first two matches whose corresponding indices in `s1`, `jp` and `jq`, are equal. Let `S1(ip, iq]` denote the substring between them, `l = iq - ip` as its length and `m` as the total number of `s2` contained in it. Then the substring `S1(ip, N1)` can be constructed by concatenating `t` times the substring `S1(ip, iq]` plus possibly some residual part `S1(r, N1)`, where `t = (N1 - ip - 1) / l`  (integer part) and `r = ip + t * l  + 1`. And the total number of `s2` contained in the substring `S1(ip, r)` will simply be the product `m * l`. Also the total length of the residual substring is less than `l`.\\n(**Note**: for the substring notations, `(` or `)` means exclusive, `[` or `]` inclusive)\\n\\n4. It can be shown that if the two indices `ip` and `iq` in part 3 exist, they can be found in `O(s1.length^2 * s2.length)` time. The reasoning is as follows: first since `s1` contains at least once of each distinct character in `s2`, starting from any index in `S1`, it will take at most `s1.length * (s2.length + 1)` characters to find a match of `s2` in `S1` (consider the worst case scenario in which it takes a whole `s1` string to match each single character in `s2`). Second there are at most `s1.length` matches of `s2` in `S1` whose corresponding indices in `s1` are all different, as each match must take one index in `s1` and we have only up to `s1.length` different positions available. Therefore the index in `s1` of the `(s1.length + 1)`-th match must coincide with some previous match. In total `ip` and `iq` will be found within `s1.length^2 * (s2.length + 1)` characters. This also sets the upper limit on `l` where `l = iq - ip`, which in turn bounds the total length of the residual substring in part 3.\\n\\n5. The total number of `s2` contained in `S1` can be obtained from three parts: the number contained in substring `S1[0, ip]`, the number contained in substring `S1(ip, r)` and lastly the number contained in the residual substring `S1[r, N1)`. The number in the second part can be obtained in constant time (simple mathematical computation) while those in the first and third parts can both be obtained in `O(s1.length^2 * s2.length)` time. Therefore our total time complexity will be at most `O(s1.length^2 * s2.length)`.\\n\\nHere is the java program for the improved solution with brief explanation as follows:\\n1. First make sure `s1` contains at least once of each distinct character in `s2`.\\n\\n2. For each match of `s2` in `S1`, we will record two piece of information: its end index in `S1` and the total number of matches up to this end index. Since we will have at most `s1.length` \"distinct\" matches, we will use an array of the same length as `s1` to hold matches found so far. The element in the array will be another array of length 2, whose first element denotes the end index and second element the total matches.\\n\\n3. We will proceed in the way described in the naive solution to identify possible matches. If we do not make it all the way to the end of `S1`, then a repeating match is found. We can obtain `l`, `m` and `t` to compute the number of `s2` contained in the second part as well as scanning the residual substring to get that in the third part. The final answer will be the total number in all three parts divided by `n2`.\\n\\n```\\npublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n    Set<Character> set = new HashSet<>(s1.length());\\n\\n    for (char ch : s1.toCharArray()) set.add(ch);\\n\\n    for (char ch : s2.toCharArray()) {\\n    \\tif (!set.contains(ch)) return 0;\\n    }\\n    \\t\\n    int[][] arr = new int[s1.length()][2];\\n\\n    for (int i = 0; i < s1.length(); i++) {\\n        arr[i][0] = -1;\\n    }\\n    \\t\\n    int i = 0, j = 0, k = 0, c = 0, N1 = n1 * s1.length();\\n    \\t\\n    for (; i < N1; i++, j = i % s1.length(), k %= s2.length()) {\\n    \\tif (s1.charAt(j) == s2.charAt(k) && ++k == s2.length()) {\\n    \\t    c++;\\n\\t    if (arr[j][0] >= 0) break;\\n\\t    arr[j][0] = i;\\n\\t    arr[j][1] = c;\\n\\t}\\n    }\\n    \\t\\n    if (i < N1) {\\n        int l = i - arr[j][0];\\n        int m = c - arr[j][1];\\n        int t = (N1 - arr[j][0] - 1) / l;\\n        c = arr[j][1] + m * t;\\n        i = arr[j][0] + l * t + 1;\\n        \\t\\n        for (j = i % s1.length(), k = 0; i < N1; i++, j = i % s1.length(), k %= s2.length()) {\\n            if (s1.charAt(j) == s2.charAt(k) && ++k == s2.length()) {\\n    \\t\\tc++;\\n    \\t    }\\n        }\\n    }\\n    \\t\\n    return c / n2;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n    int M = 0, p = 0, q = 0;\\n    \\t\\n    for (int i = 0; i < n1; i++) {\\n    \\tfor (int j = 0; j < s1.length(); j++) {\\n    \\t    if (s1.charAt(j) == s2.charAt(q)) {\\n    \\t\\tq++;\\n    \\t\\t\\t\\t\\n    \\t\\tif (q == s2.length()) {\\n    \\t\\t    p++;\\n    \\t\\t    q = 0;\\n    \\t\\t}\\n    \\t\\t\\t\\n    \\t\\tif (p == n2) {\\n    \\t\\t    M++;\\n    \\t\\t    p = 0;\\n    \\t\\t}\\n    \\t    }\\n    \\t}\\n    }\\n    \\t\\n    return M;\\n}\\n```\n```\\npublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n    Set<Character> set = new HashSet<>(s1.length());\\n\\n    for (char ch : s1.toCharArray()) set.add(ch);\\n\\n    for (char ch : s2.toCharArray()) {\\n    \\tif (!set.contains(ch)) return 0;\\n    }\\n    \\t\\n    int[][] arr = new int[s1.length()][2];\\n\\n    for (int i = 0; i < s1.length(); i++) {\\n        arr[i][0] = -1;\\n    }\\n    \\t\\n    int i = 0, j = 0, k = 0, c = 0, N1 = n1 * s1.length();\\n    \\t\\n    for (; i < N1; i++, j = i % s1.length(), k %= s2.length()) {\\n    \\tif (s1.charAt(j) == s2.charAt(k) && ++k == s2.length()) {\\n    \\t    c++;\\n\\t    if (arr[j][0] >= 0) break;\\n\\t    arr[j][0] = i;\\n\\t    arr[j][1] = c;\\n\\t}\\n    }\\n    \\t\\n    if (i < N1) {\\n        int l = i - arr[j][0];\\n        int m = c - arr[j][1];\\n        int t = (N1 - arr[j][0] - 1) / l;\\n        c = arr[j][1] + m * t;\\n        i = arr[j][0] + l * t + 1;\\n        \\t\\n        for (j = i % s1.length(), k = 0; i < N1; i++, j = i % s1.length(), k %= s2.length()) {\\n            if (s1.charAt(j) == s2.charAt(k) && ++k == s2.length()) {\\n    \\t\\tc++;\\n    \\t    }\\n        }\\n    }\\n    \\t\\n    return c / n2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95403,
                "title": "a-15ms-java-solution-with-explanation-brute-force-memorization",
                "content": "I was enlightened by the @shawngao's brute force solution, the post can be found [here](https://discuss.leetcode.com/topic/70707/ugly-java-brute-force-solution-but-accepted-1088ms).\\n\\nThe basic idea is to repeat s1 in n1 times, and count how many s2 we can find. The answer number of s2  we can find divide by n2. \\n\\nTo accelerate the process, a map is used to find \"loop\".\\n\\nThe following is the code\\n\\nPoint[][] map is used for find loop.\\nint[] p1 and int[] p2 are the counters.\\n\\n```\\npublic class Solution {\\n\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int len1 = s1.length();\\n        int len2 = s2.length();\\n        Point[][] map = new Point[len1][len2];\\n        int[] p1 = new int[2];\\n        int[] p2 = new int[2];\\n        while (p1[1] < n1) {\\n            char c = s2.charAt(p2[0]);\\n            while (p1[1] < n1 && s1.charAt(p1[0]) != c) {\\n                inc(p1, len1);\\n            }\\n            if (map[p1[0]][p2[0]] == null) {\\n                map[p1[0]][p2[0]] = new Point(p1[1], p2[1]);\\n            } else {\\n                int deltaP1 = p1[1] - map[p1[0]][p2[0]].x;\\n                int deltaP2 = p2[1] - map[p1[0]][p2[0]].y;\\n                int k = (n1 - deltaP1 - 1) / deltaP1;\\n                p1[1] += k * deltaP1;\\n                p2[1] += k * deltaP2;\\n            }\\n            inc(p1, len1);\\n            inc(p2, len2);\\n        }\\n        return p2[1] / n2;\\n    }\\n\\n    public void inc(int[] p, int len) {\\n        if (++ p[0] == len) {\\n            p[0] = 0;\\n            p[1] += 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int len1 = s1.length();\\n        int len2 = s2.length();\\n        Point[][] map = new Point[len1][len2];\\n        int[] p1 = new int[2];\\n        int[] p2 = new int[2];\\n        while (p1[1] < n1) {\\n            char c = s2.charAt(p2[0]);\\n            while (p1[1] < n1 && s1.charAt(p1[0]) != c) {\\n                inc(p1, len1);\\n            }\\n            if (map[p1[0]][p2[0]] == null) {\\n                map[p1[0]][p2[0]] = new Point(p1[1], p2[1]);\\n            } else {\\n                int deltaP1 = p1[1] - map[p1[0]][p2[0]].x;\\n                int deltaP2 = p2[1] - map[p1[0]][p2[0]].y;\\n                int k = (n1 - deltaP1 - 1) / deltaP1;\\n                p1[1] += k * deltaP1;\\n                p2[1] += k * deltaP2;\\n            }\\n            inc(p1, len1);\\n            inc(p2, len2);\\n        }\\n        return p2[1] / n2;\\n    }\\n\\n    public void inc(int[] p, int len) {\\n        if (++ p[0] == len) {\\n            p[0] = 0;\\n            p[1] += 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754336,
                "title": "precomputation-brute-force-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    count how many element from a given index of s2 match whole \\n    string of s1 that is for a single n1 , so we have to count \\n    all n1 and just increse index of s2 . and add max match len.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    count how many element from a given index of s2 match whole \\n    string of s1 that is for a single n1 , so we have to count \\n    all n1 and just increse index of s2 . and add max match len.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int len1=s1.size(),len2=s2.size();\\n        vector<int>inc(len2,0);\\n        for(int i=0;i<len2;i++){\\n            int ptr1=0,ptr2=i;\\n            while(ptr1<len1){\\n                if(s1[ptr1]==s2[ptr2%len2]){\\n                    ptr1++;\\n                    ptr2++;\\n                }\\n                else ptr1++;\\n            }\\n            inc[i]=ptr2-i;\\n        }\\n        int ptr=0,mx_match_len=0;\\n        for(int i=1;i<=n1;i++){\\n            mx_match_len+=inc[ptr];\\n            ptr+=inc[ptr];\\n            ptr%=len2;\\n        }\\n        return mx_match_len/(n2*len2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int len1=s1.size(),len2=s2.size();\\n        vector<int>inc(len2,0);\\n        for(int i=0;i<len2;i++){\\n            int ptr1=0,ptr2=i;\\n            while(ptr1<len1){\\n                if(s1[ptr1]==s2[ptr2%len2]){\\n                    ptr1++;\\n                    ptr2++;\\n                }\\n                else ptr1++;\\n            }\\n            inc[i]=ptr2-i;\\n        }\\n        int ptr=0,mx_match_len=0;\\n        for(int i=1;i<=n1;i++){\\n            mx_match_len+=inc[ptr];\\n            ptr+=inc[ptr];\\n            ptr%=len2;\\n        }\\n        return mx_match_len/(n2*len2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594109,
                "title": "bestest-solution-ever-in-javascript",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string} s1\\n * @param {number} n1\\n * @param {string} s2\\n * @param {number} n2\\n * @return {number}\\n */\\nvar getMaxRepetitions = function(s1, n1, s2, n2) {\\n    let idx2 = 0;\\n    \\n    let doWhile = true;\\n    let strCounter = 0;\\n    let sumChars = 0;\\n    let iterations = 0;\\n    while (doWhile && iterations < n1) {\\n        for (let idx1 = 0; idx1 < s1.length; idx1++) {\\n            const char1 = s1[idx1];\\n            const char2 = s2[idx2];\\n            if (char1 === char2) {\\n                sumChars++;\\n                idx2++;\\n                if (sumChars === s2.length) {\\n                    strCounter ++;\\n                    sumChars = 0;\\n                    idx2 = 0;\\n                }\\n            }\\n        }\\n        if (sumChars === 0) {\\n            doWhile = false;\\n        }\\n        iterations++;\\n    }\\n    return Math.floor((strCounter / n2) * (n1 / iterations));\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {string} s1\\n * @param {number} n1\\n * @param {string} s2\\n * @param {number} n2\\n * @return {number}\\n */\\nvar getMaxRepetitions = function(s1, n1, s2, n2) {\\n    let idx2 = 0;\\n    \\n    let doWhile = true;\\n    let strCounter = 0;\\n    let sumChars = 0;\\n    let iterations = 0;\\n    while (doWhile && iterations < n1) {\\n        for (let idx1 = 0; idx1 < s1.length; idx1++) {\\n            const char1 = s1[idx1];\\n            const char2 = s2[idx2];\\n            if (char1 === char2) {\\n                sumChars++;\\n                idx2++;\\n                if (sumChars === s2.length) {\\n                    strCounter ++;\\n                    sumChars = 0;\\n                    idx2 = 0;\\n                }\\n            }\\n        }\\n        if (sumChars === 0) {\\n            doWhile = false;\\n        }\\n        iterations++;\\n    }\\n    return Math.floor((strCounter / n2) * (n1 / iterations));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2674639,
                "title": "c-easy-to-understand-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            for(int k=0;k<i;k++){\\n                if(posRest==rest[k]){b=k;last=i;break;}\\n            }\\n            rapport[i]=rap;rest[i]=posRest;\\n            if(b>=0)break;\\n        }\\n        int interval=last-b;\\n        if(b>=n1)return rapport[n1]/n2;\\n        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            for(int k=0;k<i;k++){\\n                if(posRest==rest[k]){b=k;last=i;break;}\\n            }\\n            rapport[i]=rap;rest[i]=posRest;\\n            if(b>=0)break;\\n        }\\n        int interval=last-b;\\n        if(b>=n1)return rapport[n1]/n2;\\n        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1128061,
                "title": "c-solution-slow-but-easy-to-understand-find-lcm-of-both-the-strings-shorter-code",
                "content": "```\\nlong a=0,b=0;\\n    void lcm(string s1, long n1, string s2, long n2)\\n    {\\n        int i=0,j=0;\\n        bool pos=false;\\n        while(1)\\n        {\\n            while(i<s1.length() && j<s2.length() && a<n1)\\n            {\\n                if(i==0 && j==0 && pos)\\n                    return;\\n                pos=true;\\n                if(s1[i]==s2[j])\\n                    j++;\\n                if(j==s2.length())\\n                {\\n                    b++;\\n                    j=0;\\n                }\\n                i++;\\n                if(i==s1.length())\\n                {\\n                    a++;\\n                    i=0;\\n                }\\n            }\\n            if(a==n1)\\n                return;\\n        }\\n    }\\n    int getMaxRepetitions(string s1, long n1, string s2, long n2) {\\n        if(n1==0 || n2==0)\\n            return 0;\\n        lcm(s1,n1,s2,n2);\\n        return (long)(n1*b)/(long)(a*n2);\\n    }",
                "solutionTags": [],
                "code": "```\\nlong a=0,b=0;\\n    void lcm(string s1, long n1, string s2, long n2)\\n    {\\n        int i=0,j=0;\\n        bool pos=false;\\n        while(1)\\n        {\\n            while(i<s1.length() && j<s2.length() && a<n1)\\n            {\\n                if(i==0 && j==0 && pos)\\n                    return;\\n                pos=true;\\n                if(s1[i]==s2[j])\\n                    j++;\\n                if(j==s2.length())\\n                {\\n                    b++;\\n                    j=0;\\n                }\\n                i++;\\n                if(i==s1.length())\\n                {\\n                    a++;\\n                    i=0;\\n                }\\n            }\\n            if(a==n1)\\n                return;\\n        }\\n    }\\n    int getMaxRepetitions(string s1, long n1, string s2, long n2) {\\n        if(n1==0 || n2==0)\\n            return 0;\\n        lcm(s1,n1,s2,n2);\\n        return (long)(n1*b)/(long)(a*n2);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 791499,
                "title": "rust-translated-8ms-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn get_max_repetitions(s1: String, n1: i32, s2: String, n2: i32) -> i32 {\\n        if n1 == 0 {\\n            return 0;\\n        };\\n        let mut indices = vec![0; n1 as usize + 1];\\n        let mut counts = vec![0; n1 as usize + 1];\\n        let mut index = 0;\\n        let mut count = 0;\\n        for i in 1..=n1 as usize {\\n            for j in 0..s1.len() {\\n                if s1.as_bytes()[j] == s2.as_bytes()[index] {\\n                    index += 1;\\n                }\\n                if index == s2.len() {\\n                    index = 0;\\n                    count += 1;\\n                }\\n            }\\n            counts[i] = count;\\n            indices[i] = index;\\n            for k in 0..i {\\n                if indices[k] == index {\\n                    let pre_count = counts[k];\\n                    let pattern_count = (n1 - k as i32) / (i - k) as i32 * (counts[i] - pre_count);\\n                    let remain_count = counts[k + (n1 as usize - k) % (i - k)] - pre_count;\\n                    return (pre_count + pattern_count + remain_count) / n2;\\n                }\\n            }\\n        }\\n        counts[n1 as usize] / n2\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_get_max_repetitions() {\\n        assert_eq!(\\n            Solution::get_max_repetitions(\"acb\".to_string(), 4, \"ab\".to_string(), 2),\\n            2\\n        )\\n    }\\n\\n    #[test]\\n    fn test_get_max_repetitions_02() {\\n        assert_eq!(\\n            Solution::get_max_repetitions(\"aaa\".to_string(), 20, \"aaaaa\".to_string(), 1),\\n            12\\n        )\\n    }\\n\\n    #[test]\\n    fn test_get_max_repetitions_03() {\\n        assert_eq!(\\n            Solution::get_max_repetitions(\"bacaba\".to_string(), 3, \"abacab\".to_string(), 1),\\n            2\\n        )\\n    }\\n\\n    #[test]\\n    fn test_get_max_repetitions_04() {\\n        assert_eq!(\\n            Solution::get_max_repetitions(\"ecbafedcba\".to_string(), 3, \"abcdef\".to_string(), 1),\\n            1\\n        )\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn get_max_repetitions(s1: String, n1: i32, s2: String, n2: i32) -> i32 {\\n        if n1 == 0 {\\n            return 0;\\n        };\\n        let mut indices = vec![0; n1 as usize + 1];\\n        let mut counts = vec![0; n1 as usize + 1];\\n        let mut index = 0;\\n        let mut count = 0;\\n        for i in 1..=n1 as usize {\\n            for j in 0..s1.len() {\\n                if s1.as_bytes()[j] == s2.as_bytes()[index] {\\n                    index += 1;\\n                }\\n                if index == s2.len() {\\n                    index = 0;\\n                    count += 1;\\n                }\\n            }\\n            counts[i] = count;\\n            indices[i] = index;\\n            for k in 0..i {\\n                if indices[k] == index {\\n                    let pre_count = counts[k];\\n                    let pattern_count = (n1 - k as i32) / (i - k) as i32 * (counts[i] - pre_count);\\n                    let remain_count = counts[k + (n1 as usize - k) % (i - k)] - pre_count;\\n                    return (pre_count + pattern_count + remain_count) / n2;\\n                }\\n            }\\n        }\\n        counts[n1 as usize] / n2\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_get_max_repetitions() {\\n        assert_eq!(\\n            Solution::get_max_repetitions(\"acb\".to_string(), 4, \"ab\".to_string(), 2),\\n            2\\n        )\\n    }\\n\\n    #[test]\\n    fn test_get_max_repetitions_02() {\\n        assert_eq!(\\n            Solution::get_max_repetitions(\"aaa\".to_string(), 20, \"aaaaa\".to_string(), 1),\\n            12\\n        )\\n    }\\n\\n    #[test]\\n    fn test_get_max_repetitions_03() {\\n        assert_eq!(\\n            Solution::get_max_repetitions(\"bacaba\".to_string(), 3, \"abacab\".to_string(), 1),\\n            2\\n        )\\n    }\\n\\n    #[test]\\n    fn test_get_max_repetitions_04() {\\n        assert_eq!(\\n            Solution::get_max_repetitions(\"ecbafedcba\".to_string(), 3, \"abcdef\".to_string(), 1),\\n            1\\n        )\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 777733,
                "title": "java-1ms-100-time-55-4-space-only-array-used-in-detail-explaination-o-l-m",
                "content": "Key word: Regular, Cycle, Math;\\n\\nIdea: \\n\\nStep 1: As we should not brute force answer, we need to seperate it to a small problem, I did it wrong here in my first thought. I divided it to how many characters it need from s1 to form s2. This is trivial as after first round of choosing the character, the start of next round may not be start at the same character with same idx in s1.\\n\\nStep 2: Ok, we extend problem to how many s2 we can form when we endAt same character with same idx in s1, here is the cycle we want to find.\\neg. AAA and AA,\\n\\n1st Round: AA, we stop at idx 1 of s1 to collect s2(ie AA)\\n\\n2nd Round: AAA | A, we stop at idx 0 of second s1 to collect s2(A|A)\\n\\n3rd Round: AAA | AAA, we stop at idx 2 of second s1 to collect s2(AA)\\n\\n4th Round: AAA | AAA | AA, we stop at idx1 of third s1 to collect s2(AA)\\n\\n5th Round: There is not 5th round as we have already find a Cycle(1st and 4th round both stop at idx1) which means that \\n**every    3  +   3  +  2 = 8  characters we can collect 4 s2;**\\n\\t\\t    (AAA | AAA | AA)  \\n\\nso this is ideal scenario as we can start at first one. Generally, our first match might start at characters in s1 other than first one\\neg NBA and AB, it starts from second character. How about we refine our cycle length by deleting the header, so it will be\\n\\n1st Round: NB**A | NB**A, we stop at idx 1 of second s1 (A|NB) to collect BA \\n\\n2nd Round: NBA | NB**A | NB**A we stop at idx 1 of third s1 to collect s2(B|A), here is cycle, \\n\\nThe cycle length is 3 + 3 + 2 - 2 = 6;\\n(NBA | NBA | NBA | - NB)\\n\\nCool, we got length of cycle now, and we also know the total length of S1 is s1.length * n1, we can know how many cycles in S1, with the regular we got above, we can know in the cycles, how many s2 we can collect by #of Cycle * s2 per cycle\\n\\nWhat about remainning characters? They are capable to form s2 as well. Recall to how we find cycle, we defined in every round that how many s2 we can collect when we endAt specific idx. so we can get number of extra s2 that we collect from remaining characters;\\n\\nHere we go, we got total number of s2 we can collect from s1 by s2 in cycle + s2 in remaining characters.\\n\\nGiven repeating number n2 of s2, we can know how many s2 + s2 + ... + s2 we can get by total number of s2 / n2;\\n\\nConclusively, it will be **(# of s2 in cycle + # of s2 in remaining charaters) / n2**, by doing so, you can beat 100%, if not, ask Xfinity or Verizon for it. \\n\\n```\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int len1 = s1.length(), len2 = s2.length();\\n\\t\\t// for detecting cycle\\n        boolean[] endAt = new boolean[len1];\\n        char[] chs1 = s1.toCharArray(), chs2 = s2.toCharArray();\\n\\t\\t// how many s1 we use and how many s2 we collect when we endAt specific\\n        int[] nums1 = new int[len1], nums2 = new int[len1];\\n        \\n        int tltS1Len = len1 * n1;\\n        \\n        int startIdx = s1.indexOf(chs2[0]);\\n        if(startIdx == -1){\\n            return 0;\\n        }\\n        \\n        int s2n = 0, s1n = 0, curIdx = 0, prevIdx = -1;\\n        while(s1n * len1 + curIdx < tltS1Len){\\n            for(char c : chs2){\\n                curIdx = s1.indexOf(c, prevIdx + 1);\\n                \\n                if(curIdx == -1 && prevIdx == -1){\\n                    return 0;\\n                }\\n                prevIdx = curIdx;\\n                if(curIdx == -1){\\n                    ++s1n;\\n                    curIdx = s1.indexOf(c, prevIdx + 1);\\n                }\\n                prevIdx = curIdx;\\n            }\\n            // cycle found\\n            if(endAt[curIdx]){\\n                break;\\n            }\\n            \\n            prevIdx = curIdx;\\n            ++s2n;\\n            endAt[curIdx] = true;\\n            nums1[curIdx] = s1n;\\n            nums2[curIdx] = s2n; \\n        }\\n\\t\\t\\n        int cycleLen = (s1n - nums1[curIdx]) * len1;\\n        if(cycleLen == 0){\\n            return 0;\\n        }\\n        int nS2 = (tltS1Len - startIdx - 1) / cycleLen * s2n;\\n        int remain = (tltS1Len - startIdx - 1) % cycleLen;\\n        \\n        int extraNum = 0;\\n        for(int i = 0; i < len1; ++i){\\n            if(!endAt[i]){\\n                continue;\\n            }\\n            \\n            if(remain >= i + nums1[i] * len1){\\n                extraNum = Math.max(nums2[i], extraNum);\\n            }\\n        }\\n        \\n        return (nS2 + extraNum) / n2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int len1 = s1.length(), len2 = s2.length();\\n\\t\\t// for detecting cycle\\n        boolean[] endAt = new boolean[len1];\\n        char[] chs1 = s1.toCharArray(), chs2 = s2.toCharArray();\\n\\t\\t// how many s1 we use and how many s2 we collect when we endAt specific\\n        int[] nums1 = new int[len1], nums2 = new int[len1];\\n        \\n        int tltS1Len = len1 * n1;\\n        \\n        int startIdx = s1.indexOf(chs2[0]);\\n        if(startIdx == -1){\\n            return 0;\\n        }\\n        \\n        int s2n = 0, s1n = 0, curIdx = 0, prevIdx = -1;\\n        while(s1n * len1 + curIdx < tltS1Len){\\n            for(char c : chs2){\\n                curIdx = s1.indexOf(c, prevIdx + 1);\\n                \\n                if(curIdx == -1 && prevIdx == -1){\\n                    return 0;\\n                }\\n                prevIdx = curIdx;\\n                if(curIdx == -1){\\n                    ++s1n;\\n                    curIdx = s1.indexOf(c, prevIdx + 1);\\n                }\\n                prevIdx = curIdx;\\n            }\\n            // cycle found\\n            if(endAt[curIdx]){\\n                break;\\n            }\\n            \\n            prevIdx = curIdx;\\n            ++s2n;\\n            endAt[curIdx] = true;\\n            nums1[curIdx] = s1n;\\n            nums2[curIdx] = s2n; \\n        }\\n\\t\\t\\n        int cycleLen = (s1n - nums1[curIdx]) * len1;\\n        if(cycleLen == 0){\\n            return 0;\\n        }\\n        int nS2 = (tltS1Len - startIdx - 1) / cycleLen * s2n;\\n        int remain = (tltS1Len - startIdx - 1) % cycleLen;\\n        \\n        int extraNum = 0;\\n        for(int i = 0; i < len1; ++i){\\n            if(!endAt[i]){\\n                continue;\\n            }\\n            \\n            if(remain >= i + nums1[i] * len1){\\n                extraNum = Math.max(nums2[i], extraNum);\\n            }\\n        }\\n        \\n        return (nS2 + extraNum) / n2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757668,
                "title": "java-while-loop-o-len-s1",
                "content": "Ref: https://leetcode.com/problems/count-the-repetitions/discuss/95401/Ugly-Java-brute-force-solution-but-accepted.-1088ms.\\n```\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        char[] a1 = s1.toCharArray(), a2 = s2.toCharArray();\\n        int l1 = a1.length, l2 = a2.length, c1 = 0, c2 = 0, i = 0, j = 0;\\n        while (c1 < n1) {\\n            if (a1[i] == a2[j]) {\\n                if (++j == l2) {\\n                    j = 0;\\n                    c2++;\\n                }\\n            }\\n            if (++i == l1) {\\n                i = 0;\\n                c1++;\\n            }\\n        }\\n        return c2 / n2;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        char[] a1 = s1.toCharArray(), a2 = s2.toCharArray();\\n        int l1 = a1.length, l2 = a2.length, c1 = 0, c2 = 0, i = 0, j = 0;\\n        while (c1 < n1) {\\n            if (a1[i] == a2[j]) {\\n                if (++j == l2) {\\n                    j = 0;\\n                    c2++;\\n                }\\n            }\\n            if (++i == l1) {\\n                i = 0;\\n                c1++;\\n            }\\n        }\\n        return c2 / n2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 632449,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if(s1==null || s2==null || s2.length()*n2 > s1.length()*n1) return 0;\\n        if(s2==\"\") return 0;\\n        \\n        int str2Index = 0;\\n        int count = 0;\\n        int k=0;\\n        while(k<n1)\\n        {\\n            for(int i=0;i<s1.length();i++){\\n                if(s1.charAt(i)==s2.charAt(str2Index))\\n                    str2Index++;\\n                if(str2Index==(s2.length())){\\n                    str2Index=0;\\n                    count++;\\n                }\\n            }\\n            k++;\\n            if(str2Index==0)\\n            {\\n                if(n1%2==0 || n1 < 2)\\n                    count*=n1/k;\\n                else\\n                    count=(count*(n1-1)/k)+1;\\n                break;\\n            }\\n        }\\n\\n        return count/n2;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if(s1==null || s2==null || s2.length()*n2 > s1.length()*n1) return 0;\\n        if(s2==\"\") return 0;\\n        \\n        int str2Index = 0;\\n        int count = 0;\\n        int k=0;\\n        while(k<n1)\\n        {\\n            for(int i=0;i<s1.length();i++){\\n                if(s1.charAt(i)==s2.charAt(str2Index))\\n                    str2Index++;\\n                if(str2Index==(s2.length())){\\n                    str2Index=0;\\n                    count++;\\n                }\\n            }\\n            k++;\\n            if(str2Index==0)\\n            {\\n                if(n1%2==0 || n1 < 2)\\n                    count*=n1/k;\\n                else\\n                    count=(count*(n1-1)/k)+1;\\n                break;\\n            }\\n        }\\n\\n        return count/n2;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 553058,
                "title": "python-binary-search-for-m-inverse-1-m",
                "content": "Most posts are using pattern-finding method, which is excellent and fast (~40 ms)\\nHere I provide a Binary Search solution, which is a bit slow(~380 ms) but pretty straightforward to understand.\\n\\nBasically, we are required to find biggest M, satisfying s2x(n2xM) is subsequence of s1xn1.\\nsuppose we find M=10, then we know that for M=9,8,7,6...the subsequence condition should also hold. Therefore, we could use Binary Search to find M.\\n\\nHowever, for most tranditional binary search pattern (lo=mid+1 & hi=mid), they are not directly useable for upper-bound-finding case like this problem. ```we need to convert upper-bound-finding problem to be a lower-bound-finding problem```. Thus, the solution is: \\nwe use Binary Search algorithm to find the ```lower-bound of 1/M```, which ``corresponds to upper-bound of M``.\\n\\nThe following is the explanation for function issubseq(s2, n2, s1, n1).\\ninitially, we count the number of s1 for ```matching single s2```, we call it ```s1_used```, usually there would be a half-used s1 for matching s2\\'s tail, which is between ```best case``` and ```worst case```.\\n\\nso the ```best case``` would be ```s1_used s1``` cover ```single s2```, and  ```n2*s1_used s1``` cover ```n2 s2```\\nthe ```worst case``` would be ```(s1_used+1) s1``` cover ```single s2```, and ```n2*(s1_used+1) s1``` cover ```n2 s2```.\\n\\nthus, if ```n1 <  n2*s1_used``` for best case, return ```False```.\\nif ```n1 >=  n2*(s1_used+1)``` for worst case, return ```True```.\\nfinally, the hard part is what if n1 is between best case and worst case?\\n\\nIn this situation, we will try to match another single s2 again from the end index of previous matching, until we meet the above two extreme conditions or ```there is no half-used s1 when a full s2-matching is done```.\\n\\n```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        \\n        def divide_gcd(n1, n2):\\n            m, n = n1, n2\\n            while m % n:\\n                m, n = n, m % n\\n            return n1 // n, n2 // n\\n        \\n        def issubseq(s2, n2, s1, n1):  # return True/False s2*n2 is the subsequence of s1*n1\\n            s2_used = 0\\n            s1_used, s1_sidx = 0, 0\\n            while True:\\n                for ch in s2:\\n                    j = s1.find(ch, s1_sidx)\\n                    if j == -1:\\n                        s1_used += 1\\n                        j = s1.find(ch, 0)\\n                    s1_sidx = j + 1\\n                s2_used += 1\\n                if s1.find(s2[0], s1_sidx) == -1:\\n                    s1_used += 1\\n                    return s1_used * n2 <= s2_used * n1  # rewrite the original condition: s1_used / s2_used >= n2 / n1\\n                if s1_used * n2 >= s2_used * n1:\\n                    return False\\n                if s1_used * n2 + n2 <= s2_used * n1:\\n                    return True\\n        \\n        if not set(s2).issubset(set(s1)):\\n            return 0\\n        if len(s1) * n1 < len(s2) * n2:\\n            return 0\\n        \\n        n1, n2 = divide_gcd(n1, n2)\\n        lo, hi = (len(s2) * n2) / (len(s1) * n1), 10**5\\n        while lo + 1e-11 < hi:\\n            mid = (lo + hi) / 2\\n            if issubseq(s2, n2*(int(1/mid)+1), s1, n1):\\n                hi = mid\\n            else:\\n                lo = mid\\n        return int(1/lo)\\n```",
                "solutionTags": [],
                "code": "```we need to convert upper-bound-finding problem to be a lower-bound-finding problem```\n```lower-bound of 1/M```\n```matching single s2```\n```s1_used```\n```best case```\n```worst case```\n```best case```\n```s1_used s1```\n```single s2```\n```n2*s1_used s1```\n```n2 s2```\n```worst case```\n```(s1_used+1) s1```\n```single s2```\n```n2*(s1_used+1) s1```\n```n2 s2```\n```n1 <  n2*s1_used```\n```False```\n```n1 >=  n2*(s1_used+1)```\n```True```\n```there is no half-used s1 when a full s2-matching is done```\n```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        \\n        def divide_gcd(n1, n2):\\n            m, n = n1, n2\\n            while m % n:\\n                m, n = n, m % n\\n            return n1 // n, n2 // n\\n        \\n        def issubseq(s2, n2, s1, n1):  # return True/False s2*n2 is the subsequence of s1*n1\\n            s2_used = 0\\n            s1_used, s1_sidx = 0, 0\\n            while True:\\n                for ch in s2:\\n                    j = s1.find(ch, s1_sidx)\\n                    if j == -1:\\n                        s1_used += 1\\n                        j = s1.find(ch, 0)\\n                    s1_sidx = j + 1\\n                s2_used += 1\\n                if s1.find(s2[0], s1_sidx) == -1:\\n                    s1_used += 1\\n                    return s1_used * n2 <= s2_used * n1  # rewrite the original condition: s1_used / s2_used >= n2 / n1\\n                if s1_used * n2 >= s2_used * n1:\\n                    return False\\n                if s1_used * n2 + n2 <= s2_used * n1:\\n                    return True\\n        \\n        if not set(s2).issubset(set(s1)):\\n            return 0\\n        if len(s1) * n1 < len(s2) * n2:\\n            return 0\\n        \\n        n1, n2 = divide_gcd(n1, n2)\\n        lo, hi = (len(s2) * n2) / (len(s1) * n1), 10**5\\n        while lo + 1e-11 < hi:\\n            mid = (lo + hi) / 2\\n            if issubseq(s2, n2*(int(1/mid)+1), s1, n1):\\n                hi = mid\\n            else:\\n                lo = mid\\n        return int(1/lo)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 543506,
                "title": "python-solution-with-finding-a-cycle",
                "content": "The idea is to find the number of occurences of s2 in S1 and to find a cycle in s1.\\nHere is the code:\\n```\\ndef solve(s1, n1, s2, n2):\\n    s1l, s2l, S1L = len(s1), len(s2), len(s1) * n1\\n    # Maps from idx in s1 to \\n    #   (num characters from begin, num occurences of s2)\\n    numChars = { 0: (0, 0) } \\n    i, j = 0, 0\\n    s2Cnt = 0\\n    cntr = 10002\\n    while cntr and i < S1L:\\n        cntr -= 1\\n        idxi, idxj = i % s1l, j % s2l\\n        if s2[idxj] == s1[idxi]:\\n            j += 1\\n            if j % s2l == 0: s2Cnt += 1\\n        i += 1\\n        idxi, idxj = i % s1l, j % s2l\\n        if j and idxj == 0:\\n            if idxi not in numChars:\\n                # save the current idx of occurence of s2\\n                numChars[idxi] = (i, s2Cnt)\\n            else:\\n                # found a cycle\\n                charsInCycle, occurencesBefore = i - numChars[idxi][0], numChars[idxi][1]\\n                numberOfCycles = (S1L - i) // charsInCycle\\n                s2Cnt += (s2Cnt - occurencesBefore) * numberOfCycles\\n                i += numberOfCycles * charsInCycle\\n                # go till end normally\\n                while i < S1L:\\n                    if s1[i % s1l]==s2[j % s2l]:\\n                        j += 1\\n                        if j % s2l == 0:\\n                            s2Cnt += 1\\n                    i += 1\\n                return s2Cnt // n2\\n    return s2Cnt // n2\\n\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        return solve(s1,n1,s2,n2)\\n```",
                "solutionTags": [],
                "code": "```\\ndef solve(s1, n1, s2, n2):\\n    s1l, s2l, S1L = len(s1), len(s2), len(s1) * n1\\n    # Maps from idx in s1 to \\n    #   (num characters from begin, num occurences of s2)\\n    numChars = { 0: (0, 0) } \\n    i, j = 0, 0\\n    s2Cnt = 0\\n    cntr = 10002\\n    while cntr and i < S1L:\\n        cntr -= 1\\n        idxi, idxj = i % s1l, j % s2l\\n        if s2[idxj] == s1[idxi]:\\n            j += 1\\n            if j % s2l == 0: s2Cnt += 1\\n        i += 1\\n        idxi, idxj = i % s1l, j % s2l\\n        if j and idxj == 0:\\n            if idxi not in numChars:\\n                # save the current idx of occurence of s2\\n                numChars[idxi] = (i, s2Cnt)\\n            else:\\n                # found a cycle\\n                charsInCycle, occurencesBefore = i - numChars[idxi][0], numChars[idxi][1]\\n                numberOfCycles = (S1L - i) // charsInCycle\\n                s2Cnt += (s2Cnt - occurencesBefore) * numberOfCycles\\n                i += numberOfCycles * charsInCycle\\n                # go till end normally\\n                while i < S1L:\\n                    if s1[i % s1l]==s2[j % s2l]:\\n                        j += 1\\n                        if j % s2l == 0:\\n                            s2Cnt += 1\\n                    i += 1\\n                return s2Cnt // n2\\n    return s2Cnt // n2\\n\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        return solve(s1,n1,s2,n2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241512,
                "title": "o-m-n-python3-solution",
                "content": "\\nIn my code, the first function defined what \"contain\" is and the second function is to find maximum m.\\n\\nWe know that, in the best case:\\n    S1 = s1*n1\\n    S2 = s2*n2\\nWe compute the quotient of lengths of S1 and S2, which is M in the code and M is the best repetition we can get.\\nAnd count down from M, return the repetition as long as S1 contains S2.\\n\\nFor example:\\nif the length of S1 is 12, and S2\\'s length is 3, the largest (best) m could be 4, or less, \\nif 4*S2 can\\'t meet the condition, then let m be 3, and check again.\\nThis way, we only check 4 times at worst.\\n\\n```\\ndef Contain(L1,L2):\\n    for i in range(len(L2)):\\n        if L2[i] in L1:\\n            L1 = L1[L1.index(L2[i]):]\\n        else:\\n            return False\\n    return True\\n\\ndef getMaxRepetitions(s1,n1,s2,n2):\\n    S1 = s1*n1\\n    S2 = s2*n2\\n    M = int(len(S1)//len(S2))\\n    for m in range(M,1,-1):\\n        if Contain(S1,S2*m):\\n            return m\\n\\n\\n```\\n\\n ===================================================== 4/22/2019 Update =====================================================\\n\\nThanks to @luzi82 for pointing out my problem.\\nIn this part, if the range is from M to 1, it\\'ll exclude m=1\\n```\\nfor m in range(M,1,-1):\\n        if Contain(S1,S2*m):\\n            return m\\n```\\nI changed it into:\\n```\\nfor m in range(M,0,-1):\\n        if Contain(S1,S2*m):\\n            return m\\n```\\nAnd it worked for the cases of 1 repetition.\\n\\nAnd as for the case:\\ns1=\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\nn1=1000000\\nRunning time is up to 48s \\nThe main part slowing things down is the calculation: S1 = s1n1\\nWhen n1 is really large, this algorithm could be really slow.\\n\\nWhat\\'s sarcastic is that I used the title \\'fast solution\\' when I first posted this answer.\\nI\\'ll keep updated on this section with better solution. \\nAnd you\\'re very welcome to give me some feedback and to let me know how to improve the algorithm. \\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef Contain(L1,L2):\\n    for i in range(len(L2)):\\n        if L2[i] in L1:\\n            L1 = L1[L1.index(L2[i]):]\\n        else:\\n            return False\\n    return True\\n\\ndef getMaxRepetitions(s1,n1,s2,n2):\\n    S1 = s1*n1\\n    S2 = s2*n2\\n    M = int(len(S1)//len(S2))\\n    for m in range(M,1,-1):\\n        if Contain(S1,S2*m):\\n            return m\\n\\n\\n```\n```\\nfor m in range(M,1,-1):\\n        if Contain(S1,S2*m):\\n            return m\\n```\n```\\nfor m in range(M,0,-1):\\n        if Contain(S1,S2*m):\\n            return m\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 178774,
                "title": "use-next-array-java-solution",
                "content": "```\\nclass Solution{\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int len1 = s1.length();\\n        int len2 = s2.length();\\n        boolean c[] = new boolean[26];\\n        for (int k = 0; k < len1; k++) {\\n            c[s1.charAt(k) - \\'a\\'] = true;\\n        }\\n\\n        for (int k = 0; k < len2; k++) {\\n            if (!c[s2.charAt(k) - \\'a\\']) {\\n                return 0;\\n            }\\n        }\\n\\n\\n        int[] dp = new int[len1];\\n        for (int i = 0; i < len1; i++) {\\n            dp[i] = findNextIndex(s1, s2, i);\\n        }\\n\\n        int []fast = new int[len1];\\n        for (int i = 0; i < len1; i++) {\\n            int t = i;\\n            int step = 0;\\n            for (int j = 0; j < 1000; j++) {\\n                step += dp[t];\\n                t = t + dp[t];\\n                t %= len1;\\n            }\\n    \\n            fast[i] = step;\\n        }\\n\\n        int i = 0;\\n        int limit = len1 * n1;\\n        int sum = 0;\\n        while(i < limit) {\\n            if (dp[i%len1] < 0) break;\\n            int fastNext = i + fast[i%len1];\\n            if (fastNext <= limit) {\\n                i = fastNext;\\n                sum+=1000;\\n                continue;\\n            }\\n\\n            i = i + dp[i%len1];\\n            if (i <= limit)\\n            sum++;\\n           \\n        }\\n\\n        return sum/n2;\\n    }\\n\\n    private int findNextIndex(String s1, String s2, int i) {\\n        int j = 0;\\n        int step = 0;\\n        while(j < s2.length()) {\\n            if (s1.charAt(i) == s2.charAt(j)) {\\n                j++;\\n            }\\n\\n            i++;\\n            step++;\\n            i %= s1.length();\\n        }\\n        return step;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int len1 = s1.length();\\n        int len2 = s2.length();\\n        boolean c[] = new boolean[26];\\n        for (int k = 0; k < len1; k++) {\\n            c[s1.charAt(k) - \\'a\\'] = true;\\n        }\\n\\n        for (int k = 0; k < len2; k++) {\\n            if (!c[s2.charAt(k) - \\'a\\']) {\\n                return 0;\\n            }\\n        }\\n\\n\\n        int[] dp = new int[len1];\\n        for (int i = 0; i < len1; i++) {\\n            dp[i] = findNextIndex(s1, s2, i);\\n        }\\n\\n        int []fast = new int[len1];\\n        for (int i = 0; i < len1; i++) {\\n            int t = i;\\n            int step = 0;\\n            for (int j = 0; j < 1000; j++) {\\n                step += dp[t];\\n                t = t + dp[t];\\n                t %= len1;\\n            }\\n    \\n            fast[i] = step;\\n        }\\n\\n        int i = 0;\\n        int limit = len1 * n1;\\n        int sum = 0;\\n        while(i < limit) {\\n            if (dp[i%len1] < 0) break;\\n            int fastNext = i + fast[i%len1];\\n            if (fastNext <= limit) {\\n                i = fastNext;\\n                sum+=1000;\\n                continue;\\n            }\\n\\n            i = i + dp[i%len1];\\n            if (i <= limit)\\n            sum++;\\n           \\n        }\\n\\n        return sum/n2;\\n    }\\n\\n    private int findNextIndex(String s1, String s2, int i) {\\n        int j = 0;\\n        int step = 0;\\n        while(j < s2.length()) {\\n            if (s1.charAt(i) == s2.charAt(j)) {\\n                j++;\\n            }\\n\\n            i++;\\n            step++;\\n            i %= s1.length();\\n        }\\n        return step;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95395,
                "title": "nice-fast-ish-115ms-simple-bruteforce-java-complete-with-unit-test-that-s-right",
                "content": "Code should be self-explanatory\\n\\n```\\nimport org.junit.jupiter.api.Test;\\n\\nimport java.util.HashSet;\\nimport java.util.Set;\\n\\nimport static org.junit.jupiter.api.Assertions.assertEquals;\\n\\npublic class Solution {\\n\\n    private int countS2inS1(final char[] s1, final char[] s2) {\\n        int count = 0;\\n        int s2Pointer = 0;\\n\\n        for (final char c1 : s1) {\\n            if (c1 == s2[s2Pointer]) {\\n                s2Pointer++;\\n\\n                if (s2Pointer == s2.length) {\\n                    s2Pointer = 0;\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public int getMaxRepetitions(final String s1, final int n1, final String s2, final int n2) {\\n        final Set<Character> s1Chars = new HashSet<>();\\n\\n        for (final char c1 : s1.toCharArray()) {\\n            s1Chars.add(c1);\\n        }\\n\\n        final Set<Character> s2Chars = new HashSet<>();\\n\\n        for (final char c2 : s2.toCharArray()) {\\n            s2Chars.add(c2);\\n        }\\n\\n        if (s1Chars.size() == 1 && s2Chars.size() == 1 && s1Chars.iterator().next() == s2Chars.iterator().next()) {\\n            return (s1.length() * n1) / (s2.length() * n2);\\n        }\\n\\n        final StringBuilder sb1 = new StringBuilder();\\n\\n        for (int i = 0; i < (n1 / n2); i++) {\\n            sb1.append(s1);\\n        }\\n\\n        if (sb1.length() == 0) {\\n            sb1.append(s1);\\n            return Math.max(0, countS2inS1(sb1.toString().toCharArray(), s2.toCharArray()) - 1);\\n        }\\n\\n        return countS2inS1(sb1.toString().toCharArray(), s2.toCharArray());\\n    }\\n\\n    @Test\\n    public void test() {\\n        assertEquals(2, new Solution().getMaxRepetitions(\"acb\", 4, \"ab\", 2));\\n        assertEquals(4, new Solution().getMaxRepetitions(\"aaa\", 3, \"aa\", 1));\\n        assertEquals(7, new Solution().getMaxRepetitions(\"baba\", 11, \"baab\", 1));\\n        assertEquals(1, new Solution().getMaxRepetitions(\"adasfdgdftadwfwfereredsfssas\", 500, \"fw\", 555));\\n        assertEquals(100000000, new Solution().getMaxRepetitions(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", 1000000, \"a\", 1));\\n        assertEquals(200000, new Solution().getMaxRepetitions(\"aahumeaylnlfdxfircvscxggbwkfnqduxwfnfozvsrtkjprepggxrpnrvystmwcysyycqpevikeffmznimkkasvwsrenazkycxf\", 1000000, \"aac\", 10));\\n        assertEquals(0, new Solution().getMaxRepetitions(\"musicforever\", 10, \"lovelive\", 100000));\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport org.junit.jupiter.api.Test;\\n\\nimport java.util.HashSet;\\nimport java.util.Set;\\n\\nimport static org.junit.jupiter.api.Assertions.assertEquals;\\n\\npublic class Solution {\\n\\n    private int countS2inS1(final char[] s1, final char[] s2) {\\n        int count = 0;\\n        int s2Pointer = 0;\\n\\n        for (final char c1 : s1) {\\n            if (c1 == s2[s2Pointer]) {\\n                s2Pointer++;\\n\\n                if (s2Pointer == s2.length) {\\n                    s2Pointer = 0;\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public int getMaxRepetitions(final String s1, final int n1, final String s2, final int n2) {\\n        final Set<Character> s1Chars = new HashSet<>();\\n\\n        for (final char c1 : s1.toCharArray()) {\\n            s1Chars.add(c1);\\n        }\\n\\n        final Set<Character> s2Chars = new HashSet<>();\\n\\n        for (final char c2 : s2.toCharArray()) {\\n            s2Chars.add(c2);\\n        }\\n\\n        if (s1Chars.size() == 1 && s2Chars.size() == 1 && s1Chars.iterator().next() == s2Chars.iterator().next()) {\\n            return (s1.length() * n1) / (s2.length() * n2);\\n        }\\n\\n        final StringBuilder sb1 = new StringBuilder();\\n\\n        for (int i = 0; i < (n1 / n2); i++) {\\n            sb1.append(s1);\\n        }\\n\\n        if (sb1.length() == 0) {\\n            sb1.append(s1);\\n            return Math.max(0, countS2inS1(sb1.toString().toCharArray(), s2.toCharArray()) - 1);\\n        }\\n\\n        return countS2inS1(sb1.toString().toCharArray(), s2.toCharArray());\\n    }\\n\\n    @Test\\n    public void test() {\\n        assertEquals(2, new Solution().getMaxRepetitions(\"acb\", 4, \"ab\", 2));\\n        assertEquals(4, new Solution().getMaxRepetitions(\"aaa\", 3, \"aa\", 1));\\n        assertEquals(7, new Solution().getMaxRepetitions(\"baba\", 11, \"baab\", 1));\\n        assertEquals(1, new Solution().getMaxRepetitions(\"adasfdgdftadwfwfereredsfssas\", 500, \"fw\", 555));\\n        assertEquals(100000000, new Solution().getMaxRepetitions(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", 1000000, \"a\", 1));\\n        assertEquals(200000, new Solution().getMaxRepetitions(\"aahumeaylnlfdxfircvscxggbwkfnqduxwfnfozvsrtkjprepggxrpnrvystmwcysyycqpevikeffmznimkkasvwsrenazkycxf\", 1000000, \"aac\", 10));\\n        assertEquals(0, new Solution().getMaxRepetitions(\"musicforever\", 10, \"lovelive\", 100000));\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95418,
                "title": "java-5ms-solution-with-examination-easy-to-understand",
                "content": "Based on aaaeeeo 's solution.\\nhttps://discuss.leetcode.com/topic/70887/very-clean-and-short-7ms-java-solution-based-on-70664914-s-idea\\n```\\npublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if (s1 == null || s2 == null || n1 <= 0 || n2 <= 0) {\\n            return 0;\\n        }\\n        HashMap<Integer, Integer> posMap = new HashMap<Integer, Integer>(); // key: the rest position of s2  value:the number of s1\\n        int[] repTimes = new int[102]; // repTimes[i]: nummer of used s1 is i, repetitions times is repTimes[i]\\n        char[] chars1 = s1.toCharArray();\\n        char[] chars2 = s2.toCharArray();\\n        int len1 = s1.length();\\n        int len2 = s2.length();\\n        int s1Num = 1;\\n        int posInS2 = 0;\\n        int times = 0;\\n        while (s1Num <= n1) {\\n            for (int j = 0; j < len1; j++) {\\n                if (chars1[j] == chars2[posInS2]) {\\n                    posInS2++;\\n                    if (posInS2 == len2) {\\n                        times++;\\n                        posInS2 = 0;\\n                    }\\n                }\\n            }\\n            repTimes[s1Num] = times;\\n            if (posMap.containsKey(posInS2)) {\\n                break;\\n            }\\n            posMap.put(posInS2, s1Num);\\n            s1Num++;\\n        }\\n        if (s1Num >= n1) {\\n            return times / n2;\\n        }\\n        int k = posMap.get(posInS2);\\n        int s1NumInLoop = s1Num - k; // s1 num in each loop\\n        int s2NumInLoop = repTimes[s1Num] - repTimes[k]; // s2 num in each loop\\n        int repeatCount = (n1 - k) / s1NumInLoop;\\n        int n = repeatCount * s2NumInLoop;\\n        n += repTimes[k + (n1 - k) % s1NumInLoop];\\n        return n / n2;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if (s1 == null || s2 == null || n1 <= 0 || n2 <= 0) {\\n            return 0;\\n        }\\n        HashMap<Integer, Integer> posMap = new HashMap<Integer, Integer>(); // key: the rest position of s2  value:the number of s1\\n        int[] repTimes = new int[102]; // repTimes[i]: nummer of used s1 is i, repetitions times is repTimes[i]\\n        char[] chars1 = s1.toCharArray();\\n        char[] chars2 = s2.toCharArray();\\n        int len1 = s1.length();\\n        int len2 = s2.length();\\n        int s1Num = 1;\\n        int posInS2 = 0;\\n        int times = 0;\\n        while (s1Num <= n1) {\\n            for (int j = 0; j < len1; j++) {\\n                if (chars1[j] == chars2[posInS2]) {\\n                    posInS2++;\\n                    if (posInS2 == len2) {\\n                        times++;\\n                        posInS2 = 0;\\n                    }\\n                }\\n            }\\n            repTimes[s1Num] = times;\\n            if (posMap.containsKey(posInS2)) {\\n                break;\\n            }\\n            posMap.put(posInS2, s1Num);\\n            s1Num++;\\n        }\\n        if (s1Num >= n1) {\\n            return times / n2;\\n        }\\n        int k = posMap.get(posInS2);\\n        int s1NumInLoop = s1Num - k; // s1 num in each loop\\n        int s2NumInLoop = repTimes[s1Num] - repTimes[k]; // s2 num in each loop\\n        int repeatCount = (n1 - k) / s1NumInLoop;\\n        int n = repeatCount * s2NumInLoop;\\n        n += repTimes[k + (n1 - k) % s1NumInLoop];\\n        return n / n2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95421,
                "title": "java-5-ms-solution-similar-idea-from-418-sentence-screen-fitting",
                "content": "The idea is similar with #418 sentence screen fitting, e.g. store the next index \\n1. At Prepare funciton, calculate for each idx in s1, the next idx for fitting exactly one s2, and how many s1 is needed\\n2. Find the Looping starting index of s1, which means:\\n         m s1 can fit n s2, always from idx to idx at s1, \\n         also need to know how many times we used s1 before reaching loop index,\\n         and how many times we get s2 before reaching loop index\\n3. Using those parameters we can calculate overall how many times we can get s2 from n1 s1\\n```\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n\\tif (s1.length()*n1 < s2.length()*n2) return 0;\\n        char[] ss1 = s1.toCharArray();\\n        char[] ss2 = s2.toCharArray();\\n        for (char c: ss2) {\\n        \\tif (!s1.contains(c+\"\")) return 0;\\n        }\\n        int[] s1NextIdx = new int[ss1.length];\\n        int[] s1Costs = new int[ss1.length];\\n        prepare(ss1, ss2, s1NextIdx, s1Costs);\\n        int s1used = 0;\\n        int s1Idx = 0;\\n        int s2Count = 0;\\n        boolean[] used = new boolean[ss1.length];\\n        while (!used[s1Idx] && (s1used+s1Costs[s1Idx] <= n1)) {\\n            used[s1Idx] = true;\\n            s1used += s1Costs[s1Idx];\\n            s1Idx = s1NextIdx[s1Idx];\\n            s2Count++;\\n        }\\n        if (s1used+s1Costs[s1Idx] > n1) return s2Count/n2;\\n        if (s1Idx == 0 && n1%s1used == 0) {\\n        \\treturn s2Count*n1/s1used/n2;\\n        }\\n        int startIdx = 0;\\n        int preS2Count = 0;\\n        int preS1Used = 0;\\n        \\n        while (startIdx != s1Idx) {\\n            s1used -= s1Costs[startIdx];\\n            preS1Used += s1Costs[startIdx];\\n            startIdx = s1NextIdx[startIdx];\\n            s2Count--;\\n            preS2Count++;\\n        }\\n        if (preS2Count > 0) preS1Used++;\\n        int times = (n1-preS1Used)/s1used;\\n        s2Count = s2Count*times + preS2Count;\\n        s1used = preS1Used + times*s1used;\\n        //calcualting the tail part\\n        while (s1used+s1Costs[s1Idx] <= n1) {\\n            s1used += s1Costs[s1Idx];\\n            s1Idx = s1NextIdx[s1Idx];\\n            s2Count++;\\n        }\\n        return s2Count/n2;\\n    }\\n    private void prepare(char[] s1, char[] s2, int[] s1NextIdx, int[] s1Cost) {\\n        boolean[] used = new boolean[s1.length];\\n        int idx = 0;\\n        while (!used[idx]) {\\n            used[idx] = true;\\n            int curr = idx;\\n            int count = 0;\\n            int s2idx = 0;\\n            while (s2idx < s2.length) {\\n                if (s1[curr++] == s2[s2idx]) {\\n                    s2idx++;\\n                }\\n                if (curr >= s1.length) {\\n                    curr = 0;\\n                    count++;\\n                }\\n            }\\n            s1Cost[idx] = count;\\n            s1NextIdx[idx] = curr;\\n            idx = curr;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n\\tif (s1.length()*n1 < s2.length()*n2) return 0;\\n        char[] ss1 = s1.toCharArray();\\n        char[] ss2 = s2.toCharArray();\\n        for (char c: ss2) {\\n        \\tif (!s1.contains(c+\"\")) return 0;\\n        }\\n        int[] s1NextIdx = new int[ss1.length];\\n        int[] s1Costs = new int[ss1.length];\\n        prepare(ss1, ss2, s1NextIdx, s1Costs);\\n        int s1used = 0;\\n        int s1Idx = 0;\\n        int s2Count = 0;\\n        boolean[] used = new boolean[ss1.length];\\n        while (!used[s1Idx] && (s1used+s1Costs[s1Idx] <= n1)) {\\n            used[s1Idx] = true;\\n            s1used += s1Costs[s1Idx];\\n            s1Idx = s1NextIdx[s1Idx];\\n            s2Count++;\\n        }\\n        if (s1used+s1Costs[s1Idx] > n1) return s2Count/n2;\\n        if (s1Idx == 0 && n1%s1used == 0) {\\n        \\treturn s2Count*n1/s1used/n2;\\n        }\\n        int startIdx = 0;\\n        int preS2Count = 0;\\n        int preS1Used = 0;\\n        \\n        while (startIdx != s1Idx) {\\n            s1used -= s1Costs[startIdx];\\n            preS1Used += s1Costs[startIdx];\\n            startIdx = s1NextIdx[startIdx];\\n            s2Count--;\\n            preS2Count++;\\n        }\\n        if (preS2Count > 0) preS1Used++;\\n        int times = (n1-preS1Used)/s1used;\\n        s2Count = s2Count*times + preS2Count;\\n        s1used = preS1Used + times*s1used;\\n        //calcualting the tail part\\n        while (s1used+s1Costs[s1Idx] <= n1) {\\n            s1used += s1Costs[s1Idx];\\n            s1Idx = s1NextIdx[s1Idx];\\n            s2Count++;\\n        }\\n        return s2Count/n2;\\n    }\\n    private void prepare(char[] s1, char[] s2, int[] s1NextIdx, int[] s1Cost) {\\n        boolean[] used = new boolean[s1.length];\\n        int idx = 0;\\n        while (!used[idx]) {\\n            used[idx] = true;\\n            int curr = idx;\\n            int count = 0;\\n            int s2idx = 0;\\n            while (s2idx < s2.length) {\\n                if (s1[curr++] == s2[s2idx]) {\\n                    s2idx++;\\n                }\\n                if (curr >= s1.length) {\\n                    curr = 0;\\n                    count++;\\n                }\\n            }\\n            s1Cost[idx] = count;\\n            s1NextIdx[idx] = curr;\\n            idx = curr;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95432,
                "title": "share-my-python-solution-detailed-thought-while-not-elegant",
                "content": "```python\\nclass Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        \"\"\"\\n        :type s1: str\\n        :type n1: int\\n        :type s2: str\\n        :type n2: int\\n        :rtype: int\\n        \"\"\"\\n        # First, try to find s2 inside s1\\n        \\n        L1 = len(s1)\\n        L2 = len(s2)\\n        i = 0\\n        j = 0\\n        count = 0\\n        while i < L1:\\n            \\n            if s1[i] == s2[j]:\\n                j += 1\\n                if j == L2:\\n                    count += 1\\n                    j = 0\\n            \\n            i += 1\\n            \\n        # cannot find any single character of s2\\n        if count == 0 and j == 0:\\n            return 0\\n            \\n        # s1 contains at least one s2\\n        # concat two s1, we may find one more s2\\n        if count > 0:\\n            tmp = count\\n            i = 0\\n            while i < L1:\\n                if s1[i] == s2[j]:\\n                    j += 1\\n                    if j == L2:\\n                        count += 1\\n                        j = 0\\n            \\n                i += 1\\n        \\n\\t    # no more s2 after concat\\n            if tmp * 2 == count:\\n                return tmp * n1 / n2\\n            # we do have one more s2 after concat\\n            else:\\n                return (tmp * n1 + n1 - 1) / n2 if n1 > 0 else 0\\n                \\n        # Here count == 0, j != 0, means only part of s2 is found inside s1, in other words, we got a \"dirty tail\"\\n        # concat more s1 until we find a complete s2, and keep finding new s2, until the \"dirty tail\" is gone or remains the same, which means we finally find the pattern\\n        \\n        tmp = -1\\n        accArr = []\\n        acc = 1\\n        while j != 0 and j != tmp:\\n            tmp = j\\n \\n            s1Num = 0\\n            findS2 = False\\n            while not findS2:\\n                s1Num += 1\\n                i = 0\\n                hit = False\\n                while i < L1:\\n                    if s1[i] == s2[j]:\\n                        hit = True\\n                        j += 1\\n                        if j == L2:\\n                            findS2 = True\\n                            count += 1\\n                            j = 0\\n                \\n                    i += 1\\n                    \\n                if not hit: # cannot find necessary characters\\n                    return 0\\n                    \\n            accArr.append(acc + s1Num) # accArr[i] = how many s1 are checked when we find i th complete s2\\n            acc += s1Num\\n            if acc > n1:\\n                return (count - 1) / n2\\n            \\n        # pattern found!\\n    \\n        if j == 0:\\n            # (acc) number of s1 = (count) number of s2\\n            S = n1 / acc * count\\n            r = n1 % acc\\n\\n            for num in accArr:\\n                if num <= r:\\n                    S += 1\\n                else:\\n                    break\\n\\n            return S / n2\\n            \\n        if j == tmp:\\n            # (acc) number of s1 = (count) number of s2\\uff0cnow every new (s1Num) number of s1, gives us a new s2\\n            return ( (n1 - acc) / s1Num + count) / n2\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        \"\"\"\\n        :type s1: str\\n        :type n1: int\\n        :type s2: str\\n        :type n2: int\\n        :rtype: int\\n        \"\"\"\\n        # First, try to find s2 inside s1\\n        \\n        L1 = len(s1)\\n        L2 = len(s2)\\n        i = 0\\n        j = 0\\n        count = 0\\n        while i < L1:\\n            \\n            if s1[i] == s2[j]:\\n                j += 1\\n                if j == L2:\\n                    count += 1\\n                    j = 0\\n            \\n            i += 1\\n            \\n        # cannot find any single character of s2\\n        if count == 0 and j == 0:\\n            return 0\\n            \\n        # s1 contains at least one s2\\n        # concat two s1, we may find one more s2\\n        if count > 0:\\n            tmp = count\\n            i = 0\\n            while i < L1:\\n                if s1[i] == s2[j]:\\n                    j += 1\\n                    if j == L2:\\n                        count += 1\\n                        j = 0\\n            \\n                i += 1\\n        \\n\\t    # no more s2 after concat\\n            if tmp * 2 == count:\\n                return tmp * n1 / n2\\n            # we do have one more s2 after concat\\n            else:\\n                return (tmp * n1 + n1 - 1) / n2 if n1 > 0 else 0\\n                \\n        # Here count == 0, j != 0, means only part of s2 is found inside s1, in other words, we got a \"dirty tail\"\\n        # concat more s1 until we find a complete s2, and keep finding new s2, until the \"dirty tail\" is gone or remains the same, which means we finally find the pattern\\n        \\n        tmp = -1\\n        accArr = []\\n        acc = 1\\n        while j != 0 and j != tmp:\\n            tmp = j\\n \\n            s1Num = 0\\n            findS2 = False\\n            while not findS2:\\n                s1Num += 1\\n                i = 0\\n                hit = False\\n                while i < L1:\\n                    if s1[i] == s2[j]:\\n                        hit = True\\n                        j += 1\\n                        if j == L2:\\n                            findS2 = True\\n                            count += 1\\n                            j = 0\\n                \\n                    i += 1\\n                    \\n                if not hit: # cannot find necessary characters\\n                    return 0\\n                    \\n            accArr.append(acc + s1Num) # accArr[i] = how many s1 are checked when we find i th complete s2\\n            acc += s1Num\\n            if acc > n1:\\n                return (count - 1) / n2\\n            \\n        # pattern found!\\n    \\n        if j == 0:\\n            # (acc) number of s1 = (count) number of s2\\n            S = n1 / acc * count\\n            r = n1 % acc\\n\\n            for num in accArr:\\n                if num <= r:\\n                    S += 1\\n                else:\\n                    break\\n\\n            return S / n2\\n            \\n        if j == tmp:\\n            # (acc) number of s1 = (count) number of s2\\uff0cnow every new (s1Num) number of s1, gives us a new s2\\n            return ( (n1 - acc) / s1Num + count) / n2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95436,
                "title": "java-solution",
                "content": "```\\npublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n\\t\\tint count = 0;\\n\\t\\tString primary = \"\";\\n\\t\\tString secondary = \"\" ;\\n\\t\\tif(s1.length()*n1 < s2.length()*n2) {\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t\\tif(s1.contains(s2)){\\n\\t\\t\\tchar[] primArr = s1.toCharArray();\\n\\t\\t\\tchar[] secArr = s2.toCharArray();\\n\\t\\t\\tint j =0;\\n\\t\\t\\tfor(int i=0; i< primArr.length && j<secArr.length; i++) {\\n\\t\\t\\t\\tif(primArr[i] == secArr[j]) {\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(j == secArr.length) {\\n\\t\\t\\t\\t\\tcount +=1;\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcount = n1* count/n2;\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t\\tif(s1 == s2) {\\n\\t\\t\\tcount = (n1/n2);\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t\\tfor(int i=1;i <= n1; i++) {\\n\\t\\t\\tprimary += s1;\\n\\t\\t}\\n\\t\\tfor(int i=1; i<=n2; i++) {\\n\\t\\t\\tsecondary += s2;\\n\\t\\t}\\n\\t\\tchar[] primArr = primary.toCharArray();\\n\\t\\tchar[] secArr = secondary.toCharArray();\\n\\t\\tint j = 0;\\n\\t\\tfor(int i=0; i< primArr.length && j<secArr.length; i++) {\\n\\t\\t\\tif(primArr[i] == secArr[j]) {\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tif(j == secArr.length) {\\n\\t\\t\\t\\tcount +=1;\\n\\t\\t\\t\\tj = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n\\t\\tint count = 0;\\n\\t\\tString primary = \"\";\\n\\t\\tString secondary = \"\" ;\\n\\t\\tif(s1.length()*n1 < s2.length()*n2) {\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t\\tif(s1.contains(s2)){\\n\\t\\t\\tchar[] primArr = s1.toCharArray();\\n\\t\\t\\tchar[] secArr = s2.toCharArray();\\n\\t\\t\\tint j =0;\\n\\t\\t\\tfor(int i=0; i< primArr.length && j<secArr.length; i++) {\\n\\t\\t\\t\\tif(primArr[i] == secArr[j]) {\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(j == secArr.length) {\\n\\t\\t\\t\\t\\tcount +=1;\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcount = n1* count/n2;\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t\\tif(s1 == s2) {\\n\\t\\t\\tcount = (n1/n2);\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t\\tfor(int i=1;i <= n1; i++) {\\n\\t\\t\\tprimary += s1;\\n\\t\\t}\\n\\t\\tfor(int i=1; i<=n2; i++) {\\n\\t\\t\\tsecondary += s2;\\n\\t\\t}\\n\\t\\tchar[] primArr = primary.toCharArray();\\n\\t\\tchar[] secArr = secondary.toCharArray();\\n\\t\\tint j = 0;\\n\\t\\tfor(int i=0; i< primArr.length && j<secArr.length; i++) {\\n\\t\\t\\tif(primArr[i] == secArr[j]) {\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tif(j == secArr.length) {\\n\\t\\t\\t\\tcount +=1;\\n\\t\\t\\t\\tj = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4016217,
                "title": "count-the-repetitions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s1\\n * @param {number} n1\\n * @param {string} s2\\n * @param {number} n2\\n * @return {number}\\n */\\nvar getMaxRepetitions = function(s1, n1, s2, n2) {\\n    const len1 = s1.length;\\n    const len2 = s2.length; \\n    let count1 = 0; // Number of times s2 can be formed from s1\\n    let count2 = 0; // Number of times str2 = [s2, count2] can be formed from str1 = [s1, count1]\\n    let i = 0; // Pointer for s1\\n    let j = 0; // Pointer for s2\\n    while (count1 < n1) {\\n        if (s1[i] === s2[j]) {\\n            j++;\\n            if (j === len2) {\\n                j = 0;\\n                count2++;\\n            }\\n        }\\n        i++;\\n        if (i === len1) {\\n            i = 0;\\n            count1++;\\n        }\\n    }\\n    return Math.floor(count2 / n2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s1\\n * @param {number} n1\\n * @param {string} s2\\n * @param {number} n2\\n * @return {number}\\n */\\nvar getMaxRepetitions = function(s1, n1, s2, n2) {\\n    const len1 = s1.length;\\n    const len2 = s2.length; \\n    let count1 = 0; // Number of times s2 can be formed from s1\\n    let count2 = 0; // Number of times str2 = [s2, count2] can be formed from str1 = [s1, count1]\\n    let i = 0; // Pointer for s1\\n    let j = 0; // Pointer for s2\\n    while (count1 < n1) {\\n        if (s1[i] === s2[j]) {\\n            j++;\\n            if (j === len2) {\\n                j = 0;\\n                count2++;\\n            }\\n        }\\n        i++;\\n        if (i === len1) {\\n            i = 0;\\n            count1++;\\n        }\\n    }\\n    return Math.floor(count2 / n2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3846895,
                "title": "c-brute-force-approach-with-slight-time-optimization-slow-but-it-works",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe cannot actually store (s1 * n1) and (s2 * n2) due to memory constraints. Therefore we need to make n1 loops over s1, and for every n2 matches of s2 that we can find we increment count by 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n1 * s1.Length)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int GetMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int count = 0, ind = 0, loops = 0;\\n        for (int i = 0; i < n1; i++){\\n            for (int k = 0; k < s1.Length; k++){\\n                if (s1[k] == s2[ind]) ind++;\\n                if (ind == s2.Length){\\n                    ind = 0;\\n                    loops++;\\n                }\\n                if (loops == n2){\\n                    loops = 0;\\n                    count++;\\n                }\\n            }\\n            if (ind == 0 && loops == 0){\\n                int add = count;\\n                int times = i + 1;\\n                while (i + times < n1){\\n                    i += times;\\n                    count += add;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int GetMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int count = 0, ind = 0, loops = 0;\\n        for (int i = 0; i < n1; i++){\\n            for (int k = 0; k < s1.Length; k++){\\n                if (s1[k] == s2[ind]) ind++;\\n                if (ind == s2.Length){\\n                    ind = 0;\\n                    loops++;\\n                }\\n                if (loops == n2){\\n                    loops = 0;\\n                    count++;\\n                }\\n            }\\n            if (ind == 0 && loops == 0){\\n                int add = count;\\n                int times = i + 1;\\n                while (i + times < n1){\\n                    i += times;\\n                    count += add;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827802,
                "title": "java-solution-4ms-runtime-with-brief-explanation",
                "content": "# Explanation\\n\\n. For each repetition of s1, count the number of times we see s2\\n. Store the seen count for each repetition of s1\\n. Store the index of s2 where we stopped after each repetition of s1\\n. For each repetition of s1, check if we\\'ve seen this index of s2 before\\n. If we have, then we\\'ve found a repeating pattern\\n. The number of times we see s2 in the pattern is (count[k] - count[start])\\n. The number of times we see s2 outside the pattern is (count[start + (n1 - start) % (k - start)] - count[start])\\n. The number of times we see s2 in total is (prefixCount + patternCount + suffixCount)\\n. The number of times we see s2 in total divided by n2 is the answer\\n\\n# Code\\n```\\n// Count the repetitions\\n// LeetCode: https://leetcode.com/problems/count-the-repetitions/\\n\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int[] next = new int[s2.length() + 1];\\n        int[] count = new int[s2.length() + 1];\\n        int j = 0, cnt = 0;\\n        for (int k = 1; k <= n1; k++) {\\n            for (int i = 0; i < s1.length(); i++) {\\n                if (s1.charAt(i) == s2.charAt(j)) {\\n                    j++;\\n                    if (j == s2.length()) {\\n                        j = 0;\\n                        cnt++;\\n                    }\\n                }\\n            }\\n            count[k] = cnt;\\n            next[k] = j;\\n            for (int start = 0; start < k; start++) {\\n                if (next[start] == j) {\\n                    int prefixCount = count[start];\\n                    int patternCount = (count[k] - count[start]) * ((n1 - start) / (k - start));\\n                    int suffixCount = count[start + (n1 - start) % (k - start)] - count[start];\\n                    return (prefixCount + patternCount + suffixCount) / n2;\\n                }\\n            }\\n        }\\n        return count[n1] / n2;\\n    }\\n}\\n```\\n```C++[]\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            for(int k=0;k<i;k++){\\n                if(posRest==rest[k]){b=k;last=i;break;}\\n            }\\n            rapport[i]=rap;rest[i]=posRest;\\n            if(b>=0)break;\\n        }\\n        int interval=last-b;\\n        if(b>=n1)return rapport[n1]/n2;\\n        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;  }\\n};\\n```\\n```python3 []\\nclass Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        start = {}\\n        s1_round, s2_round, s2_idx = 0, 0, 0\\n        while s1_round < n1:\\n            s1_round += 1\\n            for ch in s1:\\n                if ch == s2[s2_idx]:\\n                    s2_idx += 1\\n                    if s2_idx == len(s2):\\n                        s2_round += 1\\n                        s2_idx = 0\\n            if s2_idx in start:\\n                prev_s1_round, prev_s2_round = start[s2_idx]\\n                circle_s1_round, circle_s2_round = s1_round - prev_s1_round, s2_round - prev_s2_round\\n                res = (n1 - prev_s1_round)\\n                left_s1_round = (n1 - prev_s1_round) % circle_s1_round + prev_s1_round\\n                for key in start:\\n                    val = start[key]\\n                    if val[0] == left_s1_round:\\n                        res += val[1]\\n                        break\\n                return res \\n            else:\\n                start[s2_idx] = (s1_round, s2_round)\\n        return s2_round\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\n// Count the repetitions\\n// LeetCode: https://leetcode.com/problems/count-the-repetitions/\\n\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int[] next = new int[s2.length() + 1];\\n        int[] count = new int[s2.length() + 1];\\n        int j = 0, cnt = 0;\\n        for (int k = 1; k <= n1; k++) {\\n            for (int i = 0; i < s1.length(); i++) {\\n                if (s1.charAt(i) == s2.charAt(j)) {\\n                    j++;\\n                    if (j == s2.length()) {\\n                        j = 0;\\n                        cnt++;\\n                    }\\n                }\\n            }\\n            count[k] = cnt;\\n            next[k] = j;\\n            for (int start = 0; start < k; start++) {\\n                if (next[start] == j) {\\n                    int prefixCount = count[start];\\n                    int patternCount = (count[k] - count[start]) * ((n1 - start) / (k - start));\\n                    int suffixCount = count[start + (n1 - start) % (k - start)] - count[start];\\n                    return (prefixCount + patternCount + suffixCount) / n2;\\n                }\\n            }\\n        }\\n        return count[n1] / n2;\\n    }\\n}\\n```\n```C++[]\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            for(int k=0;k<i;k++){\\n                if(posRest==rest[k]){b=k;last=i;break;}\\n            }\\n            rapport[i]=rap;rest[i]=posRest;\\n            if(b>=0)break;\\n        }\\n        int interval=last-b;\\n        if(b>=n1)return rapport[n1]/n2;\\n        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;  }\\n};\\n```\n```python3 []\\nclass Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        start = {}\\n        s1_round, s2_round, s2_idx = 0, 0, 0\\n        while s1_round < n1:\\n            s1_round += 1\\n            for ch in s1:\\n                if ch == s2[s2_idx]:\\n                    s2_idx += 1\\n                    if s2_idx == len(s2):\\n                        s2_round += 1\\n                        s2_idx = 0\\n            if s2_idx in start:\\n                prev_s1_round, prev_s2_round = start[s2_idx]\\n                circle_s1_round, circle_s2_round = s1_round - prev_s1_round, s2_round - prev_s2_round\\n                res = (n1 - prev_s1_round)\\n                left_s1_round = (n1 - prev_s1_round) % circle_s1_round + prev_s1_round\\n                for key in start:\\n                    val = start[key]\\n                    if val[0] == left_s1_round:\\n                        res += val[1]\\n                        break\\n                return res \\n            else:\\n                start[s2_idx] = (s1_round, s2_round)\\n        return s2_round\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749178,
                "title": "100-using-2-vectors-easy-implementation-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int len1 = s1.length(), len2 = s2.length();\\n        vector<int> repeatCount(len2 + 1, 0);\\n        vector<int> nextIndex(len2 + 1, 0);\\n\\n        int count1 = 0, count2 = 0, j = 0;\\n        for (int k = 1; k <= n1; k++) {\\n            for (int i = 0; i < len1; i++) {\\n                if (s1[i] == s2[j]) {\\n                    j++;\\n                    if (j == len2) {\\n                        j = 0;\\n                        count2++;\\n                    }\\n                }\\n            }\\n            count1++;\\n\\n            // Check for repetition pattern\\n            repeatCount[k] = count2;\\n            nextIndex[k] = j;\\n\\n            for (int start = 0; start < k; start++) {\\n                if (nextIndex[start] == j) {\\n                    int prefixCount = repeatCount[start];\\n                    int patternCount = (n1 - start) / (k - start) * (repeatCount[k] - repeatCount[start]);\\n                    int suffixCount = repeatCount[start + (n1 - start) % (k - start)] - repeatCount[start];\\n                    return (prefixCount + patternCount + suffixCount) / n2;\\n                }\\n            }\\n        }\\n\\n        return count2 / n2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "String",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int len1 = s1.length(), len2 = s2.length();\\n        vector<int> repeatCount(len2 + 1, 0);\\n        vector<int> nextIndex(len2 + 1, 0);\\n\\n        int count1 = 0, count2 = 0, j = 0;\\n        for (int k = 1; k <= n1; k++) {\\n            for (int i = 0; i < len1; i++) {\\n                if (s1[i] == s2[j]) {\\n                    j++;\\n                    if (j == len2) {\\n                        j = 0;\\n                        count2++;\\n                    }\\n                }\\n            }\\n            count1++;\\n\\n            // Check for repetition pattern\\n            repeatCount[k] = count2;\\n            nextIndex[k] = j;\\n\\n            for (int start = 0; start < k; start++) {\\n                if (nextIndex[start] == j) {\\n                    int prefixCount = repeatCount[start];\\n                    int patternCount = (n1 - start) / (k - start) * (repeatCount[k] - repeatCount[start]);\\n                    int suffixCount = repeatCount[start + (n1 - start) % (k - start)] - repeatCount[start];\\n                    return (prefixCount + patternCount + suffixCount) / n2;\\n                }\\n            }\\n        }\\n\\n        return count2 / n2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748231,
                "title": "easy-o-n1-ns2-ns2-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEntire Thought process in the comments.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n1 + ns2*ns2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(ns2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        // dp[i] = no of new blocks of s1 required to construct 1 block of str2 starting from s1[i]\\n        // next[i] = index of s1 obtained after constructing 1 block of str2 using dp[i] blocks\\n        // int blocks = 0, ind = 0, m = 0;\\n        // while (blocks + dp[ind] <= n) {\\n            // blocks += dp[ind];\\n            // ind = next[ind];\\n            // m++;\\n        // }\\n        //  return m;\\n        // TLE (10^ 6 * 100)\\n        // revision\\n        // dp[i] = no of characters of str2 satisfied for 1 block of s1 if str2 started at str2[i]\\n        // int ns2 = s2.size();\\n        // for (int i = 0, ind = 0, cnt = 0; i < n; i++) {\\n        //     cnt += dp[ind];\\n        //     ind = (ind + dp[ind]) % ns2 * n2;\\n        // }\\n        // return cnt / ns2 / n2 ;\\n        // but dp will have a size of ns2 (10 ^ 6 * 100)\\n        // TLE , MLE\\n        // can we reduce this size by leveraging periodicity of str2\\n        // revision\\n        // dp[i] = no of characters of str2 satisfied for 1 block of s1 if s2 started at s2[i]\\n        // int ns2 = s2.size();\\n        // for (int i = 0, ind = 0, cnt = 0; i < n; i++) {\\n        //     cnt += dp[ind];\\n        //     ind = (ind + dp[ind]) % ns2;\\n        // }\\n        // return cnt / ns2 / n2 ;\\n        // brute force dp (100 * 100);\\n        // for (int ind = 0; ind < ns2; ind++) {\\n        //     int l1 = 0, l2 = ind, cnt = 0;\\n        //     while (l1 < ns1) {\\n        //         if (s1[l1] == s2[l2]) {\\n        //             l2++;\\n        //             l2 %= ns2;\\n        //             cnt++;\\n        //         }\\n        //         l1++;\\n        //     }\\n        //     dp[ind] = cnt;\\n        // }\\n        int ns1 = s1.size(), ns2 = s2.size();\\n        vector<int> dp(ns2, 0);\\n        for (int ind = 0; ind < ns2; ind++) {\\n            int l1 = 0, l2 = ind, cnt = 0;\\n            while (l1 < ns1) {\\n                if (s1[l1] == s2[l2]) {\\n                    l2++;\\n                    l2 %= ns2;\\n                    cnt++;\\n                }\\n                l1++;\\n            }\\n            dp[ind] = cnt;\\n        }\\n        int cnt = 0;\\n        for (int i = 0, ind = 0; i < n1; i++) {\\n            cnt += dp[ind];\\n            ind = (ind + dp[ind]) % ns2;\\n        }\\n        return cnt / ns2 / n2 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        // dp[i] = no of new blocks of s1 required to construct 1 block of str2 starting from s1[i]\\n        // next[i] = index of s1 obtained after constructing 1 block of str2 using dp[i] blocks\\n        // int blocks = 0, ind = 0, m = 0;\\n        // while (blocks + dp[ind] <= n) {\\n            // blocks += dp[ind];\\n            // ind = next[ind];\\n            // m++;\\n        // }\\n        //  return m;\\n        // TLE (10^ 6 * 100)\\n        // revision\\n        // dp[i] = no of characters of str2 satisfied for 1 block of s1 if str2 started at str2[i]\\n        // int ns2 = s2.size();\\n        // for (int i = 0, ind = 0, cnt = 0; i < n; i++) {\\n        //     cnt += dp[ind];\\n        //     ind = (ind + dp[ind]) % ns2 * n2;\\n        // }\\n        // return cnt / ns2 / n2 ;\\n        // but dp will have a size of ns2 (10 ^ 6 * 100)\\n        // TLE , MLE\\n        // can we reduce this size by leveraging periodicity of str2\\n        // revision\\n        // dp[i] = no of characters of str2 satisfied for 1 block of s1 if s2 started at s2[i]\\n        // int ns2 = s2.size();\\n        // for (int i = 0, ind = 0, cnt = 0; i < n; i++) {\\n        //     cnt += dp[ind];\\n        //     ind = (ind + dp[ind]) % ns2;\\n        // }\\n        // return cnt / ns2 / n2 ;\\n        // brute force dp (100 * 100);\\n        // for (int ind = 0; ind < ns2; ind++) {\\n        //     int l1 = 0, l2 = ind, cnt = 0;\\n        //     while (l1 < ns1) {\\n        //         if (s1[l1] == s2[l2]) {\\n        //             l2++;\\n        //             l2 %= ns2;\\n        //             cnt++;\\n        //         }\\n        //         l1++;\\n        //     }\\n        //     dp[ind] = cnt;\\n        // }\\n        int ns1 = s1.size(), ns2 = s2.size();\\n        vector<int> dp(ns2, 0);\\n        for (int ind = 0; ind < ns2; ind++) {\\n            int l1 = 0, l2 = ind, cnt = 0;\\n            while (l1 < ns1) {\\n                if (s1[l1] == s2[l2]) {\\n                    l2++;\\n                    l2 %= ns2;\\n                    cnt++;\\n                }\\n                l1++;\\n            }\\n            dp[ind] = cnt;\\n        }\\n        int cnt = 0;\\n        for (int i = 0, ind = 0; i < n1; i++) {\\n            cnt += dp[ind];\\n            ind = (ind + dp[ind]) % ns2;\\n        }\\n        return cnt / ns2 / n2 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727400,
                "title": "100-beat-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            for(int k=0;k<i;k++){\\n                if(posRest==rest[k]){b=k;last=i;break;}\\n            }\\n            rapport[i]=rap;rest[i]=posRest;\\n            if(b>=0)break;\\n        }\\n        int interval=last-b;\\n        if(b>=n1)return rapport[n1]/n2;\\n        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            for(int k=0;k<i;k++){\\n                if(posRest==rest[k]){b=k;last=i;break;}\\n            }\\n            rapport[i]=rap;rest[i]=posRest;\\n            if(b>=0)break;\\n        }\\n        int interval=last-b;\\n        if(b>=n1)return rapport[n1]/n2;\\n        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667172,
                "title": "39-13-faster",
                "content": "\\n\\n# Code\\n```\\nclass Record{\\n    int count;\\n    int nextIndex;\\n\\n    public Record(int count, int nextIndex){\\n        this.count = count;\\n        this.nextIndex = nextIndex;\\n    }\\n}\\n\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        \\n        List<Record> records = new ArrayList();\\n\\n        this.load(s1, s2, records);\\n\\n        int index = 0, match = 0;\\n\\n        while(n1>0){\\n            match+=records.get(index).count;\\n            index = records.get(index).nextIndex;\\n            n1--;\\n        }\\n\\n        return match/n2;\\n\\n    }\\n\\n    void load(String s1, String s2, List<Record> records){\\n\\n        for(int i=0; i<s2.length(); i++){\\n            int nextIndex = i;\\n            int count = 0;\\n\\n            for(int j=0; j<s1.length(); j++){\\n\\n                if(s2.charAt(nextIndex)==s1.charAt(j)) nextIndex++;\\n\\n                if(nextIndex==s2.length()){\\n                    count++;\\n                    nextIndex = 0;\\n                }\\n\\n            }\\n            records.add(new Record(count, nextIndex));\\n        }\\n\\n\\n\\n    }\\n\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Record{\\n    int count;\\n    int nextIndex;\\n\\n    public Record(int count, int nextIndex){\\n        this.count = count;\\n        this.nextIndex = nextIndex;\\n    }\\n}\\n\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        \\n        List<Record> records = new ArrayList();\\n\\n        this.load(s1, s2, records);\\n\\n        int index = 0, match = 0;\\n\\n        while(n1>0){\\n            match+=records.get(index).count;\\n            index = records.get(index).nextIndex;\\n            n1--;\\n        }\\n\\n        return match/n2;\\n\\n    }\\n\\n    void load(String s1, String s2, List<Record> records){\\n\\n        for(int i=0; i<s2.length(); i++){\\n            int nextIndex = i;\\n            int count = 0;\\n\\n            for(int j=0; j<s1.length(); j++){\\n\\n                if(s2.charAt(nextIndex)==s1.charAt(j)) nextIndex++;\\n\\n                if(nextIndex==s2.length()){\\n                    count++;\\n                    nextIndex = 0;\\n                }\\n\\n            }\\n            records.add(new Record(count, nextIndex));\\n        }\\n\\n\\n\\n    }\\n\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591093,
                "title": "geez-mad-coz-bad",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        if n1 == 0:\\n            return 0\\n\\n        # Count the number of occurrences of s2 in each repetition of s1\\n        repeat_count = {}  # Map of count2: (count1, next_index)\\n        count1, count2 = 0, 0\\n        next_index = 0\\n\\n        while count1 < n1:\\n            for i in range(len(s1)):\\n                if s1[i] == s2[next_index]:\\n                    next_index += 1\\n                    if next_index == len(s2):\\n                        next_index = 0\\n                        count2 += 1\\n\\n            count1 += 1\\n\\n            if next_index in repeat_count:\\n                # Found a repeating pattern\\n                prev_count1, prev_count2 = repeat_count[next_index]\\n                pattern_count1 = count1 - prev_count1\\n                pattern_count2 = count2 - prev_count2\\n                pattern_repetitions = (n1 - prev_count1) // pattern_count1\\n                remaining_count1 = (n1 - prev_count1) % pattern_count1\\n\\n                count2 = prev_count2 + pattern_count2 * pattern_repetitions\\n                count1 = prev_count1 + pattern_count1 * pattern_repetitions\\n\\n                # Calculate remaining occurrences within the partial pattern\\n                for _ in range(remaining_count1):\\n                    for char in s1:\\n                        if char == s2[next_index]:\\n                            next_index += 1\\n                            if next_index == len(s2):\\n                                next_index = 0\\n                                count2 += 1\\n\\n                break\\n            else:\\n                repeat_count[next_index] = (count1, count2)\\n\\n        return count2 // n2\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        if n1 == 0:\\n            return 0\\n\\n        # Count the number of occurrences of s2 in each repetition of s1\\n        repeat_count = {}  # Map of count2: (count1, next_index)\\n        count1, count2 = 0, 0\\n        next_index = 0\\n\\n        while count1 < n1:\\n            for i in range(len(s1)):\\n                if s1[i] == s2[next_index]:\\n                    next_index += 1\\n                    if next_index == len(s2):\\n                        next_index = 0\\n                        count2 += 1\\n\\n            count1 += 1\\n\\n            if next_index in repeat_count:\\n                # Found a repeating pattern\\n                prev_count1, prev_count2 = repeat_count[next_index]\\n                pattern_count1 = count1 - prev_count1\\n                pattern_count2 = count2 - prev_count2\\n                pattern_repetitions = (n1 - prev_count1) // pattern_count1\\n                remaining_count1 = (n1 - prev_count1) % pattern_count1\\n\\n                count2 = prev_count2 + pattern_count2 * pattern_repetitions\\n                count1 = prev_count1 + pattern_count1 * pattern_repetitions\\n\\n                # Calculate remaining occurrences within the partial pattern\\n                for _ in range(remaining_count1):\\n                    for char in s1:\\n                        if char == s2[next_index]:\\n                            next_index += 1\\n                            if next_index == len(s2):\\n                                next_index = 0\\n                                count2 += 1\\n\\n                break\\n            else:\\n                repeat_count[next_index] = (count1, count2)\\n\\n        return count2 // n2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205458,
                "title": "better-loop-detection",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHaving made a previous attempt that took 600ms I realised that detecting loops against the initial s2 start point wasn\\'t enough, so maybe an array storing s1&s2 cycle numbers at s2 loop would enable detection of any loop?\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTook some thinking about but in the end storing s2 cycle number at the end of each s1 cycle and storing s1 cycle number at the first detected letter of each s2 cycle gives the right information, as long as one completes the s1 cycle one is in when one detects the s2 alignment loop. Math is explained in the code. Now takes 0ms (?). Could do with some tidying up since `e[]` is no longer required.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n\\xB2)$$ longest loop might take `s1.length` cycles of `s1.length` iterations to find\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ constant space defined by max string length\\n\\n# Code\\n```\\nint getMaxRepetitions(char * s1, int n1, char * s2, int n2){\\n    int a = 0, b = 0, c = 0, d = 0, f = -1;\\n    int e[102], g[102], h[102]; for(int n = 0; n < 102; e[n++] = -1);\\n    char s1r, s2r = s2[0];\\n    while(c < n1)\\n    {   if(!(s1r = s1[a++])) { h[c++] = d; a = 0;  if(!(f < 0)) goto earlycalc; continue; } // loop reading of s1\\n        if(s2r == s1r) \\n        {   if(b == 0) { if(e[a] == -1) { e[a] = d; g[a] = c; } else f = a; } \\n            if(!(s2r = s2[++b])) { s2r = s2[(b = 0)]; d++; }\\n        }\\n    }\\n    return (d / n2);\\nearlycalc: ;\\n//  counting continues after loop is found to end of current s1 cycle. \\n//  s2 count is taken at the end of each s1 cycle\\n\\n    int s1cr = n1 - c;                       // s1 cycles remaining\\n    int ls1c = c - g[f] - 1;                 // loop s1 cycles\\n    int ls2c = h[c - 1] - h[g[f]];           // loop s2 cycles\\n    int lr = s1cr / ls1c;                    // loops remaining\\n    int s1cafl = s1cr % ls1c;                // s1 cycles after final loop\\n    int s2cafl = h[g[f] + s1cafl] - h[g[f]]; // s2 cycles after final loop\\n    int s2t = d + (lr * ls2c) + s2cafl;      // s2 total\\n\\n    //printf(\"%i, %i, %i, %i, %i, %i, %i, %i, %i, %i\", a, b, c, d, e[0], e[1], e[2], e[a], f, g[a]);\\n\\n    return s2t / n2;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nint getMaxRepetitions(char * s1, int n1, char * s2, int n2){\\n    int a = 0, b = 0, c = 0, d = 0, f = -1;\\n    int e[102], g[102], h[102]; for(int n = 0; n < 102; e[n++] = -1);\\n    char s1r, s2r = s2[0];\\n    while(c < n1)\\n    {   if(!(s1r = s1[a++])) { h[c++] = d; a = 0;  if(!(f < 0)) goto earlycalc; continue; } // loop reading of s1\\n        if(s2r == s1r) \\n        {   if(b == 0) { if(e[a] == -1) { e[a] = d; g[a] = c; } else f = a; } \\n            if(!(s2r = s2[++b])) { s2r = s2[(b = 0)]; d++; }\\n        }\\n    }\\n    return (d / n2);\\nearlycalc: ;\\n//  counting continues after loop is found to end of current s1 cycle. \\n//  s2 count is taken at the end of each s1 cycle\\n\\n    int s1cr = n1 - c;                       // s1 cycles remaining\\n    int ls1c = c - g[f] - 1;                 // loop s1 cycles\\n    int ls2c = h[c - 1] - h[g[f]];           // loop s2 cycles\\n    int lr = s1cr / ls1c;                    // loops remaining\\n    int s1cafl = s1cr % ls1c;                // s1 cycles after final loop\\n    int s2cafl = h[g[f] + s1cafl] - h[g[f]]; // s2 cycles after final loop\\n    int s2t = d + (lr * ls2c) + s2cafl;      // s2 total\\n\\n    //printf(\"%i, %i, %i, %i, %i, %i, %i, %i, %i, %i\", a, b, c, d, e[0], e[1], e[2], e[a], f, g[a]);\\n\\n    return s2t / n2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3203214,
                "title": "calculate-early-if-cycling-is-detected",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDetect looping alignment of substring finding and use that to calculate what the total would be without having to count it out completely.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLoop through s1 finding in-order occurrances of the characters from s2, counting cycles of s1 and s2 until the first cahracter of s2 is found again in the same position of s1 as it was the first time. also record s1 count at each s2 loop for later.\\n\\nIf n1 cycles of s1 have been reached before s2 alignment cycles, do simple calculation ([s2 cycles] / n2).\\n\\nIf s2 alignment is reached, total number of s2 cycles is ((n1 * [s2 cycles done]) / [s1 cycles done]) - ([s1 cycle s2 last completed on] == [final s1 cycle]). To get max cycles of n2 cycles of s2, integer divide by n2.\\n\\nIt might be needed to also detect s2 alignment looping that hapens on the 2nd or 3rd alignment position but never returns to the first, since 600ms seems a bit long for 50 testcases. Could be implemented as an array of max string length, each time s2 first char is found check for an entry at current s1 read point, and if there isn\\'t one enter [s2 cycle number] on that array point. found entry = break, subtract entry from s2 cycle number, calculate cycles, then add back on before divide by n2.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n\\xB7s)$$ - depends on length of the strings and how they loop. Worst case they never loop and the entire n1*s1 sequence has to be searched.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ \\n\\n# Code\\n```\\nint getMaxRepetitions(char * s1, int n1, char * s2, int n2){\\n    int a = 0, b = 0, c = 0, d = 0, e = -1, f = 0;\\n    char s1r, s2r = s2[b];\\n    while(c < n1)\\n    {   if(!(s1r = s1[a++])) { c++; a = 0; continue; } // loop reading of s1\\n        if(s2r == s1r) \\n        {   if(e == -1) e = a; else if((e == a) && (b == 0)) goto earlycalc; \\n            s2r = s2[++b];\\n        }\\n        if(!s2r) { s2r = s2[(b = 0)]; d++; f = c; }\\n    }\\n    return (d / n2);\\nearlycalc:\\n    // s2 is matching s1 in same place as first letter match - cycle is complete\\n    // after c cycles of s1 and d cycles of s2\\n    // so we can say (n1 * d) / c cycles of s2 are possible in n1 cycles of s1\\n    // and that / n2 cycles of n2 cycles of s2\\n    // if the last cycle of s2 crossed s1 loop boundry, calc will be 1 too high so we -(f==c) to remove the overcaclculation\\n   \\n    return ((((n1 * d) / c) - (f == c)) / n2); \\n}\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nint getMaxRepetitions(char * s1, int n1, char * s2, int n2){\\n    int a = 0, b = 0, c = 0, d = 0, e = -1, f = 0;\\n    char s1r, s2r = s2[b];\\n    while(c < n1)\\n    {   if(!(s1r = s1[a++])) { c++; a = 0; continue; } // loop reading of s1\\n        if(s2r == s1r) \\n        {   if(e == -1) e = a; else if((e == a) && (b == 0)) goto earlycalc; \\n            s2r = s2[++b];\\n        }\\n        if(!s2r) { s2r = s2[(b = 0)]; d++; f = c; }\\n    }\\n    return (d / n2);\\nearlycalc:\\n    // s2 is matching s1 in same place as first letter match - cycle is complete\\n    // after c cycles of s1 and d cycles of s2\\n    // so we can say (n1 * d) / c cycles of s2 are possible in n1 cycles of s1\\n    // and that / n2 cycles of n2 cycles of s2\\n    // if the last cycle of s2 crossed s1 loop boundry, calc will be 1 too high so we -(f==c) to remove the overcaclculation\\n   \\n    return ((((n1 * d) / c) - (f == c)) / n2); \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3136218,
                "title": "c-solution-100-00-faster",
                "content": "\\tpublic class Solution {\\n\\t\\tpublic int GetMaxRepetitions(string s1, int n1, string s2, int n2) \\n\\t\\t{\\n\\t\\t\\tint len1 = s1.Length, len2 = s2.Length;\\n\\t\\t\\tif (len1 == 0 || len2 == 0 || len1 * n1 < len2 * n2)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tint[] repeatCnt = new int[len2 + 1];\\n\\t\\t\\tint[] nextIdx = new int[len2 + 1];\\n\\t\\t\\tint cnt = 0, idx = 0;\\n\\t\\t\\tfor (int i = 0; i < n1; i++) \\n\\t\\t\\t{\\n\\t\\t\\t\\tforeach (char c in s1) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (c == s2[idx]) \\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\t\\t\\tif (idx == len2) \\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tidx = 0;\\n\\t\\t\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\trepeatCnt[i] = cnt;\\n\\t\\t\\t\\tnextIdx[i] = idx;\\n\\t\\t\\t\\tfor (int j = 0; j < i; j++) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (nextIdx[j] == idx) \\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint prefixCount = repeatCnt[j];\\n\\t\\t\\t\\t\\t\\tint patternCount = (repeatCnt[i] - repeatCnt[j]) * ((n1 - j - 1) / (i - j));\\n\\t\\t\\t\\t\\t\\tint suffixCount = repeatCnt[j + (n1 - j - 1) % (i - j)] - repeatCnt[j];\\n\\t\\t\\t\\t\\t\\treturn (prefixCount + patternCount + suffixCount) / n2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn repeatCnt[n1 - 1] / n2;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int GetMaxRepetitions(string s1, int n1, string s2, int n2) \\n\\t\\t{\\n\\t\\t\\tint len1 = s1.Length, len2 = s2.Length;\\n\\t\\t\\tif (len1 == 0 || len2 == 0 || len1 * n1 < len2 * n2)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tint[] repeatCnt = new int[len2 + 1];\\n\\t\\t\\tint[] nextIdx = new int[len2 + 1];\\n\\t\\t\\tint cnt = 0, idx = 0;\\n\\t\\t\\tfor (int i = 0; i < n1; i++) \\n\\t\\t\\t{\\n\\t\\t\\t\\tforeach (char c in s1) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (c == s2[idx]) \\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\t\\t\\tif (idx == len2) \\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tidx = 0;\\n\\t\\t\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3076718,
                "title": "simple-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        l1, l2 = len(s1), len(s2)\\n        visited = {}\\n        index = repeat_count = i = 0\\n        while i < n1:\\n            print(i)\\n            for j in range(l1):\\n                if s1[j] == s2[index]:\\n                    index += 1\\n                if index == l2:\\n                    index = 0\\n                    repeat_count += 1\\n            if index in visited:\\n                prev_i, prev_repeat_count = visited[index]\\n                r = (n1-1-i) // (i-prev_i)\\n                i += (i-prev_i)*r\\n                repeat_count += (repeat_count-prev_repeat_count )*r\\n                visited = {}\\n            else:\\n                visited[index] = [i, repeat_count]\\n            i += 1\\n        return repeat_count // n2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        l1, l2 = len(s1), len(s2)\\n        visited = {}\\n        index = repeat_count = i = 0\\n        while i < n1:\\n            print(i)\\n            for j in range(l1):\\n                if s1[j] == s2[index]:\\n                    index += 1\\n                if index == l2:\\n                    index = 0\\n                    repeat_count += 1\\n            if index in visited:\\n                prev_i, prev_repeat_count = visited[index]\\n                r = (n1-1-i) // (i-prev_i)\\n                i += (i-prev_i)*r\\n                repeat_count += (repeat_count-prev_repeat_count )*r\\n                visited = {}\\n            else:\\n                visited[index] = [i, repeat_count]\\n            i += 1\\n        return repeat_count // n2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883422,
                "title": "100",
                "content": "![image.png](https://assets.leetcode.com/users/images/5a09beb5-18a4-47c3-b40b-7c30f69df7dd_1670323817.7765276.png)\\n\\n# Explain:\\n\\nthe goal is to find a block of x concatinations of s1 that contains all chars of s2 without leftovers from s2. once we have this block we can calculate how many times s2 * n2 fits in s1 * n1. \\n\\n#### for example:\\n#### input:\\n\"baba\" 11\\n\"baab\" 1\\n\\nwe will start by comparing \"baba\" to \"baab\":\\ns1 - b, s2 b ---> local counter = 1 ----> main counter = 0\\ns1 - a, s2 a ---> local counter = 2 ----> main counter = 0\\ns1 - b, s2 a ---> local counter = 2 ----> main counter = 0\\ns1 - a, s2 a ---> local counter = 3 ----> main counter = 0\\n\\nloop #1 ends with 3 out of 4 characters found. \\n\\ns1 - b, s2 b ---> local counter = 4 ----> main counter = 1\\ns1 - a, s2 b ---> local counter = 0 ----> main counter = 1\\ns1 - b, s2 b ---> local counter = 1 ----> main counter = 1\\ns1 - a, s2 a ---> local counter = 2 ----> main counter = 1\\n\\nloop #2 ends and we found that s2 appear 1 time in s1 (*1) and we have 2 characters left.\\n\\ns1 - b, s2 a ---> local counter = 2 ----> main counter = 1\\ns1 - a, s2 a ---> local counter = 3 ----> main counter = 1\\ns1 - b, s2 b ---> local counter = 4 ----> main counter = 2\\ns1 - a, s2 b ---> local counter = 0 ----> main counter = 2\\n\\nloop #3 ends and we found that s2 appear 2 time in s1 (*2) and we have no characters left.\\n\\nwe know now that a block of s1 * 3 have exactly 2 matches of s2.\\n\\nthe doulications of s2 is 1 and the douplications of s1 is 11\\ntherefor the answer should be (1/2) * (11 / 3) rounded to the bottom. \\n\\n# Complexity\\n    O(n)\\n\\n# Code\\n```\\n/**\\n * @param {string} s1\\n * @param {number} n1\\n * @param {string} s2\\n * @param {number} n2\\n * @return {number}\\n */\\nvar getMaxRepetitions = function(s1, n1, s2, n2) {\\n    let idx2 = 0;\\n    \\n    let doWhile = true;\\n    let strCounter = 0;\\n    let sumChars = 0;\\n    let iterations = 0;\\n    while (doWhile && iterations < n1) {\\n        for (let idx1 = 0; idx1 < s1.length; idx1++) {\\n            const char1 = s1[idx1];\\n            const char2 = s2[idx2];\\n            if (char1 === char2) {\\n                sumChars++;\\n                idx2++;\\n                if (sumChars === s2.length) {\\n                    strCounter ++;\\n                    sumChars = 0;\\n                    idx2 = 0;\\n                }\\n            }\\n        }\\n        if (sumChars === 0) {\\n            doWhile = false;\\n        }\\n        iterations++;\\n    }\\n    \\n    return Math.floor((strCounter / n2) * (n1 / iterations));\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s1\\n * @param {number} n1\\n * @param {string} s2\\n * @param {number} n2\\n * @return {number}\\n */\\nvar getMaxRepetitions = function(s1, n1, s2, n2) {\\n    let idx2 = 0;\\n    \\n    let doWhile = true;\\n    let strCounter = 0;\\n    let sumChars = 0;\\n    let iterations = 0;\\n    while (doWhile && iterations < n1) {\\n        for (let idx1 = 0; idx1 < s1.length; idx1++) {\\n            const char1 = s1[idx1];\\n            const char2 = s2[idx2];\\n            if (char1 === char2) {\\n                sumChars++;\\n                idx2++;\\n                if (sumChars === s2.length) {\\n                    strCounter ++;\\n                    sumChars = 0;\\n                    idx2 = 0;\\n                }\\n            }\\n        }\\n        if (sumChars === 0) {\\n            doWhile = false;\\n        }\\n        iterations++;\\n    }\\n    \\n    return Math.floor((strCounter / n2) * (n1 / iterations));\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2858977,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn get_max_repetitions(s1: String, n1: i32, s2: String, n2: i32) -> i32 {\\n        let m = s1.len();\\n        let n = s2.len();\\n        let mut x = vec![vec![0; n]; m];\\n        let mut y = vec![vec![0; n]; m];\\n        let (mut i, mut j) = (0, 1);\\n        loop {\\n            i += 1;\\n            let ii = (i % m as i32) as usize;\\n            let jj = (j % n as i32) as usize;\\n            let xx = x[ii][jj];\\n            let yy = y[ii][jj];\\n            x[ii][jj] = i;\\n            y[ii][jj] = j;\\n            if xx > 0 {\\n                let k = (n1 * m as i32 - i) / (i - xx);\\n                i += k * (i - xx);\\n                j += k * (j - yy);\\n            }\\n            if i == n1 * m as i32 {\\n                return j / (n * n2 as usize) as i32;\\n            }\\n            if s1.chars().nth(ii) == s2.chars().nth(jj) {\\n                j += 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_max_repetitions(s1: String, n1: i32, s2: String, n2: i32) -> i32 {\\n        let m = s1.len();\\n        let n = s2.len();\\n        let mut x = vec![vec![0; n]; m];\\n        let mut y = vec![vec![0; n]; m];\\n        let (mut i, mut j) = (0, 1);\\n        loop {\\n            i += 1;\\n            let ii = (i % m as i32) as usize;\\n            let jj = (j % n as i32) as usize;\\n            let xx = x[ii][jj];\\n            let yy = y[ii][jj];\\n            x[ii][jj] = i;\\n            y[ii][jj] = j;\\n            if xx > 0 {\\n                let k = (n1 * m as i32 - i) / (i - xx);\\n                i += k * (i - xx);\\n                j += k * (j - yy);\\n            }\\n            if i == n1 * m as i32 {\\n                return j / (n * n2 as usize) as i32;\\n            }\\n            if s1.chars().nth(ii) == s2.chars().nth(jj) {\\n                j += 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2799895,
                "title": "easy-understandable-solution",
                "content": "```\\nclass Solution {\\n    bool alls2Ins1(string s2,string s1){\\n       map<char,bool>mp;\\n        for(auto e:s1)\\n            mp[e]=true;\\n        for(auto e:s2){\\n            if(!mp[e])\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int n=s1.size();\\n        int m=s2.size();\\n        \\n        // find how many times can s2 be made a subsequence of [s1,n1]\\n        \\n        if(!alls2Ins1(s2,s1))\\n            return 0;\\n        \\n            int maxMatch[m];\\n        memset(maxMatch,0,sizeof(maxMatch));\\n        \\n        for(int i=0;i<m;i++){\\n            int ptr=i;\\n            \\n            for(int j=0;j<n;j++){\\n                if(s1[j]==s2[ptr]){\\n                  maxMatch[i]++;\\n                    ptr++;\\n                    ptr%=m;\\n                }\\n            }\\n            \\n        }\\n        \\n        int tot=0;\\n        \\n        int cur=0;\\n        \\n        for(int i=0;i<n1;i++){\\n           int matched= maxMatch[cur];\\n            tot+=matched;\\n            cur+=matched;\\n            cur%=m;\\n        }\\n        \\n        return (tot/m)/n2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool alls2Ins1(string s2,string s1){\\n       map<char,bool>mp;\\n        for(auto e:s1)\\n            mp[e]=true;\\n        for(auto e:s2){\\n            if(!mp[e])\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int n=s1.size();\\n        int m=s2.size();\\n        \\n        // find how many times can s2 be made a subsequence of [s1,n1]\\n        \\n        if(!alls2Ins1(s2,s1))\\n            return 0;\\n        \\n            int maxMatch[m];\\n        memset(maxMatch,0,sizeof(maxMatch));\\n        \\n        for(int i=0;i<m;i++){\\n            int ptr=i;\\n            \\n            for(int j=0;j<n;j++){\\n                if(s1[j]==s2[ptr]){\\n                  maxMatch[i]++;\\n                    ptr++;\\n                    ptr%=m;\\n                }\\n            }\\n            \\n        }\\n        \\n        int tot=0;\\n        \\n        int cur=0;\\n        \\n        for(int i=0;i<n1;i++){\\n           int matched= maxMatch[cur];\\n            tot+=matched;\\n            cur+=matched;\\n            cur%=m;\\n        }\\n        \\n        return (tot/m)/n2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787702,
                "title": "count-the-repetitions-hard",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWipo\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        // ptr2--> s2+s2+s2......  str2\\n        // ptr1--> s1+s1+..s1 --> str1\\n        \\n        int len1=s1.length();\\n        int len2=s2.length();\\n        \\n        unordered_map<int,int> increase;\\n        \\n        for(int i=0;i<len2;i++) {\\n            int ptr1=0;\\n            int ptr2=i;\\n            while(ptr1!=len1) {\\n                if(s1[ptr1]==s2[ptr2%len2]) {\\n                    ptr1++;\\n                    ptr2++;\\n                } else {\\n                    ptr1++;\\n                }\\n            }\\n            increase[i]=ptr2-i;\\n        }\\n        \\n        // O(len2*len1)\\n        \\n        int ptr=0;\\n        int totalMatchedLength=0;\\n        \\n        for(int i=0;i<n1;i++) {\\n            totalMatchedLength+=increase[ptr];\\n            ptr+=increase[ptr];\\n            ptr%=len2;\\n        }\\n        \\n        // O(n1+len2*len1)\\n        \\n        \\n        return totalMatchedLength/(len2*n2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        // ptr2--> s2+s2+s2......  str2\\n        // ptr1--> s1+s1+..s1 --> str1\\n        \\n        int len1=s1.length();\\n        int len2=s2.length();\\n        \\n        unordered_map<int,int> increase;\\n        \\n        for(int i=0;i<len2;i++) {\\n            int ptr1=0;\\n            int ptr2=i;\\n            while(ptr1!=len1) {\\n                if(s1[ptr1]==s2[ptr2%len2]) {\\n                    ptr1++;\\n                    ptr2++;\\n                } else {\\n                    ptr1++;\\n                }\\n            }\\n            increase[i]=ptr2-i;\\n        }\\n        \\n        // O(len2*len1)\\n        \\n        int ptr=0;\\n        int totalMatchedLength=0;\\n        \\n        for(int i=0;i<n1;i++) {\\n            totalMatchedLength+=increase[ptr];\\n            ptr+=increase[ptr];\\n            ptr%=len2;\\n        }\\n        \\n        // O(n1+len2*len1)\\n        \\n        \\n        return totalMatchedLength/(len2*n2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777270,
                "title": "swift-solution-tle",
                "content": "```\\n// Count the repetitions\\n// LeetCode: https://leetcode.com/problems/count-the-repetitions/\\n\\nclass Solution {\\n    func getMaxRepetitions(_ s1: String, _ n1: Int, _ s2: String, _ n2: Int) -> Int {\\n        let s1 = Array(s1)\\n        let s2 = Array(s2)\\n        var count1 = 0\\n        var count2 = 0\\n        var i = 0\\n        var j = 0\\n        while count1 < n1 {\\n            if s1[i] == s2[j] {\\n                j += 1\\n                if j == s2.count {\\n                    j = 0\\n                    count2 += 1\\n                }\\n            }\\n            i += 1\\n            if i == s1.count {\\n                i = 0\\n                count1 += 1\\n            }\\n        }\\n        return count2 / n2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n// Count the repetitions\\n// LeetCode: https://leetcode.com/problems/count-the-repetitions/\\n\\nclass Solution {\\n    func getMaxRepetitions(_ s1: String, _ n1: Int, _ s2: String, _ n2: Int) -> Int {\\n        let s1 = Array(s1)\\n        let s2 = Array(s2)\\n        var count1 = 0\\n        var count2 = 0\\n        var i = 0\\n        var j = 0\\n        while count1 < n1 {\\n            if s1[i] == s2[j] {\\n                j += 1\\n                if j == s2.count {\\n                    j = 0\\n                    count2 += 1\\n                }\\n            }\\n            i += 1\\n            if i == s1.count {\\n                i = 0\\n                count1 += 1\\n            }\\n        }\\n        return count2 / n2\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684735,
                "title": "c-solution-using-two-approaches-preprocessing-using-dynamic-programming-and-pattern-finding",
                "content": "## **Approach 1:** Preprocessing using Dynamic Programming\\n1. str1=[s1,n1] and str2=[s2,n2], we need to find how many times the string str2  occurs as distinct subsequences in the string str1.\\n2. Let cnt1 and cnt2 be the number of times we have visited the string s1 and the string s2.\\n3. We also maintain pointers i, and j to iterate over s1 and s2. \\n4. In the brute force approach, we scan s1 and s2 and increments all these variables accordingly. The required result is obtained by cnt2/n2. But the time complexity is O(s1.size()*n1).\\n5. As the string str1 is the repetition of string s1, we can improve the brute force with some preprocessing. \\n6. Let us the define the state **dp[i][j]=maxMatch**, such that maxMatch is the maximum length of s2[j:]+[s2,x], x>0, which occurs as subsequence in the string s1[i:].\\n7. Now, we can use this pre-processing to fast-forward our brute force approach. We can process the entire string s1, in O(1) time. The overall time complexity of this approach will be O(n1).\\n8. We no longer require the pointer i for string s1 as the entire string will be processed in O(1)  time. We just need to carefully increment the pointer j and cnt2.\\n9. While calculating the result, we will only require dp[0][j] states but not other states so therefore we can bring down the space complexity from O(s1.size()*s2.size()) to O(s2.size())\\n10. Therefore the space complexity is **O(s2.size())** and the time complexity is **O(n1+s1.size()*s2.size())**.\\n11. Calculating the actual result from this preprocessing is quite simple, we just iterate over the string s1 for n1 times and increment the pointer j and cnt2 pointers accordingly.\\n\\n```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int>dp(s2.size());\\n        for(int i=s1.size()-1 ; i>=0 ; i--)\\n        { vector<int>tmp(s2.size());\\n          for(int j=s2.size()-1 ; j>=0 ; j--)\\n          { if(s1[i]==s2[j])\\n            { tmp[j]++;\\n              if((i+1)<s1.size())\\n              { int p=j+1; if(p==s2.size()) p=0;\\n                tmp[j]+=dp[p];\\n              }\\n            }\\n            else if((i+1)<s1.size())\\n              tmp[j]=dp[j];\\n          }  \\n          dp=tmp;\\n        }\\n        \\n        int res=0,cnt1=0,cnt2=0,j=0;\\n        while(cnt1<n1)\\n        { int maxMatch=dp[j];\\n          cnt1++;\\n         \\n          int diff=s2.size()-j;\\n          if(diff>=maxMatch)\\n          { j+=maxMatch;\\n            if(j==s2.size()) { j=0; cnt2++; }\\n          }\\n          else \\n          { cnt2++;\\n            maxMatch-=diff; j=maxMatch%s2.size();\\n            cnt2+=(maxMatch/(s2.size()));\\n          }\\n        }\\n        return cnt2/n2;\\n    }\\n};\\n\\n```\\n\\n## **Approach 2: Finding the Pattern**\\n\\n1. In the brute force approach, we iterate over s1 for n1 times. Whenever we are at index 0 of s1, the maximum **number of different possible indexes pointing to s2 is s2.size()**. Therefore, by pigeonhole principle, if we visit the string s1 at (s1.size()+1)^{th} time (in the worst case), we will be visiting a particular index at the second time.\\n2. Note: In the previous approach as well, we were maintaining the j^{th} index, pointing to s2, for each iteration of s1.\\n2. Therefore, the pattern had occurred for the first time. Using this pattern, we can now calculate our required result in O(1) time.\\n3. Suppose, the index ind pointing to s2 occurs at i^{th}  and k^{th} iteration of s2, where k<i. Then the next occurrence of index ind occurs at [i+(i-k)]^{th} iteration and so on. We must have, i+t*(i-k)<n1 [using 0 based indexed while iterating through the string s1] \\u21D2 i+t*(i-k) <= (n1-1) \\u21D2 **t <= (n1-1-i)/(i-k)** and therefore the pattern occurs for t+1, times.\\n4. Then the maximum iteration number we can achieve for the occurrence of pattern is: maxind=i+t*(i-k).\\n5. Our result can be obtained in three parts:\\nFirst part: **res+=cnt[k]** (Before occurrence of pattern).\\nSecond part: **res+=(cnt[i]-cnt[k])\\\\*(t+1)** [The pattern itself]\\nThird part: **res+=cnt[k+n1-1-maxind]-cnt[k]**   [The remaining part]\\n6. The Time Complexity is O(s1.size()*s2.size()) and Space Complexity is O(s2.size()).\\n\\n```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int>nxtind(s2.size()+1),cnt(s2.size()+1);\\n        int ind=0,tcnt=0;\\n        \\n        for(int i=0; i<n1 ; i++)\\n        { for(int j=0 ; j<s1.size(); j++)\\n          { if(s1[j]==s2[ind]) ind++;\\n            if(ind==s2.size()) {ind=0; tcnt++;}   \\n          }\\n          cnt[i]=tcnt;\\n          nxtind[i]=ind;\\n          for(int k=0 ; k<i ; k++)\\n          { if(nxtind[k]==ind)\\n            { int res=cnt[k];\\n              int t=(n1-1-i)/(i-k);\\n              res+=(cnt[i]-cnt[k])*(t+1); \\n              int maxind=i+(i-k)*t;\\n              if(maxind<(n1-1)) res+=cnt[k+n1-1-maxind]-cnt[k];\\n              return res/n2;\\n            }  \\n          }\\n        }\\n        return cnt[n1-1]/n2;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int>dp(s2.size());\\n        for(int i=s1.size()-1 ; i>=0 ; i--)\\n        { vector<int>tmp(s2.size());\\n          for(int j=s2.size()-1 ; j>=0 ; j--)\\n          { if(s1[i]==s2[j])\\n            { tmp[j]++;\\n              if((i+1)<s1.size())\\n              { int p=j+1; if(p==s2.size()) p=0;\\n                tmp[j]+=dp[p];\\n              }\\n            }\\n            else if((i+1)<s1.size())\\n              tmp[j]=dp[j];\\n          }  \\n          dp=tmp;\\n        }\\n        \\n        int res=0,cnt1=0,cnt2=0,j=0;\\n        while(cnt1<n1)\\n        { int maxMatch=dp[j];\\n          cnt1++;\\n         \\n          int diff=s2.size()-j;\\n          if(diff>=maxMatch)\\n          { j+=maxMatch;\\n            if(j==s2.size()) { j=0; cnt2++; }\\n          }\\n          else \\n          { cnt2++;\\n            maxMatch-=diff; j=maxMatch%s2.size();\\n            cnt2+=(maxMatch/(s2.size()));\\n          }\\n        }\\n        return cnt2/n2;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int>nxtind(s2.size()+1),cnt(s2.size()+1);\\n        int ind=0,tcnt=0;\\n        \\n        for(int i=0; i<n1 ; i++)\\n        { for(int j=0 ; j<s1.size(); j++)\\n          { if(s1[j]==s2[ind]) ind++;\\n            if(ind==s2.size()) {ind=0; tcnt++;}   \\n          }\\n          cnt[i]=tcnt;\\n          nxtind[i]=ind;\\n          for(int k=0 ; k<i ; k++)\\n          { if(nxtind[k]==ind)\\n            { int res=cnt[k];\\n              int t=(n1-1-i)/(i-k);\\n              res+=(cnt[i]-cnt[k])*(t+1); \\n              int maxind=i+(i-k)*t;\\n              if(maxind<(n1-1)) res+=cnt[k+n1-1-maxind]-cnt[k];\\n              return res/n2;\\n            }  \\n          }\\n        }\\n        return cnt[n1-1]/n2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677329,
                "title": "calculate-wraparound-position-smart-cycle-repetition-counting",
                "content": "# Intuition\\nLet\\'s reword the question to **\"how many occurences of `[str2, n2]` appears in `[str1, n1]` as a subsequence\"**, and then the intent of the question should be much easier to understand. Which is why **the question explaisn the \"removing\" characters part**, because then we can delete all the characters outside of the subsequences and have the result as a string.\\n\\n#### Step 1: Naive Brute Force (TLE)\\nLet\\'s have **two pointers** moving in both strings, we move the `str1` pointer until we encounter `str2[i]`, and then we keep track of how many \"whole\" `str2` have we seen.\\n\\nThe problem then becomes that `n1*str1.size()` and `n2*str2.size()` can become too big (10^6*100=10^8 characters), but the idea of the two pointers remain as the general idea to improve the naive brute force.\\n\\n#### Step 2: Better Brute Force (TLE)\\nWhat if we can somehow avoid doing two pointers **naively** to search for characters of `str2`? Notice that we start with `str2[0]` and then go to `str2[str2.size() - 1]`, and **they\\'re same position in `str1` over and over again.** Remember that we\\'re working with **copies of `str1`**, so we can treat this process as **going through cycles of `str1`!** For every index in `str1` such that `str1[i] == str2[0]`, we can calculate the number of cycles we\\'d need and the position we\\'d end up with.\\n\\nE.g. `str1 = \"baba\"` and `str2 = \"baab\"`, we\\'d have `cycles = [1,0,1,0]` and `dest = [0,0,2,0]` (remember we only care about `str1[i] == str2[0]`)\\n- Starting at `i = 0`, we\\'d need `1` cycle to find `baab` because we need `babababa` to get one `baab`, we\\'d also end up at `i = 4`, which is really `i = 0` for the second copy of `str1`\\n- Starting at `i = 2`, we\\'d again need `1` cycle to find `baab` because we need `babababa` to get one `baab`, we\\'d also end up at `i = 6`, which is really `i = 2` for the second copy of `str1`\\n\\nNow, we have the information to traverse `str2` at any position in `O(1)`. But hold on, it still handle cases like this one `str1 = \"a\"*100 (100 a\\'s), n1 = 1000000` and `str2 = \"a\", n2 = 1000000`. Notice that **we have multiple \"whole\" `str2` in one `str1`.** So we\\'re finding 100 `str2` and doing that `1000000` times, which still ends up being too many operations.\\n\\n#### Step 3: Smarter Brute Force (Accepted)\\nTo account for multiple `str2` problem mentioned above, we create new information `fit_copies` and `fit_dest`, which tells us how many whole `str2` we have in `str1` starting at `i`, and where we\\'d end up fitting all the `str2` we find starting at `i`. Together with this information combined with the position wrapping information from above, we can figure out how many `str2`\\'s we\\'d have in one `str1` in `O(1)`, and travel to the next cycle of `str1` in `O(1)`. This means **we\\'d have maximum `O(1000000)` to perform as each cycle is `O(1)`.**\\n\\n# Approach\\n1. Check if it\\'s possible to have `str2` by checking `str1` have all the charaters needed for `str2`\\n2. Precompute information for cycles and wraparound position to go through entirety of `str2` for every `cycles[i]` and `dest[i]` such that `str1[i] == str2[0]`\\n3. Precompute information for maximum number of `str2` and the position we\\'d end up at in `fit_copies[i]` and `fit_dest` starting at `str1[i]` such that `str1[i] == str2[0]`\\n4. Go through each cycle and update our answer\\n\\n# Complexity\\n- Time complexity: $$O(n1 * log(len(str1)))$$\\n    - Since we\\'re calculating how many `str2` we can have for `str1`, but we have to do that `n1` times. We\\'re also performing binary search to find the appropriate position to start counting the cycles\\n\\n- Space complexity: $$O(len(str1))$$\\n    - The biggest storage comes from storing the positions of each letter in `str1`\\n\\n# Code\\n```\\n#define all(x) x.begin(), x.end()\\n#define vec vector\\n\\nusing vi = vec<int>;\\nusing vvi = vec<vec<int>>;\\n\\nclass Solution {\\npublic:\\n  int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n    int m1 = s1.size(), m2 = s2.size();\\n\\n    // Check if `str2` is possible\\n    vi exists1(26), exists2(26);\\n    for (int i = 0; i < m1; i++) {\\n      exists1[s1[i] - \\'a\\'] = true;\\n    }\\n    for (int i = 0; i < m2; i++) {\\n      exists2[s2[i] - \\'a\\'] = true;\\n    }\\n    for (int i = 0; i < 26; i++) {\\n      if (exists2[i] && !exists1[i]) {\\n        return 0;\\n      }\\n    }\\n\\n    vvi pos(26);\\n    for (int i = 0; i < m1; i++) {\\n      pos[s1[i] - \\'a\\'].push_back(i);\\n    }\\n\\n    vi cycles(m1), dest(m1);\\n    for (int start = 0; start < m1; start++) {\\n      if (s1[start] != s2[0]) {\\n        continue;\\n      }\\n\\n      int cycle = 0, end = start - 1;\\n      for (int i = 0; i < m2; i++) {\\n        auto &poses = pos[s2[i] - \\'a\\'];\\n        assert(!poses.empty());\\n\\n        auto it = upper_bound(all(poses), end);\\n        if (it == poses.end()) {\\n          // We need another cycle to go through rest of `str2`\\n          cycle++;\\n          end = poses[0];\\n        } else {\\n          end = *it;\\n        }\\n      }\\n      dest[start] = end;\\n      cycles[start] = cycle;\\n    }\\n\\n    vi fit_copies(m1), fit_dest(m1);\\n    for (int start = 0; start < m1; start++) {\\n      if (s1[start] != s2[0]) {\\n        continue;\\n      }\\n\\n      int fits = 0, end = start - 1;\\n      while (true) {\\n        auto &poses = pos[s2[0] - \\'a\\'];\\n        assert(!poses.empty());\\n\\n        auto it = upper_bound(all(poses), end);\\n        // Another `str2` would need another cycle\\n        if (it == poses.end() || cycles[*it] > 0) {\\n          break;\\n        } else {\\n          fits++;\\n          end = dest[*it];\\n        }\\n      }\\n      fit_copies[start] = fits;\\n      fit_dest[start] = end;\\n    }\\n\\n    int cycle = 1, prev = -1, cnt = 0;\\n    while (cycle <= n1) {\\n      auto &poses = pos[s2[0] - \\'a\\'];\\n      assert(!poses.empty());\\n\\n      auto it = upper_bound(all(poses), prev);\\n      if (it == poses.end()) {\\n        // We end up perfectly at the end, go to next cycle\\n        cycle += 1 + cycles[poses[0]];\\n        prev = dest[poses[0]];\\n        cnt++;\\n      } else if (cycles[*it] > 0) {\\n        // Have part of `str2` until next cycle\\n        cycle += cycles[*it];\\n        prev = dest[*it];\\n        cnt++;\\n      } else {\\n        // Have multiple `str2` for the current cycle\\n        prev = fit_dest[*it];\\n        cnt += fit_copies[*it];\\n      }\\n    }\\n\\n    // When we stop, we have one extra count, so get rid of that\\n    // Remember we need to account for `n2`, a division can do\\n    return (cnt - 1) / n2;\\n  }\\n};",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Two Pointers",
                    "Binary Search",
                    "Simulation"
                ],
                "code": "class Solution {\\npublic:\\n  int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n    int m1 = s1.size(), m2 = s2.size();\\n\\n    // Check if `str2` is possible\\n    vi exists1(26), exists2(26);\\n    for (int i = 0; i < m1; i++) {\\n      exists1[s1[i] - \\'a\\'] = true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2521184,
                "title": "python3-repeating-patterns",
                "content": "\\n```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        cnt = idx = 0 \\n        count = []\\n        index = []\\n        for i in range(n1): \\n            for ch in s1: \\n                if ch == s2[idx]: \\n                    idx += 1\\n                    if idx == len(s2): \\n                        cnt += 1\\n                        idx = 0 \\n            count.append(cnt)\\n            index.append(idx)\\n            for ii in range(i): \\n                if index[ii] == idx: \\n                    prev = count[ii]\\n                    repeat = (cnt - prev) * ((n1-1-ii) // (i - ii))\\n                    post = count[ii + (n1-1-ii) % (i-ii)] - count[ii]\\n                    return (prev + repeat + post) // n2\\n        return count[-1]//n2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        cnt = idx = 0 \\n        count = []\\n        index = []\\n        for i in range(n1): \\n            for ch in s1: \\n                if ch == s2[idx]: \\n                    idx += 1\\n                    if idx == len(s2): \\n                        cnt += 1\\n                        idx = 0 \\n            count.append(cnt)\\n            index.append(idx)\\n            for ii in range(i): \\n                if index[ii] == idx: \\n                    prev = count[ii]\\n                    repeat = (cnt - prev) * ((n1-1-ii) // (i - ii))\\n                    post = count[ii + (n1-1-ii) % (i-ii)] - count[ii]\\n                    return (prev + repeat + post) // n2\\n        return count[-1]//n2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398242,
                "title": "c-using-hash-to-ditect-repetition-and-reduce-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int i = 0;\\n        int j = 0;\\n        int sn2 = n2;\\n        int sn1 = n1;\\n        unordered_map<long long,long long> m;\\n        bool found = false;\\n        long long  ii = 0;\\n        long long  jj = 0;\\n        while(n1>0)\\n        {\\n            if (s1[i]==s2[j]) \\n            {\\n                if (m.count(i*1000000+j))\\n                {\\n                    int ii1 = m[i*1000000+j]/1000000;\\n                    int jj1 = m[i*1000000+j]%1000000;\\n                    int ii_diff = ii-ii1;\\n                    int jj_diff = jj-jj1;\\n                    int  x = (s1.size()*sn1-ii)/ii_diff;\\n                    ii += x*ii_diff;\\n                    jj += x*jj_diff;\\n                    i = ii%s1.size();\\n                    j = jj%s2.size();\\n                    n1 = sn1 -ii/s1.size();\\n                    n2 = sn2 -jj/s2.size();\\n                    if (n1 == 0)\\n                        break;\\n                }\\n                else\\n                m[i*1000000+j]=ii*1000000+jj;\\n                jj++;\\n                if (++j >= s2.size())\\n                {\\n                    j = 0;\\n                    if(--n2 == 0)\\n                    {\\n                        ans++;\\n                        n2=sn2;\\n                    }\\n                }\\n            }\\n            ii++;\\n            if (++i == s1.size())\\n            {\\n                i=0;\\n                n1--;\\n            }\\n\\n        }\\n        return jj/(s2.size()*sn2);\\n    }\\n};\\n\\n/*\\n\"niconiconi\"\\n99981\\n\"nico\"\\n81\\n\\n\"acb\"\\n1\\n\"ab\"\\n1\\n\\n\"aaa\"\\n3\\n\"aa\"\\n1\\n\\n\"acb\"\\n4\\n\"ab\"\\n2\\n\\n\"bacaba\"\\n3\\n\"abacab\"\\n1\\n\\n\"phqghumeaylnlfdxfircvscxggbwkfnqduxwfnfozvsrtkjprepggxrpnrvystmwcysyycqpevikef\"\\n1000000\\n\"fmznimkkasvwsrenzkycxfxtlsgypsfad\"\\n333\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n1000000\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n1000000\\n\\n\"a\"\\n1000000\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n1000\\n\\n\"phqghumeaylnlfdxfircvscxggbwkfnqduxwfnfozvsrtkjpre\"\\n1000000\\n\"pggxr\"\\n100\\n\\n\"a\"\\n1000000\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n1000\\n\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int i = 0;\\n        int j = 0;\\n        int sn2 = n2;\\n        int sn1 = n1;\\n        unordered_map<long long,long long> m;\\n        bool found = false;\\n        long long  ii = 0;\\n        long long  jj = 0;\\n        while(n1>0)\\n        {\\n            if (s1[i]==s2[j]) \\n            {\\n                if (m.count(i*1000000+j))\\n                {\\n                    int ii1 = m[i*1000000+j]/1000000;\\n                    int jj1 = m[i*1000000+j]%1000000;\\n                    int ii_diff = ii-ii1;\\n                    int jj_diff = jj-jj1;\\n                    int  x = (s1.size()*sn1-ii)/ii_diff;\\n                    ii += x*ii_diff;\\n                    jj += x*jj_diff;\\n                    i = ii%s1.size();\\n                    j = jj%s2.size();\\n                    n1 = sn1 -ii/s1.size();\\n                    n2 = sn2 -jj/s2.size();\\n                    if (n1 == 0)\\n                        break;\\n                }\\n                else\\n                m[i*1000000+j]=ii*1000000+jj;\\n                jj++;\\n                if (++j >= s2.size())\\n                {\\n                    j = 0;\\n                    if(--n2 == 0)\\n                    {\\n                        ans++;\\n                        n2=sn2;\\n                    }\\n                }\\n            }\\n            ii++;\\n            if (++i == s1.size())\\n            {\\n                i=0;\\n                n1--;\\n            }\\n\\n        }\\n        return jj/(s2.size()*sn2);\\n    }\\n};\\n\\n/*\\n\"niconiconi\"\\n99981\\n\"nico\"\\n81\\n\\n\"acb\"\\n1\\n\"ab\"\\n1\\n\\n\"aaa\"\\n3\\n\"aa\"\\n1\\n\\n\"acb\"\\n4\\n\"ab\"\\n2\\n\\n\"bacaba\"\\n3\\n\"abacab\"\\n1\\n\\n\"phqghumeaylnlfdxfircvscxggbwkfnqduxwfnfozvsrtkjprepggxrpnrvystmwcysyycqpevikef\"\\n1000000\\n\"fmznimkkasvwsrenzkycxfxtlsgypsfad\"\\n333\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n1000000\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n1000000\\n\\n\"a\"\\n1000000\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n1000\\n\\n\"phqghumeaylnlfdxfircvscxggbwkfnqduxwfnfozvsrtkjpre\"\\n1000000\\n\"pggxr\"\\n100\\n\\n\"a\"\\n1000000\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n1000\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2307017,
                "title": "java-6ms-find-cycle-o-mn",
                "content": "Not much to say, find the cycle. It is quite weird it is tagged under DP question. More like cycle detection question.\\n\\nThis runs in `O(MN)` because we are bound to encounter a cycle in all `M*N` possibilities, and whenever we do, we skip to near the end.\\n#### Java\\n```Java\\nclass Solution {\\n    public int getMaxRepetitions(String A, int a, String B, int b) {\\n        int m = A.length(), n = B.length();\\n        int[][] x = new int[m][n];\\n        int[][] y = new int[m][n];\\n        for (int i = 1, j = 1; true; i++){\\n            int ii = i%m, jj = j%n, xx = x[ii][jj], yy = y[ii][jj];\\n            x[ii][jj]=i;\\n            y[ii][jj]=j;\\n            if (xx > 0){ // ultra jump to the end!\\n                int k = (a*m-i)/(i-xx);\\n                i += k*(i-xx);\\n                j += k*(j-yy);\\n            }\\n            if (i == a*m){ // reached the end\\n                return j/(n*b);\\n            }\\n            if (A.charAt(ii)==B.charAt(jj)){ // subsequence check\\n                j++;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int getMaxRepetitions(String A, int a, String B, int b) {\\n        int m = A.length(), n = B.length();\\n        int[][] x = new int[m][n];\\n        int[][] y = new int[m][n];\\n        for (int i = 1, j = 1; true; i++){\\n            int ii = i%m, jj = j%n, xx = x[ii][jj], yy = y[ii][jj];\\n            x[ii][jj]=i;\\n            y[ii][jj]=j;\\n            if (xx > 0){ // ultra jump to the end!\\n                int k = (a*m-i)/(i-xx);\\n                i += k*(i-xx);\\n                j += k*(j-yy);\\n            }\\n            if (i == a*m){ // reached the end\\n                return j/(n*b);\\n            }\\n            if (A.charAt(ii)==B.charAt(jj)){ // subsequence check\\n                j++;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303632,
                "title": "time-o-s1-len-s2-len-c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> countr(s2.size(),-1), indexr(s2.size(),-1);\\n        int count = 0;\\n        vector<int> seqIndex;\\n        for (int i=0, j2=0; i<n1; i++) {\\n            if (indexr[j2] > -1) {\\n                int repC = count-countr[j2];\\n                int repN = i - indexr[j2];\\n                int remainingN = n1 - i;\\n\\t\\t\\t\\t//the times that the pattern repeated\\n                count += remainingN/repN * repC;\\n\\t\\t\\t\\t//the residue at the end of str1, but still might form valid s2\\n                int j2_ = seqIndex[indexr[j2]+remainingN%repN];\\n                count += countr[j2_] - countr[j2];\\n                break;\\n            } else {\\n                countr[j2] = count;\\n                indexr[j2] = i;\\n                seqIndex.push_back(j2);\\n            }\\n            \\n            for (int j1=0; j1<s1.size(); j1++) {\\n                if (s1[j1] == s2[j2]) {\\n                    j2++;\\n                    if (j2 == s2.size()) {\\n                        j2 = 0;\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count/n2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> countr(s2.size(),-1), indexr(s2.size(),-1);\\n        int count = 0;\\n        vector<int> seqIndex;\\n        for (int i=0, j2=0; i<n1; i++) {\\n            if (indexr[j2] > -1) {\\n                int repC = count-countr[j2];\\n                int repN = i - indexr[j2];\\n                int remainingN = n1 - i;\\n\\t\\t\\t\\t//the times that the pattern repeated\\n                count += remainingN/repN * repC;\\n\\t\\t\\t\\t//the residue at the end of str1, but still might form valid s2\\n                int j2_ = seqIndex[indexr[j2]+remainingN%repN];\\n                count += countr[j2_] - countr[j2];\\n                break;\\n            } else {\\n                countr[j2] = count;\\n                indexr[j2] = i;\\n                seqIndex.push_back(j2);\\n            }\\n            \\n            for (int j1=0; j1<s1.size(); j1++) {\\n                if (s1[j1] == s2[j2]) {\\n                    j2++;\\n                    if (j2 == s2.size()) {\\n                        j2 = 0;\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count/n2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010094,
                "title": "javascript-solution-just-code-optimization",
                "content": "```\\nconst getMaxRepetitions = (s1, n1, s2, n2) => {\\n    let c = t = i = j = 0;\\n    while (c < n1) {\\n        if (s1[i] === s2[j] && ++j === s2.length) {\\n            j = 0;\\n            t++;\\n        }\\n        if (++i === s1.length) {\\n            i = 0;\\n            c++;\\n        }\\n    }\\n    return t / n2 >> 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst getMaxRepetitions = (s1, n1, s2, n2) => {\\n    let c = t = i = j = 0;\\n    while (c < n1) {\\n        if (s1[i] === s2[j] && ++j === s2.length) {\\n            j = 0;\\n            t++;\\n        }\\n        if (++i === s1.length) {\\n            i = 0;\\n            c++;\\n        }\\n    }\\n    return t / n2 >> 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1932676,
                "title": "count-the-repetitions-solutions-java",
                "content": "class Record {\\n  public int count;\\n  public int nextIndex;\\n  public Record(int count, int nextIndex) {\\n    this.count = count;\\n    this.nextIndex = nextIndex;\\n  }\\n};\\n\\nclass Solution {\\n  public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n    List<Record> records = new ArrayList<>(); // [count(s1 matches s2[i:]), next index of s2[i:]]\\n\\n    for (int i = 0; i < s2.length(); ++i) {\\n      int count = 0;\\n      int nextIndex = i;\\n      for (int j = 0; j < s1.length(); ++j)\\n        if (s2.charAt(nextIndex) == s1.charAt(j))\\n          if (++nextIndex == s2.length()) { // have a match\\n            ++count;\\n            nextIndex = 0;\\n          }\\n      records.add(new Record(count, nextIndex));\\n    }\\n\\n    int matches = 0; // S1 matches s2\\n    int index = 0;\\n\\n    while (n1-- > 0) {\\n      matches += records.get(index).count;\\n      index = records.get(index).nextIndex;\\n    }\\n\\n    return matches / n2; // S1 matches S2\\n  }\\n}\\n",
                "solutionTags": [
                    "String",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n  public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n    List<Record> records = new ArrayList<>(); // [count(s1 matches s2[i:]), next index of s2[i:]]\\n\\n    for (int i = 0; i < s2.length(); ++i) {\\n      int count = 0;\\n      int nextIndex = i;\\n      for (int j = 0; j < s1.length(); ++j)\\n        if (s2.charAt(nextIndex) == s1.charAt(j))\\n          if (++nextIndex == s2.length()) { // have a match\\n            ++count;\\n            nextIndex = 0;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1871739,
                "title": "c-o-s1-s2-read-if-you-find-cycles-too-hard-to-understand-implement",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        \\n        const int m1 = s1.length();\\n        const int m2 = s2.length();\\n        \\n        int pos1 = 0 , pos2 = 0;\\n        int k1 = 0, k2 = 0; \\n        \\n        vector<pair<int, int>> history(m2, {-1,-1});  // <pos2, <k1,k2>>\\n        \\n        history[0] = {0,0};\\n            \\n        while(k1 < n1)\\n        {\\n            if(s1[pos1++] == s2[pos2])\\n            {\\n                if(++pos2 == m2)\\n                {\\n                    ++k2, pos2 = 0;\\n                }\\n            }\\n            \\n            if(pos1 == m1) \\n            {\\n                ++k1, pos1 = 0;\\n               \\n                if(history[pos2].first == -1)\\n                {\\n                    history[pos2] = {k1, k2};\\n                }\\n                else\\n                {\\n                    auto [prev_k1, prev_k2] = history[pos2];\\n                    \\n                    if(prev_k2 == k2)   return 0;   // cannot obtain s2 from [s1,n1]\\n                    \\n                    // fast forward k1 and k2 based on the found cycle\\n                    if(k1 < n1)\\n                    {\\n                        // calc the largest q, s.t. k1 + q * (k1 - prev_k1) <= n1\\n                        int q = (n1 - k1) / (k1 - prev_k1);\\n                        k1 += q * (k1 - prev_k1);\\n                        k2 += q * (k2 - prev_k2);\\n                    }\\n                }\\n            }\\n        }\\n                   \\n        return k2 / n2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        \\n        const int m1 = s1.length();\\n        const int m2 = s2.length();\\n        \\n        int pos1 = 0 , pos2 = 0;\\n        int k1 = 0, k2 = 0; \\n        \\n        vector<pair<int, int>> history(m2, {-1,-1});  // <pos2, <k1,k2>>\\n        \\n        history[0] = {0,0};\\n            \\n        while(k1 < n1)\\n        {\\n            if(s1[pos1++] == s2[pos2])\\n            {\\n                if(++pos2 == m2)\\n                {\\n                    ++k2, pos2 = 0;\\n                }\\n            }\\n            \\n            if(pos1 == m1) \\n            {\\n                ++k1, pos1 = 0;\\n               \\n                if(history[pos2].first == -1)\\n                {\\n                    history[pos2] = {k1, k2};\\n                }\\n                else\\n                {\\n                    auto [prev_k1, prev_k2] = history[pos2];\\n                    \\n                    if(prev_k2 == k2)   return 0;   // cannot obtain s2 from [s1,n1]\\n                    \\n                    // fast forward k1 and k2 based on the found cycle\\n                    if(k1 < n1)\\n                    {\\n                        // calc the largest q, s.t. k1 + q * (k1 - prev_k1) <= n1\\n                        int q = (n1 - k1) / (k1 - prev_k1);\\n                        k1 += q * (k1 - prev_k1);\\n                        k2 += q * (k2 - prev_k2);\\n                    }\\n                }\\n            }\\n        }\\n                   \\n        return k2 / n2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733987,
                "title": "c-passes-all-test-cases",
                "content": "I know it is not the best or fastest but here is how I solved this one:\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n    int s1size = s1.size(); int s2size = s2.size();\\n    vector<int> dpm (s1size, INT_MAX/2);\\n\\n    // store in dpm[i] how many elements from s1 does it take starting from ith element to make just one s2\\n    for(int i = 0; i < s1.size(); i++ )\\n    {\\n        int p1 = i, p2{0};\\n        bool found = false;\\n        while(p1 < s1.size() * n1 && !found)\\n        {\\n            if(s2[p2] == s1[p1 % s1size])\\n                {\\n                p2++;\\n                if(p2 == s2size)\\n                    found = true;\\n                }\\n            p1++;\\n        }\\n    if(found) dpm[i] = p1 - i;\\n    }\\n       \\n    //using dpm[i] calculate and store in number how many n2xs2 can be made before a loop is made to go back to 0th element of s1\\n    //break when a loop (back to 0th element is achieved)\\n    int p1{0}, s2count{0}, number{0};\\n    bool found = false;\\n    while(p1 <= s1size * n1)\\n        {\\n            if(s2count == n2)\\n            {\\n                s2count = 0;\\n                number++;\\n            }\\n            p1 = p1 + dpm[p1 % s1size];\\n            s2count ++;\\n\\n            if(p1 % s1size == 0)\\n           {\\n                found = true;\\n                break;\\n            }\\n        }\\n    \\n    //if no loop was found it is straightforward, just return the value of number\\n    if(!found) return number;\\n    \\n    int remaining = n1 * s1size % p1;\\n    int rem{0}, pp{0}, s2countrem{0};\\n    \\n    //if there is loop it is straightforward to calculate the total number occuring in the number of loops\\n    //but we also need to find out how many n2xs2 can be made outside of one incomplete loop\\n    while(pp <= remaining)\\n        {\\n            if(s2countrem == n2)\\n            {\\n                s2countrem = 0;\\n                rem++;\\n            }\\n            pp = pp + dpm[pp % s1size];\\n            s2countrem ++;\\n\\n        }\\n    \\n    long int temp = p1;\\n    temp = temp * n2 / s2count;\\n    \\n    int value =  n1 * s1size / p1 * number + n1 * s1size  / temp + rem;\\n    return value;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n    int s1size = s1.size(); int s2size = s2.size();\\n    vector<int> dpm (s1size, INT_MAX/2);\\n\\n    // store in dpm[i] how many elements from s1 does it take starting from ith element to make just one s2\\n    for(int i = 0; i < s1.size(); i++ )\\n    {\\n        int p1 = i, p2{0};\\n        bool found = false;\\n        while(p1 < s1.size() * n1 && !found)\\n        {\\n            if(s2[p2] == s1[p1 % s1size])\\n                {\\n                p2++;\\n                if(p2 == s2size)\\n                    found = true;\\n                }\\n            p1++;\\n        }\\n    if(found) dpm[i] = p1 - i;\\n    }\\n       \\n    //using dpm[i] calculate and store in number how many n2xs2 can be made before a loop is made to go back to 0th element of s1\\n    //break when a loop (back to 0th element is achieved)\\n    int p1{0}, s2count{0}, number{0};\\n    bool found = false;\\n    while(p1 <= s1size * n1)\\n        {\\n            if(s2count == n2)\\n            {\\n                s2count = 0;\\n                number++;\\n            }\\n            p1 = p1 + dpm[p1 % s1size];\\n            s2count ++;\\n\\n            if(p1 % s1size == 0)\\n           {\\n                found = true;\\n                break;\\n            }\\n        }\\n    \\n    //if no loop was found it is straightforward, just return the value of number\\n    if(!found) return number;\\n    \\n    int remaining = n1 * s1size % p1;\\n    int rem{0}, pp{0}, s2countrem{0};\\n    \\n    //if there is loop it is straightforward to calculate the total number occuring in the number of loops\\n    //but we also need to find out how many n2xs2 can be made outside of one incomplete loop\\n    while(pp <= remaining)\\n        {\\n            if(s2countrem == n2)\\n            {\\n                s2countrem = 0;\\n                rem++;\\n            }\\n            pp = pp + dpm[pp % s1size];\\n            s2countrem ++;\\n\\n        }\\n    \\n    long int temp = p1;\\n    temp = temp * n2 / s2count;\\n    \\n    int value =  n1 * s1size / p1 * number + n1 * s1size  / temp + rem;\\n    return value;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576273,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions-for-count-the-repetitions",
                "content": "class Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;//case when n=0\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            for(int k=0;k<i;k++){\\n                if(posRest==rest[k]){b=k;last=i;break;}\\n            }\\n            rapport[i]=rap;rest[i]=posRest;\\n            if(b>=0)break;\\n        }\\n        int interval=last-b;\\n        if(b>=n1)return rapport[n1]/n2;\\n        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;\\n//corrected thanks to @zhiqing_xiao and @iaming \\n    }\\n};`class Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;//case when n=0\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            for(int k=0;k<i;k++){\\n                if(posRest==rest[k]){b=k;last=i;break;}\\n            }\\n            rapport[i]=rap;rest[i]=posRest;\\n            if(b>=0)break;\\n        }\\n        int interval=last-b;\\n        if(b>=n1)return rapport[n1]/n2;\\n        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;\\n//corrected thanks to @zhiqing_xiao and @iaming \\n    }\\n};`",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;//case when n=0\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1526914,
                "title": "javascript-brute-force-4228ms",
                "content": "```\\nconst getMaxRepetitions = (s1, n1, s2, n2) => {\\n    let cnt1 = cnt2 = i = j = 0;\\n    while (cnt1 < n1) {\\n        if (s1[i] == s2[j]) {\\n            j++;\\n            if (j == s2.length) {\\n                j = 0;\\n                cnt2++;\\n            }\\n        }\\n        i++;\\n        if (i == s1.length) {\\n            i = 0;\\n            cnt1++;\\n        }\\n    }\\n    return cnt2 / n2 >> 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst getMaxRepetitions = (s1, n1, s2, n2) => {\\n    let cnt1 = cnt2 = i = j = 0;\\n    while (cnt1 < n1) {\\n        if (s1[i] == s2[j]) {\\n            j++;\\n            if (j == s2.length) {\\n                j = 0;\\n                cnt2++;\\n            }\\n        }\\n        i++;\\n        if (i == s1.length) {\\n            i = 0;\\n            cnt1++;\\n        }\\n    }\\n    return cnt2 / n2 >> 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1504112,
                "title": "2ms-c-c-solution-by-finding-period",
                "content": "```\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int cnt=0;\\n        int mark_s1=-1, mark_n1=-1, mark_cnt=-1, bLastPeriod=false;\\n        int i, j, k=0;\\n        for(i=0; i<n1; i++)\\n        {\\n            for(j=0; j<s1.length(); j++)\\n            {\\n                if(s1[j]!=s2[k]) continue;\\n                if(++k>=s2.length())\\n                {\\n                    k=0;\\n                    cnt++;\\n                    if(mark_s1==-1)\\n                    {\\n                        mark_s1=j;\\n                        mark_n1=i;\\n                        mark_cnt=cnt;\\n                    }\\n                    else\\n                    {\\n                        if(!bLastPeriod&& mark_s1==j) // found period\\n                        {\\n                            //i-mark_n1 is period\\n                            int more_periods=(n1-1-i)/(i-mark_n1);\\n                            i+=(more_periods*(i-mark_n1));\\n                            cnt+=(more_periods*(cnt-mark_cnt));\\n                            bLastPeriod=true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return cnt/n2; // cnt is repetitions of s2. needs to divide by n2\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int cnt=0;\\n        int mark_s1=-1, mark_n1=-1, mark_cnt=-1, bLastPeriod=false;\\n        int i, j, k=0;\\n        for(i=0; i<n1; i++)\\n        {\\n            for(j=0; j<s1.length(); j++)\\n            {\\n                if(s1[j]!=s2[k]) continue;\\n                if(++k>=s2.length())\\n                {\\n                    k=0;\\n                    cnt++;\\n                    if(mark_s1==-1)\\n                    {\\n                        mark_s1=j;\\n                        mark_n1=i;\\n                        mark_cnt=cnt;\\n                    }\\n                    else\\n                    {\\n                        if(!bLastPeriod&& mark_s1==j) // found period\\n                        {\\n                            //i-mark_n1 is period\\n                            int more_periods=(n1-1-i)/(i-mark_n1);\\n                            i+=(more_periods*(i-mark_n1));\\n                            cnt+=(more_periods*(cnt-mark_cnt));\\n                            bLastPeriod=true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return cnt/n2; // cnt is repetitions of s2. needs to divide by n2\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1449131,
                "title": "c-dynamic-programming-o-s1-size-s2-size-32-time",
                "content": "Let\\'s tackle the following problem:\\nSize of longest subsequence of \\n`s1*n = s1 s1 ... s1` (`n` times) which is a equal to a prefix of\\n`s2[j:] s2 ......` (infinite times) where `s2[j:]` is in python notation\\n\\nNow let `dp[i][j]` be the solution for `n=2^i` and `j`\\n\\nFinding `dp[0][j]` can be done by brute force.\\n```\\nfor(int i=0;i<s2.size();i++){\\n\\tdp[0][i] = 0;\\n\\tfor(int j=0;j<s1.size();j++){\\n\\t\\tif(s1[j]==s2[(i+dp[0][i])%s2.size()]) dp[0][i]++;\\n\\t}\\n}\\n```\\n\\nAnd we have recurrence relation: `dp[i+1][j] = m + dp[i][(j+m)%N]` where `m = dp[i][j]` and `N = size of s2`.\\n\\nReason: \\n\\nLet `n = 2^i` then for `dp[i+1][j]` we need to find size of subsequence for  `s1*n + s1*n` matching with `s2[j:] s2 s2 ... `. \\n\\nThen `s1*n` has `m` matches which introduces an additional offset of `m%N` , hence the relation `dp[i+1][j] = m + dp[i][(j+m)%N]`\\n\\nSo we can find the dp in `O(32)` time. And the result can be calculated in the following way\\n```\\nfor(int i=0;i<32;i++){\\n\\tif(n1%2 == 1) {\\n\\t\\tint m = dp[i][offset];\\n\\t\\tk += m;\\n\\t\\toffset = (offset+m)%s2.size();\\n\\t}\\n\\tn1 /= 2;\\n}\\n```\\n\\nFull code:\\n```\\nint getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n\\t#define int long long\\n\\tconst int N = 32;\\n\\tvector<vector<int>> dp(N, vector<int>(s2.size()));\\n\\n\\tfor(int i=0;i<s2.size();i++){\\n\\t\\tdp[0][i] = 0;\\n\\t\\tfor(int j=0;j<s1.size();j++){\\n\\t\\t\\tif(s1[j]==s2[(i+dp[0][i])%s2.size()]) dp[0][i]++;\\n\\t\\t}\\n\\t}\\n\\n\\tfor(int i=0;i<s2.size();i++){\\n\\t\\tcout << dp[0][i] << \" \";\\n\\t}\\n\\n\\tfor(int i=1;i<N;i++){\\n\\t\\tfor(int j=0;j<s2.size();j++){\\n\\t\\t\\tdp[i][j] = dp[i-1][j] + dp[i-1][(j+dp[i-1][j])%s2.size()];\\n\\t\\t}\\n\\t}\\n\\n\\tint k = 0;\\n\\tint offset = 0;\\n\\tfor(int i=0;i<N;i++){\\n\\t\\tif(n1%2 == 1) {\\n\\t\\t\\tint m = dp[i][offset];\\n\\t\\t\\tk += m;\\n\\t\\t\\toffset = (offset+m)%s2.size();\\n\\t\\t}\\n\\t\\tn1 /= 2;\\n\\t}\\n\\t#undef int\\n\\treturn k/(n2*s2.size());\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfor(int i=0;i<s2.size();i++){\\n\\tdp[0][i] = 0;\\n\\tfor(int j=0;j<s1.size();j++){\\n\\t\\tif(s1[j]==s2[(i+dp[0][i])%s2.size()]) dp[0][i]++;\\n\\t}\\n}\\n```\n```\\nfor(int i=0;i<32;i++){\\n\\tif(n1%2 == 1) {\\n\\t\\tint m = dp[i][offset];\\n\\t\\tk += m;\\n\\t\\toffset = (offset+m)%s2.size();\\n\\t}\\n\\tn1 /= 2;\\n}\\n```\n```\\nint getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n\\t#define int long long\\n\\tconst int N = 32;\\n\\tvector<vector<int>> dp(N, vector<int>(s2.size()));\\n\\n\\tfor(int i=0;i<s2.size();i++){\\n\\t\\tdp[0][i] = 0;\\n\\t\\tfor(int j=0;j<s1.size();j++){\\n\\t\\t\\tif(s1[j]==s2[(i+dp[0][i])%s2.size()]) dp[0][i]++;\\n\\t\\t}\\n\\t}\\n\\n\\tfor(int i=0;i<s2.size();i++){\\n\\t\\tcout << dp[0][i] << \" \";\\n\\t}\\n\\n\\tfor(int i=1;i<N;i++){\\n\\t\\tfor(int j=0;j<s2.size();j++){\\n\\t\\t\\tdp[i][j] = dp[i-1][j] + dp[i-1][(j+dp[i-1][j])%s2.size()];\\n\\t\\t}\\n\\t}\\n\\n\\tint k = 0;\\n\\tint offset = 0;\\n\\tfor(int i=0;i<N;i++){\\n\\t\\tif(n1%2 == 1) {\\n\\t\\t\\tint m = dp[i][offset];\\n\\t\\t\\tk += m;\\n\\t\\t\\toffset = (offset+m)%s2.size();\\n\\t\\t}\\n\\t\\tn1 /= 2;\\n\\t}\\n\\t#undef int\\n\\treturn k/(n2*s2.size());\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1437481,
                "title": "efficient-linear-extrapolation-solution-in-c-with-explanations",
                "content": "```\\nclass Solution {\\npublic:\\n    static int getMaxRepetitions(string const& s1, int n1, string const& s2, int n2) {\\n        int const s1_len = s1.size();\\n        int const s2_len = s2.size();\\n        int s2_reps = 0;\\n        int s2_idx = 0;\\n        // \"match\" will store (s1_idx, (s1_reps, s2_reps)) whenever s1[s1_idx] matches s2[s2_len - 1]\\n        unordered_map<int, pair<int, int>> match;\\n        match.reserve(s1_len);\\n        for (int s1_reps = 0; s1_reps < n1; ++s1_reps) {\\n            bool has_match = false;\\n\\t\\t\\t// iterate over a fresh copy of s1\\n            for (int s1_idx = 0; s1_idx < s1_len; ++s1_idx) {\\n                if (s1[s1_idx] == s2[s2_idx]) {\\n                    has_match = true;\\n                    if (++s2_idx == s2_len) {\\n                        ++s2_reps;\\n                        s2_idx = 0;\\n                        auto iter = match.find(s1_idx);\\n                        if (iter != match.end()) {\\n                            auto const prev_s1_reps = iter->second.first;\\n                            auto const prev_s2_reps = iter->second.second;\\n                            // preform a linear extrapolation using the current (s1_reps, s2_reps)\\n                            // and the previous (s1_reps, s2_reps) to skip over a large number of\\n\\t\\t\\t\\t\\t\\t\\t// intermediate iterations\\n                            auto const n_iters = (n1 - 1 - s1_reps) / (s1_reps - prev_s1_reps);\\n                            s1_reps += n_iters * (s1_reps - prev_s1_reps);\\n                            s2_reps += n_iters * (s2_reps - prev_s2_reps);\\n                        } else {\\n                            match[s1_idx] = make_pair(s1_reps, s2_reps);\\n                        }\\n                    }\\n                }\\n            }\\n            if (!has_match)\\n                // If we did not make progress at all with the current copy of s1, then\\n\\t\\t\\t\\t// the char at s2[s2_idx] must be missing in s1. Therefore a full match is\\n\\t\\t\\t\\t// impossible.\\n                return 0;\\n        }\\n        return s2_reps / n2;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static int getMaxRepetitions(string const& s1, int n1, string const& s2, int n2) {\\n        int const s1_len = s1.size();\\n        int const s2_len = s2.size();\\n        int s2_reps = 0;\\n        int s2_idx = 0;\\n        // \"match\" will store (s1_idx, (s1_reps, s2_reps)) whenever s1[s1_idx] matches s2[s2_len - 1]\\n        unordered_map<int, pair<int, int>> match;\\n        match.reserve(s1_len);\\n        for (int s1_reps = 0; s1_reps < n1; ++s1_reps) {\\n            bool has_match = false;\\n\\t\\t\\t// iterate over a fresh copy of s1\\n            for (int s1_idx = 0; s1_idx < s1_len; ++s1_idx) {\\n                if (s1[s1_idx] == s2[s2_idx]) {\\n                    has_match = true;\\n                    if (++s2_idx == s2_len) {\\n                        ++s2_reps;\\n                        s2_idx = 0;\\n                        auto iter = match.find(s1_idx);\\n                        if (iter != match.end()) {\\n                            auto const prev_s1_reps = iter->second.first;\\n                            auto const prev_s2_reps = iter->second.second;\\n                            // preform a linear extrapolation using the current (s1_reps, s2_reps)\\n                            // and the previous (s1_reps, s2_reps) to skip over a large number of\\n\\t\\t\\t\\t\\t\\t\\t// intermediate iterations\\n                            auto const n_iters = (n1 - 1 - s1_reps) / (s1_reps - prev_s1_reps);\\n                            s1_reps += n_iters * (s1_reps - prev_s1_reps);\\n                            s2_reps += n_iters * (s2_reps - prev_s2_reps);\\n                        } else {\\n                            match[s1_idx] = make_pair(s1_reps, s2_reps);\\n                        }\\n                    }\\n                }\\n            }\\n            if (!has_match)\\n                // If we did not make progress at all with the current copy of s1, then\\n\\t\\t\\t\\t// the char at s2[s2_idx] must be missing in s1. Therefore a full match is\\n\\t\\t\\t\\t// impossible.\\n                return 0;\\n        }\\n        return s2_reps / n2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1236296,
                "title": "python3-solution-that-doesn-t-search-for-loops-bisection-comments-inside",
                "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        l1 = len(s1)\\n        l2 = len(s2)\\n        chars = set(s1)\\n        for c in s2:\\n            if c not in chars:\\n                return 0\\n        # if s2 contains some character not from s1, it\\'s impossible for any positive m\\n        \\n        Jumps = []\\n        def getchar(ofs):\\n            return s1[ofs%l1]\\n        for i in range(l1):\\n            cur = i\\n            for c in s2:\\n                while getchar(cur)!=c:\\n                    cur += 1\\n                cur += 1\\n            Jumps.append(cur-i)\\n        # Now, Jumps[i] contains how many chars do we have to move forward to find s2,\\n        # if we start from offset i.\\n        # We just have to know, how many times can we repeat this until we pass the limit l1*n1.\\n        # Bruteforce approach will time out, we must be more clever. We\\'ll use bisection, because\\n        # I don\\'t want to find loops.\\n        \\n        # jumplen functions calculates, how many chars do we have to move forward to find m copies of s2.\\n        # Now if we know maximum such m, that we don\\'t go pass the limit, we just return m//n2.\\n        # But first, we implement a special case, where m is a power of 2, using memoization.\\n        DP = dict()\\n        def jumplen_pow2(rem, pow2):\\n            assert(rem>=0 and rem<l1)\\n            key = (rem, pow2)\\n            if key in DP:\\n                return DP[key]\\n            if pow2==1:\\n                r = Jumps[rem]\\n            else:\\n                pow2 >>= 1\\n                r = jumplen(rem, pow2)\\n                r += jumplen((rem+r)%l1, pow2)\\n            DP[key] = r\\n            return r\\n        # Now to the general case. We just split m into sum of powers of 2, using binary representation.\\n        def jumplen(rem, m):\\n            if m==0:\\n                return 0\\n            pow2 = 1\\n            jl = 0\\n            while pow2<=m:\\n                if pow2&m:\\n                    l = jumplen_pow2(rem, pow2)\\n                    jl += l\\n                    rem = (rem+l)%l1\\n                pow2 <<= 1\\n            return jl\\n        # And we are ready to do the binary search for answer. First we find the borders.\\n        limit = l1*n1\\n        m = 1\\n        prev = 0\\n        while jumplen_pow2(0,m)<=limit:\\n            prev = m\\n            m <<= 1\\n        l,r = prev,m # the borders\\n        while r-l>1:\\n            m = l+(r-l)//2\\n            if jumplen(0,m)<=limit:\\n                l = m\\n            else:\\n                r = m\\n        return l//n2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        l1 = len(s1)\\n        l2 = len(s2)\\n        chars = set(s1)\\n        for c in s2:\\n            if c not in chars:\\n                return 0\\n        # if s2 contains some character not from s1, it\\'s impossible for any positive m\\n        \\n        Jumps = []\\n        def getchar(ofs):\\n            return s1[ofs%l1]\\n        for i in range(l1):\\n            cur = i\\n            for c in s2:\\n                while getchar(cur)!=c:\\n                    cur += 1\\n                cur += 1\\n            Jumps.append(cur-i)\\n        # Now, Jumps[i] contains how many chars do we have to move forward to find s2,\\n        # if we start from offset i.\\n        # We just have to know, how many times can we repeat this until we pass the limit l1*n1.\\n        # Bruteforce approach will time out, we must be more clever. We\\'ll use bisection, because\\n        # I don\\'t want to find loops.\\n        \\n        # jumplen functions calculates, how many chars do we have to move forward to find m copies of s2.\\n        # Now if we know maximum such m, that we don\\'t go pass the limit, we just return m//n2.\\n        # But first, we implement a special case, where m is a power of 2, using memoization.\\n        DP = dict()\\n        def jumplen_pow2(rem, pow2):\\n            assert(rem>=0 and rem<l1)\\n            key = (rem, pow2)\\n            if key in DP:\\n                return DP[key]\\n            if pow2==1:\\n                r = Jumps[rem]\\n            else:\\n                pow2 >>= 1\\n                r = jumplen(rem, pow2)\\n                r += jumplen((rem+r)%l1, pow2)\\n            DP[key] = r\\n            return r\\n        # Now to the general case. We just split m into sum of powers of 2, using binary representation.\\n        def jumplen(rem, m):\\n            if m==0:\\n                return 0\\n            pow2 = 1\\n            jl = 0\\n            while pow2<=m:\\n                if pow2&m:\\n                    l = jumplen_pow2(rem, pow2)\\n                    jl += l\\n                    rem = (rem+l)%l1\\n                pow2 <<= 1\\n            return jl\\n        # And we are ready to do the binary search for answer. First we find the borders.\\n        limit = l1*n1\\n        m = 1\\n        prev = 0\\n        while jumplen_pow2(0,m)<=limit:\\n            prev = m\\n            m <<= 1\\n        l,r = prev,m # the borders\\n        while r-l>1:\\n            m = l+(r-l)//2\\n            if jumplen(0,m)<=limit:\\n                l = m\\n            else:\\n                r = m\\n        return l//n2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233331,
                "title": "brute-force-solution",
                "content": "java code is:\\n# \\n```\\npublic class Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        char[] array1 = s1.toCharArray(), array2 = s2.toCharArray();\\n        int  count = 0, i = 0, j = 0;\\n        while (n1>0) {\\n            if(array1[i++]==array2[j])j++;\\n            if(j==array2.length){\\n                j=0;\\n                count++;\\n            }\\n            if(i==array1.length){\\n                i=0;\\n                n1--;\\n            }\\n        }\\n        return count / n2;\\n    }\\n}\\n\\n```\\n**Please,Upvote if this is helpful**",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        char[] array1 = s1.toCharArray(), array2 = s2.toCharArray();\\n        int  count = 0, i = 0, j = 0;\\n        while (n1>0) {\\n            if(array1[i++]==array2[j])j++;\\n            if(j==array2.length){\\n                j=0;\\n                count++;\\n            }\\n            if(i==array1.length){\\n                i=0;\\n                n1--;\\n            }\\n        }\\n        return count / n2;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1002643,
                "title": "c-code-with-comments",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int l1 = s1.size();\\n        int l2 = s2.size();\\n        int p1 = 0; // pointer for s1, in range [0, n1*l1]\\n        int p2 = 0; // pointer for s2 in range [0, n2*l2*M]\\n        \\n        int o2p1[101][101]; // p1 value when offset on s1 & s2 is given\\n        int o2p2[101][101]; // p2 value when offset on s1 & s2 is given\\n        \\n        for (int i = 0; i <= 100; i++)\\n            for (int j = 0; j <= 100; j++){\\n                o2p1[i][j] = -1;\\n                o2p2[i][j] = -1;\\n            }\\n        \\n        while (p1 < l1 * n1){\\n            if (s1[p1 % l1] == s2[p2 % l2]){\\n                int off1 = p1 % l1; // p1\\'s offset across s1\\n                int off2 = p2 % l2; // p2\\'s offset across s2\\n                int prev1 = p1; // store p1 value before update\\n                int prev2 = p2; // store p2 value before update\\n                if (o2p1[off1][off2] != -1 && o2p2[off1][off2] != -1){ // repetition found\\n                    int times = (l1 * n1 - p1) / (p1 - o2p1[off1][off2]); // possible remaining repititions\\n                    p1 += times * (p1 - o2p1[off1][off2]); // update p1 by repititions\\n                    p2 += times * (p2 - o2p2[off1][off2]); // update p2 by repititions\\n                }\\n                else { // no repetition found\\n                    o2p1[off1][off2] = p1; // log down p1\\n                    o2p2[off1][off2] = p2; // log down p2\\n                }\\n                if (prev1 == p1 && prev2 == p2){ // no pointer update\\n                    p1 ++;\\n                    p2 ++;\\n                }\\n            }\\n            else\\n                p1 ++;\\n        }\\n        return (p2 / l2) / n2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int l1 = s1.size();\\n        int l2 = s2.size();\\n        int p1 = 0; // pointer for s1, in range [0, n1*l1]\\n        int p2 = 0; // pointer for s2 in range [0, n2*l2*M]\\n        \\n        int o2p1[101][101]; // p1 value when offset on s1 & s2 is given\\n        int o2p2[101][101]; // p2 value when offset on s1 & s2 is given\\n        \\n        for (int i = 0; i <= 100; i++)\\n            for (int j = 0; j <= 100; j++){\\n                o2p1[i][j] = -1;\\n                o2p2[i][j] = -1;\\n            }\\n        \\n        while (p1 < l1 * n1){\\n            if (s1[p1 % l1] == s2[p2 % l2]){\\n                int off1 = p1 % l1; // p1\\'s offset across s1\\n                int off2 = p2 % l2; // p2\\'s offset across s2\\n                int prev1 = p1; // store p1 value before update\\n                int prev2 = p2; // store p2 value before update\\n                if (o2p1[off1][off2] != -1 && o2p2[off1][off2] != -1){ // repetition found\\n                    int times = (l1 * n1 - p1) / (p1 - o2p1[off1][off2]); // possible remaining repititions\\n                    p1 += times * (p1 - o2p1[off1][off2]); // update p1 by repititions\\n                    p2 += times * (p2 - o2p2[off1][off2]); // update p2 by repititions\\n                }\\n                else { // no repetition found\\n                    o2p1[off1][off2] = p1; // log down p1\\n                    o2p2[off1][off2] = p2; // log down p2\\n                }\\n                if (prev1 == p1 && prev2 == p2){ // no pointer update\\n                    p1 ++;\\n                    p2 ++;\\n                }\\n            }\\n            else\\n                p1 ++;\\n        }\\n        return (p2 / l2) / n2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 930408,
                "title": "c-0ms-100-dp-loop-detection",
                "content": "1 Using DP array to store {offset of s2, length matched by s2} for each s2 start offset\\n2 Once we detect loop, accelaate only once, but figuring out loop length and advance by times of loop length as far as possible. \\n3 After accelarate, just rely on dp array to advance.\\n\\n```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int m1, string s2, int m2) {\\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        vector<pair<int, int>> dp(n2, {-1,-1});\\n        int base = 0;\\n        int cnt = 0;\\n        int step = 1;\\n        bool acc = false;\\n        for (int c = 0; c < m1; c += step)\\n        {\\n            if (dp[base].first != -1)\\n            {\\n                // detect loop length\\n                if (!acc)\\n                {\\n                    acc = true;\\n                    int curcnt = dp[base].second;\\n                    int curbase = dp[base].first;\\n                    int l = 1;\\n                    \\n                    while (curbase != base)\\n                    {\\n                        l++;\\n                        curcnt += dp[curbase].second;\\n                        curbase = dp[curbase].first;\\n                    }\\n\\n                    // accelerate here\\n                    if (m1 >= c)\\n                    {\\n                        int r = (m1 - c) / l;\\n                        cnt += r * curcnt;\\n                        c += r * l;  \\n                        if (c >= m1)\\n                        {\\n                            break;\\n                        }\\n                    }\\n                }            \\n                \\n                cnt += dp[base].second;\\n                base = dp[base].first;\\n                continue;\\n            }\\n            int j = base;\\n            int cur = 0;\\n            for (int i = 0; i < n1; i++)\\n            {\\n                if (s1[i] == s2[j])\\n                {\\n                    j = (j + 1) % n2;\\n                    if (j == 0)\\n                    {\\n                        cur++;\\n                    }\\n                }\\n            }\\n            dp[base].first = j;\\n            dp[base].second = cur;\\n            base = j;\\n            cnt += cur;\\n        }\\n        return cnt / m2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int m1, string s2, int m2) {\\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        vector<pair<int, int>> dp(n2, {-1,-1});\\n        int base = 0;\\n        int cnt = 0;\\n        int step = 1;\\n        bool acc = false;\\n        for (int c = 0; c < m1; c += step)\\n        {\\n            if (dp[base].first != -1)\\n            {\\n                // detect loop length\\n                if (!acc)\\n                {\\n                    acc = true;\\n                    int curcnt = dp[base].second;\\n                    int curbase = dp[base].first;\\n                    int l = 1;\\n                    \\n                    while (curbase != base)\\n                    {\\n                        l++;\\n                        curcnt += dp[curbase].second;\\n                        curbase = dp[curbase].first;\\n                    }\\n\\n                    // accelerate here\\n                    if (m1 >= c)\\n                    {\\n                        int r = (m1 - c) / l;\\n                        cnt += r * curcnt;\\n                        c += r * l;  \\n                        if (c >= m1)\\n                        {\\n                            break;\\n                        }\\n                    }\\n                }            \\n                \\n                cnt += dp[base].second;\\n                base = dp[base].first;\\n                continue;\\n            }\\n            int j = base;\\n            int cur = 0;\\n            for (int i = 0; i < n1; i++)\\n            {\\n                if (s1[i] == s2[j])\\n                {\\n                    j = (j + 1) % n2;\\n                    if (j == 0)\\n                    {\\n                        cur++;\\n                    }\\n                }\\n            }\\n            dp[base].first = j;\\n            dp[base].second = cur;\\n            base = j;\\n            cnt += cur;\\n        }\\n        return cnt / m2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842882,
                "title": "go-brute",
                "content": "```\\nfunc getMaxRepetitions(s1 string, n1 int, s2 string, n2 int) int {\\n    i1, i2 := 0, 0\\n    p1, p2 := 0, 0\\n    for i1 < n1 {\\n        if s1[p1] == s2[p2]  {\\n            p1++\\n            p2++\\n        } else {\\n            p1++\\n        }\\n        if p1 >= len(s1) {\\n            i1++\\n            p1 = 0\\n        }\\n        if p2 >= len(s2) {\\n            i2++\\n            p2 = 0\\n        }\\n    }\\n    return i2 / n2\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc getMaxRepetitions(s1 string, n1 int, s2 string, n2 int) int {\\n    i1, i2 := 0, 0\\n    p1, p2 := 0, 0\\n    for i1 < n1 {\\n        if s1[p1] == s2[p2]  {\\n            p1++\\n            p2++\\n        } else {\\n            p1++\\n        }\\n        if p1 >= len(s1) {\\n            i1++\\n            p1 = 0\\n        }\\n        if p2 >= len(s2) {\\n            i2++\\n            p2 = 0\\n        }\\n    }\\n    return i2 / n2\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 817198,
                "title": "java-o-n-3-with-memorization",
                "content": "```\\nclass Solution {\\n    int dp[][];\\n    String s1;String s2;\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        dp=new int[s1.length()][2];\\n        int res=0;\\n        this.s1=s1;this.s2=s2;\\n        for(int i=0;i<s1.length();i++){\\n           record(i);\\n        }\\n        \\n        long total=s1.length()*n1;\\n        int cnt=0;\\n        while(cnt<total){\\n            int start=cnt%s1.length();\\n            int add=(dp[start][0]-1)*s1.length()+dp[start][1]+(s1.length()-start);\\n            if(cnt+add>total)break;\\n            res++;\\n            cnt+=add;\\n        }\\n        \\n        return res/n2;\\n    }\\n    \\n    public void record(int start){\\n        int i=0;int j=start;\\n        int cnt=0;boolean flag=true;\\n        while(i<s2.length()){\\n            if(cnt>s2.length()){\\n                flag=false;\\n                break;\\n            }\\n            if(s1.charAt(j)==s2.charAt(i))i++;\\n            j++;\\n            if(j==s1.length()){\\n                j=0;\\n                cnt++;\\n            }\\n        }\\n        if(flag){\\n            dp[start][0]=cnt;\\n        }else{\\n            dp[start][0]=1000000;\\n        }\\n        dp[start][1]=j;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dp[][];\\n    String s1;String s2;\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        dp=new int[s1.length()][2];\\n        int res=0;\\n        this.s1=s1;this.s2=s2;\\n        for(int i=0;i<s1.length();i++){\\n           record(i);\\n        }\\n        \\n        long total=s1.length()*n1;\\n        int cnt=0;\\n        while(cnt<total){\\n            int start=cnt%s1.length();\\n            int add=(dp[start][0]-1)*s1.length()+dp[start][1]+(s1.length()-start);\\n            if(cnt+add>total)break;\\n            res++;\\n            cnt+=add;\\n        }\\n        \\n        return res/n2;\\n    }\\n    \\n    public void record(int start){\\n        int i=0;int j=start;\\n        int cnt=0;boolean flag=true;\\n        while(i<s2.length()){\\n            if(cnt>s2.length()){\\n                flag=false;\\n                break;\\n            }\\n            if(s1.charAt(j)==s2.charAt(i))i++;\\n            j++;\\n            if(j==s1.length()){\\n                j=0;\\n                cnt++;\\n            }\\n        }\\n        if(flag){\\n            dp[start][0]=cnt;\\n        }else{\\n            dp[start][0]=1000000;\\n        }\\n        dp[start][1]=j;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765447,
                "title": "c-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        if(s1.empty()) return 0;\\n\\n        std::vector<int> ws(s1.size(), 0);\\n\\n        int count = 0;\\n        int its = 0;\\n        int i = 0;\\n        int j = 0;\\n        int f = 0;\\n\\n        int curpos = 0;\\n        int lcount = 0;\\n\\n        while(its < n1){\\n            if(i == s1.size()){\\n                i = 0;\\n                ++its;\\n                continue;\\n            }\\n\\n            ++lcount;\\n\\n            if(s1[i] == s2[j]){\\n                \\n                if(j == 0){\\n                    curpos = i;\\n                   \\n                    if(ws[curpos]!=0){\\n                        int p = curpos;\\n                        std::stack<int> hops;\\n\\n                        int pos = curpos + its*s1.size();\\n                        int nxt = pos;\\n\\n                        do{\\n                            nxt = ws[p] + nxt;\\n                            hops.push(nxt - pos);\\n                            p = (p + ws[p])%s1.size();\\n                            while(ws[p]==0){\\n                                ++p;\\n                                ++nxt;\\n                                if(p == s1.size()){\\n                                    p = 0;\\n                                }\\n                            }\\n                        }while(p!=curpos);\\n\\n                        hops.push(nxt-pos);\\n\\n\\n                        if(!hops.empty()){\\n                            int lits = (n1*s1.size() - pos)/hops.top();\\n                            if(lits > 0){\\n                                count = count + (hops.size()-1)*lits;\\n                                pos = pos + hops.top()*lits;\\n                            }\\n                        }\\n                     \\n                        while((!hops.empty())&& (pos < n1*s1.size())){\\n                            if(pos + hops.top() < n1*s1.size()){\\n                                count += hops.size();\\n                                pos = pos + hops.top();\\n                            }\\n                            else{\\n                                hops.pop();\\n                            }\\n                        }\\n\\n                        return count/n2;\\n                    }             \\n\\n                }\\n                \\n                ++i;\\n                ++j;\\n\\n                if(j == s2.size()){\\n                    ++count;\\n                    j = 0;\\n                    ws[curpos] = lcount;\\n                    lcount = 0;\\n                }\\n                f = 0;\\n            }\\n            else{\\n                ++i;\\n                ++f;\\n\\n                if(j == 0){\\n                    lcount = 0;\\n                }\\n\\n                if(f == s1.size()){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return count/n2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        if(s1.empty()) return 0;\\n\\n        std::vector<int> ws(s1.size(), 0);\\n\\n        int count = 0;\\n        int its = 0;\\n        int i = 0;\\n        int j = 0;\\n        int f = 0;\\n\\n        int curpos = 0;\\n        int lcount = 0;\\n\\n        while(its < n1){\\n            if(i == s1.size()){\\n                i = 0;\\n                ++its;\\n                continue;\\n            }\\n\\n            ++lcount;\\n\\n            if(s1[i] == s2[j]){\\n                \\n                if(j == 0){\\n                    curpos = i;\\n                   \\n                    if(ws[curpos]!=0){\\n                        int p = curpos;\\n                        std::stack<int> hops;\\n\\n                        int pos = curpos + its*s1.size();\\n                        int nxt = pos;\\n\\n                        do{\\n                            nxt = ws[p] + nxt;\\n                            hops.push(nxt - pos);\\n                            p = (p + ws[p])%s1.size();\\n                            while(ws[p]==0){\\n                                ++p;\\n                                ++nxt;\\n                                if(p == s1.size()){\\n                                    p = 0;\\n                                }\\n                            }\\n                        }while(p!=curpos);\\n\\n                        hops.push(nxt-pos);\\n\\n\\n                        if(!hops.empty()){\\n                            int lits = (n1*s1.size() - pos)/hops.top();\\n                            if(lits > 0){\\n                                count = count + (hops.size()-1)*lits;\\n                                pos = pos + hops.top()*lits;\\n                            }\\n                        }\\n                     \\n                        while((!hops.empty())&& (pos < n1*s1.size())){\\n                            if(pos + hops.top() < n1*s1.size()){\\n                                count += hops.size();\\n                                pos = pos + hops.top();\\n                            }\\n                            else{\\n                                hops.pop();\\n                            }\\n                        }\\n\\n                        return count/n2;\\n                    }             \\n\\n                }\\n                \\n                ++i;\\n                ++j;\\n\\n                if(j == s2.size()){\\n                    ++count;\\n                    j = 0;\\n                    ws[curpos] = lcount;\\n                    lcount = 0;\\n                }\\n                f = 0;\\n            }\\n            else{\\n                ++i;\\n                ++f;\\n\\n                if(j == 0){\\n                    lcount = 0;\\n                }\\n\\n                if(f == s1.size()){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return count/n2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720023,
                "title": "java-3-ms-solution-o-l-2",
                "content": "Firstly we calculate the **counts** array which is number of s1 required to contain 1,2,3,4,... s2s.  For each character in s2, we greedily identify the next matching character in s1 in circular fashion. We keep track of the offset of s2[0] in s1 and remember the firs time an offset is used the second time and stop when an offset is used the third time. This way we obtain sufficient data to know that the initial [s1,b] contains [s2,idx], then every [s1,q] contains [s2, p]. The complexity is O(L^2) where L is the length of s1 and s2. The result counts array is O(L) length.\\n\\nThe we use binary search in **getNumberOfS2n2** to identify number of [s2,n2] that fit in [s1,n1]. The function **getNumS1ForS2k** calculates number of s1 required to hold [s2,k].\\n\\n```\\n  public static int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n    if (n1 == 0 || n2 == 0) {\\n      return 0;\\n    }\\n    // If s2 contain any character not appear in s1, return 0.\\n    for (char c : s2.toCharArray()) {\\n      if (s1.indexOf(c) < 0) {\\n        return 0;\\n      }\\n    }\\n\\n    List<Integer> counts = calculateCounts(s1, s2);\\n    return getNumberOfS2n2(n1, n2, counts);\\n  }\\n\\n  // Calculate counts array in which counts[i] is the number of s1 required to contain [s2,i].\\n  // The special counts[0] hold the index when first observation of repeat offset.\\n  // We stop when observe the start offset the third time. For examples:\\n  //   1. cba abc => 1,3,5\\n  //   2. acb ab => 1,1,2\\n  //   3. aaa aa => 3,1,2,2,3,4,4\\n  //   4. baba baab => 2,2,3,5,6\\n  //   5. bacaba abacab => 2,2,3,4\\n  //   6. niconiconi nico => 3,1,1,2,2,3\\n  static List<Integer> calculateCounts(String s1, String s2) {\\n    int m = s1.length();\\n    int n = s2.length();\\n    List<Integer> counts = new ArrayList<>();\\n    counts.add(0);\\n\\n    int nums1 = 0;\\n    // Map from index in s1 of the first character of s2 to number of times such index is seen.\\n    Map<Integer, Integer> seen = new HashMap<>();\\n    int j = m-1;\\n    while (true) {\\n      for (int i = 0; i < n; i++) {\\n        if (j == m-1) {\\n          nums1++;\\n          j = 0;\\n        } else {\\n          j++;\\n        }\\n        int k = indexOf(s1, s2.charAt(i), j);\\n        if (k < j) {\\n          nums1++;\\n        }\\n        if (i == 0) {\\n          seen.put(k, seen.getOrDefault(k, 0) + 1);\\n          if (seen.get(k) == 2 && counts.get(0) == 0) {\\n            counts.set(0, counts.size() - 1);\\n          } else if (seen.get(k) == 3) {\\n            // System.out.format(\"%s %s %s\\\\n\", s1, s2, Utils.join(counts));\\n            return counts;\\n          }\\n        }\\n        j = k;\\n      }\\n      counts.add(nums1);\\n    }\\n  }\\n\\n  // Gets number of [s2,n2] fit in [s1,n1].\\n  // Note that counts[p] = q means [s1,q] contain [s2,p],\\n  static int getNumberOfS2n2(int n1, int n2, List<Integer> counts) {\\n    long l = 0;\\n    long h = Integer.MAX_VALUE;\\n    while (l < h) {\\n      long m = (l + 1 == h) ? h : (l+h)/2;\\n      // number of s1 required to hold [s2, m*n2]\\n      long nums1 = getNumS1ForS2k(m * n2, counts);\\n      if (nums1 > n1) {\\n        h = m - 1;\\n      } else {\\n        l = m;\\n      }\\n    }\\n    return (int) l;\\n  }\\n\\n  // Calculate number of s1 to hold [s2,k]\\n  static long getNumS1ForS2k(long k, List<Integer> counts) {\\n    if (k < counts.size()) {\\n      return counts.get((int) k);\\n    } else {\\n      int idx = counts.get(0);\\n      int len = counts.size();\\n      int b = counts.get(idx);\\n      // The initial [s1,b] contains [s2,idx], then every [s1,q] contains [s2, p]\\n      long q = counts.get(len-1) - counts.get(idx);\\n      int p = len - 1 - idx;\\n\\n      long ans = b;\\n      k -= idx;\\n      ans += q * (k / p);\\n      k %= p;\\n      if (k > 0) {\\n        ans += counts.get((int) k);\\n      }\\n      return ans;\\n    }\\n  }\\n\\n  // Gets the circular next index of character c in s on or after index i\\n  static int indexOf(String s, char c, int i) {\\n    int k = s.indexOf(c, i);\\n    return k >= 0 ? k : s.indexOf(c, 0);\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  public static int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n    if (n1 == 0 || n2 == 0) {\\n      return 0;\\n    }\\n    // If s2 contain any character not appear in s1, return 0.\\n    for (char c : s2.toCharArray()) {\\n      if (s1.indexOf(c) < 0) {\\n        return 0;\\n      }\\n    }\\n\\n    List<Integer> counts = calculateCounts(s1, s2);\\n    return getNumberOfS2n2(n1, n2, counts);\\n  }\\n\\n  // Calculate counts array in which counts[i] is the number of s1 required to contain [s2,i].\\n  // The special counts[0] hold the index when first observation of repeat offset.\\n  // We stop when observe the start offset the third time. For examples:\\n  //   1. cba abc => 1,3,5\\n  //   2. acb ab => 1,1,2\\n  //   3. aaa aa => 3,1,2,2,3,4,4\\n  //   4. baba baab => 2,2,3,5,6\\n  //   5. bacaba abacab => 2,2,3,4\\n  //   6. niconiconi nico => 3,1,1,2,2,3\\n  static List<Integer> calculateCounts(String s1, String s2) {\\n    int m = s1.length();\\n    int n = s2.length();\\n    List<Integer> counts = new ArrayList<>();\\n    counts.add(0);\\n\\n    int nums1 = 0;\\n    // Map from index in s1 of the first character of s2 to number of times such index is seen.\\n    Map<Integer, Integer> seen = new HashMap<>();\\n    int j = m-1;\\n    while (true) {\\n      for (int i = 0; i < n; i++) {\\n        if (j == m-1) {\\n          nums1++;\\n          j = 0;\\n        } else {\\n          j++;\\n        }\\n        int k = indexOf(s1, s2.charAt(i), j);\\n        if (k < j) {\\n          nums1++;\\n        }\\n        if (i == 0) {\\n          seen.put(k, seen.getOrDefault(k, 0) + 1);\\n          if (seen.get(k) == 2 && counts.get(0) == 0) {\\n            counts.set(0, counts.size() - 1);\\n          } else if (seen.get(k) == 3) {\\n            // System.out.format(\"%s %s %s\\\\n\", s1, s2, Utils.join(counts));\\n            return counts;\\n          }\\n        }\\n        j = k;\\n      }\\n      counts.add(nums1);\\n    }\\n  }\\n\\n  // Gets number of [s2,n2] fit in [s1,n1].\\n  // Note that counts[p] = q means [s1,q] contain [s2,p],\\n  static int getNumberOfS2n2(int n1, int n2, List<Integer> counts) {\\n    long l = 0;\\n    long h = Integer.MAX_VALUE;\\n    while (l < h) {\\n      long m = (l + 1 == h) ? h : (l+h)/2;\\n      // number of s1 required to hold [s2, m*n2]\\n      long nums1 = getNumS1ForS2k(m * n2, counts);\\n      if (nums1 > n1) {\\n        h = m - 1;\\n      } else {\\n        l = m;\\n      }\\n    }\\n    return (int) l;\\n  }\\n\\n  // Calculate number of s1 to hold [s2,k]\\n  static long getNumS1ForS2k(long k, List<Integer> counts) {\\n    if (k < counts.size()) {\\n      return counts.get((int) k);\\n    } else {\\n      int idx = counts.get(0);\\n      int len = counts.size();\\n      int b = counts.get(idx);\\n      // The initial [s1,b] contains [s2,idx], then every [s1,q] contains [s2, p]\\n      long q = counts.get(len-1) - counts.get(idx);\\n      int p = len - 1 - idx;\\n\\n      long ans = b;\\n      k -= idx;\\n      ans += q * (k / p);\\n      k %= p;\\n      if (k > 0) {\\n        ans += counts.get((int) k);\\n      }\\n      return ans;\\n    }\\n  }\\n\\n  // Gets the circular next index of character c in s on or after index i\\n  static int indexOf(String s, char c, int i) {\\n    int k = s.indexOf(c, i);\\n    return k >= 0 ? k : s.indexOf(c, 0);\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 699246,
                "title": "explained-with-loop-cycles-amortized-o-1",
                "content": "While we\\'re looping up to N1 calculated cycles with remainders, note that at worst case, only one character is pushed to the remainder, and character string size limit is 100, so effectively this makes all calculations bounded at 100 iterations, and hence can be considered amortized constant.\\n\\n```\\n#include <algorithm>\\n\\nstruct cycle\\n{\\n    int result;\\n    std::string remainder;\\n};\\n\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n       \\n        //Given s1 = \"baba\" and s2 = \"ab\", we could say that for\\n        //howManyS1Consumed = 1, howManyS2Consumed  = 1 ( baba -> aba -> ab ), \\n        //but for howManyS1Consumed = 2 , we could generate howManyS3Consumed = 3\\n        //( \"babababa\" -> \"abababa\", \"ababab\")\\n        \\n        //This could be broken into following steps:\\n        //a) Remainder = \"\", \"baba\" => \"aba\" => \"ab\", result = 1, a is pushed to remainder\\n        //b) Remainder = \"a\", \"baba\" => \"(a)b\" + \"aba\", result = 2, a is pushed to remainder again and cycle is closed -> if we found a cycle loop it means we can stop as we\\'ll reuse this.\\n        \\n        std::unordered_map<std::string, int> calculatedCyclesMap; \\n        std::vector<struct cycle> calculatedCycles;\\n        int cycleLoopStart = INT_MAX;\\n        std::string remainder;        \\n        int s2Length = s2.length();\\n        \\n        int calculatedCyclesNumber = 0;\\n        while(calculatedCyclesNumber != n1)\\n        {\\n            auto cycleLoopIterator = calculatedCyclesMap.find(remainder);\\n            if(cycleLoopIterator != calculatedCyclesMap.end())\\n            {\\n                cycleLoopStart = cycleLoopIterator->second;\\n                //We\\'re at the beginning of an already calculated cycle loop\\n                break;\\n            }\\n            \\n            struct cycle calculatedCycle;\\n            calculatedCycle.remainder = remainder;\\n            int howManyS2Consumed = 0;\\n            int s2Index = remainder.size();\\n            for(int i = 0; i < s1.size(); ++i)\\n            {\\n                if(s1[i] == s2[s2Index])\\n                {\\n                    s2Index++;\\n                    if(s2Index == s2Length)\\n                    {\\n                        howManyS2Consumed++;\\n                        s2Index = 0;\\n                    }\\n                }\\n            }\\n            \\n            calculatedCycle.result = howManyS2Consumed; \\n            calculatedCycles.push_back(calculatedCycle);\\n            //Points to increasing indexes\\n            calculatedCyclesMap.insert(make_pair(remainder,calculatedCyclesNumber));\\n            remainder = s2.substr(0, s2Index);\\n            calculatedCyclesNumber++;\\n        }\\n        \\n        //Now we have 1-min(N1,100) cycles in calculatedCycles\\n        //min(N1,100), because in worst case, we will be pushing one character\\n        //into the remainder with every cycle ( remainder is built as a substring\\n        //from 0 to s2Index, where s2Index is from 0 to s2Length, and s2Length max\\n        //is 100 )\\n        //Also, optionally, we have a cycleLoopStart such as there\\'s a part\\n        //from 0 to cycleLoopStart which does not \\n        //wrap around, and then from cycleLoopStart to calculatedCycles.size()\\n        //which will loop around ( that is, upon applying this loop over and \\n        //over again, we arrive to the same result )\\n        \\n        //The final result\\n        int result = 0;\\n        \\n        for(int i = 0; i < std::min((int)cycleLoopStart, (int)calculatedCycles.size()); ++i)\\n        {\\n            result += calculatedCycles[i].result;\\n        }\\n        \\n        if(cycleLoopStart != INT_MAX)\\n        {\\n            int cycleLoopSize = calculatedCycles.size() - cycleLoopStart;\\n            int cyclesRemaining = n1 - cycleLoopStart; //cycleLoopStart = how many\\n            //cycles were already used in pre cycle loop stage.\\n            \\n            int fullCycleLoops = cyclesRemaining / cycleLoopSize;\\n            int partialCycleLoopSteps = cyclesRemaining % cycleLoopSize;\\n            int fullCycleResult = 0;\\n            int partialCycleResult = 0;\\n            bool partialCycleFinalized = (partialCycleLoopSteps == 0);            \\n            for(int i = 0; i < cycleLoopSize; ++i)\\n            {\\n                struct cycle &currentLoopCycle = calculatedCycles[cycleLoopStart + i];\\n                fullCycleResult += currentLoopCycle.result;\\n                if(!partialCycleFinalized)\\n                {\\n                    partialCycleResult += currentLoopCycle.result;\\n                    if((i + 1) == partialCycleLoopSteps)\\n                    {\\n                        partialCycleFinalized = true;\\n                    }                    \\n                }\\n            }\\n            \\n            result += (fullCycleResult * fullCycleLoops);\\n            result += partialCycleResult;\\n            \\n        }\\n\\t\\t\\n        //Finally, split the number of found s2\\'s by the n2 so that we get the actual amount of found S2\\'s\\n        return result / n2;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <algorithm>\\n\\nstruct cycle\\n{\\n    int result;\\n    std::string remainder;\\n};\\n\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n       \\n        //Given s1 = \"baba\" and s2 = \"ab\", we could say that for\\n        //howManyS1Consumed = 1, howManyS2Consumed  = 1 ( baba -> aba -> ab ), \\n        //but for howManyS1Consumed = 2 , we could generate howManyS3Consumed = 3\\n        //( \"babababa\" -> \"abababa\", \"ababab\")\\n        \\n        //This could be broken into following steps:\\n        //a) Remainder = \"\", \"baba\" => \"aba\" => \"ab\", result = 1, a is pushed to remainder\\n        //b) Remainder = \"a\", \"baba\" => \"(a)b\" + \"aba\", result = 2, a is pushed to remainder again and cycle is closed -> if we found a cycle loop it means we can stop as we\\'ll reuse this.\\n        \\n        std::unordered_map<std::string, int> calculatedCyclesMap; \\n        std::vector<struct cycle> calculatedCycles;\\n        int cycleLoopStart = INT_MAX;\\n        std::string remainder;        \\n        int s2Length = s2.length();\\n        \\n        int calculatedCyclesNumber = 0;\\n        while(calculatedCyclesNumber != n1)\\n        {\\n            auto cycleLoopIterator = calculatedCyclesMap.find(remainder);\\n            if(cycleLoopIterator != calculatedCyclesMap.end())\\n            {\\n                cycleLoopStart = cycleLoopIterator->second;\\n                //We\\'re at the beginning of an already calculated cycle loop\\n                break;\\n            }\\n            \\n            struct cycle calculatedCycle;\\n            calculatedCycle.remainder = remainder;\\n            int howManyS2Consumed = 0;\\n            int s2Index = remainder.size();\\n            for(int i = 0; i < s1.size(); ++i)\\n            {\\n                if(s1[i] == s2[s2Index])\\n                {\\n                    s2Index++;\\n                    if(s2Index == s2Length)\\n                    {\\n                        howManyS2Consumed++;\\n                        s2Index = 0;\\n                    }\\n                }\\n            }\\n            \\n            calculatedCycle.result = howManyS2Consumed; \\n            calculatedCycles.push_back(calculatedCycle);\\n            //Points to increasing indexes\\n            calculatedCyclesMap.insert(make_pair(remainder,calculatedCyclesNumber));\\n            remainder = s2.substr(0, s2Index);\\n            calculatedCyclesNumber++;\\n        }\\n        \\n        //Now we have 1-min(N1,100) cycles in calculatedCycles\\n        //min(N1,100), because in worst case, we will be pushing one character\\n        //into the remainder with every cycle ( remainder is built as a substring\\n        //from 0 to s2Index, where s2Index is from 0 to s2Length, and s2Length max\\n        //is 100 )\\n        //Also, optionally, we have a cycleLoopStart such as there\\'s a part\\n        //from 0 to cycleLoopStart which does not \\n        //wrap around, and then from cycleLoopStart to calculatedCycles.size()\\n        //which will loop around ( that is, upon applying this loop over and \\n        //over again, we arrive to the same result )\\n        \\n        //The final result\\n        int result = 0;\\n        \\n        for(int i = 0; i < std::min((int)cycleLoopStart, (int)calculatedCycles.size()); ++i)\\n        {\\n            result += calculatedCycles[i].result;\\n        }\\n        \\n        if(cycleLoopStart != INT_MAX)\\n        {\\n            int cycleLoopSize = calculatedCycles.size() - cycleLoopStart;\\n            int cyclesRemaining = n1 - cycleLoopStart; //cycleLoopStart = how many\\n            //cycles were already used in pre cycle loop stage.\\n            \\n            int fullCycleLoops = cyclesRemaining / cycleLoopSize;\\n            int partialCycleLoopSteps = cyclesRemaining % cycleLoopSize;\\n            int fullCycleResult = 0;\\n            int partialCycleResult = 0;\\n            bool partialCycleFinalized = (partialCycleLoopSteps == 0);            \\n            for(int i = 0; i < cycleLoopSize; ++i)\\n            {\\n                struct cycle &currentLoopCycle = calculatedCycles[cycleLoopStart + i];\\n                fullCycleResult += currentLoopCycle.result;\\n                if(!partialCycleFinalized)\\n                {\\n                    partialCycleResult += currentLoopCycle.result;\\n                    if((i + 1) == partialCycleLoopSteps)\\n                    {\\n                        partialCycleFinalized = true;\\n                    }                    \\n                }\\n            }\\n            \\n            result += (fullCycleResult * fullCycleLoops);\\n            result += partialCycleResult;\\n            \\n        }\\n\\t\\t\\n        //Finally, split the number of found s2\\'s by the n2 so that we get the actual amount of found S2\\'s\\n        return result / n2;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 616597,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        for(auto c : s2) {\\n            // preventive checkings, it could be O(n), but who cares.\\n            if (s1.find(c) == string::npos) return 0;\\n        }\\n        int p1 = 0, p2 = 0, mark = 0;\\n        while(p1 < s1.length() * n1) {\\n            char c = s2[p2 % s2.length()];\\n            while(s1[p1 % s1.length()] != c && p1 < s1.length() * n1) p1 ++;\\n            p2++;\\n            p1++;\\n            if (p2 % s2.length() == 0) {\\n                if (p2 == s2.length()) {\\n                    mark = p1; // mark the position in s1, when the first s2 ends\\n                } else if (p1 % s1.length() == mark % s1.length()) {\\n                    int round = (s1.length() * n1 - p1) / (p1 - mark);\\n                    p1 += round * (p1 - mark);\\n                    p2 += round * (p2 - s2.length());\\n                }\\n            }\\n        }\\n        return p2 / s2.length() / n2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        for(auto c : s2) {\\n            // preventive checkings, it could be O(n), but who cares.\\n            if (s1.find(c) == string::npos) return 0;\\n        }\\n        int p1 = 0, p2 = 0, mark = 0;\\n        while(p1 < s1.length() * n1) {\\n            char c = s2[p2 % s2.length()];\\n            while(s1[p1 % s1.length()] != c && p1 < s1.length() * n1) p1 ++;\\n            p2++;\\n            p1++;\\n            if (p2 % s2.length() == 0) {\\n                if (p2 == s2.length()) {\\n                    mark = p1; // mark the position in s1, when the first s2 ends\\n                } else if (p1 % s1.length() == mark % s1.length()) {\\n                    int round = (s1.length() * n1 - p1) / (p1 - mark);\\n                    p1 += round * (p1 - mark);\\n                    p2 += round * (p2 - s2.length());\\n                }\\n            }\\n        }\\n        return p2 / s2.length() / n2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 605918,
                "title": "extremely-concise-and-fast-solution",
                "content": "time complexity: O(n1 * len(s1)), theoretically faster than the best solution so far\\n```python\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        if not set(s1) >= set(s2):\\n            return 0\\n        s1 = \\'\\'.join(ch for ch in s1 if ch in set(s2))\\n        i2 = 0\\n        start = [0] * len(s2)\\n        start[0] = (0, 0)\\n        count_round = [0] * (n1 + 1)\\n        for round in range(1, n1 + 1):\\n            for ch in s1:\\n                if s2[i2 % len(s2)] == ch:\\n                    i2 += 1\\n            c, i = divmod(i2, len(s2))\\n            if not start[i]:\\n                start[i] = (round, c)\\n                count_round[round] = c\\n            else:\\n                pre_round, pre_c = start[i]\\n                q, r = divmod(n1 - pre_round, round - pre_round)\\n                return ((c - pre_c) * q + count_round[pre_round + r]) // n2\\n        return i2 // (len(s2) * n2)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        if not set(s1) >= set(s2):\\n            return 0\\n        s1 = \\'\\'.join(ch for ch in s1 if ch in set(s2))\\n        i2 = 0\\n        start = [0] * len(s2)\\n        start[0] = (0, 0)\\n        count_round = [0] * (n1 + 1)\\n        for round in range(1, n1 + 1):\\n            for ch in s1:\\n                if s2[i2 % len(s2)] == ch:\\n                    i2 += 1\\n            c, i = divmod(i2, len(s2))\\n            if not start[i]:\\n                start[i] = (round, c)\\n                count_round[round] = c\\n            else:\\n                pre_round, pre_c = start[i]\\n                q, r = divmod(n1 - pre_round, round - pre_round)\\n                return ((c - pre_c) * q + count_round[pre_round + r]) // n2\\n        return i2 // (len(s2) * n2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532452,
                "title": "accepted-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        public int GetMaxRepetitions(string s1, int n1, string s2, int n2)\\n        {\\n            int i = 0;\\n            int j = 0;\\n            int fullS1Length = n1 * s1.Length;\\n            IDictionary<(int i, int j), (int i, int j)> repeatingMap = new Dictionary<(int i, int j), (int i, int j)>();\\n            while (i < fullS1Length)\\n            {\\n                var modI = i % s1.Length;\\n                var modJ = j % s2.Length;\\n\\n                if (s1[modI] == s2[modJ])\\n                {\\n\\n                    if (repeatingMap.ContainsKey((modI, modJ)))\\n                    {\\n                        (int i, int j) prevMatch = repeatingMap[(modI, modJ)];\\n                        var l1 = i - prevMatch.i;\\n                        var l2 = j - prevMatch.j;\\n                        var remains = (fullS1Length - i) / l1;\\n                        i += l1 * remains;\\n                        j += l2 * remains;\\n\\n                        if (i >= fullS1Length)\\n                        {\\n                             return j / s2.Length / n2;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        repeatingMap[(modI, modJ)] = (i,j);\\n                    }\\n\\n                    j++;\\n                }\\n\\n                i++;\\n            }\\n\\n            return j / s2.Length / n2;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        public int GetMaxRepetitions(string s1, int n1, string s2, int n2)\\n        {\\n            int i = 0;\\n            int j = 0;\\n            int fullS1Length = n1 * s1.Length;\\n            IDictionary<(int i, int j), (int i, int j)> repeatingMap = new Dictionary<(int i, int j), (int i, int j)>();\\n            while (i < fullS1Length)\\n            {\\n                var modI = i % s1.Length;\\n                var modJ = j % s2.Length;\\n\\n                if (s1[modI] == s2[modJ])\\n                {\\n\\n                    if (repeatingMap.ContainsKey((modI, modJ)))\\n                    {\\n                        (int i, int j) prevMatch = repeatingMap[(modI, modJ)];\\n                        var l1 = i - prevMatch.i;\\n                        var l2 = j - prevMatch.j;\\n                        var remains = (fullS1Length - i) / l1;\\n                        i += l1 * remains;\\n                        j += l2 * remains;\\n\\n                        if (i >= fullS1Length)\\n                        {\\n                             return j / s2.Length / n2;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        repeatingMap[(modI, modJ)] = (i,j);\\n                    }\\n\\n                    j++;\\n                }\\n\\n                i++;\\n            }\\n\\n            return j / s2.Length / n2;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 471770,
                "title": "simple-clean-python-solution",
                "content": "```\\nclass Solution2:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        repeatCount = [0] * (n1 + 1)\\n        nextIndex = [0] * (n1 + 1)\\n        j, count = 0, 0\\n\\n        for k in range(1, n1 + 1):\\n            for i in range(len(s1)):\\n                if s1[i] == s2[j]:\\n                    j += 1\\n                    if j == len(s2):\\n                        j = 0\\n                        count += 1\\n            repeatCount[k] = count\\n            nextIndex[k] = j\\n\\n            for start in range(k):\\n                if nextIndex[start] == j:\\n                    prefixCount = repeatCount[start]\\n                    patternCount = (n1 - start) // (k - start) * (repeatCount[k] - prefixCount)\\n                    suffixCount = repeatCount[start + (n1 - start) % (k - start)] - prefixCount\\n                    return (prefixCount + patternCount + suffixCount) // n2\\n\\n        return repeatCount[n1] // n2\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution2:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        repeatCount = [0] * (n1 + 1)\\n        nextIndex = [0] * (n1 + 1)\\n        j, count = 0, 0\\n\\n        for k in range(1, n1 + 1):\\n            for i in range(len(s1)):\\n                if s1[i] == s2[j]:\\n                    j += 1\\n                    if j == len(s2):\\n                        j = 0\\n                        count += 1\\n            repeatCount[k] = count\\n            nextIndex[k] = j\\n\\n            for start in range(k):\\n                if nextIndex[start] == j:\\n                    prefixCount = repeatCount[start]\\n                    patternCount = (n1 - start) // (k - start) * (repeatCount[k] - prefixCount)\\n                    suffixCount = repeatCount[start + (n1 - start) % (k - start)] - prefixCount\\n                    return (prefixCount + patternCount + suffixCount) // n2\\n\\n        return repeatCount[n1] // n2\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395920,
                "title": "python-beat-100-inspired-by-70664914",
                "content": "class Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        \"\"\"\\n        :type s1: str\\n        :type n1: int\\n        :type s2: str\\n        :type n2: int\\n        :rtype: int\\n        \"\"\"\\n        idx2 = 0\\n        nextIdx = [0]\\n        rounds2 = [0]\\n        repeats2 = 0\\n        \\n        for rounds in range(min(len(s2)+1, n1)):\\n            count = 0\\n            for idx1 in range(len(s1)):\\n                if s1[idx1] == s2[idx2]:\\n                    idx2 += 1\\n                    count += 1\\n                    if idx2 == len(s2):\\n                        repeats2 += 1\\n                        idx2 = 0\\n            for i in range(len(nextIdx)):\\n                if nextIdx[i] == idx2:\\n                    return (rounds2[i] + ((n1-i) / (rounds + 1 - i))*(repeats2 - rounds2[i]) + rounds2[(n1-i) % (rounds + 1 - i)]) / n2\\n            nextIdx.append(idx2)\\n            rounds2.append(repeats2)\\n            if count == 0:\\n                return(0)\\n        return(rounds2[n1]/n2)\\n                    \\n                    \\n                    \\n                    \\n                    \\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        \"\"\"\\n        :type s1: str\\n        :type n1: int\\n        :type s2: str\\n        :type n2: int\\n        :rtype: int\\n        \"\"\"\\n        idx2 = 0\\n        nextIdx = [0]\\n        rounds2 = [0]\\n        repeats2 = 0\\n        \\n        for rounds in range(min(len(s2)+1, n1)):\\n            count = 0\\n            for idx1 in range(len(s1)):\\n                if s1[idx1] == s2[idx2]:\\n                    idx2 += 1\\n                    count += 1\\n                    if idx2 == len(s2):\\n                        repeats2 += 1\\n                        idx2 = 0\\n            for i in range(len(nextIdx)):\\n                if nextIdx[i] == idx2:\\n                    return (rounds2[i] + ((n1-i) / (rounds + 1 - i))*(repeats2 - rounds2[i]) + rounds2[(n1-i) % (rounds + 1 - i)]) / n2\\n            nextIdx.append(idx2)\\n            rounds2.append(repeats2)\\n            if count == 0:\\n                return(0)\\n        return(rounds2[n1]/n2)\\n                    \\n                    \\n                    \\n                    \\n                    \\n",
                "codeTag": "Java"
            },
            {
                "id": 369466,
                "title": "from-brute-force-to-optimal-solution-1ms",
                "content": "1. Let\\'s start with the most straightforard solution. Check [s1,n1] against s2 directly to find the max number of match , noted as jCount. Since jCount = M*n2, then jCount/n2 is the result;\\n```\\n    //brute force - tle\\n    private int sln1(String s1, int n1, String s2, int n2){\\n        char[] ss1 = s1.toCharArray();\\n        char[] ss2 = s2.toCharArray();\\n        int jCount=0;\\n        int l2 = ss2.length;\\n        for(int k=0, j=0;k <n1; k++){\\n            for(int i =0;i < ss1.length; i++){\\n                if(ss1[i] == ss2[j]){\\n                    j ++;\\n                    jCount+= j/l2;\\n                    j = j%l2;\\n                }\\n            }\\n        }\\n        return jCount/n2;\\n    }\\n```\\n\\n2. There are a lot duplicated matches during brute force search. For example, s1 = abab, s2=aaa\\ns1s1=abababab\\ns2s2=aaaaaa\\ns1s1s1=abababababab\\n...\\nThen we know 3 s1 can match exactly 2 s2, there is not need to check [s1, 6], [s1, 9], they will mach 4 s2 and 6 s2 according to the ratio 3:2.\\nHow do we find the ratio? Every time we are comparing a character in s1 and a character in s2, we check their indexes i, j. If they reach the end of their length at the same point, that is a exact match. Since I reset j everytime it reaches the end of s2, we can check if j ==0 to find the exact match. At this piont, we would have [s2, jCount] is obtained from [s1, k+1], then we know the ratio is k+1: jCount. Since we have n1: Mn2 = k+1: jCount. we can get M = n1*jCount/(k+1)/n2;\\n```\\n    //brute force improved - 303ms\\n    //O(l^2*mo)\\n    private int sln2(String s1, int n1, String s2, int n2){\\n        char[] ss1 = s1.toCharArray();\\n        char[] ss2 = s2.toCharArray();\\n        int jCount=0;\\n        int l2 = ss2.length;\\n        for(int k=0, j=0;k <n1; k++){\\n            for(int i =0;i < ss1.length; i++){\\n                if(ss1[i] == ss2[j]){\\n                    j ++;\\n                    jCount+= j/l2;\\n                    j = j%l2;\\n                }\\n            }\\n            if(j == 0){\\n                return n1*jCount/(k+1)/n2;\\n            }\\n        }\\n        return jCount/n2;\\n    }\\n```\\n\\n3. If we can find an exact match at the end of s2, can we find that at some point j, j< len(s2)? The answer is YES. We can use a hashmap to store the current nubmer of s1 visited and current number of s2 matched and use current index j in s2 as the key. If at one future point, we finish kth s1 search and end up at a point j which exists in our map, we know there is an exact match found in \"s2.substring(j)+s2s2....s2+s2.substring(0,j)\". \\nWe can get the number of s1 vistied from the diff between current number of s1, k and previous number of s1, prev(k), noted as kDiff;\\nWe can get the number of s2 matched from the diff between current jCount and previous jCount, prev(jCount), noted as jCountDiff;\\nWe can now get the ratio: kDiff/jCountDiff;\\nStarting from previous j, noted as prev(j), all matches found in the rest of string (s1s1s1...) will match this ratio. But the strings before prev(j) may not be the case. \\nThe number of s1 before prev(j) equals prev(k)+1, then the number of s1 after prev(j) equals n1-prev(k)-1, noted as n1Left. We can use this to find number of s2 matched from n1Left.\\nSince n1Left:n2Left = kDiff:jCountDiff. We can have n2Left = n1Left*jCountDiff/kDiff.\\nSince we have prev(jCount) of s2 matched before prev(j), we will have total M*n2 = n2Left+prev(jCount), and finally M= (n1Left*jCountDiff/kDiff+prev(jCount))/n2\\n\\n```\\n    //brute force improved improved - 1ms\\n    private int sln3(String s1, int n1, String s2, int n2){\\n        char[] ss1 = s1.toCharArray();\\n        char[] ss2 = s2.toCharArray();\\n        int jCount=0;\\n        int l2 = ss2.length;\\n        Map<Integer, int[]> map = new HashMap<>();\\n        for(int k=0, j=0;k <n1; k++){\\n            for(int i =0;i < ss1.length; i++){\\n                if(ss1[i] == ss2[j]){\\n                    j ++;\\n                    jCount+= j/l2;\\n                    j = j%l2;\\n                }\\n            }\\n            if(j == 0){\\n                return n1*jCount/(k+1)/n2;\\n            }\\n            if(map.containsKey(j)){\\n                int[] last = map.get(j);\\n                int kDiff = k-last[0];\\n                int jCountDiff = jCount- last[1];\\n                int n1Left = n1-last[0]-1;\\n                return (n1Left*jCountDiff/kDiff+last[1])/n2;\\n            }\\n            map.put(j, new int[]{k, jCount});\\n        }\\n        return jCount/n2;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    //brute force - tle\\n    private int sln1(String s1, int n1, String s2, int n2){\\n        char[] ss1 = s1.toCharArray();\\n        char[] ss2 = s2.toCharArray();\\n        int jCount=0;\\n        int l2 = ss2.length;\\n        for(int k=0, j=0;k <n1; k++){\\n            for(int i =0;i < ss1.length; i++){\\n                if(ss1[i] == ss2[j]){\\n                    j ++;\\n                    jCount+= j/l2;\\n                    j = j%l2;\\n                }\\n            }\\n        }\\n        return jCount/n2;\\n    }\\n```\n```\\n    //brute force improved - 303ms\\n    //O(l^2*mo)\\n    private int sln2(String s1, int n1, String s2, int n2){\\n        char[] ss1 = s1.toCharArray();\\n        char[] ss2 = s2.toCharArray();\\n        int jCount=0;\\n        int l2 = ss2.length;\\n        for(int k=0, j=0;k <n1; k++){\\n            for(int i =0;i < ss1.length; i++){\\n                if(ss1[i] == ss2[j]){\\n                    j ++;\\n                    jCount+= j/l2;\\n                    j = j%l2;\\n                }\\n            }\\n            if(j == 0){\\n                return n1*jCount/(k+1)/n2;\\n            }\\n        }\\n        return jCount/n2;\\n    }\\n```\n```\\n    //brute force improved improved - 1ms\\n    private int sln3(String s1, int n1, String s2, int n2){\\n        char[] ss1 = s1.toCharArray();\\n        char[] ss2 = s2.toCharArray();\\n        int jCount=0;\\n        int l2 = ss2.length;\\n        Map<Integer, int[]> map = new HashMap<>();\\n        for(int k=0, j=0;k <n1; k++){\\n            for(int i =0;i < ss1.length; i++){\\n                if(ss1[i] == ss2[j]){\\n                    j ++;\\n                    jCount+= j/l2;\\n                    j = j%l2;\\n                }\\n            }\\n            if(j == 0){\\n                return n1*jCount/(k+1)/n2;\\n            }\\n            if(map.containsKey(j)){\\n                int[] last = map.get(j);\\n                int kDiff = k-last[0];\\n                int jCountDiff = jCount- last[1];\\n                int n1Left = n1-last[0]-1;\\n                return (n1Left*jCountDiff/kDiff+last[1])/n2;\\n            }\\n            map.put(j, new int[]{k, jCount});\\n        }\\n        return jCount/n2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 363840,
                "title": "improvement-of-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int idx=0;\\n        int len1=s1.length();\\n        int len2=s2.length();\\n        vector<vector<int> > dps1(len1, vector<int>(len2, -1)), dps2(len1, vector<int>(len2, -1));\\n        for(int i=0;i<n1*len1;++i){\\n            if(s2[idx%len2]==s1[i%len1]){\\n                if(dps1[i%len1][idx%len2]!=-1 && i+i-dps2[i%len1][idx%len2]<n1*len1){\\n                    idx+=idx-dps1[i%len1][idx%len2];\\n                    i+=i-dps2[i%len1][idx%len2]-1;\\n                }\\n                else{\\n                    dps1[i%len1][idx%len2]=idx;\\n                    dps2[i%len1][idx%len2]=i;\\n                    ++idx;                    \\n                }\\n            }\\n        }\\n        return idx/len2/n2;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int idx=0;\\n        int len1=s1.length();\\n        int len2=s2.length();\\n        vector<vector<int> > dps1(len1, vector<int>(len2, -1)), dps2(len1, vector<int>(len2, -1));\\n        for(int i=0;i<n1*len1;++i){\\n            if(s2[idx%len2]==s1[i%len1]){\\n                if(dps1[i%len1][idx%len2]!=-1 && i+i-dps2[i%len1][idx%len2]<n1*len1){\\n                    idx+=idx-dps1[i%len1][idx%len2];\\n                    i+=i-dps2[i%len1][idx%len2]-1;\\n                }\\n                else{\\n                    dps1[i%len1][idx%len2]=idx;\\n                    dps2[i%len1][idx%len2]=i;\\n                    ++idx;                    \\n                }\\n            }\\n        }\\n        return idx/len2/n2;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 326820,
                "title": "share-my-concise-1ms-java-code",
                "content": "```\\npublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int n = s2.length();\\n        char[] ss1 = s1.toCharArray();\\n        char[] ss2 = s2.toCharArray();\\n        int[][] memo = new int[n][];\\n        int[] s2CountMap = new int[n + 1];\\n        int s1Count = 0, s2Count = 0;\\n        int s2Idx = 0;\\n        while (memo[s2Idx] == null) {\\n            memo[s2Idx] = new int[]{s1Count, s2Count};\\n            for (char c1 : ss1) {\\n                if (c1 == ss2[s2Idx]) {\\n                    s2Idx++;\\n                    if (s2Idx == n) {\\n                        s2Count++;\\n                        s2Idx = 0;\\n                    }\\n                }\\n            }\\n            s1Count++;\\n            s2CountMap[s1Count] = s2Count;\\n        }\\n\\n        int n1Left = n1 - memo[s2Idx][0];\\n        int matchedPatternCount = n1Left / (s1Count - memo[s2Idx][0]) * (s2Count - memo[s2Idx][1]);\\n        n1Left = n1Left % (s1Count - memo[s2Idx][0]);\\n        int leftS2Count = s2CountMap[memo[s2Idx][0] + n1Left] - memo[s2Idx][1];\\n        int totalCount = leftS2Count + matchedPatternCount + memo[s2Idx][1];\\n        return totalCount / n2;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int n = s2.length();\\n        char[] ss1 = s1.toCharArray();\\n        char[] ss2 = s2.toCharArray();\\n        int[][] memo = new int[n][];\\n        int[] s2CountMap = new int[n + 1];\\n        int s1Count = 0, s2Count = 0;\\n        int s2Idx = 0;\\n        while (memo[s2Idx] == null) {\\n            memo[s2Idx] = new int[]{s1Count, s2Count};\\n            for (char c1 : ss1) {\\n                if (c1 == ss2[s2Idx]) {\\n                    s2Idx++;\\n                    if (s2Idx == n) {\\n                        s2Count++;\\n                        s2Idx = 0;\\n                    }\\n                }\\n            }\\n            s1Count++;\\n            s2CountMap[s1Count] = s2Count;\\n        }\\n\\n        int n1Left = n1 - memo[s2Idx][0];\\n        int matchedPatternCount = n1Left / (s1Count - memo[s2Idx][0]) * (s2Count - memo[s2Idx][1]);\\n        n1Left = n1Left % (s1Count - memo[s2Idx][0]);\\n        int leftS2Count = s2CountMap[memo[s2Idx][0] + n1Left] - memo[s2Idx][1];\\n        int totalCount = leftS2Count + matchedPatternCount + memo[s2Idx][1];\\n        return totalCount / n2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 307601,
                "title": "python3-o-s1-s2-solution-with-detailed-explanation-beats-100",
                "content": "![image](https://assets.leetcode.com/users/dengl11/image_1559973927.png)\\n\\n\\nThis is a quite tricky solution. It took me a day to understand the [discussion here](httphttps://leetcode.com/problems/count-the-repetitions/discuss/95397/C%2B%2B-0ms-O(str1.length*str2.length)://):\\n\\nThe basic idea is to detect the repeating pattern of S2 in multiple concated S1. After we find, say, `x1->x2` passes of S2 can be made from `y1->y2` passes of S1, then it means that n1 passes of S1 can make X passes of S2. And X is made from 2 parts:\\n\\n1. repeating part: `(n1 - y1)//(y2 - y1) * (x2-x1)`\\n2. remaining part: `(n1 - y1)%(y2 - y1) + y1 *`\\n\\nNow the question is how to find out `x1, x2`, `y1, y2`:\\n```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        pass2s = [-1]*(len(s2) + 1) # pass2s[i]: i pass1 can make pass2s[i] passes of pass2\\n        index2s = [-1]*(len(s2) + 1) # index2s[i]: i pass1 match up to (not including) the pass2s[i] character of S2; all values in index2s should be different, otherwise we will catch the same value and return, as seen in the code below\\n\\t\\t# initially without any pass S1:\\n        pass2s[0] = index2s[0] = 0\\n        index2 = 0\\n        pass2 = 0\\n        for pass1 in range(1, n1+1): # this outer loop will break within min(n1, n2) iterations\\n            for index1 in range(len(s1)): # use current pass of S1 to match as many characters in S2 as we can\\n                if s1[index1] == s2[index2]:\\n                    index2 += 1\\n                    if index2 == len(s2):\\n                        index2 = 0\\n                        pass2 += 1\\n\\t\\t\\t# now we know at pass1, how many pass2 we can make, and what the final stopping character\\n            index2s[pass1] = index2\\n            pass2s[pass1] = pass2\\n\\t\\t\\t\\n            # detect repeating pattern\\n            for i in range(pass1): # try fo find one prevous pass1 that can stop at the same character\\n                if index2s[i] == index2:\\n\\t\\t\\t\\t\\t# now we\\'d like to match index^th character of S2, and we find that one previous pass1, i.e. the i^th pass, can already match that, then the repeating pattern is detected\\n                    repeating_counts, remain = divmod(n1 - i, pass1 - i)\\n                    ans = repeating_counts * (pass2s[pass1]-pass2s[i])\\n                    ans += pass2s[i + remain]\\n\\t\\t\\t\\t\\t# ans here means that we can make ans passes of S2\\n                    return ans // n2\\n\\t\\t# if repeating pattern found, then just use all passes of S1, i.e. n1 to make S2\\n        return pass2s[n1] // n2\\n                    \\n```\\n\\nTotal compleity: \\n- Outer Loop: O(min(n1, S2))\\n- Innter Loop: O(S1)\\n\\nSo total complexity is O(|S1| * |S2|)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        pass2s = [-1]*(len(s2) + 1) # pass2s[i]: i pass1 can make pass2s[i] passes of pass2\\n        index2s = [-1]*(len(s2) + 1) # index2s[i]: i pass1 match up to (not including) the pass2s[i] character of S2; all values in index2s should be different, otherwise we will catch the same value and return, as seen in the code below\\n\\t\\t# initially without any pass S1:\\n        pass2s[0] = index2s[0] = 0\\n        index2 = 0\\n        pass2 = 0\\n        for pass1 in range(1, n1+1): # this outer loop will break within min(n1, n2) iterations\\n            for index1 in range(len(s1)): # use current pass of S1 to match as many characters in S2 as we can\\n                if s1[index1] == s2[index2]:\\n                    index2 += 1\\n                    if index2 == len(s2):\\n                        index2 = 0\\n                        pass2 += 1\\n\\t\\t\\t# now we know at pass1, how many pass2 we can make, and what the final stopping character\\n            index2s[pass1] = index2\\n            pass2s[pass1] = pass2\\n\\t\\t\\t\\n            # detect repeating pattern\\n            for i in range(pass1): # try fo find one prevous pass1 that can stop at the same character\\n                if index2s[i] == index2:\\n\\t\\t\\t\\t\\t# now we\\'d like to match index^th character of S2, and we find that one previous pass1, i.e. the i^th pass, can already match that, then the repeating pattern is detected\\n                    repeating_counts, remain = divmod(n1 - i, pass1 - i)\\n                    ans = repeating_counts * (pass2s[pass1]-pass2s[i])\\n                    ans += pass2s[i + remain]\\n\\t\\t\\t\\t\\t# ans here means that we can make ans passes of S2\\n                    return ans // n2\\n\\t\\t# if repeating pattern found, then just use all passes of S1, i.e. n1 to make S2\\n        return pass2s[n1] // n2\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 201674,
                "title": "javascript-56ms-o-s1-length-s2-length-time-and-o-1-space",
                "content": "Like other solutions, we also detect the cycle occurence, but repeat twice is enough. It passes the OJ in 56ms with O(1) space, let me know if there\\'s something wrong.\\n\\n```javascript\\nvar getMaxRepetitions = function(s1, n1, s2, n2) {\\n    let j = 0, i, count = 0, perCycle = 0, firstEnd = -1, lastEnd = -1, nonMatch = 0;\\n    for(i = 0; i < s1.length * n1; i++) {\\n        if (s2[j] === s1[i % s1.length]) {\\n            j++;\\n            nonMatch = 0;\\n        }\\n        else if (++nonMatch >= s1.length) break;\\n        if (j === s2.length) {\\n            count++;\\n            perCycle++;\\n            j = 0;\\n            if (lastEnd !== -1) continue;\\n            else if (firstEnd === -1) {\\n                firstEnd = i;\\n                perCycle = 0;\\n            }\\n            else if ((i - firstEnd) % s1.length === 0) {\\n                let cycleLen = i - firstEnd;\\n                let remainLen = s1.length * n1 - i - 1;\\n                let cycles = Math.floor(remainLen / cycleLen);\\n                count += cycles * perCycle;\\n                i += cycles * cycleLen;\\n            }\\n        }\\n    }\\n    return Math.floor(count / n2);\\n};\\n```\\n\\nRemoving the `nonMatch` check does not effect the time. Maybe there should be a test case like:\\n\\n```\\naaaaaa 1000000\\nb 1\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar getMaxRepetitions = function(s1, n1, s2, n2) {\\n    let j = 0, i, count = 0, perCycle = 0, firstEnd = -1, lastEnd = -1, nonMatch = 0;\\n    for(i = 0; i < s1.length * n1; i++) {\\n        if (s2[j] === s1[i % s1.length]) {\\n            j++;\\n            nonMatch = 0;\\n        }\\n        else if (++nonMatch >= s1.length) break;\\n        if (j === s2.length) {\\n            count++;\\n            perCycle++;\\n            j = 0;\\n            if (lastEnd !== -1) continue;\\n            else if (firstEnd === -1) {\\n                firstEnd = i;\\n                perCycle = 0;\\n            }\\n            else if ((i - firstEnd) % s1.length === 0) {\\n                let cycleLen = i - firstEnd;\\n                let remainLen = s1.length * n1 - i - 1;\\n                let cycles = Math.floor(remainLen / cycleLen);\\n                count += cycles * perCycle;\\n                i += cycles * cycleLen;\\n            }\\n        }\\n    }\\n    return Math.floor(count / n2);\\n};\\n```\n```\\naaaaaa 1000000\\nb 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 155898,
                "title": "c-and-java-solution",
                "content": "The complexity lies in the fact that when we find the repetitive part s2 in s1, there could be trailing string in s1 left behind. How do we account for it in the next pattern matching ? For e.g. if we have S1 = [aba, 4] and S2 = [aab, 2] , then we have something like this:\\n\\nS1 = [ aba aba aba aba ]\\nS2 = [ aab aab ]\\nPattern matching starts at index 0 in s1.\\n\\nIn order to get one instance of s2 = [ aab ] begining from **index 0** in s1 = [aba] , We need two instances of s1, that is, [**a**b**a** a**b**a]. The pattern matching ends at index 1 in the second instance of s1 at **b**, trailing character in s2 **\"a\"** remains. So we know for any s2 that starts pattern matching at index 0 in s1 requires 2 instances of s1 and it\\'s total length is 5. The next pattern matching of s2 can begin here with **\"a\"** which is **indexed 2** in s1 originally. Suppose we have found lengths for all indices 0 <= i < s1.Length, we can simply use this pre-processed information to jump to next string s1 and find out where it ends and so on . For every jump we are matcing one s2. For every n2 * s2 we increment our result.\\n\\nFor special cases like s1 = \"aaaaaaaaaaaaa...100\"  and s2 = \"a\" we can simply return M by dividing the number of s2 we would need without processing.\\n```\\n public int GetMaxRepetitions(string s1, int n1, string s2, int n2)\\n        {\\n            var h1 = new HashSet<char>();\\n            var h2 = new HashSet<char>();\\n\\n            for (int i = 0; i < s1.Length; i++)\\n                h1.Add(s1[i]);\\n\\n            for (int i = 0; i < s2.Length; i++)\\n                h2.Add(s2[i]);\\n\\n            var it = h2.GetEnumerator();\\n            while (it.MoveNext())\\n            {\\n                // if s2 contains something that s1 does not.\\n                if (!h1.Contains(it.Current)) return 0; \\n            }\\n            \\n            if (h1.Count() == 1 && h2.Count() == 1)\\n            {\\n                //For cases like \"aaaaaaaaaaaa....\" and \"aa..\"\\n                return ((n1 * s1.Length) / (n2 * s2.Length));\\n            }\\n\\n            //Lens stores the length of a string that contains one \"s2\" and begins at index i.\\n            var lens = new int[s1.Length];\\n\\n            for (int i = 0; i < s1.Length; i++)\\n            {\\n                int j = 0;\\n                int c = 0;\\n\\n                while (j < s2.Length)\\n                {\\n                    if (s2[j] == s1[((i + c) % s1.Length)])\\n                        j++;\\n                    c++;\\n                }\\n\\n                lens[i] = c - 1;\\n            }\\n\\n            int count = 0;\\n            int total_length = s1.Length * n1;\\n\\n            int temp = 0;\\n            int k = 0;\\n            int cur_index = 0;\\n\\n            while (true)\\n            {\\n                k += lens[cur_index] + 1;\\n                if (k > total_length) break;\\n\\n                temp++;\\n                if (temp == n2)\\n                {\\n                    count++;\\n                    temp = 0;\\n                }\\n                cur_index = (cur_index + lens[cur_index] + 1) % s1.Length;\\n            }\\n\\n            return count;\\n        }\\n```\\n\\nIn Java:\\n\\n```\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n         HashSet<Character> h1 = new HashSet<>();\\n        HashSet<Character> h2 = new HashSet<>();\\n\\n        for (int i = 0; i < s1.length(); i++) {\\n            h1.add(s1.charAt(i));\\n        }\\n\\n        for (int i = 0; i < s2.length(); i++) {\\n            h2.add(s2.charAt(i));\\n        }\\n        \\n        int[] lens = new int[s1.length()];\\n\\n        Iterator<Character> it = h2.iterator();\\n        while (it.hasNext()) {\\n            if (!h1.contains(it.next())) return 0;\\n        }\\n        \\n        if (h1.size() == 1 && h2.size() == 1) {\\n            return ((n1 * s1.length()) / (n2 * s2.length()));\\n        }\\n        \\n        for (int i = 0; i < s1.length(); i++) {\\n            int j = 0;\\n            int c = 0;\\n\\n            while (j < s2.length()) {\\n                if (s2.charAt(j) == s1.charAt(((i + c) % s1.length())))\\n                    j++;\\n                c++;\\n            }\\n\\n            lens[i] = c - 1;\\n        }\\n\\n        int rep = 0;\\n        int total_length = s1.length() * n1;\\n\\n        int temp = 0;\\n        int k = 0;\\n        int cur = 0;\\n\\n        while (true) {\\n            k += lens[cur] + 1;\\n            if (k > total_length) break;\\n\\n            temp++;\\n            if (temp == n2) {\\n                rep++;\\n                temp = 0;\\n            }\\n            cur = (cur + lens[cur] + 1) % s1.length();\\n        }\\n\\n        return rep;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n public int GetMaxRepetitions(string s1, int n1, string s2, int n2)\\n        {\\n            var h1 = new HashSet<char>();\\n            var h2 = new HashSet<char>();\\n\\n            for (int i = 0; i < s1.Length; i++)\\n                h1.Add(s1[i]);\\n\\n            for (int i = 0; i < s2.Length; i++)\\n                h2.Add(s2[i]);\\n\\n            var it = h2.GetEnumerator();\\n            while (it.MoveNext())\\n            {\\n                // if s2 contains something that s1 does not.\\n                if (!h1.Contains(it.Current)) return 0; \\n            }\\n            \\n            if (h1.Count() == 1 && h2.Count() == 1)\\n            {\\n                //For cases like \"aaaaaaaaaaaa....\" and \"aa..\"\\n                return ((n1 * s1.Length) / (n2 * s2.Length));\\n            }\\n\\n            //Lens stores the length of a string that contains one \"s2\" and begins at index i.\\n            var lens = new int[s1.Length];\\n\\n            for (int i = 0; i < s1.Length; i++)\\n            {\\n                int j = 0;\\n                int c = 0;\\n\\n                while (j < s2.Length)\\n                {\\n                    if (s2[j] == s1[((i + c) % s1.Length)])\\n                        j++;\\n                    c++;\\n                }\\n\\n                lens[i] = c - 1;\\n            }\\n\\n            int count = 0;\\n            int total_length = s1.Length * n1;\\n\\n            int temp = 0;\\n            int k = 0;\\n            int cur_index = 0;\\n\\n            while (true)\\n            {\\n                k += lens[cur_index] + 1;\\n                if (k > total_length) break;\\n\\n                temp++;\\n                if (temp == n2)\\n                {\\n                    count++;\\n                    temp = 0;\\n                }\\n                cur_index = (cur_index + lens[cur_index] + 1) % s1.Length;\\n            }\\n\\n            return count;\\n        }\\n```\n```\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n         HashSet<Character> h1 = new HashSet<>();\\n        HashSet<Character> h2 = new HashSet<>();\\n\\n        for (int i = 0; i < s1.length(); i++) {\\n            h1.add(s1.charAt(i));\\n        }\\n\\n        for (int i = 0; i < s2.length(); i++) {\\n            h2.add(s2.charAt(i));\\n        }\\n        \\n        int[] lens = new int[s1.length()];\\n\\n        Iterator<Character> it = h2.iterator();\\n        while (it.hasNext()) {\\n            if (!h1.contains(it.next())) return 0;\\n        }\\n        \\n        if (h1.size() == 1 && h2.size() == 1) {\\n            return ((n1 * s1.length()) / (n2 * s2.length()));\\n        }\\n        \\n        for (int i = 0; i < s1.length(); i++) {\\n            int j = 0;\\n            int c = 0;\\n\\n            while (j < s2.length()) {\\n                if (s2.charAt(j) == s1.charAt(((i + c) % s1.length())))\\n                    j++;\\n                c++;\\n            }\\n\\n            lens[i] = c - 1;\\n        }\\n\\n        int rep = 0;\\n        int total_length = s1.length() * n1;\\n\\n        int temp = 0;\\n        int k = 0;\\n        int cur = 0;\\n\\n        while (true) {\\n            k += lens[cur] + 1;\\n            if (k > total_length) break;\\n\\n            temp++;\\n            if (temp == n2) {\\n                rep++;\\n                temp = 0;\\n            }\\n            cur = (cur + lens[cur] + 1) % s1.length();\\n        }\\n\\n        return rep;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 140674,
                "title": "python-44ms-by-finding-loop-with-same-position",
                "content": "\\t\\n\\tclass Solution:\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        \"\"\"\\n        :type s1: str\\n        :type n1: int\\n        :type s2: str\\n        :type n2: int\\n        :rtype: int\\n        \"\"\"\\n        i1, i2 = 0, 0\\n        dic_ind = {}\\n        dic_ln = {}\\n        dic_ind[0] = 0\\n        dic_ln[0] = 0\\n        k = 0\\n        cnt = 0\\n        while k < n1:\\n            if i2 == len(s2):\\n                cnt += 1\\n                i2 = 0\\n            elif i1 == len(s1):\\n                k += 1\\n                i1 = 0\\n                dic_ln[k] = cnt\\n                if i2 not in dic_ind:\\n                    dic_ind[i2] = k\\n                else:\\n                    break\\n            else:\\n                if s1[i1] == s2[i2]:\\n                    i2 += 1\\n                i1 += 1\\n        \\n        if k == n1:\\n            return cnt // n2\\n        loop_cnt = dic_ln[k] - dic_ln[dic_ind[i2]] # get the count of s2 in the loop\\n        loop_range = k - dic_ind[i2] # get the range of the loop with same i2 position\\n        num_loop = (n1 - dic_ind[i2]) // loop_range # get the number of the loops starting the first i2 line\\n        ln_rest = (n1 - dic_ind[i2]) % loop_range # get the rest of the lines\\n        res_p = dic_ln[dic_ind[i2] + ln_rest] # combine the starting point with rest of the lines\\n        return (res_p + num_loop * loop_cnt) // n2\\n\\t",
                "solutionTags": [],
                "code": "class Solution:\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        \"\"\"\\n        :type s1: str\\n        :type n1: int\\n        :type s2: str\\n        :type n2: int\\n        :rtype: int\\n        \"\"\"\\n        i1, i2 = 0, 0\\n        dic_ind = {}",
                "codeTag": "Java"
            },
            {
                "id": 95400,
                "title": "9ms-java-hashmap-solution",
                "content": "The code uses a HashMap to record the remaining string after matching (the remaining string of previous match and addition of needed number of s1) for 1*s2, and the number of s1 needed. When a remaining string loop is found, the help function stops, and the HashMap records all the remaining string records. Afterwards, the solution devides the remaining string into 2 parts, one outside the loop, and the other part inside the loop. Calculate the total number of s1 needed for pre-loop and loop separately. Based on these info, calculate how many s2 can be obtained depending on s1's value.\\n```\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        //make sure [s1,n1] is longer than [s2,n2]\\n        if(s1.length()*n1<s2.length()*n2) return 0;\\n        //make sure s1 repetition can make s2\\n        int i_2=0;\\n        int rep=0;\\n        while(i_2<s2.length()&&rep<1){\\n            int pre_2=i_2;\\n            int pre_rep=rep;\\n            for(int i=0;i<s1.length();i++){\\n                if(s1.charAt(i)==s2.charAt(i_2)) {\\n                    i_2++;\\n                    if(i_2==s2.length()){\\n                        i_2=0;\\n                        rep++;\\n                    }\\n                }\\n                \\n            }\\n            if(pre_rep==rep&&pre_2==i_2) return 0;//the pre_2 element can't be matched by s1\\n        }\\n        List<String> order=new ArrayList<>();\\n        Map<String,Integer> rem=new HashMap<>();\\n        int[] loop=new int[2];\\n        //int rank=0;\\n        int index=0;\\n        help(s1,\"\",s2,rem,order,index,loop);\\n        \\n        int pre_sum=0;\\n        int loop_sum=0;\\n        for(int i=0;i<loop[0];i++){\\n            String temp=order.get(i);\\n            pre_sum+=rem.get(temp);\\n        }\\n        for(int i=loop[0];i<=loop[1];i++){\\n            String temp=order.get(i);\\n            loop_sum+=rem.get(temp);\\n        }\\n        int n_s2=0;\\n        \\n        if(n1<=pre_sum+loop_sum){\\n            //no loop at all\\n            for(int i=0;i<order.size();i++){\\n                n1-=rem.get(order.get(i));\\n                if(n1<0) break;\\n                n_s2++;\\n            }\\n        }\\n        else{\\n            n1-=pre_sum;\\n            n_s2+=loop[0];\\n            int loop_num=n1/loop_sum;\\n            n_s2+=loop_num*(loop[1]-loop[0]+1);\\n            n1-=loop_num*loop_sum;\\n            int i=loop[0];\\n            while(n1-rem.get(order.get(i))>=0){\\n                n1-=rem.get(order.get(i));\\n                i++;\\n                n_s2++;\\n            }\\n        }\\n        \\n        return n_s2/n2;\\n    }\\n    public void help(String s1,String pre_rem,String s2, Map<String,Integer> rem,List<String> order,int index,int[] loop){\\n        int i=0,j=0;\\n        int rep_s1=0;\\n        order.add(pre_rem);\\n        String curr=pre_rem;\\n        if(curr==null||curr.length()==0){\\n            curr=s1;\\n            rep_s1++;\\n        }\\n        while(j<s2.length()){\\n            if(curr.charAt(i)==s2.charAt(j)){\\n                j++;\\n            }\\n            i++;\\n            if(j<s2.length()&&i>=curr.length()){\\n                i=0;\\n                curr=s1;\\n                rep_s1++;\\n            }\\n            \\n        }\\n        String curr_rem=curr.substring(i,curr.length());\\n        rem.put(pre_rem,rep_s1);\\n        \\n        if(!rem.containsKey(curr_rem)){\\n            help(s1,curr_rem,s2,rem,order,index+1,loop);\\n        }\\n        else{\\n            for(int k=0;k<order.size();k++){\\n                if(order.get(k).equals(curr_rem)) loop[0]=k;\\n                if(order.get(k).equals(pre_rem)){\\n                    loop[1]=k;        \\n                    break;\\n                } \\n\\n            }\\n        }\\n        return;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        //make sure [s1,n1] is longer than [s2,n2]\\n        if(s1.length()*n1<s2.length()*n2) return 0;\\n        //make sure s1 repetition can make s2\\n        int i_2=0;\\n        int rep=0;\\n        while(i_2<s2.length()&&rep<1){\\n            int pre_2=i_2;\\n            int pre_rep=rep;\\n            for(int i=0;i<s1.length();i++){\\n                if(s1.charAt(i)==s2.charAt(i_2)) {\\n                    i_2++;\\n                    if(i_2==s2.length()){\\n                        i_2=0;\\n                        rep++;\\n                    }\\n                }\\n                \\n            }\\n            if(pre_rep==rep&&pre_2==i_2) return 0;//the pre_2 element can't be matched by s1\\n        }\\n        List<String> order=new ArrayList<>();\\n        Map<String,Integer> rem=new HashMap<>();\\n        int[] loop=new int[2];\\n        //int rank=0;\\n        int index=0;\\n        help(s1,\"\",s2,rem,order,index,loop);\\n        \\n        int pre_sum=0;\\n        int loop_sum=0;\\n        for(int i=0;i<loop[0];i++){\\n            String temp=order.get(i);\\n            pre_sum+=rem.get(temp);\\n        }\\n        for(int i=loop[0];i<=loop[1];i++){\\n            String temp=order.get(i);\\n            loop_sum+=rem.get(temp);\\n        }\\n        int n_s2=0;\\n        \\n        if(n1<=pre_sum+loop_sum){\\n            //no loop at all\\n            for(int i=0;i<order.size();i++){\\n                n1-=rem.get(order.get(i));\\n                if(n1<0) break;\\n                n_s2++;\\n            }\\n        }\\n        else{\\n            n1-=pre_sum;\\n            n_s2+=loop[0];\\n            int loop_num=n1/loop_sum;\\n            n_s2+=loop_num*(loop[1]-loop[0]+1);\\n            n1-=loop_num*loop_sum;\\n            int i=loop[0];\\n            while(n1-rem.get(order.get(i))>=0){\\n                n1-=rem.get(order.get(i));\\n                i++;\\n                n_s2++;\\n            }\\n        }\\n        \\n        return n_s2/n2;\\n    }\\n    public void help(String s1,String pre_rem,String s2, Map<String,Integer> rem,List<String> order,int index,int[] loop){\\n        int i=0,j=0;\\n        int rep_s1=0;\\n        order.add(pre_rem);\\n        String curr=pre_rem;\\n        if(curr==null||curr.length()==0){\\n            curr=s1;\\n            rep_s1++;\\n        }\\n        while(j<s2.length()){\\n            if(curr.charAt(i)==s2.charAt(j)){\\n                j++;\\n            }\\n            i++;\\n            if(j<s2.length()&&i>=curr.length()){\\n                i=0;\\n                curr=s1;\\n                rep_s1++;\\n            }\\n            \\n        }\\n        String curr_rem=curr.substring(i,curr.length());\\n        rem.put(pre_rem,rep_s1);\\n        \\n        if(!rem.containsKey(curr_rem)){\\n            help(s1,curr_rem,s2,rem,order,index+1,loop);\\n        }\\n        else{\\n            for(int k=0;k<order.size();k++){\\n                if(order.get(k).equals(curr_rem)) loop[0]=k;\\n                if(order.get(k).equals(pre_rem)){\\n                    loop[1]=k;        \\n                    break;\\n                } \\n\\n            }\\n        }\\n        return;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95404,
                "title": "share-my-time-limited-java-solution-but-have-no-idea-how-to-improve-it",
                "content": "```\\npublic class Solution {\\n    class MatchIndexLoop{\\n        int countLoop;\\n        int extraStep;\\n        MatchIndexLoop(int count_loop,int extra_step){\\n            countLoop=count_loop;\\n            extraStep=extra_step;\\n        }\\n    }\\n    private int count=0;\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if(originalCheck(s1,s2)==false){\\n            return 0;\\n        }\\n        \\n        int i=0;\\n        Map<Integer,MatchIndexLoop> map = new HashMap<>();\\n        \\n        while(i<n1*s1.length()){\\n             int index=i%s1.length();\\n             if(map.containsKey(index)){\\n                 count++;\\n                 MatchIndexLoop t=map.get(index);\\n                 i+=t.countLoop*s1.length()+t.extraStep;\\n             }else{\\n                 MatchIndexLoop t = findNextPos(map,s1,index,s2);\\n                 i+=t.countLoop*s1.length()+t.extraStep;\\n                 count++;\\n             }\\n            \\n            if(i>=n1*s1.length()){\\n                count--;\\n                break;\\n            }\\n            i++;\\n            \\n        }\\n        \\n        return count/n2; \\n    }\\n    \\n    public MatchIndexLoop findNextPos(Map<Integer,MatchIndexLoop> map,String str,int start_index,String target){\\n           int loop=0;\\n           String str2=str.substring(start_index)+str.substring(0,start_index);\\n        \\n           char[] strarray=str2.toCharArray();\\n           char[] target_array=target.toCharArray();\\n           \\n           int p=0;\\n           int i=0;\\n           for(;i<strarray.length;i++){\\n               if(target_array[p]==strarray[i]){\\n                   p++;\\n               }\\n               if(p==target_array.length){\\n                   break;\\n               }\\n               if(i+1==strarray.length){\\n                   loop++;\\n                   i=-1;\\n               }\\n           }\\n           MatchIndexLoop res = new MatchIndexLoop(loop,i);\\n           map.put(start_index,res);\\n           \\n           return  res;\\n    }\\n    \\n    public boolean originalCheck(String s1,String s2){\\n        char[] array1=s1.toCharArray();\\n        char[] array2=s2.toCharArray();\\n        \\n        boolean[] hash = new boolean[256];\\n        for(int i=0;i<array1.length;i++){\\n            hash[array1[i]]=true;\\n        }\\n        \\n        for(int i=0;i<array2.length;i++){\\n            if(hash[array2[i]]==false){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    class MatchIndexLoop{\\n        int countLoop;\\n        int extraStep;\\n        MatchIndexLoop(int count_loop,int extra_step){\\n            countLoop=count_loop;\\n            extraStep=extra_step;\\n        }\\n    }\\n    private int count=0;\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if(originalCheck(s1,s2)==false){\\n            return 0;\\n        }\\n        \\n        int i=0;\\n        Map<Integer,MatchIndexLoop> map = new HashMap<>();\\n        \\n        while(i<n1*s1.length()){\\n             int index=i%s1.length();\\n             if(map.containsKey(index)){\\n                 count++;\\n                 MatchIndexLoop t=map.get(index);\\n                 i+=t.countLoop*s1.length()+t.extraStep;\\n             }else{\\n                 MatchIndexLoop t = findNextPos(map,s1,index,s2);\\n                 i+=t.countLoop*s1.length()+t.extraStep;\\n                 count++;\\n             }\\n            \\n            if(i>=n1*s1.length()){\\n                count--;\\n                break;\\n            }\\n            i++;\\n            \\n        }\\n        \\n        return count/n2; \\n    }\\n    \\n    public MatchIndexLoop findNextPos(Map<Integer,MatchIndexLoop> map,String str,int start_index,String target){\\n           int loop=0;\\n           String str2=str.substring(start_index)+str.substring(0,start_index);\\n        \\n           char[] strarray=str2.toCharArray();\\n           char[] target_array=target.toCharArray();\\n           \\n           int p=0;\\n           int i=0;\\n           for(;i<strarray.length;i++){\\n               if(target_array[p]==strarray[i]){\\n                   p++;\\n               }\\n               if(p==target_array.length){\\n                   break;\\n               }\\n               if(i+1==strarray.length){\\n                   loop++;\\n                   i=-1;\\n               }\\n           }\\n           MatchIndexLoop res = new MatchIndexLoop(loop,i);\\n           map.put(start_index,res);\\n           \\n           return  res;\\n    }\\n    \\n    public boolean originalCheck(String s1,String s2){\\n        char[] array1=s1.toCharArray();\\n        char[] array2=s2.toCharArray();\\n        \\n        boolean[] hash = new boolean[256];\\n        for(int i=0;i<array1.length;i++){\\n            hash[array1[i]]=true;\\n        }\\n        \\n        for(int i=0;i<array2.length;i++){\\n            if(hash[array2[i]]==false){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95406,
                "title": "java-30-lines-and-faster-optimize-first-ranking-answer-by-add-a-little-but-make-it-from-1088ms-to-12ms",
                "content": "When i check some fast answer, they are so many codes.\\n\\nthe brute force code is little and easy to understand, i found some clues to avoid duplicate calculate.\\n\\nyou will check the if(count2!=precount2){} clauses is the code i add, the thought is when s1 is at the ending and j==prej means \"**after that,all the for-loop is the duplicate calculations.**\" \\n\\nso i use a direct while loop without char checking.\\n\\n```\\npublic class Solution {\\n   public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if(n1==0) return 0;\\n        char[] array1 = s1.toCharArray(), array2 = s2.toCharArray();\\n        long count1 = 0, count2 = 0,precount2=0,precount1=0;\\n        int i = 0, j = 0,prej=0;\\n       \\n        while (count1 < n1) {\\n            if (array1[i] == array2[j]) {\\n                j++;\\n                if (j == array2.length) {\\n                    j = 0;\\n                    count2++;\\n                }\\n            }\\n            i++;\\n            if (i == array1.length) {\\n                i = 0;\\n                count1++;\\n                if(count2!=precount2){\\n                    if(precount2==0){\\n                        prej = j;\\n                        precount2 = count2;\\n                        precount1 = count1;\\n                    }\\n                    else if(j==prej){\\n                        long diff2 = count2-precount2,diff1 = count1-precount1;\\n                        while(count1<n1){\\n                            count1+=diff1;\\n                            count2+=diff2;\\n                        }\\n                        break;\\n                    } \\n                }\\n            }\\n        }\\n        return (int) (count2*n1/count1/ n2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n   public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if(n1==0) return 0;\\n        char[] array1 = s1.toCharArray(), array2 = s2.toCharArray();\\n        long count1 = 0, count2 = 0,precount2=0,precount1=0;\\n        int i = 0, j = 0,prej=0;\\n       \\n        while (count1 < n1) {\\n            if (array1[i] == array2[j]) {\\n                j++;\\n                if (j == array2.length) {\\n                    j = 0;\\n                    count2++;\\n                }\\n            }\\n            i++;\\n            if (i == array1.length) {\\n                i = 0;\\n                count1++;\\n                if(count2!=precount2){\\n                    if(precount2==0){\\n                        prej = j;\\n                        precount2 = count2;\\n                        precount1 = count1;\\n                    }\\n                    else if(j==prej){\\n                        long diff2 = count2-precount2,diff1 = count1-precount1;\\n                        while(count1<n1){\\n                            count1+=diff1;\\n                            count2+=diff2;\\n                        }\\n                        break;\\n                    } \\n                }\\n            }\\n        }\\n        return (int) (count2*n1/count1/ n2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95409,
                "title": "java-brute-force-one-optimization-from-loop",
                "content": "Learned from https://discuss.leetcode.com/topic/71256/easy-understanding-java-solution-with-detailed-explanation-21ms. Basically we add a new ```s1```, we try to match once, and we get some remaining string. Then we add another new ```s1```, then we try to match again, then we get another remaining string. The key point is that the remaining string might repeat itself, hence a loop is formed. The loop is the key to speed up the brute force \"adding a ```s1```, match\" process.\\n\\n```\\npublic class Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if (s1 == null || s1.length() == 0 || n1 == 0 || s2 == null || s2.length() == 0 || n2 == 0\\n                || impossibleMatch(s1, s2)) {\\n            return 0;\\n        }\\n        int matched = 0;\\n        int currentPos = 0;\\n        String lastRemain = \"\";\\n        Map<String, MatchReport> reports = new HashMap<>();\\n        while ((currentPos + lastRemain.length()) / s1.length() < n1) {\\n            if (reports.containsKey(lastRemain)) {\\n                LoopReport loop = analyzeLoop(reports, lastRemain);\\n                int loops = (s1.length() * n1 - currentPos) / loop.passedChars;\\n                matched += loops * loop.matched;\\n                currentPos += loops * loop.passedChars;\\n                reports.clear();\\n            } else {\\n                MatchReport report = match(lastRemain + s1, s2);\\n                reports.put(lastRemain, report);\\n                matched += report.matched;\\n                currentPos += report.passedChars;\\n                lastRemain = report.remain;\\n            }\\n        }\\n        return matched / n2;\\n    }\\n\\n    private LoopReport analyzeLoop(Map<String, MatchReport> reports, String entrykey) {\\n        int looplen = 0;\\n        int matched = 0;\\n        String key = entrykey;\\n        do {\\n            MatchReport report = reports.get(key);\\n            looplen += report.passedChars;\\n            matched += report.matched;\\n            key = report.remain;\\n        } while (!key.equals(entrykey));\\n        return new LoopReport(matched, looplen);\\n    }\\n\\n    private MatchReport match(String str1, String str2) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        int matched = 0;\\n        int end = 0;\\n        while (p1 < str1.length()) {\\n            char ch1 = str1.charAt(p1);\\n            char ch2 = str2.charAt(p2);\\n            if (ch1 == ch2) {\\n                if (++p2 == str2.length()) {\\n                    p2 = 0;\\n                    matched++;\\n                    end = p1 + 1;\\n                }\\n            }\\n            p1++;\\n        }\\n        return new MatchReport(matched, str1.substring(end), end);\\n    }\\n\\n    private boolean impossibleMatch(String str1, String str2) {\\n        Set<Character> chars = new HashSet<>();\\n        for (int i = 0; i < str2.length(); i++) {\\n            chars.add(str2.charAt(i));\\n        }\\n        for (int i = 0; i < str1.length(); i++) {\\n            chars.remove(str1.charAt(i));\\n        }\\n        return chars.size() > 0;\\n    }\\n\\n    class MatchReport {\\n        int matched;\\n        String remain;\\n        int passedChars;\\n        MatchReport(int matched, String remain, int passedChars) {\\n            this.matched = matched;\\n            this.remain = remain;\\n            this.passedChars = passedChars;\\n        }\\n    }\\n\\n    class LoopReport {\\n        int matched;\\n        int passedChars;\\n        LoopReport(int matched, int passedChars) {\\n            this.matched = matched;\\n            this.passedChars = passedChars;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```s1```\n```s1```\n```s1```\n```\\npublic class Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if (s1 == null || s1.length() == 0 || n1 == 0 || s2 == null || s2.length() == 0 || n2 == 0\\n                || impossibleMatch(s1, s2)) {\\n            return 0;\\n        }\\n        int matched = 0;\\n        int currentPos = 0;\\n        String lastRemain = \"\";\\n        Map<String, MatchReport> reports = new HashMap<>();\\n        while ((currentPos + lastRemain.length()) / s1.length() < n1) {\\n            if (reports.containsKey(lastRemain)) {\\n                LoopReport loop = analyzeLoop(reports, lastRemain);\\n                int loops = (s1.length() * n1 - currentPos) / loop.passedChars;\\n                matched += loops * loop.matched;\\n                currentPos += loops * loop.passedChars;\\n                reports.clear();\\n            } else {\\n                MatchReport report = match(lastRemain + s1, s2);\\n                reports.put(lastRemain, report);\\n                matched += report.matched;\\n                currentPos += report.passedChars;\\n                lastRemain = report.remain;\\n            }\\n        }\\n        return matched / n2;\\n    }\\n\\n    private LoopReport analyzeLoop(Map<String, MatchReport> reports, String entrykey) {\\n        int looplen = 0;\\n        int matched = 0;\\n        String key = entrykey;\\n        do {\\n            MatchReport report = reports.get(key);\\n            looplen += report.passedChars;\\n            matched += report.matched;\\n            key = report.remain;\\n        } while (!key.equals(entrykey));\\n        return new LoopReport(matched, looplen);\\n    }\\n\\n    private MatchReport match(String str1, String str2) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        int matched = 0;\\n        int end = 0;\\n        while (p1 < str1.length()) {\\n            char ch1 = str1.charAt(p1);\\n            char ch2 = str2.charAt(p2);\\n            if (ch1 == ch2) {\\n                if (++p2 == str2.length()) {\\n                    p2 = 0;\\n                    matched++;\\n                    end = p1 + 1;\\n                }\\n            }\\n            p1++;\\n        }\\n        return new MatchReport(matched, str1.substring(end), end);\\n    }\\n\\n    private boolean impossibleMatch(String str1, String str2) {\\n        Set<Character> chars = new HashSet<>();\\n        for (int i = 0; i < str2.length(); i++) {\\n            chars.add(str2.charAt(i));\\n        }\\n        for (int i = 0; i < str1.length(); i++) {\\n            chars.remove(str1.charAt(i));\\n        }\\n        return chars.size() > 0;\\n    }\\n\\n    class MatchReport {\\n        int matched;\\n        String remain;\\n        int passedChars;\\n        MatchReport(int matched, String remain, int passedChars) {\\n            this.matched = matched;\\n            this.remain = remain;\\n            this.passedChars = passedChars;\\n        }\\n    }\\n\\n    class LoopReport {\\n        int matched;\\n        int passedChars;\\n        LoopReport(int matched, int passedChars) {\\n            this.matched = matched;\\n            this.passedChars = passedChars;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95410,
                "title": "a-genarally-faster-than-o-str1-length-str2-length-solution",
                "content": "My code's run time is O(kL2logL1), where K is the rounds for s1 and s2' matching pattern to reoccur. For example:\\nS1:ababab\\nS2:bab\\nK = 3: because ababab|ababab contains 3 bab, after 3 repetitions of bab, the matching pattern reoccur.\\n\\nSo in average case, the code's run time is faster than O(l1*l2) But in a worst case, it can be as worse as O(L1 * L2 * lgL1).\\nOne example of the worst case is\\uff1a\\nS1:a....a (100 a's)\\nS2:a....a(99 a's)\\nK = 100: because S2 needs to repeat 100 times before the matching pattern reoccurs.\\n```\\nclass Solution {\\n    vector<int> charmap [256];\\n    void buildmap(const string & s1)\\n    {\\n        for (int i = 0; i < s1.size(); ++i)\\n            charmap[s1[i]].push_back(i);\\n    }\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        buildmap(s1);\\n        int rep = 0,  last_pos = -1, mult = 0, start_pos = -1, first_start_pos = -2, last_last_pos = -2, last_rep = 0;\\n        vector<int> reps = {0};\\n        while (true)\\n        {\\n            for (int i = 0; i < s2.size();)\\n            {\\n                auto & v = charmap[s2[i]];\\n                if (v.empty())\\n                    return 0;\\n                auto iter = upper_bound(v.begin(), v.end(), last_pos);\\n                if (iter == v.end())\\n                {\\n                    rep ++;\\n                    reps.push_back(mult);\\n                    last_pos = -1;\\n                    continue;   \\n                }\\n                last_pos = *iter;\\n                ++ i;\\n            }\\n            start_pos = last_pos + 1;\\n            for (int i = s2.size() - 1; i >= 0;)\\n            {\\n                auto & v = charmap[s2[i]];\\n                auto iter = upper_bound(v.rbegin(), v.rend(), start_pos, std::greater<int>());\\n                if (iter == v.rend())\\n                {\\n                    start_pos = s1.size();\\n                    continue;   \\n                }\\n                start_pos = *iter;\\n                -- i;\\n            }\\n            mult ++;\\n            if (start_pos == first_start_pos)\\n            {\\n                mult --;\\n                break;\\n            }\\n            if (first_start_pos == -2)\\n                first_start_pos = start_pos;\\n            last_last_pos = last_pos;\\n            last_rep = rep;\\n        }\\n        last_rep ++;\\n        if (first_start_pos <= last_last_pos)\\n            return ((n1 / last_rep) * mult + reps[n1 % last_rep])/n2;\\n        return ((n1 - 1) / (last_rep - 1) * mult + reps[(n1 - 1) % (last_rep - 1) + 1])/n2;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> charmap [256];\\n    void buildmap(const string & s1)\\n    {\\n        for (int i = 0; i < s1.size(); ++i)\\n            charmap[s1[i]].push_back(i);\\n    }\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        buildmap(s1);\\n        int rep = 0,  last_pos = -1, mult = 0, start_pos = -1, first_start_pos = -2, last_last_pos = -2, last_rep = 0;\\n        vector<int> reps = {0};\\n        while (true)\\n        {\\n            for (int i = 0; i < s2.size();)\\n            {\\n                auto & v = charmap[s2[i]];\\n                if (v.empty())\\n                    return 0;\\n                auto iter = upper_bound(v.begin(), v.end(), last_pos);\\n                if (iter == v.end())\\n                {\\n                    rep ++;\\n                    reps.push_back(mult);\\n                    last_pos = -1;\\n                    continue;   \\n                }\\n                last_pos = *iter;\\n                ++ i;\\n            }\\n            start_pos = last_pos + 1;\\n            for (int i = s2.size() - 1; i >= 0;)\\n            {\\n                auto & v = charmap[s2[i]];\\n                auto iter = upper_bound(v.rbegin(), v.rend(), start_pos, std::greater<int>());\\n                if (iter == v.rend())\\n                {\\n                    start_pos = s1.size();\\n                    continue;   \\n                }\\n                start_pos = *iter;\\n                -- i;\\n            }\\n            mult ++;\\n            if (start_pos == first_start_pos)\\n            {\\n                mult --;\\n                break;\\n            }\\n            if (first_start_pos == -2)\\n                first_start_pos = start_pos;\\n            last_last_pos = last_pos;\\n            last_rep = rep;\\n        }\\n        last_rep ++;\\n        if (first_start_pos <= last_last_pos)\\n            return ((n1 / last_rep) * mult + reps[n1 % last_rep])/n2;\\n        return ((n1 - 1) / (last_rep - 1) * mult + reps[(n1 - 1) % (last_rep - 1) + 1])/n2;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95412,
                "title": "c-easy-understand-solution",
                "content": "\\nIdea is  find index (both in s1 and s2) which start repeating before index in s1 going to the end..\\n\\nsuch as, assume n1 ,n2 is very large, for s1 = \"abca\" , s2 = \"ac\"\\ni = [0, 2, 3,     2(6), 3(7),  2(10)]  --> 6 is the real index, 2 is 6 % 4 == 2;\\nj = [0, 1, 0(2),  1(3), 0(4),  1(5) ] --> 2 is the real index, 0 is 2%2 == 0;\\n\\nso for index i , 2->6->10 is repeat, for index j, 1->3->5 is repeat follow i.\\n\\nso from i=6, every 2 step increase is repeat. so it can ease calculate instead of increase one by one\\n\\n```\\npublic class Solution {\\n    public int GetMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int len1 = s1.Length;\\n        int len2 = s2.Length;\\n        var dp = new string[len1,len2];\\n        int i = 0;\\n        int j = 0;\\n        bool find = false; \\n        while(i/len1 < n1){\\n            if(s1[i%len1] == s2[j%len2]){\\n                if(!find){\\n                    if(dp[i%len1,j%len2] == null){\\n                        dp[i%len1,j%len2] = i+\",\"+j;\\n                    }else{\\n                        find = true;\\n                        var arr = dp[i%len1,j%len2].Split(new char[]{','});\\n                        \\n                        int ii = int.Parse(arr[0]);\\n                        int jj = int.Parse(arr[1]);\\n                        //Console.WriteLine(ii+\",\"+jj+\",\"+i+\",\"+j);\\n                        int max = len1*n1;\\n                        int k = (max-i)/(i-ii);\\n                        //Console.WriteLine(k);\\n                        j = k*(j-jj)+j;\\n                        i = k*(i-ii)+i;\\n                    }\\n                }\\n                //Console.WriteLine(i+\",\"+j);\\n                i++;\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        \\n        return j/(len2*n2) -(len2*n2 == 1 ? 1 : 0);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int GetMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int len1 = s1.Length;\\n        int len2 = s2.Length;\\n        var dp = new string[len1,len2];\\n        int i = 0;\\n        int j = 0;\\n        bool find = false; \\n        while(i/len1 < n1){\\n            if(s1[i%len1] == s2[j%len2]){\\n                if(!find){\\n                    if(dp[i%len1,j%len2] == null){\\n                        dp[i%len1,j%len2] = i+\",\"+j;\\n                    }else{\\n                        find = true;\\n                        var arr = dp[i%len1,j%len2].Split(new char[]{','});\\n                        \\n                        int ii = int.Parse(arr[0]);\\n                        int jj = int.Parse(arr[1]);\\n                        //Console.WriteLine(ii+\",\"+jj+\",\"+i+\",\"+j);\\n                        int max = len1*n1;\\n                        int k = (max-i)/(i-ii);\\n                        //Console.WriteLine(k);\\n                        j = k*(j-jj)+j;\\n                        i = k*(i-ii)+i;\\n                    }\\n                }\\n                //Console.WriteLine(i+\",\"+j);\\n                i++;\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        \\n        return j/(len2*n2) -(len2*n2 == 1 ? 1 : 0);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95413,
                "title": "24ms-java-clean-solution",
                "content": "    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        //get count of s2 in s1*n1\\n        int count = getCount(s1, s2, n1);\\n        return count/n2;\\n    }\\n    \\n    private int getCount(String s1, String s2, int n) {\\n        Map<String, Integer> map = new HashMap<String, Integer>();\\n        //store cumulative count of s2\\n        List<Integer> sums = new ArrayList<Integer>();\\n        String s = s1;\\n        int sum = 0;\\n        sums.add(sum);\\n        int i = 0;\\n        while (i < n) {\\n            //cycle caught, break\\n            if (map.containsKey(s))\\n                break;\\n            //count s2 in s, add sum and return suffix index\\n            int suffixIndex = countAndUpdateSums(sums, sum, s, s2);\\n            sum = sums.get(sums.size()-1);\\n            map.put(s, sums.size()-1);\\n            s = s.substring(suffixIndex) + s1;\\n            i++;\\n        }\\n        int result = sum;\\n        if (i < n) {\\n            int cycleCount = sum-sums.get(map.get(s)-1);\\n            int cycleLen = map.size()-map.get(s)+1;\\n            int cycleNum = (n-i)/cycleLen;\\n            int postCycleLen = (n-i)%cycleLen;\\n            int postCycleCount = sums.get(map.get(s)+postCycleLen-1)-sums.get(map.get(s)-1);\\n            result += cycleCount*cycleNum+postCycleCount;\\n        }\\n        return result;\\n    }\\n    \\n    private int countAndUpdateSums(List<Integer> sums, int sum, String s1, String s2) {\\n        int i = 0;\\n        int j = 0;\\n        int last = 0;\\n        int count = 0;\\n        while (i < s1.length()) {\\n            if (s1.charAt(i) == s2.charAt(j))\\n                j++;\\n            i++;\\n            if (j == s2.length()) {\\n                last = i;\\n                count++;\\n                j = 0;\\n            }\\n        }\\n        sum += count;\\n        sums.add(sum);\\n        return last;\\n    }",
                "solutionTags": [],
                "code": "    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        //get count of s2 in s1*n1\\n        int count = getCount(s1, s2, n1);\\n        return count/n2;\\n    }\\n    \\n    private int getCount(String s1, String s2, int n) {\\n        Map<String, Integer> map = new HashMap<String, Integer>();\\n        //store cumulative count of s2\\n        List<Integer> sums = new ArrayList<Integer>();\\n        String s = s1;\\n        int sum = 0;\\n        sums.add(sum);\\n        int i = 0;\\n        while (i < n) {\\n            //cycle caught, break\\n            if (map.containsKey(s))\\n                break;\\n            //count s2 in s, add sum and return suffix index\\n            int suffixIndex = countAndUpdateSums(sums, sum, s, s2);\\n            sum = sums.get(sums.size()-1);\\n            map.put(s, sums.size()-1);\\n            s = s.substring(suffixIndex) + s1;\\n            i++;\\n        }\\n        int result = sum;\\n        if (i < n) {\\n            int cycleCount = sum-sums.get(map.get(s)-1);\\n            int cycleLen = map.size()-map.get(s)+1;\\n            int cycleNum = (n-i)/cycleLen;\\n            int postCycleLen = (n-i)%cycleLen;\\n            int postCycleCount = sums.get(map.get(s)+postCycleLen-1)-sums.get(map.get(s)-1);\\n            result += cycleCount*cycleNum+postCycleCount;\\n        }\\n        return result;\\n    }\\n    \\n    private int countAndUpdateSums(List<Integer> sums, int sum, String s1, String s2) {\\n        int i = 0;\\n        int j = 0;\\n        int last = 0;\\n        int count = 0;\\n        while (i < s1.length()) {\\n            if (s1.charAt(i) == s2.charAt(j))\\n                j++;\\n            i++;\\n            if (j == s2.length()) {\\n                last = i;\\n                count++;\\n                j = 0;\\n            }\\n        }\\n        sum += count;\\n        sums.add(sum);\\n        return last;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 95415,
                "title": "some-simple-solutions",
                "content": "1. O(n1s1) brute force. I am unsure about the early termination condition. I appreciate it if someone can comment on it or give a counter example.\\n```\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        if(!n2) return 0;\\n        int i = 0, j = 0, ct1 = 0, ct2 = 0, sz1 = s1.size(), sz2 = s2.size();\\n        while(ct1<n1) {\\n            if(s1[i++]==s2[j]) j++;\\n            if(i == sz1) {\\n                ct1++;\\n                i=0;\\n            }\\n            if(j == sz2) {\\n                ct2++;\\n                j=0;\\n            }\\n            if(!i&&!j) return (float)n1/ct1*ct2/n2; // is it correct?\\n        }\\n        return ct2/n2;\\n    }\\n```\\n2. O(n1*s1+s2s1^2) During brute force, the goal is count how many s2 can be obtained from S1. Assume the first s2 can be obtained from S1[0..i], the second s2 is checked starting from i+1. In brute force, time is wasted on scanning S1 to find the end point i for each s2. Since S1=[s1,n1], starting from the same index of s1, the length needed to obtain s2 is the same. So we can precompute the lengths. This runs much faster but worst case is same as brute force.  \\n```\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int sz1=s1.size();\\n        vector<int> len(sz1); \\n        for(int i=0;i<sz1;i++){\\n            int j=i, k=0, p=j;\\n            while(k<s2.size())\\n                if(s2[k]==s1[j++%sz1]) {\\n                    k++;\\n                    p = j;\\n                } else if (j-p==sz1) return 0;\\n            len[i] = j-i;\\n        }\\n        int i=0, ct = 0;\\n        while((i+=len[i%sz1])<=n1*sz1) {\\n            ct++;\\n            if(i%sz1 ==0 && n1*sz1%i ==0) return n1*sz1/i*ct/n2;\\n        }\\n        return ct/n2;\\n    }\\n```\\n3. O(s1*s2+n1) In #2 we are matching each s2 to S1. If we match s1 to S2, it will be much faster.The great idea is from [@sanxi](https://discuss.leetcode.com/topic/78575/simple-c-code-16-lines-but-slow-179ms).\\n```\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int sz2=s2.size();\\n        vector<int> len(sz2); //dp[i]-assume s2 is repeating, starting at idx i of s2, the length that can be obtained from s1.\\n        for(int i=0;i<sz2;i++){\\n            int j=i;\\n            for(char c : s1) if(c==s2[j%sz2]) j++;\\n            if(j==i) return 0; //s1 does not have s2[i]\\n            len[i] = j-i;\\n        }\\n        int idx=0;\\n        while(n1--) idx+=len[idx%sz2];\\n        return idx/sz2/n2;\\n    }\\n```\\n4. There are some O(s1s2) solutions, too difficult for me to understand....",
                "solutionTags": [],
                "code": "```\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        if(!n2) return 0;\\n        int i = 0, j = 0, ct1 = 0, ct2 = 0, sz1 = s1.size(), sz2 = s2.size();\\n        while(ct1<n1) {\\n            if(s1[i++]==s2[j]) j++;\\n            if(i == sz1) {\\n                ct1++;\\n                i=0;\\n            }\\n            if(j == sz2) {\\n                ct2++;\\n                j=0;\\n            }\\n            if(!i&&!j) return (float)n1/ct1*ct2/n2; // is it correct?\\n        }\\n        return ct2/n2;\\n    }\\n```\n```\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int sz1=s1.size();\\n        vector<int> len(sz1); \\n        for(int i=0;i<sz1;i++){\\n            int j=i, k=0, p=j;\\n            while(k<s2.size())\\n                if(s2[k]==s1[j++%sz1]) {\\n                    k++;\\n                    p = j;\\n                } else if (j-p==sz1) return 0;\\n            len[i] = j-i;\\n        }\\n        int i=0, ct = 0;\\n        while((i+=len[i%sz1])<=n1*sz1) {\\n            ct++;\\n            if(i%sz1 ==0 && n1*sz1%i ==0) return n1*sz1/i*ct/n2;\\n        }\\n        return ct/n2;\\n    }\\n```\n```\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int sz2=s2.size();\\n        vector<int> len(sz2); //dp[i]-assume s2 is repeating, starting at idx i of s2, the length that can be obtained from s1.\\n        for(int i=0;i<sz2;i++){\\n            int j=i;\\n            for(char c : s1) if(c==s2[j%sz2]) j++;\\n            if(j==i) return 0; //s1 does not have s2[i]\\n            len[i] = j-i;\\n        }\\n        int idx=0;\\n        while(n1--) idx+=len[idx%sz2];\\n        return idx/sz2/n2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95417,
                "title": "572-ms-accepted-c-solutions-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        if (n1 == 0 || n2 == 0) return 0;\\n        int len1 = s1.size() * n1;\\n        int res = 0, turn = 0;\\n        int i = 0, j = 0;\\n        unordered_map<int, int> mymap;\\n        while (turn < n1) {\\n        \\twhile (i < s1.size() && s2[j] != s1[i]) ++i;\\n        \\tif (i == s1.size()) {\\n        \\t\\tif (++turn == n1 || j == 0) break;\\n        \\t\\ti = 0;\\n        \\t} else {\\n        \\t\\t++i;\\n        \\t\\tif (++j == s2.size()) {\\n        \\t\\t    ++res;\\n        \\t\\t    j = 0;\\n        \\t    }\\n        \\t}\\n        }\\n        return (res * (n1 / turn) + mymap[n1 % turn]) / n2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        if (n1 == 0 || n2 == 0) return 0;\\n        int len1 = s1.size() * n1;\\n        int res = 0, turn = 0;\\n        int i = 0, j = 0;\\n        unordered_map<int, int> mymap;\\n        while (turn < n1) {\\n        \\twhile (i < s1.size() && s2[j] != s1[i]) ++i;\\n        \\tif (i == s1.size()) {\\n        \\t\\tif (++turn == n1 || j == 0) break;\\n        \\t\\ti = 0;\\n        \\t} else {\\n        \\t\\t++i;\\n        \\t\\tif (++j == s2.size()) {\\n        \\t\\t    ++res;\\n        \\t\\t    j = 0;\\n        \\t    }\\n        \\t}\\n        }\\n        return (res * (n1 / turn) + mymap[n1 % turn]) / n2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95419,
                "title": "java-solution-with-explanation-7s-please-add-more-test-cases",
                "content": "My initial solution got accepted with 6s but there is missing test cases to catch the flaw of this solution.  This solution cannot pass case like s1=\"aaa\" n1=20  s2=\"aaaaa\" n2=1\\n```\\n   public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int m1 = 1, m2 = 0, a=0, b=0, i = 0, j=0;\\n        int remMark = 0; //used to detect loop \\n        while(m1<=n1) {\\n            i = 0;\\n            int remIndex = 0;\\n            boolean foundMatch = false;\\n            while(i<s1.length()) {\\n                if(s2.charAt(j)==s1.charAt(i)) {\\n                    foundMatch=true;\\n                    if(++j==s2.length()) {\\n                        remIndex = i;\\n                        m2++;\\n                        j=0;\\n                    }\\n                }\\n                i++;\\n            }\\n            if(!foundMatch || (m2>0 && remMark==remIndex)) break;\\n            else if(a==0 && m2>0) {\\n                remMark = remIndex;\\n                a=m2;\\n                b=m1;\\n            }\\n            m1++;\\n        }\\n        return ((m2-a)*(n1-b)/(m1-b)+a)/n2;\\n   }\\n```\\nThe missing part is the calculation of incomplete loop. The following is the fixed solution:\\n```\\n   public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int m1 = 1, m2 = 0, a=0, b=0,j=0, next = 0;\\n        int[] loop = new int[s2.length()]; //every s1 will at least move one index forward in s2, so loop size at most s2.length()\\n        for(;m1<=n1;m1++) {\\n            for(int i=0; i<s1.length(); i++) {//two pointers to iterate s1 and s2. Move both if they are equal other wise advance i only\\n                if(s2.charAt(j)==s1.charAt(i)) {\\n                    if(++j==s2.length()) {\\n                        m2++;\\n                        j=0;\\n                    }\\n                }\\n            }\\n            if(j==next) break; //Every time we finish s1, we check if we found a loop by checking the next  index in s2\\n            else if(a==0 && m2>0) {\\n                next = j; //the point entering loop\\n                a=m1;\\n                b=m2;\\n            }\\n            if(m2>0) loop[m1-a] = m2-b;\\n        }\\n        return ((n1-a)/(m1-a)*(m2-b)+b + loop[(m2-b)*(n1-a)%(m1-a)])/n2; //before entering cycle we used s1 a times and got b number of s2\\n   }\\n```\\nThe key idea is to find a repeative pattern or loop such that every x numbers of s1 can get y numbers of s2. Here we use the next index of s2 to detect loop. Another key point is before entering loop we need to find out how many numbers of s1 we need and how many numbers of s2 we can get. In the code we use b, and a to denote that.\\nFor instance s1 = \"aaa\", n1=20, s2 = \"aaaaa\", n2 = 1 after -> m1=7 m2=4 a=2 b=1, loop [0,0,1,2,2], every 5 (7-2) s1 gets 3 (4-1) s2\\npart1: s1 2 s2 1, part2: 18/5 * 3 = 9, part3: 18%5 = 3 -> s2  3\\nresults: (1+9+2)/1 = 12\\n\\n![0_1483672071760_leetcountrepetition.JPG](/uploads/files/1483672066976-leetcountrepetition.jpg)",
                "solutionTags": [],
                "code": "```\\n   public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int m1 = 1, m2 = 0, a=0, b=0, i = 0, j=0;\\n        int remMark = 0; //used to detect loop \\n        while(m1<=n1) {\\n            i = 0;\\n            int remIndex = 0;\\n            boolean foundMatch = false;\\n            while(i<s1.length()) {\\n                if(s2.charAt(j)==s1.charAt(i)) {\\n                    foundMatch=true;\\n                    if(++j==s2.length()) {\\n                        remIndex = i;\\n                        m2++;\\n                        j=0;\\n                    }\\n                }\\n                i++;\\n            }\\n            if(!foundMatch || (m2>0 && remMark==remIndex)) break;\\n            else if(a==0 && m2>0) {\\n                remMark = remIndex;\\n                a=m2;\\n                b=m1;\\n            }\\n            m1++;\\n        }\\n        return ((m2-a)*(n1-b)/(m1-b)+a)/n2;\\n   }\\n```\n```\\n   public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int m1 = 1, m2 = 0, a=0, b=0,j=0, next = 0;\\n        int[] loop = new int[s2.length()]; //every s1 will at least move one index forward in s2, so loop size at most s2.length()\\n        for(;m1<=n1;m1++) {\\n            for(int i=0; i<s1.length(); i++) {//two pointers to iterate s1 and s2. Move both if they are equal other wise advance i only\\n                if(s2.charAt(j)==s1.charAt(i)) {\\n                    if(++j==s2.length()) {\\n                        m2++;\\n                        j=0;\\n                    }\\n                }\\n            }\\n            if(j==next) break; //Every time we finish s1, we check if we found a loop by checking the next  index in s2\\n            else if(a==0 && m2>0) {\\n                next = j; //the point entering loop\\n                a=m1;\\n                b=m2;\\n            }\\n            if(m2>0) loop[m1-a] = m2-b;\\n        }\\n        return ((n1-a)/(m1-a)*(m2-b)+b + loop[(m2-b)*(n1-a)%(m1-a)])/n2; //before entering cycle we used s1 a times and got b number of s2\\n   }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95414,
                "title": "nice-o-len-s1-len-s2-worst-case",
                "content": "The trick is to find minimum number - n1count such that [s2,n2count] matches **exactly** into [s1, n1count]. Exactly means that next character to be matched in both strings is the first character. \\n\\n\\n\\npublic class Solution {\\n\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if (s1.length() == 0 || s2.length() == 0 || n2 == 0 || n1 == 0) return 0;\\n        int n2count = 0, n1count = 0;\\n        int i = 0;\\n        int j = 0;\\n        while (n1count < n1) {\\n            if (s1.charAt(i) == s2.charAt(j)) j++;\\n            i++;\\n            \\n            if (i == s1.length()) {\\n                i = 0;\\n                n1count++;\\n            }\\n            if (j == s2.length()) {\\n                j = 0;\\n                n2count++;\\n            }\\n            if (i == 0 && j == 0) break;\\n        }\\n        return (int)((long)n1*n2count/n1count/n2);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if (s1.length() == 0 || s2.length() == 0 || n2 == 0 || n1 == 0) return 0;\\n        int n2count = 0, n1count = 0;\\n        int i = 0;\\n        int j = 0;\\n        while (n1count < n1) {\\n            if (s1.charAt(i) == s2.charAt(j)) j++;\\n            i++;\\n            \\n            if (i == s1.length()) {\\n                i = 0;\\n                n1count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 95423,
                "title": "ruby-solution",
                "content": "An related but slightly easier problem to the original one is finding the maximal # of `s2` that can be obtained from `S1`. \\n\\nFor example, assume `n2 = 3` and we can get 7 `s2` from `S1`, the final answer will be `7/3 = 2`\\n\\nI start w/ a brute force algorithm by having two pointer `p1` and `p2`, which iterate through `S1` and `S2` respectively. This part is pretty straightforward.\\n\\nThe brute force algorithm has some room to improve when the `n1` is large. After some iterations, we may have enough information to calculate the answer w/o continuing.\\n\\nFor example, assume the following input\\n- s1 = \"aaaaaab\"\\n- n1 = 1,000,000\\n- s2 = \"bc\"\\n\\nAfter the second iteration, we know we won't be able to find a match.\\n\\nFor those cases in which there are an answer, it's very like that there will be recurring pattern. \\n\\nFor example, assume the following input\\n- s1 = \"ababc\"\\n- n1 = 1,000,000\\n- s2 = \"ba\"\\n\\n```\\ndef get_max_repetitions(s1, n1, s2, n2)\\n  count = get_max_repetitions_helper(s1, n1, s2)\\n  count / n2\\nend\\n\\ndef get_max_repetitions_helper(s1, n1, s2)\\n  p2 = 0\\n  positions = []\\n\\n  (0...s1.size*n1).each do |p1|\\n      # Give up when no char when can be matched w/ a full cyle\\n      cycle = p1 / s1.size\\n      return 0 if positions.size < cycle    \\n\\n      c1, c2 = s1[p1 % s1.size], s2[p2 % s2.size]\\n      if c1 == c2\\n        positions[p2] = p1\\n        # puts positions.each_with_index.map { |k,i| \"(#{i}, #{k})\" }.join(\", \")\\n\\n        (p2-s2.size).step(0, -s2.size) do |i|\\n          # Found pair (i, positions[i]) and (p2, positions[p2])\\n          # where (p2-i) % s2.size == 0 and\\n          #       (positions[p2] - positions[i]) % s1.size == 0\\n          if (p1 - positions[i]) % s1.size == 0\\n            \\n            parts = [\\n              (positions.size-1),\\n              (s1.size*n1-p1) / (positions[p2] - positions[i]) * (p2-i),\\n              # How many extra s2 char can we match if\\n              # if move p1 from [positions[i], positions[i+remain])\\n              positions[i..-1].select do |k|\\n                #   [ -------- remaining step for s1 -----------   ]\\n                k <= (s1.size*n1-p1) % (positions[p2] - positions[i]) + positions[i] - 1\\n              end.size\\n            ]\\n\\n            num_of_chars = parts.reduce(&:+)\\n            return num_of_chars / s2.size\\n          end\\n          i -= s2.size\\n        end\\n        \\n        p2 += 1\\n      end\\n  end\\n\\n  positions.size / s2.size\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef get_max_repetitions(s1, n1, s2, n2)\\n  count = get_max_repetitions_helper(s1, n1, s2)\\n  count / n2\\nend\\n\\ndef get_max_repetitions_helper(s1, n1, s2)\\n  p2 = 0\\n  positions = []\\n\\n  (0...s1.size*n1).each do |p1|\\n      # Give up when no char when can be matched w/ a full cyle\\n      cycle = p1 / s1.size\\n      return 0 if positions.size < cycle    \\n\\n      c1, c2 = s1[p1 % s1.size], s2[p2 % s2.size]\\n      if c1 == c2\\n        positions[p2] = p1\\n        # puts positions.each_with_index.map { |k,i| \"(#{i}, #{k})\" }.join(\", \")\\n\\n        (p2-s2.size).step(0, -s2.size) do |i|\\n          # Found pair (i, positions[i]) and (p2, positions[p2])\\n          # where (p2-i) % s2.size == 0 and\\n          #       (positions[p2] - positions[i]) % s1.size == 0\\n          if (p1 - positions[i]) % s1.size == 0\\n            \\n            parts = [\\n              (positions.size-1),\\n              (s1.size*n1-p1) / (positions[p2] - positions[i]) * (p2-i),\\n              # How many extra s2 char can we match if\\n              # if move p1 from [positions[i], positions[i+remain])\\n              positions[i..-1].select do |k|\\n                #   [ -------- remaining step for s1 -----------   ]\\n                k <= (s1.size*n1-p1) % (positions[p2] - positions[i]) + positions[i] - 1\\n              end.size\\n            ]\\n\\n            num_of_chars = parts.reduce(&:+)\\n            return num_of_chars / s2.size\\n          end\\n          i -= s2.size\\n        end\\n        \\n        p2 += 1\\n      end\\n  end\\n\\n  positions.size / s2.size\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 95425,
                "title": "c-with-string-s1-pre-process-but-got-tle",
                "content": "Re: [Ugly Java brute force solution](but accepted. 1088ms.)\\n\\nSimilar to @shawngao 's Java brute force solution, I pre-processed string `s1` to \"cache\" for each index `j` and char `c`, pre-calculate `pos[j][c-'a']` as the index of first occurrence of char `c` stating from position `j`. This should help for two-pointer scanning, but I got TLE for test case with both `s1`, `s2` as `\"aaaaaaaa...\"` and `n1 = n2 = 1000000`.\\n\\nAfter reading other posts, I see some coders also got TLE for C++ only (?). I am wondering whether my following C++ code indeed has defects.\\n```\\n    // pos[j][c]: index of first occurrence in string starting from index j for char c\\n    vector<vector<int>> pos;\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n      int counter = -1, ls1 = s1.size(), is = 0, cnt = 0; buildPos(s1, ls1); \\n      while (++counter >= 0) {\\n          for (char c:s2) {\\n            if (is == ls1) { is = 0; if ((++cnt) >= n1) return counter/n2; }\\n            int next = pos[is][c-'a'];\\n            if (next == ls1) { \\n                if ((next = pos[0][c-'a']) == ls1) return counter/n2; \\n                if ((++cnt) >= n1) return counter/n2; \\n            }\\n            is = next + 1;\\n          }\\n      }\\n      return -1; // should never comes here\\n    }\\n    // pre-process string s to find index of first occurrence starting from index j for char c\\n    void buildPos(string& s, int npos) {\\n      pos = vector<vector<int>>(s.size(), vector<int>(26, npos));\\n      vector<vector<int>> idx(26); int c;\\n      for (int i = 0; i < s.size(); ++i) {\\n        int last = idx[c = (s[i]-'a')].empty()? -1 : idx[c].back();\\n        idx[c].push_back(i);\\n        for (int j = last+1; j <= i; ++j) pos[j][c] = i;\\n      }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    // pos[j][c]: index of first occurrence in string starting from index j for char c\\n    vector<vector<int>> pos;\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n      int counter = -1, ls1 = s1.size(), is = 0, cnt = 0; buildPos(s1, ls1); \\n      while (++counter >= 0) {\\n          for (char c:s2) {\\n            if (is == ls1) { is = 0; if ((++cnt) >= n1) return counter/n2; }\\n            int next = pos[is][c-'a'];\\n            if (next == ls1) { \\n                if ((next = pos[0][c-'a']) == ls1) return counter/n2; \\n                if ((++cnt) >= n1) return counter/n2; \\n            }\\n            is = next + 1;\\n          }\\n      }\\n      return -1; // should never comes here\\n    }\\n    // pre-process string s to find index of first occurrence starting from index j for char c\\n    void buildPos(string& s, int npos) {\\n      pos = vector<vector<int>>(s.size(), vector<int>(26, npos));\\n      vector<vector<int>> idx(26); int c;\\n      for (int i = 0; i < s.size(); ++i) {\\n        int last = idx[c = (s[i]-'a')].empty()? -1 : idx[c].back();\\n        idx[c].push_back(i);\\n        for (int j = last+1; j <= i; ++j) pos[j][c] = i;\\n      }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95427,
                "title": "python-solution-by-finding-cycle",
                "content": "We match string `s1*n1` and multiple `s2` in a greedy way, trying to find a cycle. Here a cycle means that when we match `s2` `k` times and `k + cycle_length` times, the last characters in both cases match to the characters of the same index in `s1`. \\nThen `s1*n1` can be decomposed into three parts: the part before the cycle, cycle part, the remaining incomplete cycle part. \\nThe greediness of the our matching procedure guarantee that the number of `s2` matched in the first part and last part is the same as the one we would get if these two parts are concatenated, which will be a multiple of `s1`.\\n```\\nclass Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        set_s1, set_s2 = set(s1), set(s2)\\n        if not all(ch in set_s1 for ch in s2):\\n            return 0\\n        s1 = ''.join(ch for ch in s1 if ch in set_s2) # get rid of redundant character in s1.'\\n        tmap = dict()\\n        # tmap[i] = k means that at the first time s1[i] matchs to the last character in s2, we have matched s2 k times in total.\\n        record = [0]\\n        # record[i] = k means that k is the smallest number such that s2*i is a subsequence of s1*k.\\n        cnt1 = 0\\n        beg = 0\\n        while True:\\n            for ch in s2:\\n                i = s1.find(ch, beg)\\n                if i == -1:\\n                    cnt1 += 1\\n                    i = s1.find(ch)\\n                beg = i+1\\n            record.append(cnt1 + 1)\\n            if record[-1] > n1:\\n                return (len(record)-2)//n2\\n            if i in tmap: # when find a full cycle, exit the loop.\\n                break\\n            else:\\n                tmap[i] = len(record)-1\\n        '''\\n        cycle_beg denotes the number of times we have scanned s1 (including the current one) when the cycle begins.\\n        cycle_s1 denotes the number of s1 in a full cycle.\\n        cycle_s2 denotes the number of s2 in a full cycle.\\n        '''\\n        cycle_beg = record[tmap[i]]\\n        cycle_s1 = cnt1+1 - cycle_beg\\n        cycle_s2 = len(record)-1 - tmap[i]\\n        d, r = divmod(n1 - cycle_beg, cycle_s1)\\n        # d denotes the number of full cycles, r denotes the remaining number of s1 in the last incomplete cycle.\\n        remain = cycle_beg + r # concatenate the part before the cycle begins and the incomplete cycle remaining.\\n        j = 0\\n        while record[j] <= remain: # record[-1] > remain is yet to be proved.\\n            j += 1\\n        cnt = cycle_s2*d + j-1\\n        return cnt//n2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        set_s1, set_s2 = set(s1), set(s2)\\n        if not all(ch in set_s1 for ch in s2):\\n            return 0\\n        s1 = ''.join(ch for ch in s1 if ch in set_s2) # get rid of redundant character in s1.'\\n        tmap = dict()\\n        # tmap[i] = k means that at the first time s1[i] matchs to the last character in s2, we have matched s2 k times in total.\\n        record = [0]\\n        # record[i] = k means that k is the smallest number such that s2*i is a subsequence of s1*k.\\n        cnt1 = 0\\n        beg = 0\\n        while True:\\n            for ch in s2:\\n                i = s1.find(ch, beg)\\n                if i == -1:\\n                    cnt1 += 1\\n                    i = s1.find(ch)\\n                beg = i+1\\n            record.append(cnt1 + 1)\\n            if record[-1] > n1:\\n                return (len(record)-2)//n2\\n            if i in tmap: # when find a full cycle, exit the loop.\\n                break\\n            else:\\n                tmap[i] = len(record)-1\\n        '''\\n        cycle_beg denotes the number of times we have scanned s1 (including the current one) when the cycle begins.\\n        cycle_s1 denotes the number of s1 in a full cycle.\\n        cycle_s2 denotes the number of s2 in a full cycle.\\n        '''\\n        cycle_beg = record[tmap[i]]\\n        cycle_s1 = cnt1+1 - cycle_beg\\n        cycle_s2 = len(record)-1 - tmap[i]\\n        d, r = divmod(n1 - cycle_beg, cycle_s1)\\n        # d denotes the number of full cycles, r denotes the remaining number of s1 in the last incomplete cycle.\\n        remain = cycle_beg + r # concatenate the part before the cycle begins and the incomplete cycle remaining.\\n        j = 0\\n        while record[j] <= remain: # record[-1] > remain is yet to be proved.\\n            j += 1\\n        cnt = cycle_s2*d + j-1\\n        return cnt//n2\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1872841,
                "content": [
                    {
                        "username": "bahoang3105",
                        "content": "I think the example should have explanation so as not to cause confusion"
                    },
                    {
                        "username": "bahoang3105",
                        "content": "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\\nOutput: 2\\n=> str1 = \"acbacbacbacb\"\\n      str2 = \"abab\"\\n      str = [str2, 2] = \"abababab\"\\n2 is the maximum integer such that str can be obtained from str1"
                    },
                    {
                        "username": "nguyenngocquang296",
                        "content": "It should be an easy problem."
                    }
                ]
            },
            {
                "id": 1960272,
                "content": [
                    {
                        "username": "bahoang3105",
                        "content": "I think the example should have explanation so as not to cause confusion"
                    },
                    {
                        "username": "bahoang3105",
                        "content": "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\\nOutput: 2\\n=> str1 = \"acbacbacbacb\"\\n      str2 = \"abab\"\\n      str = [str2, 2] = \"abababab\"\\n2 is the maximum integer such that str can be obtained from str1"
                    },
                    {
                        "username": "nguyenngocquang296",
                        "content": "It should be an easy problem."
                    }
                ]
            }
        ]
    },
    {
        "title": "Reshape the Matrix",
        "question_content": "<p>In MATLAB, there is a handy function called <code>reshape</code> which can reshape an <code>m x n</code> matrix into a new one with a different size <code>r x c</code> keeping its original data.</p>\n\n<p>You are given an <code>m x n</code> matrix <code>mat</code> and two integers <code>r</code> and <code>c</code> representing the number of rows and the number of columns of the wanted reshaped matrix.</p>\n\n<p>The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.</p>\n\n<p>If the <code>reshape</code> operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/24/reshape1-grid.jpg\" style=\"width: 613px; height: 173px;\" />\n<pre>\n<strong>Input:</strong> mat = [[1,2],[3,4]], r = 1, c = 4\n<strong>Output:</strong> [[1,2,3,4]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg\" style=\"width: 453px; height: 173px;\" />\n<pre>\n<strong>Input:</strong> mat = [[1,2],[3,4]], r = 2, c = 4\n<strong>Output:</strong> [[1,2],[3,4]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>-1000 &lt;= mat[i][j] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= r, c &lt;= 300</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 102491,
                "title": "java-concise-o-nm-time",
                "content": "```\\npublic int[][] matrixReshape(int[][] nums, int r, int c) {\\n    int n = nums.length, m = nums[0].length;\\n    if (r*c != n*m) return nums;\\n    int[][] res = new int[r][c];\\n    for (int i=0;i<r*c;i++) \\n        res[i/c][i%c] = nums[i/m][i%m];\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[][] matrixReshape(int[][] nums, int r, int c) {\\n    int n = nums.length, m = nums[0].length;\\n    if (r*c != n*m) return nums;\\n    int[][] res = new int[r][c];\\n    for (int i=0;i<r*c;i++) \\n        res[i/c][i%c] = nums[i/m][i%m];\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 102513,
                "title": "one-loop",
                "content": "We can use `matrix[index / width][index % width]` for both the input and the output matrix.\\n\\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\\n        int m = nums.length, n = nums[0].length;\\n        if (r * c != m * n)\\n            return nums;\\n        int[][] reshaped = new int[r][c];\\n        for (int i = 0; i < r * c; i++)\\n            reshaped[i/c][i%c] = nums[i/n][i%n];\\n        return reshaped;\\n    }",
                "solutionTags": [],
                "code": "We can use `matrix[index / width][index % width]` for both the input and the output matrix.\\n\\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\\n        int m = nums.length, n = nums[0].length;\\n        if (r * c != m * n)\\n            return nums;\\n        int[][] reshaped = new int[r][c];\\n        for (int i = 0; i < r * c; i++)\\n            reshaped[i/c][i%c] = nums[i/n][i%n];\\n        return reshaped;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1317151,
                "title": "c-one-loop-easy-solution-column-first-and-row-first-approaches",
                "content": "There\\'s nothing much to this problem - Just check if total elements in both matrices will be same and then transform. I have mentioned two approaches below.\\n\\n----\\n\\n\\u2714\\uFE0F ***Solution (Row-First Approach)***\\n\\nIterate each row column-by-column, wrap around when you reach the end on one row and move to the next row. Here, we are copying all elements of one row and then moving on to the next row.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = size(mat), n = size(mat[0]), total = m * n;\\n        if(r * c != total) return mat;\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        for(int i = 0; i < total; i++) \\n            ans[i / c][i % c] = mat[i / n][i % n];\\n        return ans;\\n    }\\n};\\n```\\n\\n<blockquote>\\n<details>\\n<summary><b>\\u2714\\uFE0F Commented Solution</b></summary>\\n\\n\\nIf the above appraoch was not clear, you can refer the below commented code -\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = size(mat), n = size(mat[0]), total = m * n;\\n        if(r * c != total) return mat;             // return if total elements don\\'t match\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        int i = 0, j = 0, new_i = 0, new_j = 0;    // i, j iterates over old matrix | new_i, new_j iterates over new matrix\\n        while(total--) {\\n            ans[new_i][new_j] = mat[i][j]; \\n            j++, new_j++;                          // move to next column in both matrix\\n            if(j == n) j = 0, i++;                 // start from beginning of next row when you reach the end of row in old matrix\\n            if(new_j == c) new_j = 0, new_i++;     // start from beginning of next row when you reach the end of row in new matrix\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n</details>\\n</blockquote>\\n\\n***Time Complexity :*** `O(r*c)`\\n***Space Complexity :*** `O(1)`, ignoring output space complexity\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Column-First Appraoch)***\\n\\nAll other posts have mentioned the first approach. It might be a good follow-up to try implementing it using column-first approach.\\n\\nIterate each column row-by-row, wrap around when you reach the end on one column and then move to the next column. Here, we are copying all elements of one column and then moving on to the next column.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = size(mat), n = size(mat[0]), total = m * n;\\n        if(r * c != total) return mat;   \\n        vector<vector<int>> ans(r, vector<int>(c));\\n        for(int col = 0; col < n; col++) {\\n            for(int row = 0; row < m; row++) {\\n                int new_row = (n * row + col) / c;\\n                int new_col = (n * row + col) % c;\\n                ans[new_row][new_col] = mat[row][col];                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n<blockquote>\\n<details>\\n<summary><b>\\u2714\\uFE0F Single-Loop Solution</b></summary>\\n\\nIf anyone figures out a cleaner code than the following version, please let me know :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = size(mat), n = size(mat[0]), total = m * n;\\n        if(r * c != total) return mat;   \\n        vector<vector<int>> ans(r, vector<int>(c));\\n        for(int i = 0; i < total; i++) \\n            ans[(i%m * n + i/m) / c][(i%m * n + i/m) % c] = mat[i % m][i / m];\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n</details>\\n</blockquote>\\n\\n***Time Complexity :*** `O(r*c)`\\n***Space Complexity :*** `O(1)`, ignoring output space complexity\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = size(mat), n = size(mat[0]), total = m * n;\\n        if(r * c != total) return mat;\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        for(int i = 0; i < total; i++) \\n            ans[i / c][i % c] = mat[i / n][i % n];\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = size(mat), n = size(mat[0]), total = m * n;\\n        if(r * c != total) return mat;             // return if total elements don\\'t match\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        int i = 0, j = 0, new_i = 0, new_j = 0;    // i, j iterates over old matrix | new_i, new_j iterates over new matrix\\n        while(total--) {\\n            ans[new_i][new_j] = mat[i][j]; \\n            j++, new_j++;                          // move to next column in both matrix\\n            if(j == n) j = 0, i++;                 // start from beginning of next row when you reach the end of row in old matrix\\n            if(new_j == c) new_j = 0, new_i++;     // start from beginning of next row when you reach the end of row in new matrix\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = size(mat), n = size(mat[0]), total = m * n;\\n        if(r * c != total) return mat;   \\n        vector<vector<int>> ans(r, vector<int>(c));\\n        for(int col = 0; col < n; col++) {\\n            for(int row = 0; row < m; row++) {\\n                int new_row = (n * row + col) / c;\\n                int new_col = (n * row + col) % c;\\n                ans[new_row][new_col] = mat[row][col];                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = size(mat), n = size(mat[0]), total = m * n;\\n        if(r * c != total) return mat;   \\n        vector<vector<int>> ans(r, vector<int>(c));\\n        for(int i = 0; i < total; i++) \\n            ans[(i%m * n + i/m) / c][(i%m * n + i/m) % c] = mat[i % m][i / m];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046840,
                "title": "python-intuitive-direct-for-beginners-with-illustrations",
                "content": "Given a matrix `mat` of 3 rows * 4 columns, \\nwe want reshape it into 2 rows (`r = 2`) * 6 columns(`c = 6`): \\n```\\n[[0,  1,  2,  3],\\n [4,  5,  6,  7],                 ->                [[0,  1,  2,  3,  4,  5],\\n [8,  9,  10, 11]]                                   [6,  7,  8,  9,  10, 11]]\\n```\\n**Step 1:** Flatten the given matrix `mat` to a 1-D list `flatten` for easier visualizations and calculations for future steps\\n```\\nflatten = [0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11]\\n```\\n**Step 2:** Check whether the total number of given elements `len(flatten)` and the new shape `r * c` matches (i.e. whether \"*given parameters is possible and legal*\")\\n```\\nr = 2, c = 6\\nr * c = 12\\n```\\n**Step 3:** Rearrange all elements in 1-D list `flatten` into the `new_mat`  according to given number of row `r` and given number of columns `c`\\n```\\nflatten = [0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11]\\n```\\n\\nreshaping: \\n```\\n                         [0,  1,  2,  3,  4,  5,   6,  7,  8,  9,  10, 11]\\nrow_index: 0\\t\\t\\t| c0  c1  c2  c3  c4  c5 |\\nrow_index: 1                           \\t\\t\\t | c0  c1  c2  c3  c4  c5 |\\n\\nindex in flatten:  [row_index * c : row_index * c + c])\\n\\n\\t\\t\\t            [0*6       :      0*6 + 6],  \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t         [1*6        :       1*6+6]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n                        [0          :           6],  \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t         [6          :          12]\\n```\\n- **iteration 0**:` row_index` **0**\\n```\\nflatten[0 : 6]   ->   [0,  1,  2,  3,  4,  5]\\n\\nappending:\\nnew_mat = [[0,  1,  2,  3,  4,  5]]\\n```\\n- **iteration 1**: `row_index` **1**\\n```\\nflatten[6 : 12]   ->   [6,  7,  8,  9,  10, 11]\\n\\nappending:\\nnew_mat = [[0,  1,  2,  3,  4,  5],\\n           [6,  7,  8,  9,  10, 11]]\\n```\\n\\n\\n\\n___________________________\\n```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        flatten = []\\n        new_mat = []\\n        for row in mat:\\n            for num in row:\\n                flatten.append(num)\\n                \\n        if r * c != len(flatten):   # when given parameters is NOT possible and legal\\n            return mat\\n        else:\\n            for row_index in range(r):\\n                new_mat.append(flatten[row_index * c : row_index * c + c])\\n            return new_mat\\n```\\n\\n________________________________________________________________________\\n\\nAs a total beginner, I am writing these all out to help myself, and hopefully also help anyone out there who is like me at the same time.\\n\\nPlease upvote\\u2B06\\uFE0F if you find this helpful or worth-reading for beginners in anyway.  \\nYour upvote is much more than just supportive to me. \\uD83D\\uDE33\\uD83E\\uDD13\\uD83E\\uDD70\\n\\nIf you find this is not helpful, needs improvement, or is questionable, would you please leave a quick comment below to point out the problem before you decide to downvote? It will be very helpful for me (maybe also others) to learn as a beginner.\\n\\nThank you very much either way \\uD83E\\uDD13.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\n[[0,  1,  2,  3],\\n [4,  5,  6,  7],                 ->                [[0,  1,  2,  3,  4,  5],\\n [8,  9,  10, 11]]                                   [6,  7,  8,  9,  10, 11]]\\n```\n```\\nflatten = [0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11]\\n```\n```\\nr = 2, c = 6\\nr * c = 12\\n```\n```\\nflatten = [0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11]\\n```\n```\\n                         [0,  1,  2,  3,  4,  5,   6,  7,  8,  9,  10, 11]\\nrow_index: 0\\t\\t\\t| c0  c1  c2  c3  c4  c5 |\\nrow_index: 1                           \\t\\t\\t | c0  c1  c2  c3  c4  c5 |\\n\\nindex in flatten:  [row_index * c : row_index * c + c])\\n\\n\\t\\t\\t            [0*6       :      0*6 + 6],  \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t         [1*6        :       1*6+6]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n                        [0          :           6],  \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t         [6          :          12]\\n```\n```\\nflatten[0 : 6]   ->   [0,  1,  2,  3,  4,  5]\\n\\nappending:\\nnew_mat = [[0,  1,  2,  3,  4,  5]]\\n```\n```\\nflatten[6 : 12]   ->   [6,  7,  8,  9,  10, 11]\\n\\nappending:\\nnew_mat = [[0,  1,  2,  3,  4,  5],\\n           [6,  7,  8,  9,  10, 11]]\\n```\n```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        flatten = []\\n        new_mat = []\\n        for row in mat:\\n            for num in row:\\n                flatten.append(num)\\n                \\n        if r * c != len(flatten):   # when given parameters is NOT possible and legal\\n            return mat\\n        else:\\n            for row_index in range(r):\\n                new_mat.append(flatten[row_index * c : row_index * c + c])\\n            return new_mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727031,
                "title": "java-solution-detailed-explanation-easy-approch-100-efficent",
                "content": "# Approch -``\\n\\n***1st condition** to be checked -*\\nFirstly will have to check if the product of dimension of the given array matrix(**mat**) and the product of dimensions of the new array matrix are eqaul. If they are not equal this means we cannot fill all the elements perfectly in one of the matrix hence in this condition, will have to return the original array.\\n\\n***Secondly***, we will traverse through the first matrix and add the elements in our newly created **output matrix**, but here we have to keep in mind to add elements column wise and not row wise. i.e we will maintain two seperate pointers for rows and colums and firstly we will go through colums & if (**column == c**) then we will move to next row & also set the column pointer to zero again.\\n\\n***For Better unnderstnading let\\'s look at the code***\\n\\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        \\n        //Storing the values of mat matrix\\n        //i.e m = rows & n = cols\\n        int rows = mat.length;\\n        int cols = mat[0].length;\\n        \\n        //if the product of rows & cols of mat matrix and the new matrix are not same then return original matrix\\n        if((rows * cols) != (r * c)) return mat;\\n        \\n        //Creating the new matrix\\n        int[][] output = new int[r][c];\\n        int output_rows = 0;\\n        int output_cols = 0;\\n        \\n        \\n        //Traversing the mat matrix and storing the its values in new matrix output cols wise\\n        for(int i = 0; i < rows; i++)\\n        {\\n            for(int j = 0; j < cols; j++)\\n            {\\n                output[output_rows][output_cols] = mat[i][j];\\n                output_cols++;\\n                \\n                //if the cols value reached then change the row and set the cols value to 0.\\n                if(output_cols == c)\\n                {\\n                    output_cols = 0;\\n                    output_rows++;\\n                }\\n            }\\n        }\\n        \\n        return output;\\n    }\\n}\\n```\\n\\n\\n**If found helpful, please upvote.\\nThank You !!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        \\n        //Storing the values of mat matrix\\n        //i.e m = rows & n = cols\\n        int rows = mat.length;\\n        int cols = mat[0].length;\\n        \\n        //if the product of rows & cols of mat matrix and the new matrix are not same then return original matrix\\n        if((rows * cols) != (r * c)) return mat;\\n        \\n        //Creating the new matrix\\n        int[][] output = new int[r][c];\\n        int output_rows = 0;\\n        int output_cols = 0;\\n        \\n        \\n        //Traversing the mat matrix and storing the its values in new matrix output cols wise\\n        for(int i = 0; i < rows; i++)\\n        {\\n            for(int j = 0; j < cols; j++)\\n            {\\n                output[output_rows][output_cols] = mat[i][j];\\n                output_cols++;\\n                \\n                //if the cols value reached then change the row and set the cols value to 0.\\n                if(output_cols == c)\\n                {\\n                    output_cols = 0;\\n                    output_rows++;\\n                }\\n            }\\n        }\\n        \\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102500,
                "title": "python-solutions",
                "content": "#### **Solution 1 - `NumPy`**\\n\\n\\nWhen I read \"MATLAB\", I immediately thought \"NumPy\". Thanks to @fallcreek for pointing out `tolist`, makes converting the result to the correct type easier than what I had originally.\\n```\\nimport numpy as np\\n\\nclass Solution(object):\\n    def matrixReshape(self, nums, r, c):\\n        try:\\n            return np.reshape(nums, (r, c)).tolist()\\n        except:\\n            return nums\\n```\\n#### **Solution 2 - Oneliner**\\n\\nAn ugly oneliner :-)\\n\\n    def matrixReshape(self, nums, r, c):\\n        return nums if len(sum(nums, [])) != r * c else map(list, zip(*([iter(sum(nums, []))]*c)))\\n\\nA more readable version of that:\\n\\n    def matrixReshape(self, nums, r, c):\\n        flat = sum(nums, [])\\n        if len(flat) != r * c:\\n            return nums\\n        tuples = zip(*([iter(flat)] * c))\\n        return map(list, tuples)\\n\\n#### **Solution 3 - `itertools`**\\n\\n    def matrixReshape(self, nums, r, c):\\n        if r * c != len(nums) * len(nums[0]):\\n            return nums\\n        it = itertools.chain(*nums)\\n        return [list(itertools.islice(it, c)) for _ in xrange(r)]",
                "solutionTags": [],
                "code": "```\\nimport numpy as np\\n\\nclass Solution(object):\\n    def matrixReshape(self, nums, r, c):\\n        try:\\n            return np.reshape(nums, (r, c)).tolist()\\n        except:\\n            return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317225,
                "title": "python-one-pass-clean-concise",
                "content": "**Python 3**\\n```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        if r * c != m * n: return mat  # Invalid size -> return original matrix\\n        ans = [[0] * c for _ in range(r)]\\n        for i in range(m * n):\\n            ans[i // c][i % c] = mat[i // n][i % n]\\n        return ans\\n```\\n**Complexity**\\n - Time & Space: `O(M*N)`",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        if r * c != m * n: return mat  # Invalid size -> return original matrix\\n        ans = [[0] * c for _ in range(r)]\\n        for i in range(m * n):\\n            ans[i // c][i % c] = mat[i // n][i % n]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734753,
                "title": "javascript-es6-simple-solution",
                "content": "```\\nvar matrixReshape = function (nums, r, c) {\\n  var arr = nums.flat();\\n  if (r * c != arr.length) return nums;\\n\\n  var res = [];\\n  while (arr.length) res.push(arr.splice(0, c));\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar matrixReshape = function (nums, r, c) {\\n  var arr = nums.flat();\\n  if (r * c != arr.length) return nums;\\n\\n  var res = [];\\n  while (arr.length) res.push(arr.splice(0, c));\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 102511,
                "title": "easy-java-solution",
                "content": "```\\npublic class Solution {\\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\\n        int m = nums.length, n = nums[0].length;\\n        if (m * n != r * c) return nums;\\n        \\n        int[][] result = new int[r][c];\\n        int row = 0, col = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                result[row][col] = nums[i][j];\\n                col++;\\n                if (col == c) {\\n                    col = 0;\\n                    row++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\\n        int m = nums.length, n = nums[0].length;\\n        if (m * n != r * c) return nums;\\n        \\n        int[][] result = new int[r][c];\\n        int row = 0, col = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                result[row][col] = nums[i][j];\\n                col++;\\n                if (col == c) {\\n                    col = 0;\\n                    row++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102516,
                "title": "easy-to-understand-python-solution",
                "content": "```\\nclass Solution(object):\\n    def matrixReshape(self, nums, r, c):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :type r: int\\n        :type c: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if len(nums) * len(nums[0]) != r * c:\\n            return nums\\n            \\n        ans = [[]]\\n        for i in range(len(nums)):\\n            for j in range(len(nums[0])):\\n                k = nums[i][j]\\n                if len(ans[-1]) < c:\\n                    ans[-1].append(k)\\n                else:\\n                    ans.append([k])\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def matrixReshape(self, nums, r, c):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :type r: int\\n        :type c: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if len(nums) * len(nums[0]) != r * c:\\n            return nums\\n            \\n        ans = [[]]\\n        for i in range(len(nums)):\\n            for j in range(len(nums[0])):\\n                k = nums[i][j]\\n                if len(ans[-1]) < c:\\n                    ans[-1].append(k)\\n                else:\\n                    ans.append([k])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102563,
                "title": "c-solution",
                "content": "```\\nint** matrixReshape(int** nums, int m, int n, int r, int c, int** columnSizes, int* returnSize) {\\n    if (r * c != m * n) {\\n        r = m;\\n        c = n;\\n    }\\n\\n    *returnSize = r;\\n    int** result = (int**) malloc(r * sizeof(int*));\\n    *columnSizes = (int*) malloc(r * sizeof(int));\\n    for (int i = 0; i < r; ++i) {\\n        result[i] = (int*) malloc(c * sizeof(int));\\n        (*columnSizes)[i] = c;\\n    }\\n    \\n    for (int i = 0; i < m * n; ++i)\\n        result[i/c][i%c] = nums[i/n][i%n];\\n\\n    return result;\\n}\\n```\\n\\nMost of the code is for creating the data structure, not for writing the real contents into it. This must be fun for masochists :-). I just did this because of @leaf2's [question about C solutions](https://discuss.leetcode.com/topic/88089/anyone-has-c-solution-of-this-question) and similar questions I've seen occasionally. Was a little challenge.\\n\\nThings to notice:\\n- If the requested shape is invalid, we can't just return `nums` (which is what the problem text somewhat sounds like). Think about what the judge is probably doing. Probably it uses and frees all the result data (the data pointed to by the `return` value as well as what we write in `returnSize` and `columnSizes`). So we should create an independent *copy* of the input matrix with all its own data. I do this by simply changing `r` and `c` to the input shape and then continuing as otherwise. Can also be done like this:\\n\\n       if (r * c != m * n)\\n           return matrixReshape(nums, m, n, m, n, columnSizes, returnSize);\\n\\n- The \"sizes\" we must write to are the numbers of rows and columns, not the malloc sizes (i.e., not multiplied with `sizeof(...)`). I found that unclear in the specification, but on the other hand, it makes more sense if you think about what the judge code probably looks like.\\n- I renamed `numsRowSize` and `numsColSize` to the standard matrix size names `m` and `n`. Can't stand those awfully long and nonstandard names.",
                "solutionTags": [],
                "code": "```\\nint** matrixReshape(int** nums, int m, int n, int r, int c, int** columnSizes, int* returnSize) {\\n    if (r * c != m * n) {\\n        r = m;\\n        c = n;\\n    }\\n\\n    *returnSize = r;\\n    int** result = (int**) malloc(r * sizeof(int*));\\n    *columnSizes = (int*) malloc(r * sizeof(int));\\n    for (int i = 0; i < r; ++i) {\\n        result[i] = (int*) malloc(c * sizeof(int));\\n        (*columnSizes)[i] = c;\\n    }\\n    \\n    for (int i = 0; i < m * n; ++i)\\n        result[i/c][i%c] = nums[i/n][i%n];\\n\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 102496,
                "title": "c-java-clean-code-5-lines-2-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\\n        int m = nums.length, n = nums[0].length, o = m * n;\\n        if (r * c != o) return nums;\\n        int[][] res = new int[r][c];\\n        for (int i = 0; i < o; i++) res[i / c][i % c] = nums[i / n][i % n];\\n        return res;        \\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {\\n        int m = nums.size(), n = nums[0].size(), o = m * n;\\n        if (r * c != o) return nums;\\n        vector<vector<int>> res(r, vector<int>(c, 0));\\n        for (int i = 0; i < o; i++) res[i / c][i % c] = nums[i / n][i % n];\\n        return res;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {\\n        int m = nums.size(), n = nums[0].size();\\n        if (m * n != r * c) {\\n            return nums;\\n        }\\n\\n        vector<vector<int>> res(r, vector<int>(c, 0));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int k = i * n + j;\\n                res[k / c][k % c] = nums[i][j];\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\\n        int m = nums.length, n = nums[0].length, o = m * n;\\n        if (r * c != o) return nums;\\n        int[][] res = new int[r][c];\\n        for (int i = 0; i < o; i++) res[i / c][i % c] = nums[i / n][i % n];\\n        return res;        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {\\n        int m = nums.size(), n = nums[0].size(), o = m * n;\\n        if (r * c != o) return nums;\\n        vector<vector<int>> res(r, vector<int>(c, 0));\\n        for (int i = 0; i < o; i++) res[i / c][i % c] = nums[i / n][i % n];\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {\\n        int m = nums.size(), n = nums[0].size();\\n        if (m * n != r * c) {\\n            return nums;\\n        }\\n\\n        vector<vector<int>> res(r, vector<int>(c, 0));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int k = i * n + j;\\n                res[k / c][k % c] = nums[i][j];\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102499,
                "title": "python-simple-with-explanation",
                "content": "Collect the values of the array A, and then put them into the answer of size ```nR x nC```.\\n\\n```\\ndef matrixReshape(self, A, nR, nC):\\n    if len(A) * len(A[0]) != nR * nC:\\n        return A\\n        \\n    vals = (val for row in A for val in row)\\n    return [[vals.next() for c in xrange(nC)] for r in xrange(nR)]\\n```\\n\\nAlternative solution without generators:\\n```\\ndef matrixReshape(self, A, nR, nC):\\n    if len(A) * len(A[0]) != nR * nC:\\n        return A\\n        \\n    vals = [val for row in A for val in row]\\n    ans = [[None] * nC for _ in xrange(nR)]\\n    i = 0\\n    for r in xrange(nR):\\n        for c in xrange(nC):\\n            ans[r][c] = vals[i]\\n            i += 1\\n    return ans",
                "solutionTags": [],
                "code": "```nR x nC```\n```\\ndef matrixReshape(self, A, nR, nC):\\n    if len(A) * len(A[0]) != nR * nC:\\n        return A\\n        \\n    vals = (val for row in A for val in row)\\n    return [[vals.next() for c in xrange(nC)] for r in xrange(nR)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2484679,
                "title": "very-easy-100-fully-explained-java-c-python-javascript-python3",
                "content": "# **Java Solution:**\\n```\\n// Runtime: 1 ms, faster than 92.33% of Java online submissions for Reshape the Matrix.\\n// Time Complexity : O(r*c)\\n// Space Complexity : O(r*c)\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        // If transformation doesn\\'t occur, return mat...\\n        if (mat.length * mat[0].length != r * c) {\\n            return mat;\\n        }\\n        // Otherwise create a output matrix and fill the cells...\\n        int[][] output = new int[r][c];\\n        // Traverse the matrix through the loop... \\n        for (int idx = 0; idx < r * c; idx++) {\\n            // idx % c will give us the current column number...\\n            // idx / c will give us how many rows we have completely filled...\\n            output[idx/c][idx % c] = mat[idx / mat[0].length][idx % mat[0].length];\\n        }\\n        return output;      // Return the output matrix...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\n// Time Complexity : O(r*c)\\n// Space Complexity : O(r*c)\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        // If transformation doesn\\'t occur, return mat...\\n        if (mat.size() * mat[0].size() != r * c) {\\n            return mat;\\n        }\\n        // Otherwise create a output matrix and fill the cells...\\n        vector<vector<int>> output(r, vector<int>(c));\\n        // Traverse the matrix through the loop... \\n        for (int idx = 0; idx < r * c; idx++) {\\n            // idx % c will give us the current column number...\\n            // idx / c will give us how many rows we have completely filled...\\n            output[idx/c][idx % c] = mat[idx / mat[0].size()][idx % mat[0].size()];\\n        }\\n        return output;      // Return the output matrix...\\n    }\\n};\\n```\\n\\n# **Python/Python3 Solution:**\\n```\\n# Time Complexity : O(r*c)\\n# Space Complexity : O(r*c)\\nclass Solution(object):\\n    def matrixReshape(self, mat, r, c):\\n        # Base case...\\n        if not mat: return mat\\n        # If transformation doesn\\'t occur, return mat...\\n        if len(mat) * len(mat[0]) != r * c:\\n            return mat\\n        # Otherwise create a output matrix and fill the cells...\\n        output = [[0 for i in range(c)] for i in range(r)]\\n        idx = 0\\n        # Traverse the matrix through the loop... \\n        while idx < r * c:\\n            # idx % c will give us the current column number...\\n            # idx / c will give us how many rows we have completely filled...\\n            output[idx // c][ idx % c] =  mat[idx // len(mat[0])][idx % len(mat[0])]\\n            idx += 1\\n        return output       # Return the output matrix...\\n```\\n                   \\n# **JavaScript Solution:**\\n```\\n// Time Complexity : O(r*c)\\n// Space Complexity : O(r*c)\\nvar matrixReshape = function(mat, r, c) {\\n    // If transformation doesn\\'t occur, return mat...\\n    if (mat.length * mat[0].length != r * c) {\\n        return mat;\\n    }\\n    // Otherwise create a output matrix and fill the cells...\\n    const output = new Array(r).fill(0).map(() => new Array(c).fill(0));\\n    // Traverse the matrix through the loop... \\n    for (let idx = 0; idx < r * c; idx++) {\\n        // idx % c will give us the current column number...\\n        // idx / c will give us how many rows we have completely filled...\\n        output[Math.floor(idx/c)][idx % c] = mat[Math.floor(idx / mat[0].length)][idx % mat[0].length];\\n    }\\n    return output;      // Return the output matrix...\\n};\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\n// Runtime: 1 ms, faster than 92.33% of Java online submissions for Reshape the Matrix.\\n// Time Complexity : O(r*c)\\n// Space Complexity : O(r*c)\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        // If transformation doesn\\'t occur, return mat...\\n        if (mat.length * mat[0].length != r * c) {\\n            return mat;\\n        }\\n        // Otherwise create a output matrix and fill the cells...\\n        int[][] output = new int[r][c];\\n        // Traverse the matrix through the loop... \\n        for (int idx = 0; idx < r * c; idx++) {\\n            // idx % c will give us the current column number...\\n            // idx / c will give us how many rows we have completely filled...\\n            output[idx/c][idx % c] = mat[idx / mat[0].length][idx % mat[0].length];\\n        }\\n        return output;      // Return the output matrix...\\n    }\\n}\\n```\n```\\n// Time Complexity : O(r*c)\\n// Space Complexity : O(r*c)\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        // If transformation doesn\\'t occur, return mat...\\n        if (mat.size() * mat[0].size() != r * c) {\\n            return mat;\\n        }\\n        // Otherwise create a output matrix and fill the cells...\\n        vector<vector<int>> output(r, vector<int>(c));\\n        // Traverse the matrix through the loop... \\n        for (int idx = 0; idx < r * c; idx++) {\\n            // idx % c will give us the current column number...\\n            // idx / c will give us how many rows we have completely filled...\\n            output[idx/c][idx % c] = mat[idx / mat[0].size()][idx % mat[0].size()];\\n        }\\n        return output;      // Return the output matrix...\\n    }\\n};\\n```\n```\\n# Time Complexity : O(r*c)\\n# Space Complexity : O(r*c)\\nclass Solution(object):\\n    def matrixReshape(self, mat, r, c):\\n        # Base case...\\n        if not mat: return mat\\n        # If transformation doesn\\'t occur, return mat...\\n        if len(mat) * len(mat[0]) != r * c:\\n            return mat\\n        # Otherwise create a output matrix and fill the cells...\\n        output = [[0 for i in range(c)] for i in range(r)]\\n        idx = 0\\n        # Traverse the matrix through the loop... \\n        while idx < r * c:\\n            # idx % c will give us the current column number...\\n            # idx / c will give us how many rows we have completely filled...\\n            output[idx // c][ idx % c] =  mat[idx // len(mat[0])][idx % len(mat[0])]\\n            idx += 1\\n        return output       # Return the output matrix...\\n```\n```\\n// Time Complexity : O(r*c)\\n// Space Complexity : O(r*c)\\nvar matrixReshape = function(mat, r, c) {\\n    // If transformation doesn\\'t occur, return mat...\\n    if (mat.length * mat[0].length != r * c) {\\n        return mat;\\n    }\\n    // Otherwise create a output matrix and fill the cells...\\n    const output = new Array(r).fill(0).map(() => new Array(c).fill(0));\\n    // Traverse the matrix through the loop... \\n    for (let idx = 0; idx < r * c; idx++) {\\n        // idx % c will give us the current column number...\\n        // idx / c will give us how many rows we have completely filled...\\n        output[Math.floor(idx/c)][idx % c] = mat[Math.floor(idx / mat[0].length)][idx % mat[0].length];\\n    }\\n    return output;      // Return the output matrix...\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534322,
                "title": "python-beginner-solution-beats-82",
                "content": "```\\ndef rotate(nums, r, c):\\n    flat_list = []\\n    matrix = []\\n\\n    for sublist in nums:\\n        for item in sublist:\\n            flat_list.append(item)\\n\\n    if len(flat_list) != r * c:\\n        return nums\\n    else:\\n        for i in range(0,len(flat_list),c):\\n            matrix.append(flat_list[i:i+c])\\n        return matrix",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef rotate(nums, r, c):\\n    flat_list = []\\n    matrix = []\\n\\n    for sublist in nums:\\n        for item in sublist:\\n            flat_list.append(item)\\n\\n    if len(flat_list) != r * c:\\n        return nums\\n    else:\\n        for i in range(0,len(flat_list),c):\\n            matrix.append(flat_list[i:i+c])\\n        return matrix",
                "codeTag": "Python3"
            },
            {
                "id": 1317320,
                "title": "python-one-line-two-line-yield-generator-circular-index-numpy-with-explaination-556",
                "content": "# Solution #1: Using Numpy\\nBelow is the one line code which makes use of numpy.reshape method provided by numpy.\\n```python\\nimport numpy\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        return numpy.reshape(mat,(r,c)) if r*c==len(mat)*len(mat[0]) else mat\\n```\\n## Lets look into the breadcrumbs!!\\n> NumPy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays.\\n> [<<\\\\<Wikipedia\\\\>>>](https://en.wikipedia.org/wiki/NumPy)\\n```python\\nreturn A if B else C\\n```\\nThis kind of statement is similar to ternary operator. Returns `A` if `B` evaluates to `True`, if not return `C`.\\n```python\\nnumpy.reshape(matrix, (row,col))\\n```\\n> Above method gives a new shape to an array without changing its data.\\n>  [<<\\\\<NumPy Docs\\\\>>>](https://numpy.org/doc/stable/reference/generated/numpy.reshape.html)\\n```python\\nif r*c==len(mat)*len(mat[0])\\n```\\nCondition: Check if the size of matrix is equals to the size of the matrix which is to be returned.\\n```\\nlen(mat) # gives the number of rows\\nlen(mat[0]) # gives the number of columns\\n```\\n-------------------------\\n\\n# Solution #2: Using Queue\\nBelow solution doesnt use any other libraries. But its written in two lines and makes use of another list/queue to build a matrix.\\n```python\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        queue = [cell for row in mat for cell in row] if r*c==len(mat)*len(mat[0]) else []\\n        return [[queue.pop(0) for _ in range(c)] for _ in range(r)] if queue else mat\\n```\\n## Lets look into the breadcrumbs!!\\n```python\\nqueue = [cell for row in mat for cell in row] if r*c==len(mat)*len(mat[0]) else []\\n```\\n`queue` contains the flattened matrix (flattening from 2D to 1D, using [row-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order)). However speaking of memory, matrix is stored as 1D array in memory.\\n`queue` will be empty if the size of given matrix and matrix supposed to be created does not match.\\n```python\\n [[queue.pop(0) for _ in range(c)] for _ in range(r)] if queue else mat\\n```\\nUsing row-major itself, we are creating a new matrix with new row_no and col_no, and finally return it.\\n\\n-----------------------------\\n# Solution #3: Using Circular Index\\nAnother two line solution which does not use any extra space or extrnal packages.\\n```python\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        if r*c!=len(mat)*(cols:=len(mat[0])): return mat\\n        return [[mat[(i*c+j)//cols][(i*c+j)%cols] for j in range(c)] for i in range(r)]\\n```\\n## Lets look into the breadcrumbs!!\\nAny 2D matrix will be stored as stated below on machines follwing row-major order.\\n![image](https://assets.leetcode.com/users/images/f54a0c80-d9cf-4d6f-bfe4-80188a10977d_1625498161.5667083.png)\\n[<<\\\\<Image Source\\\\>>>](https://eli.thegreenplace.net/2015/memory-layout-of-multi-dimensional-arrays)\\n[To know more, please make use of this webpage](https://eli.thegreenplace.net/2015/memory-layout-of-multi-dimensional-arrays)\\n```python\\nif r*c!=len(mat)*(cols:=len(mat[0])): return mat\\n```\\nReturn the given matrix if the size does not match\\n```python\\n(cols:=len(mat[0]) # this is an assignment expression\\n```\\nTo know more on assignment expressions, [click here](https://realpython.com/lessons/assignment-expressions/ \"Real Python\")\\nWe are assigning `cols` the number of columns available in given matrix and returning the same value in one single line.\\n```python\\n(i*c+j) # conversion from row,column to offset\\n(i*c+j)//cols # gives the row number of old matrix\\n(i*c+j)%cols # givens the column number of old matrix\\nmat[(i*c+j)//cols][(i*c+j)%cols] # gives you the value at specified row and column\\n```\\n\\n-----------------------------\\n# Solution #4: Using Yield\\n```python\\nclass Solution:\\n    def getCell(self, mat):\\n        for row in mat:\\n            for cell in row:\\n                yield cell\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        gen = self.getCell(mat)\\n        return [[next(gen) for _ in range(c)] for _ in range(r)] if len(mat) * len(mat[0]) == r * c else mat\\n```\\n## Lets look into the breadcrumbs!!\\n```python\\ndef getCell(self, mat):\\n\\tfor row in mat:\\n\\t\\tfor cell in row:\\n\\t\\t\\tyield cell\\n```\\n`getCell()` is a generator method which returns the next element in the original/old matrix.\\nTo know about generators, [click here](https://realpython.com/introduction-to-python-generators/)\\n```python\\n[[next(gen) for _ in range(c)] for _ in range(r)] if len(mat) * len(mat[0]) == r * c else mat\\n```\\nCreate a new matrix and return it if the condition of size satisfies, else return the old matrix.\\n\\n-----------------------------\\n# Solution #5: Using Generator\\n```python\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        gen = (cell for row in mat for cell in row)\\n        return [[next(gen) for _ in range(c)] for _ in range(r)] if len(mat) * len(mat[0]) == r * c else mat\\n```\\n## Lets look into the breadcrumbs!!\\n```python\\ngen = (cell for row in mat for cell in row)\\n```\\nIn the above solution (Solution#4), we used a generator method to generate next elements. Instead of writing a function, lets use generator expression. The only difference between Solution#4 and Solution#5 is that, 4 uses generator method and 5 uses generator expression.\\n\\n---------\\nI hope this is helpful to you :)\\n\\n--------",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```python\\nimport numpy\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        return numpy.reshape(mat,(r,c)) if r*c==len(mat)*len(mat[0]) else mat\\n```\n```python\\nreturn A if B else C\\n```\n```python\\nnumpy.reshape(matrix, (row,col))\\n```\n```python\\nif r*c==len(mat)*len(mat[0])\\n```\n```\\nlen(mat) # gives the number of rows\\nlen(mat[0]) # gives the number of columns\\n```\n```python\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        queue = [cell for row in mat for cell in row] if r*c==len(mat)*len(mat[0]) else []\\n        return [[queue.pop(0) for _ in range(c)] for _ in range(r)] if queue else mat\\n```\n```python\\nqueue = [cell for row in mat for cell in row] if r*c==len(mat)*len(mat[0]) else []\\n```\n```python\\n [[queue.pop(0) for _ in range(c)] for _ in range(r)] if queue else mat\\n```\n```python\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        if r*c!=len(mat)*(cols:=len(mat[0])): return mat\\n        return [[mat[(i*c+j)//cols][(i*c+j)%cols] for j in range(c)] for i in range(r)]\\n```\n```python\\nif r*c!=len(mat)*(cols:=len(mat[0])): return mat\\n```\n```python\\n(cols:=len(mat[0]) # this is an assignment expression\\n```\n```python\\n(i*c+j) # conversion from row,column to offset\\n(i*c+j)//cols # gives the row number of old matrix\\n(i*c+j)%cols # givens the column number of old matrix\\nmat[(i*c+j)//cols][(i*c+j)%cols] # gives you the value at specified row and column\\n```\n```python\\nclass Solution:\\n    def getCell(self, mat):\\n        for row in mat:\\n            for cell in row:\\n                yield cell\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        gen = self.getCell(mat)\\n        return [[next(gen) for _ in range(c)] for _ in range(r)] if len(mat) * len(mat[0]) == r * c else mat\\n```\n```python\\ndef getCell(self, mat):\\n\\tfor row in mat:\\n\\t\\tfor cell in row:\\n\\t\\t\\tyield cell\\n```\n```python\\n[[next(gen) for _ in range(c)] for _ in range(r)] if len(mat) * len(mat[0]) == r * c else mat\\n```\n```python\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        gen = (cell for row in mat for cell in row)\\n        return [[next(gen) for _ in range(c)] for _ in range(r)] if len(mat) * len(mat[0]) == r * c else mat\\n```\n```python\\ngen = (cell for row in mat for cell in row)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317309,
                "title": "java-in-one-pass-faster-than-100",
                "content": "*Please **UpVote** if you like the solution **Happy Coding** !!!*\\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\\n    int m = nums.length, n = nums[0].length;\\n    if (r * c != m * n)\\n        return nums;\\n    int[][] reshaped = new int[r][c];\\n    for (int i = 0; i < r * c; i++)\\n        reshaped[i/c][i%c] = nums[i/n][i%n];\\n    return reshaped;\\n }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\\n    int m = nums.length, n = nums[0].length;\\n    if (r * c != m * n)\\n        return nums;\\n    int[][] reshaped = new int[r][c];\\n    for (int i = 0; i < r * c; i++)\\n        reshaped[i/c][i%c] = nums[i/n][i%n];\\n    return reshaped;\\n }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065777,
                "title": "beats-100-simple-and-easy-to-understand-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = mat.size() , n= mat[0].size();\\n        vector<vector<int>>v(r,vector<int>(c));\\n        queue<int>q;\\n        if(m*n == r*c){\\n            for(int i=0;i<m;i++){\\n                for(int j=0;j<n;j++){\\n                    q.push(mat[i][j]);\\n                }\\n            }\\n            for(int i=0;i<r;i++){\\n                for(int j=0;j<c;j++){\\n                    v[i][j] = q.front();\\n                    q.pop();\\n                }\\n            }\\n            return v;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = mat.size() , n= mat[0].size();\\n        vector<vector<int>>v(r,vector<int>(c));\\n        queue<int>q;\\n        if(m*n == r*c){\\n            for(int i=0;i<m;i++){\\n                for(int j=0;j<n;j++){\\n                    q.push(mat[i][j]);\\n                }\\n            }\\n            for(int i=0;i<r;i++){\\n                for(int j=0;j<c;j++){\\n                    v[i][j] = q.front();\\n                    q.pop();\\n                }\\n            }\\n            return v;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317198,
                "title": "python-one-pass-solution-explained",
                "content": "First approach is to reshape to line and then reshape it to new shape. However we can do smarter: just iterate over all elements line by line and use `res[count//c][count\\\\%c] = nums[i][j]` to fill element by element. \\n\\n#### Complexity\\nTime complexity is `O(mn)`, space complexity is `O(mn)`, but in fact it is `O(1)` if we do not count output array.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def matrixReshape(self, nums, r, c):\\n        m, n, count = len(nums), len(nums[0]), 0\\n        if m*n != r*c: return nums\\n        res = [[0] * c for _ in range(r)]\\n        for i, j in product(range(m), range(n)):\\n            res[count//c][count%c] = nums[i][j]\\n            count += 1      \\n        return res\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math",
                    "Matrix"
                ],
                "code": "```python\\nclass Solution:\\n    def matrixReshape(self, nums, r, c):\\n        m, n, count = len(nums), len(nums[0]), 0\\n        if m*n != r*c: return nums\\n        res = [[0] * c for _ in range(r)]\\n        for i, j in product(range(m), range(n)):\\n            res[count//c][count%c] = nums[i][j]\\n            count += 1      \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317153,
                "title": "reshape-the-matrix-one-loop-clean-and-easy-solution",
                "content": "There\\'s nothing much to this problem - Just check if total elements in both matrices will be same and then transform. I have mentioned two approaches below.\\n\\n\\u2714\\uFE0F ***Solution (Row-First Approach)***\\n\\nIterate each row column-by-column, wrap around when you reach the end on one row and move to the next row. Here, we are copying all elements of one row and then moving on to the next row.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = size(mat), n = size(mat[0]), total = m * n;\\n        if(r * c != total) return mat;\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        for(int i = 0; i < total; i++) \\n            ans[i / c][i % c] = mat[i / n][i % n];\\n        return ans;\\n    }\\n};\\n```\\n\\n<blockquote>\\n<details>\\n<summary><b>\\u2714\\uFE0F Commented Solution</b></summary>\\n\\n\\nIf the above appraoch was not clear, you can refer the below commented code -\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = size(mat), n = size(mat[0]), total = m * n;\\n        if(r * c != total) return mat;             // return if total elements don\\'t match\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        int i = 0, j = 0, new_i = 0, new_j = 0;    // i, j iterates over old matrix | new_i, new_j iterates over new matrix\\n        while(total--) {\\n            ans[new_i][new_j] = mat[i][j]; \\n            j++, new_j++;                          // move to next column in both matrix\\n            if(j == n) j = 0, i++;                 // start from beginning of next row when you reach the end of row in old matrix\\n            if(new_j == c) new_j = 0, new_i++;     // start from beginning of next row when you reach the end of row in new matrix\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n</details>\\n</blockquote>\\n\\n***Time Complexity :*** `O(r*c)`\\n***Space Complexity :*** `O(r*c)`\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Column-First Appraoch)***\\n\\nAll other posts have mentioned the first approach. It might be a good follow-up to try implementing it using column-first approach.\\n\\nIterate each column row-by-row, wrap around when you reach the end on one column and then move to the next column. Here, we are copying all elements of one column and then moving on to the next column.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = size(mat), n = size(mat[0]), total = m * n;\\n        if(r * c != total) return mat;   \\n        vector<vector<int>> ans(r, vector<int>(c));\\n        for(int col = 0; col < n; col++) {\\n            for(int row = 0; row < m; row++) {\\n                int new_row = (n * row + col) / c;\\n                int new_col = (n * row + col) % c;\\n                ans[new_row][new_col] = mat[row][col];                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n<blockquote>\\n<details>\\n<summary><b>\\u2714\\uFE0F Single-Loop Solution</b></summary>\\n\\nIf anyone figures out a cleaner code than the following version, please let me know :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = size(mat), n = size(mat[0]), total = m * n;\\n        if(r * c != total) return mat;   \\n        vector<vector<int>> ans(r, vector<int>(c));\\n        for(int i = 0; i < total; i++) \\n            ans[(i%m * n + i/m) / c][(i%m * n + i/m) % c] = mat[i % m][i / m];\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n</details>\\n</blockquote>\\n\\n***Time Complexity :*** `O(r*c)`\\n***Space Complexity :*** `O(r*c)`\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = size(mat), n = size(mat[0]), total = m * n;\\n        if(r * c != total) return mat;\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        for(int i = 0; i < total; i++) \\n            ans[i / c][i % c] = mat[i / n][i % n];\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = size(mat), n = size(mat[0]), total = m * n;\\n        if(r * c != total) return mat;             // return if total elements don\\'t match\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        int i = 0, j = 0, new_i = 0, new_j = 0;    // i, j iterates over old matrix | new_i, new_j iterates over new matrix\\n        while(total--) {\\n            ans[new_i][new_j] = mat[i][j]; \\n            j++, new_j++;                          // move to next column in both matrix\\n            if(j == n) j = 0, i++;                 // start from beginning of next row when you reach the end of row in old matrix\\n            if(new_j == c) new_j = 0, new_i++;     // start from beginning of next row when you reach the end of row in new matrix\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = size(mat), n = size(mat[0]), total = m * n;\\n        if(r * c != total) return mat;   \\n        vector<vector<int>> ans(r, vector<int>(c));\\n        for(int col = 0; col < n; col++) {\\n            for(int row = 0; row < m; row++) {\\n                int new_row = (n * row + col) / c;\\n                int new_col = (n * row + col) % c;\\n                ans[new_row][new_col] = mat[row][col];                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = size(mat), n = size(mat[0]), total = m * n;\\n        if(r * c != total) return mat;   \\n        vector<vector<int>> ans(r, vector<int>(c));\\n        for(int i = 0; i < total; i++) \\n            ans[(i%m * n + i/m) / c][(i%m * n + i/m) % c] = mat[i % m][i / m];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936653,
                "title": "c-easy-solution-two-approaches",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n\\t\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        if(m*n!=r*c)return mat;\\n        vector<vector<int>>newm(r,vector<int>(c));\\n         for(int i=0;i<m*n;i++)\\n        {\\n           newm[i/c][i%c]=mat[i/n][i%n];\\n        }\\n        return newm;\\n         }\\n};\\n2nd solution\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n\\t\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        int ans=m*n;\\n        int ans1=r*c;\\n        if(ans!=ans1) return mat;\\n        int nc=0,nr=0;\\n        vector<vector<int>>v(r,vector<int>(c));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<mat[i].size();j++)\\n            {\\n                if(nc==c)\\n                {\\n                    nr++;\\n                    nc=0;\\n                }\\n                v[nr][nc]=mat[i][j];\\n                nc++;\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n**Please do upvote if it helped**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n\\t\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        if(m*n!=r*c)return mat;\\n        vector<vector<int>>newm(r,vector<int>(c));\\n         for(int i=0;i<m*n;i++)\\n        {\\n           newm[i/c][i%c]=mat[i/n][i%n];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1555025,
                "title": "easy-python-solution-faster-than-99-3-76-ms-with-comments",
                "content": "# Easy Python Solution | Faster than 99.3% (76 ms) | With Comments\\n**Runtime: 76 ms, faster than 99.30% of Python3 online submissions for Reshape the Matrix.\\nMemory Usage: 15 MB**\\n```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        rw = len(mat)\\n        cl = len(mat[0])\\n        old = rw * cl\\n        new = r * c\\n\\t\\t\\n\\t\\t# checking if number of elements remains the same\\n        if old != new:\\n            return mat\\n\\n        old = [ i for e in mat for i in e]\\n        new = []\\n\\n        a = 0\\n        for i in range(r):\\n            temp = []\\n            for j in range(c):\\n                temp.append(old[a])\\n                a += 1\\n            new.append(temp)\\n\\n        return new\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        rw = len(mat)\\n        cl = len(mat[0])\\n        old = rw * cl\\n        new = r * c\\n\\t\\t\\n\\t\\t# checking if number of elements remains the same\\n        if old != new:\\n            return mat\\n\\n        old = [ i for e in mat for i in e]\\n        new = []\\n\\n        a = 0\\n        for i in range(r):\\n            temp = []\\n            for j in range(c):\\n                temp.append(old[a])\\n                a += 1\\n            new.append(temp)\\n\\n        return new\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488653,
                "title": "javascript-js-3-liner-90-faster-solution",
                "content": "```\\nvar matrixReshape = function(mat, r, c) {\\n    const flat = mat.flat()\\n    if (flat.length !== r*c) return mat;\\n    return [...Array(r)].map(() => flat.splice(0,c)) \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar matrixReshape = function(mat, r, c) {\\n    const flat = mat.flat()\\n    if (flat.length !== r*c) return mat;\\n    return [...Array(r)].map(() => flat.splice(0,c)) \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2791221,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {\\n        int m = nums.size(), n = nums[0].size();\\n        if (m * n != r * c) {\\n            return nums;\\n        }\\n\\n        vector<vector<int>> res(r, vector<int>(c, 0));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int k = i * n + j;\\n                res[k / c][k % c] = nums[i][j];\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {\\n        int m = nums.size(), n = nums[0].size();\\n        if (m * n != r * c) {\\n            return nums;\\n        }\\n\\n        vector<vector<int>> res(r, vector<int>(c, 0));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int k = i * n + j;\\n                res[k / c][k % c] = nums[i][j];\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102532,
                "title": "a-few-javascript-solutions",
                "content": "The intuitive way:\\n```\\nvar matrixReshape = function(nums, h, w) {\\n    const m = nums.length, n = nums[0].length;\\n    if (m * n !== h * w) return nums;\\n    const res = [];\\n    for (let i = 0, r = 0; r < m; r++) {\\n        for (let c = 0; c < n; c++, i++) {\\n            let rr = Math.floor(i / w);\\n            if (!res[rr]) res.push([]);\\n            res[rr].push(nums[r][c]);\\n        }\\n    }\\n    return res;\\n};\\n```\\nOne loop:\\n```\\nvar matrixReshape = function(nums, h, w) {\\n    const m = nums.length, n = nums[0].length;\\n    if (m * n !== h * w) return nums;\\n    const res = [];\\n    for (let i = 0; i < m * n; i++) {\\n        let r = Math.floor(i / w);\\n        if (!res[r]) res.push([]);\\n        res[r].push(nums[Math.floor(i / n)][i % n]);\\n    }\\n    return res;\\n};\\n```\\nTwo-liner:\\n```\\nvar matrixReshape = function(nums, h, w) {\\n    const all = nums.reduce((all, row) => [...all, ...row], []);\\n    return all.length === h * w ? new Array(h).fill(0).map((row, r) => all.slice(r * w, r * w + w)) : nums;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar matrixReshape = function(nums, h, w) {\\n    const m = nums.length, n = nums[0].length;\\n    if (m * n !== h * w) return nums;\\n    const res = [];\\n    for (let i = 0, r = 0; r < m; r++) {\\n        for (let c = 0; c < n; c++, i++) {\\n            let rr = Math.floor(i / w);\\n            if (!res[rr]) res.push([]);\\n            res[rr].push(nums[r][c]);\\n        }\\n    }\\n    return res;\\n};\\n```\n```\\nvar matrixReshape = function(nums, h, w) {\\n    const m = nums.length, n = nums[0].length;\\n    if (m * n !== h * w) return nums;\\n    const res = [];\\n    for (let i = 0; i < m * n; i++) {\\n        let r = Math.floor(i / w);\\n        if (!res[r]) res.push([]);\\n        res[r].push(nums[Math.floor(i / n)][i % n]);\\n    }\\n    return res;\\n};\\n```\n```\\nvar matrixReshape = function(nums, h, w) {\\n    const all = nums.reduce((all, row) => [...all, ...row], []);\\n    return all.length === h * w ? new Array(h).fill(0).map((row, r) => all.slice(r * w, r * w + w)) : nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1454434,
                "title": "c-easy-to-understand-fast-3-methods",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n\\n**1st method**\\n```\\nclass Solution{\\n    public:\\n     vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n     int n=mat.size(),m=mat[0].size();\\n         int all=n*m;\\n         if(all!=r*c)\\n          return mat;   \\n     vector<vector<int>> ans(r,vector<int>(c,0));\\n        for(int i=0;i<all;i++)\\n        {\\n            ans[i/c][i%c]=mat[i/m][i%m];\\n        }\\n        return ans; \\n     }\\n};\\n```\\n**2nd method**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n     int n=mat.size(),m=mat[0].size(),k=0;\\n    if(c*r!=n*m)\\n        return mat;\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n     for(int i=0;i<n;i++)\\n        {\\n         for(int j=0;j<m;j++)\\n         {\\n         v.push_back(mat[i][j]);\\n             k++;\\n             if(k==c)\\n             {\\n                k=0; \\n                ans.push_back(v); \\n                v.clear();    \\n             }\\n        }\\n     }\\n        return ans;\\n    }\\n};\\n```\\n**Likewise,**\\n```\\nclass Solution{\\n    public:\\n     vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n      int n=mat.size(),m=mat[0].size();\\n         if(m*n!=r*c)\\n          return mat;\\n          vector<vector<int>> ans(r, vector<int>(c, 0));\\n         for(int i=0;i<n;i++)\\n         {\\n             for(int j=0;j<m;j++)\\n             {\\n                int k=m*i+j;\\n                 ans[k/c][k%c]=mat[i][j];\\n             }\\n         }\\n         return ans;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution{\\n    public:\\n     vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n     int n=mat.size(),m=mat[0].size();\\n         int all=n*m;\\n         if(all!=r*c)\\n          return mat;   \\n     vector<vector<int>> ans(r,vector<int>(c,0));\\n        for(int i=0;i<all;i++)\\n        {\\n            ans[i/c][i%c]=mat[i/m][i%m];\\n        }\\n        return ans; \\n     }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n     int n=mat.size(),m=mat[0].size(),k=0;\\n    if(c*r!=n*m)\\n        return mat;\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n     for(int i=0;i<n;i++)\\n        {\\n         for(int j=0;j<m;j++)\\n         {\\n         v.push_back(mat[i][j]);\\n             k++;\\n             if(k==c)\\n             {\\n                k=0; \\n                ans.push_back(v); \\n                v.clear();    \\n             }\\n        }\\n     }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution{\\n    public:\\n     vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n      int n=mat.size(),m=mat[0].size();\\n         if(m*n!=r*c)\\n          return mat;\\n          vector<vector<int>> ans(r, vector<int>(c, 0));\\n         for(int i=0;i<n;i++)\\n         {\\n             for(int j=0;j<m;j++)\\n             {\\n                int k=m*i+j;\\n                 ans[k/c][k%c]=mat[i][j];\\n             }\\n         }\\n         return ans;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724341,
                "title": "java-0ms-100-faster-vs-loops-detailed-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/9f25e6a9-328b-4b7c-8a55-2ac7e0103107_1666241352.6408157.png)\\n\\nHere are two solutions to this problem. One uses two loops, the other uses a single loop. The winner is announced at the end.\\n# 2 Loops \\uD83C\\uDF4D\\uD83C\\uDF4D \\n```\\n/**\\n * Reshape the Matrix\\n * In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new\\n * one with a different size r x c keeping its original data.\\n *\\n * You are given an m x n matrix mat and two integers r and c representing the number of rows and\\n * the number of columns of the wanted reshaped matrix.\\n *\\n * The reshaped matrix should be filled with all the elements of the original matrix in the same\\n * row-traversing order as they were.\\n *\\n * If the reshape operation with given parameters is possible and legal, output the new reshaped\\n * matrix; Otherwise, output the original matrix.\\n * \\n * Constraints:\\n * m == mat.length\\n * n == mat[i].length\\n * 1 <= m, n <= 100\\n * -1000 <= mat[i][j] <= 1000\\n * 1 <= r, c <= 300\\n */\\nclass Solution {\\n    /*\\n     * To fill in the reshaped \\'ret\\' matrix, this algorithm has two loops. The outer loop\\n     * iterates over the rows of mat; the inner loop iterates over the cols of mat.\\n     *\\n     * Example:\\n     *\\n     *                                        row 0   1\\n     *                                      col ---------\\n     *         row 0   1   2                 0  | a | b |\\n     *       col  ------------                  |-------|\\n     *        0  | a | b | c |               1  | c | d |\\n     *           |-----------|   ------->       |-------|\\n     *        1  | d | e | f |               2  | e | f |\\n     *            -----------                   |-------|\\n     *\\n     *           mat matrix                    ret matrix\\n     *         mr = 1, mc = 3                  r = 3, c = 2\\n     *\\n     *\\n     *        -------- mat --------------    ------- ret ----------------\\n     *  i j k     mat[i][j]                  ret[k/c][k%c]\\n     *  - - - ---------------------------    ----------------------------\\n     *  0 0 0     mat[0,0] = a           --> ret[0/2][0/2] = ret[0][0]\\n     *  0 1 1     mat[0,1] = b           --> ret[1/2][1/2] = ret[0][1]\\n     *  0 2 2     mat[0,2] = c           --> ret[2/2][2/2] = ret[1][0]\\n     *  1 0 3     mat[1,0] = d           --> ret[3/2][3/2] = ret[1][1]\\n     *  1 1 4     mat[1,1] = e           --> ret[4/2][4/2] = ret[2][0]\\n     *  1 2 5     mat[1,2] = f           --> ret[5/2][5/2] = ret[2][1]\\n     *\\n     * The total number of division operations of the two loops is n * 2,\\n     * where n = mr * mc. This is half as many division operations as the\\n     * single-loop version below.\\n     */\\n\\tpublic int[][] matrixReshape(final int[][] mat, final int r, final int c) {\\n         final int mr = mat.length;\\n         final int mc =  mat[0].length;\\n         final int n =  mr * mc;\\n\\n        // check arguments\\n        if (r * c != n) {\\n            return mat;\\n        }\\n\\n         // create reshaped matrix\\n         final int[][] ret = new int[r][c];\\n         int k = 0; // number of cells filled in so far\\n         for (int i = 0; i < mr; i++) {\\n             for (int j = 0; j < mc; j++) {\\n                 ret[k / c][k % c] = mat[i][j]; // see explanation above\\n                 k++;\\n             }\\n         }\\n         return ret;\\n     }\\n```\\n---\\n# Single Loop \\uD83C\\uDF4D\\n```\\n/*\\n * To fill in the reshaped \\'ret\\' matrix, this algorithm iterates over n elements\\n * where n is the rows multiplied by the columns.\\n *\\n * Example:\\n *\\n *                                        row 0   1\\n *                                      col ---------\\n *         row 0   1   2                 0  | a | b |\\n *       col  ------------                  |-------|\\n *        0  | a | b | c |               1  | c | d |\\n *           |-----------|   ------->       |-------|\\n *        1  | d | e | f |               2  | e | f |\\n *            -----------                   |-------|\\n *\\n *           mat matrix                    ret matrix\\n *         mr = 1, mc = 3                  r = 3, c = 2\\n *\\n *\\n *    ----------- mat ------------     ----------- mat ------------\\n *  i      mat[i/mc][i%mc]             ret[i/c][i%c]\\n *  - ----------------------------     ----------------------------\\n *  0 mat[0/3][0%3] = mat[0,0] = a --> ret[0/2][0/2] = ret[0][0]\\n *  1 mat[1/3][1%3] = mat[0,1] = b --> ret[1/2][1/2] = ret[0][1]\\n *  2 mat[2/3][2%3] = mat[0,2] = c --> ret[2/2][2/2] = ret[1][0]\\n *  3 mat[3/3][3%3] = mat[1,0] = d --> ret[3/2][3/2] = ret[1][1]\\n *  4 mat[4/3][4%3] = mat[1,1] = e --> ret[4/2][4/2] = ret[2][0]\\n *  5 mat[5/3][5%3] = mat[1,2] = f --> ret[5/2][5/2] = ret[2][1]\\n *\\n * The total number of division operations of the single loop is n * 4,\\n * where n = mr * mc. This is twice as many division operations as the\\n * double-loop version above.\\n */\\n    public int[][] matrixReshape(final int[][] mat, final int r, final int c) {\\n        final int mr = mat.length;\\n        final int mc =  mat[0].length;\\n        final int n =  mr * mc;\\n\\n        // check arguments\\n        if (r * c != n) {\\n            return mat;\\n        }\\n\\n        // create reshaped matrix\\n        final int[][] ret = new int[r][c];\\n        for (int i = 0; i < n; i++) {\\n            ret[i / c][i % c] = mat[i / mc][i % mc]; // see explanation above\\n        }\\n        return ret;\\n    }\\n}\\n```\\n---\\n# Comparison\\uD83C\\uDF4Dvs \\uD83C\\uDF4D\\uD83C\\uDF4D\\n\\nBoth solutions iterate over n = r * c elements. The first solution pays the cost of having additional int variables j and k, but that allows it to save 2 division operations per iteration as compared to the second solution. Also, the first solution has less cognitive complexity imo. Based on these two factors, the winner is \\uD83E\\uDD41... 2 fruit loops!\\n![image](https://assets.leetcode.com/users/images/59a34a35-c78f-4082-b31a-03d743ee8b88_1666242407.207343.png)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Reshape the Matrix\\n * In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new\\n * one with a different size r x c keeping its original data.\\n *\\n * You are given an m x n matrix mat and two integers r and c representing the number of rows and\\n * the number of columns of the wanted reshaped matrix.\\n *\\n * The reshaped matrix should be filled with all the elements of the original matrix in the same\\n * row-traversing order as they were.\\n *\\n * If the reshape operation with given parameters is possible and legal, output the new reshaped\\n * matrix; Otherwise, output the original matrix.\\n * \\n * Constraints:\\n * m == mat.length\\n * n == mat[i].length\\n * 1 <= m, n <= 100\\n * -1000 <= mat[i][j] <= 1000\\n * 1 <= r, c <= 300\\n */\\nclass Solution {\\n    /*\\n     * To fill in the reshaped \\'ret\\' matrix, this algorithm has two loops. The outer loop\\n     * iterates over the rows of mat; the inner loop iterates over the cols of mat.\\n     *\\n     * Example:\\n     *\\n     *                                        row 0   1\\n     *                                      col ---------\\n     *         row 0   1   2                 0  | a | b |\\n     *       col  ------------                  |-------|\\n     *        0  | a | b | c |               1  | c | d |\\n     *           |-----------|   ------->       |-------|\\n     *        1  | d | e | f |               2  | e | f |\\n     *            -----------                   |-------|\\n     *\\n     *           mat matrix                    ret matrix\\n     *         mr = 1, mc = 3                  r = 3, c = 2\\n     *\\n     *\\n     *        -------- mat --------------    ------- ret ----------------\\n     *  i j k     mat[i][j]                  ret[k/c][k%c]\\n     *  - - - ---------------------------    ----------------------------\\n     *  0 0 0     mat[0,0] = a           --> ret[0/2][0/2] = ret[0][0]\\n     *  0 1 1     mat[0,1] = b           --> ret[1/2][1/2] = ret[0][1]\\n     *  0 2 2     mat[0,2] = c           --> ret[2/2][2/2] = ret[1][0]\\n     *  1 0 3     mat[1,0] = d           --> ret[3/2][3/2] = ret[1][1]\\n     *  1 1 4     mat[1,1] = e           --> ret[4/2][4/2] = ret[2][0]\\n     *  1 2 5     mat[1,2] = f           --> ret[5/2][5/2] = ret[2][1]\\n     *\\n     * The total number of division operations of the two loops is n * 2,\\n     * where n = mr * mc. This is half as many division operations as the\\n     * single-loop version below.\\n     */\\n\\tpublic int[][] matrixReshape(final int[][] mat, final int r, final int c) {\\n         final int mr = mat.length;\\n         final int mc =  mat[0].length;\\n         final int n =  mr * mc;\\n\\n        // check arguments\\n        if (r * c != n) {\\n            return mat;\\n        }\\n\\n         // create reshaped matrix\\n         final int[][] ret = new int[r][c];\\n         int k = 0; // number of cells filled in so far\\n         for (int i = 0; i < mr; i++) {\\n             for (int j = 0; j < mc; j++) {\\n                 ret[k / c][k % c] = mat[i][j]; // see explanation above\\n                 k++;\\n             }\\n         }\\n         return ret;\\n     }\\n```\n```\\n/*\\n * To fill in the reshaped \\'ret\\' matrix, this algorithm iterates over n elements\\n * where n is the rows multiplied by the columns.\\n *\\n * Example:\\n *\\n *                                        row 0   1\\n *                                      col ---------\\n *         row 0   1   2                 0  | a | b |\\n *       col  ------------                  |-------|\\n *        0  | a | b | c |               1  | c | d |\\n *           |-----------|   ------->       |-------|\\n *        1  | d | e | f |               2  | e | f |\\n *            -----------                   |-------|\\n *\\n *           mat matrix                    ret matrix\\n *         mr = 1, mc = 3                  r = 3, c = 2\\n *\\n *\\n *    ----------- mat ------------     ----------- mat ------------\\n *  i      mat[i/mc][i%mc]             ret[i/c][i%c]\\n *  - ----------------------------     ----------------------------\\n *  0 mat[0/3][0%3] = mat[0,0] = a --> ret[0/2][0/2] = ret[0][0]\\n *  1 mat[1/3][1%3] = mat[0,1] = b --> ret[1/2][1/2] = ret[0][1]\\n *  2 mat[2/3][2%3] = mat[0,2] = c --> ret[2/2][2/2] = ret[1][0]\\n *  3 mat[3/3][3%3] = mat[1,0] = d --> ret[3/2][3/2] = ret[1][1]\\n *  4 mat[4/3][4%3] = mat[1,1] = e --> ret[4/2][4/2] = ret[2][0]\\n *  5 mat[5/3][5%3] = mat[1,2] = f --> ret[5/2][5/2] = ret[2][1]\\n *\\n * The total number of division operations of the single loop is n * 4,\\n * where n = mr * mc. This is twice as many division operations as the\\n * double-loop version above.\\n */\\n    public int[][] matrixReshape(final int[][] mat, final int r, final int c) {\\n        final int mr = mat.length;\\n        final int mc =  mat[0].length;\\n        final int n =  mr * mc;\\n\\n        // check arguments\\n        if (r * c != n) {\\n            return mat;\\n        }\\n\\n        // create reshaped matrix\\n        final int[][] ret = new int[r][c];\\n        for (int i = 0; i < n; i++) {\\n            ret[i / c][i % c] = mat[i / mc][i % mc]; // see explanation above\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317275,
                "title": "6-lines-of-code-python",
                "content": "\\n#  please upvote me it would encourage me alot\\n\\n```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        list1,matrix=list(chain.from_iterable(mat)),[]\\n        if len(mat)*len(mat[0])!=r*c:\\n            return mat\\n        for i in range(0,len(list1),c):\\n            matrix.append(list1[i:i+c])\\n        return matrix\\n        \\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        list1,matrix=list(chain.from_iterable(mat)),[]\\n        if len(mat)*len(mat[0])!=r*c:\\n            return mat\\n        for i in range(0,len(list1),c):\\n            matrix.append(list1[i:i+c])\\n        return matrix\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767752,
                "title": "simple-java-solution",
                "content": "```\\npublic int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int n=mat[0].length;\\n        if(r*c!=mat.length*n) {\\n            return mat;\\n        }\\n        int[][] ans = new int[r][c];\\n        for(int i=0;i<r*c;i++) {\\n            ans[i/c][i%c]=mat[i/n][i%n];\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int n=mat[0].length;\\n        if(r*c!=mat.length*n) {\\n            return mat;\\n        }\\n        int[][] ans = new int[r][c];\\n        for(int i=0;i<r*c;i++) {\\n            ans[i/c][i%c]=mat[i/n][i%n];\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1726361,
                "title": "c-reshape-the-matrix-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        \\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        if(m * n != r * c) {\\n            return mat;\\n        }\\n        \\n        vector<vector<int>> res(r, vector<int>(c));\\n        int row = 0, col = 0;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                res[row][col] = mat[i][j];\\n                col += 1;\\n                if(col == c) {\\n                    row += 1;\\n                    col = 0;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nPlease **UpVote**, if you understood the problem.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        \\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        if(m * n != r * c) {\\n            return mat;\\n        }\\n        \\n        vector<vector<int>> res(r, vector<int>(c));\\n        int row = 0, col = 0;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                res[row][col] = mat[i][j];\\n                col += 1;\\n                if(col == c) {\\n                    row += 1;\\n                    col = 0;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317465,
                "title": "reshape-the-matrix-simple-solution",
                "content": "***Solution:(Accepted)***\\n```\\nAs the question is very easy to follow but we need to keep these condition in mind,\\n1) If number of elements in current matrix != r * c (Invalid case) then we have to return the current matrix.\\n2) we will take two iterators to fill out new matrix ,\\n\\tRow iterator: ri\\n\\tCol iterator: ci\\n3) if at any point our ci==c (It means we successfully covered the row), then we have to increment our row counter,\\n\\ti.e, ri++,\\n\\t--> As for the next row ci should start with 0 , so we make ci=0 also,\\n4) We follow the same process (step 2 and 3) until every element is added to new matrix.\\n\\nPlease find the solution below:\\n```\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) \\n    {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        if(m*n!=r*c)\\n            return mat;\\n        vector<vector<int>> res(r);\\n        int ri=0,ci=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(ci==c)\\n                {\\n                    ri=ri+1;\\n                    ci=0;\\n                }\\n                res[ri].push_back(mat[i][j]);\\n                ci=ci+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n***\\n**if you found the post useful then do consider it for Upvotes :), Happy coding**\\n***\\n\\n",
                "solutionTags": [],
                "code": "```\\nAs the question is very easy to follow but we need to keep these condition in mind,\\n1) If number of elements in current matrix != r * c (Invalid case) then we have to return the current matrix.\\n2) we will take two iterators to fill out new matrix ,\\n\\tRow iterator: ri\\n\\tCol iterator: ci\\n3) if at any point our ci==c (It means we successfully covered the row), then we have to increment our row counter,\\n\\ti.e, ri++,\\n\\t--> As for the next row ci should start with 0 , so we make ci=0 also,\\n4) We follow the same process (step 2 and 3) until every element is added to new matrix.\\n\\nPlease find the solution below:\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) \\n    {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        if(m*n!=r*c)\\n            return mat;\\n        vector<vector<int>> res(r);\\n        int ri=0,ci=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(ci==c)\\n                {\\n                    ri=ri+1;\\n                    ci=0;\\n                }\\n                res[ri].push_back(mat[i][j]);\\n                ci=ci+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317380,
                "title": "python-short-easy-list-comprehension",
                "content": "# Reshape the Matrix\\n**Idea**\\n* Fisrt we check if the matrix can be transformed\\n* Form one Dimension matrix `OneD` from given matrix **mat** by traversing row-wise\\n* Then enter elements in the result of dimensions `r*c` one by one \\xA0 \\xA0 \\xA0\\n\\n**Complexity**\\n* *Time Complexity* :- `O(m*n)`\\n* *Space Complexity* :- `O(m*n)`\\n\\n```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        if not m*n == r*c: return mat\\n        OneD = [mat[i][j] for i in range(m) for j in range(n)]\\n        return [OneD[i*c:(i+1)*c] for i in range(r)]\\n```\\n\\n*Please upvote if you like the solution and comment if have any queries*. \\xA0 \\xA0 \\xA0 \\xA0",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        if not m*n == r*c: return mat\\n        OneD = [mat[i][j] for i in range(m) for j in range(n)]\\n        return [OneD[i*c:(i+1)*c] for i in range(r)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317149,
                "title": "c-easy-implementation-for-beginners",
                "content": "**Approach:** Firstly, check the dimensions required to reshape the matrix. If the multiplication of rows and columns of the original matrix is not equal to the multiplication of rows and columns of the required matrix, just return the given matrix.\\n\\nOtherwise,\\nInitialise a variable **col as 0** and increment it till it reaches **c** i.e., number of columns required to reshape.\\nAs soon as the variable **col** reaches **c**, all the elements we came across so far will be considered as a **row** and initialise **col as 0** again.\\n\\nKeep doing the process until the end which is **n * m** where **n is size of the row** and **m is size of the column** of the given matrix and return the **modified / reshaped** matrix.\\n\\n\\n**Solution:**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        \\n        if((r * c) != (mat.size() * mat[0].size()))\\n            return mat;\\n        \\n        vector<vector<int>> fans;\\n        \\n        int col = 0;\\n        vector<int> ans;\\n        for(int i = 0; i < mat.size(); i++)\\n        {\\n            \\n            for(int j = 0; j < mat[i].size(); j++)\\n            {\\n                if(c == col)\\n                {\\n                    col = 0;\\n                    fans.push_back(ans);\\n                    ans.clear();\\n                }\\n                ans.push_back(mat[i][j]);\\n                col++;\\n            }\\n        }\\n        \\n        fans.push_back(ans);\\n        \\n        return fans;\\n    }\\n};\\n```\\n\\n\\n**Time Complexity: O(n * m)**, where n is number of rows and m is number of columns.",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        \\n        if((r * c) != (mat.size() * mat[0].size()))\\n            return mat;\\n        \\n        vector<vector<int>> fans;\\n        \\n        int col = 0;\\n        vector<int> ans;\\n        for(int i = 0; i < mat.size(); i++)\\n        {\\n            \\n            for(int j = 0; j < mat[i].size(); j++)\\n            {\\n                if(c == col)\\n                {\\n                    col = 0;\\n                    fans.push_back(ans);\\n                    ans.clear();\\n                }\\n                ans.push_back(mat[i][j]);\\n                col++;\\n            }\\n        }\\n        \\n        fans.push_back(ans);\\n        \\n        return fans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317145,
                "title": "c-two-simple-and-easy-solutions-6-lines",
                "content": "**First Solution - Intuitive:\\nJust loop with nested loop through the original matrix, and keep track of the row and col in the new matrix.**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int area = mat.size() * mat[0].size();\\n        if (area != r * c) return mat;\\n        \\n        vector<vector<int>> res(r, vector<int>(c));\\n        int row = 0, col = 0;\\n        \\n        for (int i = 0; i < mat.size(); i++) {\\n            for (int j = 0; j < mat[i].size(); j++) {\\n                \\n                res[row][col] = mat[i][j];\\n                col++;\\n                \\n                if (col == c) {\\n                    col = 0; \\n                    row++;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Second Solution - Shorter:\\nSame idea, just with only one loop, using the same iterator to figure out where we are up to in both matrices.**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int area = mat.size() * mat[0].size();\\n        if (area != r * c) return mat;\\n        \\n        vector<vector<int>> res(r, vector<int>(c));\\n        \\n        for (int i = 0; i < area; i++) {\\n            res[i/c][i%c] = mat[i/mat[0].size()][i%mat[0].size()];\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int area = mat.size() * mat[0].size();\\n        if (area != r * c) return mat;\\n        \\n        vector<vector<int>> res(r, vector<int>(c));\\n        int row = 0, col = 0;\\n        \\n        for (int i = 0; i < mat.size(); i++) {\\n            for (int j = 0; j < mat[i].size(); j++) {\\n                \\n                res[row][col] = mat[i][j];\\n                col++;\\n                \\n                if (col == c) {\\n                    col = 0; \\n                    row++;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int area = mat.size() * mat[0].size();\\n        if (area != r * c) return mat;\\n        \\n        vector<vector<int>> res(r, vector<int>(c));\\n        \\n        for (int i = 0; i < area; i++) {\\n            res[i/c][i%c] = mat[i/mat[0].size()][i%mat[0].size()];\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102572,
                "title": "python-solution",
                "content": "I know that the code looks ugly, but it is good enough for a beginner like me :)\\n```\\nclass Solution(object):\\n    def matrixReshape(self, nums, r, c):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :type r: int\\n        :type c: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        nrows = len(nums)\\n        ncols = len(nums[0])\\n        \\n        if nrows * ncols == r * c:\\n            onedArray = []\\n            reshaped = [[0] * c for i in range(r)]\\n            for x in nums:\\n                onedArray += x\\n            for index, item in enumerate(onedArray):\\n                placeRow = index / c\\n                placeCol = index % c\\n                reshaped[placeRow][placeCol] = item\\n            return reshaped\\n        else:\\n            return nums\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def matrixReshape(self, nums, r, c):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :type r: int\\n        :type c: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        nrows = len(nums)\\n        ncols = len(nums[0])\\n        \\n        if nrows * ncols == r * c:\\n            onedArray = []\\n            reshaped = [[0] * c for i in range(r)]\\n            for x in nums:\\n                onedArray += x\\n            for index, item in enumerate(onedArray):\\n                placeRow = index / c\\n                placeCol = index % c\\n                reshaped[placeRow][placeCol] = item\\n            return reshaped\\n        else:\\n            return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318312,
                "title": "java-simple-solution-in-o-mn-time",
                "content": "\\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        if(r*c != mat.length*mat[0].length) return mat;\\n        int[][] res = new int[r][c];\\n        int ri = 0, cj = 0;\\n        for(int i=0; i<mat.length; ++i){\\n            for(int j=0; j<mat[0].length; ++j){\\n                //System.out.println(ri+\" \"+cj);\\n                res[ri][cj++] = mat[i][j];\\n                if(cj >= res[0].length){\\n                    cj = 0;\\n                    ri++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\nplease leave a like if you found this helpful\\nand leave a comment if you have any question\\nhappy coding : )",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        if(r*c != mat.length*mat[0].length) return mat;\\n        int[][] res = new int[r][c];\\n        int ri = 0, cj = 0;\\n        for(int i=0; i<mat.length; ++i){\\n            for(int j=0; j<mat[0].length; ++j){\\n                //System.out.println(ri+\" \"+cj);\\n                res[ri][cj++] = mat[i][j];\\n                if(cj >= res[0].length){\\n                    cj = 0;\\n                    ri++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317623,
                "title": "reshape-matrix-python",
                "content": "### ***Approach***:\\n\\n1) At first we will chech weather the given dimension matrix can be created or not. ***(i.e mn == rc)***\\n2) We will be **storing all** the matrix elements in a **1-d array** .\\n3) We will initilize a empty matrix of given size (r,c) .\\n4) We will Fill the initilize matrix row wise from that 1-d array\\n\\n### ***Code***\\n```\\nclass Solution:\\n    def matrixReshape(self, mat: list[list[int]], r: int, c: int) -> list[list[int]]:\\n        m = len(mat)\\n        n = len(mat[0])\\n\\t\\t# Check weather the matrix can be made by using the given r,c values.\\n        if m*n != r*c:\\n            return mat\\n\\t\\t# Storing in 1-d Array.\\n        arr = [0 for i in range(m*n)]\\n        count=0\\n        for i in range(m):\\n            for j in range(n):\\n                arr[count] = mat[i][j]\\n                count+=1\\n\\t\\t# Initilize a new Matrix with given Dimensions\\n        new_matrix = [[0 for i in range(c)] for j in range(r)]\\n        count =0\\n        for i in range(r):\\n            for j in range(c):\\n                new_matrix[i][j]=arr[count]\\n                count+=1\\n        return new_matrix\\n```\\n\\n***Time Complexity*** : O(RxC) \\n***Space Complexity*** : O(RxC) where R,C are Row and Column .\\n\\nNote: This might not the be the best or the only approach , this is just my implementation, and I wanted to make it as simple as possible.\\n\\nIf you like it Please **Upvote** it.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def matrixReshape(self, mat: list[list[int]], r: int, c: int) -> list[list[int]]:\\n        m = len(mat)\\n        n = len(mat[0])\\n\\t\\t# Check weather the matrix can be made by using the given r,c values.\\n        if m*n != r*c:\\n            return mat\\n\\t\\t# Storing in 1-d Array.\\n        arr = [0 for i in range(m*n)]\\n        count=0\\n        for i in range(m):\\n            for j in range(n):\\n                arr[count] = mat[i][j]\\n                count+=1\\n\\t\\t# Initilize a new Matrix with given Dimensions\\n        new_matrix = [[0 for i in range(c)] for j in range(r)]\\n        count =0\\n        for i in range(r):\\n            for j in range(c):\\n                new_matrix[i][j]=arr[count]\\n                count+=1\\n        return new_matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759132,
                "title": "c-solution",
                "content": "**Time complexity**: $$O(rc)$$ where r & c are the given variables for new matrix\\n\\n**Space complexity**: $$O(rc)$$ as we have a matric of size r*c to return\\n\\nThis my solution for the question:\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int r0 = mat.size(), c0 = mat[0].size();\\n        if (r0*c0 != r*c) return mat;\\n\\n        vector<int> v0(c);\\n        vector<vector<int>> v(r, v0);\\n\\n        // this is a approach to reduce the no of lines of code\\n        // as i iterates through 0 to r*c, dividing i by column would get you the row number\\n        // and the remainder would give you the current column number\\n        for (int i=0; i<r0*c0; ++i) {\\n            v[i/c][i%c] = mat[i/c0][i%c0];\\n        }\\n\\n        return v;\\n    }\\n};\\n```\\n\\n## Upvote the solution if it helped you! Happy coding :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int r0 = mat.size(), c0 = mat[0].size();\\n        if (r0*c0 != r*c) return mat;\\n\\n        vector<int> v0(c);\\n        vector<vector<int>> v(r, v0);\\n\\n        // this is a approach to reduce the no of lines of code\\n        // as i iterates through 0 to r*c, dividing i by column would get you the row number\\n        // and the remainder would give you the current column number\\n        for (int i=0; i<r0*c0; ++i) {\\n            v[i/c][i%c] = mat[i/c0][i%c0];\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671939,
                "title": "o-m-n-single-for-loop-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = size(mat), n = size(mat[0]), total = m * n;\\n        if(r * c != total) return mat;\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        for(int i = 0; i < total; i++) \\n            ans[i / c][i % c] = mat[i / n][i % n];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = size(mat), n = size(mat[0]), total = m * n;\\n        if(r * c != total) return mat;\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        for(int i = 0; i < total; i++) \\n            ans[i / c][i % c] = mat[i / n][i % n];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632327,
                "title": "javascript-two-pointer-easy-to-read-notes",
                "content": "```\\nvar matrixReshape = function(mat, r, c) {\\n    const result = [];\\n    \\n    // Detect if the matrices can\\'t map\\n    if (r * c !== mat.length * mat[0].length) return mat;\\n    \\n    // Create pointers to track the original matrix\\n    let pR = 0;\\n    let pC = 0;\\n    \\n    for (let row = 0; row < r; row++) {\\n        // Build a row to store the columns\\n        const target = [];\\n        result.push(target);\\n        \\n        for (let col = 0; col < c; col++) {\\n            // Push the new column\\n            target.push(mat[pR][pC]);\\n            \\n            // Update the pointer to look at the next matrix item\\n            pC++;\\n            \\n            // If we\\'ve hit undefined we\\'re overflowing, move to the next row and reset the columns\\n            if (mat[pR][pC] === undefined) {\\n                pR++;\\n                pC = 0;\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar matrixReshape = function(mat, r, c) {\\n    const result = [];\\n    \\n    // Detect if the matrices can\\'t map\\n    if (r * c !== mat.length * mat[0].length) return mat;\\n    \\n    // Create pointers to track the original matrix\\n    let pR = 0;\\n    let pC = 0;\\n    \\n    for (let row = 0; row < r; row++) {\\n        // Build a row to store the columns\\n        const target = [];\\n        result.push(target);\\n        \\n        for (let col = 0; col < c; col++) {\\n            // Push the new column\\n            target.push(mat[pR][pC]);\\n            \\n            // Update the pointer to look at the next matrix item\\n            pC++;\\n            \\n            // If we\\'ve hit undefined we\\'re overflowing, move to the next row and reset the columns\\n            if (mat[pR][pC] === undefined) {\\n                pR++;\\n                pC = 0;\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1474912,
                "title": "short-simple-c-solution-with-explanation",
                "content": "**Time Complexity:** O(m x n), where m is no of rows, n is no of columns in inital matrix\\n**Space Complexity:** O(1)\\n\\n**Intution:** Consider a 2D matrix arr of size m x n, and a counter, let\\'s say **t** to count the elements linearly and using it we can visualise this 2D matrix as 1D matrix. Now to convert it back to 2D matrix (which will be the solution) we can use this formula:\\n\\n**arr[i][j]** = **arr[t/no_of_columns][t%no_of_columns]**, where i, j points to particular valid index\\n\\nand it will map to the required index in the solution matirx. Try with 3-4 2D matrix of different sizes and it will become more clear.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n//      count of rows & columns of initial matrix \\n        int m = mat.size(), n = mat[0].size();\\n        \\n//      Checking if matrix can be reshaped or not\\n        if ((m*n) != (r*c)) return mat;\\n        \\n//      pointer to insert values in the new / reshaped matrix\\n        int t = 0;\\n        \\n//      vector to store the new matrix\\n        vector<vector<int>> res(r, vector<int> (c)); \\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                res[t/c][t%c] = mat[i][j];\\n                t++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nIf you liked the solution, please consider upvoting.",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n//      count of rows & columns of initial matrix \\n        int m = mat.size(), n = mat[0].size();\\n        \\n//      Checking if matrix can be reshaped or not\\n        if ((m*n) != (r*c)) return mat;\\n        \\n//      pointer to insert values in the new / reshaped matrix\\n        int t = 0;\\n        \\n//      vector to store the new matrix\\n        vector<vector<int>> res(r, vector<int> (c)); \\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                res[t/c][t%c] = mat[i][j];\\n                t++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317492,
                "title": "rust-4ms",
                "content": "```rust\\nimpl Solution {\\n    pub fn matrix_reshape(mat: Vec<Vec<i32>>, r: i32, c: i32) -> Vec<Vec<i32>> {\\n        let (r, c) = (r as usize, c as usize);\\n        let (m, n) = (mat.len(), mat[0].len());\\n        if r * c != m * n {\\n            mat\\n        } else {\\n            mat.iter()\\n                .flat_map(|r| r.iter().copied())\\n                .collect::<Vec<_>>()\\n                .chunks(c)\\n                .map(|r| r.to_vec())\\n                .collect()\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn matrix_reshape(mat: Vec<Vec<i32>>, r: i32, c: i32) -> Vec<Vec<i32>> {\\n        let (r, c) = (r as usize, c as usize);\\n        let (m, n) = (mat.len(), mat[0].len());\\n        if r * c != m * n {\\n            mat\\n        } else {\\n            mat.iter()\\n                .flat_map(|r| r.iter().copied())\\n                .collect::<Vec<_>>()\\n                .chunks(c)\\n                .map(|r| r.to_vec())\\n                .collect()\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 706795,
                "title": "c-98-54-solution",
                "content": "***Runtime: 16 ms, faster than 98.54% of C++ online submissions for Reshape the Matrix.\\nMemory Usage: 11.3 MB, less than 77.01% of C++ online submissions for Reshape the Matrix.***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {\\n        int rows = nums.size();\\n        int cols = nums[0].size();\\n        if(rows * cols != r * c || ( rows == r && cols == c)){\\n            return nums;\\n        }\\n        vector<vector<int>> result(r,vector<int>(c,0));\\n        int current = 0;\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                int x = current / cols;\\n                int y = current % cols;\\n                result[i][j] = nums[x][y];\\n                current ++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {\\n        int rows = nums.size();\\n        int cols = nums[0].size();\\n        if(rows * cols != r * c || ( rows == r && cols == c)){\\n            return nums;\\n        }\\n        vector<vector<int>> result(r,vector<int>(c,0));\\n        int current = 0;\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                int x = current / cols;\\n                int y = current % cols;\\n                result[i][j] = nums[x][y];\\n                current ++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168147,
                "title": "best-python-solution-easy-to-understand",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. --> First we should check if it is possible to reshape the given matrix to asked one. Then we make one dimensional array from given matrix (flat). After, we add the subarrays which are defined by dividing the flat array into c, r times .\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        if r*c!=len(mat)*len(mat[0]):\\n            return mat\\n        flat,ans=[],[]\\n        for i in mat:\\n            flat+=i\\n        for i in range(r):\\n            ans+=[flat[i*c:i*c+c]]\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        if r*c!=len(mat)*len(mat[0]):\\n            return mat\\n        flat,ans=[],[]\\n        for i in mat:\\n            flat+=i\\n        for i in range(r):\\n            ans+=[flat[i*c:i*c+c]]\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467505,
                "title": "hindi-java-easy-to-understand-1-ms-runtime",
                "content": "**Hindi Explanation**\\n*Please UpVote if you like this **HINDI** Explanation Happy Coding !!*\\n\\n\\n```\\nclass Solution {\\n\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n\\n        if (m * n != r * c) {\\n            return mat; // Question mein ye rule diya hua hai 4th paragraph mein - \"If the ...Otherwise, output the original matrix.\"\\n        }\\n\\n        int[][] rc = new int[r][c];\\n        int row = 0; // naya variable row ke liye\\n        int column = 0; // naya variable column ke liye\\n\\n        //ek simple nested \"for loop\",  original matrix mein traverse karne ke liye\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                rc[row][column] = mat[i][j]; // value assign kardo\\n\\n                column++;\\n                if (column == c) { //agar column variable row ke last column pe hai to \"if\" ke andar ghusjaega code\\n                    row++; //row ko 1 se bada do taki next row ko traverse karsake hum\\n                    column = 0; // column ko 0 set kardo taki nayi row ke 0 index se shuru ho naya traversal\\n                }\\n            }\\n        }\\n        return rc; // return kardo apna \"rc\" naam ka array\\n    }\\n}\\n//badhai ho aapne successfully ye code karlia hai, Jai Mata Di...\\n\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n\\n        if (m * n != r * c) {\\n            return mat; // Question mein ye rule diya hua hai 4th paragraph mein - \"If the ...Otherwise, output the original matrix.\"\\n        }\\n\\n        int[][] rc = new int[r][c];\\n        int row = 0; // naya variable row ke liye\\n        int column = 0; // naya variable column ke liye\\n\\n        //ek simple nested \"for loop\",  original matrix mein traverse karne ke liye\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                rc[row][column] = mat[i][j]; // value assign kardo\\n\\n                column++;\\n                if (column == c) { //agar column variable row ke last column pe hai to \"if\" ke andar ghusjaega code\\n                    row++; //row ko 1 se bada do taki next row ko traverse karsake hum\\n                    column = 0; // column ko 0 set kardo taki nayi row ke 0 index se shuru ho naya traversal\\n                }\\n            }\\n        }\\n        return rc; // return kardo apna \"rc\" naam ka array\\n    }\\n}\\n//badhai ho aapne successfully ye code karlia hai, Jai Mata Di...\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460619,
                "title": "java-arrays-matrix-reshape",
                "content": "\\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        if (mat.length * mat[0].length != r * c)\\n            return mat;\\n        int[][] answ = new int[r][c];\\n        for(int i = 0; i < r * c; i++)\\n            answ[i / c][i % c] = mat[i / mat[0].length][i % mat[0].length];\\n        return answ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        if (mat.length * mat[0].length != r * c)\\n            return mat;\\n        int[][] answ = new int[r][c];\\n        for(int i = 0; i < r * c; i++)\\n            answ[i / c][i % c] = mat[i / mat[0].length][i % mat[0].length];\\n        return answ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312708,
                "title": "beats-100-1-ms-easy-java-solution",
                "content": "****mat [ index / no. of column ] [ index % no. of column ]**** for both the input and output matrix can be used to insert element \\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int m=mat.length;\\n        int n=mat[0].length;\\n        if(r*c!=m*n)\\n            return mat;\\n        int [][] ans=new int[r][c];\\n        for(int i=0;i<r*c;i++)\\n            ans[i/c][i%c]=mat[i/n][i%n];\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int m=mat.length;\\n        int n=mat[0].length;\\n        if(r*c!=m*n)\\n            return mat;\\n        int [][] ans=new int[r][c];\\n        for(int i=0;i<r*c;i++)\\n            ans[i/c][i%c]=mat[i/n][i%n];\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202965,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Java Code\\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\\n        int n = nums.length, m = nums[0].length;\\n        if (r * c != n * m) return nums;\\n        int[][] res = new int[r][c];\\n        for (int i = 0; i < r * c; i++)\\n            res[i / c][i % c] = nums[i / m][i % m];\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\\n        int n = nums.length, m = nums[0].length;\\n        if (r * c != n * m) return nums;\\n        int[][] res = new int[r][c];\\n        for (int i = 0; i < r * c; i++)\\n            res[i / c][i % c] = nums[i / m][i % m];\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190693,
                "title": "python-clean-simple-o-m-n-solution",
                "content": "# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        m = len(mat)\\n        n = len(mat[0])\\n\\n        if m * n != r * c :\\n            return mat \\n\\n        cnt = 0\\n        ans = []\\n        row = []\\n        for i in range(m):\\n            for j in range(n):\\n                row.append(mat[i][j])\\n                cnt+=1\\n                if cnt == c:\\n                    ans.append(row)\\n                    row = []\\n                    cnt = 0\\n        return ans\\n```\\n## Numpy:\\n```\\nimport numpy as np\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        try:\\n            return np.reshape(mat, (r, c)).tolist()\\n        except:\\n            return mat\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        m = len(mat)\\n        n = len(mat[0])\\n\\n        if m * n != r * c :\\n            return mat \\n\\n        cnt = 0\\n        ans = []\\n        row = []\\n        for i in range(m):\\n            for j in range(n):\\n                row.append(mat[i][j])\\n                cnt+=1\\n                if cnt == c:\\n                    ans.append(row)\\n                    row = []\\n                    cnt = 0\\n        return ans\\n```\n```\\nimport numpy as np\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        try:\\n            return np.reshape(mat, (r, c)).tolist()\\n        except:\\n            return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132348,
                "title": "easy-solution-java-in-single-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(r*c)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(r*c)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        if(mat.length * mat[0].length != r*c){\\n            return mat;\\n        }\\n      \\n        int rshape[][] = new int [r][c];\\n        \\n         for (int i = 0;\\n             i < c*r; i++) {\\n \\n\\n            int row1 = i / mat[0].length;\\n            int col1 = i % mat[0].length;\\n            int row2 = i / c;\\n            int col2 = i % c;\\n\\n            rshape[row2][col2] = mat[row1][col1];\\n            \\n        }\\n       \\n        return rshape;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        if(mat.length * mat[0].length != r*c){\\n            return mat;\\n        }\\n      \\n        int rshape[][] = new int [r][c];\\n        \\n         for (int i = 0;\\n             i < c*r; i++) {\\n \\n\\n            int row1 = i / mat[0].length;\\n            int col1 = i % mat[0].length;\\n            int row2 = i / c;\\n            int col2 = i % c;\\n\\n            rshape[row2][col2] = mat[row1][col1];\\n            \\n        }\\n       \\n        return rshape;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346903,
                "title": "easy-python-solution-fast-beginner-friendly",
                "content": "**Given a matrix mat of 3 rows * 4 columns,**\\nwe want reshape it into 2 rows (r = 2) * 6 columns(c = 6):\\n\\n```\\n[[0,  1,  2,  3],\\n [4,  5,  6,  7],                 ->                [[0,  1,  2,  3,  4,  5],\\n [8,  9,  10, 11]]                                   [6,  7,  8,  9,  10, 11]]\\n```\\nStep 1: Flatten the given matrix mat to a 1-D list flatten for easier visualizations and calculations for future steps\\n\\n`flatten = [0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11]`\\nStep 2: Check whether the total number of given elements len(flatten) and the new shape r * c matches (i.e. whether \"given parameters is possible and legal\")\\n```\\n\\nr = 2, c = 6\\nr * c = 12\\n```\\nStep 3: Rearrange all elements in 1-D list flatten into the new_mat according to given number of row r and given number of columns c\\n\\n`flatten = [0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11]`\\nreshaping:\\n\\n\\t\\t\\t\\t [0,  1,  2,  3,  4,  5,   6,  7,  8,  9,  10, 11]\\n```\\nrow_index: 0\\t\\t\\t| c0  c1  c2  c3  c4  c5 |\\nrow_index: 1                           \\t\\t\\t | c0  c1  c2  c3  c4  c5 |\\n\\nindex in flatten:  [row_index * c : row_index * c + c])\\n\\n\\t\\t\\t            [0*6       :      0*6 + 6],  \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t         [1*6        :       1*6+6]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n                        [0          :           6],  \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t         [6          :          12]\\niteration 0:row_index 0\\nflatten[0 : 6]   ->   [0,  1,  2,  3,  4,  5]\\n\\nappending:\\nnew_mat = [[0,  1,  2,  3,  4,  5]]\\niteration 1: row_index 1\\nflatten[6 : 12]   ->   [6,  7,  8,  9,  10, 11]\\n\\nappending:\\nnew_mat = [[0,  1,  2,  3,  4,  5],\\n           [6,  7,  8,  9,  10, 11]]\\n```\\n\\n**Final Solution**\\n\\n```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        flatten = []\\n        new_mat = []\\n        for row in mat:\\n            for num in row:\\n                flatten.append(num)\\n                \\n        if r * c != len(flatten):   # when given parameters is NOT possible and legal\\n            return mat\\n        else:\\n            for row_index in range(r):\\n                new_mat.append(flatten[row_index * c : row_index * c + c])\\n            return new_mat\\n```\\n\\n\\n\\nAs a beginner, I am writing these all out to help myself, and hopefully also help anyone out there who is like me at the same time.\\n\\nPlease upvote\\u2B06\\uFE0F if you find this helpful or worth-reading for beginners in anyway.\\nYour upvote is much more than just supportive to me. \\uD83D\\uDE33\\uD83E\\uDD13\\uD83E\\uDD70\\n\\nIf you find this is not helpful, needs improvement, or is questionable, would you please leave a quick comment below to point out the problem before you decide to downvote? It will be very helpful for me (maybe also others) to learn as a beginner.\\n\\nThank you very much either way \\uD83E\\uDD13.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\n[[0,  1,  2,  3],\\n [4,  5,  6,  7],                 ->                [[0,  1,  2,  3,  4,  5],\\n [8,  9,  10, 11]]                                   [6,  7,  8,  9,  10, 11]]\\n```\n```\\n\\nr = 2, c = 6\\nr * c = 12\\n```\n```\\nrow_index: 0\\t\\t\\t| c0  c1  c2  c3  c4  c5 |\\nrow_index: 1                           \\t\\t\\t | c0  c1  c2  c3  c4  c5 |\\n\\nindex in flatten:  [row_index * c : row_index * c + c])\\n\\n\\t\\t\\t            [0*6       :      0*6 + 6],  \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t         [1*6        :       1*6+6]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n                        [0          :           6],  \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t         [6          :          12]\\niteration 0:row_index 0\\nflatten[0 : 6]   ->   [0,  1,  2,  3,  4,  5]\\n\\nappending:\\nnew_mat = [[0,  1,  2,  3,  4,  5]]\\niteration 1: row_index 1\\nflatten[6 : 12]   ->   [6,  7,  8,  9,  10, 11]\\n\\nappending:\\nnew_mat = [[0,  1,  2,  3,  4,  5],\\n           [6,  7,  8,  9,  10, 11]]\\n```\n```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        flatten = []\\n        new_mat = []\\n        for row in mat:\\n            for num in row:\\n                flatten.append(num)\\n                \\n        if r * c != len(flatten):   # when given parameters is NOT possible and legal\\n            return mat\\n        else:\\n            for row_index in range(r):\\n                new_mat.append(flatten[row_index * c : row_index * c + c])\\n            return new_mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094716,
                "title": "reshape-the-matrix-python-solution",
                "content": "```\\nclass Solution:\\n    def matrixReshape(self, mat, r, c):\\n        rows=len(mat)\\n        cols=len(mat[0])\\n        newMat=[]\\n        val=0\\n        if rows*cols!=r*c:\\n            return mat\\n        for i in range(r):\\n            newMat.append([])\\n            for _ in range(c):\\n                newMat[i].append(mat[val//cols][val%cols])\\n                val+=1\\n        return newMat\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def matrixReshape(self, mat, r, c):\\n        rows=len(mat)\\n        cols=len(mat[0])\\n        newMat=[]\\n        val=0\\n        if rows*cols!=r*c:\\n            return mat\\n        for i in range(r):\\n            newMat.append([])\\n            for _ in range(c):\\n                newMat[i].append(mat[val//cols][val%cols])\\n                val+=1\\n        return newMat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732578,
                "title": "rust-0ms-2-3mb",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Reshape the Matrix.\\nMemory Usage: 2.3 MB, less than 23.40% of Rust online submissions for Reshape the Matrix.\\n\\n```\\nimpl Solution {\\n    pub fn matrix_reshape(mut mat: Vec<Vec<i32>>, r: i32, c: i32) -> Vec<Vec<i32>> {\\n        let (row, col) = (mat.len(), mat[0].len());\\n        if row * col != (r * c) as usize {  return mat } \\n        mat.concat().chunks(c as usize).map(|r| r.to_vec()).collect()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn matrix_reshape(mut mat: Vec<Vec<i32>>, r: i32, c: i32) -> Vec<Vec<i32>> {\\n        let (row, col) = (mat.len(), mat[0].len());\\n        if row * col != (r * c) as usize {  return mat } \\n        mat.concat().chunks(c as usize).map(|r| r.to_vec()).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1317902,
                "title": "reshape-the-matrix-cpp-c-implementation-and-explanation",
                "content": "**Solution 1**\\n1. The simple and brute force way is to put all the matrix elements into the 1D array.\\n2. Create a 2D aray of size rXc and initialize with 0 & push all the elements of 1D array\\ninto the new matrix\\n* And, by the way the base condition is something very intuitive. Just think about for a sec.\\nif `m*n != r*c` then it is clear that new matrix can\\'t accommodate all elements, so just\\nreturn the same matrix otherwise calculate the calculate the new one.\\n```\\nclass Solution {\\npublic:\\n    //Time: O(mxn + rxc), Space: O(sizeof(oneDArray) + rxc)\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        //base condition\\n        if(m*n != r*c) return mat;\\n        \\n        //convert the matrix to 1d array\\n        vector<int> oneDArray;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                oneDArray.push_back(mat[i][j]);\\n            }\\n        }\\n        \\n        //put all the elements from 1d array to new matrix\\n        vector<vector<int>> newMatrix(r, vector<int>(c, 0));\\n        int idx=0;\\n        for(int i=0; i<r; i++){\\n            for(int j=0; j<c; j++){\\n                newMatrix[i][j] = oneDArray[idx];\\n                idx++;\\n            }\\n        }\\n        return newMatrix;\\n    }\\n};\\n```\\n\\n**Solution 2**\\nAnother method is like one pass of the current matrix, and create new matrix initialize with \\n0, put the previous elements into the new matrix according to the rxc dimension.\\nRemember the base condition from the previous solution, we need to apply here also.\\n```\\nclass Solution {\\npublic:\\n    //Time: O(mxn), Space: O(rxc)\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        //base condition\\n        if(m*n != r*c) return mat;\\n        \\n        //creating the new matrix with rxc dimension\\n        vector<vector<int>> newMatrix(r, vector<int>(c, 0));\\n        \\n        //put all the elements to the new matrix\\n        int newRow = 0, newColumn = 0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                \\n                //if newColumn is equal to the c then increase the newRow by 1 and set \\n                //newColumn to 0\\n                if(newColumn == c){\\n                    newRow++;\\n                    newColumn = 0;\\n                }\\n                newMatrix[newRow][newColumn] = mat[i][j];\\n                newColumn++;\\n            }\\n        }\\n        return newMatrix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Time: O(mxn + rxc), Space: O(sizeof(oneDArray) + rxc)\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        //base condition\\n        if(m*n != r*c) return mat;\\n        \\n        //convert the matrix to 1d array\\n        vector<int> oneDArray;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                oneDArray.push_back(mat[i][j]);\\n            }\\n        }\\n        \\n        //put all the elements from 1d array to new matrix\\n        vector<vector<int>> newMatrix(r, vector<int>(c, 0));\\n        int idx=0;\\n        for(int i=0; i<r; i++){\\n            for(int j=0; j<c; j++){\\n                newMatrix[i][j] = oneDArray[idx];\\n                idx++;\\n            }\\n        }\\n        return newMatrix;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //Time: O(mxn), Space: O(rxc)\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        //base condition\\n        if(m*n != r*c) return mat;\\n        \\n        //creating the new matrix with rxc dimension\\n        vector<vector<int>> newMatrix(r, vector<int>(c, 0));\\n        \\n        //put all the elements to the new matrix\\n        int newRow = 0, newColumn = 0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                \\n                //if newColumn is equal to the c then increase the newRow by 1 and set \\n                //newColumn to 0\\n                if(newColumn == c){\\n                    newRow++;\\n                    newColumn = 0;\\n                }\\n                newMatrix[newRow][newColumn] = mat[i][j];\\n                newColumn++;\\n            }\\n        }\\n        return newMatrix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494708,
                "title": "java-new-solution-using-streams",
                "content": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\\n        int n = nums.length;\\n        int m = nums[0].length;\\n        if(r*c != n*m || r == n) return nums;\\n        int[][] res = new int[r][c];\\n        \\n\\t\\tAtomicInteger ai = new AtomicInteger();\\n\\t\\tArrays.stream(nums)\\n\\t\\t\\t\\t.flatMapToInt(Arrays::stream)\\n\\t\\t\\t\\t.forEach(x -> res[ ai.get() / c ][ ai.getAndIncrement() % c ] = x);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\\n        int n = nums.length;\\n        int m = nums[0].length;\\n        if(r*c != n*m || r == n) return nums;\\n        int[][] res = new int[r][c];\\n        \\n\\t\\tAtomicInteger ai = new AtomicInteger();\\n\\t\\tArrays.stream(nums)\\n\\t\\t\\t\\t.flatMapToInt(Arrays::stream)\\n\\t\\t\\t\\t.forEach(x -> res[ ai.get() / c ][ ai.getAndIncrement() % c ] = x);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768126,
                "title": "best-solution-in-java-beats-100-java-solutions-in-run-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck if the matrix can fit in new matrix or not and copy elements to the new one. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check if the matrix can fit in new matrix if true copy elements to the new one. Else return old one.\\n2. Make two new variable x,y to be used as index of new matrix.\\n3. Run nested for loop for coping data from the old matrix and paste it in new matrix using the variables x,y.\\n4. For indexing of new variable use  \\n5.              y++;\\n                if(y == c){\\n                    y = 0;\\n                    x++;\\n                }\\nIf you Understand the Solution\\'s Approch do Upvote \\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m * n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n O(r * c)\\n# Code\\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n\\n        if(m*n != r*c){\\n            return mat;\\n        } \\n        \\n        \\n\\n        int x = 0;\\n        int y = 0;\\n        int res[][] = new int[r][c];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                res[x][y] = mat[i][j];\\n                y++;\\n                if(y == c){\\n                    y = 0;\\n                    x++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n\\n        if(m*n != r*c){\\n            return mat;\\n        } \\n        \\n        \\n\\n        int x = 0;\\n        int y = 0;\\n        int res[][] = new int[r][c];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                res[x][y] = mat[i][j];\\n                y++;\\n                if(y == c){\\n                    y = 0;\\n                    x++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438213,
                "title": "c-solution-with-explanation",
                "content": "Here, it states that the matrix should remain constant if the sizes of r and c differ from the original matrix.As a result, we can create a base case that uses multiplication to verify that the real matrix size matches the specified size in this instance.\\n\\nHere, we create a new matrix with size r*c, and we create two variables, k (row) and l (coloum), for iterating in the matrix. Here, we also need to check if the l reach the last element of the first row, in which case we need to initialise l with 0 to indicate the first coloum and increment k++ to indicate the second raw so that this type of logic can easily create new matrix.\\n\\n\\n**Complexity**\\n\\nTime complexity: O(N)\\n\\nSpace complexity: O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        if(mat.size()* mat[0].size()!= r * c) {\\n            return mat;\\n        } \\n        vector<vector<int>>v(r,vector<int>(c));\\n        int k = 0;\\n        int l = 0;\\n\\n        for(int i = 0; i < mat.size(); i++) {\\n            for(int j = 0; j < mat[0].size(); j++) {\\n                if(l == v[0].size()) {\\n                    l = 0;\\n                    k++;\\n                }\\n\\n                v[k][l++] = mat[i][j];\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        if(mat.size()* mat[0].size()!= r * c) {\\n            return mat;\\n        } \\n        vector<vector<int>>v(r,vector<int>(c));\\n        int k = 0;\\n        int l = 0;\\n\\n        for(int i = 0; i < mat.size(); i++) {\\n            for(int j = 0; j < mat[0].size(); j++) {\\n                if(l == v[0].size()) {\\n                    l = 0;\\n                    k++;\\n                }\\n\\n                v[k][l++] = mat[i][j];\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405000,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int row = mat.size();\\n        int col = mat[0].size();\\n        if (row * col != r * c) return mat;\\n        \\n        vector<vector<int>> result;\\n        int index = c;\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (index == c) {\\n                    result.push_back({});\\n                    index = 0;\\n                }\\n                result[result.size() - 1].push_back(mat[i][j]);\\n                index += 1;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n\\n        m=len(mat)\\n        n=len(mat[0])\\n        if m*n != r*c:\\n            return mat\\n        flat=[]\\n        for i in mat:\\n            flat.extend(i)\\n    \\n        output=[]\\n        for i in range(r):\\n            output.append(flat[i*c:(i+1)*c])\\n        return output\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\\n        int n = nums.length, m = nums[0].length;\\n        if (r * c != n * m) return nums;\\n        int[][] res = new int[r][c];\\n        for (int i = 0; i < r * c; i++)\\n            res[i / c][i % c] = nums[i / m][i % m];\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int row = mat.size();\\n        int col = mat[0].size();\\n        if (row * col != r * c) return mat;\\n        \\n        vector<vector<int>> result;\\n        int index = c;\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (index == c) {\\n                    result.push_back({});\\n                    index = 0;\\n                }\\n                result[result.size() - 1].push_back(mat[i][j]);\\n                index += 1;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n\\n        m=len(mat)\\n        n=len(mat[0])\\n        if m*n != r*c:\\n            return mat\\n        flat=[]\\n        for i in mat:\\n            flat.extend(i)\\n    \\n        output=[]\\n        for i in range(r):\\n            output.append(flat[i*c:(i+1)*c])\\n        return output\\n```\n```Java []\\nclass Solution {\\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\\n        int n = nums.length, m = nums[0].length;\\n        if (r * c != n * m) return nums;\\n        int[][] res = new int[r][c];\\n        for (int i = 0; i < r * c; i++)\\n            res[i / c][i % c] = nums[i / m][i % m];\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298864,
                "title": "566-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. First, check if it is possible to reshape the matrix by comparing the product of the number of rows and columns of the original matrix with the product of the number of rows and columns of the desired reshaped matrix. If they are not equal, return the original matrix.\\n2. Create a new matrix of size r x c using nested list comprehension.\\n3. Traverse the original matrix in row-major order using a single index that starts at 0.\\n4. For each element in the new matrix, calculate its row and column indices in the original matrix using integer division and modulo operations on the index, and then fill in the corresponding value from the original matrix.\\n5. Increment the index by 1 for each iteration.\\n6. Return the new matrix.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        # Check if it is possible to reshape the matrix\\n        m, n = len(mat), len(mat[0])\\n        if m * n != r * c:\\n            return mat\\n        \\n        # Create a new matrix of size r x c\\n        new_mat = [[0] * c for _ in range(r)]\\n        \\n        # Traverse the original matrix in row-major order\\n        index = 0\\n        for i in range(r):\\n            for j in range(c):\\n                # Fill in the values of the new matrix\\n                row, col = divmod(index, n)\\n                new_mat[i][j] = mat[row][col]\\n                index += 1\\n                \\n        return new_mat\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        # Check if it is possible to reshape the matrix\\n        m, n = len(mat), len(mat[0])\\n        if m * n != r * c:\\n            return mat\\n        \\n        # Create a new matrix of size r x c\\n        new_mat = [[0] * c for _ in range(r)]\\n        \\n        # Traverse the original matrix in row-major order\\n        index = 0\\n        for i in range(r):\\n            for j in range(c):\\n                # Fill in the values of the new matrix\\n                row, col = divmod(index, n)\\n                new_mat[i][j] = mat[row][col]\\n                index += 1\\n                \\n        return new_mat\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234969,
                "title": "simple-java-solution-with-0ms-runtime-beats-100",
                "content": "# Stats\\n- **RunTime**: *0ms* (**Beats 100%**)\\n\\n# Code\\npublic int[][] matrixReshape(int[][] mat, int r, int c) {\\n    int rows = mat.length, cols = mat[0].length;\\n\\n    if((r == rows && c == cols) || (rows * cols != r * c)) {\\n        return mat;\\n    }\\n\\n    int newMat [][] = new int [r][c], rIndex = 0, cIndex = 0;\\n\\n    for (int row = 0; row < rows; row++) {\\n        for (int col = 0; col < cols; col++) {\\n            if(cIndex == c) {\\n                rIndex++;\\n                cIndex = 0;\\n            }\\n\\n            newMat[rIndex][cIndex++] = mat[row][col];\\n        }\\n    }\\n\\n    return newMat;\\n}\\n```\\n<br/>\\n<br/>\\n<br/>\\n\\nAuthor :- [*Abhinav Bhardwaj*](https://abhinavbhardwaj.in)",
                "solutionTags": [
                    "Java"
                ],
                "code": "# Stats\\n- **RunTime**: *0ms* (**Beats 100%**)\\n\\n# Code\\npublic int[][] matrixReshape(int[][] mat, int r, int c) {\\n    int rows = mat.length, cols = mat[0].length;\\n\\n    if((r == rows && c == cols) || (rows * cols != r * c)) {\\n        return mat;\\n    }\\n\\n    int newMat [][] = new int [r][c], rIndex = 0, cIndex = 0;\\n\\n    for (int row = 0; row < rows; row++) {\\n        for (int col = 0; col < cols; col++) {\\n            if(cIndex == c) {\\n                rIndex++;\\n                cIndex = 0;\\n            }\\n\\n            newMat[rIndex][cIndex++] = mat[row][col];\\n        }\\n    }\\n\\n    return newMat;\\n}\\n```\\n<br/>\\n<br/>\\n<br/>\\n\\nAuthor :- [*Abhinav Bhardwaj*](https://abhinavbhardwaj.in)",
                "codeTag": "Unknown"
            },
            {
                "id": 3043388,
                "title": "java-simple-solution-with-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        if (mat.length * mat[0].length != r * c) return mat;\\n\\n        int[][] arr = new int[r][c];\\n        int k = 0, l = 0;\\n        for (int i = 0; i < mat.length; i++) {\\n            for (int j = 0; j < mat[i].length; j++) {\\n                arr[k][l] = mat[i][j];\\n                l++;\\n                if (l == c) {\\n                    l = 0;\\n                    k++;\\n                }\\n            }\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        if (mat.length * mat[0].length != r * c) return mat;\\n\\n        int[][] arr = new int[r][c];\\n        int k = 0, l = 0;\\n        for (int i = 0; i < mat.length; i++) {\\n            for (int j = 0; j < mat[i].length; j++) {\\n                arr[k][l] = mat[i][j];\\n                l++;\\n                if (l == c) {\\n                    l = 0;\\n                    k++;\\n                }\\n            }\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972246,
                "title": "simple-java-solution-with-100-faster",
                "content": "\\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        if(mat.length * mat[0].length != r*c){\\n            return mat;\\n        }\\n        int[][] newMatrix= new int[r][c];\\n        int sr = 0;\\n        int sc = 0;\\n\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0 ; j<mat[0].length;j++){\\n                if(sc==c){\\n                    sr++;\\n                    sc=0;\\n                }\\n                newMatrix[sr][sc] = mat[i][j];\\n                sc++;\\n            }\\n        }\\n        return newMatrix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        if(mat.length * mat[0].length != r*c){\\n            return mat;\\n        }\\n        int[][] newMatrix= new int[r][c];\\n        int sr = 0;\\n        int sc = 0;\\n\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0 ; j<mat[0].length;j++){\\n                if(sc==c){\\n                    sr++;\\n                    sc=0;\\n                }\\n                newMatrix[sr][sc] = mat[i][j];\\n                sc++;\\n            }\\n        }\\n        return newMatrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941148,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {\\n        int m = nums.size(), n = nums[0].size();\\n        if(m * n != r * c) return nums;\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        int row = 0, col = 0;\\n        for(int i = 0; i < r; i++) {\\n            for(int j = 0; j < c; j++) {\\n                ans[i][j] = nums[row][col++];\\n                if(col == n) col = 0, row++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {\\n        int m = nums.size(), n = nums[0].size();\\n        if(m * n != r * c) return nums;\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        int row = 0, col = 0;\\n        for(int i = 0; i < r; i++) {\\n            for(int j = 0; j < c; j++) {\\n                ans[i][j] = nums[row][col++];\\n                if(col == n) col = 0, row++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931757,
                "title": "java-modulo-arthimatic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int n = mat.length , m = mat[0].length;\\n        int arr[][] = new int[r][c];\\n        if(m*n != r*c) return mat;\\n        for(int i = 0; i < c*r; i++){\\n            arr[i/c][i%c] = mat[i/m][i%m];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int n = mat.length , m = mat[0].length;\\n        int arr[][] = new int[r][c];\\n        if(m*n != r*c) return mat;\\n        for(int i = 0; i < c*r; i++){\\n            arr[i/c][i%c] = mat[i/m][i%m];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2151421,
                "title": "3ms-simple-solution",
                "content": "Runtime: 3 ms, faster than 91.95% of Rust online submissions for Reshape the Matrix.\\nMemory Usage: 2.4 MB, less than 32.18% of Rust online submissions for Reshape the Matrix.\\n```\\nimpl Solution {\\n    pub fn matrix_reshape(mat: Vec<Vec<i32>>, r: i32, c: i32) -> Vec<Vec<i32>> {\\n        if (r*c) as usize != mat.len()*mat[0].len(){\\n            mat //illegal matrix return\\n        } else{\\n            mat\\n            .concat() //combine\\n            .chunks(c as usize) //devide\\n            .map(|row| row.to_vec())\\n            .collect() //restructure\\n        }\\n    }\\n}\\n``",
                "solutionTags": [
                    "Rust"
                ],
                "code": "Runtime: 3 ms, faster than 91.95% of Rust online submissions for Reshape the Matrix.\\nMemory Usage: 2.4 MB, less than 32.18% of Rust online submissions for Reshape the Matrix.\\n```\\nimpl Solution {\\n    pub fn matrix_reshape(mat: Vec<Vec<i32>>, r: i32, c: i32) -> Vec<Vec<i32>> {\\n        if (r*c) as usize != mat.len()*mat[0].len(){\\n            mat //illegal matrix return\\n        } else{\\n            mat\\n            .concat() //combine\\n            .chunks(c as usize) //devide\\n            .map(|row| row.to_vec())\\n            .collect() //restructure\\n        }\\n    }\\n}\\n``",
                "codeTag": "Unknown"
            },
            {
                "id": 1902576,
                "title": "easy-solution-using-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        vector<int>matri;\\n        int m=mat.size(), n=mat[0].size();\\n\\t\\t    if(r*c !=m*n){\\n            return mat;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                matri.push_back(mat[i][j]);\\n            }\\n        }\\n    \\n        vector<vector<int>>ans(r, vector<int>(c,0));\\n        int k=0;\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                ans[i][j]=matri[k];\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n//If the solution helped you then dont forget to upvote!!",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        vector<int>matri;\\n        int m=mat.size(), n=mat[0].size();\\n\\t\\t    if(r*c !=m*n){\\n            return mat;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1317443,
                "title": "c-simple-2-pointer-solution-explained-100-time-95-space",
                "content": "Nice warm up for the week, this is a nice problem to solve in one simple go.\\n\\nFirst of all, we are going create a few support variables:\\n* `mr` and `mc` will store the number of rows and columns in the provided matrix;\\n* `nx` and `ny` are 2 pointers we will use with our newly created array.\\n\\nWe will then check if the calls we are getting is either illegal (ie: the total number of elements in the new matrix does not match) or if the provided coordinates are identical to the existing one - in either case returning `mat`.\\n\\nIf that is not the case, we will then create another variable, `res`, a vector of vectors of `r` rows and `c` columns.\\n\\nNext, we will populate `res` looping with `cy` and `cx` through `mat` and:\\n* assigning the currently pointed value (`mat[cy][cx]`) to the matching cell in the new matrix (`res[ny][nx++]`);\\n* advance `ny` and reset `nx` to `0` every time we reach the end of the row in the `res` (ie: `nx == c`).\\n\\nOnce done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        // support variables\\n        int mr = mat.size(), mc = mat[0].size(), nx = 0, ny = 0;\\n        // detecting illegal calls and when the new matrix has the same size\\n        if (mr * mc != r * c || mr == r && mc == c) return mat;\\n        vector<vector<int>> res(r, vector<int>(c));\\n        // populating ress\\n        for (int cy = 0; cy < mr; cy++) {\\n            for (int cx = 0; cx < mc; cx++) {\\n                res[ny][nx++] = mat[cy][cx];\\n                // updating nx and ny when we reached the end of a row\\n                if (nx == c) nx = 0, ny++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        // support variables\\n        int mr = mat.size(), mc = mat[0].size(), nx = 0, ny = 0;\\n        // detecting illegal calls and when the new matrix has the same size\\n        if (mr * mc != r * c || mr == r && mc == c) return mat;\\n        vector<vector<int>> res(r, vector<int>(c));\\n        // populating ress\\n        for (int cy = 0; cy < mr; cy++) {\\n            for (int cx = 0; cx < mc; cx++) {\\n                res[ny][nx++] = mat[cy][cx];\\n                // updating nx and ny when we reached the end of a row\\n                if (nx == c) nx = 0, ny++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317235,
                "title": "java-matrix-0ms-beats-100-t-c-o-m-n-s-c-o-m-n",
                "content": "\\n\\n\\t// O(m*n) O(m*n)\\n\\tpublic int[][] matrixReshape(int[][] mat, int r, int c) {\\n\\n\\t\\tint m = mat.length, n = mat[0].length;\\n\\t\\tif (m * n != r * c)\\n\\t\\t\\treturn mat;\\n\\n\\t\\tint[][] ans = new int[r][c];\\n\\t\\tint x = 0, y = 0;\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tans[x][y] = mat[i][j];\\n\\t\\t\\t\\ty++;\\n\\t\\t\\t\\tif (y == c) {\\n\\t\\t\\t\\t\\tx++;\\n\\t\\t\\t\\t\\ty = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\n\\t// O(m*n) O(m*n)\\n\\tpublic int[][] matrixReshape(int[][] mat, int r, int c) {\\n\\n\\t\\tint m = mat.length, n = mat[0].length;\\n\\t\\tif (m * n != r * c)\\n\\t\\t\\treturn mat;\\n\\n\\t\\tint[][] ans = new int[r][c];\\n\\t\\tint x = 0, y = 0;\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tans[x][y] = mat[i][j];\\n\\t\\t\\t\\ty++;\\n\\t\\t\\t\\tif (y == c) {\\n\\t\\t\\t\\t\\tx++;\\n\\t\\t\\t\\t\\ty = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 895295,
                "title": "c-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {\\n        int m = nums.size();\\n        if (m == 0){\\n            return nums;\\n        }\\n        \\n        int n = nums[0].size();\\n        \\n        if (m * n != r * c) return nums;\\n        \\n        \\n        vector<vector<int>> res (r, vector<int> (c));\\n        \\n        int row = 0, col = 0;\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                res[row][col] = nums[i][j];\\n                col += 1;\\n                \\n                \\n                if (col == c){\\n                    row += 1;\\n                    col = 0;\\n                }\\n            }\\n           \\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {\\n        int m = nums.size();\\n        if (m == 0){\\n            return nums;\\n        }\\n        \\n        int n = nums[0].size();\\n        \\n        if (m * n != r * c) return nums;\\n        \\n        \\n        vector<vector<int>> res (r, vector<int> (c));\\n        \\n        int row = 0, col = 0;\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                res[row][col] = nums[i][j];\\n                col += 1;\\n                \\n                \\n                if (col == c){\\n                    row += 1;\\n                    col = 0;\\n                }\\n            }\\n           \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872415,
                "title": "easy-python-100-speed-yield-method",
                "content": "**Easy Python | 100% Speed | Yield Method**\\n\\nClean Python algorithm building the output array in a very easy way :)\\n\\n```\\nclass Solution:\\n    def yielder(self,A):\\n        for row in A:\\n            for x in row:\\n                yield x\\n    def matrixReshape(self, A, r, c):\\n        if not A:\\n            return []\\n        if len(A)*len(A[0]) != r*c:\\n            return A\\n        #\\n        gen = self.yielder(A)\\n        return [ [ next(gen) for _ in range(c) ] for _ in range(r) ]\\n```\\n\\n**PS. Circular Index Method**\\n\\nThe Yield Method works amazingly well in Python. However, implementing anything resembling the Yield functionality is low-level languages is very cumbersome (if at all possible). The Circular Index Method is a much cleaner algorithm compatible with all programming languages:\\n```\\nclass Solution:\\n    def matrixReshape(self, A, r, c):\\n        if not A:\\n            return []\\n        m,n = len(A),len(A[0])\\n        if m*n != r*c:\\n            return A\\n        #\\n        B = []\\n        for i in range(r):\\n            row = []\\n            for j in range(c):\\n                k = i*c + j\\n                row.append( A[k//n][k%n] )\\n            B.append( row )\\n        return B\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def yielder(self,A):\\n        for row in A:\\n            for x in row:\\n                yield x\\n    def matrixReshape(self, A, r, c):\\n        if not A:\\n            return []\\n        if len(A)*len(A[0]) != r*c:\\n            return A\\n        #\\n        gen = self.yielder(A)\\n        return [ [ next(gen) for _ in range(c) ] for _ in range(r) ]\\n```\n```\\nclass Solution:\\n    def matrixReshape(self, A, r, c):\\n        if not A:\\n            return []\\n        m,n = len(A),len(A[0])\\n        if m*n != r*c:\\n            return A\\n        #\\n        B = []\\n        for i in range(r):\\n            row = []\\n            for j in range(c):\\n                k = i*c + j\\n                row.append( A[k//n][k%n] )\\n            B.append( row )\\n        return B\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480865,
                "title": "3-python-sol-based-on-list-comprehension-generator-and-index-transform-80-with-explanation",
                "content": "3 Python sol. based on list comprehension, generator, and index transform.\\n\\n---\\n\\nMethod_#1: based on list comprehension\\n\\n```\\nclass Solution:\\n    def matrixReshape(self, nums: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        \\n        ori_rows, ori_cols = len(nums), len(nums[0])\\n        \\n        if ori_rows * ori_cols != r * c or (ori_rows, ori_cols) == (r, c):\\n            # Quick response:\\n            # \\n            # mismatch of total number of elements\\n            # or\\n            # dimension is the same as original\\n            \\n            return nums\\n        \\n        else:\\n            \\n            # flatten nums to 1D array\\n            flatten_array = [ element for rows in nums for element in rows ]\\n            \\n            # construct  reshape_arr by list comprehension\\n            reshape_arr = [ flatten_array[ y*c : y*c+c ] for y in range(r) ]\\n            \\n            return reshape_arr\\n```\\n\\n---\\n\\nMethod_#2: based on generator\\n\\n```\\nclass Solution:\\n    \\n    def element_generator( self, matrix ):\\n    \\n        rows, cols = len( matrix), len( matrix[0])\\n        \\n        for index_serial in range( rows*cols):\\n            y = index_serial // cols\\n            x = index_serial % cols\\n            yield matrix[y][x]\\n    \\n        \\n\\n    \\n    def matrixReshape(self, nums: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        \\n        ori_rows, ori_cols = len(nums), len(nums[0])\\n        \\n        if ori_rows * ori_cols != r * c or (ori_rows, ori_cols) == (r, c):\\n            # Quick response:\\n            # mismatch of total number of elements\\n            # or\\n            # dimension is the same as original\\n            \\n            \\n            return nums\\n        \\n        else:\\n            \\n            \\n            reshape_arr = [[ 0 for x in range (c)] for y in range(r) ]\\n            \\n            element_gen = self.element_generator( nums )\\n            \\n            for y in range(r):\\n                for x in range(c):\\n                    \\n                    reshape_arr[y][x] = next(element_gen)\\n            \\n            \\n            return reshape_arr\\n```\\n\\n---\\n\\nMethod_#3: based on index transform\\n\\n```\\nclass Solution:\\n\\n    def matrixReshape(self, nums: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        \\n        ori_rows, ori_cols = len(nums), len(nums[0])\\n        \\n        if ori_rows * ori_cols != r * c or (ori_rows, ori_cols) == (r, c):\\n            # Quick response:\\n            # mismatch of total number of elements\\n            # or\\n            # dimension is the same as original\\n            \\n            \\n            return nums\\n        \\n        else:\\n            \\n            reshape_arr = [[ 0 for x in range (c)] for y in range(r) ]\\n            \\n            for y in range(r):\\n                for x in range(c):\\n                    \\n                    # index transform\\n                    serial_index = y * c + x\\n\\n                    src_y = serial_index // ori_cols\\n                    src_x = serial_index % ori_cols\\n                    \\n                    reshape_arr[y][x] = nums[src_y][src_x]\\n            \\n            \\n            return reshape_arr\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def matrixReshape(self, nums: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        \\n        ori_rows, ori_cols = len(nums), len(nums[0])\\n        \\n        if ori_rows * ori_cols != r * c or (ori_rows, ori_cols) == (r, c):\\n            # Quick response:\\n            # \\n            # mismatch of total number of elements\\n            # or\\n            # dimension is the same as original\\n            \\n            return nums\\n        \\n        else:\\n            \\n            # flatten nums to 1D array\\n            flatten_array = [ element for rows in nums for element in rows ]\\n            \\n            # construct  reshape_arr by list comprehension\\n            reshape_arr = [ flatten_array[ y*c : y*c+c ] for y in range(r) ]\\n            \\n            return reshape_arr\\n```\n```\\nclass Solution:\\n    \\n    def element_generator( self, matrix ):\\n    \\n        rows, cols = len( matrix), len( matrix[0])\\n        \\n        for index_serial in range( rows*cols):\\n            y = index_serial // cols\\n            x = index_serial % cols\\n            yield matrix[y][x]\\n    \\n        \\n\\n    \\n    def matrixReshape(self, nums: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        \\n        ori_rows, ori_cols = len(nums), len(nums[0])\\n        \\n        if ori_rows * ori_cols != r * c or (ori_rows, ori_cols) == (r, c):\\n            # Quick response:\\n            # mismatch of total number of elements\\n            # or\\n            # dimension is the same as original\\n            \\n            \\n            return nums\\n        \\n        else:\\n            \\n            \\n            reshape_arr = [[ 0 for x in range (c)] for y in range(r) ]\\n            \\n            element_gen = self.element_generator( nums )\\n            \\n            for y in range(r):\\n                for x in range(c):\\n                    \\n                    reshape_arr[y][x] = next(element_gen)\\n            \\n            \\n            return reshape_arr\\n```\n```\\nclass Solution:\\n\\n    def matrixReshape(self, nums: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        \\n        ori_rows, ori_cols = len(nums), len(nums[0])\\n        \\n        if ori_rows * ori_cols != r * c or (ori_rows, ori_cols) == (r, c):\\n            # Quick response:\\n            # mismatch of total number of elements\\n            # or\\n            # dimension is the same as original\\n            \\n            \\n            return nums\\n        \\n        else:\\n            \\n            reshape_arr = [[ 0 for x in range (c)] for y in range(r) ]\\n            \\n            for y in range(r):\\n                for x in range(c):\\n                    \\n                    # index transform\\n                    serial_index = y * c + x\\n\\n                    src_y = serial_index // ori_cols\\n                    src_x = serial_index % ori_cols\\n                    \\n                    reshape_arr[y][x] = nums[src_y][src_x]\\n            \\n            \\n            return reshape_arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 404605,
                "title": "c-simple-solution",
                "content": "```\\npublic int[][] MatrixReshape(int[][] nums, int r, int c) {\\n        int curRows = nums.Length;\\n        int curColumns = nums[0].Length;\\n        \\n        if((curRows * curColumns) == (r * c)){\\n            int[][] result = new int[r][];\\n            \\n          for(int i = 0; i < r; i++) //this loop is because i cant just declare int [][] transpose = new int[m][n]... c# things\\n        {\\n            result[i] = new int[c];\\n        }\\n            int x =0, y =0;\\n            for(int i =0; i < r; i++){\\n                for(int j =0; j< c; j++){\\n                    if((x < curRows) || (y < curColumns)){\\n                        if(y >= curColumns){\\n                            y = 0;\\n                            x++;                     \\n                        }\\n                        result[i][j] = nums[x][y++];\\n                    }              \\n                }\\n            }\\n         return result;   \\n        }\\n            \\n        return nums;\\n               \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[][] MatrixReshape(int[][] nums, int r, int c) {\\n        int curRows = nums.Length;\\n        int curColumns = nums[0].Length;\\n        \\n        if((curRows * curColumns) == (r * c)){\\n            int[][] result = new int[r][];\\n            \\n          for(int i = 0; i < r; i++) //this loop is because i cant just declare int [][] transpose = new int[m][n]... c# things\\n        {\\n            result[i] = new int[c];\\n        }\\n            int x =0, y =0;\\n            for(int i =0; i < r; i++){\\n                for(int j =0; j< c; j++){\\n                    if((x < curRows) || (y < curColumns)){\\n                        if(y >= curColumns){\\n                            y = 0;\\n                            x++;                     \\n                        }\\n                        result[i][j] = nums[x][y++];\\n                    }              \\n                }\\n            }\\n         return result;   \\n        }\\n            \\n        return nums;\\n               \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 192009,
                "title": "javascript",
                "content": "```\\nvar matrixReshape = function(nums, r, c) {\\n    const r0 = nums.length, c0 = nums[0].length, result = [];\\n    if(r * c != r0 * c0) {\\n        return nums;\\n    }\\n    let array = [];\\n    for(let i = 0; i < r0; i++) {\\n        for(let j = 0; j < c0; j++) {\\n            array.push(nums[i][j]);\\n        }\\n    }\\n    while(array.length) {\\n        result.push(array.splice(0, c));\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar matrixReshape = function(nums, r, c) {\\n    const r0 = nums.length, c0 = nums[0].length, result = [];\\n    if(r * c != r0 * c0) {\\n        return nums;\\n    }\\n    let array = [];\\n    for(let i = 0; i < r0; i++) {\\n        for(let j = 0; j < c0; j++) {\\n            array.push(nums[i][j]);\\n        }\\n    }\\n    while(array.length) {\\n        result.push(array.splice(0, c));\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3411458,
                "title": "c-go-detailed-explanation",
                "content": "Get the number of rows n and columns m of the input matrix mat.\\nCheck if `n * m` is equal to the number of elements in the new matrix, i.e., `r * c`. If they are not equal, return the original matrix mat.\\nCreate a new matrix arr of dimensions `r x c` using a nested for loop.\\nIterate over the elements of mat using a nested for loop and fill in the elements of arr in row-major order. To do this, use the formula `l = i * m + j` to calculate the linear index of each element in mat, and the formula `arr[l / c][l % c] = mat[i][j]` to assign the element to the appropriate position in arr.\\nReturn the reshaped matrix arr.\\n\\n# Complexity\\n- Time complexity: $$O(r * c)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(r * c)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n##### Go\\n```\\nfunc matrixReshape(mat [][]int, r int, c int) [][]int {\\n\\tn := len(mat)\\n\\tm := len(mat[0])\\n\\tif m * n != r * c {\\n\\t\\treturn mat\\n\\t}\\n\\tarr := make([][]int, r)\\n\\tfor i := 0; i < r; i++ {\\n\\t\\tarr[i] = make([]int, c)\\n\\t}\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tl := i*m + j\\n\\t\\t\\tarr[l/c][l%c] = mat[i][j]\\n\\t\\t}\\n\\t}\\n\\n\\treturn arr\\n}\\n```\\n##### C#\\n```\\npublic class Solution {\\n\\tpublic int[][] MatrixReshape(int[][] mat, int r, int c) {\\n\\t\\tint n = mat.Length;\\n\\t\\tint m = mat[0].Length;\\n\\t\\t\\n\\t\\tif (m * n != r * c) {\\n\\t\\t\\treturn mat;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint[][] arr = new int[r][];\\n\\t\\tfor (int i = 0; i < r; i++) {\\n\\t\\t\\tarr[i] = new int[c];\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tfor (int j = 0; j < m; j++) {\\n\\t\\t\\t\\tint l = i * m + j;\\n\\t\\t\\t\\tarr[l / c][l % c] = mat[i][j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn arr;\\n\\t}\\n}\\n```\\n![a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png](https://assets.leetcode.com/users/images/cc82e8aa-dc98-4f10-af4c-64b1528c0fb6_1680844232.130332.png)",
                "solutionTags": [
                    "C#",
                    "Go",
                    "Array",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nfunc matrixReshape(mat [][]int, r int, c int) [][]int {\\n\\tn := len(mat)\\n\\tm := len(mat[0])\\n\\tif m * n != r * c {\\n\\t\\treturn mat\\n\\t}\\n\\tarr := make([][]int, r)\\n\\tfor i := 0; i < r; i++ {\\n\\t\\tarr[i] = make([]int, c)\\n\\t}\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tl := i*m + j\\n\\t\\t\\tarr[l/c][l%c] = mat[i][j]\\n\\t\\t}\\n\\t}\\n\\n\\treturn arr\\n}\\n```\n```\\npublic class Solution {\\n\\tpublic int[][] MatrixReshape(int[][] mat, int r, int c) {\\n\\t\\tint n = mat.Length;\\n\\t\\tint m = mat[0].Length;\\n\\t\\t\\n\\t\\tif (m * n != r * c) {\\n\\t\\t\\treturn mat;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint[][] arr = new int[r][];\\n\\t\\tfor (int i = 0; i < r; i++) {\\n\\t\\t\\tarr[i] = new int[c];\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tfor (int j = 0; j < m; j++) {\\n\\t\\t\\t\\tint l = i * m + j;\\n\\t\\t\\t\\tarr[l / c][l % c] = mat[i][j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn arr;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080569,
                "title": "memory-beats-95-4-of-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        if (r * c != mat.length * mat[0].length){\\n            return mat;\\n        }\\n        int ans[][] = new int[r][c];\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        for (int[] i: mat){\\n            for (int j: i){\\n                arr.add(j);\\n            }\\n        }\\n        int a = 0;\\n        for (int i = 0; i < r; i++){\\n            for (int j = 0; j < c; j++){\\n                ans[i][j] = arr.get(a);\\n                a++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        if (r * c != mat.length * mat[0].length){\\n            return mat;\\n        }\\n        int ans[][] = new int[r][c];\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        for (int[] i: mat){\\n            for (int j: i){\\n                arr.add(j);\\n            }\\n        }\\n        int a = 0;\\n        for (int i = 0; i < r; i++){\\n            for (int j = 0; j < c; j++){\\n                ans[i][j] = arr.get(a);\\n                a++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702976,
                "title": "simple-solution-1ms-single-loop-with-explaination",
                "content": "\\t\\t\\t\\n\\t\\t\\tclass Solution {\\n\\t\\t\\t\\tpublic int[][] matrixReshape(int[][] nums, int r, int c) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tint m = nums.length, n = nums[0].length;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (r * c != m * n)\\n\\t\\t\\t\\t\\treturn nums;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tint[][] reshaped = new int[r][c];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor (int i = 0; i < r * c; i++)\\n\\t\\t\\t\\t\\treshaped[i/c][i%c] = nums[i/n][i%n];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\treturn reshaped;\\n\\t\\t\\t }\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n#### \\t\\t\\tTime Complexity --> O(N*M)\\n#### \\t\\t\\tSpace Complexity --> O(r*c)",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\tpublic int[][] matrixReshape(int[][] nums, int r, int c) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tint m = nums.length, n = nums[0].length;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (r * c != m * n)\\n\\t\\t\\t\\t\\treturn nums;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tint[][] reshaped = new int[r][c];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor (int i = 0; i < r * c; i++)\\n\\t\\t\\t\\t\\treshaped[i/c][i%c] = nums[i/n][i%n];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\treturn reshaped;\\n\\t\\t\\t }",
                "codeTag": "Java"
            },
            {
                "id": 2594920,
                "title": "short-javascript-solution",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n\\n\\n```\\nvar matrixReshape = function (mat, r, c) {\\n    if (mat.length * mat[0].length !== r * c) return mat //Checks if a reshape is possible.\\n    let elements = []\\n    let reshapedMat = []\\n\\t\\n    for (let row of mat) elements.push(...row)\\n\\n    for (let i = 0; i < elements.length; i += c) {\\n        reshapedMat.push(elements.slice(i, i + c))\\n    }\\n\\n    return reshapedMat\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar matrixReshape = function (mat, r, c) {\\n    if (mat.length * mat[0].length !== r * c) return mat //Checks if a reshape is possible.\\n    let elements = []\\n    let reshapedMat = []\\n\\t\\n    for (let row of mat) elements.push(...row)\\n\\n    for (let i = 0; i < elements.length; i += c) {\\n        reshapedMat.push(elements.slice(i, i + c))\\n    }\\n\\n    return reshapedMat\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2580449,
                "title": "beats-97-python-list-comprehension",
                "content": "```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        flat = [item for sublist in mat for item in sublist]\\n        if r * c != len(flat): return mat    \\n        output = [flat[(row *c) :c * (row +1)] for row in range(r)]\\n        return output\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        flat = [item for sublist in mat for item in sublist]\\n        if r * c != len(flat): return mat    \\n        output = [flat[(row *c) :c * (row +1)] for row in range(r)]\\n        return output\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2343017,
                "title": "java-o-nm-solution-1-ms-best-solution",
                "content": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n       int n = mat.length, m = mat[0].length;\\n      \\n      if(r * c != m * n) {\\n        return mat;\\n      }\\n      \\n      int result[][] = new int[r][c];\\n      for(int i = 0; i < r * c; i ++) {\\n        result[i / c][i % c] = mat[i / m][i % m];\\n      }\\n      return result;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n       int n = mat.length, m = mat[0].length;\\n      \\n      if(r * c != m * n) {\\n        return mat;\\n      }\\n      \\n      int result[][] = new int[r][c];\\n      for(int i = 0; i < r * c; i ++) {\\n        result[i / c][i % c] = mat[i / m][i % m];\\n      }\\n      return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189448,
                "title": "python-solution-88-68-faster",
                "content": "```\\ndef matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        if (len(mat) * len(mat[0]) != r * c):\\n            return mat\\n        flat_mat = []\\n        prop_mat = []\\n        for i in range(len(mat)):\\n            for j in mat[i]:\\n                flat_mat.append(j)\\n        end = c\\n        for i in range(0,len(flat_mat),c):\\n            prop_mat.append(flat_mat[i:end])\\n            end += c\\n            \\n        return prop_mat\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        if (len(mat) * len(mat[0]) != r * c):\\n            return mat\\n        flat_mat = []\\n        prop_mat = []\\n        for i in range(len(mat)):\\n            for j in mat[i]:\\n                flat_mat.append(j)\\n        end = c\\n        for i in range(0,len(flat_mat),c):\\n            prop_mat.append(flat_mat[i:end])\\n            end += c\\n            \\n        return prop_mat\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1798104,
                "title": "c-simple-understandable-solution-clean-code-two-loop-r-x-c",
                "content": "\\t\\t\\t\\t\\t\\t\\u21C8\\nIf this really help please leave me a reputation \\u270C.\\n## Clean code:-\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        \\n        int rows = mat.size(), columns = mat[0].size(), length = rows * columns; \\n            // Fetch size of the input matrix (rows and columns) and total length of the input matrix.\\n        \\n        if(length != (r * c)) return mat; \\n            // If the given reshape size is invalid then the return input matrix itself.\\n        \\n        vector<vector<int>> output(r, vector<int>(c));\\n            // To store the output matrix.\\n        \\n        for(int i = 0; i < length; i++) {\\n            \\n            output[i / c][i % c] = mat[i / columns][i % columns];\\n                // i/c - will return row (The number after point is neglected as i and c is declared as integer).\\n                // i%c - will return column (The number after point is neglected as i and c is declared as integer).\\n                // i / columns and i % columns also do the same.\\n        }\\n        \\n        return output; \\n    }\\n};\\n```\\n### Time Complexity:-\\n##### O(r X c) or O(n\\xB2)\\n\\n===========================================================================\\n\\n## Understandable Code:-\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        \\n        int rows = mat.size(), columns = mat[0].size(); // Fetch size of the input matrix (rows and columns).\\n        \\n        if((rows * columns) != (r * c)) {\\n            \\n            return mat; // If the given reshape size is invalid then the return input matrix itself.\\n        }\\n        \\n        vector<vector<int>> output(r, vector<int>(c, 0));\\n        int rowOut = 0, colOut = 0; // To insert elements in specified r X c format.\\n        \\n        for(int i = 0; i<rows; i++) {\\n            for(int j = 0; j<columns; j++) {\\n                \\n                output[rowOut][colOut] = mat[i][j];\\n                colOut++; // Increment output columns.\\n                    \\n                if(colOut == c) { \\n                    \\n                    rowOut++;    // Move to the next row after we fill all the column elements in previous row.\\n                    colOut = 0; // After we reach the specified column size reset the column.\\n                      \\n                }\\n            }\\n        }\\n        \\n        return output;\\n        \\n    }\\n};\\n```\\n### Time Complexity:-\\n##### O(r X c) or O(n\\xB2)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        \\n        int rows = mat.size(), columns = mat[0].size(), length = rows * columns; \\n            // Fetch size of the input matrix (rows and columns) and total length of the input matrix.\\n        \\n        if(length != (r * c)) return mat; \\n            // If the given reshape size is invalid then the return input matrix itself.\\n        \\n        vector<vector<int>> output(r, vector<int>(c));\\n            // To store the output matrix.\\n        \\n        for(int i = 0; i < length; i++) {\\n            \\n            output[i / c][i % c] = mat[i / columns][i % columns];\\n                // i/c - will return row (The number after point is neglected as i and c is declared as integer).\\n                // i%c - will return column (The number after point is neglected as i and c is declared as integer).\\n                // i / columns and i % columns also do the same.\\n        }\\n        \\n        return output; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        \\n        int rows = mat.size(), columns = mat[0].size(); // Fetch size of the input matrix (rows and columns).\\n        \\n        if((rows * columns) != (r * c)) {\\n            \\n            return mat; // If the given reshape size is invalid then the return input matrix itself.\\n        }\\n        \\n        vector<vector<int>> output(r, vector<int>(c, 0));\\n        int rowOut = 0, colOut = 0; // To insert elements in specified r X c format.\\n        \\n        for(int i = 0; i<rows; i++) {\\n            for(int j = 0; j<columns; j++) {\\n                \\n                output[rowOut][colOut] = mat[i][j];\\n                colOut++; // Increment output columns.\\n                    \\n                if(colOut == c) { \\n                    \\n                    rowOut++;    // Move to the next row after we fill all the column elements in previous row.\\n                    colOut = 0; // After we reach the specified column size reset the column.\\n                      \\n                }\\n            }\\n        }\\n        \\n        return output;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774153,
                "title": "go-solution-using-range-append-and-mod",
                "content": "```go\\nfunc matrixReshape(mat [][]int, r int, c int) [][]int {\\n\\tif len(mat) == 0 || len(mat[0]) == 0 {\\n\\t\\treturn mat\\n\\t} else if r*c != len(mat)*len(mat[0]) {\\n\\t\\treturn mat\\n\\t}\\n\\n\\tresult := [][]int{}\\n\\tp := 0\\n\\n\\tfor _, row := range mat {\\n\\t\\tfor _, v := range row {\\n\\t\\t\\tif p%c == 0 {\\n\\t\\t\\t\\tresult = append(result, []int{v})\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresult[p/c] = append(result[p/c], v)\\n\\t\\t\\t}\\n\\n\\t\\t\\tp++\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc matrixReshape(mat [][]int, r int, c int) [][]int {\\n\\tif len(mat) == 0 || len(mat[0]) == 0 {\\n\\t\\treturn mat\\n\\t} else if r*c != len(mat)*len(mat[0]) {\\n\\t\\treturn mat\\n\\t}\\n\\n\\tresult := [][]int{}\\n\\tp := 0\\n\\n\\tfor _, row := range mat {\\n\\t\\tfor _, v := range row {\\n\\t\\t\\tif p%c == 0 {\\n\\t\\t\\t\\tresult = append(result, []int{v})\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresult[p/c] = append(result[p/c], v)\\n\\t\\t\\t}\\n\\n\\t\\t\\tp++\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1744720,
                "title": "11-ms-faster-than-70-37-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        \\n         if( mat.size() * mat[0].size() != r*c)\\n            return mat;\\n        \\n        vector<vector<int>>ans(r,vector<int>(c));\\n        \\n        int row=0, col =0;\\n        \\n        for( int i = 0 ; i <mat.size() ; i++ ){\\n            \\n            for( int j = 0 ; j < mat[0].size() ; j++ ){\\n                \\n                if( col == c ){\\n                    row++;\\n                    col=0;\\n                }\\n                 ans[row][col] = mat[i][j];\\n                col++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE IF THIS SOLUTION IS HELPFUL FOR YOU**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        \\n         if( mat.size() * mat[0].size() != r*c)\\n            return mat;\\n        \\n        vector<vector<int>>ans(r,vector<int>(c));\\n        \\n        int row=0, col =0;\\n        \\n        for( int i = 0 ; i <mat.size() ; i++ ){\\n            \\n            for( int j = 0 ; j < mat[0].size() ; j++ ){\\n                \\n                if( col == c ){\\n                    row++;\\n                    col=0;\\n                }\\n                 ans[row][col] = mat[i][j];\\n                col++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704131,
                "title": "c-easy-solution-without-converting-to-1-d-array-beginner-friendly",
                "content": "*Please **upvote** if you find it helpful :)*\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int mr = mat.size();\\n        int nc = mat[0].size();\\n        vector<vector<int> > ans;\\n        if(mr*nc != r*c)\\n            return mat;\\n        int k=0,l=0;\\n        for(int i=0;i<r;i++) {\\n            vector<int> v;\\n            for(int j=0;j<c;j++) {\\n                v.push_back(mat[k][l]);\\n                l++;\\n                if(l>=nc) {\\n                    k++;\\n                    l=0;\\n                }\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int mr = mat.size();\\n        int nc = mat[0].size();\\n        vector<vector<int> > ans;\\n        if(mr*nc != r*c)\\n            return mat;\\n        int k=0,l=0;\\n        for(int i=0;i<r;i++) {\\n            vector<int> v;\\n            for(int j=0;j<c;j++) {\\n                v.push_back(mat[k][l]);\\n                l++;\\n                if(l>=nc) {\\n                    k++;\\n                    l=0;\\n                }\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1699893,
                "title": "python-3-84ms-o-m-n-creating-new-matrix-inserting-our-values-easy-solution",
                "content": "Creating New Matrix of 0s and then Inserting our values one by one.\\nTakes O(m * n) Time & Space.\\n\\n```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        n,m=len(mat[0]),len(mat)\\n        if n*m!=r*c:\\n            return mat\\n        k=0\\n        tmp=[]\\n        output=[[0 for i in range(c)] for j in range(r)]\\n        for i in mat:\\n            for j in i:\\n                tmp.append(j)\\n        for i in range(r):\\n            for j in range(c):\\n                output[i][j] = tmp[k]\\n                k+=1\\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        n,m=len(mat[0]),len(mat)\\n        if n*m!=r*c:\\n            return mat\\n        k=0\\n        tmp=[]\\n        output=[[0 for i in range(c)] for j in range(r)]\\n        for i in mat:\\n            for j in i:\\n                tmp.append(j)\\n        for i in range(r):\\n            for j in range(c):\\n                output[i][j] = tmp[k]\\n                k+=1\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637695,
                "title": "best-solution-100-0ms-clean-code",
                "content": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int[][] matrix = new int[r][c];\\n        if(r*c != mat.length*mat[0].length) return mat;\\n        int m = 0;\\n        int n = 0;\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[0].length;j++){\\n                if(m!=r){\\n                    matrix[m][n]=mat[i][j];\\n                    n++;\\n                    if(n==c){\\n                       m++;\\n                       n=0;\\n                    }\\n                }\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n```\\n**Feel free to ask questions in the comment section.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int[][] matrix = new int[r][c];\\n        if(r*c != mat.length*mat[0].length) return mat;\\n        int m = 0;\\n        int n = 0;\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[0].length;j++){\\n                if(m!=r){\\n                    matrix[m][n]=mat[i][j];\\n                    n++;\\n                    if(n==c){\\n                       m++;\\n                       n=0;\\n                    }\\n                }\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467350,
                "title": "python3-easy-solution-o-n-m-with-explanation-and-problem-solving-logic",
                "content": "```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        \\n        # first step is quite obvious - check if transformation is possible\\n        # check if rows*columns dimensions are same for og and transformed matrix\\n        \\n        if len(mat)*len(mat[0]) != r*c:\\n            return mat\\n        \\n        # create a new blank matrix with new dimensions (r*c)\\n        \\n        new_mat = [[0 for i in range(c)] for i in range(r)]\\n        \\n        # now let\\'s dive into the problem\\n        # we will iterate through each zero in the new matrix and modify it according to the value in the old matrix \\n        # so we will need new pointers that move through old matrix\\n        \\n        # let\\'s initiate two new pointers\\n        \\n        old_row = old_col = 0\\n        \\n        # let\\'s begin the loop\\n        \\n        for i in range(r):\\n            for j in range(c):\\n                new_mat[i][j] = mat[old_row][old_col] # here we set new mat (0,0) to old mat (0,0)\\n                \\n                # let\\'s decide where to go from now\\n                \\n                # if index runs out of new dimensions, reset the column to zero and change row to +1; that is..\\n                # .. traverse to the first column of next row and start from there\\n                \\n                if old_col+1 > len(mat[0])-1:\\n                    old_col=0\\n                    old_row+=1\\n                else:\\n                    old_col+=1\\n                    \\n        return new_mat\\n                   \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        \\n        # first step is quite obvious - check if transformation is possible\\n        # check if rows*columns dimensions are same for og and transformed matrix\\n        \\n        if len(mat)*len(mat[0]) != r*c:\\n            return mat\\n        \\n        # create a new blank matrix with new dimensions (r*c)\\n        \\n        new_mat = [[0 for i in range(c)] for i in range(r)]\\n        \\n        # now let\\'s dive into the problem\\n        # we will iterate through each zero in the new matrix and modify it according to the value in the old matrix \\n        # so we will need new pointers that move through old matrix\\n        \\n        # let\\'s initiate two new pointers\\n        \\n        old_row = old_col = 0\\n        \\n        # let\\'s begin the loop\\n        \\n        for i in range(r):\\n            for j in range(c):\\n                new_mat[i][j] = mat[old_row][old_col] # here we set new mat (0,0) to old mat (0,0)\\n                \\n                # let\\'s decide where to go from now\\n                \\n                # if index runs out of new dimensions, reset the column to zero and change row to +1; that is..\\n                # .. traverse to the first column of next row and start from there\\n                \\n                if old_col+1 > len(mat[0])-1:\\n                    old_col=0\\n                    old_row+=1\\n                else:\\n                    old_col+=1\\n                    \\n        return new_mat\\n                   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317689,
                "title": "4ms-golang-solution-using-channels-and-go-routine",
                "content": "```\\nfunc matrixReshape(mat [][]int, r int, c int) [][]int {\\n    n,m := len(mat), len(mat[0])\\n    \\n    if n * m != r * c {\\n        return mat\\n    }\\n    \\n    ans := make([][]int, r)\\n    for i := range ans {\\n        ans[i] = make([]int,c)\\n    }\\n    \\n    ch,done := make(chan int),make(chan struct{})\\n    go receiveVal(&mat,n,m,ch)\\n    go sendVal(&ans,r,c,ch,done)\\n    <- done\\n    return ans\\n}\\n\\nfunc receiveVal(mat *[][]int,n,m int,ch chan<- int) {\\n    for i := 0; i < n; i++ {\\n        for j := 0; j < m; j++ {\\n            ch <- (*mat)[i][j]\\n        }\\n    }\\n}\\n\\nfunc sendVal(ans *[][]int,n,m int,ch <-chan int,done chan struct{}) {\\n    for i := 0; i < n; i++ {\\n        for j := 0; j < m; j++ {\\n            (*ans)[i][j] = <- ch\\n        }\\n    }\\n    done <- struct{}{}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc matrixReshape(mat [][]int, r int, c int) [][]int {\\n    n,m := len(mat), len(mat[0])\\n    \\n    if n * m != r * c {\\n        return mat\\n    }\\n    \\n    ans := make([][]int, r)\\n    for i := range ans {\\n        ans[i] = make([]int,c)\\n    }\\n    \\n    ch,done := make(chan int),make(chan struct{})\\n    go receiveVal(&mat,n,m,ch)\\n    go sendVal(&ans,r,c,ch,done)\\n    <- done\\n    return ans\\n}\\n\\nfunc receiveVal(mat *[][]int,n,m int,ch chan<- int) {\\n    for i := 0; i < n; i++ {\\n        for j := 0; j < m; j++ {\\n            ch <- (*mat)[i][j]\\n        }\\n    }\\n}\\n\\nfunc sendVal(ans *[][]int,n,m int,ch <-chan int,done chan struct{}) {\\n    for i := 0; i < n; i++ {\\n        for j := 0; j < m; j++ {\\n            (*ans)[i][j] = <- ch\\n        }\\n    }\\n    done <- struct{}{}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1317136,
                "title": "c-beginner-frindly-easy-to-understand",
                "content": "just check if the number of elements in the reshaped matrix and original array are equal or not.\\nif then store in another matrix with given row and column.\\n\\nfor assigning values,\\niterate over the size of new matrix and assign the value as shown in the code.\\n\\nHere\\'s the code:\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        // size of the mat matrix\\n        int a=mat.size();\\n        int b=mat[0].size();\\n        \\n        // check if the size is equal to the new matrix or not\\n        if(a*b!=r*c)\\n            return mat;\\n        // 2-d vector of the given size\\n        vector<vector<int>> ans(r,vector<int>(c,0));\\n        \\n        int p=0;\\n        int q=0;\\n        \\n        // assign values of mat matrix to new matrix\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                ans[i][j]=mat[p%a][(q++)%b];\\n                if(q%b==0)\\n                    p++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        // size of the mat matrix\\n        int a=mat.size();\\n        int b=mat[0].size();\\n        \\n        // check if the size is equal to the new matrix or not\\n        if(a*b!=r*c)\\n            return mat;\\n        // 2-d vector of the given size\\n        vector<vector<int>> ans(r,vector<int>(c,0));\\n        \\n        int p=0;\\n        int q=0;\\n        \\n        // assign values of mat matrix to new matrix\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                ans[i][j]=mat[p%a][(q++)%b];\\n                if(q%b==0)\\n                    p++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089254,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def matrixReshape(self, nums: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        n = len(nums)\\n        m = len(nums[0])\\n        if n*m != r*c:\\n            return nums\\n        else:\\n            l = []\\n            res = []\\n            for i in range(n):\\n                l.extend(nums[i])\\n            for i in range(r):\\n                res.append(l[i*c:i*c+c])\\n            return res\\n```\\n**If you like the solution, please vote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixReshape(self, nums: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        n = len(nums)\\n        m = len(nums[0])\\n        if n*m != r*c:\\n            return nums\\n        else:\\n            l = []\\n            res = []\\n            for i in range(n):\\n                l.extend(nums[i])\\n            for i in range(r):\\n                res.append(l[i*c:i*c+c])\\n            return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 989608,
                "title": "python-3-short-solution-o-mr-88ms-97",
                "content": "```\\nclass Solution:\\n    def matrixReshape(self, nums: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        #\\n        m = len(nums); n = len(nums[0])\\n        if m*n != r*c: return nums\\n        flattern = []\\n        for i in range(m):\\n            flattern += nums[i]\\n        return [flattern[i*c:i*c+c] for i in range(r)]\\n```\\n![image](https://assets.leetcode.com/users/images/f3f47eb7-f938-4e92-8422-05ac72983c47_1609102643.755119.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixReshape(self, nums: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        #\\n        m = len(nums); n = len(nums[0])\\n        if m*n != r*c: return nums\\n        flattern = []\\n        for i in range(m):\\n            flattern += nums[i]\\n        return [flattern[i*c:i*c+c] for i in range(r)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 228106,
                "title": "python-solution-beats-unstable",
                "content": "```\\nclass Solution(object):\\n    def matrixReshape(self, nums, r, c):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :type r: int\\n        :type c: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if r * c != len(nums) * len(nums[0]):\\n            return nums\\n        \\n        result = []\\n        row = []\\n        for num in nums:\\n            for n in num:\\n                row.append(n)\\n                if len(row) == c:\\n                    result.append(row)\\n                    row = []\\n        \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def matrixReshape(self, nums, r, c):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :type r: int\\n        :type c: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if r * c != len(nums) * len(nums[0]):\\n            return nums\\n        \\n        result = []\\n        row = []\\n        for num in nums:\\n            for n in num:\\n                row.append(n)\\n                if len(row) == c:\\n                    result.append(row)\\n                    row = []\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 223530,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {\\n        int M=nums.size(), N=nums[0].size();\\n        if(M*N!=r*c) return nums;\\n        \\n        vector<vector<int>> res(r,vector<int>(c));\\n       int k=0,t=0;\\n      for(int i=0;i<M;++i){\\n          for(int j=0;j<N;++j){\\n              if(t>=c) {\\n                  t=0;++k;\\n              }\\n              if(k>=r) return res;\\n              \\n              res[k][t++]=nums[i][j];\\n          }\\n      }\\n        return res;\\n    }\\n};\\n```\\n\\nO(MN) 20ms beats 100%",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {\\n        int M=nums.size(), N=nums[0].size();\\n        if(M*N!=r*c) return nums;\\n        \\n        vector<vector<int>> res(r,vector<int>(c));\\n       int k=0,t=0;\\n      for(int i=0;i<M;++i){\\n          for(int j=0;j<N;++j){\\n              if(t>=c) {\\n                  t=0;++k;\\n              }\\n              if(k>=r) return res;\\n              \\n              res[k][t++]=nums[i][j];\\n          }\\n      }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 156391,
                "title": "python-beats-93-59",
                "content": "```\\nclass Solution:\\n    def matrixReshape(self, nums, r, c):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :type r: int\\n        :type c: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if nums is None:\\n            return None\\n        \\n        if r*c != len(nums) * len(nums[0]):\\n            return nums\\n             \\n        re = []\\n        tem = []\\n        for row in range(len(nums)):\\n            for col in range(len(nums[0])):\\n                tem.append(nums[row][col])\\n                \\n        for ind in range(0, r*c, c):\\n            re.append(tem[ind:ind+c])\\n        \\n        return re\\n\\t\\t\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def matrixReshape(self, nums, r, c):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :type r: int\\n        :type c: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if nums is None:\\n            return None\\n        \\n        if r*c != len(nums) * len(nums[0]):\\n            return nums\\n             \\n        re = []\\n        tem = []\\n        for row in range(len(nums)):\\n            for col in range(len(nums[0])):\\n                tem.append(nums[row][col])\\n                \\n        for ind in range(0, r*c, c):\\n            re.append(tem[ind:ind+c])\\n        \\n        return re\\n\\t\\t\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102551,
                "title": "intuitive-javascript-solution",
                "content": "```\\nvar matrixReshape = function(nums, r, c) {\\n    const numsRow = nums.length;\\n    const numsCol = nums[0].length;\\n    const output = [];\\n    \\n    let flatNums = null;\\n    \\n    // return original if new dimension doesn't match \\n    if (r * c !== numsRow * numsCol) return nums;\\n    \\n    // deconstruct the original array and reconstruct new array\\n    flatNums = nums.reduce((acc, curr) => acc.concat(curr), []);\\n    \\n    for (let i = 0; i < r; i++) \\n        output.push(flatNums.splice(0, c));\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar matrixReshape = function(nums, r, c) {\\n    const numsRow = nums.length;\\n    const numsCol = nums[0].length;\\n    const output = [];\\n    \\n    let flatNums = null;\\n    \\n    // return original if new dimension doesn't match \\n    if (r * c !== numsRow * numsCol) return nums;\\n    \\n    // deconstruct the original array and reconstruct new array\\n    flatNums = nums.reduce((acc, curr) => acc.concat(curr), []);\\n    \\n    for (let i = 0; i < r; i++) \\n        output.push(flatNums.splice(0, c));\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 102578,
                "title": "ruby-oneliner",
                "content": "```\\ndef matrix_reshape(nums, r, c)\\n  r * c == nums.flatten.size ? nums.flatten.each_slice(c).to_a : nums\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef matrix_reshape(nums, r, c)\\n  r * c == nums.flatten.size ? nums.flatten.each_slice(c).to_a : nums\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3364530,
                "title": "python-solution-for-beginner-easy-explained",
                "content": "# Complexity\\n- Time complexity:\\nO(r*c) \\n\\n- Dont use \"[[0]* col] * row\" for new matrix. This cannot be mutated for each cell since it  only creates a single object for each row.\\n- [i//c] gives the row number and [i%c] gives the coloum number  \\n# Code\\n```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n\\n        if not mat or r*c != len(mat) * len(mat[0]):\\n            return mat\\n     \\n        l = [[0 for _ in range(c)] for _ in range(r)]\\n\\n        n=len(mat[0])\\n\\n        i=0\\n        while i < r*c:\\n            l[i//c][i%c] = mat[i//n][i%n]  \\n            i+=1\\n        return l",
                "solutionTags": [
                    "Python3"
                ],
                "code": "# Complexity\\n- Time complexity:\\nO(r*c) \\n\\n- Dont use \"[[0]* col] * row\" for new matrix. This cannot be mutated for each cell since it  only creates a single object for each row.\\n- [i//c] gives the row number and [i%c] gives the coloum number  \\n# Code\\n```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n\\n        if not mat or r*c != len(mat) * len(mat[0]):\\n            return mat\\n     \\n        l = [[0 for _ in range(c)] for _ in range(r)]\\n\\n        n=len(mat[0])\\n\\n        i=0\\n        while i < r*c:\\n            l[i//c][i%c] = mat[i//n][i%n]  \\n            i+=1\\n        return l",
                "codeTag": "Java"
            },
            {
                "id": 3304096,
                "title": "simple-easy-to-understand-java-code",
                "content": "# Intuition\\nWe need to check for the feasibilty of reshaped matrix\\n\\n## Approach\\nIf the new row*new column > old row*old column or new row and column are same as old we will return old matrix\\n## Complexity\\n# - Time complexity:\\nO(m*n)\\n- Space complexity:\\nO(r*c)\\n\\n## Code\\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int curr_r = mat.length;\\n        int curr_c = mat[0].length;\\n        if(curr_r*curr_c != r*c || curr_r == r && curr_c==c){\\n            return mat;\\n        }\\n            int[][] result = new int[r][c];\\n            int new_c =0;\\n            int new_r =0;\\n            for(int i=0;i<curr_r;i++){\\n                for(int j =0;j<curr_c;j++){\\n                    if(new_c == c ){\\n                        new_r++;\\n                        new_c=0;\\n                    }\\n                    result[new_r][new_c++] = mat[i][j];\\n                }\\n            }\\n            return result;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int curr_r = mat.length;\\n        int curr_c = mat[0].length;\\n        if(curr_r*curr_c != r*c || curr_r == r && curr_c==c){\\n            return mat;\\n        }\\n            int[][] result = new int[r][c];\\n            int new_c =0;\\n            int new_r =0;\\n            for(int i=0;i<curr_r;i++){\\n                for(int j =0;j<curr_c;j++){\\n                    if(new_c == c ){\\n                        new_r++;\\n                        new_c=0;\\n                    }\\n                    result[new_r][new_c++] = mat[i][j];\\n                }\\n            }\\n            return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007582,
                "title": "simple-java-beats-100-runtime-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to arrange the elements of the matrix into new matrix of given row and column.\\nWe have to check whether it is possible to construct a new array or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    1. Check the base conditions.\\n    2. Create a new array.\\n    3. Traverse and store the elements.\\nFollow the code below to understand the solution.\\n\\n             **If this solution helped you, give it an up-vote to help others** \\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n\\n        int oldRow = mat.length;\\n        int oldCol = mat[0].length;\\n\\n\\n        //We have to check whether it is possible to construct-\\n        //-a new array or not.\\n        //we can check it by comparing the total elements.\\n        if(oldCol*oldRow != r*c) return mat;\\n\\n        int [] [] arr = new int[r][c];\\n        int i = 0;      // row of new array\\n        int j = 0;      // col of new array\\n        int k = 0;      // row of old array\\n        int l = 0;      // col of old array\\n\\n        //Traverse the new array and put elements from the old array.\\n        for(i = 0; i < r; i++)\\n        {\\n            for(j = 0; j < c; j++)\\n            {\\n                arr[i][j] = mat[k][l];\\n\\n                //We also need to update the indices of the old array.\\n                //If column length is reached then increment row\\n                // and reset column to 0;\\n                l++;\\n                if(l == oldCol)\\n                {\\n                    k++;\\n                    l = 0;\\n                }\\n\\n            }\\n        }\\n        //Finally, return the new array;\\n        return arr;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n\\n        int oldRow = mat.length;\\n        int oldCol = mat[0].length;\\n\\n\\n        //We have to check whether it is possible to construct-\\n        //-a new array or not.\\n        //we can check it by comparing the total elements.\\n        if(oldCol*oldRow != r*c) return mat;\\n\\n        int [] [] arr = new int[r][c];\\n        int i = 0;      // row of new array\\n        int j = 0;      // col of new array\\n        int k = 0;      // row of old array\\n        int l = 0;      // col of old array\\n\\n        //Traverse the new array and put elements from the old array.\\n        for(i = 0; i < r; i++)\\n        {\\n            for(j = 0; j < c; j++)\\n            {\\n                arr[i][j] = mat[k][l];\\n\\n                //We also need to update the indices of the old array.\\n                //If column length is reached then increment row\\n                // and reset column to 0;\\n                l++;\\n                if(l == oldCol)\\n                {\\n                    k++;\\n                    l = 0;\\n                }\\n\\n            }\\n        }\\n        //Finally, return the new array;\\n        return arr;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938870,
                "title": "java-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\\n        int m = nums.length, n = nums[0].length;\\n        if (m * n != r * c) return nums;\\n        int[][] result = new int[r][c];\\n        for (int i = 0; i < m * n; ++i) {\\n            result[i / c][i % c] = nums[i / n][i % n];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\\n        int m = nums.length, n = nums[0].length;\\n        if (m * n != r * c) return nums;\\n        int[][] result = new int[r][c];\\n        for (int i = 0; i < m * n; ++i) {\\n            result[i / c][i % c] = nums[i / n][i % n];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835288,
                "title": "java-o-n-1ms-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int m = mat.length, n = mat[0].length;\\n        if (m * n != r * c) return mat;\\n        int count = 0;\\n        int[][] arr = new int[r][c];\\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                arr[i][j] = mat[count / n][count % n];\\n                count++;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int m = mat.length, n = mat[0].length;\\n        if (m * n != r * c) return mat;\\n        int count = 0;\\n        int[][] arr = new int[r][c];\\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                arr[i][j] = mat[count / n][count % n];\\n                count++;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647771,
                "title": "simplest-o-n-m-python-solution-explained-with-examples",
                "content": "**Thought process**\\nThe most important part of this problem is figuring out how to swap between the indices in our m\\u2022n matrix to the indices of the r\\u2022c matrix. To do this, let\\'s think about the first example given in the problem and a second example which I have created\\n\\n**Example 1:**\\n```\\n1, 2      -->      1, 2, 3, 4\\n3, 4\\nm = 2, n = 2\\nr = 1, c = 4\\n```\\nLet\\'s walk through the index of each element before and after the transformation.\\n```\\nElement     |   original index   |   final index\\n\\t1                (0,0)              (0,0)\\n\\t2                (0,1)              (0,1)\\n\\t3                (1,0)              (0,2)\\n\\t4                (1,1)              (0,3)\\n```\\n\\n**Custom Example:**\\n```\\n0, 1, 2      -->      0, 1\\n3, 4, 5               2, 3\\n                      4, 5\\nm = 2, n = 3\\nr = 3, c = 2\\n```\\n```\\nElement     |   original index   |   final index\\n\\t0                (0,0)              (0,0)\\n\\t1                (0,1)              (0,1)\\n\\t2                (0,2)              (1,0)\\n\\t3                (1,0)              (1,1)\\n\\t4                (1,1)              (2,0)\\n\\t5                (1,2)              (2,1)\\t\\n```\\nIn these examples, we can notice two things. First, the \"y\" index of any element in our final array is always less than ```c```. Second, the \"x\" index of each element in our final array increases after we have already added ```c``` elements to the array. In the first example, this meant that all 4 elements had an \"x\" index of 0 and a \"y\" index which increased from 0 to 3. In the second example, \\nThe way we can simulate this mathematically is using the ```//``` and ```%``` operators. If we have some number ```num``` and are calculating ```n//c```, the result will only increase when ```num``` increases by ```c```. Therefore, we can use ```//``` to get the \"x\" index of our numbers. Similarly, we can use ```num%c``` to find the \"y\" index since we want it to go from ```0``` to ```c-1```. So our plan will be to visit each element in ```mat``` and to add it to our final array in the ```(num//c, num%c)``` index.\\n\\n**O(n\\u2022m) Time & Space Solution**\\n```\\ndef matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n\\tm = len(mat)\\n\\tn = len(mat[0])\\n\\tif n*m!=r*c: #if the total number of elements in the original matrix wouldn\\'t fit into a r by  c matrix\\n\\t\\treturn mat #return original\\n\\tans = [[0 for i in range(c)] for j in range(r)] #new empty matrix\\n\\tnum = 0 #keep track of how many elements we have added to our new array\\n\\tfor i in range(m): #iterating through mat\\n\\t\\tfor j in range(n):\\n\\t\\t\\trow = num//c #the row we are writing into\\n\\t\\t\\tcol = num%c #the column we are writing into\\n\\t\\t\\tans[row][col] = mat[i][j] #add this element to the row in ans\\n\\t\\t\\tnum+=1 #we added the last element\\n\\treturn ans\\n```\\nThe first section of the code, ```if n*m!=r*c:```, is necessary to check that the number of elements in the original matrix can be reshaped into a r by c matrix. Then we simply figure out what row and column in the original matrix we should be accessing and then add that element to our new matrix.\\n\\n**Thanks for Reading!**\\nIf this post has been helpful, please consider upvoting! Also, if I made any mistakes or there are other optimizations, methods I didn\\'t consider, etc. please let me know!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n1, 2      -->      1, 2, 3, 4\\n3, 4\\nm = 2, n = 2\\nr = 1, c = 4\\n```\n```\\nElement     |   original index   |   final index\\n\\t1                (0,0)              (0,0)\\n\\t2                (0,1)              (0,1)\\n\\t3                (1,0)              (0,2)\\n\\t4                (1,1)              (0,3)\\n```\n```\\n0, 1, 2      -->      0, 1\\n3, 4, 5               2, 3\\n                      4, 5\\nm = 2, n = 3\\nr = 3, c = 2\\n```\n```\\nElement     |   original index   |   final index\\n\\t0                (0,0)              (0,0)\\n\\t1                (0,1)              (0,1)\\n\\t2                (0,2)              (1,0)\\n\\t3                (1,0)              (1,1)\\n\\t4                (1,1)              (2,0)\\n\\t5                (1,2)              (2,1)\\t\\n```\n```c```\n```c```\n```//```\n```%```\n```num```\n```n//c```\n```num```\n```c```\n```//```\n```num%c```\n```0```\n```c-1```\n```mat```\n```(num//c, num%c)```\n```\\ndef matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n\\tm = len(mat)\\n\\tn = len(mat[0])\\n\\tif n*m!=r*c: #if the total number of elements in the original matrix wouldn\\'t fit into a r by  c matrix\\n\\t\\treturn mat #return original\\n\\tans = [[0 for i in range(c)] for j in range(r)] #new empty matrix\\n\\tnum = 0 #keep track of how many elements we have added to our new array\\n\\tfor i in range(m): #iterating through mat\\n\\t\\tfor j in range(n):\\n\\t\\t\\trow = num//c #the row we are writing into\\n\\t\\t\\tcol = num%c #the column we are writing into\\n\\t\\t\\tans[row][col] = mat[i][j] #add this element to the row in ans\\n\\t\\t\\tnum+=1 #we added the last element\\n\\treturn ans\\n```\n```if n*m!=r*c:```",
                "codeTag": "Python3"
            },
            {
                "id": 2548420,
                "title": "short-line-code-shortest-easy-c-check-it",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) \\n    {\\n        vector<vector<int>> vec(r, vector<int>(c));\\n        if (mat.size() * mat[0].size() != r*c) return mat;\\n        for (int i = 0; i < (mat.size() * mat[0].size()); i++)\\n        {\\n            vec[i/c][i%c] = mat[i/mat[0].size()][i%mat[0].size()];\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) \\n    {\\n        vector<vector<int>> vec(r, vector<int>(c));\\n        if (mat.size() * mat[0].size() != r*c) return mat;\\n        for (int i = 0; i < (mat.size() * mat[0].size()); i++)\\n        {\\n            vec[i/c][i%c] = mat[i/mat[0].size()][i%mat[0].size()];\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468112,
                "title": "c-easy-small-code",
                "content": "```\\nint m = mat.size();\\n        int n = mat[0].size();\\n        \\n        vector<vector<int>> ans( r , vector<int> (c)); \\n        vector <int> vec;\\n        \\n        if (m*n == r*c) {\\n            \\n            for (int i = 0; i < m; i++) {\\n                \\n                for(int j = 0; j < n; j++) {\\n                    vec.push_back(mat[i][j]);\\n                }\\n            }\\n            \\n            int k = 0;\\n            for (int i = 0; i < r; i++) {\\n                \\n                for(int j = 0; j < c; j++) {\\n                    ans[i][j] = vec[k];\\n                    k++;\\n                }\\n            }\\n            \\n            return ans;\\n        }\\n        \\n        else return mat;",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nint m = mat.size();\\n        int n = mat[0].size();\\n        \\n        vector<vector<int>> ans( r , vector<int> (c)); \\n        vector <int> vec;\\n        \\n        if (m*n == r*c) {\\n            \\n            for (int i = 0; i < m; i++) {\\n                \\n                for(int j = 0; j < n; j++) {\\n                    vec.push_back(mat[i][j]);\\n                }\\n            }\\n            \\n            int k = 0;\\n            for (int i = 0; i < r; i++) {\\n                \\n                for(int j = 0; j < c; j++) {\\n                    ans[i][j] = vec[k];\\n                    k++;\\n                }\\n            }\\n            \\n            return ans;\\n        }\\n        \\n        else return mat;",
                "codeTag": "Unknown"
            },
            {
                "id": 2383173,
                "title": "c-matrix-traversal-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = mat.size(), n = mat[0].size();\\n        if(m*n != r*c)\\n            return mat;\\n        vector<vector<int>> res(r, vector<int>(c));\\n        \\n        int k = 0, l = 0;\\n        for(int i = 0; i < m; i++) \\n            for(int j = 0; j < n; j++) {\\n                res[k][l++] = mat[i][j]; \\n                if(l == c) k++,l = 0;\\n            }\\n                \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = mat.size(), n = mat[0].size();\\n        if(m*n != r*c)\\n            return mat;\\n        vector<vector<int>> res(r, vector<int>(c));\\n        \\n        int k = 0, l = 0;\\n        for(int i = 0; i < m; i++) \\n            for(int j = 0; j < n; j++) {\\n                res[k][l++] = mat[i][j]; \\n                if(l == c) k++,l = 0;\\n            }\\n                \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366367,
                "title": "python-intuitive",
                "content": "```\\n def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        if len(mat)*len(mat[0]) == r*c:\\n            lis = []\\n            for i in mat:\\n                lis += i\\n            res = [[0 for i in range(c)] for j in range(r)]\\n            ind = 0\\n            for i in range(r):\\n                for j in range(c):\\n                    res[i][j] = lis[ind]\\n                    ind += 1\\n            return res\\n        return mat\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        if len(mat)*len(mat[0]) == r*c:\\n            lis = []\\n            for i in mat:\\n                lis += i\\n            res = [[0 for i in range(c)] for j in range(r)]\\n            ind = 0\\n            for i in range(r):\\n                for j in range(c):\\n                    res[i][j] = lis[ind]\\n                    ind += 1\\n            return res\\n        return mat\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2314861,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        if(r * c != m * n) return mat;\\n        vector<vector<int>> reshaped = vector<vector<int>>(r, vector<int>(c, 0));\\n        for(int i = 0; i < m*n; i++) {\\n                reshaped[i/c][i%c] = mat[i/n][i%n];\\n        }\\n        return reshaped;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        if(r * c != m * n) return mat;\\n        vector<vector<int>> reshaped = vector<vector<int>>(r, vector<int>(c, 0));\\n        for(int i = 0; i < m*n; i++) {\\n                reshaped[i/c][i%c] = mat[i/n][i%n];\\n        }\\n        return reshaped;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2286972,
                "title": "java-easy-to-understand-100-fast",
                "content": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        if((m * n) != (r * c)) return mat;\\n        int[][] ans = new int[r][c];\\n        int row = 0;\\n        int col = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                ans[row][col] = mat[i][j];\\n                col++;\\n                if (col == c){ \\n                    row++;\\n                    col = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        if((m * n) != (r * c)) return mat;\\n        int[][] ans = new int[r][c];\\n        int row = 0;\\n        int col = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                ans[row][col] = mat[i][j];\\n                col++;\\n                if (col == c){ \\n                    row++;\\n                    col = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2251623,
                "title": "python-single-for-loop-fast",
                "content": "```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        cm = len(mat[0])\\n        if r*c != len(mat)*cm:\\n            return mat\\n        \\n        out = [[] for i in range(r)]\\n        for i in range(r*c):\\n            out[i//c].append(mat[i//cm][i%cm])\\n        return out\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        cm = len(mat[0])\\n        if r*c != len(mat)*cm:\\n            return mat\\n        \\n        out = [[] for i in range(r)]\\n        for i in range(r*c):\\n            out[i//c].append(mat[i//cm][i%cm])\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2248978,
                "title": "go-o-n",
                "content": "```\\nfunc matrixReshape(mat [][]int, r int, c int) [][]int {\\n    if r*c != len(mat)*len(mat[0]) { return mat }\\n    \\n    res := make([][]int, r)\\n    \\n    for i := 0; i < r; i++ {\\n        res[i] = make([]int, c)\\n    }\\n    \\n    resRow, resCol := 0, 0\\n    \\n    for row := 0; row < len(mat); row++ {\\n        for col := 0; col < len(mat[0]); col++ {\\n            res[resRow][resCol] = mat[row][col]\\n            resCol++\\n            \\n            if resCol > c - 1 {\\n                resRow++\\n                resCol = 0\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Go"
                ],
                "code": "```\\nfunc matrixReshape(mat [][]int, r int, c int) [][]int {\\n    if r*c != len(mat)*len(mat[0]) { return mat }\\n    \\n    res := make([][]int, r)\\n    \\n    for i := 0; i < r; i++ {\\n        res[i] = make([]int, c)\\n    }\\n    \\n    resRow, resCol := 0, 0\\n    \\n    for row := 0; row < len(mat); row++ {\\n        for col := 0; col < len(mat[0]); col++ {\\n            res[resRow][resCol] = mat[row][col]\\n            resCol++\\n            \\n            if resCol > c - 1 {\\n                resRow++\\n                resCol = 0\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2174495,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n    int m = mat.length;\\n    int n = mat[0].length;\\n    if(m * n != r * c) return mat;\\n    if(m == r && n == c) return mat;\\n    int [][]result = new int[r][c];\\n    int row = 0;\\n    int col = 0;\\n    for(int i=0;i<m;i++){\\n        for(int j=0;j<n;j++){\\n            if(col==c){\\n                row++;\\n                col=0;\\n            }\\n            result[row][col]=mat[i][j];\\n                col++;\\n            }\\n        }\\n    return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n    int m = mat.length;\\n    int n = mat[0].length;\\n    if(m * n != r * c) return mat;\\n    if(m == r && n == c) return mat;\\n    int [][]result = new int[r][c];\\n    int row = 0;\\n    int col = 0;\\n    for(int i=0;i<m;i++){\\n        for(int j=0;j<n;j++){\\n            if(col==c){\\n                row++;\\n                col=0;\\n            }\\n            result[row][col]=mat[i][j];\\n                col++;\\n            }\\n        }\\n    return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2149770,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int[][] m =new int[r][c];\\n        ArrayList<Integer> l =new ArrayList<>();\\n        \\n        for(int[] a:mat){\\n            for(int i:a){\\n                l.add(i);\\n            }\\n        }\\n        if(l.size()!=r*c)\\n            return mat;\\n        \\n        \\n        int k=0;\\n        for(int row=0;row<r;row++){\\n                for(int col=0;col<c;col++){\\n                    m[row][col]=l.get(k);\\n                    k++;\\n                }\\n        }\\n        \\n        \\n        return m;\\n    }      \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int[][] m =new int[r][c];\\n        ArrayList<Integer> l =new ArrayList<>();\\n        \\n        for(int[] a:mat){\\n            for(int i:a){\\n                l.add(i);\\n            }\\n        }\\n        if(l.size()!=r*c)\\n            return mat;\\n        \\n        \\n        int k=0;\\n        for(int row=0;row<r;row++){\\n                for(int col=0;col<c;col++){\\n                    m[row][col]=l.get(k);\\n                    k++;\\n                }\\n        }\\n        \\n        \\n        return m;\\n    }      \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121614,
                "title": "simple-c-solution-in-single-loop",
                "content": "Simply compute respective indices for each array from loop variable iterating over the entire size.\\n\\nTaking an example, we have a 3x4 [n = 3, m = 4] array and we know that at i == 5, we\\'ll have row 1 col 1\\nSo, row = i/m = 5/4 = 1 and col = i - i/m * m = 5 - 5/4 * 4 = 5- 4 = 1\\nergo the formula works and its simple derived from computation of row number, and then computing column number by deleting number of rows * column elements ( as we use zero indexing, it fits!)\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int n = mat.size(), m = mat[0].size();\\n        if(n*m != r*c)\\n            return mat;\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        for(int i =0; i < n*m; i++)\\n            ans[i/c][i- i/c * c] = mat[i/m][i- i/m * m];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int n = mat.size(), m = mat[0].size();\\n        if(n*m != r*c)\\n            return mat;\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        for(int i =0; i < n*m; i++)\\n            ans[i/c][i- i/c * c] = mat[i/m][i- i/m * m];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119436,
                "title": "c-easy-using-single-loop",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int columns= mat[0].size();\\n        int rows = mat.size();\\n        \\n        if(columns*rows != r*c) return mat;\\n        \\n        int total = r*c;\\n        \\n        vector<vector<int>> ans(r,vector<int>(c));\\n         for(int i=0;i<total;i++){\\n             ans[i/c][i%c] = mat[i/columns][i%columns];    \\n         }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int columns= mat[0].size();\\n        int rows = mat.size();\\n        \\n        if(columns*rows != r*c) return mat;\\n        \\n        int total = r*c;\\n        \\n        vector<vector<int>> ans(r,vector<int>(c));\\n         for(int i=0;i<total;i++){\\n             ans[i/c][i%c] = mat[i/columns][i%columns];    \\n         }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2103122,
                "title": "python-solution-easy-beats-94-3-in-tc",
                "content": "```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        \\n        f = sum(mat , [])\\n        lent = len(f)\\n        \\n        #if reshape is not possible then we have to return the same matrix\\n        \\n        if lent != r*c:\\n            return mat\\n        \\n        g = 0\\n        ans = []\\n        \\n        for i in range(r):\\n            l = []\\n            for j in range(c):\\n                l.append(f[g])\\n                g += 1\\n                \\n            ans.append(l)\\n            \\n        return ans\\n```\\n\\nPLEASE UPVOTE...  IF IT HELPED YOU...THEN HELP ME GET MY FIRST UPVOTE : )",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        \\n        f = sum(mat , [])\\n        lent = len(f)\\n        \\n        #if reshape is not possible then we have to return the same matrix\\n        \\n        if lent != r*c:\\n            return mat\\n        \\n        g = 0\\n        ans = []\\n        \\n        for i in range(r):\\n            l = []\\n            for j in range(c):\\n                l.append(f[g])\\n                g += 1\\n                \\n            ans.append(l)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074564,
                "title": "c-2-solutions",
                "content": "**Hey all..**\\nI have solved this in 2 ways using 2d vectors in cpp using basic traversing and counting.\\nI have **commented** in the code so that it can be useful..\\nIf you have any doubts be free to ask..\\nand **please upvote if you understood or found it useful :)**\\n\\nThank you..\\n\\n**TC= O( r*c ) as we are using for loop for all elements of the matrix\\nSC = O ( 1 ) not taking output 2d vector into account.**\\n```\\n// for fastening the input and output operations\\nconst static auto fast=[]{\\nios_base::sync_with_stdio(false);\\ncin.tie(nullptr);\\ncout.tie(nullptr);\\nreturn 0;\\n}();\\n\\n--------- Method 1 ----------\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m=mat.size(),n=mat[0].size();\\n        vector<vector<int>> ans(r,vector<int> (c));\\n\\t\\t// if all elements doesn\\'t fit into another vector \\n        if(m*n!=r*c){\\n            return mat;\\n        }\\n\\t\\t// (i/c) gives new row number to insert.\\n\\t\\t// (i%c) gives new column number to insert.\\n        for(int i=0;i<m*n;i++){\\n            ans[i/c][i%c]=mat[i/n][i%n];\\n        }\\n        return ans;\\n\\t\\t\\n\\t\\t------- Method 2 ------\\n            int row=0,col=0;\\n\\t\\t\\tif(m*n!=r*c){\\n\\t\\t\\t\\treturn mat;\\n\\t\\t\\t}\\n\\t\\t\\t// traversing over all vectors\\n\\t\\t\\tfor(int i=0;i<m;i++){\\n\\t\\t\\t\\t// traversing over vectors inner elements\\n\\t\\t\\t\\t for(int j=0;j<n;j++){\\n\\t\\t\\t\\t\\t // putting inside elements\\n\\t\\t\\t\\t\\t ans[row][col]=mat[i][j];\\n\\t\\t\\t\\t\\t // after one element insertion increment col to insert next element in same row.\\n\\t\\t\\t\\t\\t col++;\\n\\t\\t\\t\\t\\t // if that row fully got filled, then increment row to fillin next row \\n\\t\\t\\t\\t\\t if(col==c){\\n\\t\\t\\t\\t\\t\\t row++;\\n\\t\\t\\t\\t\\t\\t // to start filling from first\\n\\t\\t\\t\\t\\t\\t col=0;\\n\\t\\t\\t\\t\\t }\\n\\t\\t\\t\\t }\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// for fastening the input and output operations\\nconst static auto fast=[]{\\nios_base::sync_with_stdio(false);\\ncin.tie(nullptr);\\ncout.tie(nullptr);\\nreturn 0;\\n}();\\n\\n--------- Method 1 ----------\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m=mat.size(),n=mat[0].size();\\n        vector<vector<int>> ans(r,vector<int> (c));\\n\\t\\t// if all elements doesn\\'t fit into another vector \\n        if(m*n!=r*c){\\n            return mat;\\n        }\\n\\t\\t// (i/c) gives new row number to insert.\\n\\t\\t// (i%c) gives new column number to insert.\\n        for(int i=0;i<m*n;i++){\\n            ans[i/c][i%c]=mat[i/n][i%n];\\n        }\\n        return ans;\\n\\t\\t\\n\\t\\t------- Method 2 ------\\n            int row=0,col=0;\\n\\t\\t\\tif(m*n!=r*c){\\n\\t\\t\\t\\treturn mat;\\n\\t\\t\\t}\\n\\t\\t\\t// traversing over all vectors\\n\\t\\t\\tfor(int i=0;i<m;i++){\\n\\t\\t\\t\\t// traversing over vectors inner elements\\n\\t\\t\\t\\t for(int j=0;j<n;j++){\\n\\t\\t\\t\\t\\t // putting inside elements\\n\\t\\t\\t\\t\\t ans[row][col]=mat[i][j];\\n\\t\\t\\t\\t\\t // after one element insertion increment col to insert next element in same row.\\n\\t\\t\\t\\t\\t col++;\\n\\t\\t\\t\\t\\t // if that row fully got filled, then increment row to fillin next row \\n\\t\\t\\t\\t\\t if(col==c){\\n\\t\\t\\t\\t\\t\\t row++;\\n\\t\\t\\t\\t\\t\\t // to start filling from first\\n\\t\\t\\t\\t\\t\\t col=0;\\n\\t\\t\\t\\t\\t }\\n\\t\\t\\t\\t }\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1965495,
                "title": "java-easy-simple-iterative-approach",
                "content": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int m = mat.length, n = mat[0].length;\\n        if(m*n != r*c) {\\n            return mat;\\n        }\\n        int[][] answer = new int[r][c];\\n        int x = 0, y = 0;\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                answer[x][y++] = mat[i][j];\\n                if(y == c) {\\n                    x++;\\n                    y = 0;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int m = mat.length, n = mat[0].length;\\n        if(m*n != r*c) {\\n            return mat;\\n        }\\n        int[][] answer = new int[r][c];\\n        int x = 0, y = 0;\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                answer[x][y++] = mat[i][j];\\n                if(y == c) {\\n                    x++;\\n                    y = 0;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829052,
                "title": "without-nested-loops-80",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m_r = mat.size();\\n        int m_c = mat[0].size();\\n        \\n        if (r*c != m_r*m_c)\\n            return mat;\\n        \\n        vector<vector<int>> out(r, vector<int>(c));\\n        \\n        int ind=0;\\n        while(ind < r*c){\\n            out[ind/c][ind%c] = mat[ind/m_c][ind%m_c];\\n            ind++;\\n        }\\n        return out;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int m_r = mat.size();\\n        int m_c = mat[0].size();\\n        \\n        if (r*c != m_r*m_c)\\n            return mat;\\n        \\n        vector<vector<int>> out(r, vector<int>(c));\\n        \\n        int ind=0;\\n        while(ind < r*c){\\n            out[ind/c][ind%c] = mat[ind/m_c][ind%m_c];\\n            ind++;\\n        }\\n        return out;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787625,
                "title": "python-3-simple-solution-93-lessser-memory",
                "content": "```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        original = []\\n        for i in mat:\\n            for j in i:\\n                original.append(j)\\n        if r*c != len(original):\\n            return mat\\n        lst = []\\n        for i in range(0,len(original),c):\\n            lst.append(original[i:i+c])\\n        return lst\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        original = []\\n        for i in mat:\\n            for j in i:\\n                original.append(j)\\n        if r*c != len(original):\\n            return mat\\n        lst = []\\n        for i in range(0,len(original),c):\\n            lst.append(original[i:i+c])\\n        return lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715866,
                "title": "optimized-easy-solution",
                "content": "```\\n\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** matrixReshape(int** mat, int matSize, int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes){\\n    int cols=*matColSize;\\n\\n    if(matSize*cols != r*c)\\n    {\\n        *returnSize = matSize;\\n        *returnColumnSizes = matColSize;\\n\\n        return mat;\\n    }\\n    else\\n    {\\n        *returnSize = r;\\n        *returnColumnSizes = (int*)malloc(r * sizeof(int));\\n        \\n        int** arr = (int**)malloc(r * sizeof(int*));\\n        for(int i = 0; i < r; i++)\\n        {\\n            arr[i] = (int*)malloc(c * sizeof(int));\\n            (*returnColumnSizes)[i] = c;\\n        }\\n\\n\\n\\n        int n=0,m=0;\\n        for(int i=0;i<matSize;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if(m>=c)\\n                {\\n                    m=0;\\n                    n++;   \\n                }\\n                arr[n][m]=mat[i][j];\\n                m++;\\n  \\n            }\\n        }\\n        return arr;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** matrixReshape(int** mat, int matSize, int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes){\\n    int cols=*matColSize;\\n\\n    if(matSize*cols != r*c)\\n    {\\n        *returnSize = matSize;\\n        *returnColumnSizes = matColSize;\\n\\n        return mat;\\n    }\\n    else\\n    {\\n        *returnSize = r;\\n        *returnColumnSizes = (int*)malloc(r * sizeof(int));\\n        \\n        int** arr = (int**)malloc(r * sizeof(int*));\\n        for(int i = 0; i < r; i++)\\n        {\\n            arr[i] = (int*)malloc(c * sizeof(int));\\n            (*returnColumnSizes)[i] = c;\\n        }\\n\\n\\n\\n        int n=0,m=0;\\n        for(int i=0;i<matSize;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if(m>=c)\\n                {\\n                    m=0;\\n                    n++;   \\n                }\\n                arr[n][m]=mat[i][j];\\n                m++;\\n  \\n            }\\n        }\\n        return arr;\\n    }\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711021,
                "title": "solution-in-java-using-one-loop",
                "content": "This solution uses one loop which will iterate to r\\\\*c. The complexity is still O(m\\\\*n) but it is much easier to understand. \\n\\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        if(mat.length * mat[0].length  != r*c)\\n            return mat;\\n        \\n        int[][] result = new int[r][c];\\n        for(int i=0;i<r*c;i++){\\n        \\n            result[i/c][i%c] = mat[i/mat[0].length][i%mat[0].length];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        if(mat.length * mat[0].length  != r*c)\\n            return mat;\\n        \\n        int[][] result = new int[r][c];\\n        for(int i=0;i<r*c;i++){\\n        \\n            result[i/c][i%c] = mat[i/mat[0].length][i%mat[0].length];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1702859,
                "title": "self-explainable-code-easy-to-understand-in-c",
                "content": "\\n```\\nvector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        vector<vector<int>>res(r, vector<int>(c));\\n        int row_counter = 0;\\n        int col_counter = 0;\\n        \\n        if(mat.size()*mat[0].size()!= r*c) return mat;\\n       \\n        \\n        for(int i = 0; i<mat.size(); i++){\\n            for(int j =0; j<mat[0].size();j++){\\n                res[row_counter][col_counter] = mat[i][j];\\n                col_counter++;\\n                if(col_counter == c){\\n                    row_counter++;\\n                    col_counter = 0;\\n                }\\n              \\n                \\n            }\\n        }\\n        return res;\\n        \\n    }\\n```\\n\\nIf you found this code helpful, do upvote!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        vector<vector<int>>res(r, vector<int>(c));\\n        int row_counter = 0;\\n        int col_counter = 0;\\n        \\n        if(mat.size()*mat[0].size()!= r*c) return mat;\\n       \\n        \\n        for(int i = 0; i<mat.size(); i++){\\n            for(int j =0; j<mat[0].size();j++){\\n                res[row_counter][col_counter] = mat[i][j];\\n                col_counter++;\\n                if(col_counter == c){\\n                    row_counter++;\\n                    col_counter = 0;\\n                }\\n              \\n                \\n            }\\n        }\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1688735,
                "title": "python-solution-time-o-r-c-space-o-r-c",
                "content": "```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        mat_row = len(mat)\\n        mat_col = len(mat[0])\\n        \\n        if (mat_row * mat_col) != (r * c):\\n            return mat\\n        \\n        elif (mat_row == r) and (mat_col == c):\\n            return mat\\n        \\n        else:\\n            result = [[0]*c for j in range(r)]\\n            \\n            for i in range(mat_row * mat_col):\\n                result[i//c][i%c] = mat[i//mat_col][i%mat_col]\\n            \\n            return result\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        mat_row = len(mat)\\n        mat_col = len(mat[0])\\n        \\n        if (mat_row * mat_col) != (r * c):\\n            return mat\\n        \\n        elif (mat_row == r) and (mat_col == c):\\n            return mat\\n        \\n        else:\\n            result = [[0]*c for j in range(r)]\\n            \\n            for i in range(mat_row * mat_col):\\n                result[i//c][i%c] = mat[i//mat_col][i%mat_col]\\n            \\n            return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590919,
                "title": "need-feedback-to-improve-my-javascript-solution",
                "content": "My current solution has alot to improve on, for both the runtime and memory usage. My current solution consists of the following steps:\\n\\n1. \\tFlattening the array into 1D\\n2. \\tCheck if the new r*c is legal\\n3. \\tCreate an empty 2D array of size r*c\\n4. \\tPopulate the the 2D array iteratively\\n\\nMy suspicion for my slow runtime would be the nested loop and I am hoping someone could provide feedback on how i can improve my current solution. Any feedback will be greatly appreciated :)\\n\\n**Runtime:** 143 ms, faster than 15.77% of JavaScript online submissions for Reshape the Matrix.\\n**Memory Usage:** 42.8 MB, less than 27.57% of JavaScript online submissions for Reshape the Matrix.\\n\\n```\\nvar matrixReshape = function(mat, r, c) {\\n    var flatMat = mat.flat()\\n    if (flatMat.length != r*c) return mat\\n    var newMat = [...Array(r)].map(e => Array(c));\\n    var p = 0\\n    \\n    for(var i = 0; i < r; i++) {\\n        for(var j = 0; j < c; j++){\\n            newMat[i][j] = flatMat[p]\\n            p += 1\\n        }\\n    }\\n    \\n    return newMat\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar matrixReshape = function(mat, r, c) {\\n    var flatMat = mat.flat()\\n    if (flatMat.length != r*c) return mat\\n    var newMat = [...Array(r)].map(e => Array(c));\\n    var p = 0\\n    \\n    for(var i = 0; i < r; i++) {\\n        for(var j = 0; j < c; j++){\\n            newMat[i][j] = flatMat[p]\\n            p += 1\\n        }\\n    }\\n    \\n    return newMat\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1432984,
                "title": "java-100-faster-solution",
                "content": "```\\npublic int[][] matrixReshape(int[][] mat, int r, int c) {\\n        if(r*c != mat[0].length*mat.length){\\n            return mat;\\n        }\\n        int ans [][] = new int[r][c];\\n        int m =0,n=0;\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                ans[i][j] = mat[m][n];\\n                if(n< mat[0].length-1){\\n                    n++;\\n                }else{\\n                    m++;\\n                    n=0; \\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[][] matrixReshape(int[][] mat, int r, int c) {\\n        if(r*c != mat[0].length*mat.length){\\n            return mat;\\n        }\\n        int ans [][] = new int[r][c];\\n        int m =0,n=0;\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                ans[i][j] = mat[m][n];\\n                if(n< mat[0].length-1){\\n                    n++;\\n                }else{\\n                    m++;\\n                    n=0; \\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1318204,
                "title": "c-python-using-division-and-modulus",
                "content": "Approach 1: Using division and modulus\\nTime Complexity: O(MN)\\nSpace Complexity: O(MN) for result, O(1) for the intermediate variable.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        const int m = mat.size(), n = mat[0].size();\\n        if(m*n != r * c) return mat;\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        for(int i = 0; i < r; i++)\\n            for(int j = 0; j < c; j++){\\n                int newIdx = i * c + j;\\n                ans[i][j]=mat[newIdx/n][newIdx%n];\\n            }\\n        return ans;\\n    }\\n};\\n```\\n\\nApproach 2: compact version of Appraoch 1 in 5-line\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        const int m = mat.size(), n = mat[0].size();\\n        if(m*n != r * c) return mat;\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        for(int i = 0; i < r*c; i++)    ans[i/c][i%c]=mat[i/n][i%n];            \\n        return ans;\\n    }\\n};\\n```\\n\\nApprach 3: Python version of Approach 2\\n```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        m = len(mat)\\n        n = len(mat[0])\\n        if m * n != r * c: return mat\\n        #ans = [[0]*c]*r # WRONG\\n        ans = [[0 for i in range(c)] for j in range(r)]        \\n        for i in range(r*c): ans[i//c][i%c] = mat[i//n][i%n]            \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        const int m = mat.size(), n = mat[0].size();\\n        if(m*n != r * c) return mat;\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        for(int i = 0; i < r; i++)\\n            for(int j = 0; j < c; j++){\\n                int newIdx = i * c + j;\\n                ans[i][j]=mat[newIdx/n][newIdx%n];\\n            }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        const int m = mat.size(), n = mat[0].size();\\n        if(m*n != r * c) return mat;\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        for(int i = 0; i < r*c; i++)    ans[i/c][i%c]=mat[i/n][i%n];            \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        m = len(mat)\\n        n = len(mat[0])\\n        if m * n != r * c: return mat\\n        #ans = [[0]*c]*r # WRONG\\n        ans = [[0 for i in range(c)] for j in range(r)]        \\n        for i in range(r*c): ans[i//c][i%c] = mat[i//n][i%n]            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317756,
                "title": "c-easy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        vector<vector<int>> vc(r,vector<int>(c));\\n        if((r*c)!=(mat.size()*mat[0].size())) return mat;\\n        vector<int> y;\\n        for(int p=0;p<mat.size();p++){\\n            for(int q=0;q<mat[0].size();q++){\\n                y.push_back(mat[p][q]);\\n            }\\n        }       \\n        auto it = y.begin();\\n        for(int i=0;i<r;i++){\\n            for(int j = 0;j<c;j++){\\n                vc[i][j]=*it;\\n                it++;\\n            }\\n        }\\n        return vc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        vector<vector<int>> vc(r,vector<int>(c));\\n        if((r*c)!=(mat.size()*mat[0].size())) return mat;\\n        vector<int> y;\\n        for(int p=0;p<mat.size();p++){\\n            for(int q=0;q<mat[0].size();q++){\\n                y.push_back(mat[p][q]);\\n            }\\n        }       \\n        auto it = y.begin();\\n        for(int i=0;i<r;i++){\\n            for(int j = 0;j<c;j++){\\n                vc[i][j]=*it;\\n                it++;\\n            }\\n        }\\n        return vc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317729,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn matrix_reshape(mat: Vec<Vec<i32>>, r: i32, c: i32) -> Vec<Vec<i32>> {\\n        if mat.len() * mat[0].len() != (r * c) as usize {\\n            return mat;\\n        }\\n        let mut answer = vec![vec![0; c as usize]; r as usize];\\n        let mut values = mat.iter().flat_map(|row| row.iter());\\n        for col in answer.iter_mut().flat_map(|row| row.iter_mut()) {\\n            if let Some(&val) = values.next() {\\n                *col = val;\\n            }\\n        }\\n        answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn matrix_reshape(mat: Vec<Vec<i32>>, r: i32, c: i32) -> Vec<Vec<i32>> {\\n        if mat.len() * mat[0].len() != (r * c) as usize {\\n            return mat;\\n        }\\n        let mut answer = vec![vec![0; c as usize]; r as usize];\\n        let mut values = mat.iter().flat_map(|row| row.iter());\\n        for col in answer.iter_mut().flat_map(|row| row.iter_mut()) {\\n            if let Some(&val) = values.next() {\\n                *col = val;\\n            }\\n        }\\n        answer\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1317471,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution\\n{\\n    public int[][] MatrixReshape(int[][] mat, int r, int c)\\n    {\\n        if (r * c != mat.Length * mat[0].Length)\\n        {\\n            return mat;\\n        }\\n            \\n        int[][] res = new int[r][];\\n\\n        for (int i = 0; i < r; i++)\\n        {\\n            res[i] = new int[c];\\n            for (int j = 0; j < c; j++)\\n            {\\n                int index = i * c + j;\\n                int row = index / mat[0].Length;\\n                int col = index - row * mat[0].Length;\\n                res[i][j] = mat[row][col];\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int[][] MatrixReshape(int[][] mat, int r, int c)\\n    {\\n        if (r * c != mat.Length * mat[0].Length)\\n        {\\n            return mat;\\n        }\\n            \\n        int[][] res = new int[r][];\\n\\n        for (int i = 0; i < r; i++)\\n        {\\n            res[i] = new int[c];\\n            for (int j = 0; j < c; j++)\\n            {\\n                int index = i * c + j;\\n                int row = index / mat[0].Length;\\n                int col = index - row * mat[0].Length;\\n                res[i][j] = mat[row][col];\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317113,
                "title": "c-reshape-the-matrix",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int n = mat.size(), m = mat[0].size();\\n        if(n*m != r*c)return mat;\\n        vector<vector<int>>ans(r,vector<int>(c,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int cell = i*m + j;\\n                int newi = cell/c;\\n                int newj = cell%c;\\n                ans[newi][newj] = mat[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int n = mat.size(), m = mat[0].size();\\n        if(n*m != r*c)return mat;\\n        vector<vector<int>>ans(r,vector<int>(c,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int cell = i*m + j;\\n                int newi = cell/c;\\n                int newj = cell%c;\\n                ans[newi][newj] = mat[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278441,
                "title": "c-easy-faster-than-96-single-loop",
                "content": "```\\nvector<vector<int>>out(r,vector<int>(c,0));\\n        int n=mat.size();//row size\\n        int  m=mat[0].size();//column size\\n        if((n*m)==(r*c))\\n        {\\n            for(int i=0;i<(r*c);i++)\\n            {\\n                out[i/c][i%c]=mat[i/m][i%m];//simple evaluation of matrix\\n            }\\n            return out;\\n        }\\n        else\\n            return mat;\\n```\\n\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>>out(r,vector<int>(c,0));\\n        int n=mat.size();//row size\\n        int  m=mat[0].size();//column size\\n        if((n*m)==(r*c))\\n        {\\n            for(int i=0;i<(r*c);i++)\\n            {\\n                out[i/c][i%c]=mat[i/m][i%m];//simple evaluation of matrix\\n            }\\n            return out;\\n        }\\n        else\\n            return mat;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 559556,
                "title": "c-solutions",
                "content": "**approach 1**\\n1-dimensional array index => 2-dimensional array index: **row = i / n; column = i % n**\\n2-dimensional array index => 1-dimensional array index: **i = row * n + column**\\n```\\n    public int[][] MatrixReshape(int[][] nums, int r, int c) {\\n        \\n        int m = nums.Length, n = nums[0].Length;\\n        \\n        if(nums == null || r * c != m * n)\\n            return nums;\\n        \\n        int[][] res = new int[r][];\\n        for(int i = 0; i < r; i++)\\n        {\\n            res[i] = new int[c];           \\n            for(int j = 0; j < c; j++)\\n                res[i][j] = nums[(i * c + j) / n][(i * c + j) % n];                 \\n        }\\n        \\n        return res;\\n    }\\n```\\n\\n**approach 2**\\n```\\npublic class Solution {\\n    public int[][] MatrixReshape(int[][] mat, int r, int c) {\\n        \\n        int m = mat.Length, n = mat[0].Length;\\n        \\n        if(m * n != r * c)\\n            return mat;\\n        \\n        int size = m * n;\\n        int[][] res = new int[r][];\\n        for(int k = 0; k < r; k++)\\n            res[k] = new int[c];\\n        \\n        for(int i = 0; i < size; i++)\\n        {\\n            int oriX = i / n;\\n            int oriY = i % n;\\n            int resX = i / c;\\n            int resY = i % c;\\n            res[resX][resY] = mat[oriX][oriY];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[][] MatrixReshape(int[][] nums, int r, int c) {\\n        \\n        int m = nums.Length, n = nums[0].Length;\\n        \\n        if(nums == null || r * c != m * n)\\n            return nums;\\n        \\n        int[][] res = new int[r][];\\n        for(int i = 0; i < r; i++)\\n        {\\n            res[i] = new int[c];           \\n            for(int j = 0; j < c; j++)\\n                res[i][j] = nums[(i * c + j) / n][(i * c + j) % n];                 \\n        }\\n        \\n        return res;\\n    }\\n```\n```\\npublic class Solution {\\n    public int[][] MatrixReshape(int[][] mat, int r, int c) {\\n        \\n        int m = mat.Length, n = mat[0].Length;\\n        \\n        if(m * n != r * c)\\n            return mat;\\n        \\n        int size = m * n;\\n        int[][] res = new int[r][];\\n        for(int k = 0; k < r; k++)\\n            res[k] = new int[c];\\n        \\n        for(int i = 0; i < size; i++)\\n        {\\n            int oriX = i / n;\\n            int oriY = i % n;\\n            int resX = i / c;\\n            int resY = i % c;\\n            res[resX][resY] = mat[oriX][oriY];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 317083,
                "title": "golang-solution",
                "content": "```\\nfunc matrixReshape(nums [][]int, r int, c int) [][]int {\\n\\tif len(nums) == 0 {\\n\\t\\treturn nums\\n\\t}\\n\\n\\tor, oc := len(nums), len(nums[0])\\n\\tif or*oc != c*r {\\n\\t\\treturn nums\\n\\t}\\n\\n\\tresult := make([][]int, 0)\\n\\tfor i := 0; i < r; i++ {\\n\\t\\tresult = append(result, make([]int, c))\\n\\t}\\n\\n\\tfor i := 0; i < c*r; i++ {\\n\\t\\tresult[i/c][i%c] = nums[i/oc][i%oc]\\n\\t}\\n\\n\\treturn result\\n\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc matrixReshape(nums [][]int, r int, c int) [][]int {\\n\\tif len(nums) == 0 {\\n\\t\\treturn nums\\n\\t}\\n\\n\\tor, oc := len(nums), len(nums[0])\\n\\tif or*oc != c*r {\\n\\t\\treturn nums\\n\\t}\\n\\n\\tresult := make([][]int, 0)\\n\\tfor i := 0; i < r; i++ {\\n\\t\\tresult = append(result, make([]int, c))\\n\\t}\\n\\n\\tfor i := 0; i < c*r; i++ {\\n\\t\\tresult[i/c][i%c] = nums[i/oc][i%oc]\\n\\t}\\n\\n\\treturn result\\n\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 235833,
                "title": "does-anyone-think-the-description-is-hard-to-understand",
                "content": "may there should be more examples or detailed explanation.\\n\\nif old_row is equal to new_row, return nums.\\n\\nrow has higher priority than column.\\n\\nthere is a test case is:\\n```\\ninput: [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16],[17,18,19,20]], 42, 5\\n\\nexpexted: [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16],[17,18,19,20]]\\n```\\n\\n\\n```java\\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\\n        int rr = nums.length;\\n        int cc = nums[0].length;\\n\\n        if (r!=rr && (rr*cc)%r==0 ) {\\n            int[][] result = new int[r][(rr*cc)/r];\\n            int m = 0;\\n            int n = 0;\\n\\n            for (int i = 0; i < rr; i++) {\\n                for (int j = 0; j < cc; j++) {\\n                    result[m][n++] = nums[i][j];\\n                    if (n == c) {\\n                        m++;\\n                        n = 0;\\n                    }\\n                }\\n            }\\n\\n            return result;\\n        } else {\\n            return nums;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\ninput: [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16],[17,18,19,20]], 42, 5\\n\\nexpexted: [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16],[17,18,19,20]]\\n```\n```java\\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\\n        int rr = nums.length;\\n        int cc = nums[0].length;\\n\\n        if (r!=rr && (rr*cc)%r==0 ) {\\n            int[][] result = new int[r][(rr*cc)/r];\\n            int m = 0;\\n            int n = 0;\\n\\n            for (int i = 0; i < rr; i++) {\\n                for (int j = 0; j < cc; j++) {\\n                    result[m][n++] = nums[i][j];\\n                    if (n == c) {\\n                        m++;\\n                        n = 0;\\n                    }\\n                }\\n            }\\n\\n            return result;\\n        } else {\\n            return nums;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3958521,
                "title": "easy-code-for-beginners-o-n-2",
                "content": "# Intuition\\nKCE\\n\\n# Approach\\n1. Check whether the given matrix size(m,n) and wanted reshaped matrix size (r,c) equal or  not,  (m * n==r * c).\\n2. If equal first create one Array and pass the values of given matrix.\\n3. Next create another matrix with wanted shape and size using given rows and column.\\n4. Now pass the stored array elements to new reshaped matrix. \\n5.  If not equal return a same matrix given in a question.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] a, int r, int c) {\\n        int m=a.length;\\n        int n=a[0].length;\\n        if(m*n==r*c)\\n        {\\n               int p[]=new int[r*c];\\n               int k=0;\\n              for(int i=0;i<m;i++){\\n               for(int j=0;j<n;j++){\\n                p[k++]=a[i][j];\\n               }\\n              }\\n             int q=0;\\n       \\n             int b[][]=new int[r][c];\\n            for(int i=0;i<r;i++){\\n              for(int j=0;j<c;j++){\\n                  b[i][j]=p[q++];\\n              }\\n            }\\n            return b;\\n     }\\n    else\\n    return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] a, int r, int c) {\\n        int m=a.length;\\n        int n=a[0].length;\\n        if(m*n==r*c)\\n        {\\n               int p[]=new int[r*c];\\n               int k=0;\\n              for(int i=0;i<m;i++){\\n               for(int j=0;j<n;j++){\\n                p[k++]=a[i][j];\\n               }\\n              }\\n             int q=0;\\n       \\n             int b[][]=new int[r][c];\\n            for(int i=0;i<r;i++){\\n              for(int j=0;j<c;j++){\\n                  b[i][j]=p[q++];\\n              }\\n            }\\n            return b;\\n     }\\n    else\\n    return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790586,
                "title": "python-simple-and-fastest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple and clear\\nNo need to convert the input into 1d array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncheck if both have same space or not.\\nThen simply add elemts into row and add those rows into the\\nfinal array\\n\\n\\n\\n# Complexity\\n- Time complexity:** O(m*n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        if r*c != len(mat)* len(mat[0]):\\n            return mat\\n\\n        final = []\\n        temp = 0\\n        c_temp = 0\\n        row = []\\n\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                if c_temp == c:\\n                    final.append(list(row))\\n                    row.clear()\\n                    c_temp = 0\\n\\n                row.append(mat[i][j])\\n                c_temp += 1\\n        if row:\\n            final.append(list(row))\\n        return final\\n        \\n\\n\\n                \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        if r*c != len(mat)* len(mat[0]):\\n            return mat\\n\\n        final = []\\n        temp = 0\\n        c_temp = 0\\n        row = []\\n\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                if c_temp == c:\\n                    final.append(list(row))\\n                    row.clear()\\n                    c_temp = 0\\n\\n                row.append(mat[i][j])\\n                c_temp += 1\\n        if row:\\n            final.append(list(row))\\n        return final\\n        \\n\\n\\n                \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511296,
                "title": "easy-slow-approach-2ms-beats-10",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        if(mat.length * mat[0].length != r * c) {\\n            return mat;\\n        }\\n        List<Integer> AL = new ArrayList();\\n        for(int i = 0; i < mat.length; i++) {\\n            for( int j = 0; j < mat[0].length; j++) {\\n                AL.add(mat[i][j]);\\n            }\\n        }\\n        int arr[][] = new int[r][c];\\n        int index = 0;\\n        for(int i = 0; i < r; i++) {\\n            for( int j = 0; j < c; j++) {\\n                arr[i][j] = AL.get(index++);\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        if(mat.length * mat[0].length != r * c) {\\n            return mat;\\n        }\\n        List<Integer> AL = new ArrayList();\\n        for(int i = 0; i < mat.length; i++) {\\n            for( int j = 0; j < mat[0].length; j++) {\\n                AL.add(mat[i][j]);\\n            }\\n        }\\n        int arr[][] = new int[r][c];\\n        int index = 0;\\n        for(int i = 0; i < r; i++) {\\n            for( int j = 0; j < c; j++) {\\n                arr[i][j] = AL.get(index++);\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500271,
                "title": "easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int row1=mat.length;\\n        int col1=mat[0].length;\\n        if((row1*col1)!=(r*c))return mat;\\n        int p=0;\\n        int[][] arr=new int[r][c];\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n             \\n              arr[i][j]=mat[p/col1][p%col1];\\n              p++;\\n                          \\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int row1=mat.length;\\n        int col1=mat[0].length;\\n        if((row1*col1)!=(r*c))return mat;\\n        int p=0;\\n        int[][] arr=new int[r][c];\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n             \\n              arr[i][j]=mat[p/col1][p%col1];\\n              p++;\\n                          \\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420851,
                "title": "reshape-the-matrix-easiest-with-c",
                "content": "\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int row=mat.size(), col=mat[0].size();\\n        if(row*col != r*c)\\n            return mat;\\n        vector<vector<int>>ans(r, vector<int>(c)); \\n        vector<int>v;\\n        for(auto i:mat)\\n            for(auto j:i)\\n                v.push_back(j);\\n        int index=0;\\n        for(int i=0; i<r; i++)\\n            for(int j=0; j<c; j++)\\n                ans[i][j] = v[index++];\\n        return ans;\\n    }\\n};\\n```\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int row=mat.size(), col=mat[0].size();\\n        if(row*col != r*c)\\n            return mat;\\n        vector<vector<int>>ans(r, vector<int>(c)); \\n        vector<int>v;\\n        for(auto i:mat)\\n            for(auto j:i)\\n                v.push_back(j);\\n        int index=0;\\n        for(int i=0; i<r; i++)\\n            for(int j=0; j<c; j++)\\n                ans[i][j] = v[index++];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382808,
                "title": "simple-and-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        \\n        int[][] op = new int[r][c];\\n\\n        if(mat.length* mat[0].length != r*c)return mat;\\n\\n        int row=0;\\n        int col=0;\\n        for(int i=0; i<mat.length; i++){\\n            for(int j=0; j<mat[0].length; j++){\\n                    op[row][col]=mat[i][j];\\n                    col++;\\n                    if(col==c){\\n                        row++;\\n                        col=0;\\n                    }   \\n            }\\n        }\\n        return op;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        \\n        int[][] op = new int[r][c];\\n\\n        if(mat.length* mat[0].length != r*c)return mat;\\n\\n        int row=0;\\n        int col=0;\\n        for(int i=0; i<mat.length; i++){\\n            for(int j=0; j<mat[0].length; j++){\\n                    op[row][col]=mat[i][j];\\n                    col++;\\n                    if(col==c){\\n                        row++;\\n                        col=0;\\n                    }   \\n            }\\n        }\\n        return op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279842,
                "title": "0ms-solution-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst check if the product of r and c is equal to number of element in the given matrix or not. If the product is not equal or if the value of r == mat.length && value of c == mat[0].length , return the given matrix.\\nElse make a new matrix and store all the data in it and use this matrix to make your final matrix having r and c as the number of rows and column respectively.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        if(r*c != mat.length*mat[0].length){\\n            return mat;\\n        }\\n        if(r == mat.length && c == mat[0].length){\\n            return mat;\\n        }\\n        int[][] arr = new int[1][r*c];\\n        int count = 0;\\n        for(int row = 0; row < mat.length ; row++){\\n            for(int col = 0; col < mat[0].length; col++){\\n                arr[0][count] = mat[row][col];\\n                count++;\\n            }\\n        }\\n        int[][] ans = new int[r][c];\\n        count = 0;\\n        for(int row = 0; row < r; row++){\\n            for(int col = 0; col < c; col++){\\n                ans[row][col] = arr[0][count];\\n\\n                count++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n*Please upvote if the solution is helpful to you and feel free to ask if you have any doubt*\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/410eda98-6137-40e6-86fc-b59e10fda302_1678120758.9848907.jpeg\" alt=\"\">\\n</p>\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        if(r*c != mat.length*mat[0].length){\\n            return mat;\\n        }\\n        if(r == mat.length && c == mat[0].length){\\n            return mat;\\n        }\\n        int[][] arr = new int[1][r*c];\\n        int count = 0;\\n        for(int row = 0; row < mat.length ; row++){\\n            for(int col = 0; col < mat[0].length; col++){\\n                arr[0][count] = mat[row][col];\\n                count++;\\n            }\\n        }\\n        int[][] ans = new int[r][c];\\n        count = 0;\\n        for(int row = 0; row < r; row++){\\n            for(int col = 0; col < c; col++){\\n                ans[row][col] = arr[0][count];\\n\\n                count++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975588,
                "title": "dart-one-loop-100",
                "content": "\\nIf you Learned something new please give it upvote;\\notherwise thank you for having a look \\uD83D\\uDE4F\\uD83C\\uDFFB\\n\\n# Code\\n```\\nclass Solution {\\n  List<List<int>> matrixReshape(List<List<int>> mat, int r, int c) {\\n      int m = mat.length , n = mat[0].length, total = m * n;\\n        if(r * c != total) return mat;\\n        List<List<int>> ans= List.generate(r, (i) => List.filled(c,0));\\n        for(int i = 0; i < total; i++) \\n            ans[i ~/ c][i % c] = mat[i ~/ n][i % n];\\n        return ans;\\n  }\\n}\\n```\\n\\nPls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding :)",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<List<int>> matrixReshape(List<List<int>> mat, int r, int c) {\\n      int m = mat.length , n = mat[0].length, total = m * n;\\n        if(r * c != total) return mat;\\n        List<List<int>> ans= List.generate(r, (i) => List.filled(c,0));\\n        for(int i = 0; i < total; i++) \\n            ans[i ~/ c][i % c] = mat[i ~/ n][i % n];\\n        return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939328,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(N*N)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        if(mat.size()*mat[0].size()!=r*c){return mat;}\\n        vector<vector<int>>v(r, vector<int>(c, 0));\\n        int k=0;\\n        for(int i=0; i<r; i++){\\n            for(int j=0; j<c; j++){\\n                v[i][j]=mat[k/mat[0].size()][k%mat[0].size()];\\n                k++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        if(mat.size()*mat[0].size()!=r*c){return mat;}\\n        vector<vector<int>>v(r, vector<int>(c, 0));\\n        int k=0;\\n        for(int i=0; i<r; i++){\\n            for(int j=0; j<c; j++){\\n                v[i][j]=mat[k/mat[0].size()][k%mat[0].size()];\\n                k++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931524,
                "title": "java-using-modulo-arithmetic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int n = mat.length , m = mat[0].length;\\n        int arr[][] = new int[r][c];\\n        if(m*n != r*c) return mat;\\n        for(int i = 0; i < c*r; i++){\\n            arr[i/c][i%c] = mat[i/m][i%m];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int n = mat.length , m = mat[0].length;\\n        int arr[][] = new int[r][c];\\n        if(m*n != r*c) return mat;\\n        for(int i = 0; i < c*r; i++){\\n            arr[i/c][i%c] = mat[i/m][i%m];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917066,
                "title": "easy-and-simple-c-solution-matrix",
                "content": "\\n## Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int row= mat.size();\\n        int col= mat[0].size();\\n        vector<vector<int>> newMat;\\n        int cnt=0;\\n        if (row*col != r*c)return mat;\\n        for (int i=0; i<r; i++){\\n            vector<int> row_vect;\\n            for (int j=0; j<c; j++){\\n                row_vect.push_back(mat[cnt/col][cnt%col]);\\n                //row_vect.push_back(mat[cnt/row][cnt%row]);\\n                cnt++;\\n            }\\n            newMat.push_back(row_vect);\\n        }\\n        return newMat;\\n    }\\n};\\n```\\n### Complexity\\n- Time complexity: $$O(r*c)$$ ~ $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\\n        int row= mat.size();\\n        int col= mat[0].size();\\n        vector<vector<int>> newMat;\\n        int cnt=0;\\n        if (row*col != r*c)return mat;\\n        for (int i=0; i<r; i++){\\n            vector<int> row_vect;\\n            for (int j=0; j<c; j++){\\n                row_vect.push_back(mat[cnt/col][cnt%col]);\\n                //row_vect.push_back(mat[cnt/row][cnt%row]);\\n                cnt++;\\n            }\\n            newMat.push_back(row_vect);\\n        }\\n        return newMat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870043,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn matrix_reshape(mat: Vec<Vec<i32>>, r: i32, c: i32) -> Vec<Vec<i32>> {\\n        let m = mat.len();\\n        let n = mat[0].len();\\n\\n        if m * n != (r * c) as usize {\\n            return mat;\\n        }\\n\\n        let mut result = vec![vec![0; c as usize]; r as usize];\\n        let mut i = 0;\\n        let mut j = 0;\\n\\n        for row in mat {\\n            for num in row {\\n                result[i][j] = num;\\n                j += 1;\\n\\n                if j == c as usize {\\n                    j = 0;\\n                    i += 1;\\n                }\\n            }\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn matrix_reshape(mat: Vec<Vec<i32>>, r: i32, c: i32) -> Vec<Vec<i32>> {\\n        let m = mat.len();\\n        let n = mat[0].len();\\n\\n        if m * n != (r * c) as usize {\\n            return mat;\\n        }\\n\\n        let mut result = vec![vec![0; c as usize]; r as usize];\\n        let mut i = 0;\\n        let mut j = 0;\\n\\n        for row in mat {\\n            for num in row {\\n                result[i][j] = num;\\n                j += 1;\\n\\n                if j == c as usize {\\n                    j = 0;\\n                    i += 1;\\n                }\\n            }\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2502347,
                "title": "potential-error-in-example-2",
                "content": "Input: mat = [[1,2],[3,4]], r = 2, c = 4\\nOutput: [[1,2],[3,4]]\\n\\nHello guys, the test case seems to be wrong. Here we are saying we want to convert it to a matrix of 2 rows & 4 columns. Yet we get a matrix of 2 rows & 2 columns. And even though the code I wrote for this test case shouldn\\'t works, it actually works for some reason. Can someone assist me in this confusion or is it an error on Leetcode\\'s part? The weird thing is that it\\'s as if this test case is hardcoded to accept answers because In my solution I create a 2D array with r=2 & c=4, yet the output is a matrix of c=2... Please check up & assist where possible.\\n",
                "solutionTags": [],
                "code": "Input: mat = [[1,2],[3,4]], r = 2, c = 4\\nOutput: [[1,2],[3,4]]\\n\\nHello guys, the test case seems to be wrong. Here we are saying we want to convert it to a matrix of 2 rows & 4 columns. Yet we get a matrix of 2 rows & 2 columns. And even though the code I wrote for this test case shouldn\\'t works, it actually works for some reason. Can someone assist me in this confusion or is it an error on Leetcode\\'s part? The weird thing is that it\\'s as if this test case is hardcoded to accept answers because In my solution I create a 2D array with r=2 & c=4, yet the output is a matrix of c=2... Please check up & assist where possible.\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2455350,
                "title": "java-easy-solution-1ms",
                "content": "\\'\\'\\'\\n1. class Solution {\\n2. \\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n\\t\\n             if((mat.length*mat[0].length) != (r*c)){\\n            return mat;\\n           }\\n        \\n        int row = 0;\\n        int col = 0;\\n        int[][] arr = new int[r][c];\\n        \\n        for(int i = 0; i < mat.length; i++ ) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                arr[row][col] = mat[i][j]; // putting the elements from mat to arr(new matrix)\\n                col++;\\n                if(col == c) {  // if col becomes equal to c then we need to start from next row and 0th col again\\n                    row++;\\n                    col = 0;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n2. \\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n\\t\\n             if((mat.length*mat[0].length) != (r*c)){\\n            return mat;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2430756,
                "title": "java-1-ms-simple-and-easy-solution-builds-logic",
                "content": "```\\n//If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; \\n        //Otherwise, output the original matrix this is given in question ;\\n        if((r*c) != (mat.length*mat[0].length)){\\n            return mat ;\\n        }\\n        \\n        //make a new array with given indexes r & c ;\\n        int[][] arr = new int[r][c] ;\\n        \\n        //take 2 variables bcz we will be incrementing & using theses ;\\n        int row = 0 ; int col = 0;\\n        \\n        //for loop for iterating over the mat matrix ;\\n        for(int i = 0 ; i < mat.length ; i++){\\n            for(int j = 0 ; j < mat[i].length ; j++){\\n                  arr[row][col] = mat[i][j] ;//iterate over mat and put the elements in arr(new matrix) ;\\n                  col++;\\n                \\n                if(col == c){\\n                    row++ ;\\n                    col = 0 ;\\n                }\\n            }\\n        }\\n        \\n        return arr  ;",
                "solutionTags": [
                    "Array",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\n//If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; \\n        //Otherwise, output the original matrix this is given in question ;\\n        if((r*c) != (mat.length*mat[0].length)){\\n            return mat ;\\n        }\\n        \\n        //make a new array with given indexes r & c ;\\n        int[][] arr = new int[r][c] ;\\n        \\n        //take 2 variables bcz we will be incrementing & using theses ;\\n        int row = 0 ; int col = 0;\\n        \\n        //for loop for iterating over the mat matrix ;\\n        for(int i = 0 ; i < mat.length ; i++){\\n            for(int j = 0 ; j < mat[i].length ; j++){\\n                  arr[row][col] = mat[i][j] ;//iterate over mat and put the elements in arr(new matrix) ;\\n                  col++;\\n                \\n                if(col == c){\\n                    row++ ;\\n                    col = 0 ;\\n                }\\n            }\\n        }\\n        \\n        return arr  ;",
                "codeTag": "Unknown"
            },
            {
                "id": 2425160,
                "title": "javascript-simple-for-loop-iterative-o-n-m-solution",
                "content": "```\\nfunction matrixReshape(matrix, rows, columns) {\\n    const newMatrix = [];\\n\\n    if(rows * columns !== matrix.length * matrix[0].length) {\\n        return matrix;\\n    }\\n\\n    let rowReader = 0;\\n    let columnReader = 0;\\n\\n    for (let row = 0; row < rows; row++) {\\n        const newRow = [];\\n        \\n        for (let col = 0; col < columns; col++) {\\n            if(columnReader > matrix[rowReader].length - 1) {\\n                columnReader = 0;\\n                rowReader++;\\n            }\\n\\n            if(rowReader >= matrix.length) {\\n                return matrix;\\n            }\\n\\n            newRow.push(matrix[rowReader][columnReader++]);\\n        }\\n\\n        newMatrix.push(newRow);\\n    }\\n\\n    return newMatrix;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction matrixReshape(matrix, rows, columns) {\\n    const newMatrix = [];\\n\\n    if(rows * columns !== matrix.length * matrix[0].length) {\\n        return matrix;\\n    }\\n\\n    let rowReader = 0;\\n    let columnReader = 0;\\n\\n    for (let row = 0; row < rows; row++) {\\n        const newRow = [];\\n        \\n        for (let col = 0; col < columns; col++) {\\n            if(columnReader > matrix[rowReader].length - 1) {\\n                columnReader = 0;\\n                rowReader++;\\n            }\\n\\n            if(rowReader >= matrix.length) {\\n                return matrix;\\n            }\\n\\n            newRow.push(matrix[rowReader][columnReader++]);\\n        }\\n\\n        newMatrix.push(newRow);\\n    }\\n\\n    return newMatrix;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1710174,
                "content": [
                    {
                        "username": "mnithish850",
                        "content": "there is mistake in testcase\\ngiven mat\\n[[1,2],[3,4]]\\n give r=2, c=4\\nbut it is expecting answer as  [[1,2],[3,4]]\\nwhich is wrong"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think it\\'s correct as r*c is != m*n that is no. of elements are not same so we return the orignal matrix"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "Test case is right, in this case you have to return the original array because to dimension (size) mismatch."
                    },
                    {
                        "username": "123004048",
                        "content": "[@tenplus_086](/tenplus_086)  im getting [[1,2,3,4]] as the output"
                    },
                    {
                        "username": "kavignaani8203",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks. felt the same doubt that testcase is wrong. With your provided explanation , got it right"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@tenplus_086](/tenplus_086)  Yeah in case of dimension mismatch, we should return original matrix.. It cant be reshaped"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "No that test case is true\n because the given matrix is 2-2 means there are 4 element and we have to form new matrix of size 2-4 which has 8 element \nthen how you fill the 4 element in the 8 indexes matrix  "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I think its correct..What should be the expected output according to you?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "## Explanation:\\nThis task is easy for those who understand it as it is given in the question. However, for those who may initially think it is a task involving matrix transposition, it may be confusing at first. Therefore, for anyone who initially thought this was a matrix transpose task like I did, let me clarify: it is not. Simply read the question again.\\n\\nNow that we are clear on the question:\\n\\n- Imagine the given matrix as a set of cubicles. We are moving to a new office and the room has a different length and width, so we need to adjust the positions of the cubicles to fit them in the new office.\\n- However, what if the area of the new office is different from that of the old office? If it is smaller, we cannot fit all the cubicles. If it is larger, we cannot fill the space properly. In this case, we will not move to the new office.\\n- On the other hand, if the new office has the same area as the old one, we need to disassemble the cubicles and fit them in a truck for transport.\\n- Maintaining the order and position of the cubicles, we will disassemble them and place them in the truck in order.\\n- We will then unload the cubicles one by one, maintaining the first-in-first-out order and placing them in the new office according to its new dimensions.\\n- This way, we can fit all the cubicles in order from the old office to the new office, as long as the new office has the same area as the old one."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal Matrix Problem. Just make sure to add the base condition of returning the original(given) matrix if the given matrix\\'s dimensions doesn\\'t match the rehaped matrix\\'s dimensions"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When will people understand, to NOT post solutions here?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "In this [example](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg), `c` should be 2 not `4` Am I wrong?"
                    },
                    {
                        "username": "lcmpbll",
                        "content": "This is an example of what you should return if the reshape is not possible:\\n\\nIf the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\\n\\n"
                    },
                    {
                        "username": "mnmlyn",
                        "content": "why it is\"int** columnSizes\",not \"int* columnSizes\"?\\nand then\\ncolumnSizes = (int *)malloc(sizeof(int)*r);"
                    },
                    {
                        "username": "tarun22",
                        "content": "It would be great if you can put a minor comment on the Testcase 2 , that it returned the original matrix as the are does not match. That would reduce confusion."
                    },
                    {
                        "username": "AlisherRMA",
                        "content": "there is incorrect testcase(\\u211654)\\nmat = [[1,2]]\\nr = 1\\nc = 1\\nexpected result: [[1, 2]]\\nit should be just [[1]]"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Check for the base case.. If the given matrix\\'s dimensions doesn\\'t match the to be reshaped to matrix\\'s dimensions, we return the given matrix. That\\'s y for the above test case the result is [[1,2]]"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Logic, yet efficient , Beats 100% in Runtime & 99.10% in Memory, with Detailed Explantion: `\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3877156/simple-iterative-approach-beats-100-detailed-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "balls."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "penis."
                    }
                ]
            },
            {
                "id": 1742440,
                "content": [
                    {
                        "username": "mnithish850",
                        "content": "there is mistake in testcase\\ngiven mat\\n[[1,2],[3,4]]\\n give r=2, c=4\\nbut it is expecting answer as  [[1,2],[3,4]]\\nwhich is wrong"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think it\\'s correct as r*c is != m*n that is no. of elements are not same so we return the orignal matrix"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "Test case is right, in this case you have to return the original array because to dimension (size) mismatch."
                    },
                    {
                        "username": "123004048",
                        "content": "[@tenplus_086](/tenplus_086)  im getting [[1,2,3,4]] as the output"
                    },
                    {
                        "username": "kavignaani8203",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks. felt the same doubt that testcase is wrong. With your provided explanation , got it right"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@tenplus_086](/tenplus_086)  Yeah in case of dimension mismatch, we should return original matrix.. It cant be reshaped"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "No that test case is true\n because the given matrix is 2-2 means there are 4 element and we have to form new matrix of size 2-4 which has 8 element \nthen how you fill the 4 element in the 8 indexes matrix  "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I think its correct..What should be the expected output according to you?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "## Explanation:\\nThis task is easy for those who understand it as it is given in the question. However, for those who may initially think it is a task involving matrix transposition, it may be confusing at first. Therefore, for anyone who initially thought this was a matrix transpose task like I did, let me clarify: it is not. Simply read the question again.\\n\\nNow that we are clear on the question:\\n\\n- Imagine the given matrix as a set of cubicles. We are moving to a new office and the room has a different length and width, so we need to adjust the positions of the cubicles to fit them in the new office.\\n- However, what if the area of the new office is different from that of the old office? If it is smaller, we cannot fit all the cubicles. If it is larger, we cannot fill the space properly. In this case, we will not move to the new office.\\n- On the other hand, if the new office has the same area as the old one, we need to disassemble the cubicles and fit them in a truck for transport.\\n- Maintaining the order and position of the cubicles, we will disassemble them and place them in the truck in order.\\n- We will then unload the cubicles one by one, maintaining the first-in-first-out order and placing them in the new office according to its new dimensions.\\n- This way, we can fit all the cubicles in order from the old office to the new office, as long as the new office has the same area as the old one."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal Matrix Problem. Just make sure to add the base condition of returning the original(given) matrix if the given matrix\\'s dimensions doesn\\'t match the rehaped matrix\\'s dimensions"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When will people understand, to NOT post solutions here?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "In this [example](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg), `c` should be 2 not `4` Am I wrong?"
                    },
                    {
                        "username": "lcmpbll",
                        "content": "This is an example of what you should return if the reshape is not possible:\\n\\nIf the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\\n\\n"
                    },
                    {
                        "username": "mnmlyn",
                        "content": "why it is\"int** columnSizes\",not \"int* columnSizes\"?\\nand then\\ncolumnSizes = (int *)malloc(sizeof(int)*r);"
                    },
                    {
                        "username": "tarun22",
                        "content": "It would be great if you can put a minor comment on the Testcase 2 , that it returned the original matrix as the are does not match. That would reduce confusion."
                    },
                    {
                        "username": "AlisherRMA",
                        "content": "there is incorrect testcase(\\u211654)\\nmat = [[1,2]]\\nr = 1\\nc = 1\\nexpected result: [[1, 2]]\\nit should be just [[1]]"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Check for the base case.. If the given matrix\\'s dimensions doesn\\'t match the to be reshaped to matrix\\'s dimensions, we return the given matrix. That\\'s y for the above test case the result is [[1,2]]"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Logic, yet efficient , Beats 100% in Runtime & 99.10% in Memory, with Detailed Explantion: `\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3877156/simple-iterative-approach-beats-100-detailed-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "balls."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "penis."
                    }
                ]
            },
            {
                "id": 1670312,
                "content": [
                    {
                        "username": "mnithish850",
                        "content": "there is mistake in testcase\\ngiven mat\\n[[1,2],[3,4]]\\n give r=2, c=4\\nbut it is expecting answer as  [[1,2],[3,4]]\\nwhich is wrong"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think it\\'s correct as r*c is != m*n that is no. of elements are not same so we return the orignal matrix"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "Test case is right, in this case you have to return the original array because to dimension (size) mismatch."
                    },
                    {
                        "username": "123004048",
                        "content": "[@tenplus_086](/tenplus_086)  im getting [[1,2,3,4]] as the output"
                    },
                    {
                        "username": "kavignaani8203",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks. felt the same doubt that testcase is wrong. With your provided explanation , got it right"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@tenplus_086](/tenplus_086)  Yeah in case of dimension mismatch, we should return original matrix.. It cant be reshaped"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "No that test case is true\n because the given matrix is 2-2 means there are 4 element and we have to form new matrix of size 2-4 which has 8 element \nthen how you fill the 4 element in the 8 indexes matrix  "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I think its correct..What should be the expected output according to you?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "## Explanation:\\nThis task is easy for those who understand it as it is given in the question. However, for those who may initially think it is a task involving matrix transposition, it may be confusing at first. Therefore, for anyone who initially thought this was a matrix transpose task like I did, let me clarify: it is not. Simply read the question again.\\n\\nNow that we are clear on the question:\\n\\n- Imagine the given matrix as a set of cubicles. We are moving to a new office and the room has a different length and width, so we need to adjust the positions of the cubicles to fit them in the new office.\\n- However, what if the area of the new office is different from that of the old office? If it is smaller, we cannot fit all the cubicles. If it is larger, we cannot fill the space properly. In this case, we will not move to the new office.\\n- On the other hand, if the new office has the same area as the old one, we need to disassemble the cubicles and fit them in a truck for transport.\\n- Maintaining the order and position of the cubicles, we will disassemble them and place them in the truck in order.\\n- We will then unload the cubicles one by one, maintaining the first-in-first-out order and placing them in the new office according to its new dimensions.\\n- This way, we can fit all the cubicles in order from the old office to the new office, as long as the new office has the same area as the old one."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal Matrix Problem. Just make sure to add the base condition of returning the original(given) matrix if the given matrix\\'s dimensions doesn\\'t match the rehaped matrix\\'s dimensions"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When will people understand, to NOT post solutions here?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "In this [example](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg), `c` should be 2 not `4` Am I wrong?"
                    },
                    {
                        "username": "lcmpbll",
                        "content": "This is an example of what you should return if the reshape is not possible:\\n\\nIf the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\\n\\n"
                    },
                    {
                        "username": "mnmlyn",
                        "content": "why it is\"int** columnSizes\",not \"int* columnSizes\"?\\nand then\\ncolumnSizes = (int *)malloc(sizeof(int)*r);"
                    },
                    {
                        "username": "tarun22",
                        "content": "It would be great if you can put a minor comment on the Testcase 2 , that it returned the original matrix as the are does not match. That would reduce confusion."
                    },
                    {
                        "username": "AlisherRMA",
                        "content": "there is incorrect testcase(\\u211654)\\nmat = [[1,2]]\\nr = 1\\nc = 1\\nexpected result: [[1, 2]]\\nit should be just [[1]]"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Check for the base case.. If the given matrix\\'s dimensions doesn\\'t match the to be reshaped to matrix\\'s dimensions, we return the given matrix. That\\'s y for the above test case the result is [[1,2]]"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Logic, yet efficient , Beats 100% in Runtime & 99.10% in Memory, with Detailed Explantion: `\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3877156/simple-iterative-approach-beats-100-detailed-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "balls."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "penis."
                    }
                ]
            },
            {
                "id": 1856626,
                "content": [
                    {
                        "username": "mnithish850",
                        "content": "there is mistake in testcase\\ngiven mat\\n[[1,2],[3,4]]\\n give r=2, c=4\\nbut it is expecting answer as  [[1,2],[3,4]]\\nwhich is wrong"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think it\\'s correct as r*c is != m*n that is no. of elements are not same so we return the orignal matrix"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "Test case is right, in this case you have to return the original array because to dimension (size) mismatch."
                    },
                    {
                        "username": "123004048",
                        "content": "[@tenplus_086](/tenplus_086)  im getting [[1,2,3,4]] as the output"
                    },
                    {
                        "username": "kavignaani8203",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks. felt the same doubt that testcase is wrong. With your provided explanation , got it right"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@tenplus_086](/tenplus_086)  Yeah in case of dimension mismatch, we should return original matrix.. It cant be reshaped"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "No that test case is true\n because the given matrix is 2-2 means there are 4 element and we have to form new matrix of size 2-4 which has 8 element \nthen how you fill the 4 element in the 8 indexes matrix  "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I think its correct..What should be the expected output according to you?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "## Explanation:\\nThis task is easy for those who understand it as it is given in the question. However, for those who may initially think it is a task involving matrix transposition, it may be confusing at first. Therefore, for anyone who initially thought this was a matrix transpose task like I did, let me clarify: it is not. Simply read the question again.\\n\\nNow that we are clear on the question:\\n\\n- Imagine the given matrix as a set of cubicles. We are moving to a new office and the room has a different length and width, so we need to adjust the positions of the cubicles to fit them in the new office.\\n- However, what if the area of the new office is different from that of the old office? If it is smaller, we cannot fit all the cubicles. If it is larger, we cannot fill the space properly. In this case, we will not move to the new office.\\n- On the other hand, if the new office has the same area as the old one, we need to disassemble the cubicles and fit them in a truck for transport.\\n- Maintaining the order and position of the cubicles, we will disassemble them and place them in the truck in order.\\n- We will then unload the cubicles one by one, maintaining the first-in-first-out order and placing them in the new office according to its new dimensions.\\n- This way, we can fit all the cubicles in order from the old office to the new office, as long as the new office has the same area as the old one."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal Matrix Problem. Just make sure to add the base condition of returning the original(given) matrix if the given matrix\\'s dimensions doesn\\'t match the rehaped matrix\\'s dimensions"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When will people understand, to NOT post solutions here?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "In this [example](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg), `c` should be 2 not `4` Am I wrong?"
                    },
                    {
                        "username": "lcmpbll",
                        "content": "This is an example of what you should return if the reshape is not possible:\\n\\nIf the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\\n\\n"
                    },
                    {
                        "username": "mnmlyn",
                        "content": "why it is\"int** columnSizes\",not \"int* columnSizes\"?\\nand then\\ncolumnSizes = (int *)malloc(sizeof(int)*r);"
                    },
                    {
                        "username": "tarun22",
                        "content": "It would be great if you can put a minor comment on the Testcase 2 , that it returned the original matrix as the are does not match. That would reduce confusion."
                    },
                    {
                        "username": "AlisherRMA",
                        "content": "there is incorrect testcase(\\u211654)\\nmat = [[1,2]]\\nr = 1\\nc = 1\\nexpected result: [[1, 2]]\\nit should be just [[1]]"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Check for the base case.. If the given matrix\\'s dimensions doesn\\'t match the to be reshaped to matrix\\'s dimensions, we return the given matrix. That\\'s y for the above test case the result is [[1,2]]"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Logic, yet efficient , Beats 100% in Runtime & 99.10% in Memory, with Detailed Explantion: `\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3877156/simple-iterative-approach-beats-100-detailed-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "balls."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "penis."
                    }
                ]
            },
            {
                "id": 1819625,
                "content": [
                    {
                        "username": "mnithish850",
                        "content": "there is mistake in testcase\\ngiven mat\\n[[1,2],[3,4]]\\n give r=2, c=4\\nbut it is expecting answer as  [[1,2],[3,4]]\\nwhich is wrong"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think it\\'s correct as r*c is != m*n that is no. of elements are not same so we return the orignal matrix"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "Test case is right, in this case you have to return the original array because to dimension (size) mismatch."
                    },
                    {
                        "username": "123004048",
                        "content": "[@tenplus_086](/tenplus_086)  im getting [[1,2,3,4]] as the output"
                    },
                    {
                        "username": "kavignaani8203",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks. felt the same doubt that testcase is wrong. With your provided explanation , got it right"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@tenplus_086](/tenplus_086)  Yeah in case of dimension mismatch, we should return original matrix.. It cant be reshaped"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "No that test case is true\n because the given matrix is 2-2 means there are 4 element and we have to form new matrix of size 2-4 which has 8 element \nthen how you fill the 4 element in the 8 indexes matrix  "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I think its correct..What should be the expected output according to you?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "## Explanation:\\nThis task is easy for those who understand it as it is given in the question. However, for those who may initially think it is a task involving matrix transposition, it may be confusing at first. Therefore, for anyone who initially thought this was a matrix transpose task like I did, let me clarify: it is not. Simply read the question again.\\n\\nNow that we are clear on the question:\\n\\n- Imagine the given matrix as a set of cubicles. We are moving to a new office and the room has a different length and width, so we need to adjust the positions of the cubicles to fit them in the new office.\\n- However, what if the area of the new office is different from that of the old office? If it is smaller, we cannot fit all the cubicles. If it is larger, we cannot fill the space properly. In this case, we will not move to the new office.\\n- On the other hand, if the new office has the same area as the old one, we need to disassemble the cubicles and fit them in a truck for transport.\\n- Maintaining the order and position of the cubicles, we will disassemble them and place them in the truck in order.\\n- We will then unload the cubicles one by one, maintaining the first-in-first-out order and placing them in the new office according to its new dimensions.\\n- This way, we can fit all the cubicles in order from the old office to the new office, as long as the new office has the same area as the old one."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal Matrix Problem. Just make sure to add the base condition of returning the original(given) matrix if the given matrix\\'s dimensions doesn\\'t match the rehaped matrix\\'s dimensions"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When will people understand, to NOT post solutions here?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "In this [example](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg), `c` should be 2 not `4` Am I wrong?"
                    },
                    {
                        "username": "lcmpbll",
                        "content": "This is an example of what you should return if the reshape is not possible:\\n\\nIf the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\\n\\n"
                    },
                    {
                        "username": "mnmlyn",
                        "content": "why it is\"int** columnSizes\",not \"int* columnSizes\"?\\nand then\\ncolumnSizes = (int *)malloc(sizeof(int)*r);"
                    },
                    {
                        "username": "tarun22",
                        "content": "It would be great if you can put a minor comment on the Testcase 2 , that it returned the original matrix as the are does not match. That would reduce confusion."
                    },
                    {
                        "username": "AlisherRMA",
                        "content": "there is incorrect testcase(\\u211654)\\nmat = [[1,2]]\\nr = 1\\nc = 1\\nexpected result: [[1, 2]]\\nit should be just [[1]]"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Check for the base case.. If the given matrix\\'s dimensions doesn\\'t match the to be reshaped to matrix\\'s dimensions, we return the given matrix. That\\'s y for the above test case the result is [[1,2]]"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Logic, yet efficient , Beats 100% in Runtime & 99.10% in Memory, with Detailed Explantion: `\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3877156/simple-iterative-approach-beats-100-detailed-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "balls."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "penis."
                    }
                ]
            },
            {
                "id": 1569137,
                "content": [
                    {
                        "username": "mnithish850",
                        "content": "there is mistake in testcase\\ngiven mat\\n[[1,2],[3,4]]\\n give r=2, c=4\\nbut it is expecting answer as  [[1,2],[3,4]]\\nwhich is wrong"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think it\\'s correct as r*c is != m*n that is no. of elements are not same so we return the orignal matrix"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "Test case is right, in this case you have to return the original array because to dimension (size) mismatch."
                    },
                    {
                        "username": "123004048",
                        "content": "[@tenplus_086](/tenplus_086)  im getting [[1,2,3,4]] as the output"
                    },
                    {
                        "username": "kavignaani8203",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks. felt the same doubt that testcase is wrong. With your provided explanation , got it right"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@tenplus_086](/tenplus_086)  Yeah in case of dimension mismatch, we should return original matrix.. It cant be reshaped"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "No that test case is true\n because the given matrix is 2-2 means there are 4 element and we have to form new matrix of size 2-4 which has 8 element \nthen how you fill the 4 element in the 8 indexes matrix  "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I think its correct..What should be the expected output according to you?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "## Explanation:\\nThis task is easy for those who understand it as it is given in the question. However, for those who may initially think it is a task involving matrix transposition, it may be confusing at first. Therefore, for anyone who initially thought this was a matrix transpose task like I did, let me clarify: it is not. Simply read the question again.\\n\\nNow that we are clear on the question:\\n\\n- Imagine the given matrix as a set of cubicles. We are moving to a new office and the room has a different length and width, so we need to adjust the positions of the cubicles to fit them in the new office.\\n- However, what if the area of the new office is different from that of the old office? If it is smaller, we cannot fit all the cubicles. If it is larger, we cannot fill the space properly. In this case, we will not move to the new office.\\n- On the other hand, if the new office has the same area as the old one, we need to disassemble the cubicles and fit them in a truck for transport.\\n- Maintaining the order and position of the cubicles, we will disassemble them and place them in the truck in order.\\n- We will then unload the cubicles one by one, maintaining the first-in-first-out order and placing them in the new office according to its new dimensions.\\n- This way, we can fit all the cubicles in order from the old office to the new office, as long as the new office has the same area as the old one."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal Matrix Problem. Just make sure to add the base condition of returning the original(given) matrix if the given matrix\\'s dimensions doesn\\'t match the rehaped matrix\\'s dimensions"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When will people understand, to NOT post solutions here?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "In this [example](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg), `c` should be 2 not `4` Am I wrong?"
                    },
                    {
                        "username": "lcmpbll",
                        "content": "This is an example of what you should return if the reshape is not possible:\\n\\nIf the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\\n\\n"
                    },
                    {
                        "username": "mnmlyn",
                        "content": "why it is\"int** columnSizes\",not \"int* columnSizes\"?\\nand then\\ncolumnSizes = (int *)malloc(sizeof(int)*r);"
                    },
                    {
                        "username": "tarun22",
                        "content": "It would be great if you can put a minor comment on the Testcase 2 , that it returned the original matrix as the are does not match. That would reduce confusion."
                    },
                    {
                        "username": "AlisherRMA",
                        "content": "there is incorrect testcase(\\u211654)\\nmat = [[1,2]]\\nr = 1\\nc = 1\\nexpected result: [[1, 2]]\\nit should be just [[1]]"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Check for the base case.. If the given matrix\\'s dimensions doesn\\'t match the to be reshaped to matrix\\'s dimensions, we return the given matrix. That\\'s y for the above test case the result is [[1,2]]"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Logic, yet efficient , Beats 100% in Runtime & 99.10% in Memory, with Detailed Explantion: `\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3877156/simple-iterative-approach-beats-100-detailed-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "balls."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "penis."
                    }
                ]
            },
            {
                "id": 1852543,
                "content": [
                    {
                        "username": "mnithish850",
                        "content": "there is mistake in testcase\\ngiven mat\\n[[1,2],[3,4]]\\n give r=2, c=4\\nbut it is expecting answer as  [[1,2],[3,4]]\\nwhich is wrong"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think it\\'s correct as r*c is != m*n that is no. of elements are not same so we return the orignal matrix"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "Test case is right, in this case you have to return the original array because to dimension (size) mismatch."
                    },
                    {
                        "username": "123004048",
                        "content": "[@tenplus_086](/tenplus_086)  im getting [[1,2,3,4]] as the output"
                    },
                    {
                        "username": "kavignaani8203",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks. felt the same doubt that testcase is wrong. With your provided explanation , got it right"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@tenplus_086](/tenplus_086)  Yeah in case of dimension mismatch, we should return original matrix.. It cant be reshaped"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "No that test case is true\n because the given matrix is 2-2 means there are 4 element and we have to form new matrix of size 2-4 which has 8 element \nthen how you fill the 4 element in the 8 indexes matrix  "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I think its correct..What should be the expected output according to you?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "## Explanation:\\nThis task is easy for those who understand it as it is given in the question. However, for those who may initially think it is a task involving matrix transposition, it may be confusing at first. Therefore, for anyone who initially thought this was a matrix transpose task like I did, let me clarify: it is not. Simply read the question again.\\n\\nNow that we are clear on the question:\\n\\n- Imagine the given matrix as a set of cubicles. We are moving to a new office and the room has a different length and width, so we need to adjust the positions of the cubicles to fit them in the new office.\\n- However, what if the area of the new office is different from that of the old office? If it is smaller, we cannot fit all the cubicles. If it is larger, we cannot fill the space properly. In this case, we will not move to the new office.\\n- On the other hand, if the new office has the same area as the old one, we need to disassemble the cubicles and fit them in a truck for transport.\\n- Maintaining the order and position of the cubicles, we will disassemble them and place them in the truck in order.\\n- We will then unload the cubicles one by one, maintaining the first-in-first-out order and placing them in the new office according to its new dimensions.\\n- This way, we can fit all the cubicles in order from the old office to the new office, as long as the new office has the same area as the old one."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal Matrix Problem. Just make sure to add the base condition of returning the original(given) matrix if the given matrix\\'s dimensions doesn\\'t match the rehaped matrix\\'s dimensions"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When will people understand, to NOT post solutions here?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "In this [example](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg), `c` should be 2 not `4` Am I wrong?"
                    },
                    {
                        "username": "lcmpbll",
                        "content": "This is an example of what you should return if the reshape is not possible:\\n\\nIf the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\\n\\n"
                    },
                    {
                        "username": "mnmlyn",
                        "content": "why it is\"int** columnSizes\",not \"int* columnSizes\"?\\nand then\\ncolumnSizes = (int *)malloc(sizeof(int)*r);"
                    },
                    {
                        "username": "tarun22",
                        "content": "It would be great if you can put a minor comment on the Testcase 2 , that it returned the original matrix as the are does not match. That would reduce confusion."
                    },
                    {
                        "username": "AlisherRMA",
                        "content": "there is incorrect testcase(\\u211654)\\nmat = [[1,2]]\\nr = 1\\nc = 1\\nexpected result: [[1, 2]]\\nit should be just [[1]]"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Check for the base case.. If the given matrix\\'s dimensions doesn\\'t match the to be reshaped to matrix\\'s dimensions, we return the given matrix. That\\'s y for the above test case the result is [[1,2]]"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Logic, yet efficient , Beats 100% in Runtime & 99.10% in Memory, with Detailed Explantion: `\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3877156/simple-iterative-approach-beats-100-detailed-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "balls."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "penis."
                    }
                ]
            },
            {
                "id": 1721781,
                "content": [
                    {
                        "username": "mnithish850",
                        "content": "there is mistake in testcase\\ngiven mat\\n[[1,2],[3,4]]\\n give r=2, c=4\\nbut it is expecting answer as  [[1,2],[3,4]]\\nwhich is wrong"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think it\\'s correct as r*c is != m*n that is no. of elements are not same so we return the orignal matrix"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "Test case is right, in this case you have to return the original array because to dimension (size) mismatch."
                    },
                    {
                        "username": "123004048",
                        "content": "[@tenplus_086](/tenplus_086)  im getting [[1,2,3,4]] as the output"
                    },
                    {
                        "username": "kavignaani8203",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks. felt the same doubt that testcase is wrong. With your provided explanation , got it right"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@tenplus_086](/tenplus_086)  Yeah in case of dimension mismatch, we should return original matrix.. It cant be reshaped"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "No that test case is true\n because the given matrix is 2-2 means there are 4 element and we have to form new matrix of size 2-4 which has 8 element \nthen how you fill the 4 element in the 8 indexes matrix  "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I think its correct..What should be the expected output according to you?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "## Explanation:\\nThis task is easy for those who understand it as it is given in the question. However, for those who may initially think it is a task involving matrix transposition, it may be confusing at first. Therefore, for anyone who initially thought this was a matrix transpose task like I did, let me clarify: it is not. Simply read the question again.\\n\\nNow that we are clear on the question:\\n\\n- Imagine the given matrix as a set of cubicles. We are moving to a new office and the room has a different length and width, so we need to adjust the positions of the cubicles to fit them in the new office.\\n- However, what if the area of the new office is different from that of the old office? If it is smaller, we cannot fit all the cubicles. If it is larger, we cannot fill the space properly. In this case, we will not move to the new office.\\n- On the other hand, if the new office has the same area as the old one, we need to disassemble the cubicles and fit them in a truck for transport.\\n- Maintaining the order and position of the cubicles, we will disassemble them and place them in the truck in order.\\n- We will then unload the cubicles one by one, maintaining the first-in-first-out order and placing them in the new office according to its new dimensions.\\n- This way, we can fit all the cubicles in order from the old office to the new office, as long as the new office has the same area as the old one."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal Matrix Problem. Just make sure to add the base condition of returning the original(given) matrix if the given matrix\\'s dimensions doesn\\'t match the rehaped matrix\\'s dimensions"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When will people understand, to NOT post solutions here?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "In this [example](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg), `c` should be 2 not `4` Am I wrong?"
                    },
                    {
                        "username": "lcmpbll",
                        "content": "This is an example of what you should return if the reshape is not possible:\\n\\nIf the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\\n\\n"
                    },
                    {
                        "username": "mnmlyn",
                        "content": "why it is\"int** columnSizes\",not \"int* columnSizes\"?\\nand then\\ncolumnSizes = (int *)malloc(sizeof(int)*r);"
                    },
                    {
                        "username": "tarun22",
                        "content": "It would be great if you can put a minor comment on the Testcase 2 , that it returned the original matrix as the are does not match. That would reduce confusion."
                    },
                    {
                        "username": "AlisherRMA",
                        "content": "there is incorrect testcase(\\u211654)\\nmat = [[1,2]]\\nr = 1\\nc = 1\\nexpected result: [[1, 2]]\\nit should be just [[1]]"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Check for the base case.. If the given matrix\\'s dimensions doesn\\'t match the to be reshaped to matrix\\'s dimensions, we return the given matrix. That\\'s y for the above test case the result is [[1,2]]"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Logic, yet efficient , Beats 100% in Runtime & 99.10% in Memory, with Detailed Explantion: `\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3877156/simple-iterative-approach-beats-100-detailed-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "balls."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "penis."
                    }
                ]
            },
            {
                "id": 2004399,
                "content": [
                    {
                        "username": "mnithish850",
                        "content": "there is mistake in testcase\\ngiven mat\\n[[1,2],[3,4]]\\n give r=2, c=4\\nbut it is expecting answer as  [[1,2],[3,4]]\\nwhich is wrong"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think it\\'s correct as r*c is != m*n that is no. of elements are not same so we return the orignal matrix"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "Test case is right, in this case you have to return the original array because to dimension (size) mismatch."
                    },
                    {
                        "username": "123004048",
                        "content": "[@tenplus_086](/tenplus_086)  im getting [[1,2,3,4]] as the output"
                    },
                    {
                        "username": "kavignaani8203",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks. felt the same doubt that testcase is wrong. With your provided explanation , got it right"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@tenplus_086](/tenplus_086)  Yeah in case of dimension mismatch, we should return original matrix.. It cant be reshaped"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "No that test case is true\n because the given matrix is 2-2 means there are 4 element and we have to form new matrix of size 2-4 which has 8 element \nthen how you fill the 4 element in the 8 indexes matrix  "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I think its correct..What should be the expected output according to you?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "## Explanation:\\nThis task is easy for those who understand it as it is given in the question. However, for those who may initially think it is a task involving matrix transposition, it may be confusing at first. Therefore, for anyone who initially thought this was a matrix transpose task like I did, let me clarify: it is not. Simply read the question again.\\n\\nNow that we are clear on the question:\\n\\n- Imagine the given matrix as a set of cubicles. We are moving to a new office and the room has a different length and width, so we need to adjust the positions of the cubicles to fit them in the new office.\\n- However, what if the area of the new office is different from that of the old office? If it is smaller, we cannot fit all the cubicles. If it is larger, we cannot fill the space properly. In this case, we will not move to the new office.\\n- On the other hand, if the new office has the same area as the old one, we need to disassemble the cubicles and fit them in a truck for transport.\\n- Maintaining the order and position of the cubicles, we will disassemble them and place them in the truck in order.\\n- We will then unload the cubicles one by one, maintaining the first-in-first-out order and placing them in the new office according to its new dimensions.\\n- This way, we can fit all the cubicles in order from the old office to the new office, as long as the new office has the same area as the old one."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal Matrix Problem. Just make sure to add the base condition of returning the original(given) matrix if the given matrix\\'s dimensions doesn\\'t match the rehaped matrix\\'s dimensions"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When will people understand, to NOT post solutions here?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "In this [example](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg), `c` should be 2 not `4` Am I wrong?"
                    },
                    {
                        "username": "lcmpbll",
                        "content": "This is an example of what you should return if the reshape is not possible:\\n\\nIf the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\\n\\n"
                    },
                    {
                        "username": "mnmlyn",
                        "content": "why it is\"int** columnSizes\",not \"int* columnSizes\"?\\nand then\\ncolumnSizes = (int *)malloc(sizeof(int)*r);"
                    },
                    {
                        "username": "tarun22",
                        "content": "It would be great if you can put a minor comment on the Testcase 2 , that it returned the original matrix as the are does not match. That would reduce confusion."
                    },
                    {
                        "username": "AlisherRMA",
                        "content": "there is incorrect testcase(\\u211654)\\nmat = [[1,2]]\\nr = 1\\nc = 1\\nexpected result: [[1, 2]]\\nit should be just [[1]]"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Check for the base case.. If the given matrix\\'s dimensions doesn\\'t match the to be reshaped to matrix\\'s dimensions, we return the given matrix. That\\'s y for the above test case the result is [[1,2]]"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Logic, yet efficient , Beats 100% in Runtime & 99.10% in Memory, with Detailed Explantion: `\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3877156/simple-iterative-approach-beats-100-detailed-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "balls."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "penis."
                    }
                ]
            },
            {
                "id": 1977037,
                "content": [
                    {
                        "username": "mnithish850",
                        "content": "there is mistake in testcase\\ngiven mat\\n[[1,2],[3,4]]\\n give r=2, c=4\\nbut it is expecting answer as  [[1,2],[3,4]]\\nwhich is wrong"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think it\\'s correct as r*c is != m*n that is no. of elements are not same so we return the orignal matrix"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "Test case is right, in this case you have to return the original array because to dimension (size) mismatch."
                    },
                    {
                        "username": "123004048",
                        "content": "[@tenplus_086](/tenplus_086)  im getting [[1,2,3,4]] as the output"
                    },
                    {
                        "username": "kavignaani8203",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks. felt the same doubt that testcase is wrong. With your provided explanation , got it right"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@tenplus_086](/tenplus_086)  Yeah in case of dimension mismatch, we should return original matrix.. It cant be reshaped"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "No that test case is true\n because the given matrix is 2-2 means there are 4 element and we have to form new matrix of size 2-4 which has 8 element \nthen how you fill the 4 element in the 8 indexes matrix  "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I think its correct..What should be the expected output according to you?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "## Explanation:\\nThis task is easy for those who understand it as it is given in the question. However, for those who may initially think it is a task involving matrix transposition, it may be confusing at first. Therefore, for anyone who initially thought this was a matrix transpose task like I did, let me clarify: it is not. Simply read the question again.\\n\\nNow that we are clear on the question:\\n\\n- Imagine the given matrix as a set of cubicles. We are moving to a new office and the room has a different length and width, so we need to adjust the positions of the cubicles to fit them in the new office.\\n- However, what if the area of the new office is different from that of the old office? If it is smaller, we cannot fit all the cubicles. If it is larger, we cannot fill the space properly. In this case, we will not move to the new office.\\n- On the other hand, if the new office has the same area as the old one, we need to disassemble the cubicles and fit them in a truck for transport.\\n- Maintaining the order and position of the cubicles, we will disassemble them and place them in the truck in order.\\n- We will then unload the cubicles one by one, maintaining the first-in-first-out order and placing them in the new office according to its new dimensions.\\n- This way, we can fit all the cubicles in order from the old office to the new office, as long as the new office has the same area as the old one."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal Matrix Problem. Just make sure to add the base condition of returning the original(given) matrix if the given matrix\\'s dimensions doesn\\'t match the rehaped matrix\\'s dimensions"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When will people understand, to NOT post solutions here?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "In this [example](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg), `c` should be 2 not `4` Am I wrong?"
                    },
                    {
                        "username": "lcmpbll",
                        "content": "This is an example of what you should return if the reshape is not possible:\\n\\nIf the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\\n\\n"
                    },
                    {
                        "username": "mnmlyn",
                        "content": "why it is\"int** columnSizes\",not \"int* columnSizes\"?\\nand then\\ncolumnSizes = (int *)malloc(sizeof(int)*r);"
                    },
                    {
                        "username": "tarun22",
                        "content": "It would be great if you can put a minor comment on the Testcase 2 , that it returned the original matrix as the are does not match. That would reduce confusion."
                    },
                    {
                        "username": "AlisherRMA",
                        "content": "there is incorrect testcase(\\u211654)\\nmat = [[1,2]]\\nr = 1\\nc = 1\\nexpected result: [[1, 2]]\\nit should be just [[1]]"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Check for the base case.. If the given matrix\\'s dimensions doesn\\'t match the to be reshaped to matrix\\'s dimensions, we return the given matrix. That\\'s y for the above test case the result is [[1,2]]"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Logic, yet efficient , Beats 100% in Runtime & 99.10% in Memory, with Detailed Explantion: `\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3877156/simple-iterative-approach-beats-100-detailed-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "balls."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "penis."
                    }
                ]
            },
            {
                "id": 1710174,
                "content": [
                    {
                        "username": "mnithish850",
                        "content": "there is mistake in testcase\\ngiven mat\\n[[1,2],[3,4]]\\n give r=2, c=4\\nbut it is expecting answer as  [[1,2],[3,4]]\\nwhich is wrong"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think it\\'s correct as r*c is != m*n that is no. of elements are not same so we return the orignal matrix"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "Test case is right, in this case you have to return the original array because to dimension (size) mismatch."
                    },
                    {
                        "username": "123004048",
                        "content": "[@tenplus_086](/tenplus_086)  im getting [[1,2,3,4]] as the output"
                    },
                    {
                        "username": "kavignaani8203",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks. felt the same doubt that testcase is wrong. With your provided explanation , got it right"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@tenplus_086](/tenplus_086)  Yeah in case of dimension mismatch, we should return original matrix.. It cant be reshaped"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "No that test case is true\n because the given matrix is 2-2 means there are 4 element and we have to form new matrix of size 2-4 which has 8 element \nthen how you fill the 4 element in the 8 indexes matrix  "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I think its correct..What should be the expected output according to you?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "## Explanation:\\nThis task is easy for those who understand it as it is given in the question. However, for those who may initially think it is a task involving matrix transposition, it may be confusing at first. Therefore, for anyone who initially thought this was a matrix transpose task like I did, let me clarify: it is not. Simply read the question again.\\n\\nNow that we are clear on the question:\\n\\n- Imagine the given matrix as a set of cubicles. We are moving to a new office and the room has a different length and width, so we need to adjust the positions of the cubicles to fit them in the new office.\\n- However, what if the area of the new office is different from that of the old office? If it is smaller, we cannot fit all the cubicles. If it is larger, we cannot fill the space properly. In this case, we will not move to the new office.\\n- On the other hand, if the new office has the same area as the old one, we need to disassemble the cubicles and fit them in a truck for transport.\\n- Maintaining the order and position of the cubicles, we will disassemble them and place them in the truck in order.\\n- We will then unload the cubicles one by one, maintaining the first-in-first-out order and placing them in the new office according to its new dimensions.\\n- This way, we can fit all the cubicles in order from the old office to the new office, as long as the new office has the same area as the old one."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal Matrix Problem. Just make sure to add the base condition of returning the original(given) matrix if the given matrix\\'s dimensions doesn\\'t match the rehaped matrix\\'s dimensions"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When will people understand, to NOT post solutions here?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "In this [example](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg), `c` should be 2 not `4` Am I wrong?"
                    },
                    {
                        "username": "lcmpbll",
                        "content": "This is an example of what you should return if the reshape is not possible:\\n\\nIf the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\\n\\n"
                    },
                    {
                        "username": "mnmlyn",
                        "content": "why it is\"int** columnSizes\",not \"int* columnSizes\"?\\nand then\\ncolumnSizes = (int *)malloc(sizeof(int)*r);"
                    },
                    {
                        "username": "tarun22",
                        "content": "It would be great if you can put a minor comment on the Testcase 2 , that it returned the original matrix as the are does not match. That would reduce confusion."
                    },
                    {
                        "username": "AlisherRMA",
                        "content": "there is incorrect testcase(\\u211654)\\nmat = [[1,2]]\\nr = 1\\nc = 1\\nexpected result: [[1, 2]]\\nit should be just [[1]]"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Check for the base case.. If the given matrix\\'s dimensions doesn\\'t match the to be reshaped to matrix\\'s dimensions, we return the given matrix. That\\'s y for the above test case the result is [[1,2]]"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Logic, yet efficient , Beats 100% in Runtime & 99.10% in Memory, with Detailed Explantion: `\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3877156/simple-iterative-approach-beats-100-detailed-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "balls."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "penis."
                    }
                ]
            },
            {
                "id": 1742440,
                "content": [
                    {
                        "username": "mnithish850",
                        "content": "there is mistake in testcase\\ngiven mat\\n[[1,2],[3,4]]\\n give r=2, c=4\\nbut it is expecting answer as  [[1,2],[3,4]]\\nwhich is wrong"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think it\\'s correct as r*c is != m*n that is no. of elements are not same so we return the orignal matrix"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "Test case is right, in this case you have to return the original array because to dimension (size) mismatch."
                    },
                    {
                        "username": "123004048",
                        "content": "[@tenplus_086](/tenplus_086)  im getting [[1,2,3,4]] as the output"
                    },
                    {
                        "username": "kavignaani8203",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks. felt the same doubt that testcase is wrong. With your provided explanation , got it right"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@tenplus_086](/tenplus_086)  Yeah in case of dimension mismatch, we should return original matrix.. It cant be reshaped"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "No that test case is true\n because the given matrix is 2-2 means there are 4 element and we have to form new matrix of size 2-4 which has 8 element \nthen how you fill the 4 element in the 8 indexes matrix  "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I think its correct..What should be the expected output according to you?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "## Explanation:\\nThis task is easy for those who understand it as it is given in the question. However, for those who may initially think it is a task involving matrix transposition, it may be confusing at first. Therefore, for anyone who initially thought this was a matrix transpose task like I did, let me clarify: it is not. Simply read the question again.\\n\\nNow that we are clear on the question:\\n\\n- Imagine the given matrix as a set of cubicles. We are moving to a new office and the room has a different length and width, so we need to adjust the positions of the cubicles to fit them in the new office.\\n- However, what if the area of the new office is different from that of the old office? If it is smaller, we cannot fit all the cubicles. If it is larger, we cannot fill the space properly. In this case, we will not move to the new office.\\n- On the other hand, if the new office has the same area as the old one, we need to disassemble the cubicles and fit them in a truck for transport.\\n- Maintaining the order and position of the cubicles, we will disassemble them and place them in the truck in order.\\n- We will then unload the cubicles one by one, maintaining the first-in-first-out order and placing them in the new office according to its new dimensions.\\n- This way, we can fit all the cubicles in order from the old office to the new office, as long as the new office has the same area as the old one."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal Matrix Problem. Just make sure to add the base condition of returning the original(given) matrix if the given matrix\\'s dimensions doesn\\'t match the rehaped matrix\\'s dimensions"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When will people understand, to NOT post solutions here?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "In this [example](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg), `c` should be 2 not `4` Am I wrong?"
                    },
                    {
                        "username": "lcmpbll",
                        "content": "This is an example of what you should return if the reshape is not possible:\\n\\nIf the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\\n\\n"
                    },
                    {
                        "username": "mnmlyn",
                        "content": "why it is\"int** columnSizes\",not \"int* columnSizes\"?\\nand then\\ncolumnSizes = (int *)malloc(sizeof(int)*r);"
                    },
                    {
                        "username": "tarun22",
                        "content": "It would be great if you can put a minor comment on the Testcase 2 , that it returned the original matrix as the are does not match. That would reduce confusion."
                    },
                    {
                        "username": "AlisherRMA",
                        "content": "there is incorrect testcase(\\u211654)\\nmat = [[1,2]]\\nr = 1\\nc = 1\\nexpected result: [[1, 2]]\\nit should be just [[1]]"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Check for the base case.. If the given matrix\\'s dimensions doesn\\'t match the to be reshaped to matrix\\'s dimensions, we return the given matrix. That\\'s y for the above test case the result is [[1,2]]"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Logic, yet efficient , Beats 100% in Runtime & 99.10% in Memory, with Detailed Explantion: `\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3877156/simple-iterative-approach-beats-100-detailed-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "balls."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "penis."
                    }
                ]
            },
            {
                "id": 1670312,
                "content": [
                    {
                        "username": "mnithish850",
                        "content": "there is mistake in testcase\\ngiven mat\\n[[1,2],[3,4]]\\n give r=2, c=4\\nbut it is expecting answer as  [[1,2],[3,4]]\\nwhich is wrong"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think it\\'s correct as r*c is != m*n that is no. of elements are not same so we return the orignal matrix"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "Test case is right, in this case you have to return the original array because to dimension (size) mismatch."
                    },
                    {
                        "username": "123004048",
                        "content": "[@tenplus_086](/tenplus_086)  im getting [[1,2,3,4]] as the output"
                    },
                    {
                        "username": "kavignaani8203",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks. felt the same doubt that testcase is wrong. With your provided explanation , got it right"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@tenplus_086](/tenplus_086)  Yeah in case of dimension mismatch, we should return original matrix.. It cant be reshaped"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "No that test case is true\n because the given matrix is 2-2 means there are 4 element and we have to form new matrix of size 2-4 which has 8 element \nthen how you fill the 4 element in the 8 indexes matrix  "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I think its correct..What should be the expected output according to you?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "## Explanation:\\nThis task is easy for those who understand it as it is given in the question. However, for those who may initially think it is a task involving matrix transposition, it may be confusing at first. Therefore, for anyone who initially thought this was a matrix transpose task like I did, let me clarify: it is not. Simply read the question again.\\n\\nNow that we are clear on the question:\\n\\n- Imagine the given matrix as a set of cubicles. We are moving to a new office and the room has a different length and width, so we need to adjust the positions of the cubicles to fit them in the new office.\\n- However, what if the area of the new office is different from that of the old office? If it is smaller, we cannot fit all the cubicles. If it is larger, we cannot fill the space properly. In this case, we will not move to the new office.\\n- On the other hand, if the new office has the same area as the old one, we need to disassemble the cubicles and fit them in a truck for transport.\\n- Maintaining the order and position of the cubicles, we will disassemble them and place them in the truck in order.\\n- We will then unload the cubicles one by one, maintaining the first-in-first-out order and placing them in the new office according to its new dimensions.\\n- This way, we can fit all the cubicles in order from the old office to the new office, as long as the new office has the same area as the old one."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal Matrix Problem. Just make sure to add the base condition of returning the original(given) matrix if the given matrix\\'s dimensions doesn\\'t match the rehaped matrix\\'s dimensions"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When will people understand, to NOT post solutions here?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "In this [example](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg), `c` should be 2 not `4` Am I wrong?"
                    },
                    {
                        "username": "lcmpbll",
                        "content": "This is an example of what you should return if the reshape is not possible:\\n\\nIf the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\\n\\n"
                    },
                    {
                        "username": "mnmlyn",
                        "content": "why it is\"int** columnSizes\",not \"int* columnSizes\"?\\nand then\\ncolumnSizes = (int *)malloc(sizeof(int)*r);"
                    },
                    {
                        "username": "tarun22",
                        "content": "It would be great if you can put a minor comment on the Testcase 2 , that it returned the original matrix as the are does not match. That would reduce confusion."
                    },
                    {
                        "username": "AlisherRMA",
                        "content": "there is incorrect testcase(\\u211654)\\nmat = [[1,2]]\\nr = 1\\nc = 1\\nexpected result: [[1, 2]]\\nit should be just [[1]]"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Check for the base case.. If the given matrix\\'s dimensions doesn\\'t match the to be reshaped to matrix\\'s dimensions, we return the given matrix. That\\'s y for the above test case the result is [[1,2]]"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Logic, yet efficient , Beats 100% in Runtime & 99.10% in Memory, with Detailed Explantion: `\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3877156/simple-iterative-approach-beats-100-detailed-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "balls."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "penis."
                    }
                ]
            },
            {
                "id": 1856626,
                "content": [
                    {
                        "username": "mnithish850",
                        "content": "there is mistake in testcase\\ngiven mat\\n[[1,2],[3,4]]\\n give r=2, c=4\\nbut it is expecting answer as  [[1,2],[3,4]]\\nwhich is wrong"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think it\\'s correct as r*c is != m*n that is no. of elements are not same so we return the orignal matrix"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "Test case is right, in this case you have to return the original array because to dimension (size) mismatch."
                    },
                    {
                        "username": "123004048",
                        "content": "[@tenplus_086](/tenplus_086)  im getting [[1,2,3,4]] as the output"
                    },
                    {
                        "username": "kavignaani8203",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks. felt the same doubt that testcase is wrong. With your provided explanation , got it right"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@tenplus_086](/tenplus_086)  Yeah in case of dimension mismatch, we should return original matrix.. It cant be reshaped"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "No that test case is true\n because the given matrix is 2-2 means there are 4 element and we have to form new matrix of size 2-4 which has 8 element \nthen how you fill the 4 element in the 8 indexes matrix  "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I think its correct..What should be the expected output according to you?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "## Explanation:\\nThis task is easy for those who understand it as it is given in the question. However, for those who may initially think it is a task involving matrix transposition, it may be confusing at first. Therefore, for anyone who initially thought this was a matrix transpose task like I did, let me clarify: it is not. Simply read the question again.\\n\\nNow that we are clear on the question:\\n\\n- Imagine the given matrix as a set of cubicles. We are moving to a new office and the room has a different length and width, so we need to adjust the positions of the cubicles to fit them in the new office.\\n- However, what if the area of the new office is different from that of the old office? If it is smaller, we cannot fit all the cubicles. If it is larger, we cannot fill the space properly. In this case, we will not move to the new office.\\n- On the other hand, if the new office has the same area as the old one, we need to disassemble the cubicles and fit them in a truck for transport.\\n- Maintaining the order and position of the cubicles, we will disassemble them and place them in the truck in order.\\n- We will then unload the cubicles one by one, maintaining the first-in-first-out order and placing them in the new office according to its new dimensions.\\n- This way, we can fit all the cubicles in order from the old office to the new office, as long as the new office has the same area as the old one."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal Matrix Problem. Just make sure to add the base condition of returning the original(given) matrix if the given matrix\\'s dimensions doesn\\'t match the rehaped matrix\\'s dimensions"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When will people understand, to NOT post solutions here?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "In this [example](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg), `c` should be 2 not `4` Am I wrong?"
                    },
                    {
                        "username": "lcmpbll",
                        "content": "This is an example of what you should return if the reshape is not possible:\\n\\nIf the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\\n\\n"
                    },
                    {
                        "username": "mnmlyn",
                        "content": "why it is\"int** columnSizes\",not \"int* columnSizes\"?\\nand then\\ncolumnSizes = (int *)malloc(sizeof(int)*r);"
                    },
                    {
                        "username": "tarun22",
                        "content": "It would be great if you can put a minor comment on the Testcase 2 , that it returned the original matrix as the are does not match. That would reduce confusion."
                    },
                    {
                        "username": "AlisherRMA",
                        "content": "there is incorrect testcase(\\u211654)\\nmat = [[1,2]]\\nr = 1\\nc = 1\\nexpected result: [[1, 2]]\\nit should be just [[1]]"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Check for the base case.. If the given matrix\\'s dimensions doesn\\'t match the to be reshaped to matrix\\'s dimensions, we return the given matrix. That\\'s y for the above test case the result is [[1,2]]"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Logic, yet efficient , Beats 100% in Runtime & 99.10% in Memory, with Detailed Explantion: `\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3877156/simple-iterative-approach-beats-100-detailed-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "balls."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "penis."
                    }
                ]
            },
            {
                "id": 1819625,
                "content": [
                    {
                        "username": "mnithish850",
                        "content": "there is mistake in testcase\\ngiven mat\\n[[1,2],[3,4]]\\n give r=2, c=4\\nbut it is expecting answer as  [[1,2],[3,4]]\\nwhich is wrong"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think it\\'s correct as r*c is != m*n that is no. of elements are not same so we return the orignal matrix"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "Test case is right, in this case you have to return the original array because to dimension (size) mismatch."
                    },
                    {
                        "username": "123004048",
                        "content": "[@tenplus_086](/tenplus_086)  im getting [[1,2,3,4]] as the output"
                    },
                    {
                        "username": "kavignaani8203",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks. felt the same doubt that testcase is wrong. With your provided explanation , got it right"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@tenplus_086](/tenplus_086)  Yeah in case of dimension mismatch, we should return original matrix.. It cant be reshaped"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "No that test case is true\n because the given matrix is 2-2 means there are 4 element and we have to form new matrix of size 2-4 which has 8 element \nthen how you fill the 4 element in the 8 indexes matrix  "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I think its correct..What should be the expected output according to you?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "## Explanation:\\nThis task is easy for those who understand it as it is given in the question. However, for those who may initially think it is a task involving matrix transposition, it may be confusing at first. Therefore, for anyone who initially thought this was a matrix transpose task like I did, let me clarify: it is not. Simply read the question again.\\n\\nNow that we are clear on the question:\\n\\n- Imagine the given matrix as a set of cubicles. We are moving to a new office and the room has a different length and width, so we need to adjust the positions of the cubicles to fit them in the new office.\\n- However, what if the area of the new office is different from that of the old office? If it is smaller, we cannot fit all the cubicles. If it is larger, we cannot fill the space properly. In this case, we will not move to the new office.\\n- On the other hand, if the new office has the same area as the old one, we need to disassemble the cubicles and fit them in a truck for transport.\\n- Maintaining the order and position of the cubicles, we will disassemble them and place them in the truck in order.\\n- We will then unload the cubicles one by one, maintaining the first-in-first-out order and placing them in the new office according to its new dimensions.\\n- This way, we can fit all the cubicles in order from the old office to the new office, as long as the new office has the same area as the old one."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal Matrix Problem. Just make sure to add the base condition of returning the original(given) matrix if the given matrix\\'s dimensions doesn\\'t match the rehaped matrix\\'s dimensions"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When will people understand, to NOT post solutions here?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "In this [example](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg), `c` should be 2 not `4` Am I wrong?"
                    },
                    {
                        "username": "lcmpbll",
                        "content": "This is an example of what you should return if the reshape is not possible:\\n\\nIf the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\\n\\n"
                    },
                    {
                        "username": "mnmlyn",
                        "content": "why it is\"int** columnSizes\",not \"int* columnSizes\"?\\nand then\\ncolumnSizes = (int *)malloc(sizeof(int)*r);"
                    },
                    {
                        "username": "tarun22",
                        "content": "It would be great if you can put a minor comment on the Testcase 2 , that it returned the original matrix as the are does not match. That would reduce confusion."
                    },
                    {
                        "username": "AlisherRMA",
                        "content": "there is incorrect testcase(\\u211654)\\nmat = [[1,2]]\\nr = 1\\nc = 1\\nexpected result: [[1, 2]]\\nit should be just [[1]]"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Check for the base case.. If the given matrix\\'s dimensions doesn\\'t match the to be reshaped to matrix\\'s dimensions, we return the given matrix. That\\'s y for the above test case the result is [[1,2]]"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Logic, yet efficient , Beats 100% in Runtime & 99.10% in Memory, with Detailed Explantion: `\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3877156/simple-iterative-approach-beats-100-detailed-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "balls."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "penis."
                    }
                ]
            },
            {
                "id": 1569137,
                "content": [
                    {
                        "username": "mnithish850",
                        "content": "there is mistake in testcase\\ngiven mat\\n[[1,2],[3,4]]\\n give r=2, c=4\\nbut it is expecting answer as  [[1,2],[3,4]]\\nwhich is wrong"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think it\\'s correct as r*c is != m*n that is no. of elements are not same so we return the orignal matrix"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "Test case is right, in this case you have to return the original array because to dimension (size) mismatch."
                    },
                    {
                        "username": "123004048",
                        "content": "[@tenplus_086](/tenplus_086)  im getting [[1,2,3,4]] as the output"
                    },
                    {
                        "username": "kavignaani8203",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks. felt the same doubt that testcase is wrong. With your provided explanation , got it right"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@tenplus_086](/tenplus_086)  Yeah in case of dimension mismatch, we should return original matrix.. It cant be reshaped"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "No that test case is true\n because the given matrix is 2-2 means there are 4 element and we have to form new matrix of size 2-4 which has 8 element \nthen how you fill the 4 element in the 8 indexes matrix  "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I think its correct..What should be the expected output according to you?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "## Explanation:\\nThis task is easy for those who understand it as it is given in the question. However, for those who may initially think it is a task involving matrix transposition, it may be confusing at first. Therefore, for anyone who initially thought this was a matrix transpose task like I did, let me clarify: it is not. Simply read the question again.\\n\\nNow that we are clear on the question:\\n\\n- Imagine the given matrix as a set of cubicles. We are moving to a new office and the room has a different length and width, so we need to adjust the positions of the cubicles to fit them in the new office.\\n- However, what if the area of the new office is different from that of the old office? If it is smaller, we cannot fit all the cubicles. If it is larger, we cannot fill the space properly. In this case, we will not move to the new office.\\n- On the other hand, if the new office has the same area as the old one, we need to disassemble the cubicles and fit them in a truck for transport.\\n- Maintaining the order and position of the cubicles, we will disassemble them and place them in the truck in order.\\n- We will then unload the cubicles one by one, maintaining the first-in-first-out order and placing them in the new office according to its new dimensions.\\n- This way, we can fit all the cubicles in order from the old office to the new office, as long as the new office has the same area as the old one."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal Matrix Problem. Just make sure to add the base condition of returning the original(given) matrix if the given matrix\\'s dimensions doesn\\'t match the rehaped matrix\\'s dimensions"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When will people understand, to NOT post solutions here?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "In this [example](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg), `c` should be 2 not `4` Am I wrong?"
                    },
                    {
                        "username": "lcmpbll",
                        "content": "This is an example of what you should return if the reshape is not possible:\\n\\nIf the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\\n\\n"
                    },
                    {
                        "username": "mnmlyn",
                        "content": "why it is\"int** columnSizes\",not \"int* columnSizes\"?\\nand then\\ncolumnSizes = (int *)malloc(sizeof(int)*r);"
                    },
                    {
                        "username": "tarun22",
                        "content": "It would be great if you can put a minor comment on the Testcase 2 , that it returned the original matrix as the are does not match. That would reduce confusion."
                    },
                    {
                        "username": "AlisherRMA",
                        "content": "there is incorrect testcase(\\u211654)\\nmat = [[1,2]]\\nr = 1\\nc = 1\\nexpected result: [[1, 2]]\\nit should be just [[1]]"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Check for the base case.. If the given matrix\\'s dimensions doesn\\'t match the to be reshaped to matrix\\'s dimensions, we return the given matrix. That\\'s y for the above test case the result is [[1,2]]"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Logic, yet efficient , Beats 100% in Runtime & 99.10% in Memory, with Detailed Explantion: `\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3877156/simple-iterative-approach-beats-100-detailed-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "balls."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "penis."
                    }
                ]
            },
            {
                "id": 1852543,
                "content": [
                    {
                        "username": "mnithish850",
                        "content": "there is mistake in testcase\\ngiven mat\\n[[1,2],[3,4]]\\n give r=2, c=4\\nbut it is expecting answer as  [[1,2],[3,4]]\\nwhich is wrong"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think it\\'s correct as r*c is != m*n that is no. of elements are not same so we return the orignal matrix"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "Test case is right, in this case you have to return the original array because to dimension (size) mismatch."
                    },
                    {
                        "username": "123004048",
                        "content": "[@tenplus_086](/tenplus_086)  im getting [[1,2,3,4]] as the output"
                    },
                    {
                        "username": "kavignaani8203",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks. felt the same doubt that testcase is wrong. With your provided explanation , got it right"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@tenplus_086](/tenplus_086)  Yeah in case of dimension mismatch, we should return original matrix.. It cant be reshaped"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "No that test case is true\n because the given matrix is 2-2 means there are 4 element and we have to form new matrix of size 2-4 which has 8 element \nthen how you fill the 4 element in the 8 indexes matrix  "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I think its correct..What should be the expected output according to you?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "## Explanation:\\nThis task is easy for those who understand it as it is given in the question. However, for those who may initially think it is a task involving matrix transposition, it may be confusing at first. Therefore, for anyone who initially thought this was a matrix transpose task like I did, let me clarify: it is not. Simply read the question again.\\n\\nNow that we are clear on the question:\\n\\n- Imagine the given matrix as a set of cubicles. We are moving to a new office and the room has a different length and width, so we need to adjust the positions of the cubicles to fit them in the new office.\\n- However, what if the area of the new office is different from that of the old office? If it is smaller, we cannot fit all the cubicles. If it is larger, we cannot fill the space properly. In this case, we will not move to the new office.\\n- On the other hand, if the new office has the same area as the old one, we need to disassemble the cubicles and fit them in a truck for transport.\\n- Maintaining the order and position of the cubicles, we will disassemble them and place them in the truck in order.\\n- We will then unload the cubicles one by one, maintaining the first-in-first-out order and placing them in the new office according to its new dimensions.\\n- This way, we can fit all the cubicles in order from the old office to the new office, as long as the new office has the same area as the old one."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal Matrix Problem. Just make sure to add the base condition of returning the original(given) matrix if the given matrix\\'s dimensions doesn\\'t match the rehaped matrix\\'s dimensions"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When will people understand, to NOT post solutions here?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "In this [example](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg), `c` should be 2 not `4` Am I wrong?"
                    },
                    {
                        "username": "lcmpbll",
                        "content": "This is an example of what you should return if the reshape is not possible:\\n\\nIf the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\\n\\n"
                    },
                    {
                        "username": "mnmlyn",
                        "content": "why it is\"int** columnSizes\",not \"int* columnSizes\"?\\nand then\\ncolumnSizes = (int *)malloc(sizeof(int)*r);"
                    },
                    {
                        "username": "tarun22",
                        "content": "It would be great if you can put a minor comment on the Testcase 2 , that it returned the original matrix as the are does not match. That would reduce confusion."
                    },
                    {
                        "username": "AlisherRMA",
                        "content": "there is incorrect testcase(\\u211654)\\nmat = [[1,2]]\\nr = 1\\nc = 1\\nexpected result: [[1, 2]]\\nit should be just [[1]]"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Check for the base case.. If the given matrix\\'s dimensions doesn\\'t match the to be reshaped to matrix\\'s dimensions, we return the given matrix. That\\'s y for the above test case the result is [[1,2]]"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Logic, yet efficient , Beats 100% in Runtime & 99.10% in Memory, with Detailed Explantion: `\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3877156/simple-iterative-approach-beats-100-detailed-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "balls."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "penis."
                    }
                ]
            },
            {
                "id": 1721781,
                "content": [
                    {
                        "username": "mnithish850",
                        "content": "there is mistake in testcase\\ngiven mat\\n[[1,2],[3,4]]\\n give r=2, c=4\\nbut it is expecting answer as  [[1,2],[3,4]]\\nwhich is wrong"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think it\\'s correct as r*c is != m*n that is no. of elements are not same so we return the orignal matrix"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "Test case is right, in this case you have to return the original array because to dimension (size) mismatch."
                    },
                    {
                        "username": "123004048",
                        "content": "[@tenplus_086](/tenplus_086)  im getting [[1,2,3,4]] as the output"
                    },
                    {
                        "username": "kavignaani8203",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks. felt the same doubt that testcase is wrong. With your provided explanation , got it right"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@tenplus_086](/tenplus_086)  Yeah in case of dimension mismatch, we should return original matrix.. It cant be reshaped"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "No that test case is true\n because the given matrix is 2-2 means there are 4 element and we have to form new matrix of size 2-4 which has 8 element \nthen how you fill the 4 element in the 8 indexes matrix  "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I think its correct..What should be the expected output according to you?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "## Explanation:\\nThis task is easy for those who understand it as it is given in the question. However, for those who may initially think it is a task involving matrix transposition, it may be confusing at first. Therefore, for anyone who initially thought this was a matrix transpose task like I did, let me clarify: it is not. Simply read the question again.\\n\\nNow that we are clear on the question:\\n\\n- Imagine the given matrix as a set of cubicles. We are moving to a new office and the room has a different length and width, so we need to adjust the positions of the cubicles to fit them in the new office.\\n- However, what if the area of the new office is different from that of the old office? If it is smaller, we cannot fit all the cubicles. If it is larger, we cannot fill the space properly. In this case, we will not move to the new office.\\n- On the other hand, if the new office has the same area as the old one, we need to disassemble the cubicles and fit them in a truck for transport.\\n- Maintaining the order and position of the cubicles, we will disassemble them and place them in the truck in order.\\n- We will then unload the cubicles one by one, maintaining the first-in-first-out order and placing them in the new office according to its new dimensions.\\n- This way, we can fit all the cubicles in order from the old office to the new office, as long as the new office has the same area as the old one."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal Matrix Problem. Just make sure to add the base condition of returning the original(given) matrix if the given matrix\\'s dimensions doesn\\'t match the rehaped matrix\\'s dimensions"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When will people understand, to NOT post solutions here?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "In this [example](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg), `c` should be 2 not `4` Am I wrong?"
                    },
                    {
                        "username": "lcmpbll",
                        "content": "This is an example of what you should return if the reshape is not possible:\\n\\nIf the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\\n\\n"
                    },
                    {
                        "username": "mnmlyn",
                        "content": "why it is\"int** columnSizes\",not \"int* columnSizes\"?\\nand then\\ncolumnSizes = (int *)malloc(sizeof(int)*r);"
                    },
                    {
                        "username": "tarun22",
                        "content": "It would be great if you can put a minor comment on the Testcase 2 , that it returned the original matrix as the are does not match. That would reduce confusion."
                    },
                    {
                        "username": "AlisherRMA",
                        "content": "there is incorrect testcase(\\u211654)\\nmat = [[1,2]]\\nr = 1\\nc = 1\\nexpected result: [[1, 2]]\\nit should be just [[1]]"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Check for the base case.. If the given matrix\\'s dimensions doesn\\'t match the to be reshaped to matrix\\'s dimensions, we return the given matrix. That\\'s y for the above test case the result is [[1,2]]"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Logic, yet efficient , Beats 100% in Runtime & 99.10% in Memory, with Detailed Explantion: `\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3877156/simple-iterative-approach-beats-100-detailed-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "balls."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "penis."
                    }
                ]
            },
            {
                "id": 2004399,
                "content": [
                    {
                        "username": "mnithish850",
                        "content": "there is mistake in testcase\\ngiven mat\\n[[1,2],[3,4]]\\n give r=2, c=4\\nbut it is expecting answer as  [[1,2],[3,4]]\\nwhich is wrong"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think it\\'s correct as r*c is != m*n that is no. of elements are not same so we return the orignal matrix"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "Test case is right, in this case you have to return the original array because to dimension (size) mismatch."
                    },
                    {
                        "username": "123004048",
                        "content": "[@tenplus_086](/tenplus_086)  im getting [[1,2,3,4]] as the output"
                    },
                    {
                        "username": "kavignaani8203",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks. felt the same doubt that testcase is wrong. With your provided explanation , got it right"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@tenplus_086](/tenplus_086)  Yeah in case of dimension mismatch, we should return original matrix.. It cant be reshaped"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "No that test case is true\n because the given matrix is 2-2 means there are 4 element and we have to form new matrix of size 2-4 which has 8 element \nthen how you fill the 4 element in the 8 indexes matrix  "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I think its correct..What should be the expected output according to you?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "## Explanation:\\nThis task is easy for those who understand it as it is given in the question. However, for those who may initially think it is a task involving matrix transposition, it may be confusing at first. Therefore, for anyone who initially thought this was a matrix transpose task like I did, let me clarify: it is not. Simply read the question again.\\n\\nNow that we are clear on the question:\\n\\n- Imagine the given matrix as a set of cubicles. We are moving to a new office and the room has a different length and width, so we need to adjust the positions of the cubicles to fit them in the new office.\\n- However, what if the area of the new office is different from that of the old office? If it is smaller, we cannot fit all the cubicles. If it is larger, we cannot fill the space properly. In this case, we will not move to the new office.\\n- On the other hand, if the new office has the same area as the old one, we need to disassemble the cubicles and fit them in a truck for transport.\\n- Maintaining the order and position of the cubicles, we will disassemble them and place them in the truck in order.\\n- We will then unload the cubicles one by one, maintaining the first-in-first-out order and placing them in the new office according to its new dimensions.\\n- This way, we can fit all the cubicles in order from the old office to the new office, as long as the new office has the same area as the old one."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal Matrix Problem. Just make sure to add the base condition of returning the original(given) matrix if the given matrix\\'s dimensions doesn\\'t match the rehaped matrix\\'s dimensions"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When will people understand, to NOT post solutions here?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "In this [example](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg), `c` should be 2 not `4` Am I wrong?"
                    },
                    {
                        "username": "lcmpbll",
                        "content": "This is an example of what you should return if the reshape is not possible:\\n\\nIf the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\\n\\n"
                    },
                    {
                        "username": "mnmlyn",
                        "content": "why it is\"int** columnSizes\",not \"int* columnSizes\"?\\nand then\\ncolumnSizes = (int *)malloc(sizeof(int)*r);"
                    },
                    {
                        "username": "tarun22",
                        "content": "It would be great if you can put a minor comment on the Testcase 2 , that it returned the original matrix as the are does not match. That would reduce confusion."
                    },
                    {
                        "username": "AlisherRMA",
                        "content": "there is incorrect testcase(\\u211654)\\nmat = [[1,2]]\\nr = 1\\nc = 1\\nexpected result: [[1, 2]]\\nit should be just [[1]]"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Check for the base case.. If the given matrix\\'s dimensions doesn\\'t match the to be reshaped to matrix\\'s dimensions, we return the given matrix. That\\'s y for the above test case the result is [[1,2]]"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Logic, yet efficient , Beats 100% in Runtime & 99.10% in Memory, with Detailed Explantion: `\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3877156/simple-iterative-approach-beats-100-detailed-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "balls."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "penis."
                    }
                ]
            },
            {
                "id": 1977037,
                "content": [
                    {
                        "username": "mnithish850",
                        "content": "there is mistake in testcase\\ngiven mat\\n[[1,2],[3,4]]\\n give r=2, c=4\\nbut it is expecting answer as  [[1,2],[3,4]]\\nwhich is wrong"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think it\\'s correct as r*c is != m*n that is no. of elements are not same so we return the orignal matrix"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "Test case is right, in this case you have to return the original array because to dimension (size) mismatch."
                    },
                    {
                        "username": "123004048",
                        "content": "[@tenplus_086](/tenplus_086)  im getting [[1,2,3,4]] as the output"
                    },
                    {
                        "username": "kavignaani8203",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks. felt the same doubt that testcase is wrong. With your provided explanation , got it right"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@tenplus_086](/tenplus_086)  Yeah in case of dimension mismatch, we should return original matrix.. It cant be reshaped"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "No that test case is true\n because the given matrix is 2-2 means there are 4 element and we have to form new matrix of size 2-4 which has 8 element \nthen how you fill the 4 element in the 8 indexes matrix  "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I think its correct..What should be the expected output according to you?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "## Explanation:\\nThis task is easy for those who understand it as it is given in the question. However, for those who may initially think it is a task involving matrix transposition, it may be confusing at first. Therefore, for anyone who initially thought this was a matrix transpose task like I did, let me clarify: it is not. Simply read the question again.\\n\\nNow that we are clear on the question:\\n\\n- Imagine the given matrix as a set of cubicles. We are moving to a new office and the room has a different length and width, so we need to adjust the positions of the cubicles to fit them in the new office.\\n- However, what if the area of the new office is different from that of the old office? If it is smaller, we cannot fit all the cubicles. If it is larger, we cannot fill the space properly. In this case, we will not move to the new office.\\n- On the other hand, if the new office has the same area as the old one, we need to disassemble the cubicles and fit them in a truck for transport.\\n- Maintaining the order and position of the cubicles, we will disassemble them and place them in the truck in order.\\n- We will then unload the cubicles one by one, maintaining the first-in-first-out order and placing them in the new office according to its new dimensions.\\n- This way, we can fit all the cubicles in order from the old office to the new office, as long as the new office has the same area as the old one."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal Matrix Problem. Just make sure to add the base condition of returning the original(given) matrix if the given matrix\\'s dimensions doesn\\'t match the rehaped matrix\\'s dimensions"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "When will people understand, to NOT post solutions here?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "In this [example](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg), `c` should be 2 not `4` Am I wrong?"
                    },
                    {
                        "username": "lcmpbll",
                        "content": "This is an example of what you should return if the reshape is not possible:\\n\\nIf the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\\n\\n"
                    },
                    {
                        "username": "mnmlyn",
                        "content": "why it is\"int** columnSizes\",not \"int* columnSizes\"?\\nand then\\ncolumnSizes = (int *)malloc(sizeof(int)*r);"
                    },
                    {
                        "username": "tarun22",
                        "content": "It would be great if you can put a minor comment on the Testcase 2 , that it returned the original matrix as the are does not match. That would reduce confusion."
                    },
                    {
                        "username": "AlisherRMA",
                        "content": "there is incorrect testcase(\\u211654)\\nmat = [[1,2]]\\nr = 1\\nc = 1\\nexpected result: [[1, 2]]\\nit should be just [[1]]"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Check for the base case.. If the given matrix\\'s dimensions doesn\\'t match the to be reshaped to matrix\\'s dimensions, we return the given matrix. That\\'s y for the above test case the result is [[1,2]]"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Logic, yet efficient , Beats 100% in Runtime & 99.10% in Memory, with Detailed Explantion: `\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3877156/simple-iterative-approach-beats-100-detailed-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "balls."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "penis."
                    }
                ]
            },
            {
                "id": 1967742,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "I found this pretty tricky for an easy problem... I guess I just don't like matrix problems lol"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "c/column input is confusing in example true . "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3007582/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "ah yes, another exercise in reading the instructions carefully."
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "Can anyone tell me how example 2 is working?? I think it may be wrong."
                    },
                    {
                        "username": "distructfruct",
                        "content": "The size of the new matrix MUST be the same as the original matrix. If false, return the original matrix. The second example should be more clear."
                    },
                    {
                        "username": "ANKIT_1008",
                        "content": "There is a mistake in Test case 2."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "I passed test-1 and test-2 but I got this error : `TypeError: Cannot set properties of undefined (setting \\'0\\')` in other tests? Help\\n\\n## Code\\n```javascript\\n\\n/**\\n * @param {number[][]} mat\\n * @param {number} r\\n * @param {number} c\\n * @return {number[][]}\\n */\\nvar matrixReshape = function (mat, r, c) {\\n\\n    let m = mat.length;\\n    let n = mat[0].length;\\n    let arr = [[]];\\n    if (n * m !== r * c) return mat;\\n    for (let index = 0; index < m * n; index++) {\\n        arr[Math.floor(index / c)][index % c] =\\n            mat[Math.floor(index / m)][index % m];\\n    }\\n    return arr;\\n\\n};\\n```\\n## Error:\\n`\\nLine 14 in solution.js\\n        arr[Math.floor(index / c)][index % c] =\\n                                              ^\\nTypeError: Cannot set properties of undefined (setting \\'0\\')\\n    Line 14: Char 47 in solution.js (matrixReshape)\\n    Line 33: Char 19 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 20: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47\\n`\\n"
                    },
                    {
                        "username": "sreejadevisetti",
                        "content": "int** matrixReshape(int** mat,int matSize,int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes){\\n    if (matSize * *(matColSize) != r * c)\\n        return mat;\\n    \\n    *returnSize = r;\\n    int arr[matSize * *(matColSize)], matrix[r][c], i, j;\\n    for (i = 0; i < matSize; i++)\\n    {\\n        for (j = 0; j < *matColSize; j++)\\n            arr[*(matColSize) * i + j] = mat[i][j];\\n    }\\n\\n    *returnColumnSizes = (int*) malloc(c * sizeof(int));\\n    for (i = 0; i < r; i++)\\n    {\\n        for (j = 0; j < c; j++)\\n            matrix[i][j] = arr[c * i + j];\\n        *returnColumnSizes[i] = c;\\n    }\\n    return matrix;\\n}\\n\\nI am getting run-time error for the above, Can anyone please spot the mistakes?"
                    },
                    {
                        "username": "psionl0",
                        "content": "One error is the failure to set the returnColumSizes and returnSize (matcolSize and matSize respectively) if the base case fails. This can cause seg faults."
                    },
                    {
                        "username": "garabed99",
                        "content": "[JS] Trying to figure out how to turn 1D to 2D using the **Hint** (M[i] => M[i/n][i%n]) but not quite sure how to implement it, tried a lot but nothing worked"
                    }
                ]
            },
            {
                "id": 1854225,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "I found this pretty tricky for an easy problem... I guess I just don't like matrix problems lol"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "c/column input is confusing in example true . "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3007582/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "ah yes, another exercise in reading the instructions carefully."
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "Can anyone tell me how example 2 is working?? I think it may be wrong."
                    },
                    {
                        "username": "distructfruct",
                        "content": "The size of the new matrix MUST be the same as the original matrix. If false, return the original matrix. The second example should be more clear."
                    },
                    {
                        "username": "ANKIT_1008",
                        "content": "There is a mistake in Test case 2."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "I passed test-1 and test-2 but I got this error : `TypeError: Cannot set properties of undefined (setting \\'0\\')` in other tests? Help\\n\\n## Code\\n```javascript\\n\\n/**\\n * @param {number[][]} mat\\n * @param {number} r\\n * @param {number} c\\n * @return {number[][]}\\n */\\nvar matrixReshape = function (mat, r, c) {\\n\\n    let m = mat.length;\\n    let n = mat[0].length;\\n    let arr = [[]];\\n    if (n * m !== r * c) return mat;\\n    for (let index = 0; index < m * n; index++) {\\n        arr[Math.floor(index / c)][index % c] =\\n            mat[Math.floor(index / m)][index % m];\\n    }\\n    return arr;\\n\\n};\\n```\\n## Error:\\n`\\nLine 14 in solution.js\\n        arr[Math.floor(index / c)][index % c] =\\n                                              ^\\nTypeError: Cannot set properties of undefined (setting \\'0\\')\\n    Line 14: Char 47 in solution.js (matrixReshape)\\n    Line 33: Char 19 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 20: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47\\n`\\n"
                    },
                    {
                        "username": "sreejadevisetti",
                        "content": "int** matrixReshape(int** mat,int matSize,int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes){\\n    if (matSize * *(matColSize) != r * c)\\n        return mat;\\n    \\n    *returnSize = r;\\n    int arr[matSize * *(matColSize)], matrix[r][c], i, j;\\n    for (i = 0; i < matSize; i++)\\n    {\\n        for (j = 0; j < *matColSize; j++)\\n            arr[*(matColSize) * i + j] = mat[i][j];\\n    }\\n\\n    *returnColumnSizes = (int*) malloc(c * sizeof(int));\\n    for (i = 0; i < r; i++)\\n    {\\n        for (j = 0; j < c; j++)\\n            matrix[i][j] = arr[c * i + j];\\n        *returnColumnSizes[i] = c;\\n    }\\n    return matrix;\\n}\\n\\nI am getting run-time error for the above, Can anyone please spot the mistakes?"
                    },
                    {
                        "username": "psionl0",
                        "content": "One error is the failure to set the returnColumSizes and returnSize (matcolSize and matSize respectively) if the base case fails. This can cause seg faults."
                    },
                    {
                        "username": "garabed99",
                        "content": "[JS] Trying to figure out how to turn 1D to 2D using the **Hint** (M[i] => M[i/n][i%n]) but not quite sure how to implement it, tried a lot but nothing worked"
                    }
                ]
            },
            {
                "id": 1744523,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "I found this pretty tricky for an easy problem... I guess I just don't like matrix problems lol"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "c/column input is confusing in example true . "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3007582/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "ah yes, another exercise in reading the instructions carefully."
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "Can anyone tell me how example 2 is working?? I think it may be wrong."
                    },
                    {
                        "username": "distructfruct",
                        "content": "The size of the new matrix MUST be the same as the original matrix. If false, return the original matrix. The second example should be more clear."
                    },
                    {
                        "username": "ANKIT_1008",
                        "content": "There is a mistake in Test case 2."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "I passed test-1 and test-2 but I got this error : `TypeError: Cannot set properties of undefined (setting \\'0\\')` in other tests? Help\\n\\n## Code\\n```javascript\\n\\n/**\\n * @param {number[][]} mat\\n * @param {number} r\\n * @param {number} c\\n * @return {number[][]}\\n */\\nvar matrixReshape = function (mat, r, c) {\\n\\n    let m = mat.length;\\n    let n = mat[0].length;\\n    let arr = [[]];\\n    if (n * m !== r * c) return mat;\\n    for (let index = 0; index < m * n; index++) {\\n        arr[Math.floor(index / c)][index % c] =\\n            mat[Math.floor(index / m)][index % m];\\n    }\\n    return arr;\\n\\n};\\n```\\n## Error:\\n`\\nLine 14 in solution.js\\n        arr[Math.floor(index / c)][index % c] =\\n                                              ^\\nTypeError: Cannot set properties of undefined (setting \\'0\\')\\n    Line 14: Char 47 in solution.js (matrixReshape)\\n    Line 33: Char 19 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 20: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47\\n`\\n"
                    },
                    {
                        "username": "sreejadevisetti",
                        "content": "int** matrixReshape(int** mat,int matSize,int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes){\\n    if (matSize * *(matColSize) != r * c)\\n        return mat;\\n    \\n    *returnSize = r;\\n    int arr[matSize * *(matColSize)], matrix[r][c], i, j;\\n    for (i = 0; i < matSize; i++)\\n    {\\n        for (j = 0; j < *matColSize; j++)\\n            arr[*(matColSize) * i + j] = mat[i][j];\\n    }\\n\\n    *returnColumnSizes = (int*) malloc(c * sizeof(int));\\n    for (i = 0; i < r; i++)\\n    {\\n        for (j = 0; j < c; j++)\\n            matrix[i][j] = arr[c * i + j];\\n        *returnColumnSizes[i] = c;\\n    }\\n    return matrix;\\n}\\n\\nI am getting run-time error for the above, Can anyone please spot the mistakes?"
                    },
                    {
                        "username": "psionl0",
                        "content": "One error is the failure to set the returnColumSizes and returnSize (matcolSize and matSize respectively) if the base case fails. This can cause seg faults."
                    },
                    {
                        "username": "garabed99",
                        "content": "[JS] Trying to figure out how to turn 1D to 2D using the **Hint** (M[i] => M[i/n][i%n]) but not quite sure how to implement it, tried a lot but nothing worked"
                    }
                ]
            },
            {
                "id": 1999360,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "I found this pretty tricky for an easy problem... I guess I just don't like matrix problems lol"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "c/column input is confusing in example true . "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3007582/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "ah yes, another exercise in reading the instructions carefully."
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "Can anyone tell me how example 2 is working?? I think it may be wrong."
                    },
                    {
                        "username": "distructfruct",
                        "content": "The size of the new matrix MUST be the same as the original matrix. If false, return the original matrix. The second example should be more clear."
                    },
                    {
                        "username": "ANKIT_1008",
                        "content": "There is a mistake in Test case 2."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "I passed test-1 and test-2 but I got this error : `TypeError: Cannot set properties of undefined (setting \\'0\\')` in other tests? Help\\n\\n## Code\\n```javascript\\n\\n/**\\n * @param {number[][]} mat\\n * @param {number} r\\n * @param {number} c\\n * @return {number[][]}\\n */\\nvar matrixReshape = function (mat, r, c) {\\n\\n    let m = mat.length;\\n    let n = mat[0].length;\\n    let arr = [[]];\\n    if (n * m !== r * c) return mat;\\n    for (let index = 0; index < m * n; index++) {\\n        arr[Math.floor(index / c)][index % c] =\\n            mat[Math.floor(index / m)][index % m];\\n    }\\n    return arr;\\n\\n};\\n```\\n## Error:\\n`\\nLine 14 in solution.js\\n        arr[Math.floor(index / c)][index % c] =\\n                                              ^\\nTypeError: Cannot set properties of undefined (setting \\'0\\')\\n    Line 14: Char 47 in solution.js (matrixReshape)\\n    Line 33: Char 19 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 20: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47\\n`\\n"
                    },
                    {
                        "username": "sreejadevisetti",
                        "content": "int** matrixReshape(int** mat,int matSize,int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes){\\n    if (matSize * *(matColSize) != r * c)\\n        return mat;\\n    \\n    *returnSize = r;\\n    int arr[matSize * *(matColSize)], matrix[r][c], i, j;\\n    for (i = 0; i < matSize; i++)\\n    {\\n        for (j = 0; j < *matColSize; j++)\\n            arr[*(matColSize) * i + j] = mat[i][j];\\n    }\\n\\n    *returnColumnSizes = (int*) malloc(c * sizeof(int));\\n    for (i = 0; i < r; i++)\\n    {\\n        for (j = 0; j < c; j++)\\n            matrix[i][j] = arr[c * i + j];\\n        *returnColumnSizes[i] = c;\\n    }\\n    return matrix;\\n}\\n\\nI am getting run-time error for the above, Can anyone please spot the mistakes?"
                    },
                    {
                        "username": "psionl0",
                        "content": "One error is the failure to set the returnColumSizes and returnSize (matcolSize and matSize respectively) if the base case fails. This can cause seg faults."
                    },
                    {
                        "username": "garabed99",
                        "content": "[JS] Trying to figure out how to turn 1D to 2D using the **Hint** (M[i] => M[i/n][i%n]) but not quite sure how to implement it, tried a lot but nothing worked"
                    }
                ]
            },
            {
                "id": 1975124,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "I found this pretty tricky for an easy problem... I guess I just don't like matrix problems lol"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "c/column input is confusing in example true . "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3007582/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "ah yes, another exercise in reading the instructions carefully."
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "Can anyone tell me how example 2 is working?? I think it may be wrong."
                    },
                    {
                        "username": "distructfruct",
                        "content": "The size of the new matrix MUST be the same as the original matrix. If false, return the original matrix. The second example should be more clear."
                    },
                    {
                        "username": "ANKIT_1008",
                        "content": "There is a mistake in Test case 2."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "I passed test-1 and test-2 but I got this error : `TypeError: Cannot set properties of undefined (setting \\'0\\')` in other tests? Help\\n\\n## Code\\n```javascript\\n\\n/**\\n * @param {number[][]} mat\\n * @param {number} r\\n * @param {number} c\\n * @return {number[][]}\\n */\\nvar matrixReshape = function (mat, r, c) {\\n\\n    let m = mat.length;\\n    let n = mat[0].length;\\n    let arr = [[]];\\n    if (n * m !== r * c) return mat;\\n    for (let index = 0; index < m * n; index++) {\\n        arr[Math.floor(index / c)][index % c] =\\n            mat[Math.floor(index / m)][index % m];\\n    }\\n    return arr;\\n\\n};\\n```\\n## Error:\\n`\\nLine 14 in solution.js\\n        arr[Math.floor(index / c)][index % c] =\\n                                              ^\\nTypeError: Cannot set properties of undefined (setting \\'0\\')\\n    Line 14: Char 47 in solution.js (matrixReshape)\\n    Line 33: Char 19 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 20: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47\\n`\\n"
                    },
                    {
                        "username": "sreejadevisetti",
                        "content": "int** matrixReshape(int** mat,int matSize,int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes){\\n    if (matSize * *(matColSize) != r * c)\\n        return mat;\\n    \\n    *returnSize = r;\\n    int arr[matSize * *(matColSize)], matrix[r][c], i, j;\\n    for (i = 0; i < matSize; i++)\\n    {\\n        for (j = 0; j < *matColSize; j++)\\n            arr[*(matColSize) * i + j] = mat[i][j];\\n    }\\n\\n    *returnColumnSizes = (int*) malloc(c * sizeof(int));\\n    for (i = 0; i < r; i++)\\n    {\\n        for (j = 0; j < c; j++)\\n            matrix[i][j] = arr[c * i + j];\\n        *returnColumnSizes[i] = c;\\n    }\\n    return matrix;\\n}\\n\\nI am getting run-time error for the above, Can anyone please spot the mistakes?"
                    },
                    {
                        "username": "psionl0",
                        "content": "One error is the failure to set the returnColumSizes and returnSize (matcolSize and matSize respectively) if the base case fails. This can cause seg faults."
                    },
                    {
                        "username": "garabed99",
                        "content": "[JS] Trying to figure out how to turn 1D to 2D using the **Hint** (M[i] => M[i/n][i%n]) but not quite sure how to implement it, tried a lot but nothing worked"
                    }
                ]
            },
            {
                "id": 1971735,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "I found this pretty tricky for an easy problem... I guess I just don't like matrix problems lol"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "c/column input is confusing in example true . "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3007582/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "ah yes, another exercise in reading the instructions carefully."
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "Can anyone tell me how example 2 is working?? I think it may be wrong."
                    },
                    {
                        "username": "distructfruct",
                        "content": "The size of the new matrix MUST be the same as the original matrix. If false, return the original matrix. The second example should be more clear."
                    },
                    {
                        "username": "ANKIT_1008",
                        "content": "There is a mistake in Test case 2."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "I passed test-1 and test-2 but I got this error : `TypeError: Cannot set properties of undefined (setting \\'0\\')` in other tests? Help\\n\\n## Code\\n```javascript\\n\\n/**\\n * @param {number[][]} mat\\n * @param {number} r\\n * @param {number} c\\n * @return {number[][]}\\n */\\nvar matrixReshape = function (mat, r, c) {\\n\\n    let m = mat.length;\\n    let n = mat[0].length;\\n    let arr = [[]];\\n    if (n * m !== r * c) return mat;\\n    for (let index = 0; index < m * n; index++) {\\n        arr[Math.floor(index / c)][index % c] =\\n            mat[Math.floor(index / m)][index % m];\\n    }\\n    return arr;\\n\\n};\\n```\\n## Error:\\n`\\nLine 14 in solution.js\\n        arr[Math.floor(index / c)][index % c] =\\n                                              ^\\nTypeError: Cannot set properties of undefined (setting \\'0\\')\\n    Line 14: Char 47 in solution.js (matrixReshape)\\n    Line 33: Char 19 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 20: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47\\n`\\n"
                    },
                    {
                        "username": "sreejadevisetti",
                        "content": "int** matrixReshape(int** mat,int matSize,int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes){\\n    if (matSize * *(matColSize) != r * c)\\n        return mat;\\n    \\n    *returnSize = r;\\n    int arr[matSize * *(matColSize)], matrix[r][c], i, j;\\n    for (i = 0; i < matSize; i++)\\n    {\\n        for (j = 0; j < *matColSize; j++)\\n            arr[*(matColSize) * i + j] = mat[i][j];\\n    }\\n\\n    *returnColumnSizes = (int*) malloc(c * sizeof(int));\\n    for (i = 0; i < r; i++)\\n    {\\n        for (j = 0; j < c; j++)\\n            matrix[i][j] = arr[c * i + j];\\n        *returnColumnSizes[i] = c;\\n    }\\n    return matrix;\\n}\\n\\nI am getting run-time error for the above, Can anyone please spot the mistakes?"
                    },
                    {
                        "username": "psionl0",
                        "content": "One error is the failure to set the returnColumSizes and returnSize (matcolSize and matSize respectively) if the base case fails. This can cause seg faults."
                    },
                    {
                        "username": "garabed99",
                        "content": "[JS] Trying to figure out how to turn 1D to 2D using the **Hint** (M[i] => M[i/n][i%n]) but not quite sure how to implement it, tried a lot but nothing worked"
                    }
                ]
            },
            {
                "id": 1921130,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "I found this pretty tricky for an easy problem... I guess I just don't like matrix problems lol"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "c/column input is confusing in example true . "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3007582/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "ah yes, another exercise in reading the instructions carefully."
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "Can anyone tell me how example 2 is working?? I think it may be wrong."
                    },
                    {
                        "username": "distructfruct",
                        "content": "The size of the new matrix MUST be the same as the original matrix. If false, return the original matrix. The second example should be more clear."
                    },
                    {
                        "username": "ANKIT_1008",
                        "content": "There is a mistake in Test case 2."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "I passed test-1 and test-2 but I got this error : `TypeError: Cannot set properties of undefined (setting \\'0\\')` in other tests? Help\\n\\n## Code\\n```javascript\\n\\n/**\\n * @param {number[][]} mat\\n * @param {number} r\\n * @param {number} c\\n * @return {number[][]}\\n */\\nvar matrixReshape = function (mat, r, c) {\\n\\n    let m = mat.length;\\n    let n = mat[0].length;\\n    let arr = [[]];\\n    if (n * m !== r * c) return mat;\\n    for (let index = 0; index < m * n; index++) {\\n        arr[Math.floor(index / c)][index % c] =\\n            mat[Math.floor(index / m)][index % m];\\n    }\\n    return arr;\\n\\n};\\n```\\n## Error:\\n`\\nLine 14 in solution.js\\n        arr[Math.floor(index / c)][index % c] =\\n                                              ^\\nTypeError: Cannot set properties of undefined (setting \\'0\\')\\n    Line 14: Char 47 in solution.js (matrixReshape)\\n    Line 33: Char 19 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 20: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47\\n`\\n"
                    },
                    {
                        "username": "sreejadevisetti",
                        "content": "int** matrixReshape(int** mat,int matSize,int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes){\\n    if (matSize * *(matColSize) != r * c)\\n        return mat;\\n    \\n    *returnSize = r;\\n    int arr[matSize * *(matColSize)], matrix[r][c], i, j;\\n    for (i = 0; i < matSize; i++)\\n    {\\n        for (j = 0; j < *matColSize; j++)\\n            arr[*(matColSize) * i + j] = mat[i][j];\\n    }\\n\\n    *returnColumnSizes = (int*) malloc(c * sizeof(int));\\n    for (i = 0; i < r; i++)\\n    {\\n        for (j = 0; j < c; j++)\\n            matrix[i][j] = arr[c * i + j];\\n        *returnColumnSizes[i] = c;\\n    }\\n    return matrix;\\n}\\n\\nI am getting run-time error for the above, Can anyone please spot the mistakes?"
                    },
                    {
                        "username": "psionl0",
                        "content": "One error is the failure to set the returnColumSizes and returnSize (matcolSize and matSize respectively) if the base case fails. This can cause seg faults."
                    },
                    {
                        "username": "garabed99",
                        "content": "[JS] Trying to figure out how to turn 1D to 2D using the **Hint** (M[i] => M[i/n][i%n]) but not quite sure how to implement it, tried a lot but nothing worked"
                    }
                ]
            },
            {
                "id": 1819775,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "I found this pretty tricky for an easy problem... I guess I just don't like matrix problems lol"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "c/column input is confusing in example true . "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3007582/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "ah yes, another exercise in reading the instructions carefully."
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "Can anyone tell me how example 2 is working?? I think it may be wrong."
                    },
                    {
                        "username": "distructfruct",
                        "content": "The size of the new matrix MUST be the same as the original matrix. If false, return the original matrix. The second example should be more clear."
                    },
                    {
                        "username": "ANKIT_1008",
                        "content": "There is a mistake in Test case 2."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "I passed test-1 and test-2 but I got this error : `TypeError: Cannot set properties of undefined (setting \\'0\\')` in other tests? Help\\n\\n## Code\\n```javascript\\n\\n/**\\n * @param {number[][]} mat\\n * @param {number} r\\n * @param {number} c\\n * @return {number[][]}\\n */\\nvar matrixReshape = function (mat, r, c) {\\n\\n    let m = mat.length;\\n    let n = mat[0].length;\\n    let arr = [[]];\\n    if (n * m !== r * c) return mat;\\n    for (let index = 0; index < m * n; index++) {\\n        arr[Math.floor(index / c)][index % c] =\\n            mat[Math.floor(index / m)][index % m];\\n    }\\n    return arr;\\n\\n};\\n```\\n## Error:\\n`\\nLine 14 in solution.js\\n        arr[Math.floor(index / c)][index % c] =\\n                                              ^\\nTypeError: Cannot set properties of undefined (setting \\'0\\')\\n    Line 14: Char 47 in solution.js (matrixReshape)\\n    Line 33: Char 19 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 20: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47\\n`\\n"
                    },
                    {
                        "username": "sreejadevisetti",
                        "content": "int** matrixReshape(int** mat,int matSize,int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes){\\n    if (matSize * *(matColSize) != r * c)\\n        return mat;\\n    \\n    *returnSize = r;\\n    int arr[matSize * *(matColSize)], matrix[r][c], i, j;\\n    for (i = 0; i < matSize; i++)\\n    {\\n        for (j = 0; j < *matColSize; j++)\\n            arr[*(matColSize) * i + j] = mat[i][j];\\n    }\\n\\n    *returnColumnSizes = (int*) malloc(c * sizeof(int));\\n    for (i = 0; i < r; i++)\\n    {\\n        for (j = 0; j < c; j++)\\n            matrix[i][j] = arr[c * i + j];\\n        *returnColumnSizes[i] = c;\\n    }\\n    return matrix;\\n}\\n\\nI am getting run-time error for the above, Can anyone please spot the mistakes?"
                    },
                    {
                        "username": "psionl0",
                        "content": "One error is the failure to set the returnColumSizes and returnSize (matcolSize and matSize respectively) if the base case fails. This can cause seg faults."
                    },
                    {
                        "username": "garabed99",
                        "content": "[JS] Trying to figure out how to turn 1D to 2D using the **Hint** (M[i] => M[i/n][i%n]) but not quite sure how to implement it, tried a lot but nothing worked"
                    }
                ]
            },
            {
                "id": 1797814,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "I found this pretty tricky for an easy problem... I guess I just don't like matrix problems lol"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "c/column input is confusing in example true . "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3007582/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "ah yes, another exercise in reading the instructions carefully."
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "Can anyone tell me how example 2 is working?? I think it may be wrong."
                    },
                    {
                        "username": "distructfruct",
                        "content": "The size of the new matrix MUST be the same as the original matrix. If false, return the original matrix. The second example should be more clear."
                    },
                    {
                        "username": "ANKIT_1008",
                        "content": "There is a mistake in Test case 2."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "I passed test-1 and test-2 but I got this error : `TypeError: Cannot set properties of undefined (setting \\'0\\')` in other tests? Help\\n\\n## Code\\n```javascript\\n\\n/**\\n * @param {number[][]} mat\\n * @param {number} r\\n * @param {number} c\\n * @return {number[][]}\\n */\\nvar matrixReshape = function (mat, r, c) {\\n\\n    let m = mat.length;\\n    let n = mat[0].length;\\n    let arr = [[]];\\n    if (n * m !== r * c) return mat;\\n    for (let index = 0; index < m * n; index++) {\\n        arr[Math.floor(index / c)][index % c] =\\n            mat[Math.floor(index / m)][index % m];\\n    }\\n    return arr;\\n\\n};\\n```\\n## Error:\\n`\\nLine 14 in solution.js\\n        arr[Math.floor(index / c)][index % c] =\\n                                              ^\\nTypeError: Cannot set properties of undefined (setting \\'0\\')\\n    Line 14: Char 47 in solution.js (matrixReshape)\\n    Line 33: Char 19 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 20: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47\\n`\\n"
                    },
                    {
                        "username": "sreejadevisetti",
                        "content": "int** matrixReshape(int** mat,int matSize,int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes){\\n    if (matSize * *(matColSize) != r * c)\\n        return mat;\\n    \\n    *returnSize = r;\\n    int arr[matSize * *(matColSize)], matrix[r][c], i, j;\\n    for (i = 0; i < matSize; i++)\\n    {\\n        for (j = 0; j < *matColSize; j++)\\n            arr[*(matColSize) * i + j] = mat[i][j];\\n    }\\n\\n    *returnColumnSizes = (int*) malloc(c * sizeof(int));\\n    for (i = 0; i < r; i++)\\n    {\\n        for (j = 0; j < c; j++)\\n            matrix[i][j] = arr[c * i + j];\\n        *returnColumnSizes[i] = c;\\n    }\\n    return matrix;\\n}\\n\\nI am getting run-time error for the above, Can anyone please spot the mistakes?"
                    },
                    {
                        "username": "psionl0",
                        "content": "One error is the failure to set the returnColumSizes and returnSize (matcolSize and matSize respectively) if the base case fails. This can cause seg faults."
                    },
                    {
                        "username": "garabed99",
                        "content": "[JS] Trying to figure out how to turn 1D to 2D using the **Hint** (M[i] => M[i/n][i%n]) but not quite sure how to implement it, tried a lot but nothing worked"
                    }
                ]
            },
            {
                "id": 1797062,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "I found this pretty tricky for an easy problem... I guess I just don't like matrix problems lol"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "c/column input is confusing in example true . "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/reshape-the-matrix/solutions/3007582/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "ah yes, another exercise in reading the instructions carefully."
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "Can anyone tell me how example 2 is working?? I think it may be wrong."
                    },
                    {
                        "username": "distructfruct",
                        "content": "The size of the new matrix MUST be the same as the original matrix. If false, return the original matrix. The second example should be more clear."
                    },
                    {
                        "username": "ANKIT_1008",
                        "content": "There is a mistake in Test case 2."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "I passed test-1 and test-2 but I got this error : `TypeError: Cannot set properties of undefined (setting \\'0\\')` in other tests? Help\\n\\n## Code\\n```javascript\\n\\n/**\\n * @param {number[][]} mat\\n * @param {number} r\\n * @param {number} c\\n * @return {number[][]}\\n */\\nvar matrixReshape = function (mat, r, c) {\\n\\n    let m = mat.length;\\n    let n = mat[0].length;\\n    let arr = [[]];\\n    if (n * m !== r * c) return mat;\\n    for (let index = 0; index < m * n; index++) {\\n        arr[Math.floor(index / c)][index % c] =\\n            mat[Math.floor(index / m)][index % m];\\n    }\\n    return arr;\\n\\n};\\n```\\n## Error:\\n`\\nLine 14 in solution.js\\n        arr[Math.floor(index / c)][index % c] =\\n                                              ^\\nTypeError: Cannot set properties of undefined (setting \\'0\\')\\n    Line 14: Char 47 in solution.js (matrixReshape)\\n    Line 33: Char 19 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 20: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47\\n`\\n"
                    },
                    {
                        "username": "sreejadevisetti",
                        "content": "int** matrixReshape(int** mat,int matSize,int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes){\\n    if (matSize * *(matColSize) != r * c)\\n        return mat;\\n    \\n    *returnSize = r;\\n    int arr[matSize * *(matColSize)], matrix[r][c], i, j;\\n    for (i = 0; i < matSize; i++)\\n    {\\n        for (j = 0; j < *matColSize; j++)\\n            arr[*(matColSize) * i + j] = mat[i][j];\\n    }\\n\\n    *returnColumnSizes = (int*) malloc(c * sizeof(int));\\n    for (i = 0; i < r; i++)\\n    {\\n        for (j = 0; j < c; j++)\\n            matrix[i][j] = arr[c * i + j];\\n        *returnColumnSizes[i] = c;\\n    }\\n    return matrix;\\n}\\n\\nI am getting run-time error for the above, Can anyone please spot the mistakes?"
                    },
                    {
                        "username": "psionl0",
                        "content": "One error is the failure to set the returnColumSizes and returnSize (matcolSize and matSize respectively) if the base case fails. This can cause seg faults."
                    },
                    {
                        "username": "garabed99",
                        "content": "[JS] Trying to figure out how to turn 1D to 2D using the **Hint** (M[i] => M[i/n][i%n]) but not quite sure how to implement it, tried a lot but nothing worked"
                    }
                ]
            }
        ]
    },
    {
        "title": "Beautiful Arrangement II",
        "question_content": "<p>Given two integers <code>n</code> and <code>k</code>, construct a list <code>answer</code> that contains <code>n</code> different positive integers ranging from <code>1</code> to <code>n</code> and obeys the following requirement:</p>\n\n<ul>\n\t<li>Suppose this list is <code>answer =&nbsp;[a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, ... , a<sub>n</sub>]</code>, then the list <code>[|a<sub>1</sub> - a<sub>2</sub>|, |a<sub>2</sub> - a<sub>3</sub>|, |a<sub>3</sub> - a<sub>4</sub>|, ... , |a<sub>n-1</sub> - a<sub>n</sub>|]</code> has exactly <code>k</code> distinct integers.</li>\n</ul>\n\n<p>Return <em>the list</em> <code>answer</code>. If there multiple valid answers, return <strong>any of them</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, k = 1\n<strong>Output:</strong> [1,2,3]\nExplanation: The [1,2,3] has three different positive integers ranging from 1 to 3, and the [1,1] has exactly 1 distinct integer: 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, k = 2\n<strong>Output:</strong> [1,3,2]\nExplanation: The [1,3,2] has three different positive integers ranging from 1 to 3, and the [2,1] has exactly 2 distinct integers: 1 and 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt; n &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 106948,
                "title": "c-java-clean-code-4-liner",
                "content": "if you have `n` number, the maximum `k` can be `n - 1`;\\nif `n` is 9, max `k` is 8.\\nThis can be done by picking numbers interleavingly from head and tail, \\n```\\n// start from i = 1, j = n;\\n// i++, j--, i++, j--, i++, j--\\n\\ni: 1   2   3   4   5\\nj:   9   8   7   6\\nout: 1 9 2 8 3 7 4 6 5\\ndif:  8 7 6 5 4 3 2 1\\n```\\nAbove is a case where `k` is exactly `n - 1`\\nWhen k is less than that, simply lay out the rest `(i, j)` in incremental\\n order(all diff is 1). Say if k is 5:\\n```\\n     i++ j-- i++ j--  i++ i++ i++ ...\\nout: 1   9   2   8    3   4   5   6   7\\ndif:   8   7   6   5    1   1   1   1 \\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> res;\\n        for (int i = 1, j = n; i <= j; ) {\\n            if (k > 1) {\\n                res.push_back(k-- % 2 ? i++ : j--);\\n            }\\n            else {\\n                res.push_back(i++);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\n**C++ Compact**\\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> res;\\n        for (int i = 1, j = n; i <= j; )\\n            res.push_back(k > 1 ? (k-- % 2 ? i++ : j--) : i++;\\n        return res;\\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] res = new int[n];\\n        for (int i = 0, l = 1, r = n; l <= r; i++)\\n            res[i] = k > 1 ? (k-- % 2 != 0 ? l++ : r--) : l++;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// start from i = 1, j = n;\\n// i++, j--, i++, j--, i++, j--\\n\\ni: 1   2   3   4   5\\nj:   9   8   7   6\\nout: 1 9 2 8 3 7 4 6 5\\ndif:  8 7 6 5 4 3 2 1\\n```\n```\\n     i++ j-- i++ j--  i++ i++ i++ ...\\nout: 1   9   2   8    3   4   5   6   7\\ndif:   8   7   6   5    1   1   1   1 \\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> res;\\n        for (int i = 1, j = n; i <= j; ) {\\n            if (k > 1) {\\n                res.push_back(k-- % 2 ? i++ : j--);\\n            }\\n            else {\\n                res.push_back(i++);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> res;\\n        for (int i = 1, j = n; i <= j; )\\n            res.push_back(k > 1 ? (k-- % 2 ? i++ : j--) : i++;\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] res = new int[n];\\n        for (int i = 0, l = 1, r = n; l <= r; i++)\\n            res[i] = k > 1 ? (k-- % 2 != 0 ? l++ : r--) : l++;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 166827,
                "title": "java-solution-everyone-else-s-code-is-way-too-convoluted-to-understand",
                "content": "So we know that if we want to have (say n = 6) *<there are multiple sets that work for each, I will only show one or two basic ones>*:\\nk = 1\\n {1, 2, 3, 4, 5, 6} OR {6, 5, 4, 3, 2, 1}.\\n\\nFor k = 2\\n{1, 6, 5, 4, 3, 2} OR {6, 1, 2, 3, 4, 5}.\\n\\nFor k = 3\\n{1, 6, 2, 3, 4, 5} OR {6, 1, 5, 4, 3, 2}.\\n\\nNotice that each time we want to increase k, we reverse the list again and again from list of size n - 1 to n - 2 to n - 3 to.....\\nHence, to have a higher k, we just have to keep reversing the elements on top of each other from index 0 to index k - 1.\\n\\nSo, a naive approach would be O(kn) = O(n^2) since k at worst = n - 1:\\n\\n\\n```\\npublic int[] constructArray(int n, int k) {\\n\\tint[] res = new int[n];\\n\\t\\n\\t// Create initial array of {1, 2, 3, 4, ..., n}\\n\\tfor(int i = 0; i < n; i++)\\n\\t\\tres[i] = i + 1;\\n\\t\\t\\n\\t// Keep reversing each sub-array from index 0 to k - 1\\n\\tfor(int i = 1; i < k; i++)\\n\\t\\treverseList(res, i, n - 1);\\n\\treturn res;\\n}\\n\\n// Reverse sub-array.\\n// You can also use XOR to swap for \"coolness\" since you don\\'t use another variable but it is slower than using the int temp itself\\npublic void reverseList(int[] res, int left, int right){\\n        while(left < right){\\n            int temp = res[left];\\n            res[left] = res[right];\\n            res[right] = temp;\\n            \\n            left++;\\n            right--;\\n        }\\n    }\\n```\\n\\n\\nNow, since we know the pattern, the next thing you might wonder is:\\nCan I do this is O(n)? Can I do this in 1 go since the pattern is simple? After all, I\\'m just reversing every other number until k - 1 times and the rest of the numbers being either incremement of 1 from there or decrement of 1 from there. And yes, yes you can.\\n\\n\\tpublic int[] constructArray(int n, int k) {\\n\\t\\tint[] res = new int[n];\\n\\t\\tint left = 1;\\n\\t\\tint right = n;\\n\\n\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t // If k is even, increment by 1, else decrement by 1 (you can swap this order. Just be consistent)\\n\\t\\t if(k % 2 == 0)\\n\\t\\t  res[i] = left++;\\n\\t\\t else \\n\\t\\t  res[i] = right--;\\n\\t\\t\\t\\n\\t\\t // Keep swapping the reverses on each index until you do it k - 1 times.\\n\\t\\t // Then rest of numbers should just ONLY incremements or ONLY decrements.\\n\\t\\t if(k > 1)\\n\\t\\t  k--;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\t\\nI understand that this code is also found in the 2 liner one in the top voted. But seriously, that\\'s unreadable and completely unhelpful. So if you guys are struggling and not understanding the logic behind this, I hope this makes more sense. Basically, if you reverse the whole array, you get k = 1. If you reverse that from index 2 then, you get k = 2. If you reverse that from index 3 then, you get k = 3.. and so on.\\nThe for loop for O(n) is doing just that. \"k--\" until all the necessary reverses are done to get the number of k differences then just either going increments of 1 or decrements of 1 only on the rest of the array.",
                "solutionTags": [],
                "code": "```\\npublic int[] constructArray(int n, int k) {\\n\\tint[] res = new int[n];\\n\\t\\n\\t// Create initial array of {1, 2, 3, 4, ..., n}\\n\\tfor(int i = 0; i < n; i++)\\n\\t\\tres[i] = i + 1;\\n\\t\\t\\n\\t// Keep reversing each sub-array from index 0 to k - 1\\n\\tfor(int i = 1; i < k; i++)\\n\\t\\treverseList(res, i, n - 1);\\n\\treturn res;\\n}\\n\\n// Reverse sub-array.\\n// You can also use XOR to swap for \"coolness\" since you don\\'t use another variable but it is slower than using the int temp itself\\npublic void reverseList(int[] res, int left, int right){\\n        while(left < right){\\n            int temp = res[left];\\n            res[left] = res[right];\\n            res[right] = temp;\\n            \\n            left++;\\n            right--;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1154683,
                "title": "short-simple-solution-multiple-approaches-explained-with-examples",
                "content": "The problem statement asks us to find a permutation of `1 to n` such that there are `k` Unique Absolute Adjacent Difference (let\\'s call it **UAAD** henceforth). We must realize that with `n` elements, we can form any permutation for `k` UAADs such that `1 <= k < n`. \\n\\nThe solution for this problem is mostly observation based. I will suggest you to try out some examples before moving on to the explanation below.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I***\\n\\nWe need to find permutation with `k` UAAD. This means we can make a permutation such that the set of UAADs are `k, k-1, k-2, ..., 2, 1`. \\n\\n* So we can start the permutation with `1`.\\n* Choose the next element such that the absolute difference between them is `k`. \\n* Now, choose the next element such that the absolute difference between it & previous element is `k - 1`.\\n* And continue so on till absolute difference is 1. Thereafter, we just fill the remaining elements of array such that all of them have absolute difference of 1 (Meaning rest all elements are consecutive).\\n\\n```\\nBelow are some examples which will provide better understanding -\\n\\nFor eg. \\n1. let n = 10, k = 4\\npermutation                           =>       [1, 5, 2, 4, 3, 6, 7, 8, 9, 10]\\nUAADs(abs(arr[i] - arr[i - 1]))       =>       [X, 4, 3, 2, 1, 3, 1, 1, 1, 1]\\n\\n\\n2. n = 10, k = 5\\npermutation                           =>       [1, 6, 2, 5, 3, 4, 7, 8, 9, 10]\\nUAADs                                 =>       [X, 5, 4, 3, 2, 1, 3, 1, 1, 1]\\n\\n\\n3. n = 9, k = 8\\npermutation                           =>       [1, 9, 2, 8, 3, 7, 4, 6, 5]\\nUAADs                                 =>       [X, 8, 7, 6, 5, 4, 3, 2, 1]\\n\\n\\n4. n = 15, k = 6\\npermutation                           =>       [1, 7, 2, 6, 3, 5, 4, 8, 9, 10, 11, 12, 13, 14, 15]\\nUAADs                                 =>       [X, 6, 5, 4, 3, 2, 1, 4, 1,  1,  1,  1,  1,  1,  1]\\n\\nAs we can see from above examples, the approach is like maintaining two pointers: l = 1, r = k + 1.\\n1. We assign 1st index as \\'l\\' and increment \\'l\\'. Then assign 2nd index as \\'r\\' and decrement \\'r\\'.\\n2. Assign 3rd index as \\'l\\' and increment it. Assign 4th index as \\'r\\' and decrement it.\\nWe continue this process till first k index are assigned in this manner.\\n```\\n\\n---\\n\\nThe implementation of above idea is given below -\\n\\n**C++**\\n```\\nvector<int> constructArray(int n, int k) {\\n    vector<int> ans(n);\\n    int l = 1, r = k + 1, i = 0;\\n    while(i < k)   // first k elements will be such there are k unique UAADs\\n        ans[i++] = l++, ans[i++] = r--;\\n    if(l == r) ans[i++] = r; // required for case when k is even\\n    while(i < n) ans[i++] = i + 1; // rest of last elements will be consecutive having adjacent difference of 1\\n\\treturn ans;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N)`**, we only iterate once from `0 to n-1`.\\n***Space Complexity :*** **`O(N)`**, required for storing the answer\\n\\n---\\n---\\n\\n\\u2714\\uFE0F ***Solution - II***\\n\\nIn this, the idea is the same as above, only the way numbers are chosen is different.\\n\\nHere, we choose the numbers as - `1, n, 2, n - 1, 3, n - 2, ...`. This will be done till first `k` index are filled. \\n\\nThe rest of the remaining indices are filled with consecutive elements. Thus, the first `k` elements will give `k - 1` UAADs and the rest of the consecutive elements will give `1` as another UAAD, thus making the total count of UAADs to be `k`.\\n\\n\\n```\\nBelow are some examples which will provide better understanding -\\n\\nFor eg. \\n1. let n = 10, k = 4\\npermutation                           =>       [1, 10, 2, 9, 8, 7, 6, 5, 4, 3]\\nUAADs(abs(arr[i] - arr[i - 1]))       =>       [X,  9, 8, 7, 1, 1, 1, 1, 1, 1]\\n\\n\\n2. n = 10, k = 5\\npermutation                           =>       [1, 10, 2, 9, 3, 4, 5, 6, 7, 8]\\nUAADs                                 =>       [X, 9, 8, 7, 6, 1, 1, 1, 1, 1]\\n\\n\\n3. n = 9, k = 8\\npermutation                           =>       [1, 9, 2, 8, 3, 7, 4, 6, 5]\\nUAADs                                 =>       [X, 8, 7, 6, 5, 4, 3, 2, 1]\\n\\n\\n4. n = 9, k = 5\\npermutation                           =>       [1, 9, 2, 8, 3, 4, 5, 6, 7]\\nUAADs                                 =>       [X, 8, 7, 6, 5, 1, 1, 1, 1]\\n\\n\\n5. n = 15, k = 6\\npermutation                           =>       [1, 15,  2, 14,  3, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4]\\nUAADs                                 =>       [X, 14, 13, 12, 11, 10,  1,  1,  1, 1, 1, 1, 1, 1, 1]\\n\\n\\n1. As we can see from above examples, the approach is again like maintaining two pointers: l = 1, r = n ( <- notice the different initialization than above).\\nThe same process as 1st solution is followed till first k index are assigned.\\n\\n2. Rest of the index are assigned in consecutive manner. For this there will be two different cases -\\n\\ta. k is odd - Assign consecutive elements starting from l & incrementing it \\n\\t             (Since previous element ends with l+1 and we need rest of remaining elements to have difference of 1).\\n\\t\\t\\t\\t  \\n\\tb. k is even - Assign consecutive elements starting from r & decrement it\\n\\t\\t\\t\\t (Since previous element ends with l+1 and we need rest of remaining elements to have difference of 1).\\n\\t\\t\\t\\t \\nIn simple words, the rest of elements are filled by taking where the sequence ended in step 1 and appending consecutive elements from there.\\n```\\n\\n---\\n\\nThe implementation of above idea is given below -\\n\\n**C++**\\n```\\nvector<int> constructArray(int n, int k) {\\n    vector<int> ans(n);\\n    int l = 1, r = n, i = 0;\\n    while(i < k - 1) // first k indices are filled with sequence [1, n, 2, n-1, 3, ...]\\n        ans[i++] = l++, ans[i++] = r--;\\n\\t// Remaining indices are filled by consecutive elements. \\n\\t// The sequence is continued from l or r depending on k (explanation provided above)\\n    while(i < n) ans[i++] = (k & 1 ? l++ : r--);\\n    return ans;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n---\\n\\n\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any questions or mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```\\nBelow are some examples which will provide better understanding -\\n\\nFor eg. \\n1. let n = 10, k = 4\\npermutation                           =>       [1, 5, 2, 4, 3, 6, 7, 8, 9, 10]\\nUAADs(abs(arr[i] - arr[i - 1]))       =>       [X, 4, 3, 2, 1, 3, 1, 1, 1, 1]\\n\\n\\n2. n = 10, k = 5\\npermutation                           =>       [1, 6, 2, 5, 3, 4, 7, 8, 9, 10]\\nUAADs                                 =>       [X, 5, 4, 3, 2, 1, 3, 1, 1, 1]\\n\\n\\n3. n = 9, k = 8\\npermutation                           =>       [1, 9, 2, 8, 3, 7, 4, 6, 5]\\nUAADs                                 =>       [X, 8, 7, 6, 5, 4, 3, 2, 1]\\n\\n\\n4. n = 15, k = 6\\npermutation                           =>       [1, 7, 2, 6, 3, 5, 4, 8, 9, 10, 11, 12, 13, 14, 15]\\nUAADs                                 =>       [X, 6, 5, 4, 3, 2, 1, 4, 1,  1,  1,  1,  1,  1,  1]\\n\\nAs we can see from above examples, the approach is like maintaining two pointers: l = 1, r = k + 1.\\n1. We assign 1st index as \\'l\\' and increment \\'l\\'. Then assign 2nd index as \\'r\\' and decrement \\'r\\'.\\n2. Assign 3rd index as \\'l\\' and increment it. Assign 4th index as \\'r\\' and decrement it.\\nWe continue this process till first k index are assigned in this manner.\\n```\n```\\nvector<int> constructArray(int n, int k) {\\n    vector<int> ans(n);\\n    int l = 1, r = k + 1, i = 0;\\n    while(i < k)   // first k elements will be such there are k unique UAADs\\n        ans[i++] = l++, ans[i++] = r--;\\n    if(l == r) ans[i++] = r; // required for case when k is even\\n    while(i < n) ans[i++] = i + 1; // rest of last elements will be consecutive having adjacent difference of 1\\n\\treturn ans;\\n}\\n```\n```\\nBelow are some examples which will provide better understanding -\\n\\nFor eg. \\n1. let n = 10, k = 4\\npermutation                           =>       [1, 10, 2, 9, 8, 7, 6, 5, 4, 3]\\nUAADs(abs(arr[i] - arr[i - 1]))       =>       [X,  9, 8, 7, 1, 1, 1, 1, 1, 1]\\n\\n\\n2. n = 10, k = 5\\npermutation                           =>       [1, 10, 2, 9, 3, 4, 5, 6, 7, 8]\\nUAADs                                 =>       [X, 9, 8, 7, 6, 1, 1, 1, 1, 1]\\n\\n\\n3. n = 9, k = 8\\npermutation                           =>       [1, 9, 2, 8, 3, 7, 4, 6, 5]\\nUAADs                                 =>       [X, 8, 7, 6, 5, 4, 3, 2, 1]\\n\\n\\n4. n = 9, k = 5\\npermutation                           =>       [1, 9, 2, 8, 3, 4, 5, 6, 7]\\nUAADs                                 =>       [X, 8, 7, 6, 5, 1, 1, 1, 1]\\n\\n\\n5. n = 15, k = 6\\npermutation                           =>       [1, 15,  2, 14,  3, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4]\\nUAADs                                 =>       [X, 14, 13, 12, 11, 10,  1,  1,  1, 1, 1, 1, 1, 1, 1]\\n\\n\\n1. As we can see from above examples, the approach is again like maintaining two pointers: l = 1, r = n ( <- notice the different initialization than above).\\nThe same process as 1st solution is followed till first k index are assigned.\\n\\n2. Rest of the index are assigned in consecutive manner. For this there will be two different cases -\\n\\ta. k is odd - Assign consecutive elements starting from l & incrementing it \\n\\t             (Since previous element ends with l+1 and we need rest of remaining elements to have difference of 1).\\n\\t\\t\\t\\t  \\n\\tb. k is even - Assign consecutive elements starting from r & decrement it\\n\\t\\t\\t\\t (Since previous element ends with l+1 and we need rest of remaining elements to have difference of 1).\\n\\t\\t\\t\\t \\nIn simple words, the rest of elements are filled by taking where the sequence ended in step 1 and appending consecutive elements from there.\\n```\n```\\nvector<int> constructArray(int n, int k) {\\n    vector<int> ans(n);\\n    int l = 1, r = n, i = 0;\\n    while(i < k - 1) // first k indices are filled with sequence [1, n, 2, n-1, 3, ...]\\n        ans[i++] = l++, ans[i++] = r--;\\n\\t// Remaining indices are filled by consecutive elements. \\n\\t// The sequence is continued from l or r depending on k (explanation provided above)\\n    while(i < n) ans[i++] = (k & 1 ? l++ : r--);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 106957,
                "title": "c-concise-code-o-n",
                "content": "The requirement of k distinct distance can be achieved from 1, 2, ..., k+1 (<= n), by the following strategy:\\n```\\n1, k+1, 2, k, 3, k-1 ...;\\nThe distance of this sequence is k, k-1, k-2, ..., 2, 1\\n```\\nThen append the remaining numbers to the list.\\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        int l = 1, r = k+1;\\n        vector<int> ans;\\n        while (l <= r) {\\n            ans.push_back(l++);\\n            if (l <= r) ans.push_back(r--);\\n        }\\n        for (int i = k+2; i <= n; i++)\\n            ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n1, k+1, 2, k, 3, k-1 ...;\\nThe distance of this sequence is k, k-1, k-2, ..., 2, 1\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        int l = 1, r = k+1;\\n        vector<int> ans;\\n        while (l <= r) {\\n            ans.push_back(l++);\\n            if (l <= r) ans.push_back(r--);\\n        }\\n        for (int i = k+2; i <= n; i++)\\n            ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154742,
                "title": "js-python-java-c-simple-mathematical-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nFor this problem, we have to think about the nature of the range of possible values for **k** and their matching arrays. The smallest value of **k** possible is obviously **1**, which can be achieved by a strictly increasing (or decreasing) array. Thinking about the largest possible value for **k**, however, is slightly more challenging.\\n\\nFirst, we can consider the range of values in our array, which is **[1, n]**. The largest possible absolute difference of any two numbers in that range would obviously be the difference between the two extremes, **1** and **n**, which is **n - 1**. Since the smallest possible absolute difference is obviously **1**, then it would appear to perhaps be possible to achieve each difference in the range **[1, n - 1]**, or a **k** value of **n - 1**.\\n\\n*But is this actually possible?*\\n\\nLet\\'s take **n = 5** and **k = 4** for example. The only possible way to get the absolute difference of **4** would be for **1** and **5** to be consecutive. After that there are two possibilites for next smallest absolute difference of **3**, which are **1** & **4** or **2** & **5**. Since the **1** and **5** are already next to each other, that means we can achieve this second step with either **[1,5,2]** or **[4,1,5]** (or their reverses).\\n\\nContinuing this trend along, we can gradually see that we can indeed achieve the maximum **k** value of **n - 1** by zig-zagging back and forth between the remaining extremes as we add them to our array. In the previous example, one such example would be **[1,5,2,4,3]**.\\n\\nThe question then remains how we go about achieving some medium value of **k** larger than **1** but smaller than **n - 1**. The answer to that lies in considering the array to be made of two parts. In the first part, **[1, k+1]**, we can achieve our **k** number of absolute differences, then we can simply fill in the remaining range, **[k+2, n]**, with the ideal incrementing values without increasing the value of **k**.\\n\\nFor example, if we have **n = 8** and **k = 4**, we would build the first part the same as the last example, **[1,5,2,4,3]**, then we would add on the remaining values in increasing order, **[6,7,8]**, to make the wole array, **[1,5,2,4,3,6,7,8]**.\\n\\n_Examples of each variation of **k** when **n = 8**:_\\n![Visual 1](https://i.imgur.com/OOuahhe.png)\\n\\nTo achieve the zig-zag fill, we can use variables for the top and bottom values of our first part (**a, z**), then use a **modulo** operation (**i % 2**) to alternate between the two options, remembering to increment/decrement the respective variables each time they\\'re used.\\n\\nA slightly easier to visualize (but harder to code) version of the solution similarly involves using the same zig-zag for the first **k** elements, but with the full range of **n** numbers, and then moving in ideal fashion (either increasing or decreasing by **1**, depending on whether **k** is even or odd) to fill the remaining elements of the array.\\n\\n_Examples of each alternate variation of **k** when **n = 8**:_\\n![Visual 2](https://i.imgur.com/foIzoFT.png)\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThe are only minor differences between each of the four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **80ms / 40.2MB** (beats 100% / 91%).\\n```javascript\\nvar constructArray = function(n, k) {\\n    let ans = new Array(n)\\n    for (let i = 0, a = 1, z = k + 1; i <= k; i++)\\n        ans[i] = i % 2 ? z-- : a++\\n    for (let i = k + 1; i < n;)\\n        ans[i] = ++i\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **40ms / 15.0MB** (beats 97% / 93%).\\n```python\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        ans, a, z = [0] * n, 1, k + 1\\n        for i in range(k+1):\\n            if i % 2:\\n                ans[i] = z\\n                z -= 1\\n            else:\\n                ans[i] = a\\n                a += 1\\n        for i in range(k+1,n):\\n            ans[i] = i + 1\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 38.8MB** (beats 100% / 98%).\\n```java\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] ans = new int[n];\\n        for (int i = 0, a = 1, z = k + 1; i <= k; i++)\\n            ans[i] = i % 2 == 1 ? z-- : a++;\\n        for (int i = k+1; i < n;)\\n            ans[i] = ++i;\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.3MB** (beats 100% / 88%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans(n);\\n        for (int i = 0, a = 1, z = k + 1; i <= k; i++)\\n            ans[i] = i % 2 ? z-- : a++;\\n        for (int i = k+1; i < n; i++)\\n            ans[i] = i + 1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar constructArray = function(n, k) {\\n    let ans = new Array(n)\\n    for (let i = 0, a = 1, z = k + 1; i <= k; i++)\\n        ans[i] = i % 2 ? z-- : a++\\n    for (let i = k + 1; i < n;)\\n        ans[i] = ++i\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        ans, a, z = [0] * n, 1, k + 1\\n        for i in range(k+1):\\n            if i % 2:\\n                ans[i] = z\\n                z -= 1\\n            else:\\n                ans[i] = a\\n                a += 1\\n        for i in range(k+1,n):\\n            ans[i] = i + 1\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] ans = new int[n];\\n        for (int i = 0, a = 1, z = k + 1; i <= k; i++)\\n            ans[i] = i % 2 == 1 ? z-- : a++;\\n        for (int i = k+1; i < n;)\\n            ans[i] = ++i;\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans(n);\\n        for (int i = 0, a = 1, z = k + 1; i <= k; i++)\\n            ans[i] = i % 2 ? z-- : a++;\\n        for (int i = k+1; i < n; i++)\\n            ans[i] = i + 1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154746,
                "title": "beautiful-arrangement-ii-js-python-java-c-simple-mathematical-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nFor this problem, we have to think about the nature of the range of possible values for **k** and their matching arrays. The smallest value of **k** possible is obviously **1**, which can be achieved by a strictly increasing (or decreasing) array. Thinking about the largest possible value for **k**, however, is slightly more challenging.\\n\\nFirst, we can consider the range of values in our array, which is **[1, n]**. The largest possible absolute difference of any two numbers in that range would obviously be the difference between the two extremes, **1** and **n**, which is **n - 1**. Since the smallest possible absolute difference is obviously **1**, then it would appear to perhaps be possible to achieve each difference in the range **[1, n - 1]**, or a **k** value of **n - 1**.\\n\\n*But is this actually possible?*\\n\\nLet\\'s take **n = 5** and **k = 4** for example. The only possible way to get the absolute difference of **4** would be for **1** and **5** to be consecutive. After that there are two possibilites for next smallest absolute difference of **3**, which are **1** & **4** or **2** & **5**. Since the **1** and **5** are already next to each other, that means we can achieve this second step with either **[1,5,2]** or **[4,1,5]** (or their reverses).\\n\\nContinuing this trend along, we can gradually see that we can indeed achieve the maximum **k** value of **n - 1** by zig-zagging back and forth between the remaining extremes as we add them to our array. In the previous example, one such example would be **[1,5,2,4,3]**.\\n\\nThe question then remains how we go about achieving some medium value of **k** larger than **1** but smaller than **n - 1**. The answer to that lies in considering the array to be made of two parts. In the first part, **[1, k+1]**, we can achieve our **k** number of absolute differences, then we can simply fill in the remaining range, **[k+2, n]**, with the ideal incrementing values without increasing the value of **k**.\\n\\nFor example, if we have **n = 8** and **k = 4**, we would build the first part the same as the last example, **[1,5,2,4,3]**, then we would add on the remaining values in increasing order, **[6,7,8]**, to make the wole array, **[1,5,2,4,3,6,7,8]**.\\n\\n_Examples of each variation of **k** when **n = 8**:_\\n![Visual 1](https://i.imgur.com/OOuahhe.png)\\n\\nTo achieve the zig-zag fill, we can use variables for the top and bottom values of our first part (**a, z**), then use a **modulo** operation (**i % 2**) to alternate between the two options, remembering to increment/decrement the respective variables each time they\\'re used.\\n\\nA slightly easier to visualize (but harder to code) version of the solution similarly involves using the same zig-zag for the first **k** elements, but with the full range of **n** numbers, and then moving in ideal fashion (either increasing or decreasing by **1**, depending on whether **k** is even or odd) to fill the remaining elements of the array.\\n\\n_Examples of each alternate variation of **k** when **n = 8**:_\\n![Visual 2](https://i.imgur.com/foIzoFT.png)\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThe are only minor differences between each of the four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **80ms / 40.2MB** (beats 100% / 91%).\\n```javascript\\nvar constructArray = function(n, k) {\\n    let ans = new Array(n)\\n    for (let i = 0, a = 1, z = k + 1; i <= k; i++)\\n        ans[i] = i % 2 ? z-- : a++\\n    for (let i = k + 1; i < n;)\\n        ans[i] = ++i\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **40ms / 15.0MB** (beats 97% / 93%).\\n```python\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        ans, a, z = [0] * n, 1, k + 1\\n        for i in range(k+1):\\n            if i % 2:\\n                ans[i] = z\\n                z -= 1\\n            else:\\n                ans[i] = a\\n                a += 1\\n        for i in range(k+1,n):\\n            ans[i] = i + 1\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 38.8MB** (beats 100% / 98%).\\n```java\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] ans = new int[n];\\n        for (int i = 0, a = 1, z = k + 1; i <= k; i++)\\n            ans[i] = i % 2 == 1 ? z-- : a++;\\n        for (int i = k+1; i < n;)\\n            ans[i] = ++i;\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.3MB** (beats 100% / 88%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans(n);\\n        for (int i = 0, a = 1, z = k + 1; i <= k; i++)\\n            ans[i] = i % 2 ? z-- : a++;\\n        for (int i = k+1; i < n; i++)\\n            ans[i] = i + 1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar constructArray = function(n, k) {\\n    let ans = new Array(n)\\n    for (let i = 0, a = 1, z = k + 1; i <= k; i++)\\n        ans[i] = i % 2 ? z-- : a++\\n    for (let i = k + 1; i < n;)\\n        ans[i] = ++i\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        ans, a, z = [0] * n, 1, k + 1\\n        for i in range(k+1):\\n            if i % 2:\\n                ans[i] = z\\n                z -= 1\\n            else:\\n                ans[i] = a\\n                a += 1\\n        for i in range(k+1,n):\\n            ans[i] = i + 1\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] ans = new int[n];\\n        for (int i = 0, a = 1, z = k + 1; i <= k; i++)\\n            ans[i] = i % 2 == 1 ? z-- : a++;\\n        for (int i = k+1; i < n;)\\n            ans[i] = ++i;\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans(n);\\n        for (int i = 0, a = 1, z = k + 1; i <= k; i++)\\n            ans[i] = i % 2 ? z-- : a++;\\n        for (int i = k+1; i < n; i++)\\n            ans[i] = i + 1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106965,
                "title": "python-straightforward-with-explanation",
                "content": "When `k = n-1`, a valid construction is `[1, n, 2, n-1, 3, n-2, ....]`.  One way to see this is, we need to have a difference of `n-1`, which means we need `1` and `n` adjacent; then, we need a difference of `n-2`, etc.\\n\\nThis leads to the following idea:  we will put `[1, 2, ...., n-k-1]` first, and then we have `N = k+1` adjacent numbers left, of which we want `k` different differences.  This is just the answer above translated by `n-k-1`: we'll put `[n-k, n, n-k+1, n-1, ....]` after.\\n\\n```\\ndef constructArray(self, n, k):\\n    ans = range(1, n - k)\\n    for d in xrange(k+1):\\n        if d % 2 == 0:\\n            ans.append(n-k + d/2)\\n        else:\\n            ans.append(n - d/2)\\n\\n    return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef constructArray(self, n, k):\\n    ans = range(1, n - k)\\n    for d in xrange(k+1):\\n        if d % 2 == 0:\\n            ans.append(n-k + d/2)\\n        else:\\n            ans.append(n - d/2)\\n\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 106955,
                "title": "short-simple-with-explanation",
                "content": "Start with the numbers sorted, e.g., `1 2 3 4 5 6 7 8 9 10`. Then we only have difference 1, many times. We can create the largest possible difference by making the smallest and largest number neighbors. In the example, let's bring 10 next to 1. If we do this by reversing the whole subarray from 2 to 10, then no other neighborships in 2 to 10 are affected: `1 10 9 8 7 6 5 4 3 2`. To create the next larger possible difference, we can bring 2 next to 10 by reversing the subarray from 9 to 2: `1 10 2 3 4 5 6 7 8 9`. And so on, reversing shorter and shorter suffixes. Just create as many differences as requested.\\n\\nPython\\n\\n    def constructArray(self, n, k):\\n        a = range(1, n+1)\\n        for i in range(1, k):\\n            a[i:] = a[:i-1:-1]\\n        return a\\n\\nRuby\\n```\\ndef construct_array(n, k)\\n  a = (1..n).to_a\\n  (1...k).each { |i| a[i..-1] = a[i..-1].reverse }\\n  a\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef construct_array(n, k)\\n  a = (1..n).to_a\\n  (1...k).each { |i| a[i..-1] = a[i..-1].reverse }\\n  a\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 106971,
                "title": "java-easy-to-understand-with-explanation",
                "content": "1,n,2,n-1,3,n-2,4... ==> Diff:  n-1, n-2, n-3, n-4, n-5...\\nBy following this pattern, k numbers will have k-1 distinct difference values; \\nand all the rest numbers should have |ai - a_i-1| = 1; \\nIn total, we will have k-1+1 = k distinct values.\\n\\n```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        if(k>=n) return null;\\n        int[] arr = new int[n];\\n        int i = 0, small = 1, large = n;        \\n        while(i<k){ \\n            arr[i++] = small++;\\n            if(i<k) arr[i++] = large--;\\n        }        \\n        if(k%2 == 0){ // k==2 ==> 1, 6, 5,4,3,2\\n            while(i<arr.length) arr[i++] = large--;\\n        } else { // k==3 ==> 1,6,2,3,4,5\\n            while(i<arr.length) arr[i++] = small++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        if(k>=n) return null;\\n        int[] arr = new int[n];\\n        int i = 0, small = 1, large = n;        \\n        while(i<k){ \\n            arr[i++] = small++;\\n            if(i<k) arr[i++] = large--;\\n        }        \\n        if(k%2 == 0){ // k==2 ==> 1, 6, 5,4,3,2\\n            while(i<arr.length) arr[i++] = large--;\\n        } else { // k==3 ==> 1,6,2,3,4,5\\n            while(i<arr.length) arr[i++] = small++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154681,
                "title": "beautiful-arrangement-ii-multiple-approaches-explained-with-examples",
                "content": "The problem statement asks us to find a permutation of `1 to n` such that there are `k` Unique Absolute Adjacent Difference (let\\'s call it **UAAD** henceforth). We must realize that with `n` elements, we can form any permutation for `k` UAADs such that `1 <= k < n`. \\n\\nThe solution for this problem is mostly observation based. I will suggest you to try out some examples before moving on to the explanation below.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I***\\n\\nWe need to find permutation with `k` UAAD. This means we can make a permutation such that the set of UAADs are `k, k-1, k-2, ..., 2, 1`. \\n\\n* So we can start the permutation with `1`.\\n* Choose the next element such that the absolute difference between them is `k`. \\n* Now, choose the next element such that the absolute difference between it & previous element is `k - 1`.\\n* And continue so on till absolute difference is 1. Thereafter, we just fill the remaining elements of array such that all of them have absolute difference of 1 (Meaning rest all elements are consecutive).\\n\\n```\\nBelow are some examples which will provide better understanding -\\n\\nFor eg. \\n1. let n = 10, k = 4\\npermutation                           =>       [1, 5, 2, 4, 3, 6, 7, 8, 9, 10]\\nUAADs(abs(arr[i] - arr[i - 1]))       =>       [X, 4, 3, 2, 1, 3, 1, 1, 1, 1]\\n\\n\\n2. n = 10, k = 5\\npermutation                           =>       [1, 6, 2, 5, 3, 4, 7, 8, 9, 10]\\nUAADs                                 =>       [X, 5, 4, 3, 2, 1, 3, 1, 1, 1]\\n\\n\\n3. n = 9, k = 8\\npermutation                           =>       [1, 9, 2, 8, 3, 7, 4, 6, 5]\\nUAADs                                 =>       [X, 8, 7, 6, 5, 4, 3, 2, 1]\\n\\n\\n4. n = 15, k = 6\\npermutation                           =>       [1, 7, 2, 6, 3, 5, 4, 8, 9, 10, 11, 12, 13, 14, 15]\\nUAADs                                 =>       [X, 6, 5, 4, 3, 2, 1, 4, 1,  1,  1,  1,  1,  1,  1]\\n\\nAs we can see from above examples, the approach is like maintaining two pointers: l = 1, r = k + 1.\\n1. We assign 1st index as \\'l\\' and increment \\'l\\'. Then assign 2nd index as \\'r\\' and decrement \\'r\\'.\\n2. Assign 3rd index as \\'l\\' and increment it. Assign 4th index as \\'r\\' and decrement it.\\nWe continue this process till first k index are assigned in this manner.\\n```\\n\\n---\\n\\nThe implementation of above idea is given below -\\n\\n**C++**\\n```\\nvector<int> constructArray(int n, int k) {\\n    vector<int> ans(n);\\n    int l = 1, r = k + 1, i = 0;\\n    while(i < k)   // first k elements will be such there are k unique UAADs\\n        ans[i++] = l++, ans[i++] = r--;\\n    if(l == r) ans[i++] = r; // required for case when k is even\\n    while(i < n) ans[i++] = i + 1; // rest of last elements will be consecutive having adjacent difference of 1\\n\\treturn ans;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N)`**, we only iterate once from `0 to n-1`.\\n***Space Complexity :*** **`O(N)`**, required for storing the answer\\n\\n---\\n---\\n\\n\\u2714\\uFE0F ***Solution - II***\\n\\nIn this, the idea is the same as above, only the way numbers are chosen is different.\\n\\nHere, we choose the numbers as - `1, n, 2, n - 1, 3, n - 2, ...`. This will be done till first `k` index are filled. \\n\\nThe rest of the remaining indices are filled with consecutive elements. Thus, the first `k` elements will give `k - 1` UAADs and the rest of the consecutive elements will give `1` as another UAAD, thus making the total count of UAADs to be `k`.\\n\\n\\n```\\nBelow are some examples which will provide better understanding -\\n\\nFor eg. \\n1. let n = 10, k = 4\\npermutation                           =>       [1, 10, 2, 9, 8, 7, 6, 5, 4, 3]\\nUAADs(abs(arr[i] - arr[i - 1]))       =>       [X,  9, 8, 7, 1, 1, 1, 1, 1, 1]\\n\\n\\n2. n = 10, k = 5\\npermutation                           =>       [1, 10, 2, 9, 3, 4, 5, 6, 7, 8]\\nUAADs                                 =>       [X, 9, 8, 7, 6, 1, 1, 1, 1, 1]\\n\\n\\n3. n = 9, k = 8\\npermutation                           =>       [1, 9, 2, 8, 3, 7, 4, 6, 5]\\nUAADs                                 =>       [X, 8, 7, 6, 5, 4, 3, 2, 1]\\n\\n\\n4. n = 9, k = 5\\npermutation                           =>       [1, 9, 2, 8, 3, 4, 5, 6, 7]\\nUAADs                                 =>       [X, 8, 7, 6, 5, 1, 1, 1, 1]\\n\\n\\n5. n = 15, k = 6\\npermutation                           =>       [1, 15,  2, 14,  3, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4]\\nUAADs                                 =>       [X, 14, 13, 12, 11, 10,  1,  1,  1, 1, 1, 1, 1, 1, 1]\\n\\n\\n1. As we can see from above examples, the approach is again like maintaining two pointers: l = 1, r = n ( <- notice the different initialization than above).\\nThe same process as 1st solution is followed till first k index are assigned.\\n\\n2. Rest of the index are assigned in consecutive manner. For this there will be two different cases -\\n\\ta. k is odd - Assign consecutive elements starting from l & incrementing it \\n\\t             (Since previous element ends with l+1 and we need rest of remaining elements to have difference of 1).\\n\\t\\t\\t\\t  \\n\\tb. k is even - Assign consecutive elements starting from r & decrement it\\n\\t\\t\\t\\t (Since previous element ends with l+1 and we need rest of remaining elements to have difference of 1).\\n\\t\\t\\t\\t \\nIn simple words, the rest of elements are filled by taking where the sequence ended in step 1 and appending consecutive elements from there.\\n```\\n\\n---\\n\\nThe implementation of above idea is given below -\\n\\n**C++**\\n```\\nvector<int> constructArray(int n, int k) {\\n    vector<int> ans(n);\\n    int l = 1, r = n, i = 0;\\n    while(i < k - 1) // first k indices are filled with sequence [1, n, 2, n-1, 3, ...]\\n        ans[i++] = l++, ans[i++] = r--;\\n\\t// Remaining indices are filled by consecutive elements. \\n\\t// The sequence is continued from l or r depending on k (explanation provided above)\\n    while(i < n) ans[i++] = (k & 1 ? l++ : r--);\\n    return ans;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n---\\n\\n\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any questions or mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nBelow are some examples which will provide better understanding -\\n\\nFor eg. \\n1. let n = 10, k = 4\\npermutation                           =>       [1, 5, 2, 4, 3, 6, 7, 8, 9, 10]\\nUAADs(abs(arr[i] - arr[i - 1]))       =>       [X, 4, 3, 2, 1, 3, 1, 1, 1, 1]\\n\\n\\n2. n = 10, k = 5\\npermutation                           =>       [1, 6, 2, 5, 3, 4, 7, 8, 9, 10]\\nUAADs                                 =>       [X, 5, 4, 3, 2, 1, 3, 1, 1, 1]\\n\\n\\n3. n = 9, k = 8\\npermutation                           =>       [1, 9, 2, 8, 3, 7, 4, 6, 5]\\nUAADs                                 =>       [X, 8, 7, 6, 5, 4, 3, 2, 1]\\n\\n\\n4. n = 15, k = 6\\npermutation                           =>       [1, 7, 2, 6, 3, 5, 4, 8, 9, 10, 11, 12, 13, 14, 15]\\nUAADs                                 =>       [X, 6, 5, 4, 3, 2, 1, 4, 1,  1,  1,  1,  1,  1,  1]\\n\\nAs we can see from above examples, the approach is like maintaining two pointers: l = 1, r = k + 1.\\n1. We assign 1st index as \\'l\\' and increment \\'l\\'. Then assign 2nd index as \\'r\\' and decrement \\'r\\'.\\n2. Assign 3rd index as \\'l\\' and increment it. Assign 4th index as \\'r\\' and decrement it.\\nWe continue this process till first k index are assigned in this manner.\\n```\n```\\nvector<int> constructArray(int n, int k) {\\n    vector<int> ans(n);\\n    int l = 1, r = k + 1, i = 0;\\n    while(i < k)   // first k elements will be such there are k unique UAADs\\n        ans[i++] = l++, ans[i++] = r--;\\n    if(l == r) ans[i++] = r; // required for case when k is even\\n    while(i < n) ans[i++] = i + 1; // rest of last elements will be consecutive having adjacent difference of 1\\n\\treturn ans;\\n}\\n```\n```\\nBelow are some examples which will provide better understanding -\\n\\nFor eg. \\n1. let n = 10, k = 4\\npermutation                           =>       [1, 10, 2, 9, 8, 7, 6, 5, 4, 3]\\nUAADs(abs(arr[i] - arr[i - 1]))       =>       [X,  9, 8, 7, 1, 1, 1, 1, 1, 1]\\n\\n\\n2. n = 10, k = 5\\npermutation                           =>       [1, 10, 2, 9, 3, 4, 5, 6, 7, 8]\\nUAADs                                 =>       [X, 9, 8, 7, 6, 1, 1, 1, 1, 1]\\n\\n\\n3. n = 9, k = 8\\npermutation                           =>       [1, 9, 2, 8, 3, 7, 4, 6, 5]\\nUAADs                                 =>       [X, 8, 7, 6, 5, 4, 3, 2, 1]\\n\\n\\n4. n = 9, k = 5\\npermutation                           =>       [1, 9, 2, 8, 3, 4, 5, 6, 7]\\nUAADs                                 =>       [X, 8, 7, 6, 5, 1, 1, 1, 1]\\n\\n\\n5. n = 15, k = 6\\npermutation                           =>       [1, 15,  2, 14,  3, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4]\\nUAADs                                 =>       [X, 14, 13, 12, 11, 10,  1,  1,  1, 1, 1, 1, 1, 1, 1]\\n\\n\\n1. As we can see from above examples, the approach is again like maintaining two pointers: l = 1, r = n ( <- notice the different initialization than above).\\nThe same process as 1st solution is followed till first k index are assigned.\\n\\n2. Rest of the index are assigned in consecutive manner. For this there will be two different cases -\\n\\ta. k is odd - Assign consecutive elements starting from l & incrementing it \\n\\t             (Since previous element ends with l+1 and we need rest of remaining elements to have difference of 1).\\n\\t\\t\\t\\t  \\n\\tb. k is even - Assign consecutive elements starting from r & decrement it\\n\\t\\t\\t\\t (Since previous element ends with l+1 and we need rest of remaining elements to have difference of 1).\\n\\t\\t\\t\\t \\nIn simple words, the rest of elements are filled by taking where the sequence ended in step 1 and appending consecutive elements from there.\\n```\n```\\nvector<int> constructArray(int n, int k) {\\n    vector<int> ans(n);\\n    int l = 1, r = n, i = 0;\\n    while(i < k - 1) // first k indices are filled with sequence [1, n, 2, n-1, 3, ...]\\n        ans[i++] = l++, ans[i++] = r--;\\n\\t// Remaining indices are filled by consecutive elements. \\n\\t// The sequence is continued from l or r depending on k (explanation provided above)\\n    while(i < n) ans[i++] = (k & 1 ? l++ : r--);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1154794,
                "title": "python-simple-solution-explained",
                "content": "Just create sentence `1,2, . . . , n\\u2212k, n, n\\u2212k+ 1, n\\u22121, . . .`, where we start to take biggest and smallest elements from place `n\\u2212k`.  Let us consider case `n = 14` and `k = 6`, then what  `[1,2,3,4,5,6,7,8,14,9,13,10,12,11]`: then first differences are equal to `1`, then we have differencese `6, -5, 4, -3, 2, -1`, so in the end we will have absolute differences `1, 2, 3, 4, 5, 6`.\\n\\n#### Complexity\\nTime complexity is `O(n)`, space as well to form output array\\n\\n#### Code\\n```\\nclass Solution:\\n    def constructArray(self, n, k):\\n        dr, diff = 1, k\\n        result = list(range(1, n-k+1))\\n        for i in range(k):\\n            result.append(result[-1] + dr*diff)\\n            dr *= -1\\n            diff -= 1      \\n        return result\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def constructArray(self, n, k):\\n        dr, diff = 1, k\\n        result = list(range(1, n-k+1))\\n        for i in range(k):\\n            result.append(result[-1] + dr*diff)\\n            dr *= -1\\n            diff -= 1      \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154732,
                "title": "c-super-simple-easy-and-short-explained-solution-0-ms-faster-than-100",
                "content": "**Explanation:**\\nWe pick the numbers alternating between the beginning index and end index until we have k differences, and when we finish we just add the rest of the numbers.\\nSo we start off with i = 1 and j = n.\\nWe add to res i, and increase it, and then j, and decrease it, then decrease k.\\n**For example:**\\nn = 7, k = 6\\nres = 1, 7, 2, 6, 3, 5, 4\\nThis is for the case that k is the maximum - n-1.\\nIf k is less, and we finish it before adding all the numbers, we just add the rest in the end with difference 1.\\n**For example:**\\nn = 7, k = 3\\nres = 1, 7, 2 - then k reaches 1, we go to \\'else\\' and add - 3, 4, 5, 6.\\nso res = 1, 7, 2, 3, 4, 5, 6 - exactly k differences.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> res;\\n        int i = 1, j = n;\\n        \\n        while (i <= j) {\\n            if (k > 1)\\n                k-- % 2 ? res.push_back(i++) : res.push_back(j--);\\n            \\n            else \\n                res.push_back(i++);\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> res;\\n        int i = 1, j = n;\\n        \\n        while (i <= j) {\\n            if (k > 1)\\n                k-- % 2 ? res.push_back(i++) : res.push_back(j--);\\n            \\n            else \\n                res.push_back(i++);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155391,
                "title": "out-of-the-box-and-easy-to-understand-solution",
                "content": "The problem asks us to generate an array of size \\'n\\' where the number of distinct absolute difference of adjacent elements are \\'k\\'. The problem can be solved by making a set of solutions and then observing the pattern within that solution.\\n\\n**For example,**\\nLets take ```n=5 and k=1```\\nOne of the possible solution is: ``1, 2, 3, 4, 5``\\n\\n**Now lets consider n=5 and k=2**\\n\\nWe can see that if we adjust the first 3 elements such that we get 2 different abolute differences, we would be left with only remaining n-3 elements and we can arrange them in any order keeping in mind the difference is either of the value which we got from the first 2 elements.\\n\\nLets take the absolute difference as , ```+2,-1. (Dont worry the sign is just for explanation)```\\n- So, lets put 1 as the first number of array.\\n- The next number would be **1 + 2 = 3**\\n- The third number would be **3 - 1 = 2**\\n\\nSince we are done with the first 3 elements we can simply store the remaining n-3 elements, in sorted order. Thus assuring that the abolute difference of adjacent elements remain 1 whereas the difference between the 3rd element(i.e. 2) and its next element(i.e. 4) remains 2 thus it doesn\\'t violate our condition. Hence the sequence becomes: 1, 3, 2, 4, 5\\n\\n**Now lets consider n=5 and k=3**\\n\\nWe can again make a pattern **```+3, -2, +1```**\\nOnce again put 1 as the first element of the answer vector. Followed by 1 + 3 = 4, followed by 4 - 2 = 2, followed by 2 + 1 = 3.\\nThen we store the remaining elements that are nothing but from k+2 to n.\\nHence the resultant array would be: 1, 4, 2, 3, 5\\n\\n**Now a DIY**\\n\\nTry to solve for n=9, k=4.\\n\\n**Hint - The pattern would be: +4, -3, +2, -1**\\n\\nThe elements will be 1, (1+4=)5, (5-3=)2, (2+2=)4, (4-1=)3, (remaining number from [k+2 till n]), 6, 7, 8, 9\\nHence the resultant sequence would be: ```1, 5, 2, 4, 3, 6, 7, 8, 9``` \\n\\n- - - - -\\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> pre;\\n        int f=1;\\n        int temp=k;\\n        while(k)\\n        {\\n            pre.push_back(k);\\n            k = abs(k)-1;\\n            if(f)\\n            {\\n                k*=-1;\\n            }\\n            f^=1;\\n        }\\n        vector<int> ans;\\n        ans.push_back(1);\\n        for(int i=0;i<temp;i++)\\n        {\\n            int ele = ans[i]+pre[i];\\n            ans.push_back(ele);\\n        }\\n        for(int i=temp+2;i<=n;i++)\\n        {\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nDo upvote and put your queries(if any) below.",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```n=5 and k=1```\n```+2,-1. (Dont worry the sign is just for explanation)```\n```+3, -2, +1```\n```1, 5, 2, 4, 3, 6, 7, 8, 9```\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> pre;\\n        int f=1;\\n        int temp=k;\\n        while(k)\\n        {\\n            pre.push_back(k);\\n            k = abs(k)-1;\\n            if(f)\\n            {\\n                k*=-1;\\n            }\\n            f^=1;\\n        }\\n        vector<int> ans;\\n        ans.push_back(1);\\n        for(int i=0;i<temp;i++)\\n        {\\n            int ele = ans[i]+pre[i];\\n            ans.push_back(ele);\\n        }\\n        for(int i=temp+2;i<=n;i++)\\n        {\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106963,
                "title": "java-simple-solution",
                "content": "    public int[] constructArray(int n, int k) {\\n        //number 1-n. if ascending order, always has diff = 1. \\n        //reorder to be 1, k+1, 2, k, 3 ... so have diff = k,k-1,k-2....1\\n        int[] res = new int[n];\\n        int inc = 1, dec = k+1;\\n        for(int i=0;i<=k;i++){\\n            if(i%2==0)\\n                res[i] = inc++;\\n            else\\n                res[i] = dec--;\\n        }\\n       \\n        for(int i=k+1;i<n;i++){\\n            res[i] = i+1;\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    public int[] constructArray(int n, int k) {\\n        //number 1-n. if ascending order, always has diff = 1. \\n        //reorder to be 1, k+1, 2, k, 3 ... so have diff = k,k-1,k-2....1\\n        int[] res = new int[n];\\n        int inc = 1, dec = k+1;\\n        for(int i=0;i<=k;i++){\\n            if(i%2==0)\\n                res[i] = inc++;\\n            else\\n                res[i] = dec--;\\n        }\\n       \\n        for(int i=k+1;i<n;i++){\\n            res[i] = i+1;\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 106950,
                "title": "3-lines-python",
                "content": "    def constructArray(self, n, k):\\n        res = range(1, n+1)\\n        for i in range(2, k+1): res = res[:i-1] + res[i-1:][::-1]\\n        return res\\n\\nExample: n = 7\\nk = 1, 1234567\\nk = 2, 1765432\\nk = 3, 1723456\\n....",
                "solutionTags": [],
                "code": "    def constructArray(self, n, k):\\n        res = range(1, n+1)\\n        for i in range(2, k+1): res = res[:i-1] + res[i-1:][::-1]\\n        return res\\n\\nExample: n = 7\\nk = 1, 1234567\\nk = 2, 1765432\\nk = 3, 1723456\\n....",
                "codeTag": "Python3"
            },
            {
                "id": 1581804,
                "title": "c-simple-concise-solution-without-any-even-odd-check",
                "content": "Understand with an example ... n=8, k=5, minm_val(left)=1, maxm_val(right)=8\\ntake the result array and fill it upto the (n-k) value, i.e., till (n-k-1)th index with left++...\\nhence, array after this operation becomes 1,2,3...\\nthen run the loop for (n-k)th till the last index and fill up the array with alternate values of right-- and left++ .. array becomes ---->> 1,2,3,8,4,7,5,6 \\nthats our answer ... with exactly k different differences \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        \\n        vector<int>res(n,0);\\n        \\n        int left=1,right=n,i=0;\\n        \\n        while(i<n-k)res[i++]=left++;\\n      \\n        while(i<n){\\n            \\n            res[i++]=right--;\\n            \\n            if(i==n)break;\\n            \\n            res[i++]=left++;\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        \\n        vector<int>res(n,0);\\n        \\n        int left=1,right=n,i=0;\\n        \\n        while(i<n-k)res[i++]=left++;\\n      \\n        while(i<n){\\n            \\n            res[i++]=right--;\\n            \\n            if(i==n)break;\\n            \\n            res[i++]=left++;\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154966,
                "title": "easy-c-solution-time-complexity-o-n",
                "content": "<img src = \"https://assets.leetcode.com/users/images/5edd4714-b747-47b3-9a37-897cc51d4663_1618233545.1771939.jpeg\" width = \"500\" >\\n\\nFrom the above example we can observe that :\\n* We need to put a breaker at index k.\\n* Take 2 variables low and high whose initial values are 1 and k+1 respectively. \\n* Till index k put low at even index and high at odd index. (increment low and decrement high values after every insertion)\\n* After index k push value i + 1 at index i.\\n\\n**My Implementation :**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans;\\n        int low = 1;\\n        int high = k + 1;\\n        for(int i = 0 ; i <= k ; i++){\\n\\t\\t\\t//at even index we assign lower value\\n            if(i%2 == 0){\\n                ans.push_back(low);\\n                low++;\\n            }\\n\\t\\t\\t//at odd index we put higher value\\n            else{\\n                ans.push_back(high);\\n                high--;\\n            }\\n        }\\n        for(int i = k+1 ; i <n ; i++)\\n            ans.push_back(i+1);\\n        \\n        return ans;\\n    }\\n};\\n```\\nTime Complexity of this approach - O(N)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans;\\n        int low = 1;\\n        int high = k + 1;\\n        for(int i = 0 ; i <= k ; i++){\\n\\t\\t\\t//at even index we assign lower value\\n            if(i%2 == 0){\\n                ans.push_back(low);\\n                low++;\\n            }\\n\\t\\t\\t//at odd index we put higher value\\n            else{\\n                ans.push_back(high);\\n                high--;\\n            }\\n        }\\n        for(int i = k+1 ; i <n ; i++)\\n            ans.push_back(i+1);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154747,
                "title": "python-3-two-pointers-o-n-40ms",
                "content": "- Increasing (e.g. `1, 2, 3, 4, 5`) or decreasing (e.g. `5, 4, 3, 2, 1`) list gives minimum `1` distinct absolute difference.\\n- Jumping min-max list `1, n, 2, n-1, 3, n-2, ...` (e.g. `1, 5, 2, 4, 3`) or max-min list `n, 1, n-1, 2, n-2, 3, ...` (e.g. `5, 1, 4, 2, 3`) gives maximum `n-1` distinct absolute differences.\\n- To get exactly `k` (e.g. `3`) differences we need to concatenate two algorithms. We can use `k` elements from the second algorithm and `n-k` elements from the first one (e.g. `(1, 5, 2), (3, 4)`) or `n-k` elements from the first algorithm and `k` elements from the second one (e.g. `(1, 2), (5, 3, 4)`).\\n- Time complexity is `O(n)`. Additional space complexity is `O(1)`.\\n```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        i, j = 1, n; ret = [i] \\n        while i < j:\\n            if (k > 1) ^ (ret[-1] == i):\\n                i += 1; ret.append(i)\\n            else:\\n                ret.append(j); j -= 1\\n            k -= 1\\n                \\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        i, j = 1, n; ret = [i] \\n        while i < j:\\n            if (k > 1) ^ (ret[-1] == i):\\n                i += 1; ret.append(i)\\n            else:\\n                ret.append(j); j -= 1\\n            k -= 1\\n                \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106954,
                "title": "unexpected-tle",
                "content": "I'm not certain this code produces the correct answer, however I was surprised to get TLE. I originally was using `push_back` on the vector, but even with a size initializer to avoid multiple heap allocations it still takes too long on the input `(9999,9998)`. On my machine, this code runs in about 8 *micro*seconds, or about 2.5 clocks per `n`, so I don't really know what's going on here.\\n```\\nvector<int> constructArray(int n, int k) {\\n    vector<int> ret(n);\\n    int d = n - 1;\\n    int c = 1;\\n    bool low = true;\\n    int idx = 0;\\n    ret[idx++] = c;\\n    for (int i = 0; i < k - 1; i++)\\n    {\\n        if (low) c += d--;\\n        else c -= d--;\\n        ret[idx++] = c;\\n        low = !low;\\n    }\\n    for (int i = k; i < n; i++)\\n    {\\n        if (low) c++;\\n        else c--;\\n        ret[idx++] = c;\\n    }\\n    return ret;\\n}\\n```\\n\\n**Edit:**\\nI even tried alexander's \"[Clean Code 4-liner](https://discuss.leetcode.com/topic/101113/c-java-clean-code-4-liner)\" solution and it takes over 8 times as long, mostly spent in vector-realloc.\\n\\n**Edit 2:**\\nOk so I just resubmitted this code as-is and it was accepted... Wouldn't have impacted my ranking in the contest much, but still I'd like to know what might have caused TLE in the first place.  In case it matters, my submissions were all within about 10 minutes of the end of the contest.",
                "solutionTags": [],
                "code": "```\\nvector<int> constructArray(int n, int k) {\\n    vector<int> ret(n);\\n    int d = n - 1;\\n    int c = 1;\\n    bool low = true;\\n    int idx = 0;\\n    ret[idx++] = c;\\n    for (int i = 0; i < k - 1; i++)\\n    {\\n        if (low) c += d--;\\n        else c -= d--;\\n        ret[idx++] = c;\\n        low = !low;\\n    }\\n    for (int i = k; i < n; i++)\\n    {\\n        if (low) c++;\\n        else c--;\\n        ret[idx++] = c;\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1932932,
                "title": "c-java-0ms-o-n-time-complexity-100-simple-solution-easy-understanding",
                "content": "Pls upvote(\\uD83E\\uDD7A\\uD83D\\uDE48\\uD83D\\uDE0C). If you found it useful,\\nplease comment for any doubts, will be happy to reply\\n\\nLanguages : C++, Java\\n\\nSolution : \\nFor generating unique difference between subsequent elements we have to generate elements in a zig zag manner\\n\\nfor n = 6  -> 1, 6, 2, 5, 3, 4 \\n\\nNo we want only k < n unique difference between subsequent elements.\\nFor this we generate same difference between subsqeuent elements n - k times and then generate k unique difference between subsequent elements from there on.\\n\\nSee the comments\\nC++\\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        int diff = n - k;\\n        int lo = 1;\\n        int hi = n;\\n        vector<int> out;\\n        int i = 0; \\n\\t\\t// we generate a difference of 1 between subsequent elements for the first n-k times.\\n        while(i < diff){\\n            out.push_back(lo);\\n            lo++;\\n            i++;\\n        }\\n        bool flag = true;\\n\\t\\t//Now we go zig zag to generate k unique differences, the last one will be automatically taken care\\n\\t\\t//as the difference between last two elements will be one which we have already generated above.\\n        for(int i = out.size()   ; i < n ; i++){\\n           //flag to alternatively zig zag\\n\\t\\t   if(flag){\\n                out.push_back(hi);\\n                hi--;\\n                flag = false;\\n            }\\n            else{\\n                out.push_back(lo);\\n                lo++;\\n                flag = true;\\n            }\\n        }\\n        return out;\\n    }\\n};\\n```\\n\\nJava\\n\\n```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int diff = n - k;\\n        int lo = 1;\\n        int hi = n;\\n        int[] out = new int[n];\\n        int i = 0; \\n\\t\\t// we generate a difference of 1 between subsequent elements for the first n-k times.\\n        while(i < diff){\\n            out[i] = lo;\\n            lo++;\\n            i++;\\n        }\\n        boolean flag = true;\\n\\t\\t//Now we go zig zag to generate k unique differences, the last one will be automatically taken care\\n\\t\\t//as the difference between last two elements will be one which we have already generated above.\\n        for( ; i < n ; i++){\\n\\t\\t\\t//flag to alternatively zig zag\\n            if(flag){\\n                out[i] = hi;\\n                hi--;\\n                flag = false;\\n            }\\n            else{\\n                out[i] = lo;\\n                lo++;\\n                flag = true;\\n            }\\n        }\\n        return out;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        int diff = n - k;\\n        int lo = 1;\\n        int hi = n;\\n        vector<int> out;\\n        int i = 0; \\n\\t\\t// we generate a difference of 1 between subsequent elements for the first n-k times.\\n        while(i < diff){\\n            out.push_back(lo);\\n            lo++;\\n            i++;\\n        }\\n        bool flag = true;\\n\\t\\t//Now we go zig zag to generate k unique differences, the last one will be automatically taken care\\n\\t\\t//as the difference between last two elements will be one which we have already generated above.\\n        for(int i = out.size()   ; i < n ; i++){\\n           //flag to alternatively zig zag\\n\\t\\t   if(flag){\\n                out.push_back(hi);\\n                hi--;\\n                flag = false;\\n            }\\n            else{\\n                out.push_back(lo);\\n                lo++;\\n                flag = true;\\n            }\\n        }\\n        return out;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int diff = n - k;\\n        int lo = 1;\\n        int hi = n;\\n        int[] out = new int[n];\\n        int i = 0; \\n\\t\\t// we generate a difference of 1 between subsequent elements for the first n-k times.\\n        while(i < diff){\\n            out[i] = lo;\\n            lo++;\\n            i++;\\n        }\\n        boolean flag = true;\\n\\t\\t//Now we go zig zag to generate k unique differences, the last one will be automatically taken care\\n\\t\\t//as the difference between last two elements will be one which we have already generated above.\\n        for( ; i < n ; i++){\\n\\t\\t\\t//flag to alternatively zig zag\\n            if(flag){\\n                out[i] = hi;\\n                hi--;\\n                flag = false;\\n            }\\n            else{\\n                out[i] = lo;\\n                lo++;\\n                flag = true;\\n            }\\n        }\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1506737,
                "title": "java-solution-constant-space-simple-approach",
                "content": "Suppose n = 6, k = 4\\nWe will form array as :\\narr[0] = 1,\\narr[1] = 1 + k(=4) = 5, and k--,\\narr[2] =  5 - k(=3) = 2, and k--,\\narr[3] = 2 + k(=2)= 4,  and k--,\\narr[4] = 4 - k(=1) = 3, and k-- (Here k = 0) after this we will fill remaining numbers normally\\narr[5] = 6\\nSo array formed : [1, 5, 2, 4, 3, 6] after following operation it will be [4, 3, 2, 1, 3] which contains exactly 4 distinct numbers.\\n```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] arr = new int[n];\\n        arr[0] = 1;\\n        int x = 1 + k;\\n        for(int i=1 ; i<arr.length ; i++){\\n            arr[i] = (k <= 0) ? ++x : (i % 2 == 0) ? arr[i-1] - k : arr[i-1] + k;\\n            k--;\\n        }\\n        return arr;\\n    }\\n}\\n```\\nTime Complexity : O(n)\\nAuxiliary Space : O(1)\\n**Please upvote if you like the implementation**\\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] arr = new int[n];\\n        arr[0] = 1;\\n        int x = 1 + k;\\n        for(int i=1 ; i<arr.length ; i++){\\n            arr[i] = (k <= 0) ? ++x : (i % 2 == 0) ? arr[i-1] - k : arr[i-1] + k;\\n            k--;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425775,
                "title": "c-no-logic-just-observed-a-pattern-must-see",
                "content": "**Pattern :**\\n1) Start with \"1\"\\n2) Firstly add \"k\" to the previous element of array and store it.\\n3)  Secondly subtract \"k-1\" to the previous element of array and store it.\\n4)  Do this until adding or subtracting number reaches 1.\\n5)  store remaining number starting from arr[1]+1 in increasing order until its size becomes equal to n.\\n\\nex:-\\n\\n![image](https://assets.leetcode.com/users/images/aee08608-0a72-4d93-857f-2142ece5c9d2_1629904655.7689116.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int> &ans, int k, bool takePositive){\\n        if(k == 0)\\n            return;\\n        takePositive ? ans.push_back(ans[ans.size()-1] + k) : ans.push_back(ans[ans.size()-1] - k);\\n        helper(ans, k-1, !takePositive);\\n    }\\n    \\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans;\\n        ans.push_back(1);\\n        helper(ans,k,true);\\n        int c = n - ans.size();\\n        int a = ans[1]+1;\\n        while(c--)\\n            ans.push_back(a++);\\n        \\n        return ans;\\n    }\\n};\\n```\\nI hope you will like this..... if yes then pls upvote...... explain karne me itni mehnat pehli baar ki he XD",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int> &ans, int k, bool takePositive){\\n        if(k == 0)\\n            return;\\n        takePositive ? ans.push_back(ans[ans.size()-1] + k) : ans.push_back(ans[ans.size()-1] - k);\\n        helper(ans, k-1, !takePositive);\\n    }\\n    \\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans;\\n        ans.push_back(1);\\n        helper(ans,k,true);\\n        int c = n - ans.size();\\n        int a = ans[1]+1;\\n        while(c--)\\n            ans.push_back(a++);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154776,
                "title": "python-deque",
                "content": "# Idea\\nConsecutively use the smallest and largest available numbers from a deque of [1, 2, ... n] to form your unique pairs. You\\'ll get a sequence n-1, n-2, n-3, etc. Stop when you hit k-1. Then fill the rest with consecutive values which will all have a difference of 1. This will get you k unique values.\\n\\nP.S. you don\\'t really need a deque, just need the left and right pointers.\\n```\\ndef constructArray(self, n: int, k: int) -> List[int]:\\n\\tdq = deque(range(1, n+1))\\n\\tres = []\\n\\tfor i in range(k):\\n\\t\\tpop = dq.popleft if i & 1 else dq.pop\\n\\t\\tres.append(pop())\\n\\tres.extend(reversed(dq) if k & 1 else dq)  # to make sure the diff stays 1\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\ndef constructArray(self, n: int, k: int) -> List[int]:\\n\\tdq = deque(range(1, n+1))\\n\\tres = []\\n\\tfor i in range(k):\\n\\t\\tpop = dq.popleft if i & 1 else dq.pop\\n\\t\\tres.append(pop())\\n\\tres.extend(reversed(dq) if k & 1 else dq)  # to make sure the diff stays 1\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 510428,
                "title": "java-solution-with-explanation",
                "content": "1. For the first k elements, we arrange in the following way:\\n```1, k + 1, 2, k, 3, k - 1, ....```\\n2. For the remaining elements, we set ```a[i] = i + 1```, for `i = k + 1, ....,n`\\n\\n```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] res = new int[n];\\n        for(int i = 0; i < k + 1; ++i) {\\n            res[i] = (i % 2 == 0) ? i / 2 + 1 : k + 1 - (i - 1) / 2;\\n        }\\n        for(int i = k + 1; i < n; ++i) {\\n            res[i] = i + 1;\\n        }\\n        return res;    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```1, k + 1, 2, k, 3, k - 1, ....```\n```a[i] = i + 1```\n```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] res = new int[n];\\n        for(int i = 0; i < k + 1; ++i) {\\n            res[i] = (i % 2 == 0) ? i / 2 + 1 : k + 1 - (i - 1) / 2;\\n        }\\n        for(int i = k + 1; i < n; ++i) {\\n            res[i] = i + 1;\\n        }\\n        return res;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325975,
                "title": "java-beats-100-with-explanation",
                "content": "1. Arrange first k+1 elements to obtain k different distinct numbers:\\n\\t  ex. For (k = 5, n = 9) the first 6 numbers will be: [1, 6, 2, 5, 3, 4]. This will result in 5 distinct integers: [5, 4, 3, 2, 1]\\n2. For the rest of them (from k+1 to n), we can just add them to the result in increasing order which will give us 1 all the way.\\n3. The final result will be for k=5, n=9 : [1, 6, 2, 5, 3, 4, 7, 8, 9]\\n\\n```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] result = new int[n];\\n        \\n        int index = 0;\\n        int x = 1, y = k+1;\\n            \\n        while (x <= y) {\\n            result[index++] = x++;\\n                \\n            if (x < y) {\\n                result[index++] = y--;\\n            }\\n        }\\n        \\n        for (int i=index+1; i<=n; i++) {\\n            result[index++] = i;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] result = new int[n];\\n        \\n        int index = 0;\\n        int x = 1, y = k+1;\\n            \\n        while (x <= y) {\\n            result[index++] = x++;\\n                \\n            if (x < y) {\\n                result[index++] = y--;\\n            }\\n        }\\n        \\n        for (int i=index+1; i<=n; i++) {\\n            result[index++] = i;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695730,
                "title": "best-c-solution-easy-approach",
                "content": "Dry run the code and you can understand the logic. \\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans;\\n        int i = 1, j = n;\\n        while(i<=j)\\n        {\\n            if(k>1)\\n                ans.push_back( (k--)%2 ? i++ : j--); \\n            else\\n                ans.push_back(i++);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans;\\n        int i = 1, j = n;\\n        while(i<=j)\\n        {\\n            if(k>1)\\n                ans.push_back( (k--)%2 ? i++ : j--); \\n            else\\n                ans.push_back(i++);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317091,
                "title": "667-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create an empty list called \"ans\".\\n\\n2. Add integers 1 through (n-k) to the \"ans\" list using the range() function.\\n\\n3. For each value of i in the range of 0 to k-1:\\na. Calculate the difference between i and the nearest even number using the floor division operator \"//\". This value represents the distance of the current element from the previous element in the result array.\\nb. If i is even, append the value n minus the calculated difference plus 1 to the \"ans\" list. This will ensure that the difference between this value and the previous value is equal to the difference calculated in step 3a.\\nc. If i is odd, append the value n-k plus the calculated difference to the \"ans\" list. This will ensure that the difference between this value and the previous value is equal to the difference calculated in step 3a.\\n\\n4. Return the \"ans\" list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def constructArray(self, n: int, k: int) -> List[int]:\\n    ans = list(range(1, n - k + 1))\\n    for i in range(k):\\n        diff = i // 2 + 1\\n        if i % 2 == 0:\\n            ans.append(n - diff + 1)\\n        else:\\n            ans.append(n - k + diff)\\n\\n    return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n  def constructArray(self, n: int, k: int) -> List[int]:\\n    ans = list(range(1, n - k + 1))\\n    for i in range(k):\\n        diff = i // 2 + 1\\n        if i % 2 == 0:\\n            ans.append(n - diff + 1)\\n        else:\\n            ans.append(n - k + diff)\\n\\n    return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929174,
                "title": "simple-java-solution-beats-96-46",
                "content": "# Intuition\\nPattern for first k position is { n , arr[i-1]-(n-i) , arr[i-1]+(n-i) , arr[i-1]-(n-i)......... and so on }\\n\\nPattern after k postion is (arr[i-1] +/- 1) , depending whether the last position was a addition or subtraction\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n\\n        int num=-1;\\n        int[] res = new int[n];\\n        res[0]=n;\\n        for(int i=1;i<n;i++){\\n            if(i<k){\\n                if(num>0){    \\n                    res[i]=res[i-1]+(n-i);\\n                    num*=-1;\\n                }else{\\n                    res[i]=res[i-1]-(n-i);\\n                    num*=-1;\\n                }\\n            }else{\\n                res[i]=res[i-1]+num;\\n            }\\n        }\\n\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n\\n        int num=-1;\\n        int[] res = new int[n];\\n        res[0]=n;\\n        for(int i=1;i<n;i++){\\n            if(i<k){\\n                if(num>0){    \\n                    res[i]=res[i-1]+(n-i);\\n                    num*=-1;\\n                }else{\\n                    res[i]=res[i-1]-(n-i);\\n                    num*=-1;\\n                }\\n            }else{\\n                res[i]=res[i-1]+num;\\n            }\\n        }\\n\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2067848,
                "title": "greedy-simple-approach",
                "content": "```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int [] result = new int[n];\\n        result[0] = 1;\\n        int sign = 1;\\n        for(int i = 1 ; i < n; i++, k--){\\n            if(k > 0){\\n                result[i] = result[i-1] + k * sign;\\n                sign *= -1;\\n            }\\n            else{\\n                result[i] = i+1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int [] result = new int[n];\\n        result[0] = 1;\\n        int sign = 1;\\n        for(int i = 1 ; i < n; i++, k--){\\n            if(k > 0){\\n                result[i] = result[i-1] + k * sign;\\n                sign *= -1;\\n            }\\n            else{\\n                result[i] = i+1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332481,
                "title": "java-array-0ms-beats-100-t-c-o-n-s-c-n",
                "content": "\\n\\n\\t// O(n) O(n)\\n\\tpublic int[] constructArray(int n, int k) {\\n\\n\\t\\tint[] ans = new int[n];\\n\\t\\tint small = 1, big = n, idx = 0;\\n\\n\\t\\tfor (int i = 0; i < k - 1; i += 2) {\\n\\t\\t\\tans[idx++] = small++;\\n\\t\\t\\tans[idx++] = big--;\\n\\t\\t}\\n\\n\\t\\tint diff = n - k;\\n\\t\\tif (k % 2 != 0) {\\n\\t\\t\\tfor (int i = 0; i <= diff; i++)\\n\\t\\t\\t\\tans[idx++] = small++;\\n\\t\\t} else {\\n\\t\\t\\tidx--;\\n\\t\\t\\tbig++;\\n\\t\\t\\tfor (int i = 0; i <= diff; i++)\\n\\t\\t\\t\\tans[idx++] = big--;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n\\n\\t// O(n) O(n)\\n\\tpublic int[] constructArray(int n, int k) {\\n\\n\\t\\tint[] ans = new int[n];\\n\\t\\tint small = 1, big = n, idx = 0;\\n\\n\\t\\tfor (int i = 0; i < k - 1; i += 2) {\\n\\t\\t\\tans[idx++] = small++;\\n\\t\\t\\tans[idx++] = big--;\\n\\t\\t}\\n\\n\\t\\tint diff = n - k;\\n\\t\\tif (k % 2 != 0) {\\n\\t\\t\\tfor (int i = 0; i <= diff; i++)\\n\\t\\t\\t\\tans[idx++] = small++;\\n\\t\\t} else {\\n\\t\\t\\tidx--;\\n\\t\\t\\tbig++;\\n\\t\\t\\tfor (int i = 0; i <= diff; i++)\\n\\t\\t\\t\\tans[idx++] = big--;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1157211,
                "title": "c-single-pass-solution-explained-100-time-98-space",
                "content": "This problem is made of 2 challenges: spotting what kind of pattern might work for each kind of input and finding out how. to generate it efficiently.\\n\\nFor the first part, let\\'s start with 2 edge cases for `n == 10`; first with `k == 1`, so every number is at the same distance and then we will have:\\n\\n```cpp\\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10\\n```\\n\\nSecond case with the opposite - `k == 9`, so we have to create `9` pairs of numbers with different distances like this:\\n\\n```cpp\\n1, 10, 2, 9, 3, 8, 4, 7, 5, 6\\n```\\n\\nSeen a pattern here? If not yet, let\\'s try with `k == 5`:\\n\\n```cpp\\n1, 6, 2, 5, 3, 4, 7, 8, 9, 10\\n```\\n\\nIt looks like if all we need is the same homogeneous distance, we then can just leave the numbers in their increasing order (of course, since they are all equal to the previous `+ 1`, by definition); if we need more groups, then we need to swap a few more and so that usually the first one is always `1`, the second is equal to `1 + k`, the third (if we swapped) is equal to `2`, followed by `2 + k - 2` and so on - as long as we can go, always decreasing `k` by `2` at each step and then summing it to the previous number; once we have consumed `k`, all we can do is just progress and put the remaining numbers in, in their natural order.\\n\\nNow, the harder part is going to code it all efficiently and possibly elegantly as well.\\n\\nTo do so, we will first of all start declaring the support variable `res`, already properly sized to avoid reallocations.\\n\\nNext, we are going to populate it running across it with the pointer `i`, initialised to `0`, while also using `v`, initialised to `1`; at each step we will:\\n* if `k-- <= 0`, which means we have \"consumed\" `k`, we will just set the current cell to be `i + 1` (its \"normal\", non shuffled value) - note that also makes it so we keep decreasing `k` by `2` at each usage, as discussed above;\\n* if otherwise we are on an odd value of `i` (ie: `i & 1`), we will assign it the value of `v` and still increase it;\\n* in all the other cases we will give it value of `k + v + 1`\\n\\nOnce done, we can `return res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> res(n);\\n        for (int i = 0, v = 1; i < n; i++) {\\n            res[i] = k-- <= -1 ? i + 1 : !(i & 1) ? v++ : k + v + 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```cpp\\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10\\n```\n```cpp\\n1, 10, 2, 9, 3, 8, 4, 7, 5, 6\\n```\n```cpp\\n1, 6, 2, 5, 3, 4, 7, 8, 9, 10\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> res(n);\\n        for (int i = 0, v = 1; i < n; i++) {\\n            res[i] = k-- <= -1 ? i + 1 : !(i & 1) ? v++ : k + v + 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446022,
                "title": "javascript",
                "content": "\\n\\n```\\nvar constructArray = function(n, k) {\\n\\n    let a = Array.from(Array(n).keys()).map( a => a + 1);\\n    if(k ===1) return a;\\n\\n    const len = a.length;\\n\\n    for(let i=2;i<= k;i++) {\\n        let x = a.slice( len - i + 1 ,len);\\n        let y = a.slice(0, len - i + 1);\\n        a = [...y.reverse(),...x];\\n    }\\n    return a;\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar constructArray = function(n, k) {\\n\\n    let a = Array.from(Array(n).keys()).map( a => a + 1);\\n    if(k ===1) return a;\\n\\n    const len = a.length;\\n\\n    for(let i=2;i<= k;i++) {\\n        let x = a.slice( len - i + 1 ,len);\\n        let y = a.slice(0, len - i + 1);\\n        a = [...y.reverse(),...x];\\n    }\\n    return a;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 306337,
                "title": "arrange-the-first-k-elements-easy-java-solution-with-explanation",
                "content": "We can arrange the first k elements that there difference is n-1, n-2, etc, and there are k-1 unique difference now, then we can make the k-th difference as 1.\\neg. n = 7, k = 4\\n(1) make the first k elements starting from 1 (beacuase only 1 and n can form \\'n-1\\' difference)\\n1, 7, 2, 6\\n(2) now there are 3 unique difference (6,5,4), we then set all other difference as 1\\n1, 7, 2, 6, 5, 4, 3\\n\\n```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] res = new int[n];\\n        boolean[] visited = new boolean[n + 1];\\n        //ensure the first k number has k-1 unique difference\\n        int count = k;\\n        int diff = n - 1;\\n        res[0] = 1;\\n        visited[1] = true;\\n        for (int i = 1; i < k; i++) {\\n            if (res[i-1] + diff > 0 && res[i-1] + diff <= n && !visited[res[i-1]+diff])\\n                res[i] = res[i-1] + diff;\\n            else\\n                res[i] = res[i-1] - diff;\\n            diff--;\\n            visited[res[i]] = true;\\n        }\\n        //for the rest numbers, let the difference as 1\\n        for (int i = k; i < n; i++) {\\n            if (res[i-1] + 1 > n || visited[res[i-1] + 1]) \\n                res[i] = res[i-1] - 1;\\n            else \\n                res[i] = res[i-1] + 1;\\n            visited[res[i]] = true;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] res = new int[n];\\n        boolean[] visited = new boolean[n + 1];\\n        //ensure the first k number has k-1 unique difference\\n        int count = k;\\n        int diff = n - 1;\\n        res[0] = 1;\\n        visited[1] = true;\\n        for (int i = 1; i < k; i++) {\\n            if (res[i-1] + diff > 0 && res[i-1] + diff <= n && !visited[res[i-1]+diff])\\n                res[i] = res[i-1] + diff;\\n            else\\n                res[i] = res[i-1] - diff;\\n            diff--;\\n            visited[res[i]] = true;\\n        }\\n        //for the rest numbers, let the difference as 1\\n        for (int i = k; i < n; i++) {\\n            if (res[i-1] + 1 > n || visited[res[i-1] + 1]) \\n                res[i] = res[i-1] - 1;\\n            else \\n                res[i] = res[i-1] + 1;\\n            visited[res[i]] = true;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142346,
                "title": "short-java-solution-with-explaination",
                "content": "From observation, for the first K+1 items in the result array should be like this: start from 1 as ans[0],  then ans[1] = ans[0]+k, ans[2] = ans[1]-(k-1), ans[3] = ans[2]+(k-1-1),...ans[i] = ans[i-1]+0...\\nThe sign flips each time until 0, and afterward, all the difference between two adjacent items could be 1, that is ans[i] = i+1. Here comes the code:\\n```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] ans = new int[n];\\n        ans[0] = 1;\\n        int v = k;\\n        int sign = 1;\\n        for(int i = 1; i < n; i++) {\\n            if(k == 1 || v == 0){\\n                ans[i] = i+1;\\n                continue;\\n            }          \\n            ans[i] = ans[i-1] + v*sign;\\n            v--;\\n            sign = -sign;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] ans = new int[n];\\n        ans[0] = 1;\\n        int v = k;\\n        int sign = 1;\\n        for(int i = 1; i < n; i++) {\\n            if(k == 1 || v == 0){\\n                ans[i] = i+1;\\n                continue;\\n            }          \\n            ans[i] = ans[i-1] + v*sign;\\n            v--;\\n            sign = -sign;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872672,
                "title": "clean-and-intuitive-greedy-approach",
                "content": "consider \\n\\n1,2,3,4,5\\n\\nhere you can see that the number of unique differences is 1\\n\\nconsider \\n\\n5 1 2 4 3\\n\\nhere the number of unique difference is n-1\\n\\nwell these two examples give a big hint\\n\\ntill k>1, everytime make a new diferrence\\n\\nthen simply use the the digits to make a difference of exact 1\\n\\ndry run to understand better\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        return util1(n,k);\\n    }\\n    public int[] util1(int n, int k) {\\n        int left = 1, right = n;\\n        int ans[] = new int[n];\\n        int a = 0;\\n        while (k != 1) {\\n            if (a % 2 == 0) {\\n                ans[a] = right;\\n                right--;\\n            } else {\\n                ans[a] = left;\\n                left++;\\n            }\\n            a++;\\n            k--;\\n        }\\n\\n        if (a % 2 == 0) {\\n            while (right >= left) {\\n                ans[a] = right;\\n                right--;\\n                a++;\\n            }\\n        } else {\\n            while (right >= left) {\\n                ans[a] = left;\\n                left++;\\n                a++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\n    \\n",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        return util1(n,k);\\n    }\\n    public int[] util1(int n, int k) {\\n        int left = 1, right = n;\\n        int ans[] = new int[n];\\n        int a = 0;\\n        while (k != 1) {\\n            if (a % 2 == 0) {\\n                ans[a] = right;\\n                right--;\\n            } else {\\n                ans[a] = left;\\n                left++;\\n            }\\n            a++;\\n            k--;\\n        }\\n\\n        if (a % 2 == 0) {\\n            while (right >= left) {\\n                ans[a] = right;\\n                right--;\\n                a++;\\n            }\\n        } else {\\n            while (right >= left) {\\n                ans[a] = left;\\n                left++;\\n                a++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437501,
                "title": "short-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to generate a list of n distinct positive integers ranging from 1 to n such that the absolute differences of all adjacent pairs in the list have exactly k distinct integers. One way to achieve this is by starting with the list [1, 2, ..., n] and performing a certain number of swaps between adjacent elements.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can start with the list [1, 2, ..., n] and initialize two pointers, left and right, to 1 and n, respectively. Then, for each element of the answer list, we decide whether to pick the left or the right pointer, based on the value of k. If k > 1, we need to alternate between the two pointers in order to generate different absolute differences. If k == 1, we can simply use the left pointer for the remaining elements.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n), since we need to iterate over all n elements of the answer list.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(n), since we need to store the entire list.\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] answer = new int[n];\\n        int left = 1, right = n;\\n        int i = 0;\\n        while (i < n) {\\n            if (k > 1) {\\n                answer[i++] = (k % 2 == 0) ? right-- : left++;\\n                k--;\\n            } else {\\n                answer[i++] = left++;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] answer = new int[n];\\n        int left = 1, right = n;\\n        int i = 0;\\n        while (i < n) {\\n            if (k > 1) {\\n                answer[i++] = (k % 2 == 0) ? right-- : left++;\\n                k--;\\n            } else {\\n                answer[i++] = left++;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426867,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans;\\n        int i;\\n        for(i = 1; i <= n - k; i++)\\n        {\\n            ans.push_back(i);\\n        }\\n        int count = 0;\\n        for(int j = 0; j < k; j++)\\n        {\\n            if(j%2==0)\\n            ans.push_back(n-count), count++;\\n            else ans.push_back(i), i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n\\n        ans = list(range(1, n - k)) \\n        for i in range(k+1):\\n            if i % 2 == 0:\\n                ans.append(n-k + i//2)\\n            else:\\n                ans.append(n - i//2)\\n\\n        return ans\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int ans[]=new int[n];\\n        int low=1,high=n,index=0;\\n        boolean isHigh=false;\\n        ans[index++]=low++;\\n        while(k>1){\\n            ans[index++]=high--;\\n            k--;\\n            isHigh=true;\\n            if(k>1){\\n                ans[index++]=low++;\\n                k--;\\n                isHigh=false;\\n            }\\n        }\\n        while(index<n){\\n            if(isHigh) ans[index++]=high--;\\n            else ans[index++]=low++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans;\\n        int i;\\n        for(i = 1; i <= n - k; i++)\\n        {\\n            ans.push_back(i);\\n        }\\n        int count = 0;\\n        for(int j = 0; j < k; j++)\\n        {\\n            if(j%2==0)\\n            ans.push_back(n-count), count++;\\n            else ans.push_back(i), i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n\\n        ans = list(range(1, n - k)) \\n        for i in range(k+1):\\n            if i % 2 == 0:\\n                ans.append(n-k + i//2)\\n            else:\\n                ans.append(n - i//2)\\n\\n        return ans\\n```\n```Java []\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int ans[]=new int[n];\\n        int low=1,high=n,index=0;\\n        boolean isHigh=false;\\n        ans[index++]=low++;\\n        while(k>1){\\n            ans[index++]=high--;\\n            k--;\\n            isHigh=true;\\n            if(k>1){\\n                ans[index++]=low++;\\n                k--;\\n                isHigh=false;\\n            }\\n        }\\n        while(index<n){\\n            if(isHigh) ans[index++]=high--;\\n            else ans[index++]=low++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859211,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans(n);\\n        for (int i = 0, a = 1, z = k + 1; i <= k; i++)\\n            ans[i] = i % 2 ? z-- : a++;\\n        for (int i = k+1; i < n; i++)\\n            ans[i] = i + 1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans(n);\\n        for (int i = 0, a = 1, z = k + 1; i <= k; i++)\\n            ans[i] = i % 2 ? z-- : a++;\\n        for (int i = k+1; i < n; i++)\\n            ans[i] = i + 1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462649,
                "title": "easy-to-understand-o-n-c-two-pointer",
                "content": "class Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        \\n        vector<int> a(n,0);\\n        \\n        int i,j;\\n        for(i=0;i<n;i++)\\n            a[i] = i+1;\\n        \\n        if(k==1)\\n            return a;\\n        \\n        i=0;j=n-1;\\n        \\n        vector<int> res(n,0);\\n        \\n        int ind=0;\\n        int t=0; // insert from back  , t=1 -> inset from front\\n        \\n        while(k--){\\n            \\n            if(t==0)\\n             res[ind++] = a[j--];\\n            else\\n                res[ind++] = a[i++];\\n            \\n            t=t^1;\\n        }\\n        \\n        if(t){\\n            while(j>=i && j>=0)\\n                res[ind++] = a[j--];\\n        }\\n        else{\\n            while(i<=j && i<n)\\n                res[ind++] = a[i++];\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        \\n        vector<int> a(n,0);\\n        \\n        int i,j;\\n        for(i=0;i<n;i++)\\n            a[i] = i+1;\\n        \\n        if(k==1)\\n            return a;\\n        \\n        i=0;j=n-1;\\n        \\n        vector<int> res(n,0);\\n        \\n        int ind=0;\\n        int t=0; // insert from back  , t=1 -> inset from front\\n        \\n        while(k--){\\n            \\n            if(t==0)\\n             res[ind++] = a[j--];\\n            else\\n                res[ind++] = a[i++];\\n            \\n            t=t^1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2049214,
                "title": "python-find-pattern-with-explainations-tc-o-n-sc-o-n",
                "content": "I find a pattern to construct the list:\\n1. Construct a list of ```1, 2, ..., n-k```\\n2. Append```(n-k)``` **+** ```k```\\n3. Append```(n-k)+k``` **-** ```(k-1)```\\n4. Append```(n-k)+k - (k-1)``` **+** ```(k-2)```\\n5. Reapt the above steps until we append ```k``` numbers (the total length of ```res``` is ```n```) \\nI personally think this question isn\\'t interesting. We can use ```sign``` to determine ```+``` or ```-```. Also you can refer to the example in the comment of the code.\\n```\\n        n = 8, k = 5\\n        1 2 3 8 4 7 5 6\\n        1 1 5 4 3 2 1\\n```\\n```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        # n = 8, k = 5\\n        # 1 2 3 8 4 7 5 6\\n        # 1 1 5 4 3 2 1\\n        res = list(range(1,n-k+1))\\n        sign, val = 1, k\\n        for i in range(k):\\n            res.append(res[-1]+sign*val)\\n            sign *= -1\\n            val -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```1, 2, ..., n-k```\n```(n-k)```\n```k```\n```(n-k)+k```\n```(k-1)```\n```(n-k)+k - (k-1)```\n```(k-2)```\n```k```\n```res```\n```n```\n```sign```\n```+```\n```-```\n```\\n        n = 8, k = 5\\n        1 2 3 8 4 7 5 6\\n        1 1 5 4 3 2 1\\n```\n```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        # n = 8, k = 5\\n        # 1 2 3 8 4 7 5 6\\n        # 1 1 5 4 3 2 1\\n        res = list(range(1,n-k+1))\\n        sign, val = 1, k\\n        for i in range(k):\\n            res.append(res[-1]+sign*val)\\n            sign *= -1\\n            val -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881777,
                "title": "c-simple-logical-approach-and-code-100-faster-solution-75-5-space-efficient-then-rest",
                "content": "**Approach** - Lets keep the solution as simple as possible.So let us consider the k differences be 1,2,3,4.... upto k which would surely yeild a valid solution.\\nNow as k < n the only number which can be included in all valid adjacent differences is 1 (as if n= 8 and k = 7  only 1 and 8 can give that difference ).So we start constructing our ans from 1.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int>a;\\n\\t\\t//filling rest numbers which only constitute adjacent absolute differnce of 1 as k>=1\\n        for(int i=n;i>k;i--)\\n        {\\n            a.push_back(i);\\n        }\\n\\t\\t//here the last element of a is k + 1 so start with a negative sign and alternate it for each value of k\\n        bool sign = 0;\\n        while(a.size()<n && k>0)\\n        {\\n            if(!sign)\\n            {\\n                a.push_back(a.back()-k);\\n                sign = 1;\\n            }\\n            else a.push_back(a.back()+k),sign = 0;\\n            k--;\\n        }\\n        return a;\\n    }\\n};\\n```\\n\\nTime Complexity - O(n) one time linear iteration for all indexes.\\nSpace Complexity - O(n) + k* O(1) = O(n)             //k is a constant.\\n\\nOpen for any suggestions/opinions...\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int>a;\\n\\t\\t//filling rest numbers which only constitute adjacent absolute differnce of 1 as k>=1\\n        for(int i=n;i>k;i--)\\n        {\\n            a.push_back(i);\\n        }\\n\\t\\t//here the last element of a is k + 1 so start with a negative sign and alternate it for each value of k\\n        bool sign = 0;\\n        while(a.size()<n && k>0)\\n        {\\n            if(!sign)\\n            {\\n                a.push_back(a.back()-k);\\n                sign = 1;\\n            }\\n            else a.push_back(a.back()+k),sign = 0;\\n            k--;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243480,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int nums[] = new int[n];\\n        nums[0] = 1;\\n        boolean flip = false;\\n        int init = k + 1;\\n        for(int i = 1 ; i < n ; i++) {\\n            if(k == 0) nums[i] = 1 + init++;\\n            else {\\n                if(flip) {\\n                    nums[i] = nums[i - 1] - k--;\\n                    flip = false;\\n                } else {\\n                    nums[i] = nums[i - 1] + k--; \\n                    flip = true;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int nums[] = new int[n];\\n        nums[0] = 1;\\n        boolean flip = false;\\n        int init = k + 1;\\n        for(int i = 1 ; i < n ; i++) {\\n            if(k == 0) nums[i] = 1 + init++;\\n            else {\\n                if(flip) {\\n                    nums[i] = nums[i - 1] - k--;\\n                    flip = false;\\n                } else {\\n                    nums[i] = nums[i - 1] + k--; \\n                    flip = true;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203958,
                "title": "c-2-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) \\n    {\\n        vector<int>v;\\n        int add=0;\\n        for(int i=1;i<=n-k;i++)\\n        {\\n            v.push_back(i);\\n        }\\n        int x=n-k+1,y=n;\\n        for(int i=0;i<k;i+=2)\\n        {\\n            v.push_back(y--);\\n            if(i+1<k)\\n                v.push_back(x++);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) \\n    {\\n        vector<int>v;\\n        int add=0;\\n        for(int i=1;i<=n-k;i++)\\n        {\\n            v.push_back(i);\\n        }\\n        int x=n-k+1,y=n;\\n        for(int i=0;i<k;i+=2)\\n        {\\n            v.push_back(y--);\\n            if(i+1<k)\\n                v.push_back(x++);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165029,
                "title": "observation-mechanical-steps-60-faster",
                "content": "1.start with 1always.\\n2.till k is not sufficed, alternate values of high and low are to be inserted viz. high starts from n and low starts from 2 (as 1 is defaulted as first element)\\n3.once done, we have to fill array till it reaches n, for that, whatever is the last element, if its from high, we keep on padding array with decrementing values of high\\n4.else if low, we keep on padding array with incrementing values of low.\\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n     vector<int> arr(n , 0);\\n     int high = n , low = 2,index = 0;\\n     bool isHigh = false;\\n     arr[index++] = 1;   \\n     while(k>1){\\n         arr[index++] = high--;\\n         isHigh = true;\\n         k--;\\n         if(k > 1){\\n             arr[index++]= low++;\\n             k--;\\n             isHigh=false;\\n         }\\n     }\\n     while(index < n){\\n         if(isHigh){\\n             arr[index++] = high--;\\n         }\\n         else{\\n             arr[index++] = low++;\\n         }\\n     }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n     vector<int> arr(n , 0);\\n     int high = n , low = 2,index = 0;\\n     bool isHigh = false;\\n     arr[index++] = 1;   \\n     while(k>1){\\n         arr[index++] = high--;\\n         isHigh = true;\\n         k--;\\n         if(k > 1){\\n             arr[index++]= low++;\\n             k--;\\n             isHigh=false;\\n         }\\n     }\\n     while(index < n){\\n         if(isHigh){\\n             arr[index++] = high--;\\n         }\\n         else{\\n             arr[index++] = low++;\\n         }\\n     }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158414,
                "title": "python3-greedy",
                "content": "\\n```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        lo, hi = 1, n \\n        ans = []\\n        while lo <= hi: \\n            if k&1: \\n                ans.append(lo)\\n                lo += 1\\n            else: \\n                ans.append(hi)\\n                hi -= 1\\n            if k > 1: k -= 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        lo, hi = 1, n \\n        ans = []\\n        while lo <= hi: \\n            if k&1: \\n                ans.append(lo)\\n                lo += 1\\n            else: \\n                ans.append(hi)\\n                hi -= 1\\n            if k > 1: k -= 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158069,
                "title": "c-greedy-solution",
                "content": "```\\n// Runtime: 4 ms, faster than 63.20% of C++ online submissions for Beautiful Arrangement II.\\n// Memory Usage: 7.8 MB, less than 28.80% of C++ online submissions for Beautiful Arrangement II.\\nvector<int> constructArray(int n, int k) {\\n\\tvector<int> res {};\\n\\tint i = 1, j = n;\\n\\twhile (i <= j) {\\n\\t\\tif (k > 0) {\\n\\t\\t\\tres.push_back(k-- % 2 ? i++ : j--);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tres.push_back(i++);\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n// Runtime: 4 ms, faster than 63.20% of C++ online submissions for Beautiful Arrangement II.\\n// Memory Usage: 7.8 MB, less than 28.80% of C++ online submissions for Beautiful Arrangement II.\\nvector<int> constructArray(int n, int k) {\\n\\tvector<int> res {};\\n\\tint i = 1, j = n;\\n\\twhile (i <= j) {\\n\\t\\tif (k > 0) {\\n\\t\\t\\tres.push_back(k-- % 2 ? i++ : j--);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tres.push_back(i++);\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1156151,
                "title": "java-solution-with-intuitive-proof",
                "content": "```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] res = new int[n];\\n        \\n        // [1..n-k] leave as it is, it may contains diff of 1, or contains no diff (i.e. 1 == n - k)\\n        // [n-k+1..n] jump between two ends, first jump is to the right end: right -> left -> right - 1 -> left + 1\\n        //            (a) each jump ensures a new diff (prev jump length - 1)\\n        //            (b) x jump ensures there\\'s x distinct diff \\n        //            (c) the last jump is always 1, so same diff as [1..n-k] if any\\n        //            Thus total # of distinct diff is x.  (here x = size of [n-k+1..n] = k)\\n        \\n        // fill out [1..n-k]\\n        for (int i = 1; i <= n-k; i++) {\\n            res[i-1] = i;\\n        }\\n        \\n        boolean increasing = false;\\n        int left = n - k + 1;\\n        int right = n;\\n        // fill out [n-k+1..n]\\n        for (int pos = n - k; pos < n; pos++) {\\n            if (!increasing) {\\n                res[pos] = right;\\n                right--;\\n            } else {\\n                res[pos] = left;\\n                left++;\\n            }\\n            increasing = !increasing;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] res = new int[n];\\n        \\n        // [1..n-k] leave as it is, it may contains diff of 1, or contains no diff (i.e. 1 == n - k)\\n        // [n-k+1..n] jump between two ends, first jump is to the right end: right -> left -> right - 1 -> left + 1\\n        //            (a) each jump ensures a new diff (prev jump length - 1)\\n        //            (b) x jump ensures there\\'s x distinct diff \\n        //            (c) the last jump is always 1, so same diff as [1..n-k] if any\\n        //            Thus total # of distinct diff is x.  (here x = size of [n-k+1..n] = k)\\n        \\n        // fill out [1..n-k]\\n        for (int i = 1; i <= n-k; i++) {\\n            res[i-1] = i;\\n        }\\n        \\n        boolean increasing = false;\\n        int left = n - k + 1;\\n        int right = n;\\n        // fill out [n-k+1..n]\\n        for (int pos = n - k; pos < n; pos++) {\\n            if (!increasing) {\\n                res[pos] = right;\\n                right--;\\n            } else {\\n                res[pos] = left;\\n                left++;\\n            }\\n            increasing = !increasing;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155675,
                "title": "rust-0ms-short-o-n",
                "content": "```rust\\nimpl Solution {\\n    pub fn construct_array(n: i32, k: i32) -> Vec<i32> {\\n        (1..=k + 1)\\n            .rev()\\n            .scan((k + 2, -1), |s, x| {\\n                s.0 += x * s.1;\\n                s.1 *= -1;\\n                Some(s.0)\\n            })\\n            .chain(k + 2..=n)\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn construct_array(n: i32, k: i32) -> Vec<i32> {\\n        (1..=k + 1)\\n            .rev()\\n            .scan((k + 2, -1), |s, x| {\\n                s.0 += x * s.1;\\n                s.1 *= -1;\\n                Some(s.0)\\n            })\\n            .chain(k + 2..=n)\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1155417,
                "title": "python-one-liner",
                "content": "nobody:\\nlist compehension:\\n```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        return [(i//2+1 if i%2==0 else k+1-i//2) for i in range(k+1)] + [i for i in range(k+2, n+1)]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        return [(i//2+1 if i%2==0 else k+1-i//2) for i in range(k+1)] + [i for i in range(k+2, n+1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155329,
                "title": "python-beats-99-33-short-and-straightforward-solution",
                "content": "```\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        l1 = list(range(1, n-k+1))\\n        l2 = deque(range(n-k+1, n+1))\\n        \\n        sub = []\\n\\t\\t# keep inserting the largest and smallest elements to fetch the required number\\n\\t\\t# of unique differences\\n        while l2:\\n            if l2:\\n                sub.append(l2.pop())\\n            if l2:\\n                sub.append(l2.popleft())\\n            \\n        return l1 + sub\\n```",
                "solutionTags": [],
                "code": "```\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        l1 = list(range(1, n-k+1))\\n        l2 = deque(range(n-k+1, n+1))\\n        \\n        sub = []\\n\\t\\t# keep inserting the largest and smallest elements to fetch the required number\\n\\t\\t# of unique differences\\n        while l2:\\n            if l2:\\n                sub.append(l2.pop())\\n            if l2:\\n                sub.append(l2.popleft())\\n            \\n        return l1 + sub\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1155305,
                "title": "c-simple-pattern-matching-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans(n);\\n        int odd=k+1;\\n        int even=1;\\n        for(int i=0;i<n;i++){\\n            ans[i]=i+1;\\n        }\\n        for(int i=0;i<=k;i++){\\n            if(i%2==0){\\n                ans[i]=even;\\n                even++;\\n            }\\n            else{\\n                ans[i]=odd;\\n                odd--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans(n);\\n        int odd=k+1;\\n        int even=1;\\n        for(int i=0;i<n;i++){\\n            ans[i]=i+1;\\n        }\\n        for(int i=0;i<=k;i++){\\n            if(i%2==0){\\n                ans[i]=even;\\n                even++;\\n            }\\n            else{\\n                ans[i]=odd;\\n                odd--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155297,
                "title": "simple-o-n-python-solution",
                "content": "Recognized this pattern after observing multiple test cases.\\n1. Have a visited array initialised to FALSE. Start with \\'1\\' then find x = last_value + k, then append x in result array.\\n2. Decrement k.\\n3. Then in next iteration, find x = last_value - k. then append x to result array.\\n4. After this, append all the values that are not visited.\\n```\\ndef constructArray(self, n: int, k: int) -> List[int]:\\n        result = [1]\\n        visited = [False for i in range(n+1)]\\n        visited[1] = True\\n        flag = True\\n        while k-1:\\n            a = abs(result[-1] + k)\\n            b = abs(result[-1] - k)\\n            if flag:\\n                result.append(a)\\n                visited[a] = True\\n                flag = not flag\\n            else:\\n                result.append(b)\\n                visited[b] = True\\n                flag = not flag\\n            k -= 1\\n        for i in range(1, len(visited)):\\n            if not visited[i]:\\n                result.append(i)\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\ndef constructArray(self, n: int, k: int) -> List[int]:\\n        result = [1]\\n        visited = [False for i in range(n+1)]\\n        visited[1] = True\\n        flag = True\\n        while k-1:\\n            a = abs(result[-1] + k)\\n            b = abs(result[-1] - k)\\n            if flag:\\n                result.append(a)\\n                visited[a] = True\\n                flag = not flag\\n            else:\\n                result.append(b)\\n                visited[b] = True\\n                flag = not flag\\n            k -= 1\\n        for i in range(1, len(visited)):\\n            if not visited[i]:\\n                result.append(i)\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1155210,
                "title": "easy-idiomatic-go-solution-beats-100-0ms",
                "content": "```\\nfunc constructArray(n int, k int) []int {\\n\\tresult := make([]int, 0, n)\\n\\tleft, right := 1, n\\n\\tfor ; left < n-k; left++ {\\n\\t\\tresult = append(result, left)\\n\\t}\\n\\tfor i := 0; i <= k; i++ {\\n\\t\\tif i%2 == 0 {\\n\\t\\t\\tresult, left = append(result, left), left+1\\n\\t\\t} else {\\n\\t\\t\\tresult, right = append(result, right), right-1\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc constructArray(n int, k int) []int {\\n\\tresult := make([]int, 0, n)\\n\\tleft, right := 1, n\\n\\tfor ; left < n-k; left++ {\\n\\t\\tresult = append(result, left)\\n\\t}\\n\\tfor i := 0; i <= k; i++ {\\n\\t\\tif i%2 == 0 {\\n\\t\\t\\tresult, left = append(result, left), left+1\\n\\t\\t} else {\\n\\t\\t\\tresult, right = append(result, right), right-1\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1154883,
                "title": "beautiful-arrangement-c-fast-and-slow-pointer-approach-easy-best-explanation",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> constructArray(int n, int k) {\\n        \\n        //vector having the beautiful arrangement of numbers\\n        vector<int> result(n);\\n        \\n        //we are solving the array by dividing it into two parts \\n        // covering till k+1 and after that simply incrementing the number and storing it.\\n        for(int i = 0 , a = 1 , z = k+1 ; i <= k; i++)\\n        {\\n            \\n            //here we are dealing with the extremes and the maximum and unique differences can be calculated using the extremes only\\n            //for ex : [1,2,3,4,5]\\n            //max diff of 4 can be from (1,5) max diff of 3 can be from (1,4) OR (2,5)\\n            //max diff of 2 can be from (1,3) OR (2,5) and so on\\n            //here i%2 is being used to alternatively choose one extreme\\n            result[i] = i % 2 ? z-- : a++;\\n        }\\n        \\n        //after covering till k+1 elements we have found all the distinct differences and for the rest of elements of array , we can simply add them to the last\\n        for(int i = k+1; i < n; i++)\\n        {\\n            result[i] = i + 1;\\n        }\\n        \\n        //now return the resultant array\\n        return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> constructArray(int n, int k) {\\n        \\n        //vector having the beautiful arrangement of numbers\\n        vector<int> result(n);\\n        \\n        //we are solving the array by dividing it into two parts \\n        // covering till k+1 and after that simply incrementing the number and storing it.\\n        for(int i = 0 , a = 1 , z = k+1 ; i <= k; i++)\\n        {\\n            \\n            //here we are dealing with the extremes and the maximum and unique differences can be calculated using the extremes only\\n            //for ex : [1,2,3,4,5]\\n            //max diff of 4 can be from (1,5) max diff of 3 can be from (1,4) OR (2,5)\\n            //max diff of 2 can be from (1,3) OR (2,5) and so on\\n            //here i%2 is being used to alternatively choose one extreme\\n            result[i] = i % 2 ? z-- : a++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1154874,
                "title": "python-solution-o-n",
                "content": "Python Solution\\nTime Complexity : o(n)\\n```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        arr = [0] *n\\n        arr[0] = 1\\n        c = k \\n        for i in range(1,k+1):\\n            if i % 2 ==1:\\n                arr[i] = arr[i-1] +k\\n                k -= 1\\n            else:\\n                arr[i] = arr[i-1] -k\\n                k -= 1\\n        for i in range(c+1, n):\\n            arr[i] = i+1\\n        return arr\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        arr = [0] *n\\n        arr[0] = 1\\n        c = k \\n        for i in range(1,k+1):\\n            if i % 2 ==1:\\n                arr[i] = arr[i-1] +k\\n                k -= 1\\n            else:\\n                arr[i] = arr[i-1] -k\\n                k -= 1\\n        for i in range(c+1, n):\\n            arr[i] = i+1\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154729,
                "title": "c-o-n-1-k-1-2-k-2-3-k-3",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> res;\\n        int start = 1 , end = k+1;\\n        while(start < end){\\n            res.push_back(start++);\\n            res.push_back(end--);\\n        }\\n        if(start == end){\\n            res.push_back(start);\\n        }\\n        for(int i = k+2;i <= n;i++){\\n            res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> res;\\n        int start = 1 , end = k+1;\\n        while(start < end){\\n            res.push_back(start++);\\n            res.push_back(end--);\\n        }\\n        if(start == end){\\n            res.push_back(start);\\n        }\\n        for(int i = k+2;i <= n;i++){\\n            res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131232,
                "title": "c-easy-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> res(n);\\n        for(int i = 0;i<=k;i++)\\n        {\\n            if(i == 0)\\n            {\\n                res[i] = 1;\\n                continue;\\n            }\\n            if(i==1)\\n            {\\n                res[i] = k+1;\\n                continue;\\n            }\\n            if(i%2==0)\\n                res[i] = res[i-2]+1;\\n            else\\n                res[i] = res[i-2] -1; \\n        }\\n        for(int i = k+1;i<n;i++)\\n        {\\n            res[i] = i+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> res(n);\\n        for(int i = 0;i<=k;i++)\\n        {\\n            if(i == 0)\\n            {\\n                res[i] = 1;\\n                continue;\\n            }\\n            if(i==1)\\n            {\\n                res[i] = k+1;\\n                continue;\\n            }\\n            if(i%2==0)\\n                res[i] = res[i-2]+1;\\n            else\\n                res[i] = res[i-2] -1; \\n        }\\n        for(int i = k+1;i<n;i++)\\n        {\\n            res[i] = i+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109836,
                "title": "java-solution-easy-to-understand-explanation",
                "content": "We have 2 cases:\\n\\n1. k is 1 , this means that the only possible difference between 2 consecutive numbers is 1, so the answer is the array of consecutive numbers between 1 and n: [1,2,...,n]\\n2. k is greater than 1, this means we have to create k different differences in our array.\\n   The easiest way to do that is by creating 2 auxiliary numbers that will help us assign values in our array. At start, these 2 values are 1 and n. The idea is that for the even indexes we assign the lower value that increments at every even index, and for the odd indexes we assign the higher value that decrements at every odd index. By doing that, we make sure that the difference is always different between 2 consecutive numbers because it decrements at every index through the iteration. Here\\'s how:\\n\\tindex 0: 1\\n    index 1: n, the difference is n-1\\n   index 2: 2 (even index, so we increment), the difference is n-2\\n   index 3: n-1 (odd index, so we decrement), the difference is n-3.... and so on\\n   When we reach k-1 different differences, we stop the method above. The k-th different difference is 1, so that we can put in the array the unassigned values from the [1...n] interval. Depending on where we left the array, we start iterating and assign the rest of the array, decrementing if we left the array on an odd index, or incrementing if we left the array on an even index.\\n   \\n  ```\\n public int[] constructArray(int n, int k) {\\n        int[] rez=new int[n];\\n        if(k==1){\\n            for(int i=0;i<n;i++){\\n                rez[i]=i+1;\\n            }\\n            return rez;\\n        }\\n        int k1=2;\\n        int k2=n;\\n        int nr=0;\\n        rez[0]=1;\\n        int i=1;\\n        while(i<n){\\n            if(i%2==0){\\n                rez[i]=k1;\\n                k1++;\\n            }\\n            else{\\n                rez[i]=k2;\\n                k2--;\\n            }\\n            nr++;\\n            if(nr==k-1){\\n                break;\\n            }\\n            i++;\\n        }\\n        if(i%2==0){\\n            i++;\\n            while(i<n){\\n                rez[i]=rez[i-1]+1;\\n                i++;\\n            }\\n        }\\n        else{\\n            i++;\\n            while(i<n){\\n                rez[i]=rez[i-1]-1;\\n                i++;\\n            }\\n        }\\n        return rez;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int[] constructArray(int n, int k) {\\n        int[] rez=new int[n];\\n        if(k==1){\\n            for(int i=0;i<n;i++){\\n                rez[i]=i+1;\\n            }\\n            return rez;\\n        }\\n        int k1=2;\\n        int k2=n;\\n        int nr=0;\\n        rez[0]=1;\\n        int i=1;\\n        while(i<n){\\n            if(i%2==0){\\n                rez[i]=k1;\\n                k1++;\\n            }\\n            else{\\n                rez[i]=k2;\\n                k2--;\\n            }\\n            nr++;\\n            if(nr==k-1){\\n                break;\\n            }\\n            i++;\\n        }\\n        if(i%2==0){\\n            i++;\\n            while(i<n){\\n                rez[i]=rez[i-1]+1;\\n                i++;\\n            }\\n        }\\n        else{\\n            i++;\\n            while(i<n){\\n                rez[i]=rez[i-1]-1;\\n                i++;\\n            }\\n        }\\n        return rez;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1000759,
                "title": "java-short-clean-code-with-explanation",
                "content": "Keep last n - k values as they should be. \\u21D2 generating consecutive difference of 1\\nFill from k\\'th element to 1st element by alternately picking from increasing direction (1 to k) and decreasing direction (k to 1). \\u21D2 generating consecutive difference of k, k - 1, ... 3, 2, 1\\n\\n```\\npublic int[] constructArray(int n, int k) {\\n    int[] A = new int[n];\\n    for(int i = k; i < n; i++) A[i] = i + 1;\\n    for(int i = k - 1, val = 1; i >= 0; i -= 2) A[i] = val++;\\n    for(int i = k - 2, val = k; i >= 0; i -= 2) A[i] = val--;\\n    return A;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] constructArray(int n, int k) {\\n    int[] A = new int[n];\\n    for(int i = k; i < n; i++) A[i] = i + 1;\\n    for(int i = k - 1, val = 1; i >= 0; i -= 2) A[i] = val++;\\n    for(int i = k - 2, val = k; i >= 0; i -= 2) A[i] = val--;\\n    return A;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 968507,
                "title": "python-straightforward-and-intuitive-solution-with-comments-and-no-extra-space",
                "content": "**Intuition** :- So the main idea is to find the find a way to make all the unique differences and then just append the remaining numbers to form the answer list. One way to make all unique differences is to start from 1 and then make an alternating sequence which will exhaust all unique differences we need to make\\n\\n```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        res = []\\n        st = 1\\n        res.append(st)\\n        org_k = k\\n\\t\\t\\n\\t\\t# exhuasting the number of different differences that we have to make\\n        while(k != 0):\\n            st += k\\n            res.append(st)\\n            k = -(k-1) if k > 0 else -(k + 1)\\n\\t\\t\\t\\n\\t\\t# after we have exhausted unique differences just start with the lowest number that is still not included in the list\\n        new_num = org_k + 2\\n        while(new_num <= n):\\n            res.append(new_num)\\n            new_num += 1\\n        return res\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        res = []\\n        st = 1\\n        res.append(st)\\n        org_k = k\\n\\t\\t\\n\\t\\t# exhuasting the number of different differences that we have to make\\n        while(k != 0):\\n            st += k\\n            res.append(st)\\n            k = -(k-1) if k > 0 else -(k + 1)\\n\\t\\t\\t\\n\\t\\t# after we have exhausted unique differences just start with the lowest number that is still not included in the list\\n        new_num = org_k + 2\\n        while(new_num <= n):\\n            res.append(new_num)\\n            new_num += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 830242,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        int i=1,j=n;\\n        vector<int>ans;\\n        int f=-1;\\n        while(k){\\n            f=-1;\\n            if(k){\\n                ans.push_back(i);\\n                k--;\\n                i++;\\n                f=0;\\n            }\\n            if(k){\\n                ans.push_back(j);\\n                k--;\\n                j--;\\n                f=1;\\n            }\\n        }\\n        if(f==0){\\n            while(i<=j){\\n                ans.push_back(i);\\n                i++;\\n            }\\n        }else if(f==1){\\n            while(i<=j){\\n                ans.push_back(j);\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        int i=1,j=n;\\n        vector<int>ans;\\n        int f=-1;\\n        while(k){\\n            f=-1;\\n            if(k){\\n                ans.push_back(i);\\n                k--;\\n                i++;\\n                f=0;\\n            }\\n            if(k){\\n                ans.push_back(j);\\n                k--;\\n                j--;\\n                f=1;\\n            }\\n        }\\n        if(f==0){\\n            while(i<=j){\\n                ans.push_back(i);\\n                i++;\\n            }\\n        }else if(f==1){\\n            while(i<=j){\\n                ans.push_back(j);\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413583,
                "title": "simple-java-solution-o-n-with-explanation",
                "content": "1. If the integer array ranging from ```1``` to ```n```, the max possible diffenece is ```n-1```. \\n\\tThat is, ```ans = [1, n, 2, n-1, ..., n/2]```.\\n2. If we only want the result has exactly ```k``` distinct integer, the easiest way is to \\n\\t(1) Create an array from ```1``` to ```k+1``` which has max diffenece. \\n\\t(2) Attach the remaining numbers from ```k+2``` to ```n``` in the end of the result.\\n\\tThat is, ```ans = [1, k+1, 2, k, ..., k/2+1] + [k+2, k+3, ..., n]```.\\n\\n```\\n    public int[] constructArray(int n, int k) {\\n        int[] ans = new int[n];\\n        // Create an array from 1 to n\\n        for(int i = 0; i < n; i++) ans[i] = i+1;\\n        // Let the first k+1 element has the max difference\\n        for(int i = 0, j = 0; i <= k; j++) {\\n            ans[i++] = j+1;\\n            if(i <= k) ans[i++] = k-j+1;\\n        }\\n        return ans;\\n    }\\n```\\nTime: O(n)",
                "solutionTags": [],
                "code": "```1```\n```n```\n```n-1```\n```ans = [1, n, 2, n-1, ..., n/2]```\n```k```\n```1```\n```k+1```\n```k+2```\n```n```\n```ans = [1, k+1, 2, k, ..., k/2+1] + [k+2, k+3, ..., n]```\n```\\n    public int[] constructArray(int n, int k) {\\n        int[] ans = new int[n];\\n        // Create an array from 1 to n\\n        for(int i = 0; i < n; i++) ans[i] = i+1;\\n        // Let the first k+1 element has the max difference\\n        for(int i = 0, j = 0; i <= k; j++) {\\n            ans[i++] = j+1;\\n            if(i <= k) ans[i++] = k-j+1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 373036,
                "title": "c-easy-to-understand-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> result(n, 0);\\n        int sign = 1;\\n        result[0] = 1;\\n        for(int i = 1; i < n; i++) {\\n            if(k == 0) {\\n                result[i] = i + 1;\\n                continue;\\n            }\\n            result[i] = result[i - 1] + k * sign;\\n            sign *= -1;\\n            k--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> result(n, 0);\\n        int sign = 1;\\n        result[0] = 1;\\n        for(int i = 1; i < n; i++) {\\n            if(k == 0) {\\n                result[i] = i + 1;\\n                continue;\\n            }\\n            result[i] = result[i - 1] + k * sign;\\n            sign *= -1;\\n            k--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296235,
                "title": "c-a-simple-solution",
                "content": "```\\n\\nstatic const auto io_sync_off = [](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return nullptr;\\n}();\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k){         \\n         int l=2,r=n;\\n         vector<int> res; res.push_back(1);\\n         if(k==1){\\n             for(int i=l;i<=r;i++)\\n                 res.push_back(i);\\n             return res;             \\n         }\\n         int time=1;\\n         while(l<=r)\\n         {\\n             if(time&1)             \\n                 //\\u5947\\u6570\\n                 res.push_back(r--);\\n             else\\n                 res.push_back(l++);\\n             k--;\\n             time++;\\n             if(k==1){\\n                 if(time&1)\\n                 for(int i=l;i<=r;i++)\\n                 res.push_back(i);\\n                 else\\n                 for(int i=r;i>=l;i--)\\n                 res.push_back(i);\\n                 return res;          \\n             }                 \\n         }\\n         return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nstatic const auto io_sync_off = [](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return nullptr;\\n}();\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k){         \\n         int l=2,r=n;\\n         vector<int> res; res.push_back(1);\\n         if(k==1){\\n             for(int i=l;i<=r;i++)\\n                 res.push_back(i);\\n             return res;             \\n         }\\n         int time=1;\\n         while(l<=r)\\n         {\\n             if(time&1)             \\n                 //\\u5947\\u6570\\n                 res.push_back(r--);\\n             else\\n                 res.push_back(l++);\\n             k--;\\n             time++;\\n             if(k==1){\\n                 if(time&1)\\n                 for(int i=l;i<=r;i++)\\n                 res.push_back(i);\\n                 else\\n                 for(int i=r;i>=l;i--)\\n                 res.push_back(i);\\n                 return res;          \\n             }                 \\n         }\\n         return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291518,
                "title": "java-100-faster-98-less-memory",
                "content": "```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] res = new int[n];\\n        int left = 1, right = k + 1, i = 0;\\n        while (left < right) {\\n            res[i++] = left++;\\n            res[i++] = right--;\\n        }\\n        if (left == right) res[i++] = left;\\n        while (i < n) res[i++] = i;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] res = new int[n];\\n        int left = 1, right = k + 1, i = 0;\\n        while (left < right) {\\n            res[i++] = left++;\\n            res[i++] = right--;\\n        }\\n        if (left == right) res[i++] = left;\\n        while (i < n) res[i++] = i;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 153114,
                "title": "java-solution-with-odd-even",
                "content": "for array res[], supposing the index(short for i) is from 0 to n-1:\\n\\nif i is odd, res[i] increases from 1;\\nif i is even, res[i] decreases  from n;\\nhigh is the parameter **k**\\nif low reaches high, the low stops growing,\\n```\\n\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] res=new int[n];\\n        int low=1;\\n        int high=k;\\n        int poi=0;\\n        int l=1;\\n        int r=n;\\n\\n        for(int i=0;i<n;i++){\\n               if(low%2==0){ //even\\n                   res[poi++]=r--;\\n            }else{\\t//odd\\n                   res[poi++]=l++;\\n            }\\n               if(low < high){    \\n                   low++;\\n            }\\n        }\\n  return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] res=new int[n];\\n        int low=1;\\n        int high=k;\\n        int poi=0;\\n        int l=1;\\n        int r=n;\\n\\n        for(int i=0;i<n;i++){\\n               if(low%2==0){ //even\\n                   res[poi++]=r--;\\n            }else{\\t//odd\\n                   res[poi++]=l++;\\n            }\\n               if(low < high){    \\n                   low++;\\n            }\\n        }\\n  return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 131493,
                "title": "a-simple-c-solution-beats-100-00-12ms",
                "content": "// .1 2 3 4 5 6 7  distinct integers 1\\n// 7.1 2 3 4 5 6   distinct integers 6 1\\n// 7 1.6 5 4 3 2   distinct integers 6 5 1\\n// 7 1 6.2 3 4 5   distinct integers 6 5 4 1\\n//...\\n// 7 1 6 2 5 3 4.   distinct integers 6 5 4 3 2 1\\n\\nint* constructArray(int n, int k, int* returnSize) {\\n    *returnSize = n;\\n    int *resultArr = (int*)calloc(n,sizeof(int));\\n  \\n    for(int i = 0,right = n ; i< k/2    ; i++, right-- )\\n        resultArr[2*i] = right;\\n    \\n    for(int i = 0,left = 1 ; i< (k-1)/2 ; i++, left++ )\\n        resultArr[1 + 2*i] = left;\\n        \\n     for(int i= 0 ; i< n-k+1 ; i++){\\n         if(k % 2 == 0)//\\u5076\\u6570\\u6B63\\u5E8F\\n            resultArr[i+k-1] = i + (k+1)/2 ;\\n         else//\\u5947\\u6570\\u9006\\u5E8F\\n            resultArr[i+k-1] = n-i -k/2 ;\\n     }\\n    \\n    return resultArr;\\n    \\n}",
                "solutionTags": [],
                "code": "// .1 2 3 4 5 6 7  distinct integers 1\\n// 7.1 2 3 4 5 6   distinct integers 6 1\\n// 7 1.6 5 4 3 2   distinct integers 6 5 1\\n// 7 1 6.2 3 4 5   distinct integers 6 5 4 1\\n//...\\n// 7 1 6 2 5 3 4.   distinct integers 6 5 4 3 2 1\\n\\nint* constructArray(int n, int k, int* returnSize) {\\n    *returnSize = n;\\n    int *resultArr = (int*)calloc(n,sizeof(int));\\n  \\n    for(int i = 0,right = n ; i< k/2    ; i++, right-- )\\n        resultArr[2*i] = right;\\n    \\n    for(int i = 0,left = 1 ; i< (k-1)/2 ; i++, left++ )\\n        resultArr[1 + 2*i] = left;\\n        \\n     for(int i= 0 ; i< n-k+1 ; i++){\\n         if(k % 2 == 0)//\\u5076\\u6570\\u6B63\\u5E8F\\n            resultArr[i+k-1] = i + (k+1)/2 ;\\n         else//\\u5947\\u6570\\u9006\\u5E8F\\n            resultArr[i+k-1] = n-i -k/2 ;\\n     }\\n    \\n    return resultArr;\\n    \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 106944,
                "title": "2-methods-in-python-beat-95-49",
                "content": "first, reverse list in place, easy to code but slow, takes about 675ms:\\n```\\n    def constructArray(self, n, k):\\n        result = range(1, n + 1)\\n        for i in range(1, k):\\n            result[i:] = result[:i - 1:-1]\\n        return result\\n```\\nsecond, use deque, takes about 85ms, beat 95%:\\n```\\n    def constructArray2(self, n, k):\\n        from collections import deque\\n        src = deque(range(1, n + 1))\\n        dst = [src.pop() if i % 2 else src.popleft() for i in range(k)]\\n        if k % 2 == 0:\\n            src.reverse()\\n        dst.extend(src)\\n        return dst",
                "solutionTags": [],
                "code": "```\\n    def constructArray(self, n, k):\\n        result = range(1, n + 1)\\n        for i in range(1, k):\\n            result[i:] = result[:i - 1:-1]\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 106949,
                "title": "my-construction-use-7-as-example",
                "content": "Use 7 as an example, we can obtain some clue about the construction of the array.\\n7, 1\\n[1,2,3,4,5,6,7]  => [1,1,1,1,1,1]\\n\\n7,2\\n[1,7,6,5,4,3,2] => [6,1,1,1,1,1]\\n\\n7,3\\n[1,7,2,3,4,5,6] => [6,5,1,1,1,1]\\n\\n7,4\\n[1,7,2,6,5,4,3] => [6,5,4,1,1,1]\\n\\n7,5\\n[1,7,2,6,3,4,5] => [6,5,4,3,1,1]\\n\\n7,6\\n[1,7,2,6,3,5,4] => [6,5,4,3,2,1]\\n\\nBelow is my code implementation\\n```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] res = new int[n];\\n        int i, j = 1, m = n, s;\\n        for(i = 0; i < k; i ++) {\\n            if(i % 2 == 0) {\\n                res[i] = j;\\n                j ++;\\n            }\\n            else {\\n                res[i] = m;\\n                m --;\\n            }\\n        }\\n        s = i;\\n        if(s % 2 == 1) {\\n            for(s = i; s < n; s ++) {\\n                res[s] = j;\\n                j ++;\\n            }\\n        }\\n        else {\\n            for(s = i; s < n; s ++) {\\n                res[s] = m;\\n                m --;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] res = new int[n];\\n        int i, j = 1, m = n, s;\\n        for(i = 0; i < k; i ++) {\\n            if(i % 2 == 0) {\\n                res[i] = j;\\n                j ++;\\n            }\\n            else {\\n                res[i] = m;\\n                m --;\\n            }\\n        }\\n        s = i;\\n        if(s % 2 == 1) {\\n            for(s = i; s < n; s ++) {\\n                res[s] = j;\\n                j ++;\\n            }\\n        }\\n        else {\\n            for(s = i; s < n; s ++) {\\n                res[s] = m;\\n                m --;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106970,
                "title": "java-o-n-solution",
                "content": "    public int[] constructArray(int n, int k) {\\n        int[] ret = new int[n];\\n        int hi = n;\\n        int lo = 2;\\n        ret[0] = 1;\\n        boolean last_hi = false;\\n        for (int i = 1; i < n; i++) {\\n            if (k > 1) {\\n                if (!last_hi){\\n                    ret[i] = hi;\\n                    hi --;\\n                }\\n                else {\\n                    ret[i] = lo;\\n                    lo ++;\\n                }\\n                last_hi = !last_hi;\\n                k--;\\n            }\\n            else {\\n                if (last_hi) {\\n                    ret[i] = hi;\\n                    hi--;\\n                }\\n                else {\\n                    ret[i] = lo;\\n                    lo++;\\n                }\\n            }\\n        }\\n        return ret;\\n    }",
                "solutionTags": [],
                "code": "    public int[] constructArray(int n, int k) {\\n        int[] ret = new int[n];\\n        int hi = n;\\n        int lo = 2;\\n        ret[0] = 1;\\n        boolean last_hi = false;\\n        for (int i = 1; i < n; i++) {\\n            if (k > 1) {\\n                if (!last_hi){\\n                    ret[i] = hi;\\n                    hi --;\\n                }\\n                else {\\n                    ret[i] = lo;\\n                    lo ++;\\n                }\\n                last_hi = !last_hi;\\n                k--;\\n            }\\n            else {\\n                if (last_hi) {\\n                    ret[i] = hi;\\n                    hi--;\\n                }\\n                else {\\n                    ret[i] = lo;\\n                    lo++;\\n                }\\n            }\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4086550,
                "title": "java-o-n-2-easy-to-understand",
                "content": "class Solution {\\n\\n    public int[] constructArray(int n, int k) {\\n        int[] res = new int[n];\\n        for(int i=1;i<=n;i++){\\n            res[i-1]=i;   \\n        }\\n        \\n        \\n        // [1,2,3,4,5,6] //start with this. suppose k=4.\\n        // we always let 1 be the starting element.\\n        // find element which will give a diff of 4. In this case 5.\\n        // modify array, [ 1,5,3,4,2,6]\\n        // reduce k ( k becomes 3 )\\n        // shrink array and let 5 be the starting element [5,3,4,2,6] and repeat above steps until desired array is achieved.\\n        int reindex=0;\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(Math.abs(res[reindex]-res[j])==k){\\n                    int temp = res[i+1];\\n                    res[i+1]=res[j];\\n                    res[j]=temp;\\n                    k--;    //reduce k value.\\n                    reindex++;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int[] constructArray(int n, int k) {\\n        int[] res = new int[n];\\n        for(int i=1;i<=n;i++){\\n            res[i-1]=i;   \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4061841,
                "title": "c-beats-100-two-pointers",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> res {1};\\n        int l = 2, r = n, cnt = 1;\\n        while (cnt < k) {\\n            if (cnt & 1) res.push_back(r --);\\n            else res.push_back(l ++);\\n            ++ cnt;\\n        }\\n        if (cnt & 1) while (l <= r) res.push_back(l ++);\\n        else while (l <= r) res.push_back(r --);\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> res {1};\\n        int l = 2, r = n, cnt = 1;\\n        while (cnt < k) {\\n            if (cnt & 1) res.push_back(r --);\\n            else res.push_back(l ++);\\n            ++ cnt;\\n        }\\n        if (cnt & 1) while (l <= r) res.push_back(l ++);\\n        else while (l <= r) res.push_back(r --);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059561,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) \\n    {\\n      int high=k;\\n      int prev=1;\\n      vector<int>ans;\\n      ans.push_back(prev);\\n      while(prev+k<n)\\n      {\\n          prev++;\\n          ans.push_back(prev);\\n      } \\n      int even=1;  \\n      while(high>0)\\n      {\\n          if (even) \\n          {\\n              prev=prev+high;\\n          }\\n          else{\\n              prev=prev-high;\\n          }\\n           ans.push_back(prev);\\n           high--;\\n           even=1-even;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) \\n    {\\n      int high=k;\\n      int prev=1;\\n      vector<int>ans;\\n      ans.push_back(prev);\\n      while(prev+k<n)\\n      {\\n          prev++;\\n          ans.push_back(prev);\\n      } \\n      int even=1;  \\n      while(high>0)\\n      {\\n          if (even) \\n          {\\n              prev=prev+high;\\n          }\\n          else{\\n              prev=prev-high;\\n          }\\n           ans.push_back(prev);\\n           high--;\\n           even=1-even;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051042,
                "title": "java-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int res[] = new int[n];\\n        res[0] = 1 ;\\n        int prev = 1  , t = k ;\\n        for( int i = 1 ; i <= k ;i++){\\n            if( i%2 == 1) res[i] = prev + t ;\\n            else res[i] = prev -t ;\\n            prev = res[i];\\n            t--;\\n        }\\n        for( int i = k+2 ; i <= n ;i++) res[i-1] = i ;\\n        \\n        return res ;\\n    }\\n}\\n\\n// 1 4 2 3 5\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int res[] = new int[n];\\n        res[0] = 1 ;\\n        int prev = 1  , t = k ;\\n        for( int i = 1 ; i <= k ;i++){\\n            if( i%2 == 1) res[i] = prev + t ;\\n            else res[i] = prev -t ;\\n            prev = res[i];\\n            t--;\\n        }\\n        for( int i = k+2 ; i <= n ;i++) res[i-1] = i ;\\n        \\n        return res ;\\n    }\\n}\\n\\n// 1 4 2 3 5\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039734,
                "title": "beautiful-arrangement-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] ans = new int[n];\\n        int c = 0;\\n        for (int v = 1; v < n-k; v++) {\\n            ans[c++] = v;\\n        }\\n        for (int i = 0; i <= k; i++) {\\n            ans[c++] = (i%2 == 0) ? (n-k + i/2) : (n - i/2);\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] ans = new int[n];\\n        int c = 0;\\n        for (int v = 1; v < n-k; v++) {\\n            ans[c++] = v;\\n        }\\n        for (int i = 0; i <= k; i++) {\\n            ans[c++] = (i%2 == 0) ? (n-k + i/2) : (n - i/2);\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012030,
                "title": "very-easy-c-solution-only-traversal-from-1-to-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        \\n\\n\\nvector<int>v;\\n\\nint a=1;\\nint b=n;\\nint uniq=0;\\nint turn =1;\\nwhile(v.size()<k){\\n\\nif(turn){v.push_back(a);a++;turn=0;}\\nelse {v.push_back(b);b--;turn=1;}\\n\\n}\\n\\n\\n\\nwhile(v.size()<n){\\n\\n    if(turn){v.push_back(b);b--;}\\n    else {v.push_back(a);a++;}\\n}\\n\\n\\nreturn v;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        \\n\\n\\nvector<int>v;\\n\\nint a=1;\\nint b=n;\\nint uniq=0;\\nint turn =1;\\nwhile(v.size()<k){\\n\\nif(turn){v.push_back(a);a++;turn=0;}\\nelse {v.push_back(b);b--;turn=1;}\\n\\n}\\n\\n\\n\\nwhile(v.size()<n){\\n\\n    if(turn){v.push_back(b);b--;}\\n    else {v.push_back(a);a++;}\\n}\\n\\n\\nreturn v;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004895,
                "title": "c-python-solution-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/488d2d2b-b320-4e62-81c1-f545718b7a88_1693907221.2434201.png)\\nwe can use deque to simulate the process.\\ntc is O(n), sc is O(n).\\n### deque\\n```python\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        k -= 1\\n        deq = deque(range(1,n+1))\\n        f = True\\n        ans = []\\n        while deq:\\n            if f: ans.append(deq.popleft())\\n            else: ans.append(deq.pop())\\n            if k:\\n                k -= 1\\n                f = not f\\n        return ans\\n```\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        deque<int> deq (n);\\n        iota(deq.begin(), deq.end(), 1);\\n        k -= 1;\\n        bool f = true;\\n        vector<int> ans;\\n        while (!deq.empty()) {\\n            if (f) {\\n                ans.emplace_back(deq.front());\\n                deq.pop_front();\\n            } else {\\n                ans.emplace_back(deq.back());\\n                deq.pop_back();\\n            }\\n            if (k) {\\n                f = !f;\\n                k-=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Queue"
                ],
                "code": "```python\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        k -= 1\\n        deq = deque(range(1,n+1))\\n        f = True\\n        ans = []\\n        while deq:\\n            if f: ans.append(deq.popleft())\\n            else: ans.append(deq.pop())\\n            if k:\\n                k -= 1\\n                f = not f\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        deque<int> deq (n);\\n        iota(deq.begin(), deq.end(), 1);\\n        k -= 1;\\n        bool f = true;\\n        vector<int> ans;\\n        while (!deq.empty()) {\\n            if (f) {\\n                ans.emplace_back(deq.front());\\n                deq.pop_front();\\n            } else {\\n                ans.emplace_back(deq.back());\\n                deq.pop_back();\\n            }\\n            if (k) {\\n                f = !f;\\n                k-=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915858,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nimport java.util.*;\\n\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] answer = new int[n];\\n        int left = 1, right = n;\\n        int i = 0;\\n        while (i < n) {\\n            if (k > 1) {\\n                answer[i++] = (k % 2 == 0) ? right-- : left++;\\n                k--;\\n            } else {\\n                answer[i++] = left++;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\\n\\n```python []\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        int diff = n - k;\\n        int lo = 1;\\n        int hi = n;\\n        vector<int> out;\\n        int i = 0; \\n\\t\\t// we generate a difference of 1 between subsequent elements for the first n-k times.\\n        while(i < diff){\\n            out.push_back(lo);\\n            lo++;\\n            i++;\\n        }\\n        bool flag = true;\\n\\t\\t//Now we go zig zag to generate k unique differences, the last one will be automatically taken care\\n\\t\\t//as the difference between last two elements will be one which we have already generated above.\\n        for(int i = out.size()   ; i < n ; i++){\\n           //flag to alternatively zig zag\\n\\t\\t   if(flag){\\n                out.push_back(hi);\\n                hi--;\\n                flag = false;\\n            }\\n            else{\\n                out.push_back(lo);\\n                lo++;\\n                flag = true;\\n            }\\n        }\\n        return out;\\n    }\\n};\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        int diff = n - k;\\n        int lo = 1;\\n        int hi = n;\\n        vector<int> out;\\n        int i = 0; \\n\\t\\t// we generate a difference of 1 between subsequent elements for the first n-k times.\\n        while(i < diff){\\n            out.push_back(lo);\\n            lo++;\\n            i++;\\n        }\\n        bool flag = true;\\n\\t\\t//Now we go zig zag to generate k unique differences, the last one will be automatically taken care\\n\\t\\t//as the difference between last two elements will be one which we have already generated above.\\n        for(int i = out.size()   ; i < n ; i++){\\n           //flag to alternatively zig zag\\n\\t\\t   if(flag){\\n                out.push_back(hi);\\n                hi--;\\n                flag = false;\\n            }\\n            else{\\n                out.push_back(lo);\\n                lo++;\\n                flag = true;\\n            }\\n        }\\n        return out;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```java []\\nimport java.util.*;\\n\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] answer = new int[n];\\n        int left = 1, right = n;\\n        int i = 0;\\n        while (i < n) {\\n            if (k > 1) {\\n                answer[i++] = (k % 2 == 0) ? right-- : left++;\\n                k--;\\n            } else {\\n                answer[i++] = left++;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\n```python []\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        int diff = n - k;\\n        int lo = 1;\\n        int hi = n;\\n        vector<int> out;\\n        int i = 0; \\n\\t\\t// we generate a difference of 1 between subsequent elements for the first n-k times.\\n        while(i < diff){\\n            out.push_back(lo);\\n            lo++;\\n            i++;\\n        }\\n        bool flag = true;\\n\\t\\t//Now we go zig zag to generate k unique differences, the last one will be automatically taken care\\n\\t\\t//as the difference between last two elements will be one which we have already generated above.\\n        for(int i = out.size()   ; i < n ; i++){\\n           //flag to alternatively zig zag\\n\\t\\t   if(flag){\\n                out.push_back(hi);\\n                hi--;\\n                flag = false;\\n            }\\n            else{\\n                out.push_back(lo);\\n                lo++;\\n                flag = true;\\n            }\\n        }\\n        return out;\\n    }\\n};\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        int diff = n - k;\\n        int lo = 1;\\n        int hi = n;\\n        vector<int> out;\\n        int i = 0; \\n\\t\\t// we generate a difference of 1 between subsequent elements for the first n-k times.\\n        while(i < diff){\\n            out.push_back(lo);\\n            lo++;\\n            i++;\\n        }\\n        bool flag = true;\\n\\t\\t//Now we go zig zag to generate k unique differences, the last one will be automatically taken care\\n\\t\\t//as the difference between last two elements will be one which we have already generated above.\\n        for(int i = out.size()   ; i < n ; i++){\\n           //flag to alternatively zig zag\\n\\t\\t   if(flag){\\n                out.push_back(hi);\\n                hi--;\\n                flag = false;\\n            }\\n            else{\\n                out.push_back(lo);\\n                lo++;\\n                flag = true;\\n            }\\n        }\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850173,
                "title": "c-zigzag-move",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans (k+1);\\n        int cur=1;\\n        for (int i=0;i<=k;i+=2) ans[i]=cur++;\\n        cur = k+1;\\n        for (int i=1;i<=k;i+=2) ans[i]=cur--;\\n        for (int i=k+1;i<n;i++) ans.push_back(i+1);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans (k+1);\\n        int cur=1;\\n        for (int i=0;i<=k;i+=2) ans[i]=cur++;\\n        cur = k+1;\\n        for (int i=1;i<=k;i+=2) ans[i]=cur--;\\n        for (int i=k+1;i<n;i++) ans.push_back(i+1);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837209,
                "title": "python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n\\n        ans = list(range(1, n - k)) \\n        for i in range(k+1):\\n            if i % 2 == 0:\\n                ans.append(n-k + i//2)\\n            else:\\n                ans.append(n - i//2)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n\\n        ans = list(range(1, n - k)) \\n        for i in range(k+1):\\n            if i % 2 == 0:\\n                ans.append(n-k + i//2)\\n            else:\\n                ans.append(n - i//2)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700862,
                "title": "very-easy-to-understand-c-solution",
                "content": "# Intuition\\nWe need to create an answer array `[a1, a2, a3, ... , an]` ranged from `1` to `n`, that satisfies the criteria `[|a1 - a2|, |a2 - a3|, ... , |an-1 - an|]` have distinct `k` elements.\\n\\nSo when `k = 1`, the difference between adjacent elements must be `1`\\n\\nAnd when `k = 2`, the difference between adjacent elements must be `1` or `2`, and both must occure at least once\\n\\nAnd when `k = 3`, the difference between adjacent elements must be `1`, `2` or `3`, and all must occure at least once\\n\\nAnd so on...\\n\\nSo we will use the `k` to fulfill our requirement first, then fill the rest of the array ascendingly till we reach `n`.\\n\\n# Approach\\nAssume `n = 10` and `k = 3`\\nWe will fill `n` as follow:\\n`[1, 1 + k]` k = 3\\n`[1, 4, 4 - (k - 1)]` k = -2\\n`[1, 4, 2, 2 + (k - 2)]` k = 1\\n`[1, 4, 2, 3]`\\n\\nNotice how `k` updates; the value reduces by one, and the sign changes.\\n\\nWe have fulfilled the requirement, now fill the array normally using:\\n`answer[i] = i + 1`\\n\\n`[1, 4, 2, 3, 5, 6, 7, 8, 9, 10]`\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] ConstructArray(int n, int k) {\\n        int[] answer = new int[n];\\n        answer[0] = 1;\\n\\n        int i = 1;\\n        while(k != 0)\\n        {\\n            answer[i] = answer[i - 1] + k;\\n            i++;\\n\\n            k = -(k - (Math.Abs(k) / k));\\n        }\\n\\n        while(i < n)\\n        {\\n            answer[i] = i + 1;\\n            i++;\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Math"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] ConstructArray(int n, int k) {\\n        int[] answer = new int[n];\\n        answer[0] = 1;\\n\\n        int i = 1;\\n        while(k != 0)\\n        {\\n            answer[i] = answer[i - 1] + k;\\n            i++;\\n\\n            k = -(k - (Math.Abs(k) / k));\\n        }\\n\\n        while(i < n)\\n        {\\n            answer[i] = i + 1;\\n            i++;\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684647,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def constructArray(n: Int, k: Int): Array[Int] = {\\n      var num = -1\\n      val res = new Array[Int](n)\\n      res(0) = n\\n      for (i <- 1 until n) \\n        if (i < k)\\n          if (num > 0) {\\n            res(i) = res(i - 1) + (n - i)\\n            num *= -1\\n          } else {\\n            res(i) = res(i - 1) - (n - i)\\n            num *= -1\\n          }\\n        else res(i) = res(i - 1) + num\\n      res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def constructArray(n: Int, k: Int): Array[Int] = {\\n      var num = -1\\n      val res = new Array[Int](n)\\n      res(0) = n\\n      for (i <- 1 until n) \\n        if (i < k)\\n          if (num > 0) {\\n            res(i) = res(i - 1) + (n - i)\\n            num *= -1\\n          } else {\\n            res(i) = res(i - 1) - (n - i)\\n            num *= -1\\n          }\\n        else res(i) = res(i - 1) + num\\n      res\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3671278,
                "title": "beautiful-arrangement-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar constructArray = function(n, k) {\\n    let start=1;\\n    let end=k+1;\\n    let result=[];\\n    while(start<end){\\n        result.push(start);\\n        result.push(end);\\n        end--;\\n        start++;\\n    }\\n    let nums = Array.from({ length: n }).map((v, i) => {\\n  return i + 1;\\n});\\nfor(let num of nums){if(result.indexOf(num)===-1){result.push(num)}}\\nreturn result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar constructArray = function(n, k) {\\n    let start=1;\\n    let end=k+1;\\n    let result=[];\\n    while(start<end){\\n        result.push(start);\\n        result.push(end);\\n        end--;\\n        start++;\\n    }\\n    let nums = Array.from({ length: n }).map((v, i) => {\\n  return i + 1;\\n});\\nfor(let num of nums){if(result.indexOf(num)===-1){result.push(num)}}\\nreturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3619832,
                "title": "simple-c-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are different ways to do this problem but here is a simple way.\\n\\nIf we have to make k different differences then the differences should contain all numbers from 1 to k (differences can repeat but all numbers from 1 to k should be covered). For ex. if K is 3 then no matter what the array is, 1,2,3 should be the differences.\\n\\nSo, all we need to do is first set the starting number in array as 1. We also make a hash array to store numbers that have been covered. Now, we sub k and add k to it. If the new number is a valid number (between 1 and n) and is not in hash array then that is the next number (check first for sub and if that is not valid then add). Then subtract 1 from k. Do this till k becomes zero.\\n\\nAfter K is 0, simply traverse the hash array and add the numbers that have not been covered in ascending order. Done!!!\\n\\nI am not sure why the last step works but I think the differnce will never exceed 2 and when k is 1 it will not exceed 1. But, I can\\'t prove it mathematically.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans;\\n        vector<int> hash(n+10, 0);\\n        ans.push_back(1);\\n        hash[1] = 1;\\n        int num = 1;\\n        while(k){\\n            int t1 = num - k;\\n            if(t1 > 1 && hash[t1] == 0){\\n                hash[t1] = 1;\\n                ans.push_back(t1);\\n                num = t1;\\n                k--;\\n            }\\n            else{\\n                int t2 = num + k;\\n                hash[t2] = 1;\\n                ans.push_back(t2);\\n                num = t2;\\n                k--;\\n            }\\n        }\\n        for(int i = 1; i<=n; i++){\\n            if(hash[i] == 0){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans;\\n        vector<int> hash(n+10, 0);\\n        ans.push_back(1);\\n        hash[1] = 1;\\n        int num = 1;\\n        while(k){\\n            int t1 = num - k;\\n            if(t1 > 1 && hash[t1] == 0){\\n                hash[t1] = 1;\\n                ans.push_back(t1);\\n                num = t1;\\n                k--;\\n            }\\n            else{\\n                int t2 = num + k;\\n                hash[t2] = 1;\\n                ans.push_back(t2);\\n                num = t2;\\n                k--;\\n            }\\n        }\\n        for(int i = 1; i<=n; i++){\\n            if(hash[i] == 0){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591726,
                "title": "bruteforce-math-relation-approach",
                "content": "# Intuition\\nName itself is a hint.\\n\\n# Approach\\nThere is relation between elements of array like this.\\nfor every solution arr[0]=1 (must)\\narr[1]=arr(0)+k\\narr[2]=arr(0)-(k-1)\\narr[3]=arr(0)+(k-2)\\n... and so on.\\nwhen k becomes 0 then just add remaining distinct elements to arr from arr(1){as it is the greatest till now} to n.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] arr=new int[n];\\n        arr[0]=1;\\n        for (int i = 1; i <arr.length ; i++) {\\n            if (k!=0) {\\n                if (i%2!=0) {\\n                    arr[i]=arr[i-1]+k;\\n                } else {\\n                    arr[i]=arr[i-1]-k;\\n                }\\n            k--;} else {break;}\\n        }\\n        int increment=1;\\n        for (int i = arr[1]; i < arr.length ; i++) {\\n            arr[i]=arr[1]+increment;\\n            increment++;\\n        }\\n                return arr;\\n    }}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] arr=new int[n];\\n        arr[0]=1;\\n        for (int i = 1; i <arr.length ; i++) {\\n            if (k!=0) {\\n                if (i%2!=0) {\\n                    arr[i]=arr[i-1]+k;\\n                } else {\\n                    arr[i]=arr[i-1]-k;\\n                }\\n            k--;} else {break;}\\n        }\\n        int increment=1;\\n        for (int i = arr[1]; i < arr.length ; i++) {\\n            arr[i]=arr[1]+increment;\\n            increment++;\\n        }\\n                return arr;\\n    }}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569081,
                "title": "not-fast-but-more-explainable-than-original-question-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOur goal is to get all numbers in range 1 to n+1 \\nWe need them in a \\'beautiful\\' order \\nTo start, we know we can get the beginning of an answer by going from 1 to n-k values \\nSo, we start our answer there \\nThen, we know that we want distint values in that range, and so we want to have the values marked when we have used them \\nTo accomplish this, we can mark their availability \\nWe build this by first marking all of our start answer components as False\\nThen, we loop from where we stopped/1 to n+1 that those values are available. \\n\\nTo find our final answer we now do two steps \\nFirst, we get our current value to consider as the last value of answer + 1 or just 1 if we have no answer built due to range considerations \\nWe mark that as unavailable, and then add it to the answer \\n\\nWe can then loop over k from current to 0 and determine next updates as detailed in approach, before finally adding any missed values still available and then returning. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe get our original problem space with a list from 1 to n-k \\nWe then set up values available and mark the original problem space considerations as unavailable \\nWe then set up from our stopping point in original problem space to n+1 as available in our mapping \\n\\nWe select the current value based on either final of original problem space solution + 1 or 1 if no problem space set up yet \\nMark it as unavailable and then add it to the answer \\n\\nNow while we have k > 1 \\n- We could find an update at current value - k -> points to left end of range \\n- Or we could find an update current value + k -> points to right end of range \\n- If we have a value on left that is gt 0 and is available, we\\'ll use that, otherwise we\\'ll use the addition valuation \\n- Once we know our next value, mark it\\'s available status as false, set current value to it and update our answer \\n- decrement k when done \\n\\nAt the end of the while loop, update answer with every value in value available we have not yet considered \\n\\nreturn when completed \\n\\nThis works by first eliminating the base case considered \\nThen, does so by marking and udpates within range with consideration for which end of the \\'total\\' list we\\'d be pulling from at any point \\nThen finalizes with a final update for all unused values \\n\\n# Complexity\\n- Time complexity : O(N + K) \\n    - O(N) to build answer at start \\n    - O(N) to build up value available \\n    - O(N) to finalize value available \\n    - O(K) to conduct while loop \\n    - O(N) to finalize answer  \\n\\n- Space complexity : O(N) \\n    - O(N) values stored  \\n\\n# Code\\n```\\nclass Solution :\\n    def constructArray(self, n: int, k: int) -> List[int] :\\n        # build array \\n        answer = list(range(1, n-k))\\n        # by first mapping if values are used or not \\n        value_available = dict() \\n        # mark initial considerations \\n        for value in answer : \\n            value_available[value] = False\\n\\n        # loop over values we may use \\n        for value in range(min(1, n-k), n+1) : \\n            # and since we have not used them, mark as True \\n            value_available[value] = True\\n        \\n        # use either last value + 1 to start or 1 if no answer built yet \\n        current_value = answer[-1]+1 if answer else 1 \\n        value_available[current_value] = False\\n        answer.append(current_value)\\n\\n        # loop while you have k to consider \\n        while k > 1 : \\n            # get subtraction by k and addition by k update \\n            subtraction = current_value - k\\n            addition    = current_value + k \\n            # go with subtraction if subtraction is positive and we haven\\'t used that value, otherwise addition \\n            next_value = subtraction if (subtraction > 0 and value_available[subtraction]) else addition\\n            # whatever it was, it\\'s now not available \\n            value_available[next_value] = False\\n            # update current, add to answer and decrement k \\n            current_value = next_value \\n            answer.append(current_value)\\n            k -= 1 \\n\\n        # add to answer all values still True for values in range we need and have not yet done\\n        answer += [value for value in value_available.keys() if value_available[value] == True]\\n        # return completed answer \\n        return answer \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution :\\n    def constructArray(self, n: int, k: int) -> List[int] :\\n        # build array \\n        answer = list(range(1, n-k))\\n        # by first mapping if values are used or not \\n        value_available = dict() \\n        # mark initial considerations \\n        for value in answer : \\n            value_available[value] = False\\n\\n        # loop over values we may use \\n        for value in range(min(1, n-k), n+1) : \\n            # and since we have not used them, mark as True \\n            value_available[value] = True\\n        \\n        # use either last value + 1 to start or 1 if no answer built yet \\n        current_value = answer[-1]+1 if answer else 1 \\n        value_available[current_value] = False\\n        answer.append(current_value)\\n\\n        # loop while you have k to consider \\n        while k > 1 : \\n            # get subtraction by k and addition by k update \\n            subtraction = current_value - k\\n            addition    = current_value + k \\n            # go with subtraction if subtraction is positive and we haven\\'t used that value, otherwise addition \\n            next_value = subtraction if (subtraction > 0 and value_available[subtraction]) else addition\\n            # whatever it was, it\\'s now not available \\n            value_available[next_value] = False\\n            # update current, add to answer and decrement k \\n            current_value = next_value \\n            answer.append(current_value)\\n            k -= 1 \\n\\n        # add to answer all values still True for values in range we need and have not yet done\\n        answer += [value for value in value_available.keys() if value_available[value] == True]\\n        # return completed answer \\n        return answer \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502838,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] sol = new int [n];\\n        int smallIter =1, bigIter=n , solIter= 0;\\n\\n        if (k==2) {\\n            sol[solIter++] = bigIter--;\\n            k=1;\\n        }\\n        while (k>1){\\n            sol[solIter++] = smallIter++;\\n            sol[solIter++] = bigIter--;\\n            k-=2;\\n        }\\n        if (k%2==0) {\\n            while (solIter<n) sol[solIter++] = bigIter--;\\n        }\\n        else while (solIter<n) sol[solIter++] = smallIter++;\\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] sol = new int [n];\\n        int smallIter =1, bigIter=n , solIter= 0;\\n\\n        if (k==2) {\\n            sol[solIter++] = bigIter--;\\n            k=1;\\n        }\\n        while (k>1){\\n            sol[solIter++] = smallIter++;\\n            sol[solIter++] = bigIter--;\\n            k-=2;\\n        }\\n        if (k%2==0) {\\n            while (solIter<n) sol[solIter++] = bigIter--;\\n        }\\n        else while (solIter<n) sol[solIter++] = smallIter++;\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418869,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func constructArray(_ n: Int, _ k: Int) -> [Int] {\\n\\n        var res = [Int]()\\n        var l = 1\\n        var h = l + k\\n\\n        while l < h {\\n            res.append(l)\\n            res.append(h)\\n            l += 1\\n            h -= 1\\n        }\\n\\n        if l == h { res.append(l) }\\n        l = k + 2\\n        \\n        while l <= n {\\n            res.append(l)\\n            l += 1\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func constructArray(_ n: Int, _ k: Int) -> [Int] {\\n\\n        var res = [Int]()\\n        var l = 1\\n        var h = l + k\\n\\n        while l < h {\\n            res.append(l)\\n            res.append(h)\\n            l += 1\\n            h -= 1\\n        }\\n\\n        if l == h { res.append(l) }\\n        l = k + 2\\n        \\n        while l <= n {\\n            res.append(l)\\n            l += 1\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405075,
                "title": "most-easy-solution-and-explanation-you-will-ever-see",
                "content": "Explanation:Suppose n=10 and k=9 which is the highest k possible.\\nHow will you achieve this k distint integer?\\nYou will first start with 1 and then place 10 and then 2 and then 9 and so on which will give you highest k possible k unique integer.\\n(1,10,2,9,3,8,4,7,5,6)\\nSo i tell you n=10 and k=5?\\nSuppose we don\\'t have n=10 ,we have n=6.Then how do you find it?Like above\\n1,6,2,5,3,4 which will give you k=5.\\nNow it\\'s time to get back to n=10;\\nWe constructed first portion of our solution which is 1,6,2,5,3,4 and the next number will be 7 and the difference will be (7-4=3) which will fall into our first portion of our solution and then we will just add number with one difference.\\nSo our final solution will be 1,6,2,5,3,4,7,8,9,10.\\n**So the main idea is first construct with k distance integer and then make the rest of the numbers fall into our first solution.**\\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ret;\\n        int low=1;\\n        int high=low+k;\\n        while(low<high){\\n            ret.push_back(low);\\n            ret.push_back(high);\\n            low++;\\n            high--;\\n        }\\n        if(low==high){ret.push_back(low);}\\n        int new_low=1+k+1;\\n        int new_up=n;\\n        while(new_low<=new_up){ret.push_back(new_low);new_low++;}\\n        return ret;\\n    }\\n    \\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ret;\\n        int low=1;\\n        int high=low+k;\\n        while(low<high){\\n            ret.push_back(low);\\n            ret.push_back(high);\\n            low++;\\n            high--;\\n        }\\n        if(low==high){ret.push_back(low);}\\n        int new_low=1+k+1;\\n        int new_up=n;\\n        while(new_low<=new_up){ret.push_back(new_low);new_low++;}\\n        return ret;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370487,
                "title": "simple-c-code-100-faster-just-need-to-observe-a-pattern-to-solve-this-question",
                "content": "# Intuition\\nIf you look at the pattern of various output values (different n & k values), you will find that we always start with initial value 1 and keep addition and subtracting decreasing value of k from initial value. And where ever possible, always choose lower value if that is not already selected before. E.g. for n = 10, k = 7 \\nStart with initial value of 1, the follow this to populate solution matrix:\\n1 + 7 = 8\\n8 - 6 = 2\\n2 + 5 = 7\\n7 - 4 = 3\\n3 + 3 = 6\\n6 - 2 = 4\\n4 + 1 = 5\\nAnd then just append rest of the remaning non-explored no\\'s at the end.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) \\n    {\\n        vector<int> ans, track(n+1, 0);\\n        ans.push_back(1);\\n        track[1] = 1;\\n        int curr = 1;\\n\\n        for(int i=k; i>0; i--)\\n        {\\n            if(curr - i > 0 and track[curr - i] == 0) curr = curr - i;\\n            else curr = curr + i;\\n\\n            ans.push_back(curr);\\n            track[curr] = 1;\\n        }\\n\\n        for(int i=1; i<=n; i++)\\n            if(track[i] == 0) ans.push_back(i);\\n\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) \\n    {\\n        vector<int> ans, track(n+1, 0);\\n        ans.push_back(1);\\n        track[1] = 1;\\n        int curr = 1;\\n\\n        for(int i=k; i>0; i--)\\n        {\\n            if(curr - i > 0 and track[curr - i] == 0) curr = curr - i;\\n            else curr = curr + i;\\n\\n            ans.push_back(curr);\\n            track[curr] = 1;\\n        }\\n\\n        for(int i=1; i<=n; i++)\\n            if(track[i] == 0) ans.push_back(i);\\n\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352867,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> constructArray(int n, int k) \\n    {\\n        int i=1, j=n;\\n        vector<int> ans;\\n        int f=1, cnt=0;\\n        while(k-1)\\n        {\\n            if(f) \\n            {\\n                ans.push_back(i);\\n                i++;\\n            }\\n            else \\n            {\\n                ans.push_back(j);\\n                j--;\\n            }\\n            k--;\\n            f=1-f;\\n            cnt++;\\n        }\\n        if(f)\\n        {\\n            while(cnt!=n) \\n            {\\n                ans.push_back(i++);\\n                cnt++;\\n            }\\n        }\\n        else\\n        {\\n            while(cnt!=n) \\n            {\\n                ans.push_back(j--);\\n                cnt++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> constructArray(int n, int k) \\n    {\\n        int i=1, j=n;\\n        vector<int> ans;\\n        int f=1, cnt=0;\\n        while(k-1)\\n        {\\n            if(f) \\n            {\\n                ans.push_back(i);\\n                i++;\\n            }\\n            else \\n            {\\n                ans.push_back(j);\\n                j--;\\n            }\\n            k--;\\n            f=1-f;\\n            cnt++;\\n        }\\n        if(f)\\n        {\\n            while(cnt!=n) \\n            {\\n                ans.push_back(i++);\\n                cnt++;\\n            }\\n        }\\n        else\\n        {\\n            while(cnt!=n) \\n            {\\n                ans.push_back(j--);\\n                cnt++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239949,
                "title": "easy-c-solution-explained",
                "content": "# Intuition\\nWith K=1 we can just create an array with all integer from 1 to N.\\n{1,2,3,4,5} K=1;\\nFor each K increase we have to flip the remaining sub-array from X to N-1 where X goes from 1 to N-2 for each K increase.\\n{1,5,4,3,2} K=2 (1 flip)\\n{1,5,2,3,4} K=3 (2 flips)\\n{1,5,2,4,3} K=4 (3 flips)\\n\\nThe max valid K is equal to N-1.\\n\\n# Approach\\nI set Low to 1 and High to N.\\nI start creating the array adding the Low element and then picking the next element alternatively as High and Low, incrementing Low and reducing High accordingly and reducing K at each step until K reaches 1. When K reaches 1 I just continue to add the remaining elements without flipping.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] ConstructArray(int n, int k)\\n    {\\n        int low = 1;\\n        int hi = n;\\n        int[] res = new int[n];\\n        bool useLow = true;\\n        for (int i = 0; i < n; i++)\\n        {\\n            res[i] = useLow? low++ : hi--;\\n            if (k>1)\\n            {\\n                useLow = !useLow;\\n                k--;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] ConstructArray(int n, int k)\\n    {\\n        int low = 1;\\n        int hi = n;\\n        int[] res = new int[n];\\n        bool useLow = true;\\n        for (int i = 0; i < n; i++)\\n        {\\n            res[i] = useLow? low++ : hi--;\\n            if (k>1)\\n            {\\n                useLow = !useLow;\\n                k--;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188203,
                "title": "100-optimal-c-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHere , we do the simple things.\\n           if n = 5 and k=4;\\n           then combination is = [1,5,2,4,3]\\n            where differences = [4,3,2,1] which contains 4 distinct integer\\n            \\n            if k=3;\\n            then combination is = [1,5,2,3,4]\\n            where differences = [4,3,1,1] which contains 3 distinct integer\\n            \\n            if k=2;\\n            then combination is = [1,5,4,3,2]\\n            where differences = [4,1,1,1] which contains 2 distinct integer\\n            \\n            if k=1;\\n            then combination is = [1,2,3,4,5]\\n            where differences = [1,1,1,1] which contains 1 distinct integer\\n            \\n            We put elements alternatively, firstly smaller then bigger then smaller ang bigger and so on. until k==0\\n            if(k==0) means than we need only one distinct integer which is 1. so put all remaining elements at 1 distance.\\n            eg:\\n               if k=2;\\n               first choose minimum = 1; // k-- => k=1;\\n               choose maximum = 5; // k--m=> k=0;\\n               if(k==0)\\n                   then after 5 , I put elements ith difference 1 until I reached the first non-picked element.\\n                   \\n               if k=1;\\n               first choose minimum = 1; // k-- => k=0;\\n               if(k==0)\\n                    then after 1 , I put elements with difference 1 until I reached the last non-picked element.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> finalAns;\\n        int start = 1;\\n        int end = n;\\n        int ind =0;\\n        while(ind<n && start<end){\\n            if(ind&1)\\n            finalAns.push_back(end--); \\n            else\\n            finalAns.push_back(start++);\\n            k--;\\n            if(k==0){\\n                break;\\n            }\\n            ind++;\\n        }\\n        \\n        if(ind&1){\\n            ind++;\\n            for(int i=end;i>=start;i--)\\n              finalAns.push_back(i);\\n        }else{\\n            for(int i=start;i<=end;i++)\\n              finalAns.push_back(i);\\n        }\\n\\n        return finalAns;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> finalAns;\\n        int start = 1;\\n        int end = n;\\n        int ind =0;\\n        while(ind<n && start<end){\\n            if(ind&1)\\n            finalAns.push_back(end--); \\n            else\\n            finalAns.push_back(start++);\\n            k--;\\n            if(k==0){\\n                break;\\n            }\\n            ind++;\\n        }\\n        \\n        if(ind&1){\\n            ind++;\\n            for(int i=end;i>=start;i--)\\n              finalAns.push_back(i);\\n        }else{\\n            for(int i=start;i<=end;i++)\\n              finalAns.push_back(i);\\n        }\\n\\n        return finalAns;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166856,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\nThe intuition for this problem is simple.We have given that there should be k distinct differences .So, the differences between consecutive elements will range from 1 to k i.e. 1,2,3,4....,k.\\nSo, we have to somehow manage these differences atleast one time. And after adjusting these differences one time each,if elements from range of 1 to n left to be pushed in vector will be pushed directly,as we have managed all the distinct differences for atleast one time.\\n\\n\\n# Approach\\nWe can approach this problem by simply pushing the largest element first then we will push (last element-k) then decremeting k,then we will push (last element+k) then decremeting k, and so on. This will help us to store distinct elements in vector with varying differences.\\nAfter this process,if elements remained to be pushed will be pushed from largest to 1 sequentially.\\n\\n# Complexity\\n- Time complexity:\\nTime complexity for the above solution will be O(k*k).\\n\\n\\n- Space complexity:\\nSpace complexity will be O(n), required for storing the elements in vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans; //required answer vector\\n        int z=k;\\n        ans.push_back(n); //pushing the highest element into vector\\n        int ct=0;\\n        while(k){\\n            //if-else conditions to execute alternate addition and subtraction from previously pushed element\\n           if(ct%2==0){\\n              ans.push_back(ans[ct]-k);\\n              k--; ct++;\\n           }\\n           else { \\n            ans.push_back(ans[ct]+k);\\n            k--; ct++;\\n           }\\n        }\\n        //pushing the remaining elements into vector sequentially from higher to lower\\n        if(n-z!=1){\\n        for(int i=n-z-2;i>=0;i--){\\n            ans.push_back(i+1);\\n         }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans; //required answer vector\\n        int z=k;\\n        ans.push_back(n); //pushing the highest element into vector\\n        int ct=0;\\n        while(k){\\n            //if-else conditions to execute alternate addition and subtraction from previously pushed element\\n           if(ct%2==0){\\n              ans.push_back(ans[ct]-k);\\n              k--; ct++;\\n           }\\n           else { \\n            ans.push_back(ans[ct]+k);\\n            k--; ct++;\\n           }\\n        }\\n        //pushing the remaining elements into vector sequentially from higher to lower\\n        if(n-z!=1){\\n        for(int i=n-z-2;i>=0;i--){\\n            ans.push_back(i+1);\\n         }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114737,
                "title": "golang-solution-easy-math-prove",
                "content": "**Time: O(n)**\\n**Space: O(n)**\\n\\n# Code\\n```\\nfunc constructArray(n int, k int) []int {\\n    //\\n    // start from extreme case\\n    // C1. 1 = k < n\\n    // 1 = k < n, distincts = [1], answer = [1, 2, ..., n]\\n    // Continue\\n    // 2 = k < n, distincts = [1, 1, ..., 1, 2, -1], answer = [1, 2, ..., n-2, n, n-1]\\n    // 3 = k < n, distincts = [1, 1, ..., 1, 3, -2, 1], answer = [1, 2, ..., n-3, n, n-2, n-1]\\n    // ...\\n    // 1 <= k < n, distincts = [1, 1, ..., 1, k, -(k-1), k-2, -(k-3)..., 1], answer = [1, 2, ..., n-k, n, n-k]\\n    //\\n    // example:\\n    // k = 3 n = 8, answer is [1, 2, 3, 4, 5, 8, 6, 7], distincts = [1, 1, 1, 1, 3, -2, 1]\\n    // k = 5 n = 8, answer is [1, 2, 3, 8, 4, 7, 5, 6], distincts = [1, 1, 1, 4, -3, -2, 1]\\n    //\\n    //\\n    // C2. k = n - 1 alse n = k + 1\\n    // the distinct integer can only be [1, ..., k]\\n    // Continue...\\n    // k = n - 2 als0 n = k + 2 = (k+1) + 1\\n    // k = n - 3 ...\\n    // ...\\n    // k = n - x alse n = k + n = (k + 1) + (x-1)\\n    //\\n    //\\n    // example:\\n    // n = 6, k = 5\\n    // 1   2    3\\n    //   6    5    4\\n    // answer(6, 5) = 1, 6, 2, 5, 3, 4\\n    //\\n    // it can easy to prove\\n    // answer(7, 5) = answer(6, 5) , 7\\n    // answer(8, 5) = answer(6, 5) , 7, 8\\n    // ...\\n    // answer(n, k) = answer(k+1, k) , k + 2, k + 3, ..., n-1, n\\n    //\\n    //\\n    // Prove:\\n    // the distinct integers of answer(k+1, k) must be [1, 2, ..., k - 1, k]\\n    // and the absolute difference between the last number of answer(k+1, k) and k + 2 must in [1, 2, ..., k - 1, k]\\n    //\\n    //\\n    // so, any n and k, 1 <= k <= n\\n    // answer(n, k) = answer(k + 1, k), k + 2, k + 3, ..., n-1, n\\n    // answer(n, k) = 1, k + 1, 2, k, 3, k - 1, ... , (k+1)/2 + 1, k + 2, k + 3, ..., n\\n    //\\n\\n    res := make([]int, n)\\n\\n    l, r := 1, k + 1\\n    for i := 0; i < k + 1; i++ {\\n        if i % 2 == 0 {\\n            res[i] = l\\n            l++\\n        } else {\\n            res[i] = r\\n            r--\\n        }\\n    }\\n\\n    for i := k + 2; i <= n; i++ {\\n        res[i-1] = i\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc constructArray(n int, k int) []int {\\n    //\\n    // start from extreme case\\n    // C1. 1 = k < n\\n    // 1 = k < n, distincts = [1], answer = [1, 2, ..., n]\\n    // Continue\\n    // 2 = k < n, distincts = [1, 1, ..., 1, 2, -1], answer = [1, 2, ..., n-2, n, n-1]\\n    // 3 = k < n, distincts = [1, 1, ..., 1, 3, -2, 1], answer = [1, 2, ..., n-3, n, n-2, n-1]\\n    // ...\\n    // 1 <= k < n, distincts = [1, 1, ..., 1, k, -(k-1), k-2, -(k-3)..., 1], answer = [1, 2, ..., n-k, n, n-k]\\n    //\\n    // example:\\n    // k = 3 n = 8, answer is [1, 2, 3, 4, 5, 8, 6, 7], distincts = [1, 1, 1, 1, 3, -2, 1]\\n    // k = 5 n = 8, answer is [1, 2, 3, 8, 4, 7, 5, 6], distincts = [1, 1, 1, 4, -3, -2, 1]\\n    //\\n    //\\n    // C2. k = n - 1 alse n = k + 1\\n    // the distinct integer can only be [1, ..., k]\\n    // Continue...\\n    // k = n - 2 als0 n = k + 2 = (k+1) + 1\\n    // k = n - 3 ...\\n    // ...\\n    // k = n - x alse n = k + n = (k + 1) + (x-1)\\n    //\\n    //\\n    // example:\\n    // n = 6, k = 5\\n    // 1   2    3\\n    //   6    5    4\\n    // answer(6, 5) = 1, 6, 2, 5, 3, 4\\n    //\\n    // it can easy to prove\\n    // answer(7, 5) = answer(6, 5) , 7\\n    // answer(8, 5) = answer(6, 5) , 7, 8\\n    // ...\\n    // answer(n, k) = answer(k+1, k) , k + 2, k + 3, ..., n-1, n\\n    //\\n    //\\n    // Prove:\\n    // the distinct integers of answer(k+1, k) must be [1, 2, ..., k - 1, k]\\n    // and the absolute difference between the last number of answer(k+1, k) and k + 2 must in [1, 2, ..., k - 1, k]\\n    //\\n    //\\n    // so, any n and k, 1 <= k <= n\\n    // answer(n, k) = answer(k + 1, k), k + 2, k + 3, ..., n-1, n\\n    // answer(n, k) = 1, k + 1, 2, k, 3, k - 1, ... , (k+1)/2 + 1, k + 2, k + 3, ..., n\\n    //\\n\\n    res := make([]int, n)\\n\\n    l, r := 1, k + 1\\n    for i := 0; i < k + 1; i++ {\\n        if i % 2 == 0 {\\n            res[i] = l\\n            l++\\n        } else {\\n            res[i] = r\\n            r--\\n        }\\n    }\\n\\n    for i := k + 2; i <= n; i++ {\\n        res[i-1] = i\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3095986,
                "title": "c-observation-based-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {   \\n        vector<int> ans;\\n        int num = n, diff = k, lowest = n;\\n        ans.push_back(num);\\n        for(int i=1;i<=k;i++)\\n        {\\n           if(i&1){ans.push_back(num-diff);num-=(diff--);lowest=min(lowest, num);} \\n           else{ans.push_back(num+diff);num+=(diff--);}\\n        }\\n        for(int i=lowest-1;i>0;i--)ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {   \\n        vector<int> ans;\\n        int num = n, diff = k, lowest = n;\\n        ans.push_back(num);\\n        for(int i=1;i<=k;i++)\\n        {\\n           if(i&1){ans.push_back(num-diff);num-=(diff--);lowest=min(lowest, num);} \\n           else{ans.push_back(num+diff);num+=(diff--);}\\n        }\\n        for(int i=lowest-1;i>0;i--)ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088229,
                "title": "linear-time-space-solution-in-python-with-explanation",
                "content": "# Intuition\\nLet\\'s understand the question first:\\n**Input**: two integers $$n$$ and $$k$$\\nCreate an array A = [a1, a2 .... an] which satisfies 2 conditions:\\n1. The array is of size $$n$$ and has elements $$1,2,..., n$$ in some order\\n2. Consider a new array A\\' = $$[|a1-a2|, |a2-a3|, ... , |an-1-an|]$$ which is basically the absolute differences of consecutive elements of the  array A. This new array A\\' should have exactly $$k$$ unique elements.\\n\\nNow, the idea is that given $$k$$, the array A\\' will have $$1,2,...,k$$ unique elements.\\n\\n# Approach\\nCreate a map which will have keys $$1,2,...,n$$ with initial values $$1$$ which would represent that the particular element is not yet added to the final solution array.\\n\\nWe start by trying to get the highest difference first ie. $$k$$. So, our array will start like this: $$[1, 1+k]$$ . Create a pointer to the last element of the array like this: $$last = 1+k$$, we will check if $$last-k > 0$$ and $$last-k$$ is not yet added to the array. If these 2 conditions satisfy, we will add $$last-k$$ to the array, otherwise we\\'ll add $$last+k$$ to the array. We\\'ll decrement $$k$$ every step and update $$last$$ to point to the new last element. This iteration will continue until $$k > 1$$. \\n\\nAfter this, we\\'ll check the map from $$1$$ to $$n$$ and simply add the element to the array if it is not present in the array. \\n\\n**Important**: Since we start from $$1, 1+k$$ and so on, the order in which we check and add $$last-k$$ first rather than $$last+k$$ matters. If you reverse this order, you might have to change the overall logic.\\n\\n# Complexity\\n- Time complexity:\\nLinear $$O(n)$$\\n\\n- Space complexity:\\nthe map and the solution array will take $$O(n)$$ space\\n\\n# Code\\n```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        map = {}\\n        for i in range(1, n+1):\\n            map[i] = 1\\n        \\n        ans = []\\n        last = 1\\n        map[last] = 0\\n        ans.append(last)\\n        while k > 1:\\n            next = last - k if (last - k > 0 and map[last-k] == 1) else last + k\\n            last = next\\n            map[last] = 0\\n            ans.append(last)\\n            k -= 1\\n        for i in range(1, n+1):\\n            if map[i] == 1:\\n                ans.append(i)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        map = {}\\n        for i in range(1, n+1):\\n            map[i] = 1\\n        \\n        ans = []\\n        last = 1\\n        map[last] = 0\\n        ans.append(last)\\n        while k > 1:\\n            next = last - k if (last - k > 0 and map[last-k] == 1) else last + k\\n            last = next\\n            map[last] = 0\\n            ans.append(last)\\n            k -= 1\\n        for i in range(1, n+1):\\n            if map[i] == 1:\\n                ans.append(i)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013542,
                "title": "100-faster-really-simple",
                "content": "# Intuition\\ninter_weaving 1_to_k+1\\nthis ensures that we have k distinct differences in our ans\\n\\n# Complexity\\n- Time complexity:  O(n)\\n- Space complexity:  O(n)\\n\\n# Code\\n```\\nclass Solution {\\n   public int[] constructArray(int n, int k) {\\n        int i = 1 , j = k+1 ;\\n        int [] ans=  new int[n] ;\\n        int index = 0 ;\\n\\n        // inter_weaving 1_to_k+1\\n        // this ensures that we have k distinct differences in our ans\\n        while(i<j){\\n            ans[index++] = i++ ;\\n            ans[index++] = j-- ;\\n        }\\n        if(i==j)ans[index++] = i ;\\n\\n        // filling rem num in ans\\n        k+=2 ;\\n        while(k<=n){\\n            ans[index++] = k++ ;\\n        }\\n        return ans ;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int[] constructArray(int n, int k) {\\n        int i = 1 , j = k+1 ;\\n        int [] ans=  new int[n] ;\\n        int index = 0 ;\\n\\n        // inter_weaving 1_to_k+1\\n        // this ensures that we have k distinct differences in our ans\\n        while(i<j){\\n            ans[index++] = i++ ;\\n            ans[index++] = j-- ;\\n        }\\n        if(i==j)ans[index++] = i ;\\n\\n        // filling rem num in ans\\n        k+=2 ;\\n        while(k<=n){\\n            ans[index++] = k++ ;\\n        }\\n        return ans ;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977150,
                "title": "java-solution-o-n-with-detailed-explanation-thought-process",
                "content": "# Step 1. Play With Certain Cases\\nFirst, lets try solving the problem for the easiest cases, k = 1 and k = n-1, the minimum and maximum possible values for k. K denotes the unique amount of \"step sizes\" we can use to bounce around the array and hit every number once.\\n\\nThere is a straight forward answer for one unique step size:\\n![image.png](https://assets.leetcode.com/users/images/bd1e1c2c-afd8-46e9-8c5b-cb9160049faf_1672540759.7595036.png)\\n\\nNow lets tackle the latter case, k = n - 1. Note that in this case, every step size that we make must be unique, since there are n - 1 steps in total to make. To get an idea of maybe what to do, lets see what moves we have after starting with some element as our first element in our answer:\\n\\n![image.png](https://assets.leetcode.com/users/images/6745cdf8-7ea8-4b0b-878e-e4e40ea65ff8_1672540975.356649.png)\\n\\nThe red numbers indicate the step size to reach that number from the arrowed element. Note that starting at either the front or end provides us the nicest path forward. It provides the maximum amount of unique ways to progress, and it wont leave a random hole in the middle of the array that we can\\'t acsess later. \\n\\nLets choose the end (choosing the front works too, but I simply decided to go with the end). What should our next element be? Well, again it is nice to not have random holes in the middle of our array, so 4 and 1 seem like nice choices.\\n\\nIf you choose 4, you will notice that you will later be forced to make another step of size 1. Going from 5 to 4 was a step size of 1, so thus we repeated a step of size 1, and thus going from 5 to 4 will result in a sequence that is not a solution to this case.\\n\\nSo, lets now choose 1. If you continue, you may now notice the pattern at this point, we choose the end, then the first element, and then the last element left, etc in a spiral. This will produce all unique steps.\\n\\n![image.png](https://assets.leetcode.com/users/images/ca73df71-01b6-470a-8758-6d1e972baa6c_1672541772.1100557.png)\\n\\nNotice that we take a step of 4, then 3, then 2, then 1, and at every stage, the indices that we haven\\'t visited yet form a contiguous subarray.\\n\\n\\n# Step 2. Try To Generalize\\n\\nSo now, the final peice of the puzzle is how do we get the solutions where we don\\'t need to use all unique step sizes. We know the solution to the two extremes, and this can give use a clue into how to approach this. Since the spiral approach of the k = n - 1 case always leaves a contiguous subarray unvisited at every iteration, we are always free at any point to exit the spiral stepping and go into the linear marching pattern of k = 1:\\n\\n![image.png](https://assets.leetcode.com/users/images/096cd56e-5ba2-4d45-b2d2-17ec53ee5de4_1672542289.8664255.png)\\n\\nThis works out really nicely, and solves our problem. Note in all cases, we do k - 1 \"spiral\" steps, and then we finish up the rest with marching steps.\\n\\nAll that is left is to implement it. The following solution has O(n) time complexity and O(n) space complexity in order to store and build the answer. \\n\\n# Code\\n```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] answer = new int[n];\\n        int answerIndex = 0;\\n\\n        boolean useHighNum = true;\\n        int low = 1;\\n        int high = n;\\n\\n        // Spiraling\\n        for (int i = 0; i < k - 1; i++) {\\n            if (useHighNum) {\\n                answer[answerIndex] = high;\\n                high--;\\n            } else {\\n                answer[answerIndex] = low;\\n                low++;\\n            }\\n            answerIndex++;\\n            useHighNum = !useHighNum;\\n        }\\n\\n        // Marching\\n        if (useHighNum) {\\n            while (answerIndex < n) {\\n                answer[answerIndex] = high;\\n                high--;\\n                answerIndex++;\\n            }\\n        } else {\\n            while (answerIndex < n) {\\n                answer[answerIndex] = low;\\n                low++;\\n                answerIndex++;\\n            }\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int[] answer = new int[n];\\n        int answerIndex = 0;\\n\\n        boolean useHighNum = true;\\n        int low = 1;\\n        int high = n;\\n\\n        // Spiraling\\n        for (int i = 0; i < k - 1; i++) {\\n            if (useHighNum) {\\n                answer[answerIndex] = high;\\n                high--;\\n            } else {\\n                answer[answerIndex] = low;\\n                low++;\\n            }\\n            answerIndex++;\\n            useHighNum = !useHighNum;\\n        }\\n\\n        // Marching\\n        if (useHighNum) {\\n            while (answerIndex < n) {\\n                answer[answerIndex] = high;\\n                high--;\\n                answerIndex++;\\n            }\\n        } else {\\n            while (answerIndex < n) {\\n                answer[answerIndex] = low;\\n                low++;\\n                answerIndex++;\\n            }\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883849,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn construct_array(n: i32, k: i32) -> Vec<i32> {\\n        let mut k = k;\\n        let mut result = Vec::with_capacity(n as usize);\\n        let mut i = 1;\\n        let mut j = n;\\n        while i <= j {\\n            if k % 2 == 1 {\\n                result.push(i);\\n                i += 1;\\n            } else {\\n                result.push(j);\\n                j -= 1;\\n            }\\n            if k > 1 {\\n                k -= 1;\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn construct_array(n: i32, k: i32) -> Vec<i32> {\\n        let mut k = k;\\n        let mut result = Vec::with_capacity(n as usize);\\n        let mut i = 1;\\n        let mut j = n;\\n        while i <= j {\\n            if k % 2 == 1 {\\n                result.push(i);\\n                i += 1;\\n            } else {\\n                result.push(j);\\n                j -= 1;\\n            }\\n            if k > 1 {\\n                k -= 1;\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2868674,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        if k==1:\\n            return [i for i in range(1,n+1)]\\n        arr=[1]\\n        v=1\\n        while len(arr)<n:\\n            arr.append(arr[-1]+k)\\n            v+=1\\n            arr.append(v)\\n            k-=2\\n            if k<=1:\\n                break\\n\\n        u=set(arr)\\n        for i in range(1,n+1):\\n            if i not in u:\\n                arr.append(i)\\n        return arr\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        if k==1:\\n            return [i for i in range(1,n+1)]\\n        arr=[1]\\n        v=1\\n        while len(arr)<n:\\n            arr.append(arr[-1]+k)\\n            v+=1\\n            arr.append(v)\\n            k-=2\\n            if k<=1:\\n                break\\n\\n        u=set(arr)\\n        for i in range(1,n+1):\\n            if i not in u:\\n                arr.append(i)\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831178,
                "title": "easy-understanding",
                "content": "# Intuition\\n---\\n\\n1 2 3 4 5 6\\nk = 5 ... 1 6 2 5 3 4 \\nk = 4 ... 6 1 5 2 3 4\\nk = 3 ... 1 6 2 3 4 5\\nk = 2 ... 6 1 2 3 4 5\\nk = 1 ... 1 2 3 4 5 6\\n\\n---\\n1 2 3 4 5 6 7\\nk = 6 ... 7 1 6 2 5 3 4\\nk = 5 ... 1 7 2 6 3 4 5\\nk = 4 ... 7 1 6 2 3 4 5\\nk = 3 ... 1 7 2 3 4 5 6\\nk = 2 ... 7 1 2 3 4 5 6\\nk = 1 ... 1 2 3 4 5 6 7\\n\\n---\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        number_tail = k // 2\\n        start, end = [i for i in range(1, n - number_tail + 1)], [i for i in range(n, n - number_tail, -1)]\\n        i, j = 0, 0\\n        if k % 2 == 0:\\n            start, end = end, start\\n        answer = []\\n        for i, j in zip(start, end):\\n            answer.append(i)\\n            answer.append(j)\\n        if len(start) > len(end):\\n            for i in range(len(end), len(start)):\\n                answer.append(start[i])\\n        if len(start) < len(end):\\n            for i in range(len(start), len(end)):\\n                answer.append(end[i])\\n        return answer\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        number_tail = k // 2\\n        start, end = [i for i in range(1, n - number_tail + 1)], [i for i in range(n, n - number_tail, -1)]\\n        i, j = 0, 0\\n        if k % 2 == 0:\\n            start, end = end, start\\n        answer = []\\n        for i, j in zip(start, end):\\n            answer.append(i)\\n            answer.append(j)\\n        if len(start) > len(end):\\n            for i in range(len(end), len(start)):\\n                answer.append(start[i])\\n        if len(start) < len(end):\\n            for i in range(len(start), len(end)):\\n                answer.append(end[i])\\n        return answer\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2820124,
                "title": "python-solution-in-o-n-and-o-1",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        m=k//2\\n        ans=[0 for _ in range(n)]\\n        i=(n-m)\\n        j=(n-m+1)\\n        t=n-1\\n        if(k%2!=0):\\n            ans[t]=i\\n            i-=1\\n            t-=1\\n        while(m!=0):\\n            ans[t]=i\\n            t-=1\\n            i-=1\\n            ans[t]=j\\n            j+=1\\n            t-=1\\n            m-=1\\n        while(i>0):\\n            ans[t]=i\\n            i-=1\\n            t-=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        m=k//2\\n        ans=[0 for _ in range(n)]\\n        i=(n-m)\\n        j=(n-m+1)\\n        t=n-1\\n        if(k%2!=0):\\n            ans[t]=i\\n            i-=1\\n            t-=1\\n        while(m!=0):\\n            ans[t]=i\\n            t-=1\\n            i-=1\\n            ans[t]=j\\n            j+=1\\n            t-=1\\n            m-=1\\n        while(i>0):\\n            ans[t]=i\\n            i-=1\\n            t-=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782563,
                "title": "python-all-consecutive-differences-range-from-1-to-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nSince $k < n$, we can construct an answer such that all consecutive differences range from 1 to $k$.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe answer contains two part.\\n\\nThe first part:\\n\\n$1, k + 1, 2, k - 1, 3, k - 2, ...$\\n\\nOne can verify that differences are $k, k - 1, k - 2, ...$.\\n\\nAssume the end of the first part is $end$, then we construct the second part of our answer as follows.\\n\\nWe first add $end + k$ into our answer, then we start from $end + k$ to add $end + k - 1$, $end + k - 2$, ... until the maximum value of the first part (i.e., k + 1). One can verify that the current sequence satisfies the condition.\\n\\nFurther, we start from the current end to construct the rest of the answer following the same strategy. We first add $end + k$, then we add $end + k - 1$, $end + k - 2$, ... until the maximum value of values already being added.\\n\\nThe critical part is to maintain the maximum value we have already added.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        ans = [1]\\n        num = k + 1\\n        flag = True\\n        diff = k\\n        while len(ans) < num:\\n            if flag:\\n                ans.append(ans[-1] + diff)\\n            else:\\n                ans.append(ans[-1] - diff)\\n\\n            diff -= 1\\n            flag = not flag\\n        \\n        cur_max = num\\n        while len(ans) < n:\\n            end = ans[-1]\\n            for z in range(min(end + k, n), cur_max, -1):\\n                ans.append(z)\\n            cur_max = end + k\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        ans = [1]\\n        num = k + 1\\n        flag = True\\n        diff = k\\n        while len(ans) < num:\\n            if flag:\\n                ans.append(ans[-1] + diff)\\n            else:\\n                ans.append(ans[-1] - diff)\\n\\n            diff -= 1\\n            flag = not flag\\n        \\n        cur_max = num\\n        while len(ans) < n:\\n            end = ans[-1]\\n            for z in range(min(end + k, n), cur_max, -1):\\n                ans.append(z)\\n            cur_max = end + k\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747600,
                "title": "simple-java-solution-with-detailed-explanation",
                "content": "* Observations:\\n\\n  For numbers **1** to **n**, there could be at most **n-1** intervals, so  **k** must be **<= n-1**. Therefore we have the following possibilities for values of **k**.\\n\\n  1)  When **k = 1**,  we must have a sequence of consecutive integers from **1** to **n**,, which is **[1,2,3,..., n]** or **[n, n-1, ..., 1]**, in which all pairs of adjacent numbers share a single difference 1.\\n  2)  When **k = n-1**,  how should we make \\u201Cthe beautiful arrangement\\u201D ?                  \\n        We observe:\\n \\n                    |n - 1| = n -1 , |1- (n-1)| = n - 2, |(n-1)-2| = n - 3, \\u2026\\n\\t\\t\\t\\t\\t\\n\\t  so we can make the arrangement as **[1, n, 2, n-1, \\u2026]** or **[ n , 1,  n-1, 2, \\u2026]**  in which we alternate the  numbers with the pattern **[smallest, largest, second smallest, second largest, \\u2026]** or the other way by switching the order of each pair.           In the end the differences of pairs will be **[n-1, n-2, n-3, \\u2026 , 1]**  with **n-1 = k** distinct values. For example, rearranging **[1, 2, 3, 4, 5]** into **[1, 5, 2, 4, 3]** will result in differences **[4, 3, 2, 1]**.\\n      \\n   3) Then what if  **1 < k < n-1** ?\\n        We can split **k** into two parts: **k-1** and **1**. Starting with the **k - 1** distinct differences, we first need **k** numbers to have **k-1** intervals. We then use the pattern in **2** to arrange them to have differences **[ n-1, n-2, \\u2026 ,n-(k-1)]**. Then we arrange the remaining **n-k+1** numbers starting from the last one of the **k** numbers because we can\\u2019t have a gap between the two parts. We can only have **1**  difference value, so we use **observation 1** to arrange these numbers into a consecutive sequence sharing a single difference **1**. Be careful that the starting number of the consecutive sequence can either be the smallest or largest of the **n-k+1** numbers, so we need to make the sequence ascending or descending accordingly.  Now we will have differences **[ n-1, n-2, \\u2026n-(k-1), 1]**. One can easily prove that these are **k** distinct differences. Wait, what if **n-(k-1) = 1**, won\\u2019t we have one less distinct difference? We can see this won\\u2019t happen because if it does, we will get **n = k**, but we observed in the beginning: **k <= n-1**\\n\\n  Now let\\'s look at an Example:  \\n  ``` \\n   n = 5, k = 3, we will show two ways to make the arrangement:\\n \\n  Way # 1\\n\\n   1 Make an arrangement as in observation 2 that has length = k = 3: [1, 5, 2] => last number is 2\\n   2 Starting from 2, make the consecutive sequence of length n-k+1 = 5-3+1 = 3: [2, 3, 4].  Notice that because 2 is the  \\n      smallest among the remaining numbers, we make the sequence ascending.\\n   3 Our final arrangement is then [1, 5, 2, 3, 4] , differences are [4, 3, 1].\\n   \\n  Way # 2 \\n   \\n  1 Make an arrangement as in observation 2 that has length = k = 3: [5, 1, 4] => last number is 4\\n  2 Starting from 4, make the consecutive sequence of length n-k+1 = 5-3+1 = 3: [4, 3, 2].  Notice that     \\n     because 4 is the largest among the remaining numbers, we make the sequence descending.\\n  3 Our final arrangement is then [5, 1, 4, 3, 2] , differences are [4, 3, 1]. \\n  ```\\n*   Implementation:\\n\\n    We use way **#1** where the first **k** elements are arranged using pattern in **observation 2** as **[small, large, small, large, \\u2026]**\\n\\t```\\n\\t public int[] constructArray(int n, int k) {   \\n          int[] res = new int[n];\\n          int small = 1, large = n;\\n          for (int i=0; i< n; i++) {\\n              if (i<k) {\\n                   res[i] = i % 2 == 0 ? small++ : large--;  // do arrangement 2)\\n              } else {    // starting from k, we do arrangement 1)\\n\\t\\t\\t              // but we need to pay attention to res[k-1], which is where we actually start the consecutive sequence from\\n                   res[i] = (k-1) % 2 == 0 ? res[i-1] + 1 : res[i-1] - 1; // if k-1 is even, then res[k-1] is small, and large otherwise\\n             }\\n        }\\n        return res;\\n    }\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n) to store our answer",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` \\n   n = 5, k = 3, we will show two ways to make the arrangement:\\n \\n  Way # 1\\n\\n   1 Make an arrangement as in observation 2 that has length = k = 3: [1, 5, 2] => last number is 2\\n   2 Starting from 2, make the consecutive sequence of length n-k+1 = 5-3+1 = 3: [2, 3, 4].  Notice that because 2 is the  \\n      smallest among the remaining numbers, we make the sequence ascending.\\n   3 Our final arrangement is then [1, 5, 2, 3, 4] , differences are [4, 3, 1].\\n   \\n  Way # 2 \\n   \\n  1 Make an arrangement as in observation 2 that has length = k = 3: [5, 1, 4] => last number is 4\\n  2 Starting from 4, make the consecutive sequence of length n-k+1 = 5-3+1 = 3: [4, 3, 2].  Notice that     \\n     because 4 is the largest among the remaining numbers, we make the sequence descending.\\n  3 Our final arrangement is then [5, 1, 4, 3, 2] , differences are [4, 3, 1]. \\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2743579,
                "title": "help-c",
                "content": "Please help me with this code its showing wrong answer\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans;\\n        int l = 1, r = n;\\n        int size = 0;\\n        char which_side;\\n        while(size != n){\\n            if(k > 1){\\n                if(size%2 == 0){\\n                    ans.push_back(l);\\n                    l++;\\n                    which_side = l;\\n                    k--;\\n                }\\n                else{\\n                    ans.push_back(r);\\n                    r--;\\n                    which_side = r;\\n                    k--;\\n                }\\n            }\\n            else{\\n                if(which_side == \\'l\\'){\\n                    ans.push_back(l);\\n                    l++;\\n                }\\n                else{\\n                    ans.push_back(r);\\n                    r--;\\n                }\\n            }\\n            size = ans.size();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n   \\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans;\\n        int l = 1, r = n;\\n        int size = 0;\\n        char which_side;\\n        while(size != n){\\n            if(k > 1){\\n                if(size%2 == 0){\\n                    ans.push_back(l);\\n                    l++;\\n                    which_side = l;\\n                    k--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2724644,
                "title": "python-3-line-solution-list-slice-solution",
                "content": "```\\ndef constructArray(self, n: int, k: int) -> List[int]:\\n\\tr = list(range(n-k, n+1))\\n\\tr[::2], r[1::2]= r[:k//2+1], r[k//2+1:][::-1]\\n\\treturn list(range(1, n-k))+r\\n```",
                "solutionTags": [],
                "code": "```\\ndef constructArray(self, n: int, k: int) -> List[int]:\\n\\tr = list(range(n-k, n+1))\\n\\tr[::2], r[1::2]= r[:k//2+1], r[k//2+1:][::-1]\\n\\treturn list(range(1, n-k))+r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2712626,
                "title": "c",
                "content": "example 9 5\\n1 2 3 4 9 5 8 6 7\\n````\\nint* constructArray(int n, int k, int* returnSize){\\n    int* ans = malloc(n * sizeof(int));\\n    *returnSize = n;\\n    for(int i = 0; i < (n-k); i++){\\n        ans[i] = i + 1;\\n    }\\n    ans[n-k] = n;\\n    if(k == 1)\\n        return ans;\\n    int diff= k - 1;\\n    bool flag = true;\\n    for(int i = n-k+1; i < n; i++){\\n        if(flag){\\n            ans[i] = ans[i-1] - diff;\\n            flag = false;\\n        }\\n        else{\\n            ans[i] = ans[i-1] + diff;\\n            flag = true;\\n        }\\n        diff--;\\n    }\\n    return ans;\\n}\\n````",
                "solutionTags": [],
                "code": "````\\nint* constructArray(int n, int k, int* returnSize){\\n    int* ans = malloc(n * sizeof(int));\\n    *returnSize = n;\\n    for(int i = 0; i < (n-k); i++){\\n        ans[i] = i + 1;\\n    }\\n    ans[n-k] = n;\\n    if(k == 1)\\n        return ans;\\n    int diff= k - 1;\\n    bool flag = true;\\n    for(int i = n-k+1; i < n; i++){\\n        if(flag){\\n            ans[i] = ans[i-1] - diff;\\n            flag = false;\\n        }\\n        else{\\n            ans[i] = ans[i-1] + diff;\\n            flag = true;\\n        }\\n        diff--;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2661811,
                "title": "simple-solution",
                "content": "In this problem, we are kind of greedy. We should first construct those distinct k differences. One naive way is trying to construct k differences as `1, 2, 3, ...., k` because small differences can be constructed much easiler. We could  only use the first k+1 elements (1, 2, ..., k+1) to achieve this. For this subarray, the maximal range is `k` (the most significant difference).  So the answer starts with [1, k+1,...]. Then we construct the difference `k-1`, following `k+1`, which would be 2. Then again, starting from 2, we want to find a number that is larger that 2 by `k-2`, which would be `k`. You can follow this pattern to extend the array until you use all first `k+1` elements.\\nThen just concatenate [k+2:N+1] to the end. Note that the difference between `k+2` and the last element in our previously constructed array would be smaller or equal than `k+1`.\\n\\n\\t  def constructArray(self, n: int, k: int) -> List[int]: \\n\\t\\t\\tinitial = []\\n\\t\\t\\tstart = 1\\n\\t\\t\\ttimes = 1\\n\\t\\t\\tfor i in range(k, -1, -1):\\n\\t\\t\\t\\tinitial.append(start)\\n\\t\\t\\t\\tstart = start + i * times\\n\\t\\t\\t\\ttimes = -times\\n\\n\\t\\t\\treturn initial + list(range(k+2, n+1))",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Greedy"
                ],
                "code": "In this problem, we are kind of greedy. We should first construct those distinct k differences. One naive way is trying to construct k differences as `1, 2, 3, ...., k` because small differences can be constructed much easiler. We could  only use the first k+1 elements (1, 2, ..., k+1) to achieve this. For this subarray, the maximal range is `k` (the most significant difference).  So the answer starts with [1, k+1,...]. Then we construct the difference `k-1`, following `k+1`, which would be 2. Then again, starting from 2, we want to find a number that is larger that 2 by `k-2`, which would be `k`. You can follow this pattern to extend the array until you use all first `k+1` elements.\\nThen just concatenate [k+2:N+1] to the end. Note that the difference between `k+2` and the last element in our previously constructed array would be smaller or equal than `k+1`.\\n\\n\\t  def constructArray(self, n: int, k: int) -> List[int]: \\n\\t\\t\\tinitial = []\\n\\t\\t\\tstart = 1\\n\\t\\t\\ttimes = 1\\n\\t\\t\\tfor i in range(k, -1, -1):\\n\\t\\t\\t\\tinitial.append(start)\\n\\t\\t\\t\\tstart = start + i * times\\n\\t\\t\\t\\ttimes = -times\\n\\n\\t\\t\\treturn initial + list(range(k+2, n+1))",
                "codeTag": "Python3"
            },
            {
                "id": 2660576,
                "title": "easy-to-understand-96-faster-simple-sol",
                "content": "```\\npublic int[] constructArray(int n, int k) {\\n//         here it not so tricky, lets consider arr = [1,2,3,4,5] k = 3\\n//         so possible ans = [1,5,2,3,4]\\n//         here we will take 2 variable 1st representing from start i.e num1 = 1;\\n//         ans 2nd representing end i.e num2 = n;\\n//         and count the difference at each step \\n        boolean lastSmallNum = true;\\n        int[] arr = new int[n];\\n        int num1 = 1;\\n        int num2 = n;\\n        int m = 0;\\n        while(k >= 1){\\n            arr[m] = num1;\\n            num1 += 1;\\n            k -= 1;\\n            m += 1;\\n            if(k >= 1){\\n                lastSmallNum = false;\\n                arr[m] = num2;\\n                num2 -= 1;\\n                k -= 1;\\n                m += 1;\\n            }else{\\n                lastSmallNum = true;\\n                break;\\n            }\\n        }\\n        if(lastSmallNum){\\n            while(m < n){\\n                arr[m] = num1;\\n                m++;\\n                num1++;\\n            }\\n        }else{\\n            while(m < n){\\n                arr[m] = num2;\\n                m++;\\n                num2--;\\n            }\\n        }\\n        return arr;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] constructArray(int n, int k) {\\n//         here it not so tricky, lets consider arr = [1,2,3,4,5] k = 3\\n//         so possible ans = [1,5,2,3,4]\\n//         here we will take 2 variable 1st representing from start i.e num1 = 1;\\n//         ans 2nd representing end i.e num2 = n;\\n//         and count the difference at each step \\n        boolean lastSmallNum = true;\\n        int[] arr = new int[n];\\n        int num1 = 1;\\n        int num2 = n;\\n        int m = 0;\\n        while(k >= 1){\\n            arr[m] = num1;\\n            num1 += 1;\\n            k -= 1;\\n            m += 1;\\n            if(k >= 1){\\n                lastSmallNum = false;\\n                arr[m] = num2;\\n                num2 -= 1;\\n                k -= 1;\\n                m += 1;\\n            }else{\\n                lastSmallNum = true;\\n                break;\\n            }\\n        }\\n        if(lastSmallNum){\\n            while(m < n){\\n                arr[m] = num1;\\n                m++;\\n                num1++;\\n            }\\n        }else{\\n            while(m < n){\\n                arr[m] = num2;\\n                m++;\\n                num2--;\\n            }\\n        }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2640491,
                "title": "actually-clean-java-o-n-code",
                "content": "If you are only allowed ```k``` distinct values, the first ```n-k``` values can form a sequence: ```[1, 2, 3, ...n-k]```. The rest can be allotted by switching between left (min) and right (max) values for odds and evens. Code should be self-explanatory.\\n```\\npublic int[] constructArray(int n, int k) {\\n        int a = n-k;\\n        int[] sol = new int[n];\\n        for(int i = 0; i < a; i++){\\n            sol[i] = i+1;\\n        }\\n        for(int i = a; i < n; i++){\\n            int idx = i-a; //this is the 0-based index\\n            if(idx%2 == 0){\\n                sol[i] = n - (idx/2);\\n            }\\n            else {\\n                sol[i] = (a) + (idx/2)+1;\\n            }\\n        }\\n        return sol;\\n    }\\n```\\n\\t",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```k```\n```n-k```\n```[1, 2, 3, ...n-k]```\n```\\npublic int[] constructArray(int n, int k) {\\n        int a = n-k;\\n        int[] sol = new int[n];\\n        for(int i = 0; i < a; i++){\\n            sol[i] = i+1;\\n        }\\n        for(int i = a; i < n; i++){\\n            int idx = i-a; //this is the 0-based index\\n            if(idx%2 == 0){\\n                sol[i] = n - (idx/2);\\n            }\\n            else {\\n                sol[i] = (a) + (idx/2)+1;\\n            }\\n        }\\n        return sol;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2636276,
                "title": "easy-to-understand-c-sol",
                "content": "class Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        int hi=n,lo=1;\\n        int i=0;\\n        vector<int>ans;\\n        int b=k;\\n        while(b--){\\n            if(i&1){\\n                ans.push_back(hi--);\\n            }\\n            else{\\n                ans.push_back(lo++);\\n            }\\n            i++;\\n        }\\n        int df=n-k;\\n        while(df--){\\n            if(i%2!=0)ans.push_back(lo++);\\n            else ans.push_back(hi--);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        int hi=n,lo=1;\\n        int i=0;\\n        vector<int>ans;\\n        int b=k;\\n        while(b--){\\n            if(i&1){\\n                ans.push_back(hi--);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2620230,
                "title": "ruby-t-o-n-s-o-n-100-100",
                "content": "```\\n# @param {Integer} n\\n# @param {Integer} k\\n# @return {Integer[]}\\ndef construct_array(n, k)\\n  result = [1]\\n  plus = true\\n  current = 1\\n  k.downto(1) do |j|\\n    if plus\\n      current += j\\n    else\\n      current -= j\\n    end\\n    result << current    \\n    plus = !plus\\n  end\\n\\n  (k + 2).upto(n) do |i|\\n    result << i\\n  end\\n\\n  result\\nend",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer} n\\n# @param {Integer} k\\n# @return {Integer[]}\\ndef construct_array(n, k)\\n  result = [1]\\n  plus = true\\n  current = 1\\n  k.downto(1) do |j|\\n    if plus\\n      current += j\\n    else\\n      current -= j\\n    end\\n    result << current    \\n    plus = !plus\\n  end\\n\\n  (k + 2).upto(n) do |i|\\n    result << i\\n  end\\n\\n  result\\nend",
                "codeTag": "Python3"
            },
            {
                "id": 2614749,
                "title": "python-straightforward",
                "content": "```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        digits, res = {*range(1, n)}, [n]\\n        while True:\\n            if res[-1] - k in digits:\\n                digits -= {res[-1] - k}\\n                res.append(res[-1] - k)\\n                k = -(k - 1) if k > 0 else -(k + 1)\\n            else:    \\n                break\\n        return res + sorted(list(digits), reverse=True)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        digits, res = {*range(1, n)}, [n]\\n        while True:\\n            if res[-1] - k in digits:\\n                digits -= {res[-1] - k}\\n                res.append(res[-1] - k)\\n                k = -(k - 1) if k > 0 else -(k + 1)\\n            else:    \\n                break\\n        return res + sorted(list(digits), reverse=True)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585693,
                "title": "python-direct-construction-easy-to-understand-o-n",
                "content": "```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        i, j = 2, n\\n        res = [1]\\n        while k > 2:\\n            res.append(j)\\n            res.append(i)\\n            j -= 1\\n            i += 1\\n            k -= 2\\n        if k == 2:\\n            for k in range(i,j-1):\\n                res.append(k)\\n            res.append(j)\\n            res.append(j-1)\\n        else:\\n            for k in range(i,j+1):\\n                res.append(k)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        i, j = 2, n\\n        res = [1]\\n        while k > 2:\\n            res.append(j)\\n            res.append(i)\\n            j -= 1\\n            i += 1\\n            k -= 2\\n        if k == 2:\\n            for k in range(i,j-1):\\n                res.append(k)\\n            res.append(j)\\n            res.append(j-1)\\n        else:\\n            for k in range(i,j+1):\\n                res.append(k)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2582265,
                "title": "c-easy-solution-o-n-greedy-approach",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> arr(n);\\n        int inc=0;\\n        int dec=k+1;\\n        for(int i=0;i<=k;i++){\\n            if(i%2==0) arr[i]=++inc;\\n            else arr[i]=dec--;\\n        }\\n        for(int i=k+1;i<n;i++){\\n            arr[i]=i+1;\\n        }\\n        return arr;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> arr(n);\\n        int inc=0;\\n        int dec=k+1;\\n        for(int i=0;i<=k;i++){\\n            if(i%2==0) arr[i]=++inc;\\n            else arr[i]=dec--;\\n        }\\n        for(int i=k+1;i<n;i++){\\n            arr[i]=i+1;\\n        }\\n        return arr;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575729,
                "title": "short",
                "content": "**zig-zag and linear**\\n**time: `O(n)`; space: `O(1)`**\\n\\n![image](https://assets.leetcode.com/users/images/6c666c0d-14b3-4a4a-b7ab-c31d664b7d8f_1663172136.1739454.png)\\n\\n```\\nvector<int> constructArray(int n, int k) \\n{\\n\\tvector<int> out(n);\\n\\tfor(int i{}, b{}; i<size(out); ++i)\\n\\t\\tout[i] = min(i,k-1)&1 ? n-- : ++b; \\n\\treturn out;\\n}\\n```\\n**Notation:**\\n`b`- **b**egin;\\n`n` - end.\\n\\n![image](https://assets.leetcode.com/users/images/7f818811-5eb8-49ad-9684-69e6b986e752_1663176731.638163.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> constructArray(int n, int k) \\n{\\n\\tvector<int> out(n);\\n\\tfor(int i{}, b{}; i<size(out); ++i)\\n\\t\\tout[i] = min(i,k-1)&1 ? n-- : ++b; \\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2553642,
                "title": "o-n-time-o-n-space-clear-explanation-oneliner",
                "content": "![image](https://assets.leetcode.com/users/images/cab57f9a-7578-4b10-b0c8-6cb54cfb4fb5_1662726547.730287.png)\\n\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        \"\"\" O(N)TS \"\"\"\\n        ans, nums = list(range(1, n - k)), collections.deque(range(n - k, n + 1))\\n\\n        while len(nums) > 1:\\n            ans += nums.popleft(), nums.pop()\\n\\n        return ans + list(nums)\\n\\t\\nand..oneliner))\\n\\n![image](https://assets.leetcode.com/users/images/4cafa42e-ed65-44ff-bc93-4c8bfcb1ef19_1662726770.512549.png)\\n\\n\\n    def constructArray(self, n, k):\\n        \"\"\" O(N)TS \"\"\"\\n        return list(range(1, n - k)) + [n - j if i % 2 else n - k + j for i in range(k + 1) if (j := i // 2) is not None]\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n![image](https://assets.leetcode.com/users/images/1afdb07b-3001-47e0-95b4-985c1ccf7966_1662731459.4971755.png)\\n\\n    def constructArray(self, n, k):\\n        a, b = list(range(1, n - k)), list(range(n - k, n + 1))\\n        c = [b[j] for i in range(1 + (len(b) - 1) // 2) for j in {i: 0, len(b) - 1 - i: 0}]\\n        return a + c",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/cab57f9a-7578-4b10-b0c8-6cb54cfb4fb5_1662726547.730287.png)\\n\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        \"\"\" O(N)TS \"\"\"\\n        ans, nums = list(range(1, n - k)), collections.deque(range(n - k, n + 1))\\n\\n        while len(nums) > 1:\\n            ans += nums.popleft(), nums.pop()\\n\\n        return ans + list(nums)\\n\\t\\nand..oneliner))\\n\\n![image](https://assets.leetcode.com/users/images/4cafa42e-ed65-44ff-bc93-4c8bfcb1ef19_1662726770.512549.png)\\n\\n\\n    def constructArray(self, n, k):\\n        \"\"\" O(N)TS \"\"\"\\n        return list(range(1, n - k)) + [n - j if i % 2 else n - k + j for i in range(k + 1) if (j := i // 2) is not None]\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n![image](https://assets.leetcode.com/users/images/1afdb07b-3001-47e0-95b4-985c1ccf7966_1662731459.4971755.png)\\n\\n    def constructArray(self, n, k):\\n        a, b = list(range(1, n - k)), list(range(n - k, n + 1))\\n        c = [b[j] for i in range(1 + (len(b) - 1) // 2) for j in {i: 0, len(b) - 1 - i: 0}]\\n        return a + c",
                "codeTag": "Python3"
            },
            {
                "id": 2465818,
                "title": "c-two-pointers-o-n-no-mod-operation",
                "content": "```\\nvector<int> constructArray(int n, int k) {\\n\\tvector<int> ans;\\n\\tans.reserve(n);\\n\\tint l=1, r=k+1;\\n\\twhile (l<r) {\\n\\t\\tans.push_back(l++);\\n\\t\\tans.push_back(r--);\\n\\t}\\n\\tif (l==r) ans.push_back(l);\\n\\tfor (int i=k+2; i<=n; i++)\\n\\t\\tans.push_back(i);\\n\\treturn ans;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvector<int> constructArray(int n, int k) {\\n\\tvector<int> ans;\\n\\tans.reserve(n);\\n\\tint l=1, r=k+1;\\n\\twhile (l<r) {\\n\\t\\tans.push_back(l++);\\n\\t\\tans.push_back(r--);\\n\\t}\\n\\tif (l==r) ans.push_back(l);\\n\\tfor (int i=k+2; i<=n; i++)\\n\\t\\tans.push_back(i);\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2438292,
                "title": "easier-to-understang-logic",
                "content": "When k is greater than 1, there is a simple pattern to fill the array with numbers as [ 1 , n-1, 2 , n-2, 3 , n-2....]. Now when k =1 we need constant difference between all the left numbers. |a-b| == |c-d|. For the this, the most appropriate constant difference is 1. \\n\\nFor example. N=6 and k =3\\ntill k=2 answer vector will be filled as [ 1, 6, 2 ]\\nfor k =1. the rest elements can be filled as [1, 6, 2, 3, 4, 5]\\n\\nFor N=6 and k =4\\ntill k=3 answer vector will be filled as [ 1, 6, 2, 5 ]\\nfor k =1. the rest elements can be filled as [1, 6, 2, 5, 4,3].\\n\\nSo for k =1, the trick is check the last element filled. if it was filled with s (smaller number) next elements will be filled in increasing order. [......2, 3, 4, 5]\\nif it was filled with e (bigger number) next elements will be filled first in decreasing order till s==e and then in increasing order. [....,6, 2, 5, 4,3].\\n\\n```\\nvector<int> constructArray(int n, int k) {\\n        int s=2, e=n;\\n        vector<int> ans(n);\\n        ans[0]=1;\\n        \\n        int i=1;\\n        while(i<n){\\n            if(k>1){\\n                ans[i++]=i%2==0? s++ : e--;\\n                k--;\\n            }else{\\n                if(ans[i-1]<s || s==e){\\n                    ans[i++]=s++;\\n                }else{\\n                    if(e>s){\\n                        ans[i++]=e--;\\n                    }\\n                }\\n            }\\n        }  \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> constructArray(int n, int k) {\\n        int s=2, e=n;\\n        vector<int> ans(n);\\n        ans[0]=1;\\n        \\n        int i=1;\\n        while(i<n){\\n            if(k>1){\\n                ans[i++]=i%2==0? s++ : e--;\\n                k--;\\n            }else{\\n                if(ans[i-1]<s || s==e){\\n                    ans[i++]=s++;\\n                }else{\\n                    if(e>s){\\n                        ans[i++]=e--;\\n                    }\\n                }\\n            }\\n        }  \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2426382,
                "title": "construct-with-patterns-c",
                "content": "```c++\\nclass Solution {\\npublic:\\n    /*\\n        1, 2, 3, ..., n - 1, n         k = 1\\n        \\n        1, n, 2, n - 1, 3, n - 2, ...  k = n - 1\\n        \\n        construct sequence with same diff with first pattern using n - k numbers\\n        \\n        construct sequence with k - 1 diff with the second pattern using last m numbers (m = k)\\n        \\n    */\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> res;\\n        for (int i = 0; i < n - k - 1; i++) {\\n            res.push_back(i + 1);\\n        }\\n        \\n        for (int t = n - k - 1, i = n - k, j = n; t < n;) {\\n            res.push_back(i);\\n            i++, t++;\\n            if (t < n) {\\n                res.push_back(j);\\n                j--, t++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    /*\\n        1, 2, 3, ..., n - 1, n         k = 1\\n        \\n        1, n, 2, n - 1, 3, n - 2, ...  k = n - 1\\n        \\n        construct sequence with same diff with first pattern using n - k numbers\\n        \\n        construct sequence with k - 1 diff with the second pattern using last m numbers (m = k)\\n        \\n    */\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> res;\\n        for (int i = 0; i < n - k - 1; i++) {\\n            res.push_back(i + 1);\\n        }\\n        \\n        for (int t = n - k - 1, i = n - k, j = n; t < n;) {\\n            res.push_back(i);\\n            i++, t++;\\n            if (t < n) {\\n                res.push_back(j);\\n                j--, t++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411264,
                "title": "c-o-n-very-detailed-explanation-very-interesting-math-problem-figuring-out-a-pattern",
                "content": "![image](https://assets.leetcode.com/users/images/092c9b5b-6de8-434d-bb40-ae1dfb5bf9b4_1660221521.7592764.jpeg)\\nit is tricky to figure out this pattern\\nwe know k is guaranteed to be <= n-1, we just need to find the most optimal solution where n = k+1, although n might be much larger than k+1.\\nat first, i manually wrote the most opmital solutions for k=1,2,3,4,5. then i figured out a pattern. \\nin an optimal solution, we need to find distinct difference values from 1-k.  \\nhow to achieve that? we put the max and min in pairs.\\nfor example if k = 5, then n = k+1 = 6, we choose from 1 to 6 \\n(6, 1), (5, 2), (4, 3) all the differences within pairs and between pairs are distinct! \\nwhats more. all the differences are in sorted descending order: 5 4 3 2 1\\nwe can use this sorted difference list to construct the answer.\\nafter we construct optimal solution for k, what if there are still many more n left? \\nwe cannot create anymore distinct differences now, and all the remaining numbers are bigger than k+1, which is the biggest number in our current answer list. \\nthus, it is intuitive to reverse our answer list, and append all remaining numbers in ascending order to the back of answer list.  All the differences between pairs of numbers  will be 1, which already exists. \\nfor example if k=5 and n = 10, the answer will be \\n3 4 2 5 1 6 | 7 8 9 10\\nnote that before \"|\" is our optimal solution for k=5, after \"|\" is simply appending remaining numbers and maintain a difference of 1, which already exists in abs(3-4)\\n```\\nvector<int> constructArray(int n, int k) {\\n        vector<int> res(n);\\n        int big = k+1;\\n        int small = 1;\\n        int i = k;\\n        while(i>=0&&big>=small){\\n            if(i>=0) res[i--] = big--;\\n            if(i>=0) res[i--] = small++;\\n        }\\n        for(int i=k+1; i<n; i++) res[i] = res[i-1]+1;\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> constructArray(int n, int k) {\\n        vector<int> res(n);\\n        int big = k+1;\\n        int small = 1;\\n        int i = k;\\n        while(i>=0&&big>=small){\\n            if(i>=0) res[i--] = big--;\\n            if(i>=0) res[i--] = small++;\\n        }\\n        for(int i=k+1; i<n; i++) res[i] = res[i-1]+1;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2411171,
                "title": "my-solution",
                "content": "```\\n/**\\n * 1. let n = 5, k = 1\\n *    1, 2, 3, 4, 5\\n * 2. let n = 5, k = 2\\n *    1, 3, 2, 4, 5\\n * 3. let n = 5, k = 3\\n *    1, 4, 2, 3, 5\\n * 4. let n = 5, k = 4\\n *    1, 5, 2, 4, 3\\n *\\n * for any `n` and `k`,\\n * 1, k + 1, 2, k, 3, k - 2, ..., k + 2, k + 3, ..., n\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n public:\\n  vector<int> constructArray(const int n, const int k) {\\n    vector<int> ret(n);\\n    int index = 0;\\n    int begin = 1;\\n    int end = k + 1;\\n    while (begin <= end) {\\n      ret[index++] = begin;\\n      if (begin != end) {\\n        ret[index++] = end;\\n      }\\n      ++begin;\\n      --end;\\n    }\\n    for (int i = k + 2; i < n + 1; ++i) {\\n      ret[i - 1] = i;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * 1. let n = 5, k = 1\\n *    1, 2, 3, 4, 5\\n * 2. let n = 5, k = 2\\n *    1, 3, 2, 4, 5\\n * 3. let n = 5, k = 3\\n *    1, 4, 2, 3, 5\\n * 4. let n = 5, k = 4\\n *    1, 5, 2, 4, 3\\n *\\n * for any `n` and `k`,\\n * 1, k + 1, 2, k, 3, k - 2, ..., k + 2, k + 3, ..., n\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n public:\\n  vector<int> constructArray(const int n, const int k) {\\n    vector<int> ret(n);\\n    int index = 0;\\n    int begin = 1;\\n    int end = k + 1;\\n    while (begin <= end) {\\n      ret[index++] = begin;\\n      if (begin != end) {\\n        ret[index++] = end;\\n      }\\n      ++begin;\\n      --end;\\n    }\\n    for (int i = k + 2; i < n + 1; ++i) {\\n      ret[i - 1] = i;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406931,
                "title": "c-greedy-approach-simple-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n     \\n        int i = 2, j = k + 1;\\n        vector<int> v{1};\\n        vector<bool> included(n + 1, false);\\n        included[1] = true;\\n        \\n        while(k > 1)\\n        {\\n            v.push_back(j), k--;\\n            included[j--] = true;\\n            \\n            if(k > 1)\\n            {\\n                v.push_back(i), k--;\\n                included[i++] = true;\\n            }\\n        }\\n        \\n        while(i <= n)\\n        {\\n            if(!included[i])\\n                v.push_back(i);\\n            \\n            i++;\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n     \\n        int i = 2, j = k + 1;\\n        vector<int> v{1};\\n        vector<bool> included(n + 1, false);\\n        included[1] = true;\\n        \\n        while(k > 1)\\n        {\\n            v.push_back(j), k--;\\n            included[j--] = true;\\n            \\n            if(k > 1)\\n            {\\n                v.push_back(i), k--;\\n                included[i++] = true;\\n            }\\n        }\\n        \\n        while(i <= n)\\n        {\\n            if(!included[i])\\n                v.push_back(i);\\n            \\n            i++;\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2371253,
                "title": "c-observation-time-complexity-o-n-space-complexity-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans;\\n        for(int i=1; i<=n; i++){\\n            ans.push_back(i);\\n        }\\n        \\n        int j = 1;\\n        \\n        for(int i=k; i>0; i--){\\n            if(j%2!=0){\\n                ans[j] = ans[j-1]+i;\\n            }\\n            else{\\n                ans[j] = ans[j-1]-i;\\n            }\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> ans;\\n        for(int i=1; i<=n; i++){\\n            ans.push_back(i);\\n        }\\n        \\n        int j = 1;\\n        \\n        for(int i=k; i>0; i--){\\n            if(j%2!=0){\\n                ans[j] = ans[j-1]+i;\\n            }\\n            else{\\n                ans[j] = ans[j-1]-i;\\n            }\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320423,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\tvar constructArray = function(n, k) {\\n\\t\\tconst result = [];\\n\\t\\tlet left = 1;\\n\\t\\tlet right = n;\\n\\n\\t\\tfor (let index = 0; index < n; index++) {\\n\\t\\t\\tif (k === 1) {\\n\\t\\t\\t\\tresult.push(left++);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tconst num = k & 1 ? left++ : right--;\\n\\t\\t\\tresult.push(num);\\n\\t\\t\\tk -= 1;\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar constructArray = function(n, k) {\\n\\t\\tconst result = [];\\n\\t\\tlet left = 1;\\n\\t\\tlet right = n;\\n\\n\\t\\tfor (let index = 0; index < n; index++) {\\n\\t\\t\\tif (k === 1) {\\n\\t\\t\\t\\tresult.push(left++);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tconst num = k & 1 ? left++ : right--;\\n\\t\\t\\tresult.push(num);\\n\\t\\t\\tk -= 1;\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2263386,
                "title": "simple-o-n-c-simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        int i = 0;\\n        int first = 1;\\n        int second = first+k;\\n        vector<int> ans;\\n        ans.push_back(first);\\n        int currCount = 2+k;\\n        for(int i=1;i<n;i++){\\n            if(i%2 != 0 && i<=k){\\n                ans.push_back(second);\\n                second--;\\n            } else {\\n                if(i>k){\\n                    ans.push_back(currCount++);\\n                } else{\\n                    first++;\\n                    ans.push_back(first);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n        /*\\n        6, 5;\\n        1, 6, 2, 5, 3, 4;\\n        5, 4, 3, 2, 1;\\n        \\n        6, 4\\n        1, 5, 2, 4, 3, 6;\\n        4, 3, 2, 1, 3;\\n        \\n        6, 3;\\n        1, 4, 2, 3, 5, 6\\n        \\n        \\n        20, 9;\\n        1, 10, 2, 9, 3, 8, 4, 7, 5, 6, 11 ;\\n        9, 8, 7, 6, 5, 4, 3, 2, 1, 6 ;\\n        */\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        int i = 0;\\n        int first = 1;\\n        int second = first+k;\\n        vector<int> ans;\\n        ans.push_back(first);\\n        int currCount = 2+k;\\n        for(int i=1;i<n;i++){\\n            if(i%2 != 0 && i<=k){\\n                ans.push_back(second);\\n                second--;\\n            } else {\\n                if(i>k){\\n                    ans.push_back(currCount++);\\n                } else{\\n                    first++;\\n                    ans.push_back(first);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n        /*\\n        6, 5;\\n        1, 6, 2, 5, 3, 4;\\n        5, 4, 3, 2, 1;\\n        \\n        6, 4\\n        1, 5, 2, 4, 3, 6;\\n        4, 3, 2, 1, 3;\\n        \\n        6, 3;\\n        1, 4, 2, 3, 5, 6\\n        \\n        \\n        20, 9;\\n        1, 10, 2, 9, 3, 8, 4, 7, 5, 6, 11 ;\\n        9, 8, 7, 6, 5, 4, 3, 2, 1, 6 ;\\n        */\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2231840,
                "title": "js-solution",
                "content": "```\\nvar constructArray = function(n, k) {\\n    const ans = [1];\\n    \\n    const used = new Map();\\n    used.set(1, true);\\n    \\n    for(let i = n - 1; i > 0; i--) {\\n        if(i <= k) {\\n            const plus = ans.at(-1) + i, minus = ans.at(-1) - i;\\n            if(!used.get(plus) && plus <= n && plus >= 1) \\n                ans.push(plus), used.set(plus, true);\\n            else \\n                ans.push(minus), used.set(minus, true);\\n        } else {\\n            ans.push(ans.at(-1) + 1);\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar constructArray = function(n, k) {\\n    const ans = [1];\\n    \\n    const used = new Map();\\n    used.set(1, true);\\n    \\n    for(let i = n - 1; i > 0; i--) {\\n        if(i <= k) {\\n            const plus = ans.at(-1) + i, minus = ans.at(-1) - i;\\n            if(!used.get(plus) && plus <= n && plus >= 1) \\n                ans.push(plus), used.set(plus, true);\\n            else \\n                ans.push(minus), used.set(minus, true);\\n        } else {\\n            ans.push(ans.at(-1) + 1);\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2231808,
                "title": "naive-js-solution",
                "content": "```\\nvar constructArray = function(n, k) {\\n    // 1 2 3 4 5\\n    // 1 2 3 4 5\\n    // 1 1 2 1 => 1 2 3 5 4\\n    // 1 3 2 1 => 1 2 5 3 4\\n    // 4 3 2 1 => 1 5 2 4 3\\n    // build pattern\\n    const pattern = new Array(n - 1).fill(1);\\n    for(let i = n - 1 - k; i < n -1; i++, k--) {\\n        pattern[i] = k;\\n    }\\n    const ans = [1];\\n    console.log(pattern)\\n    for(let x of pattern) {\\n        const top = ans.at(-1);\\n        if(x + top <= n && x + top >= 1 && !ans.includes(x + top)) ans.push(x + top);\\n        else ans.push(top - x);\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar constructArray = function(n, k) {\\n    // 1 2 3 4 5\\n    // 1 2 3 4 5\\n    // 1 1 2 1 => 1 2 3 5 4\\n    // 1 3 2 1 => 1 2 5 3 4\\n    // 4 3 2 1 => 1 5 2 4 3\\n    // build pattern\\n    const pattern = new Array(n - 1).fill(1);\\n    for(let i = n - 1 - k; i < n -1; i++, k--) {\\n        pattern[i] = k;\\n    }\\n    const ans = [1];\\n    console.log(pattern)\\n    for(let x of pattern) {\\n        const top = ans.at(-1);\\n        if(x + top <= n && x + top >= 1 && !ans.includes(x + top)) ans.push(x + top);\\n        else ans.push(top - x);\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2226023,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> nums = {1}; \\n        int st = 1, last = 1, t = k;\\n        while(k){\\n            last = last+k*st; \\n            nums.push_back(last); st = st*-1; k--;\\n        }\\n        for(int i = t+2; i<=n;++i) nums.push_back(i);\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> nums = {1}; \\n        int st = 1, last = 1, t = k;\\n        while(k){\\n            last = last+k*st; \\n            nums.push_back(last); st = st*-1; k--;\\n        }\\n        for(int i = t+2; i<=n;++i) nums.push_back(i);\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172716,
                "title": "full-hinglish-explanation-of-code-intuition-crux-of-question",
                "content": "```\\nvector<int> constructArray(int n, int k) {\\n        \\n        /*Main logic --> \\n        Alternate inserting till we achieve our aim then just the same diff of 1\\n            \\n            n=12 k=6\\n            \\n            1 12 2 11 3 10 9 8 7 6 5 4\\n    diff   11 10 9  8 7  1 1 1 1 1 1 1         no of distinct elements =6 hence proved   */\\n        \\n        \\n//Step 1 Initalize the array by inserting 1 first as from 2nd index our k will start to decrease \\n        vector<int> arr(n);\\n        int i=2,j=n,idx=1,flag=0;\\n        arr[0]=1;\\n        \\n//Step 2 Alternate inserting till k>1\\n        while(k>1)        \\n        {\\n            if(flag==0)   //bhai ab max element daldo jab b count even ho 1 9 2 8 3 7\\n            {\\n                arr[idx++]=j--;\\n                flag=1;\\n            }\\n            \\n            else   \\n            {\\n                flag=0;\\n                arr[idx++]=i++;\\n            }\\n            k--;\\n        }\\n/* Step 3 Ab k-1 distinct hogye ab bas 1 ke diff me isnert krdo baaki bche hue\\n\\nIMPORTANT PART --> j wala element dalna tha(flag==0) par ab we are like this  for n=12 k=3 \\n1 12 2 we have succesfully made 2 distinct elements now we need just 1 more so we will add i till it last  \\n             ans ={1,12,2,3,4,5,6,7,8,9,10,11}  distinct elemnts ={11,10,1}; \\n             \\nSo thats why              \\n 1. If i\\'s turn then we will insert j as we want just gap 1 for all not decrease k further\\n 2. If j\\'s turn then we will insert i as we want just gap 1 for all not decrease k further\\n*/\\n        \\n        if(flag==0)  \\n        {\\n            while(i<=j)\\n            arr[idx++]=i++;\\n        }\\n        \\n        if(flag==1)  \\n        {\\n            while(j>=i)\\n            arr[idx++]=j--;\\n        }\\n        \\n        return arr;\\n    }",
                "solutionTags": [],
                "code": "```\\nvector<int> constructArray(int n, int k) {\\n        \\n        /*Main logic --> \\n        Alternate inserting till we achieve our aim then just the same diff of 1\\n            \\n            n=12 k=6\\n            \\n            1 12 2 11 3 10 9 8 7 6 5 4\\n    diff   11 10 9  8 7  1 1 1 1 1 1 1         no of distinct elements =6 hence proved   */\\n        \\n        \\n//Step 1 Initalize the array by inserting 1 first as from 2nd index our k will start to decrease \\n        vector<int> arr(n);\\n        int i=2,j=n,idx=1,flag=0;\\n        arr[0]=1;\\n        \\n//Step 2 Alternate inserting till k>1\\n        while(k>1)        \\n        {\\n            if(flag==0)   //bhai ab max element daldo jab b count even ho 1 9 2 8 3 7\\n            {\\n                arr[idx++]=j--;\\n                flag=1;\\n            }\\n            \\n            else   \\n            {\\n                flag=0;\\n                arr[idx++]=i++;\\n            }\\n            k--;\\n        }\\n/* Step 3 Ab k-1 distinct hogye ab bas 1 ke diff me isnert krdo baaki bche hue\\n\\nIMPORTANT PART --> j wala element dalna tha(flag==0) par ab we are like this  for n=12 k=3 \\n1 12 2 we have succesfully made 2 distinct elements now we need just 1 more so we will add i till it last  \\n             ans ={1,12,2,3,4,5,6,7,8,9,10,11}  distinct elemnts ={11,10,1}; \\n             \\nSo thats why              \\n 1. If i\\'s turn then we will insert j as we want just gap 1 for all not decrease k further\\n 2. If j\\'s turn then we will insert i as we want just gap 1 for all not decrease k further\\n*/\\n        \\n        if(flag==0)  \\n        {\\n            while(i<=j)\\n            arr[idx++]=i++;\\n        }\\n        \\n        if(flag==1)  \\n        {\\n            while(j>=i)\\n            arr[idx++]=j--;\\n        }\\n        \\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2116096,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n       vector<int> ans(n);\\n       int left=1,right=k+1;\\n       int idx=0;\\n        while(idx<k)\\n        {\\n            ans[idx++]=left++;\\n            ans[idx++]=right--;\\n        }\\n        if(left==right)\\n        {\\n            ans[idx++]=right;\\n        }\\n        while(idx<n)\\n        {\\n            ans[idx++]=idx+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n       vector<int> ans(n);\\n       int left=1,right=k+1;\\n       int idx=0;\\n        while(idx<k)\\n        {\\n            ans[idx++]=left++;\\n            ans[idx++]=right--;\\n        }\\n        if(left==right)\\n        {\\n            ans[idx++]=right;\\n        }\\n        while(idx<n)\\n        {\\n            ans[idx++]=idx+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106533,
                "title": "c-greedy-simple",
                "content": "Simple idea:\\n\\nquestion : return array of length n, with numbers 1 to n, such that the array (|a1 - a2|, |a2 - a3|, ...) has k distinct integers.\\n\\nidea : Notice this. (k + 1) - 1 = k, then (k + 1) - 2 = k - 1, then (k) - 2 = k - 2...\\n\\nBasically, we generate such sequence, such that **all the distinct differences** are placed at the front part of the array.\\n\\nOnce we have exactly k distinct differences, we can put {*whatever numbers at the back*}, such that the size of array is n.\\n\\nFor example, if n = 8, k = 4, so (k + 1) = 5, we have:\\n\\n[1, 5, 2, 4, 3, 6, 7, 8]\\n\\nSo that: \\n\\n[**1, 5, 2, 4, {3**, *6, 7, 8*}]\\n\\nThe differences:\\n[**4, 3, 2, 1**, {*3, 1, 1*}]\\n\\nOne way to create such sequence is as follows:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    set<int> S;\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> res;\\n        if (k == 1) {\\n            for (int v = 1; v <= n; v++) {\\n                res.push_back(v);\\n            }\\n        }\\n        else {\\n            int l = 1;\\n            int r = k + 1; \\n            while (l < r) {\\n                res.push_back(l);\\n                res.push_back(r);\\n                S.insert(l);\\n                S.insert(r);\\n                l++;\\n                r--;\\n            }\\n            for (int v = 1; v <= n; v++) {\\n                if (S.find(v) == S.end()) {\\n                    res.push_back(v);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    set<int> S;\\n    vector<int> constructArray(int n, int k) {\\n        vector<int> res;\\n        if (k == 1) {\\n            for (int v = 1; v <= n; v++) {\\n                res.push_back(v);\\n            }\\n        }\\n        else {\\n            int l = 1;\\n            int r = k + 1; \\n            while (l < r) {\\n                res.push_back(l);\\n                res.push_back(r);\\n                S.insert(l);\\n                S.insert(r);\\n                l++;\\n                r--;\\n            }\\n            for (int v = 1; v <= n; v++) {\\n                if (S.find(v) == S.end()) {\\n                    res.push_back(v);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2037710,
                "title": "i-can-guarantee-that-this-will-be-the-best-soln-so-far",
                "content": "```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int inc=0;\\n        int dec=k+1;\\n        int arr[]=new int[n];\\n        for(int i=0;i<=k;i++){\\n            if(i%2==0) arr[i]=++inc;\\n            else arr[i]=dec--;\\n        }\\n        for(int i=k+1;i<n;i++){\\n            arr[i]=i+1;\\n        }\\n        return arr;\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int[] constructArray(int n, int k) {\\n        int inc=0;\\n        int dec=k+1;\\n        int arr[]=new int[n];\\n        for(int i=0;i<=k;i++){\\n            if(i%2==0) arr[i]=++inc;\\n            else arr[i]=dec--;\\n        }\\n        for(int i=k+1;i<n;i++){\\n            arr[i]=i+1;\\n        }\\n        return arr;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1964017,
                "title": "why-leetcode-saying-my-answer-in-wrong-please-help",
                "content": "Can someone explain to me why my answer below is wrong? It seems to me that  that I have 12 disctint absolute difference between the items\\nn=20\\nk=12\\n[1,13,2,12,3,11,18,12,17,13,16,14,15,4,5,6,7,8,9,10,19,20]",
                "solutionTags": [],
                "code": "Can someone explain to me why my answer below is wrong? It seems to me that  that I have 12 disctint absolute difference between the items\\nn=20\\nk=12\\n[1,13,2,12,3,11,18,12,17,13,16,14,15,4,5,6,7,8,9,10,19,20]",
                "codeTag": "Unknown"
            },
            {
                "id": 1928918,
                "title": "c-solution",
                "content": "Approach: **T.C -> O(n), A.S.C -> O(1)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        int i = 1, j = n;\\n        vector<int> res;\\n        \\n        while(i <= j) {\\n            if(k > 1) {\\n                res.push_back(k % 2 == 1 ? i++ : j--);\\n                k--;\\n            } else {\\n                res.push_back(i++);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        int i = 1, j = n;\\n        vector<int> res;\\n        \\n        while(i <= j) {\\n            if(k > 1) {\\n                res.push_back(k % 2 == 1 ? i++ : j--);\\n                k--;\\n            } else {\\n                res.push_back(i++);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1797344,
                "title": "super-simple-and-easy-to-understand-python-solution",
                "content": "The idea is to consturct k distinct using first k + 1 numbers. \\nThe absolute difference will be k, k - 1, k - 2, ..., 1.\\nThe sign will be alternative. +1, -1, +1, -1, ...\\n\\nAnd then we append the remaining numbers. \\nNote that the minimum last number of the first k + 1 numbers is 2, and the 1st number of the remaining sequence is k + 2. The difference will be at most k, which is covered already. The remaining differences will be all 1s.\\n        \\n        res = [1] * (k + 1)        \\n        diff = k\\n        sign = 1\\n        for i in range(1, k + 1):\\n            res[i] = res[i - 1] + sign * diff\\n            diff -= 1\\n            sign *= -1\\n        \\n        return res + list(range(k + 2, n + 1))",
                "solutionTags": [],
                "code": "The idea is to consturct k distinct using first k + 1 numbers. \\nThe absolute difference will be k, k - 1, k - 2, ..., 1.\\nThe sign will be alternative. +1, -1, +1, -1, ...\\n\\nAnd then we append the remaining numbers. \\nNote that the minimum last number of the first k + 1 numbers is 2, and the 1st number of the remaining sequence is k + 2. The difference will be at most k, which is covered already. The remaining differences will be all 1s.\\n        \\n        res = [1] * (k + 1)        \\n        diff = k\\n        sign = 1\\n        for i in range(1, k + 1):\\n            res[i] = res[i - 1] + sign * diff\\n            diff -= 1\\n            sign *= -1\\n        \\n        return res + list(range(k + 2, n + 1))",
                "codeTag": "Unknown"
            },
            {
                "id": 1780346,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        \\n\\t\\n        vector<int> res;\\n        \\n        int a = ceil(k/2.0);\\n        \\n        int b = a+1;\\n        \\n        for(int i=0; i < n; i++)\\n        {\\n            if(i < k && k%2 != i%2)\\n            {\\n               res.push_back(a--) ;\\n            }\\n            else\\n            {\\n                res.push_back(b++);\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        \\n\\t\\n        vector<int> res;\\n        \\n        int a = ceil(k/2.0);\\n        \\n        int b = a+1;\\n        \\n        for(int i=0; i < n; i++)\\n        {\\n            if(i < k && k%2 != i%2)\\n            {\\n               res.push_back(a--) ;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1698845,
                "title": "another-clean-and-easy-python-code-with-top-bottom-two-variables",
                "content": "if k = 1, we can imagine, only diff 1 \\nn = 4, will be [1,2,3,4]\\nn = 6, will be [1,2,3,4,5,6]\\n\\nwhen k = 2, we want to make diff as 1,2\\nso keep to add diff1 until we collect enough and then add diff 2\\nn = 6 will be [1,2,3,4,6,5] so we add until 4, making 6-4 = 2 (k)\\nhow to decide 4? , 4 will be n - k, cuz we want to make the first diff as k \\nand then down, up, down, up until end\\n\\ntaking k = 5, k = 7\\nans will be [1,2,7,3,6,4,5]\\nthe process of (down, up, down, up), we can use two variable (top, bottom) each round -1, and +1 \\n\\n\\n```\\ndef constructArray(self, n: int, k: int) -> List[int]:\\n        ans = list(range(1, n - k + 1))\\n        \\n        top, bottom = n, ans[-1] + 1\\n        for i in range(k):\\n            if i % 2 == 0:\\n                ans.append(top)\\n                top -= 1\\n            else:\\n                ans.append(bottom)\\n                bottom += 1\\n        return ans\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndef constructArray(self, n: int, k: int) -> List[int]:\\n        ans = list(range(1, n - k + 1))\\n        \\n        top, bottom = n, ans[-1] + 1\\n        for i in range(k):\\n            if i % 2 == 0:\\n                ans.append(top)\\n                top -= 1\\n            else:\\n                ans.append(bottom)\\n                bottom += 1\\n        return ans\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1616557,
                "title": "scala-resursive-solution",
                "content": "```scala\\n/**\\n  permutation:\\n    n==k :  1, n, 2, n-1, 3, n-2, ...\\n    k%2=1:  1, n, 2, n-(k/2), ... n-(k/2)-1, n-(k/2)-2, ...\\n    k%2=0:  1, n, 2, ... k/2, k/2+1,...\\n */\\nobject Solution {\\n  def constructArray(n: Int, k: Int): Array[Int] = {\\n    def constructArrayImpl(n: Int, k: Int, delta:Int, acc:List[Int]): Array[Int] = {\\n      lazy val newDelta = if(delta>0) 1-delta else -delta-1\\n      lazy val deltaSign = if(delta>0) 1 else -1\\n      if(n==0) acc.toArray.reverse\\n      else if(k==0) \\n        acc.reverse.to(Array) ++\\n          ((acc.head + deltaSign) to (acc.head + n*(deltaSign)) by deltaSign).to(Array) \\n      else \\n        constructArrayImpl(n-1, k-1, newDelta, (acc.head + delta) +: acc)\\n    }\\n    constructArrayImpl(n-1, k-1, n-1, List(1))\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Recursion"
                ],
                "code": "```scala\\n/**\\n  permutation:\\n    n==k :  1, n, 2, n-1, 3, n-2, ...\\n    k%2=1:  1, n, 2, n-(k/2), ... n-(k/2)-1, n-(k/2)-2, ...\\n    k%2=0:  1, n, 2, ... k/2, k/2+1,...\\n */\\nobject Solution {\\n  def constructArray(n: Int, k: Int): Array[Int] = {\\n    def constructArrayImpl(n: Int, k: Int, delta:Int, acc:List[Int]): Array[Int] = {\\n      lazy val newDelta = if(delta>0) 1-delta else -delta-1\\n      lazy val deltaSign = if(delta>0) 1 else -1\\n      if(n==0) acc.toArray.reverse\\n      else if(k==0) \\n        acc.reverse.to(Array) ++\\n          ((acc.head + deltaSign) to (acc.head + n*(deltaSign)) by deltaSign).to(Array) \\n      else \\n        constructArrayImpl(n-1, k-1, newDelta, (acc.head + delta) +: acc)\\n    }\\n    constructArrayImpl(n-1, k-1, n-1, List(1))\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1609670,
                "title": "swift-simple-solution",
                "content": "```\\nclass Solution {\\n    func constructArray(_ n: Int, _ k: Int) -> [Int] {\\n        var queue: [Int] = []\\n        for i in 1..<(n + 1) {\\n            queue.append(i)\\n        }\\n        \\n        var result: [Int] = []\\n        var lower: Int = 0\\n        var upper: Int = k\\n        for i in 1...(k + 1) {\\n            if lower > upper {\\n                break\\n            }\\n            if i % 2 == 0 {\\n                result.append(queue[upper])\\n                upper -= 1\\n            } else {\\n                result.append(queue[lower])\\n                lower += 1\\n            }\\n        }\\n        \\n        for i in (k + 1)..<queue.count {\\n            result.append(queue[i])\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func constructArray(_ n: Int, _ k: Int) -> [Int] {\\n        var queue: [Int] = []\\n        for i in 1..<(n + 1) {\\n            queue.append(i)\\n        }\\n        \\n        var result: [Int] = []\\n        var lower: Int = 0\\n        var upper: Int = k\\n        for i in 1...(k + 1) {\\n            if lower > upper {\\n                break\\n            }\\n            if i % 2 == 0 {\\n                result.append(queue[upper])\\n                upper -= 1\\n            } else {\\n                result.append(queue[lower])\\n                lower += 1\\n            }\\n        }\\n        \\n        for i in (k + 1)..<queue.count {\\n            result.append(queue[i])\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1574163,
                "title": "python3-solution-100-faster-4-line-code",
                "content": "```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        result = list(range(1,n+1))\\n        result[0 : k+1 : 2] = list(range(1,(k+2)//2 + 1))\\n        result[1 : k+1 : 2] = list(range(k+1,(k+2)//2,-1))\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        result = list(range(1,n+1))\\n        result[0 : k+1 : 2] = list(range(1,(k+2)//2 + 1))\\n        result[1 : k+1 : 2] = list(range(k+1,(k+2)//2,-1))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1558635,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public void flip(int[] nums, int left, int right){\\n        while(left <= right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n    public int[] constructArray(int n, int k) {\\n        int[] nums = new int[n];\\n        \\n        for(int i=1; i<=n; i++)\\n            nums[i-1] = i;\\n        \\n        int i = 0;\\n        while(i != k){\\n            flip(nums, i, n-1);\\n            i++;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void flip(int[] nums, int left, int right){\\n        while(left <= right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n    public int[] constructArray(int n, int k) {\\n        int[] nums = new int[n];\\n        \\n        for(int i=1; i<=n; i++)\\n            nums[i-1] = i;\\n        \\n        int i = 0;\\n        while(i != k){\\n            flip(nums, i, n-1);\\n            i++;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529374,
                "title": "rust-4ms",
                "content": "```\\nimpl Solution {\\n    pub fn construct_array(n: i32, k: i32) -> Vec<i32> {\\n        let mut answer = vec![0;n as usize];\\n        let (mut a, mut z) = (1,k+1);\\n        for i in 0..=k{\\n            if i%2 ==0 {\\n                answer[i as usize] = a;\\n                a+=1;\\n            } else {\\n                answer[i as usize] = z;\\n                z-=1;\\n            }\\n        }\\n        let k = k +1;\\n        for i in k..n{\\n            answer[i as usize] = i+1;\\n        }\\n        answer\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn construct_array(n: i32, k: i32) -> Vec<i32> {\\n        let mut answer = vec![0;n as usize];\\n        let (mut a, mut z) = (1,k+1);\\n        for i in 0..=k{\\n            if i%2 ==0 {\\n                answer[i as usize] = a;\\n                a+=1;\\n            } else {\\n                answer[i as usize] = z;\\n                z-=1;\\n            }\\n        }\\n        let k = k +1;\\n        for i in k..n{\\n            answer[i as usize] = i+1;\\n        }\\n        answer\\n\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1481161,
                "title": "python-3-98-faster-explained-graphically",
                "content": "![image](https://assets.leetcode.com/users/images/7d71d037-cdca-48f5-ac28-89ad03c5f3dd_1632405399.398822.png)\\n![image](https://assets.leetcode.com/users/images/2a7996fb-c1f5-42ea-8aa5-f637d90994ff_1632405945.9730294.png)\\n\\n```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        # Take first k + 1 elements from the ascendingly sorted array\\n        # Place the first half at the even indices, and reversely place  \\n        # the second half at the gaps. Difference between the new k+1\\n        # and the original k+2 is not an issue, which is covered by the new\\n        # k + 1 elements.\\n        ans = [i+1 for i in range(n)]\\n        k += 1\\n        ans[:k:2], ans[(k-1)-(k&1)::-2] = ans[:(k+1)//2], ans[(k+1)//2:k]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        # Take first k + 1 elements from the ascendingly sorted array\\n        # Place the first half at the even indices, and reversely place  \\n        # the second half at the gaps. Difference between the new k+1\\n        # and the original k+2 is not an issue, which is covered by the new\\n        # k + 1 elements.\\n        ans = [i+1 for i in range(n)]\\n        k += 1\\n        ans[:k:2], ans[(k-1)-(k&1)::-2] = ans[:(k+1)//2], ans[(k+1)//2:k]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447565,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        l,h = 1,n\\n        res = [l]\\n        l += 1\\n        while k > 1:\\n            res.append(h)\\n            h -= 1\\n            k -= 1\\n            if k > 1:\\n                res.append(l)\\n                l += 1\\n                k -= 1\\n        if res[-1] == h+1:\\n            res += list(range(h,l-1,-1))\\n        else:\\n            res += list(range(l,h+1))\\n        return res\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        l,h = 1,n\\n        res = [l]\\n        l += 1\\n        while k > 1:\\n            res.append(h)\\n            h -= 1\\n            k -= 1\\n            if k > 1:\\n                res.append(l)\\n                l += 1\\n                k -= 1\\n        if res[-1] == h+1:\\n            res += list(range(h,l-1,-1))\\n        else:\\n            res += list(range(l,h+1))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418398,
                "title": "python-concise",
                "content": "```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        res = []\\n        \\n        i = 0\\n        j = k\\n        \\n        while i <= j:\\n            res.append(i+1)\\n            if i < j:\\n                res.append(j+1)\\n            i += 1\\n            j -= 1\\n            \\n        res += list(range(k+2, n+1))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constructArray(self, n: int, k: int) -> List[int]:\\n        res = []\\n        \\n        i = 0\\n        j = k\\n        \\n        while i <= j:\\n            res.append(i+1)\\n            if i < j:\\n                res.append(j+1)\\n            i += 1\\n            j -= 1\\n            \\n        res += list(range(k+2, n+1))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409341,
                "title": "python-simple-solution",
                "content": "```\\ndef constructArray(self, n: int, k: int) -> List[int]:\\n        \"\"\"\\n            take first and last element alternatively .\\n            sample :\\n            1 2 3 4 5 <= k=1\\n            1 5 4 3 2 <= k=2\\n            1 5 2 3 4 <= k=3\\n            1 5 2 4 3 <= k=4\\n        \"\"\"\\n        arr = [i for i in range(1, n+1)]\\n        if k == 1:\\n            return arr\\n        idx = 0\\n        res=[]\\n        while idx < k:\\n            if idx % 2 == 0:\\n                res.append(arr.pop(0))\\n            else:\\n                res.append(arr.pop())\\n            idx += 1\\n        if idx%2 == 0:\\n            res.extend(arr[::-1])\\n        else:\\n            res.extend(arr)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef constructArray(self, n: int, k: int) -> List[int]:\\n        \"\"\"\\n            take first and last element alternatively .\\n            sample :\\n            1 2 3 4 5 <= k=1\\n            1 5 4 3 2 <= k=2\\n            1 5 2 3 4 <= k=3\\n            1 5 2 4 3 <= k=4\\n        \"\"\"\\n        arr = [i for i in range(1, n+1)]\\n        if k == 1:\\n            return arr\\n        idx = 0\\n        res=[]\\n        while idx < k:\\n            if idx % 2 == 0:\\n                res.append(arr.pop(0))\\n            else:\\n                res.append(arr.pop())\\n            idx += 1\\n        if idx%2 == 0:\\n            res.extend(arr[::-1])\\n        else:\\n            res.extend(arr)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1400476,
                "title": "smart-solution-the-permutation-have-max-and-min-distinct-k-of-n-number",
                "content": "take n=10 for instance\\nthe minimum distinct differences      1, 2, 3, 4, 5, 6, 7, 8, 9, 10     is 1\\nthe maximum distinct differences       1, 10, 2, 9, 3, 8, 4, 7, 5, 6,    is 9\\nfinding the max gap is |1-n|  and write the following number by luck? \\n\\n\\n ```\\n def constructArray(self, n: int, k: int) -> List[int]:       \\n        \\n        # 1 10 2 9 3 8 4 7 5 6  n=10, maxk=9\\n        # 11 12 13 14  following number with abs 1 will not count\\n        \\n        #k nend k+1 num \\n        #from 1 to k+1\\n        \\n        link=[1,k+1]\\n        more=k+1-2\\n        while more>1:\\n            link.append(link[-2]+1)\\n            link.append(link[-2]-1)\\n            more-=2\\n        if more==1:\\n            link.append(link[-2]+1)\\n        \\n        left=[x for x in range(k+2,n+1)]\\n       \\n        return link+left\\n```",
                "solutionTags": [],
                "code": "```\\n def constructArray(self, n: int, k: int) -> List[int]:       \\n        \\n        # 1 10 2 9 3 8 4 7 5 6  n=10, maxk=9\\n        # 11 12 13 14  following number with abs 1 will not count\\n        \\n        #k nend k+1 num \\n        #from 1 to k+1\\n        \\n        link=[1,k+1]\\n        more=k+1-2\\n        while more>1:\\n            link.append(link[-2]+1)\\n            link.append(link[-2]-1)\\n            more-=2\\n        if more==1:\\n            link.append(link[-2]+1)\\n        \\n        left=[x for x in range(k+2,n+1)]\\n       \\n        return link+left\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1396322,
                "title": "eas-c-solution-with-explaination-0-n",
                "content": "// if k=1 then simply do 1,2,3,4...\\n\\n// if k=n-1 that is to get max no of differences we have place numbers in the format 1 , n-1 , 2 , n-2 , .....\\n\\n// so for any general n and k\\n// consider the length to be k+1 and get max no of differences by the above method and  after that at any index i place i+1.\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        \\n        vector<int> ans;\\n        int low = 1;\\n        int high = k+1;\\n        for(int i=0 ; i<k+1 ; i++)\\n        {\\n            if(i%2 == 0) \\n            {\\n                ans.push_back(low);\\n                low++;\\n            }\\n            else\\n            {\\n                ans.push_back(high);\\n                high--;\\n            }\\n        }\\n        \\n        for(int i = k+1 ; i<n ; i++ ) ans.push_back(i+1);\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> constructArray(int n, int k) {\\n        \\n        vector<int> ans;\\n        int low = 1;\\n        int high = k+1;\\n        for(int i=0 ; i<k+1 ; i++)\\n        {\\n            if(i%2 == 0) \\n            {\\n                ans.push_back(low);\\n                low++;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1574088,
                "content": [
                    {
                        "username": "Ranchhor",
                        "content": "I read this problem more than 10 times at the end i decided to left this problem. Please anyone explain the problem statement in details."
                    },
                    {
                        "username": "laichbr",
                        "content": "3 years old, but here\\'s the idea from future land : you want an array containing the values from 1 to n + 1. After point n-k, the values need to alternate from either the next point in the n+1 series at point n-k going forward or from point n  going backwards from your listing. This construction  can be thought of as two pointer, and can be constructed with a mapping of values available to use and values used already, as explained more here : https://leetcode.com/problems/beautiful-arrangement-ii/solutions/3569081/not-fast-but-more-explainable-than-original-question-commented-and-explained/"
                    },
                    {
                        "username": "user5130F",
                        "content": "Author himself will not understand the question after few days."
                    },
                    {
                        "username": "ZX007PI",
                        "content": "Sometimes I feel like a scientist trying to understand the meaning written in an ancient forgotten language ... What is the use of this task ??? What will this task teach me ???"
                    },
                    {
                        "username": "godshiva",
                        "content": "It\\'s testing if you just happen to know some strange theorem from number theory and if you don\\'t, too bad, I guess"
                    },
                    {
                        "username": "user4249wA",
                        "content": "text cases are fixed"
                    }
                ]
            },
            {
                "id": 1754371,
                "content": [
                    {
                        "username": "Ranchhor",
                        "content": "I read this problem more than 10 times at the end i decided to left this problem. Please anyone explain the problem statement in details."
                    },
                    {
                        "username": "laichbr",
                        "content": "3 years old, but here\\'s the idea from future land : you want an array containing the values from 1 to n + 1. After point n-k, the values need to alternate from either the next point in the n+1 series at point n-k going forward or from point n  going backwards from your listing. This construction  can be thought of as two pointer, and can be constructed with a mapping of values available to use and values used already, as explained more here : https://leetcode.com/problems/beautiful-arrangement-ii/solutions/3569081/not-fast-but-more-explainable-than-original-question-commented-and-explained/"
                    },
                    {
                        "username": "user5130F",
                        "content": "Author himself will not understand the question after few days."
                    },
                    {
                        "username": "ZX007PI",
                        "content": "Sometimes I feel like a scientist trying to understand the meaning written in an ancient forgotten language ... What is the use of this task ??? What will this task teach me ???"
                    },
                    {
                        "username": "godshiva",
                        "content": "It\\'s testing if you just happen to know some strange theorem from number theory and if you don\\'t, too bad, I guess"
                    },
                    {
                        "username": "user4249wA",
                        "content": "text cases are fixed"
                    }
                ]
            },
            {
                "id": 1575129,
                "content": [
                    {
                        "username": "Ranchhor",
                        "content": "I read this problem more than 10 times at the end i decided to left this problem. Please anyone explain the problem statement in details."
                    },
                    {
                        "username": "laichbr",
                        "content": "3 years old, but here\\'s the idea from future land : you want an array containing the values from 1 to n + 1. After point n-k, the values need to alternate from either the next point in the n+1 series at point n-k going forward or from point n  going backwards from your listing. This construction  can be thought of as two pointer, and can be constructed with a mapping of values available to use and values used already, as explained more here : https://leetcode.com/problems/beautiful-arrangement-ii/solutions/3569081/not-fast-but-more-explainable-than-original-question-commented-and-explained/"
                    },
                    {
                        "username": "user5130F",
                        "content": "Author himself will not understand the question after few days."
                    },
                    {
                        "username": "ZX007PI",
                        "content": "Sometimes I feel like a scientist trying to understand the meaning written in an ancient forgotten language ... What is the use of this task ??? What will this task teach me ???"
                    },
                    {
                        "username": "godshiva",
                        "content": "It\\'s testing if you just happen to know some strange theorem from number theory and if you don\\'t, too bad, I guess"
                    },
                    {
                        "username": "user4249wA",
                        "content": "text cases are fixed"
                    }
                ]
            },
            {
                "id": 2058656,
                "content": [
                    {
                        "username": "Ranchhor",
                        "content": "I read this problem more than 10 times at the end i decided to left this problem. Please anyone explain the problem statement in details."
                    },
                    {
                        "username": "laichbr",
                        "content": "3 years old, but here\\'s the idea from future land : you want an array containing the values from 1 to n + 1. After point n-k, the values need to alternate from either the next point in the n+1 series at point n-k going forward or from point n  going backwards from your listing. This construction  can be thought of as two pointer, and can be constructed with a mapping of values available to use and values used already, as explained more here : https://leetcode.com/problems/beautiful-arrangement-ii/solutions/3569081/not-fast-but-more-explainable-than-original-question-commented-and-explained/"
                    },
                    {
                        "username": "user5130F",
                        "content": "Author himself will not understand the question after few days."
                    },
                    {
                        "username": "ZX007PI",
                        "content": "Sometimes I feel like a scientist trying to understand the meaning written in an ancient forgotten language ... What is the use of this task ??? What will this task teach me ???"
                    },
                    {
                        "username": "godshiva",
                        "content": "It\\'s testing if you just happen to know some strange theorem from number theory and if you don\\'t, too bad, I guess"
                    },
                    {
                        "username": "user4249wA",
                        "content": "text cases are fixed"
                    }
                ]
            }
        ]
    },
    {
        "title": "Reorganize String",
        "question_content": "<p>Given a string <code>s</code>, rearrange the characters of <code>s</code> so that any two adjacent characters are not the same.</p>\n\n<p>Return <em>any possible rearrangement of</em> <code>s</code> <em>or return</em> <code>&quot;&quot;</code> <em>if not possible</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"aab\"\n<strong>Output:</strong> \"aba\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"aaab\"\n<strong>Output:</strong> \"\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 232469,
                "title": "java-no-sort-o-n-0ms-beat-100",
                "content": "No Sort O(N):\\n1. count letter appearance and store in hash[i]\\n2. find the letter with largest occurence. \\n3. put the letter into even index numbe (0, 2, 4 ...) char array\\n4. put the rest into the array\\n\\n```\\n    public String reorganizeString(String S) {\\n        int[] hash = new int[26];\\n        for (int i = 0; i < S.length(); i++) {\\n            hash[S.charAt(i) - \\'a\\']++;\\n        } \\n        int max = 0, letter = 0;\\n        for (int i = 0; i < hash.length; i++) {\\n            if (hash[i] > max) {\\n                max = hash[i];\\n                letter = i;\\n            }\\n        }\\n        if (max > (S.length() + 1) / 2) {\\n            return \"\"; \\n        }\\n        char[] res = new char[S.length()];\\n        int idx = 0;\\n        while (hash[letter] > 0) {\\n            res[idx] = (char) (letter + \\'a\\');\\n            idx += 2;\\n            hash[letter]--;\\n        }\\n        for (int i = 0; i < hash.length; i++) {\\n            while (hash[i] > 0) {\\n                if (idx >= res.length) {\\n                    idx = 1;\\n                }\\n                res[idx] = (char) (i + \\'a\\');\\n                idx += 2;\\n                hash[i]--;\\n            }\\n        }\\n        return String.valueOf(res);\\n    }\\n```\\nTime O(N): fill hash[] + find the letter + write results into char array\\nSpace O(N + 26): result + hash[]",
                "solutionTags": [],
                "code": "```\\n    public String reorganizeString(String S) {\\n        int[] hash = new int[26];\\n        for (int i = 0; i < S.length(); i++) {\\n            hash[S.charAt(i) - \\'a\\']++;\\n        } \\n        int max = 0, letter = 0;\\n        for (int i = 0; i < hash.length; i++) {\\n            if (hash[i] > max) {\\n                max = hash[i];\\n                letter = i;\\n            }\\n        }\\n        if (max > (S.length() + 1) / 2) {\\n            return \"\"; \\n        }\\n        char[] res = new char[S.length()];\\n        int idx = 0;\\n        while (hash[letter] > 0) {\\n            res[idx] = (char) (letter + \\'a\\');\\n            idx += 2;\\n            hash[letter]--;\\n        }\\n        for (int i = 0; i < hash.length; i++) {\\n            while (hash[i] > 0) {\\n                if (idx >= res.length) {\\n                    idx = 1;\\n                }\\n                res[idx] = (char) (i + \\'a\\');\\n                idx += 2;\\n                hash[i]--;\\n            }\\n        }\\n        return String.valueOf(res);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 113457,
                "title": "simple-python-solution-using-priorityqueue",
                "content": "The idea is to build a max heap with freq. count\\na) At each step, we choose the element with highest freq (a, b) where b is the element, to append to result.\\nb) Now that b is chosen. We cant choose b for the next loop. So we dont add b with decremented value count immediately into the heap. Rather we store it in prev_a, prev_b variables.\\nc) Before we update our prev_a, prev_b variables as mentioned in step 2, we know that whatever  prev_a, prev_b contains, has become eligible for next loop selection. so we add that back in the heap.\\n\\nIn essence, \\n- at each step, we make the currently added one  ineligible for next step, by not adding it to the heap\\n- at each step, we make the previously added one eligible for next step, by adding it back to the heap\\n\\n```\\n def reorganizeString(self, S):\\n        res, c = [], Counter(S)\\n        pq = [(-value,key) for key,value in c.items()]\\n        heapq.heapify(pq)\\n        p_a, p_b = 0, \\'\\'\\n        while pq:\\n            a, b = heapq.heappop(pq)\\n            res += [b]\\n            if p_a < 0:\\n                heapq.heappush(pq, (p_a, p_b))\\n            a += 1\\n            p_a, p_b = a, b\\n        res = \\'\\'.join(res)\\n        if len(res) != len(S): return \"\"\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n def reorganizeString(self, S):\\n        res, c = [], Counter(S)\\n        pq = [(-value,key) for key,value in c.items()]\\n        heapq.heapify(pq)\\n        p_a, p_b = 0, \\'\\'\\n        while pq:\\n            a, b = heapq.heappop(pq)\\n            res += [b]\\n            if p_a < 0:\\n                heapq.heappush(pq, (p_a, p_b))\\n            a += 1\\n            p_a, p_b = a, b\\n        res = \\'\\'.join(res)\\n        if len(res) != len(S): return \"\"\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 335312,
                "title": "c-beat-100",
                "content": "```cpp\\nstring reorganizeString(string S) {\\n\\tvector<int> cnt(26);\\n\\tint mostFreq = 0, i = 0;\\n\\n\\tfor(char c : S)\\n\\t\\tif(++cnt[c - \\'a\\'] > cnt[mostFreq])\\n\\t\\t\\tmostFreq = (c - \\'a\\');\\n\\n\\tif(2 * cnt[mostFreq] - 1 > S.size()) return \"\";\\n\\n\\twhile(cnt[mostFreq]) {\\n\\t\\tS[i] = (\\'a\\' + mostFreq);\\n\\t\\ti += 2;\\n\\t\\tcnt[mostFreq]--;\\n\\t}\\n\\n\\tfor(int j = 0; j < 26; j++) {\\n\\t\\twhile(cnt[j]) {\\n\\t\\t\\tif(i >= S.size()) i = 1;\\n\\t\\t\\tS[i] = (\\'a\\' + j);\\n\\t\\t\\tcnt[j]--;\\n\\t\\t\\ti += 2;\\n\\t\\t}\\n\\t}\\n\\n\\treturn S;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nstring reorganizeString(string S) {\\n\\tvector<int> cnt(26);\\n\\tint mostFreq = 0, i = 0;\\n\\n\\tfor(char c : S)\\n\\t\\tif(++cnt[c - \\'a\\'] > cnt[mostFreq])\\n\\t\\t\\tmostFreq = (c - \\'a\\');\\n\\n\\tif(2 * cnt[mostFreq] - 1 > S.size()) return \"\";\\n\\n\\twhile(cnt[mostFreq]) {\\n\\t\\tS[i] = (\\'a\\' + mostFreq);\\n\\t\\ti += 2;\\n\\t\\tcnt[mostFreq]--;\\n\\t}\\n\\n\\tfor(int j = 0; j < 26; j++) {\\n\\t\\twhile(cnt[j]) {\\n\\t\\t\\tif(i >= S.size()) i = 1;\\n\\t\\t\\tS[i] = (\\'a\\' + j);\\n\\t\\t\\tcnt[j]--;\\n\\t\\t\\ti += 2;\\n\\t\\t}\\n\\t}\\n\\n\\treturn S;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 113435,
                "title": "4-lines-python",
                "content": "Put the *least* common letters at the *odd* indexes and put the *most* common letters at the *even* indexes (both from left to right in order of frequency). The task is only impossible if some letter appears too often, in which case it'll occupy all of the even indexes and at least the last odd index, so I check the last two indexes.\\n\\n    def reorganizeString(self, S):\\n        a = sorted(sorted(S), key=S.count)\\n        h = len(a) / 2\\n        a[1::2], a[::2] = a[:h], a[h:]\\n        return ''.join(a) * (a[-1:] != a[-2:-1])",
                "solutionTags": [],
                "code": "Put the *least* common letters at the *odd* indexes and put the *most* common letters at the *even* indexes (both from left to right in order of frequency). The task is only impossible if some letter appears too often, in which case it'll occupy all of the even indexes and at least the last odd index, so I check the last two indexes.\\n\\n    def reorganizeString(self, S):\\n        a = sorted(sorted(S), key=S.count)\\n        h = len(a) / 2\\n        a[1::2], a[::2] = a[:h], a[h:]\\n        return ''.join(a) * (a[-1:] != a[-2:-1])",
                "codeTag": "Python3"
            },
            {
                "id": 113440,
                "title": "java-solution-priorityqueue",
                "content": "```\\nclass Solution {\\n    public String reorganizeString(String S) {\\n        // Create map of each char to its count\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char c : S.toCharArray()) {\\n            int count = map.getOrDefault(c, 0) + 1;\\n            // Impossible to form a solution\\n            if (count > (S.length() + 1) / 2) return \"\";\\n            map.put(c, count);\\n        }\\n        // Greedy: fetch char of max count as next char in the result.\\n        // Use PriorityQueue to store pairs of (char, count) and sort by count DESC.\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[1] - a[1]);\\n        for (char c : map.keySet()) {\\n            pq.add(new int[] {c, map.get(c)});\\n        }\\n        // Build the result.\\n        StringBuilder sb = new StringBuilder();\\n        while (!pq.isEmpty()) {\\n            int[] first = pq.poll();\\n            if (sb.length() == 0 || first[0] != sb.charAt(sb.length() - 1)) {\\n                sb.append((char) first[0]);\\n                if (--first[1] > 0) {\\n                    pq.add(first);\\n                }\\n            } else {\\n                int[] second = pq.poll();\\n                sb.append((char) second[0]);\\n                if (--second[1] > 0) {\\n                    pq.add(second);\\n                }\\n                pq.add(first);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String reorganizeString(String S) {\\n        // Create map of each char to its count\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char c : S.toCharArray()) {\\n            int count = map.getOrDefault(c, 0) + 1;\\n            // Impossible to form a solution\\n            if (count > (S.length() + 1) / 2) return \"\";\\n            map.put(c, count);\\n        }\\n        // Greedy: fetch char of max count as next char in the result.\\n        // Use PriorityQueue to store pairs of (char, count) and sort by count DESC.\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[1] - a[1]);\\n        for (char c : map.keySet()) {\\n            pq.add(new int[] {c, map.get(c)});\\n        }\\n        // Build the result.\\n        StringBuilder sb = new StringBuilder();\\n        while (!pq.isEmpty()) {\\n            int[] first = pq.poll();\\n            if (sb.length() == 0 || first[0] != sb.charAt(sb.length() - 1)) {\\n                sb.append((char) first[0]);\\n                if (--first[1] > 0) {\\n                    pq.add(first);\\n                }\\n            } else {\\n                int[] second = pq.poll();\\n                sb.append((char) second[0]);\\n                if (--second[1] > 0) {\\n                    pq.add(second);\\n                }\\n                pq.add(first);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972856,
                "title": "c-priority-queue-hash-map-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string S) {\\n        string res=\"\";\\n        unordered_map<char,int> mp;\\n        priority_queue<pair<int,char>>pq;\\n        \\n        for(auto s: S)\\n            mp[s]+=1;\\n        \\n        for(auto m: mp)\\n            pq.push(make_pair(m.second,m.first));\\n        \\n        while(pq.size()>1){\\n            auto top1= pq.top();\\n            pq.pop();\\n            auto top2 = pq.top();\\n            pq.pop();\\n            \\n            res+=top1.second;\\n            res+=top2.second;\\n            \\n            top1.first -=1;\\n            top2.first -= 1;\\n            \\n            if(top1.first > 0)\\n                pq.push(top1);\\n            \\n            if(top2.first > 0)\\n                pq.push(top2);\\n        }\\n        \\n        if(!pq.empty()){\\n            if(pq.top().first > 1)\\n                return \"\";\\n            \\n            else\\n                res+=pq.top().second;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string S) {\\n        string res=\"\";\\n        unordered_map<char,int> mp;\\n        priority_queue<pair<int,char>>pq;\\n        \\n        for(auto s: S)\\n            mp[s]+=1;\\n        \\n        for(auto m: mp)\\n            pq.push(make_pair(m.second,m.first));\\n        \\n        while(pq.size()>1){\\n            auto top1= pq.top();\\n            pq.pop();\\n            auto top2 = pq.top();\\n            pq.pop();\\n            \\n            res+=top1.second;\\n            res+=top2.second;\\n            \\n            top1.first -=1;\\n            top2.first -= 1;\\n            \\n            if(top1.first > 0)\\n                pq.push(top1);\\n            \\n            if(top2.first > 0)\\n                pq.push(top2);\\n        }\\n        \\n        if(!pq.empty()){\\n            if(pq.top().first > 1)\\n                return \"\";\\n            \\n            else\\n                res+=pq.top().second;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492827,
                "title": "python-simple-heap-solution-with-detailed-explanation",
                "content": "**The basic idea:**\\nThe goal is to first exhaust the most-frequent chars. We build a frequency dict of the letters in the string. We push all the letters into a max heap together with their -ve frequencies (max heap: high-freq letters are towards the top of the heap)\\nWe pop two letters at a time from the heap, add them to our result string, decrement their frequencies and push them back into heap. **Why do we have to pop two items/letters at a time you\\'re wondering?** Because if we only pop one at a time, we will keep popping and pushing the same letter over and over again if that letter has a freq greater than 1. Hence by popping two at time, adding them to result, decrementing their freq and finally pushing them back into heap, we guranatee that we are always alternating between letters.\\n\\nFor example: for the string ```s = aab```\\nThe freq dict will be: ``` d = {\"a\": 2, \"b\":1}```\\nAnd the heap: ``` h = [(-2, \"a\"), (-1, \"b\")]```\\n- After the first iteration:\\n ``` h = [(-1, \"a\")]``` \\n and so on...\\n\\n**Edge Case:**\\n**NOTE [1]**\\n- Since we are always popping two items at a time, we will definitely run into an out of bounds error if we have an odd number of unique items in the given string. To avoid this, we need to make sure our heap at least has two items at any given time. We achive this by running our main logic inside a ```while len(heap) > 1``` instead of a ```while heap```\\n\\n**NOTE [2]**\\n- Again if the there is an odd number of unique letters in the string, there will be one last item/letter remaining in the heap when our loop terminates. Hence we need to examine that last item:\\n- If the last item has a freq greater than 1: -> then return \"\" becasue we can\\'t escape having the same letter repeated contigiously.\\n- else if the item has freq = 1, we pop it, add it to our result and we\\'re done.\\n\\n\\n```\\ndef reorganizeString(S):   \\n\\tif not S:\\n\\t\\treturn \"\"\\n\\t# Build freq dict:\\n\\td = {}\\n\\tfor c in S:\\n\\t\\tif c in d:\\n\\t\\t\\td[c] += 1\\n\\t\\telse:\\n\\t\\t\\td[c] = 1\\n\\n\\t# push (-ve frq, char) pairs into heap\\n\\th = []\\n\\tfrom heapq import heappush, heappop\\n\\tfor k in d:\\n\\t\\theappush(h, (-d[k], k))\\n\\n\\tres = \"\"\\n\\t# pop and examine frq and append to res\\n\\twhile len(h) > 1:        # -------------------------------- NOTE [1]\\n\\t\\tf1, c1 = heappop(h)\\n\\t\\tf2, c2 = heappop(h)\\n\\n\\t\\tres += c1\\n\\t\\tres += c2\\n\\n\\t\\tif abs(f1) > 1: # if char repeats\\n\\t\\t\\theappush(h, (f1+1, c1)) # push back with decrement frq\\n\\n\\t\\tif abs(f2) > 1: \\n\\t\\t\\theappush(h, (f2+1, c2)) # push back with decrement frq\\n\\n\\n\\tif h:     # -------------------------------- NOTE [2]\\n\\t\\tf, c = h[0]\\n\\t\\tif abs(f) > 1: \\n\\t\\t\\treturn \"\" # this means we have something like h = [(2, \"a\")] which means there is no escape from repeating same char in text\\n\\t\\telse:\\n\\t\\t\\tres += c\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```s = aab```\n``` d = {\"a\": 2, \"b\":1}```\n``` h = [(-2, \"a\"), (-1, \"b\")]```\n``` h = [(-1, \"a\")]```\n```while len(heap) > 1```\n```while heap```\n```\\ndef reorganizeString(S):   \\n\\tif not S:\\n\\t\\treturn \"\"\\n\\t# Build freq dict:\\n\\td = {}\\n\\tfor c in S:\\n\\t\\tif c in d:\\n\\t\\t\\td[c] += 1\\n\\t\\telse:\\n\\t\\t\\td[c] = 1\\n\\n\\t# push (-ve frq, char) pairs into heap\\n\\th = []\\n\\tfrom heapq import heappush, heappop\\n\\tfor k in d:\\n\\t\\theappush(h, (-d[k], k))\\n\\n\\tres = \"\"\\n\\t# pop and examine frq and append to res\\n\\twhile len(h) > 1:        # -------------------------------- NOTE [1]\\n\\t\\tf1, c1 = heappop(h)\\n\\t\\tf2, c2 = heappop(h)\\n\\n\\t\\tres += c1\\n\\t\\tres += c2\\n\\n\\t\\tif abs(f1) > 1: # if char repeats\\n\\t\\t\\theappush(h, (f1+1, c1)) # push back with decrement frq\\n\\n\\t\\tif abs(f2) > 1: \\n\\t\\t\\theappush(h, (f2+1, c2)) # push back with decrement frq\\n\\n\\n\\tif h:     # -------------------------------- NOTE [2]\\n\\t\\tf, c = h[0]\\n\\t\\tif abs(f) > 1: \\n\\t\\t\\treturn \"\" # this means we have something like h = [(2, \"a\")] which means there is no escape from repeating same char in text\\n\\t\\telse:\\n\\t\\t\\tres += c\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 113425,
                "title": "c-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        map<int, int> cnts;\\n        for (char c : s) cnts[c]++;\\n        priority_queue<pair<int, int>> pq;\\n        for (auto p : cnts)\\n            pq.push({p.second, p.first});\\n\\n        string res;\\n        pair<int, int> top1, top2;\\n        while (!pq.empty()) {\\n            top1 = pq.top(); pq.pop();\\n            res += top1.second;\\n            if (!pq.empty()) {\\n                res += pq.top().second;\\n                top2 = pq.top(); pq.pop();\\n                if (top2.first > 1) pq.push({ top2.first - 1, top2.second });\\n            }\\n            if (top1.first > 1) pq.push({ top1.first - 1, top1.second });\\n        }\\n\\n        for (int i = 1; i < res.size(); i++)\\n            if (res[i] == res[i - 1]) return \"\";\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        map<int, int> cnts;\\n        for (char c : s) cnts[c]++;\\n        priority_queue<pair<int, int>> pq;\\n        for (auto p : cnts)\\n            pq.push({p.second, p.first});\\n\\n        string res;\\n        pair<int, int> top1, top2;\\n        while (!pq.empty()) {\\n            top1 = pq.top(); pq.pop();\\n            res += top1.second;\\n            if (!pq.empty()) {\\n                res += pq.top().second;\\n                top2 = pq.top(); pq.pop();\\n                if (top2.first > 1) pq.push({ top2.first - 1, top2.second });\\n            }\\n            if (top1.first > 1) pq.push({ top1.first - 1, top1.second });\\n        }\\n\\n        for (int i = 1; i < res.size(); i++)\\n            if (res[i] == res[i - 1]) return \"\";\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947780,
                "title": "100-2-approaches-priority-queue-sort",
                "content": "# Problem Understanding\\n\\nIn the \"767. Reorganize String\" problem, we are given a string  `s`  consisting of lowercase English letters. The task is to rearrange the string such that no two adjacent characters are the same. If it\\'s not possible to do so, we return an empty string.\\n\\nFor instance, given the input \"aab,\" the output could be \"aba\"\\n\\n---\\n\\n# Live Coding & Explenation\\n## Priority Queue\\nhttps://youtu.be/69ViY9Trto8\\n\\n\\n- [Priority Queue in Python \\uD83D\\uDC0D](https://youtu.be/69ViY9Trto8)\\n- [Array Sort  in Python \\uD83D\\uDC0D](https://youtu.be/eCBOPJNE4to)\\n\\n\\n---\\n\\n## Approach 1: Priority Queue Approach\\n\\n### Objective\\nTo solve the \"767. Reorganize String\" problem, the priority queue approach leverages a max heap to maintain the frequency of each character. By doing so, we can alternate the most frequent characters with the remaining ones to ensure no adjacent characters are the same.\\n\\n### Key Data Structures\\n- **Max Heap**: Used for storing characters sorted by their frequency in descending order.\\n\\n### Enhanced Breakdown\\n\\n1. **Initialization**:\\n    - Count the frequency of each character in the string.\\n    - Populate the max heap with these frequencies.\\n  \\n2. **Processing Each Character**:\\n    - Pop the top two characters from the max heap (i.e., the ones with the highest frequency).\\n    - Append these two characters to the result string.\\n    - Decrement their frequencies and re-insert them back into the max heap.\\n    - If only one character remains in the heap, make sure it doesn\\'t exceed half of the string length, otherwise, return an empty string.\\n\\n3. **Wrap-up**:\\n    - If there\\'s a single remaining character with a frequency of 1, append it to the result.\\n    - Join all the characters to return the final reorganized string.\\n\\n## Example:\\n\\nGiven the input \"aab\":\\n\\n- Max heap after initialization: `[(-2, \\'a\\'), (-1, \\'b\\')]`\\n- Result after first iteration: \"ab\"\\n- Wrap-up: Result is \"aba\"\\n\\n---\\n\\n## Approach 2: Array Sort Approach\\n\\n### Objective\\nIn this approach, we sort the array of characters by their frequency and then place them at alternate positions in the result string. This ensures that no two adjacent characters are the same.\\n\\n### Key Data Structures\\n- **Array**: Used for storing characters sorted by frequency for easy access.\\n\\n### Enhanced Breakdown\\n\\n1. **Initialization**:\\n    - Count the frequency of each character in the string.\\n    - Sort the array of characters based on their frequency in descending order.\\n  \\n2. **Processing Each Character**:\\n    - Start placing the most frequent characters first. Place them at even indices (0, 2, 4, ...).\\n    - Next, place the remaining characters at the odd indices (1, 3, 5, ...).\\n    - During this process, if the most frequent character appears more than $$(\\\\text{length of string} + 1) / 2$$ times, return an empty string as reorganization is not possible.\\n\\n3. **Wrap-up**:\\n    - Combine all the individual characters to form the final reorganized string.\\n\\n## Example:\\n\\nGiven the input \"aab\":\\n\\n- Sorted array after initialization: `[\\'a\\', \\'a\\', \\'b\\']`\\n- Result after processing: \"aba\"\\n\\n---\\n\\n# Complexity:\\n\\n## Time Complexity:\\n\\n1. **Priority Queue Approach: $$ O(n \\\\log k) $$**\\n\\n    - $$ O(n) $$ for counting the frequency of each character in the string. Here, $$ n $$ is the length of the string.\\n    - $$ O(k \\\\log k) $$ for building the max heap, where $$ k $$ is the number of unique characters in the string.\\n    - The heap operations (insertion and deletion) would require $$ \\\\log k $$ time each. In the worst-case scenario, you would be doing these operations $$ n $$ times (once for each character in the string).\\n  \\n\\n2. **Array Sort Approach: $$ O(n + k \\\\log k) $$**\\n\\n    - $$ O(n) $$ for counting the frequency of each character in the string.\\n    - $$ O(k \\\\log k) $$ for sorting the unique characters by their frequency.\\n    - $$ O(n) $$ for placing the characters into the new string. Here, you iterate through each character, inserting them into their respective places in the result string.\\n\\n---\\n\\n## Space Complexity:\\n\\n1. **Both approaches: $$ O(n) $$**\\n\\n    - For both approaches, you would need an additional data structure (either a max heap or an array) to store the characters and their frequencies. \\n    - In the Priority Queue Approach, the heap would contain at most $$ k $$ elements (unique characters), and the result string would contain $$ n $$ characters.\\n    - In the Array Sort Approach, the sorted array and result string would also contain $$ n $$ characters.\\n\\n---\\n\\n# Performance:\\n\\n## Priority Queue\\n| Language  | Runtime (ms) | Runtime Beat (%) | Memory (MB) | Memory Beat (%) |\\n|-----------|--------------|------------------|-------------|-----------------|\\n| Go        | 0            | 100%             | 2.2         | 60.78%          |\\n| Rust      | 1            | 83.33%           | 2           | 100%            |\\n| C++       | 4            | 38.45%           | 6.3         | 46.7%           |\\n| Java      | 6            | 35.10%           | 40.6        | 67.8%           |\\n| Python3   | 31           | 98.6%            | 16.3        | 46.15%          |\\n| JavaScript| 57           | 91.34%           | 44.7        | 63.78%          |\\n| C#        | 79           | 62.86%           | 37.1        | 85.71%          |\\n\\n![p1.png](https://assets.leetcode.com/users/images/62920fbe-6643-4954-9ec5-05f9cf487dca_1692751904.5525727.png)\\n\\n\\n## Array Sort\\n| Language  | Runtime (ms) | Runtime Beat (%) | Memory (MB) | Memory Beat (%) |\\n|-----------|--------------|------------------|-------------|-----------------|\\n| C++       | 0            | 100%             | 6.4         | 21.22%          |\\n| Go        | 1            | 72.55%           | 2           | 70.59%          |\\n| Rust      | 1            | 83.33%           | 2.1         | 16.67%          |\\n| Java      | 3            | 68.33%           | 40.5        | 87.22%          |\\n| Python3   | 39           | 85.26%           | 16.3        | 46.15%          |\\n| JavaScript| 49           | 99.21%           | 44          | 79.53%          |\\n| C#        | 81           | 60%              | 37.2        | 82.86%          |\\n\\n![p2.png](https://assets.leetcode.com/users/images/ea330341-4766-4659-a1b8-4c1e84c1b357_1692751910.8446956.png)\\n\\n\\n# Code Priority Queue\\n``` Python []\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        freq_map = {}\\n        for char in s:\\n            freq_map[char] = freq_map.get(char, 0) + 1\\n            \\n        max_heap = [(-freq, char) for char, freq in freq_map.items()]\\n        heapq.heapify(max_heap)\\n        \\n        res = []\\n        \\n        while len(max_heap) >= 2:\\n            freq1, char1 = heapq.heappop(max_heap)\\n            freq2, char2 = heapq.heappop(max_heap)\\n            \\n            res.extend([char1, char2])\\n            \\n            if freq1 + 1 < 0:\\n                heapq.heappush(max_heap, (freq1 + 1, char1))\\n            if freq2 + 1 < 0:\\n                heapq.heappush(max_heap, (freq2 + 1, char2))\\n                \\n        if max_heap:\\n            freq, char = heapq.heappop(max_heap)\\n            if -freq > 1:\\n                return \"\"\\n            res.append(char)\\n            \\n        return \"\".join(res)\\n\\n```\\n``` Rust []\\nuse std::collections::BinaryHeap;\\nuse std::collections::HashMap;\\nuse std::cmp::Reverse;\\n\\nimpl Solution {\\n    pub fn reorganize_string(s: String) -> String {\\n    let mut freq_map = HashMap::new();\\n    for c in s.chars() {\\n        *freq_map.entry(c).or_insert(0) += 1;\\n    }\\n    \\n    let mut max_heap: BinaryHeap<(i32, char)> = BinaryHeap::new();\\n    for (&ch, &freq) in freq_map.iter() {\\n        max_heap.push((freq, ch));\\n    }\\n    \\n    let mut res = Vec::new();\\n    while max_heap.len() >= 2 {\\n        let (freq1, char1) = max_heap.pop().unwrap();\\n        let (freq2, char2) = max_heap.pop().unwrap();\\n        \\n        res.push(char1);\\n        res.push(char2);\\n        \\n        if freq1 > 1 { max_heap.push((freq1 - 1, char1)); }\\n        if freq2 > 1 { max_heap.push((freq2 - 1, char2)); }\\n    }\\n    \\n    if let Some((freq, ch)) = max_heap.pop() {\\n        if freq > 1 {\\n            return \"\".to_string();\\n        }\\n        res.push(ch);\\n    }\\n    \\n    let result: String = res.into_iter().collect();\\n    result\\n}\\n}\\n```\\n``` Go []\\nimport (\\n\\t\"container/heap\"\\n\\t\"strings\"\\n)\\n\\ntype CharFreq struct {\\n\\tchar  rune\\n\\tcount int\\n}\\n\\ntype MaxHeap []CharFreq\\n\\nfunc (h MaxHeap) Len() int           { return len(h) }\\nfunc (h MaxHeap) Less(i, j int) bool { return h[i].count > h[j].count }\\nfunc (h MaxHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *MaxHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.(CharFreq))\\n}\\n\\nfunc (h *MaxHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\nfunc reorganizeString(s string) string {\\n\\tfreqMap := make(map[rune]int)\\n\\tfor _, c := range s {\\n\\t\\tfreqMap[c]++\\n\\t}\\n\\n\\tmaxHeap := &MaxHeap{}\\n\\theap.Init(maxHeap)\\n\\tfor c, freq := range freqMap {\\n\\t\\theap.Push(maxHeap, CharFreq{c, freq})\\n\\t}\\n\\n\\tvar res strings.Builder\\n\\tfor maxHeap.Len() >= 2 {\\n\\t\\tcharFreq1 := heap.Pop(maxHeap).(CharFreq)\\n\\t\\tcharFreq2 := heap.Pop(maxHeap).(CharFreq)\\n\\n\\t\\tres.WriteRune(charFreq1.char)\\n\\t\\tres.WriteRune(charFreq2.char)\\n\\n\\t\\tif charFreq1.count > 1 {\\n\\t\\t\\theap.Push(maxHeap, CharFreq{charFreq1.char, charFreq1.count - 1})\\n\\t\\t}\\n\\t\\tif charFreq2.count > 1 {\\n\\t\\t\\theap.Push(maxHeap, CharFreq{charFreq2.char, charFreq2.count - 1})\\n\\t\\t}\\n\\t}\\n\\n\\tif maxHeap.Len() > 0 {\\n\\t\\tlastFreq := heap.Pop(maxHeap).(CharFreq)\\n\\t\\tif lastFreq.count > 1 {\\n\\t\\t\\treturn \"\"\\n\\t\\t}\\n\\t\\tres.WriteRune(lastFreq.char)\\n\\t}\\n\\n\\treturn res.String()\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        unordered_map<char, int> freq_map;\\n        for (char c : s) {\\n            freq_map[c]++;\\n        }\\n\\n        priority_queue<pair<int, char>> max_heap;\\n        for (auto &[ch, freq] : freq_map) {\\n            max_heap.push({freq, ch});\\n        }\\n\\n        string res;\\n        while (max_heap.size() >= 2) {\\n            auto [freq1, char1] = max_heap.top(); max_heap.pop();\\n            auto [freq2, char2] = max_heap.top(); max_heap.pop();\\n\\n            res += char1;\\n            res += char2;\\n\\n            if (--freq1 > 0) max_heap.push({freq1, char1});\\n            if (--freq2 > 0) max_heap.push({freq2, char2});\\n        }\\n\\n        if (!max_heap.empty()) {\\n            auto [freq, ch] = max_heap.top();\\n            if (freq > 1) return \"\";\\n            res += ch;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public String reorganizeString(String s) {\\n        HashMap<Character, Integer> freqMap = new HashMap<>();\\n        for (char c : s.toCharArray()) {\\n            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);\\n        }\\n\\n        PriorityQueue<Character> maxHeap = new PriorityQueue<>((a, b) -> freqMap.get(b) - freqMap.get(a));\\n        maxHeap.addAll(freqMap.keySet());\\n\\n        StringBuilder res = new StringBuilder();\\n        while (maxHeap.size() >= 2) {\\n            char char1 = maxHeap.poll();\\n            char char2 = maxHeap.poll();\\n\\n            res.append(char1);\\n            res.append(char2);\\n\\n            freqMap.put(char1, freqMap.get(char1) - 1);\\n            freqMap.put(char2, freqMap.get(char2) - 1);\\n\\n            if (freqMap.get(char1) > 0) maxHeap.add(char1);\\n            if (freqMap.get(char2) > 0) maxHeap.add(char2);\\n        }\\n\\n        if (!maxHeap.isEmpty()) {\\n            char ch = maxHeap.poll();\\n            if (freqMap.get(ch) > 1) return \"\";\\n            res.append(ch);\\n        }\\n\\n        return res.toString();\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public string ReorganizeString(string s) {\\n        Dictionary<char, int> freqMap = new Dictionary<char, int>();\\n        foreach (char c in s) {\\n            if (!freqMap.ContainsKey(c)) freqMap[c] = 0;\\n            freqMap[c]++;\\n        }\\n\\n        var maxHeap = new SortedSet<(int, char)>();\\n        foreach (var kvp in freqMap) {\\n            maxHeap.Add((kvp.Value, kvp.Key));\\n        }\\n\\n        List<char> res = new List<char>();\\n        while (maxHeap.Count >= 2) {\\n            var elem1 = maxHeap.Max; maxHeap.Remove(elem1);\\n            var elem2 = maxHeap.Max; maxHeap.Remove(elem2);\\n\\n            res.Add(elem1.Item2);\\n            res.Add(elem2.Item2);\\n\\n            if (--elem1.Item1 > 0) maxHeap.Add(elem1);\\n            if (--elem2.Item1 > 0) maxHeap.Add(elem2);\\n        }\\n\\n        if (maxHeap.Count > 0) {\\n            var elem = maxHeap.Max;\\n            if (elem.Item1 > 1) return \"\";\\n            res.Add(elem.Item2);\\n        }\\n\\n        return new string(res.ToArray());\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reorganizeString = function(s) {\\n    const freqMap = {};\\n    for (const c of s) {\\n        freqMap[c] = (freqMap[c] || 0) + 1;\\n    }\\n\\n    const maxHeap = [...Object.keys(freqMap)].sort((a, b) => freqMap[b] - freqMap[a]);\\n\\n    let res = \"\";\\n    while (maxHeap.length >= 2) {\\n        const char1 = maxHeap.shift();\\n        const char2 = maxHeap.shift();\\n\\n        res += char1;\\n        res += char2;\\n\\n        if (--freqMap[char1] > 0) maxHeap.push(char1);\\n        if (--freqMap[char2] > 0) maxHeap.push(char2);\\n\\n        maxHeap.sort((a, b) => freqMap[b] - freqMap[a]);\\n    }\\n\\n    if (maxHeap.length) {\\n        const char = maxHeap[0];\\n        if (freqMap[char] > 1) return \"\";\\n        res += char;\\n    }\\n\\n    return res;\\n}\\n```\\n\\n# Code Array Sort\\n``` Python []\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        freq_map = {}\\n        for char in s:\\n            freq_map[char] = freq_map.get(char, 0) + 1\\n            \\n        sorted_chars = sorted(freq_map.keys(), key=lambda x: freq_map[x], reverse=True)\\n        \\n        if freq_map[sorted_chars[0]] > (len(s) + 1) // 2:\\n            return \"\"\\n        \\n        res = [None] * len(s)\\n        \\n        i = 0\\n        for char in sorted_chars:\\n            for _ in range(freq_map[char]):\\n                if i >= len(s):\\n                    i = 1\\n                res[i] = char\\n                i += 2\\n                \\n        return \"\".join(res)\\n```\\n``` Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn reorganize_string(s: String) -> String {\\n        let mut freq_map: HashMap<char, usize> = HashMap::new();\\n        for c in s.chars() {\\n            *freq_map.entry(c).or_insert(0) += 1;\\n        }\\n\\n        let mut sorted_chars: Vec<char> = freq_map.keys().cloned().collect();\\n        sorted_chars.sort_by_key(|&c| std::cmp::Reverse(freq_map[&c]));\\n\\n        if freq_map[&sorted_chars[0]] > (s.len() + 1) / 2 {\\n            return \"\".to_string();\\n        }\\n\\n        let mut res = vec![\\' \\'; s.len()];\\n        let mut i = 0;\\n        for &c in sorted_chars.iter() {\\n            for _ in 0..freq_map[&c] {\\n                if i >= s.len() {\\n                    i = 1;\\n                }\\n                res[i] = c;\\n                i += 2;\\n            }\\n        }\\n\\n        res.iter().collect()\\n    }\\n}\\n```\\n``` Go []\\nimport \"strings\"\\n\\nfunc reorganizeString(s string) string {\\n    freqMap := make(map[rune]int)\\n    for _, c := range s {\\n        freqMap[c]++\\n    }\\n\\n    var sortedChars []rune\\n    for ch := range freqMap {\\n        sortedChars = append(sortedChars, ch)\\n    }\\n\\n    sort.Slice(sortedChars, func(i, j int) bool {\\n        return freqMap[sortedChars[i]] > freqMap[sortedChars[j]]\\n    })\\n\\n    if freqMap[sortedChars[0]] > (len(s)+1)/2 {\\n        return \"\"\\n    }\\n\\n    res := make([]rune, len(s))\\n    i := 0\\n    for _, ch := range sortedChars {\\n        for j := 0; j < freqMap[ch]; j++ {\\n            if i >= len(s) {\\n                i = 1\\n            }\\n            res[i] = ch\\n            i += 2\\n        }\\n    }\\n\\n    return string(res)\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    string reorganizeString(std::string s) {\\n    std::unordered_map<char, int> freq_map;\\n    for (char c : s) {\\n        freq_map[c]++;\\n    }\\n\\n    std::vector<char> sorted_chars;\\n    for (auto& pair : freq_map) {\\n        sorted_chars.push_back(pair.first);\\n    }\\n\\n    std::sort(sorted_chars.begin(), sorted_chars.end(), [&](char a, char b) {\\n        return freq_map[a] > freq_map[b];\\n    });\\n\\n    if (freq_map[sorted_chars[0]] > (s.length() + 1) / 2) {\\n        return \"\";\\n    }\\n\\n    std::string res(s.length(), \\' \\');\\n    int i = 0;\\n    for (char c : sorted_chars) {\\n        for (int j = 0; j < freq_map[c]; ++j) {\\n            if (i >= s.length()) {\\n                i = 1;\\n            }\\n            res[i] = c;\\n            i += 2;\\n        }\\n    }\\n\\n    return res;\\n}\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public String reorganizeString(String s) {\\n        HashMap<Character, Integer> freqMap = new HashMap<>();\\n        for (char c : s.toCharArray()) {\\n            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);\\n        }\\n\\n        PriorityQueue<Character> maxHeap = new PriorityQueue<>((a, b) -> freqMap.get(b) - freqMap.get(a));\\n        maxHeap.addAll(freqMap.keySet());\\n\\n        if (freqMap.get(maxHeap.peek()) > (s.length() + 1) / 2) {\\n            return \"\";\\n        }\\n\\n        StringBuilder res = new StringBuilder();\\n        char[] result = new char[s.length()];\\n        int i = 0;\\n        while (!maxHeap.isEmpty()) {\\n            char c = maxHeap.poll();\\n            for (int j = 0; j < freqMap.get(c); j++) {\\n                if (i >= s.length()) i = 1;\\n                result[i] = c;\\n                i += 2;\\n            }\\n        }\\n\\n        return new String(result);\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public string ReorganizeString(string s) {\\n        Dictionary<char, int> freqMap = new Dictionary<char, int>();\\n        foreach (char c in s) {\\n            if (!freqMap.ContainsKey(c)) freqMap[c] = 0;\\n            freqMap[c]++;\\n        }\\n\\n        List<char> sortedChars = new List<char>(freqMap.Keys);\\n        sortedChars.Sort((a, b) => freqMap[b].CompareTo(freqMap[a]));\\n\\n        if (freqMap[sortedChars[0]] > (s.Length + 1) / 2) return \"\";\\n\\n        char[] res = new char[s.Length];\\n        int i = 0;\\n        foreach (char c in sortedChars) {\\n            for (int j = 0; j < freqMap[c]; j++) {\\n                if (i >= s.Length) i = 1;\\n                res[i] = c;\\n                i += 2;\\n            }\\n        }\\n\\n        return new string(res);\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reorganizeString = function(s) {\\n    const freqMap = {};\\n    for (const c of s) {\\n        freqMap[c] = (freqMap[c] || 0) + 1;\\n    }\\n\\n    const sortedChars = Object.keys(freqMap).sort((a, b) => freqMap[b] - freqMap[a]);\\n\\n    if (freqMap[sortedChars[0]] > Math.floor((s.length + 1) / 2)) {\\n        return \"\";\\n    }\\n\\n    const res = Array(s.length).fill(null);\\n    let i = 0;\\n    for (const c of sortedChars) {\\n        for (let j = 0; j < freqMap[c]; j++) {\\n            if (i >= s.length) i = 1;\\n            res[i] = c;\\n            i += 2;\\n        }\\n    }\\n\\n    return res.join(\\'\\');\\n}\\n```\\n\\n# Live Coding & Explenation\\n## Array Sort\\n\\nhttps://youtu.be/eCBOPJNE4to\\n\\nWhether you\\'re prepping for interviews or just love solving algorithmic challenges, understanding different approaches to problem-solving will sharpen your coding skills. \\uD83D\\uDCA1\\uD83C\\uDF20\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "String",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        freq_map = {}\\n        for char in s:\\n            freq_map[char] = freq_map.get(char, 0) + 1\\n            \\n        max_heap = [(-freq, char) for char, freq in freq_map.items()]\\n        heapq.heapify(max_heap)\\n        \\n        res = []\\n        \\n        while len(max_heap) >= 2:\\n            freq1, char1 = heapq.heappop(max_heap)\\n            freq2, char2 = heapq.heappop(max_heap)\\n            \\n            res.extend([char1, char2])\\n            \\n            if freq1 + 1 < 0:\\n                heapq.heappush(max_heap, (freq1 + 1, char1))\\n            if freq2 + 1 < 0:\\n                heapq.heappush(max_heap, (freq2 + 1, char2))\\n                \\n        if max_heap:\\n            freq, char = heapq.heappop(max_heap)\\n            if -freq > 1:\\n                return \"\"\\n            res.append(char)\\n            \\n        return \"\".join(res)\\n\\n```\n``` Rust []\\nuse std::collections::BinaryHeap;\\nuse std::collections::HashMap;\\nuse std::cmp::Reverse;\\n\\nimpl Solution {\\n    pub fn reorganize_string(s: String) -> String {\\n    let mut freq_map = HashMap::new();\\n    for c in s.chars() {\\n        *freq_map.entry(c).or_insert(0) += 1;\\n    }\\n    \\n    let mut max_heap: BinaryHeap<(i32, char)> = BinaryHeap::new();\\n    for (&ch, &freq) in freq_map.iter() {\\n        max_heap.push((freq, ch));\\n    }\\n    \\n    let mut res = Vec::new();\\n    while max_heap.len() >= 2 {\\n        let (freq1, char1) = max_heap.pop().unwrap();\\n        let (freq2, char2) = max_heap.pop().unwrap();\\n        \\n        res.push(char1);\\n        res.push(char2);\\n        \\n        if freq1 > 1 { max_heap.push((freq1 - 1, char1)); }\\n        if freq2 > 1 { max_heap.push((freq2 - 1, char2)); }\\n    }\\n    \\n    if let Some((freq, ch)) = max_heap.pop() {\\n        if freq > 1 {\\n            return \"\".to_string();\\n        }\\n        res.push(ch);\\n    }\\n    \\n    let result: String = res.into_iter().collect();\\n    result\\n}\\n}\\n```\n``` Go []\\nimport (\\n\\t\"container/heap\"\\n\\t\"strings\"\\n)\\n\\ntype CharFreq struct {\\n\\tchar  rune\\n\\tcount int\\n}\\n\\ntype MaxHeap []CharFreq\\n\\nfunc (h MaxHeap) Len() int           { return len(h) }\\nfunc (h MaxHeap) Less(i, j int) bool { return h[i].count > h[j].count }\\nfunc (h MaxHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *MaxHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.(CharFreq))\\n}\\n\\nfunc (h *MaxHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\nfunc reorganizeString(s string) string {\\n\\tfreqMap := make(map[rune]int)\\n\\tfor _, c := range s {\\n\\t\\tfreqMap[c]++\\n\\t}\\n\\n\\tmaxHeap := &MaxHeap{}\\n\\theap.Init(maxHeap)\\n\\tfor c, freq := range freqMap {\\n\\t\\theap.Push(maxHeap, CharFreq{c, freq})\\n\\t}\\n\\n\\tvar res strings.Builder\\n\\tfor maxHeap.Len() >= 2 {\\n\\t\\tcharFreq1 := heap.Pop(maxHeap).(CharFreq)\\n\\t\\tcharFreq2 := heap.Pop(maxHeap).(CharFreq)\\n\\n\\t\\tres.WriteRune(charFreq1.char)\\n\\t\\tres.WriteRune(charFreq2.char)\\n\\n\\t\\tif charFreq1.count > 1 {\\n\\t\\t\\theap.Push(maxHeap, CharFreq{charFreq1.char, charFreq1.count - 1})\\n\\t\\t}\\n\\t\\tif charFreq2.count > 1 {\\n\\t\\t\\theap.Push(maxHeap, CharFreq{charFreq2.char, charFreq2.count - 1})\\n\\t\\t}\\n\\t}\\n\\n\\tif maxHeap.Len() > 0 {\\n\\t\\tlastFreq := heap.Pop(maxHeap).(CharFreq)\\n\\t\\tif lastFreq.count > 1 {\\n\\t\\t\\treturn \"\"\\n\\t\\t}\\n\\t\\tres.WriteRune(lastFreq.char)\\n\\t}\\n\\n\\treturn res.String()\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        unordered_map<char, int> freq_map;\\n        for (char c : s) {\\n            freq_map[c]++;\\n        }\\n\\n        priority_queue<pair<int, char>> max_heap;\\n        for (auto &[ch, freq] : freq_map) {\\n            max_heap.push({freq, ch});\\n        }\\n\\n        string res;\\n        while (max_heap.size() >= 2) {\\n            auto [freq1, char1] = max_heap.top(); max_heap.pop();\\n            auto [freq2, char2] = max_heap.top(); max_heap.pop();\\n\\n            res += char1;\\n            res += char2;\\n\\n            if (--freq1 > 0) max_heap.push({freq1, char1});\\n            if (--freq2 > 0) max_heap.push({freq2, char2});\\n        }\\n\\n        if (!max_heap.empty()) {\\n            auto [freq, ch] = max_heap.top();\\n            if (freq > 1) return \"\";\\n            res += ch;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public String reorganizeString(String s) {\\n        HashMap<Character, Integer> freqMap = new HashMap<>();\\n        for (char c : s.toCharArray()) {\\n            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);\\n        }\\n\\n        PriorityQueue<Character> maxHeap = new PriorityQueue<>((a, b) -> freqMap.get(b) - freqMap.get(a));\\n        maxHeap.addAll(freqMap.keySet());\\n\\n        StringBuilder res = new StringBuilder();\\n        while (maxHeap.size() >= 2) {\\n            char char1 = maxHeap.poll();\\n            char char2 = maxHeap.poll();\\n\\n            res.append(char1);\\n            res.append(char2);\\n\\n            freqMap.put(char1, freqMap.get(char1) - 1);\\n            freqMap.put(char2, freqMap.get(char2) - 1);\\n\\n            if (freqMap.get(char1) > 0) maxHeap.add(char1);\\n            if (freqMap.get(char2) > 0) maxHeap.add(char2);\\n        }\\n\\n        if (!maxHeap.isEmpty()) {\\n            char ch = maxHeap.poll();\\n            if (freqMap.get(ch) > 1) return \"\";\\n            res.append(ch);\\n        }\\n\\n        return res.toString();\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public string ReorganizeString(string s) {\\n        Dictionary<char, int> freqMap = new Dictionary<char, int>();\\n        foreach (char c in s) {\\n            if (!freqMap.ContainsKey(c)) freqMap[c] = 0;\\n            freqMap[c]++;\\n        }\\n\\n        var maxHeap = new SortedSet<(int, char)>();\\n        foreach (var kvp in freqMap) {\\n            maxHeap.Add((kvp.Value, kvp.Key));\\n        }\\n\\n        List<char> res = new List<char>();\\n        while (maxHeap.Count >= 2) {\\n            var elem1 = maxHeap.Max; maxHeap.Remove(elem1);\\n            var elem2 = maxHeap.Max; maxHeap.Remove(elem2);\\n\\n            res.Add(elem1.Item2);\\n            res.Add(elem2.Item2);\\n\\n            if (--elem1.Item1 > 0) maxHeap.Add(elem1);\\n            if (--elem2.Item1 > 0) maxHeap.Add(elem2);\\n        }\\n\\n        if (maxHeap.Count > 0) {\\n            var elem = maxHeap.Max;\\n            if (elem.Item1 > 1) return \"\";\\n            res.Add(elem.Item2);\\n        }\\n\\n        return new string(res.ToArray());\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reorganizeString = function(s) {\\n    const freqMap = {};\\n    for (const c of s) {\\n        freqMap[c] = (freqMap[c] || 0) + 1;\\n    }\\n\\n    const maxHeap = [...Object.keys(freqMap)].sort((a, b) => freqMap[b] - freqMap[a]);\\n\\n    let res = \"\";\\n    while (maxHeap.length >= 2) {\\n        const char1 = maxHeap.shift();\\n        const char2 = maxHeap.shift();\\n\\n        res += char1;\\n        res += char2;\\n\\n        if (--freqMap[char1] > 0) maxHeap.push(char1);\\n        if (--freqMap[char2] > 0) maxHeap.push(char2);\\n\\n        maxHeap.sort((a, b) => freqMap[b] - freqMap[a]);\\n    }\\n\\n    if (maxHeap.length) {\\n        const char = maxHeap[0];\\n        if (freqMap[char] > 1) return \"\";\\n        res += char;\\n    }\\n\\n    return res;\\n}\\n```\n``` Python []\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        freq_map = {}\\n        for char in s:\\n            freq_map[char] = freq_map.get(char, 0) + 1\\n            \\n        sorted_chars = sorted(freq_map.keys(), key=lambda x: freq_map[x], reverse=True)\\n        \\n        if freq_map[sorted_chars[0]] > (len(s) + 1) // 2:\\n            return \"\"\\n        \\n        res = [None] * len(s)\\n        \\n        i = 0\\n        for char in sorted_chars:\\n            for _ in range(freq_map[char]):\\n                if i >= len(s):\\n                    i = 1\\n                res[i] = char\\n                i += 2\\n                \\n        return \"\".join(res)\\n```\n``` Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn reorganize_string(s: String) -> String {\\n        let mut freq_map: HashMap<char, usize> = HashMap::new();\\n        for c in s.chars() {\\n            *freq_map.entry(c).or_insert(0) += 1;\\n        }\\n\\n        let mut sorted_chars: Vec<char> = freq_map.keys().cloned().collect();\\n        sorted_chars.sort_by_key(|&c| std::cmp::Reverse(freq_map[&c]));\\n\\n        if freq_map[&sorted_chars[0]] > (s.len() + 1) / 2 {\\n            return \"\".to_string();\\n        }\\n\\n        let mut res = vec![\\' \\'; s.len()];\\n        let mut i = 0;\\n        for &c in sorted_chars.iter() {\\n            for _ in 0..freq_map[&c] {\\n                if i >= s.len() {\\n                    i = 1;\\n                }\\n                res[i] = c;\\n                i += 2;\\n            }\\n        }\\n\\n        res.iter().collect()\\n    }\\n}\\n```\n``` Go []\\nimport \"strings\"\\n\\nfunc reorganizeString(s string) string {\\n    freqMap := make(map[rune]int)\\n    for _, c := range s {\\n        freqMap[c]++\\n    }\\n\\n    var sortedChars []rune\\n    for ch := range freqMap {\\n        sortedChars = append(sortedChars, ch)\\n    }\\n\\n    sort.Slice(sortedChars, func(i, j int) bool {\\n        return freqMap[sortedChars[i]] > freqMap[sortedChars[j]]\\n    })\\n\\n    if freqMap[sortedChars[0]] > (len(s)+1)/2 {\\n        return \"\"\\n    }\\n\\n    res := make([]rune, len(s))\\n    i := 0\\n    for _, ch := range sortedChars {\\n        for j := 0; j < freqMap[ch]; j++ {\\n            if i >= len(s) {\\n                i = 1\\n            }\\n            res[i] = ch\\n            i += 2\\n        }\\n    }\\n\\n    return string(res)\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    string reorganizeString(std::string s) {\\n    std::unordered_map<char, int> freq_map;\\n    for (char c : s) {\\n        freq_map[c]++;\\n    }\\n\\n    std::vector<char> sorted_chars;\\n    for (auto& pair : freq_map) {\\n        sorted_chars.push_back(pair.first);\\n    }\\n\\n    std::sort(sorted_chars.begin(), sorted_chars.end(), [&](char a, char b) {\\n        return freq_map[a] > freq_map[b];\\n    });\\n\\n    if (freq_map[sorted_chars[0]] > (s.length() + 1) / 2) {\\n        return \"\";\\n    }\\n\\n    std::string res(s.length(), \\' \\');\\n    int i = 0;\\n    for (char c : sorted_chars) {\\n        for (int j = 0; j < freq_map[c]; ++j) {\\n            if (i >= s.length()) {\\n                i = 1;\\n            }\\n            res[i] = c;\\n            i += 2;\\n        }\\n    }\\n\\n    return res;\\n}\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public String reorganizeString(String s) {\\n        HashMap<Character, Integer> freqMap = new HashMap<>();\\n        for (char c : s.toCharArray()) {\\n            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);\\n        }\\n\\n        PriorityQueue<Character> maxHeap = new PriorityQueue<>((a, b) -> freqMap.get(b) - freqMap.get(a));\\n        maxHeap.addAll(freqMap.keySet());\\n\\n        if (freqMap.get(maxHeap.peek()) > (s.length() + 1) / 2) {\\n            return \"\";\\n        }\\n\\n        StringBuilder res = new StringBuilder();\\n        char[] result = new char[s.length()];\\n        int i = 0;\\n        while (!maxHeap.isEmpty()) {\\n            char c = maxHeap.poll();\\n            for (int j = 0; j < freqMap.get(c); j++) {\\n                if (i >= s.length()) i = 1;\\n                result[i] = c;\\n                i += 2;\\n            }\\n        }\\n\\n        return new String(result);\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public string ReorganizeString(string s) {\\n        Dictionary<char, int> freqMap = new Dictionary<char, int>();\\n        foreach (char c in s) {\\n            if (!freqMap.ContainsKey(c)) freqMap[c] = 0;\\n            freqMap[c]++;\\n        }\\n\\n        List<char> sortedChars = new List<char>(freqMap.Keys);\\n        sortedChars.Sort((a, b) => freqMap[b].CompareTo(freqMap[a]));\\n\\n        if (freqMap[sortedChars[0]] > (s.Length + 1) / 2) return \"\";\\n\\n        char[] res = new char[s.Length];\\n        int i = 0;\\n        foreach (char c in sortedChars) {\\n            for (int j = 0; j < freqMap[c]; j++) {\\n                if (i >= s.Length) i = 1;\\n                res[i] = c;\\n                i += 2;\\n            }\\n        }\\n\\n        return new string(res);\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reorganizeString = function(s) {\\n    const freqMap = {};\\n    for (const c of s) {\\n        freqMap[c] = (freqMap[c] || 0) + 1;\\n    }\\n\\n    const sortedChars = Object.keys(freqMap).sort((a, b) => freqMap[b] - freqMap[a]);\\n\\n    if (freqMap[sortedChars[0]] > Math.floor((s.length + 1) / 2)) {\\n        return \"\";\\n    }\\n\\n    const res = Array(s.length).fill(null);\\n    let i = 0;\\n    for (const c of sortedChars) {\\n        for (let j = 0; j < freqMap[c]; j++) {\\n            if (i >= s.length) i = 1;\\n            res[i] = c;\\n            i += 2;\\n        }\\n    }\\n\\n    return res.join(\\'\\');\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113427,
                "title": "c-greedy-sort-o-n",
                "content": "We can solve this problem using priority queue. Another solution is using sort.\\n\\n```\\nThe solution sort the string by occurrence, i.e. the character with most occurrence is at front. For example, aaaaabbcc.\\n\\nNext, let i = 0 at the beginning, j = (n-1)/2+1 in the middle.\\nWe can build the answer by appending s[i++] and s[j++] sequentially.\\n```\\nSort\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string S) {\\n        vector<int> mp(26);\\n        int n = S.size();\\n        for (char c: S) ++mp[c-'a'];\\n        vector<pair<int, char>> charCounts;\\n        for (int i = 0; i < 26; ++i) {\\n            if (mp[i] > (n+1)/2) return \"\";\\n            if (mp[i]) charCounts.push_back({mp[i], i+'a'});\\n        }\\n        sort(charCounts.rbegin(), charCounts.rend());\\n        string strSorted;\\n        for (auto& p: charCounts)\\n            strSorted += string(p.first, p.second);\\n        string ans;\\n        for (int i = 0, j = (n-1)/2+1; i <= (n-1)/2; ++i, ++j) {\\n            ans += strSorted[i];\\n            if (j < n) ans += strSorted[j];\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPriority Queue\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string S) {\\n        vector<int> mp(26);\\n        int n = S.size();\\n        for (char c: S)\\n            ++mp[c-'a'];\\n        priority_queue<pair<int, char>> pq;\\n        for (int i = 0; i < 26; ++i) {\\n            if (mp[i] > (n+1)/2) return \"\";\\n            if (mp[i]) pq.push({mp[i], i+'a'});\\n        }\\n        queue<pair<int, char>> myq;\\n        string ans;\\n        while (!pq.empty() || myq.size() > 1) {\\n            if (myq.size() > 1) {\\n                auto cur = myq.front();\\n                myq.pop();\\n                if (cur.first != 0) pq.push(cur);\\n            }\\n            if (!pq.empty()) {\\n                auto cur = pq.top();\\n                pq.pop();\\n                ans += cur.second;\\n                cur.first--;\\n                myq.push(cur);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nThe solution sort the string by occurrence, i.e. the character with most occurrence is at front. For example, aaaaabbcc.\\n\\nNext, let i = 0 at the beginning, j = (n-1)/2+1 in the middle.\\nWe can build the answer by appending s[i++] and s[j++] sequentially.\\n```\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string S) {\\n        vector<int> mp(26);\\n        int n = S.size();\\n        for (char c: S) ++mp[c-'a'];\\n        vector<pair<int, char>> charCounts;\\n        for (int i = 0; i < 26; ++i) {\\n            if (mp[i] > (n+1)/2) return \"\";\\n            if (mp[i]) charCounts.push_back({mp[i], i+'a'});\\n        }\\n        sort(charCounts.rbegin(), charCounts.rend());\\n        string strSorted;\\n        for (auto& p: charCounts)\\n            strSorted += string(p.first, p.second);\\n        string ans;\\n        for (int i = 0, j = (n-1)/2+1; i <= (n-1)/2; ++i, ++j) {\\n            ans += strSorted[i];\\n            if (j < n) ans += strSorted[j];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string S) {\\n        vector<int> mp(26);\\n        int n = S.size();\\n        for (char c: S)\\n            ++mp[c-'a'];\\n        priority_queue<pair<int, char>> pq;\\n        for (int i = 0; i < 26; ++i) {\\n            if (mp[i] > (n+1)/2) return \"\";\\n            if (mp[i]) pq.push({mp[i], i+'a'});\\n        }\\n        queue<pair<int, char>> myq;\\n        string ans;\\n        while (!pq.empty() || myq.size() > 1) {\\n            if (myq.size() > 1) {\\n                auto cur = myq.front();\\n                myq.pop();\\n                if (cur.first != 0) pq.push(cur);\\n            }\\n            if (!pq.empty()) {\\n                auto cur = pq.top();\\n                pq.pop();\\n                ans += cur.second;\\n                cur.first--;\\n                myq.push(cur);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 130825,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Reorganize String** https://leetcode.com/problems/reorganize-string/description/\\n\\n**Algorithm**\\n1. Say most frequently occuring character (say c) has frequency max_freq. Then arrange c leaving a space between consecutive c\\'s. The remaining characters should be more than the number of spaces for a valid arrangement. This means that max_freq + (max_freq-1) <= len(S). We can test this quickly using Counter class from collections module and using the *mostcommon(i)* method which returns a list i most frequent tuples.\\n2. Now we create an array called result to store the result. We add (freq*-1,char) tuples to a heap (this is how we simulate a max-heap in Python using  a min-heap.  We then pick the most frequent element and if that element is not the last element in the result, we add it to result, If it is the last element of the result, then we pick the second most frequent element and add that to the result, and also add back the most frequent element back to the heap. Note when we pop from the heap and utilize the character in the result, we need to add it back to the heap if the frequency is not -1 (-1 means that only one instance of that element was in the heap and we have now used it, so no need to add it back).\\n3. Time Complexity is O(N * lg(A)). N is the length of the string. A is the size of the alphabet. The size of the heap will be at-most A. But since we remove and add back elements such that at each iteration we only add one character to the result, there will be N * lg(A) calls. Since A is fixed, we can assume complexity to be O(N).\\n4. Space is also O(A). \\n\\n```\\nfrom collections import Counter\\nfrom heapq import heappush, heappop\\n\\nclass Solution:\\n    def reorganizeString(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        max_freq = Counter(S).most_common(1)[0][1]\\n        if 2*max_freq -1 > len(S):\\n            return \"\"\\n        else:\\n            heap = []\\n            for k,v in Counter(S).items():\\n                heappush(heap, (v*-1, k))\\n            result = []\\n            while heap:\\n                v,k = heappop(heap)\\n                if not result or k != result[-1]: # can add the top most element\\n                    result.append(k)\\n                    if v != -1:\\n                        heappush(heap,(v+1,k))\\n                else:                             # cannot add the top most element\\n                    v1,k1 = heappop(heap)\\n                    result.append(k1)\\n                    heappush(heap, (v,k))\\n                    if v1 != -1:\\n                        heappush(heap, (v1+1,k1))\\n            return \"\".join(result)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nfrom heapq import heappush, heappop\\n\\nclass Solution:\\n    def reorganizeString(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        max_freq = Counter(S).most_common(1)[0][1]\\n        if 2*max_freq -1 > len(S):\\n            return \"\"\\n        else:\\n            heap = []\\n            for k,v in Counter(S).items():\\n                heappush(heap, (v*-1, k))\\n            result = []\\n            while heap:\\n                v,k = heappop(heap)\\n                if not result or k != result[-1]: # can add the top most element\\n                    result.append(k)\\n                    if v != -1:\\n                        heappush(heap,(v+1,k))\\n                else:                             # cannot add the top most element\\n                    v1,k1 = heappop(heap)\\n                    result.append(k1)\\n                    heappush(heap, (v,k))\\n                    if v1 != -1:\\n                        heappush(heap, (v1+1,k1))\\n            return \"\".join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262019,
                "title": "simple-java-solution-using-priorityqueue-with-detailed-explanation",
                "content": "1. We store frequency of characters from the String in a Hashmap. Build a PriorityQueue(Max Heap), pq that stores characters and their frequencies. We are maintaining a Priority Queue based on max frequency. \\n2. We are storing a previous entry which tells which was our last character processed. The previous entry is important since we don\\'t want 2 consecutive characters to be the same. \\n3. Pop an element from Priority Queue and add it to the final result. When we pop an element from the queue, we have used 1 character, so we decrease the frequency count of that Entry\\'s Character. If the Character count of that Entry is >0  then we need to add that entry back to the Priority Queue for further processing.\\n4. The reason why we are adding ```prev``` to the heap and not ```curr```, is because we don\\'t consecutive characters to be same. Because when we do ```maxHeap.poll()```, then we are taking out an Entry(char and it\\'s frequency), so next time we remove an entry from the PriorityQueue, we are going to get a different character entry for sure(which is the base condition: No consecutive chars should be same) \\n5. If length of resultant string and original string is equal then return the resultant string, otherwise return an Empty String. \\n```\\nclass Solution {\\n    public String reorganizeString(String S) {\\n        \\n        Map<Character, Integer> map = new HashMap<Character, Integer>();\\n        for(char c: S.toCharArray())\\n            map.put(c, map.getOrDefault(c, 0)+1); //Character Frequency count\\n        \\n        PriorityQueue<Map.Entry<Character, Integer>> maxHeap = new PriorityQueue<>((a,b) -> (b.getValue() - a.getValue()));\\n        maxHeap.addAll(map.entrySet());//Adding all elements to our heap \\n        \\n        StringBuilder result = new StringBuilder();\\n        \\n        //The reason we need \"prev\" Entry is because we don\\'t want 2 consecutive same characters! \\n        Map.Entry<Character, Integer> prev = null; //Since this is the start of the resultant string we have to keep prev = null. We don\\'t want to add anything before the start of the resultant string. \\n        \\n        while(!maxHeap.isEmpty())\\n        {\\n            Map.Entry<Character, Integer> curr = maxHeap.poll(); //Get the element with the highest freq from the PQ\\n            result.append(curr.getKey());//Append the current character\\n            \\n            curr.setValue(curr.getValue()-1); //Since we have used one character from the current Entry, we update the frequency count\\n            if(prev != null)\\n                maxHeap.offer(prev); //Means that our previous entry still has characters available to use, so add it to the Priority Queue for further processing. \\n            \\n            //After updating the current node\\'s frequency count, if we are still having some characters available, so update the prev with the current value.\\n            if(curr.getValue() > 0) \\n                prev = curr;\\n            else\\n                prev = null;\\n        }\\n        \\n\\treturn result.length() == S.length() ? result.toString() : \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```prev```\n```curr```\n```maxHeap.poll()```\n```\\nclass Solution {\\n    public String reorganizeString(String S) {\\n        \\n        Map<Character, Integer> map = new HashMap<Character, Integer>();\\n        for(char c: S.toCharArray())\\n            map.put(c, map.getOrDefault(c, 0)+1); //Character Frequency count\\n        \\n        PriorityQueue<Map.Entry<Character, Integer>> maxHeap = new PriorityQueue<>((a,b) -> (b.getValue() - a.getValue()));\\n        maxHeap.addAll(map.entrySet());//Adding all elements to our heap \\n        \\n        StringBuilder result = new StringBuilder();\\n        \\n        //The reason we need \"prev\" Entry is because we don\\'t want 2 consecutive same characters! \\n        Map.Entry<Character, Integer> prev = null; //Since this is the start of the resultant string we have to keep prev = null. We don\\'t want to add anything before the start of the resultant string. \\n        \\n        while(!maxHeap.isEmpty())\\n        {\\n            Map.Entry<Character, Integer> curr = maxHeap.poll(); //Get the element with the highest freq from the PQ\\n            result.append(curr.getKey());//Append the current character\\n            \\n            curr.setValue(curr.getValue()-1); //Since we have used one character from the current Entry, we update the frequency count\\n            if(prev != null)\\n                maxHeap.offer(prev); //Means that our previous entry still has characters available to use, so add it to the Priority Queue for further processing. \\n            \\n            //After updating the current node\\'s frequency count, if we are still having some characters available, so update the prev with the current value.\\n            if(curr.getValue() > 0) \\n                prev = curr;\\n            else\\n                prev = null;\\n        }\\n        \\n\\treturn result.length() == S.length() ? result.toString() : \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948110,
                "title": "easy-solution-python3-c-c-java-python-with-image",
                "content": "\\n![Screenshot 2023-08-20 065922.png](https://assets.leetcode.com/users/images/62945814-a6d0-4e8c-89c9-6f7a605695a0_1692760772.3556774.png)\\n\\n```Python3 []\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        count = Counter(s)\\n        maxHeap = [[-cnt, char] for char, cnt in count.items()]\\n        heapq.heapify(maxHeap)\\n\\n        prev = None\\n        res = \"\"\\n        while maxHeap or prev:\\n            if prev and not maxHeap:\\n                return \"\"\\n            cnt, char = heapq.heappop(maxHeap)\\n            res += char\\n            cnt += 1\\n\\n            if prev:\\n                heapq.heappush(maxHeap, prev)\\n                prev = None\\n\\n            if cnt != 0:\\n                prev = [cnt, char]\\n\\n        return res\\n```\\n```python []\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        count = Counter(s)\\n        maxHeap = [[-cnt, char] for char, cnt in count.items()]\\n        heapq.heapify(maxHeap)\\n\\n        prev = None\\n        res = \"\"\\n        while maxHeap or prev:\\n            if prev and not maxHeap:\\n                return \"\"\\n            cnt, char = heapq.heappop(maxHeap)\\n            res += char\\n            cnt += 1\\n\\n            if prev:\\n                heapq.heappush(maxHeap, prev)\\n                prev = None\\n\\n            if cnt != 0:\\n                prev = [cnt, char]\\n\\n        return res\\n```\\n```C# []\\nusing System;\\nusing System.Collections.Generic;\\n\\npublic class Solution {\\n    public string ReorganizeString(string s) {\\n        Dictionary<char, int> count = new Dictionary<char, int>();\\n        foreach (char c in s) {\\n            if (count.ContainsKey(c)) {\\n                count[c]++;\\n            } else {\\n                count[c] = 1;\\n            }\\n        }\\n\\n        List<int[]> maxHeap = new List<int[]>();\\n        foreach (var entry in count) {\\n            maxHeap.Add(new int[] {-entry.Value, entry.Key});\\n        }\\n        Heapify(maxHeap);\\n\\n        int[] prev = null;\\n        string res = \"\";\\n        while (maxHeap.Count > 0 || prev != null) {\\n            if (prev != null && maxHeap.Count == 0) {\\n                return \"\";\\n            }\\n            \\n            int[] top = HeapPop(maxHeap);\\n            res += (char)top[1];\\n            top[0]++;\\n\\n            if (prev != null) {\\n                HeapPush(maxHeap, prev);\\n                prev = null;\\n            }\\n\\n            if (top[0] != 0) {\\n                prev = top;\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    private void Heapify(List<int[]> heap) {\\n        int n = heap.Count;\\n        for (int i = n / 2 - 1; i >= 0; i--) {\\n            HeapifyDown(heap, i);\\n        }\\n    }\\n\\n    private void HeapifyDown(List<int[]> heap, int index) {\\n        int n = heap.Count;\\n        int left = 2 * index + 1;\\n        int right = 2 * index + 2;\\n        int largest = index;\\n\\n        if (left < n && heap[left][0] < heap[largest][0]) {\\n            largest = left;\\n        }\\n        if (right < n && heap[right][0] < heap[largest][0]) {\\n            largest = right;\\n        }\\n\\n        if (largest != index) {\\n            Swap(heap, index, largest);\\n            HeapifyDown(heap, largest);\\n        }\\n    }\\n\\n    private int[] HeapPop(List<int[]> heap) {\\n        int n = heap.Count;\\n        int[] top = heap[0];\\n        heap[0] = heap[n - 1];\\n        heap.RemoveAt(n - 1);\\n        HeapifyDown(heap, 0);\\n        return top;\\n    }\\n\\n    private void HeapPush(List<int[]> heap, int[] element) {\\n        heap.Add(element);\\n        HeapifyUp(heap, heap.Count - 1);\\n    }\\n\\n    private void HeapifyUp(List<int[]> heap, int index) {\\n        while (index > 0) {\\n            int parent = (index - 1) / 2;\\n            if (heap[index][0] >= heap[parent][0]) {\\n                break;\\n            }\\n            Swap(heap, index, parent);\\n            index = parent;\\n        }\\n    }\\n\\n    private void Swap(List<int[]> heap, int i, int j) {\\n        int[] temp = heap[i];\\n        heap[i] = heap[j];\\n        heap[j] = temp;\\n    }\\n}\\n```\\n\\n```Java []\\nclass Solution {\\n    public String reorganizeString(String s) {\\n        Map<Character, Integer> count = new HashMap<>();\\n        for (char c : s.toCharArray()) {\\n            count.put(c, count.getOrDefault(c, 0) + 1);\\n        }\\n\\n        List<int[]> maxHeap = new ArrayList<>();\\n        for (Map.Entry<Character, Integer> entry : count.entrySet()) {\\n            maxHeap.add(new int[]{-entry.getValue(), entry.getKey()});\\n        }\\n        heapify(maxHeap);\\n\\n        int[] prev = null;\\n        StringBuilder res = new StringBuilder();\\n        while (!maxHeap.isEmpty() || prev != null) {\\n            if (prev != null && maxHeap.isEmpty()) {\\n                return \"\";\\n            }\\n\\n            int[] top = heapPop(maxHeap);\\n            res.append((char) top[1]);\\n            top[0]++;\\n\\n            if (prev != null) {\\n                heapPush(maxHeap, prev);\\n                prev = null;\\n            }\\n\\n            if (top[0] != 0) {\\n                prev = top;\\n            }\\n        }\\n\\n        return res.toString();\\n    }\\n\\n    private void heapify(List<int[]> heap) {\\n        int n = heap.size();\\n        for (int i = n / 2 - 1; i >= 0; i--) {\\n            heapifyDown(heap, i);\\n        }\\n    }\\n\\n    private void heapifyDown(List<int[]> heap, int index) {\\n        int n = heap.size();\\n        int left = 2 * index + 1;\\n        int right = 2 * index + 2;\\n        int largest = index;\\n\\n        if (left < n && heap.get(left)[0] < heap.get(largest)[0]) {\\n            largest = left;\\n        }\\n        if (right < n && heap.get(right)[0] < heap.get(largest)[0]) {\\n            largest = right;\\n        }\\n\\n        if (largest != index) {\\n            Collections.swap(heap, index, largest);\\n            heapifyDown(heap, largest);\\n        }\\n    }\\n\\n    private int[] heapPop(List<int[]> heap) {\\n        int n = heap.size();\\n        int[] top = heap.get(0);\\n        heap.set(0, heap.get(n - 1));\\n        heap.remove(n - 1);\\n        heapifyDown(heap, 0);\\n        return top;\\n    }\\n\\n    private void heapPush(List<int[]> heap, int[] element) {\\n        heap.add(element);\\n        heapifyUp(heap, heap.size() - 1);\\n    }\\n\\n    private void heapifyUp(List<int[]> heap, int index) {\\n        while (index > 0) {\\n            int parent = (index - 1) / 2;\\n            if (heap.get(index)[0] >= heap.get(parent)[0]) {\\n                break;\\n            }\\n            Collections.swap(heap, index, parent);\\n            index = parent;\\n        }\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    std::string reorganizeString(std::string s) {\\n        std::unordered_map<char, int> count;\\n        for (char c : s) {\\n            count[c]++;\\n        }\\n\\n        std::vector<std::vector<int>> maxHeap;\\n        for (auto entry : count) {\\n            maxHeap.push_back({-entry.second, entry.first});\\n        }\\n        heapify(maxHeap);\\n\\n        std::vector<int> prev;\\n        std::string res = \"\";\\n        while (!maxHeap.empty() || !prev.empty()) {\\n            if (!prev.empty() && maxHeap.empty()) {\\n                return \"\";\\n            }\\n\\n            std::vector<int> top = heapPop(maxHeap);\\n            res += static_cast<char>(top[1]);\\n            top[0]++;\\n\\n            if (!prev.empty()) {\\n                heapPush(maxHeap, prev);\\n                prev.clear();\\n            }\\n\\n            if (top[0] != 0) {\\n                prev = top;\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\nprivate:\\n    void heapify(std::vector<std::vector<int>>& heap) {\\n        int n = heap.size();\\n        for (int i = n / 2 - 1; i >= 0; i--) {\\n            heapifyDown(heap, i);\\n        }\\n    }\\n\\n    void heapifyDown(std::vector<std::vector<int>>& heap, int index) {\\n        int n = heap.size();\\n        int left = 2 * index + 1;\\n        int right = 2 * index + 2;\\n        int largest = index;\\n\\n        if (left < n && heap[left][0] < heap[largest][0]) {\\n            largest = left;\\n        }\\n        if (right < n && heap[right][0] < heap[largest][0]) {\\n            largest = right;\\n        }\\n\\n        if (largest != index) {\\n            std::swap(heap[index], heap[largest]);\\n            heapifyDown(heap, largest);\\n        }\\n    }\\n\\n    std::vector<int> heapPop(std::vector<std::vector<int>>& heap) {\\n        int n = heap.size();\\n        std::vector<int> top = heap[0];\\n        heap[0] = heap[n - 1];\\n        heap.pop_back();\\n        heapifyDown(heap, 0);\\n        return top;\\n    }\\n\\n    void heapPush(std::vector<std::vector<int>>& heap, std::vector<int>& element) {\\n        heap.push_back(element);\\n        heapifyUp(heap, heap.size() - 1);\\n    }\\n\\n    void heapifyUp(std::vector<std::vector<int>>& heap, int index) {\\n        while (index > 0) {\\n            int parent = (index - 1) / 2;\\n            if (heap[index][0] >= heap[parent][0]) {\\n                break;\\n            }\\n            std::swap(heap[index], heap[parent]);\\n            index = parent;\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C#"
                ],
                "code": "```Python3 []\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        count = Counter(s)\\n        maxHeap = [[-cnt, char] for char, cnt in count.items()]\\n        heapq.heapify(maxHeap)\\n\\n        prev = None\\n        res = \"\"\\n        while maxHeap or prev:\\n            if prev and not maxHeap:\\n                return \"\"\\n            cnt, char = heapq.heappop(maxHeap)\\n            res += char\\n            cnt += 1\\n\\n            if prev:\\n                heapq.heappush(maxHeap, prev)\\n                prev = None\\n\\n            if cnt != 0:\\n                prev = [cnt, char]\\n\\n        return res\\n```\n```python []\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        count = Counter(s)\\n        maxHeap = [[-cnt, char] for char, cnt in count.items()]\\n        heapq.heapify(maxHeap)\\n\\n        prev = None\\n        res = \"\"\\n        while maxHeap or prev:\\n            if prev and not maxHeap:\\n                return \"\"\\n            cnt, char = heapq.heappop(maxHeap)\\n            res += char\\n            cnt += 1\\n\\n            if prev:\\n                heapq.heappush(maxHeap, prev)\\n                prev = None\\n\\n            if cnt != 0:\\n                prev = [cnt, char]\\n\\n        return res\\n```\n```C# []\\nusing System;\\nusing System.Collections.Generic;\\n\\npublic class Solution {\\n    public string ReorganizeString(string s) {\\n        Dictionary<char, int> count = new Dictionary<char, int>();\\n        foreach (char c in s) {\\n            if (count.ContainsKey(c)) {\\n                count[c]++;\\n            } else {\\n                count[c] = 1;\\n            }\\n        }\\n\\n        List<int[]> maxHeap = new List<int[]>();\\n        foreach (var entry in count) {\\n            maxHeap.Add(new int[] {-entry.Value, entry.Key});\\n        }\\n        Heapify(maxHeap);\\n\\n        int[] prev = null;\\n        string res = \"\";\\n        while (maxHeap.Count > 0 || prev != null) {\\n            if (prev != null && maxHeap.Count == 0) {\\n                return \"\";\\n            }\\n            \\n            int[] top = HeapPop(maxHeap);\\n            res += (char)top[1];\\n            top[0]++;\\n\\n            if (prev != null) {\\n                HeapPush(maxHeap, prev);\\n                prev = null;\\n            }\\n\\n            if (top[0] != 0) {\\n                prev = top;\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    private void Heapify(List<int[]> heap) {\\n        int n = heap.Count;\\n        for (int i = n / 2 - 1; i >= 0; i--) {\\n            HeapifyDown(heap, i);\\n        }\\n    }\\n\\n    private void HeapifyDown(List<int[]> heap, int index) {\\n        int n = heap.Count;\\n        int left = 2 * index + 1;\\n        int right = 2 * index + 2;\\n        int largest = index;\\n\\n        if (left < n && heap[left][0] < heap[largest][0]) {\\n            largest = left;\\n        }\\n        if (right < n && heap[right][0] < heap[largest][0]) {\\n            largest = right;\\n        }\\n\\n        if (largest != index) {\\n            Swap(heap, index, largest);\\n            HeapifyDown(heap, largest);\\n        }\\n    }\\n\\n    private int[] HeapPop(List<int[]> heap) {\\n        int n = heap.Count;\\n        int[] top = heap[0];\\n        heap[0] = heap[n - 1];\\n        heap.RemoveAt(n - 1);\\n        HeapifyDown(heap, 0);\\n        return top;\\n    }\\n\\n    private void HeapPush(List<int[]> heap, int[] element) {\\n        heap.Add(element);\\n        HeapifyUp(heap, heap.Count - 1);\\n    }\\n\\n    private void HeapifyUp(List<int[]> heap, int index) {\\n        while (index > 0) {\\n            int parent = (index - 1) / 2;\\n            if (heap[index][0] >= heap[parent][0]) {\\n                break;\\n            }\\n            Swap(heap, index, parent);\\n            index = parent;\\n        }\\n    }\\n\\n    private void Swap(List<int[]> heap, int i, int j) {\\n        int[] temp = heap[i];\\n        heap[i] = heap[j];\\n        heap[j] = temp;\\n    }\\n}\\n```\n```Java []\\nclass Solution {\\n    public String reorganizeString(String s) {\\n        Map<Character, Integer> count = new HashMap<>();\\n        for (char c : s.toCharArray()) {\\n            count.put(c, count.getOrDefault(c, 0) + 1);\\n        }\\n\\n        List<int[]> maxHeap = new ArrayList<>();\\n        for (Map.Entry<Character, Integer> entry : count.entrySet()) {\\n            maxHeap.add(new int[]{-entry.getValue(), entry.getKey()});\\n        }\\n        heapify(maxHeap);\\n\\n        int[] prev = null;\\n        StringBuilder res = new StringBuilder();\\n        while (!maxHeap.isEmpty() || prev != null) {\\n            if (prev != null && maxHeap.isEmpty()) {\\n                return \"\";\\n            }\\n\\n            int[] top = heapPop(maxHeap);\\n            res.append((char) top[1]);\\n            top[0]++;\\n\\n            if (prev != null) {\\n                heapPush(maxHeap, prev);\\n                prev = null;\\n            }\\n\\n            if (top[0] != 0) {\\n                prev = top;\\n            }\\n        }\\n\\n        return res.toString();\\n    }\\n\\n    private void heapify(List<int[]> heap) {\\n        int n = heap.size();\\n        for (int i = n / 2 - 1; i >= 0; i--) {\\n            heapifyDown(heap, i);\\n        }\\n    }\\n\\n    private void heapifyDown(List<int[]> heap, int index) {\\n        int n = heap.size();\\n        int left = 2 * index + 1;\\n        int right = 2 * index + 2;\\n        int largest = index;\\n\\n        if (left < n && heap.get(left)[0] < heap.get(largest)[0]) {\\n            largest = left;\\n        }\\n        if (right < n && heap.get(right)[0] < heap.get(largest)[0]) {\\n            largest = right;\\n        }\\n\\n        if (largest != index) {\\n            Collections.swap(heap, index, largest);\\n            heapifyDown(heap, largest);\\n        }\\n    }\\n\\n    private int[] heapPop(List<int[]> heap) {\\n        int n = heap.size();\\n        int[] top = heap.get(0);\\n        heap.set(0, heap.get(n - 1));\\n        heap.remove(n - 1);\\n        heapifyDown(heap, 0);\\n        return top;\\n    }\\n\\n    private void heapPush(List<int[]> heap, int[] element) {\\n        heap.add(element);\\n        heapifyUp(heap, heap.size() - 1);\\n    }\\n\\n    private void heapifyUp(List<int[]> heap, int index) {\\n        while (index > 0) {\\n            int parent = (index - 1) / 2;\\n            if (heap.get(index)[0] >= heap.get(parent)[0]) {\\n                break;\\n            }\\n            Collections.swap(heap, index, parent);\\n            index = parent;\\n        }\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    std::string reorganizeString(std::string s) {\\n        std::unordered_map<char, int> count;\\n        for (char c : s) {\\n            count[c]++;\\n        }\\n\\n        std::vector<std::vector<int>> maxHeap;\\n        for (auto entry : count) {\\n            maxHeap.push_back({-entry.second, entry.first});\\n        }\\n        heapify(maxHeap);\\n\\n        std::vector<int> prev;\\n        std::string res = \"\";\\n        while (!maxHeap.empty() || !prev.empty()) {\\n            if (!prev.empty() && maxHeap.empty()) {\\n                return \"\";\\n            }\\n\\n            std::vector<int> top = heapPop(maxHeap);\\n            res += static_cast<char>(top[1]);\\n            top[0]++;\\n\\n            if (!prev.empty()) {\\n                heapPush(maxHeap, prev);\\n                prev.clear();\\n            }\\n\\n            if (top[0] != 0) {\\n                prev = top;\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\nprivate:\\n    void heapify(std::vector<std::vector<int>>& heap) {\\n        int n = heap.size();\\n        for (int i = n / 2 - 1; i >= 0; i--) {\\n            heapifyDown(heap, i);\\n        }\\n    }\\n\\n    void heapifyDown(std::vector<std::vector<int>>& heap, int index) {\\n        int n = heap.size();\\n        int left = 2 * index + 1;\\n        int right = 2 * index + 2;\\n        int largest = index;\\n\\n        if (left < n && heap[left][0] < heap[largest][0]) {\\n            largest = left;\\n        }\\n        if (right < n && heap[right][0] < heap[largest][0]) {\\n            largest = right;\\n        }\\n\\n        if (largest != index) {\\n            std::swap(heap[index], heap[largest]);\\n            heapifyDown(heap, largest);\\n        }\\n    }\\n\\n    std::vector<int> heapPop(std::vector<std::vector<int>>& heap) {\\n        int n = heap.size();\\n        std::vector<int> top = heap[0];\\n        heap[0] = heap[n - 1];\\n        heap.pop_back();\\n        heapifyDown(heap, 0);\\n        return top;\\n    }\\n\\n    void heapPush(std::vector<std::vector<int>>& heap, std::vector<int>& element) {\\n        heap.push_back(element);\\n        heapifyUp(heap, heap.size() - 1);\\n    }\\n\\n    void heapifyUp(std::vector<std::vector<int>>& heap, int index) {\\n        while (index > 0) {\\n            int parent = (index - 1) / 2;\\n            if (heap[index][0] >= heap[parent][0]) {\\n                break;\\n            }\\n            std::swap(heap[index], heap[parent]);\\n            index = parent;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 943268,
                "title": "heap-fetch-2-at-once-with-very-detail-explanations",
                "content": "```\\nclass Solution {\\n    public String reorganizeString(String S) {\\n      \\n        // step 1:\\n        // build a hashmap to store characters and its frequencies:\\n        Map<Character, Integer> freq_map = new HashMap<>();\\n        for (char c: S.toCharArray()) {\\n            freq_map.put(c, freq_map.getOrDefault(c, 0) + 1);\\n        }\\n        // step 2:\\n        // put the char of freq_map into the maxheap with sorting the frequencies by large->small\\n        PriorityQueue<Character> maxheap = new PriorityQueue<>(\\n            (a, b) -> freq_map.get(b) - freq_map.get(a)\\n        );\\n        // addAll() is adding more then one element to heap\\n        maxheap.addAll(freq_map.keySet());  \\n        \\n        // now maxheap has the most frequent character on the top\\n        \\n        // step 3:\\n        // obtain the character 2 by 2 from the maxheap to put in the result sb\\n        // until there is only one element(character) left in the maxheap\\n        // create a stringbuilder to build the result result\\n        StringBuilder sb = new StringBuilder();\\n        while (maxheap.size() > 1) {\\n            char first = maxheap.poll();\\n            char second = maxheap.poll();\\n            sb.append(first);\\n            sb.append(second);\\n            freq_map.put(first, freq_map.get(first) - 1);\\n            freq_map.put(second, freq_map.get(second) - 1);\\n            // insert the character back to the freq_map if the count in \\n            // hashmap of these two character are still > 0\\n\\n            if (freq_map.get(first) > 0) {\\n                maxheap.offer(first);\\n            }\\n            if (freq_map.get(second) > 0) {\\n                maxheap.offer(second);\\n            }\\n        }\\n        \\n        if (!maxheap.isEmpty()) {\\n            // when there is only 1 element left in the maxheap\\n            // check the count, it should not be greater than 1\\n            // otherwise it would be impossible and should return \"\"\\n            if (freq_map.get(maxheap.peek()) > 1) {\\n                return \"\";\\n            }\\n            else {\\n                sb.append(maxheap.poll());\\n            }\\n        }\\n        \\n        return sb.toString();\\n        \\n\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public String reorganizeString(String S) {\\n      \\n        // step 1:\\n        // build a hashmap to store characters and its frequencies:\\n        Map<Character, Integer> freq_map = new HashMap<>();\\n        for (char c: S.toCharArray()) {\\n            freq_map.put(c, freq_map.getOrDefault(c, 0) + 1);\\n        }\\n        // step 2:\\n        // put the char of freq_map into the maxheap with sorting the frequencies by large->small\\n        PriorityQueue<Character> maxheap = new PriorityQueue<>(\\n            (a, b) -> freq_map.get(b) - freq_map.get(a)\\n        );\\n        // addAll() is adding more then one element to heap\\n        maxheap.addAll(freq_map.keySet());  \\n        \\n        // now maxheap has the most frequent character on the top\\n        \\n        // step 3:\\n        // obtain the character 2 by 2 from the maxheap to put in the result sb\\n        // until there is only one element(character) left in the maxheap\\n        // create a stringbuilder to build the result result\\n        StringBuilder sb = new StringBuilder();\\n        while (maxheap.size() > 1) {\\n            char first = maxheap.poll();\\n            char second = maxheap.poll();\\n            sb.append(first);\\n            sb.append(second);\\n            freq_map.put(first, freq_map.get(first) - 1);\\n            freq_map.put(second, freq_map.get(second) - 1);\\n            // insert the character back to the freq_map if the count in \\n            // hashmap of these two character are still > 0\\n\\n            if (freq_map.get(first) > 0) {\\n                maxheap.offer(first);\\n            }\\n            if (freq_map.get(second) > 0) {\\n                maxheap.offer(second);\\n            }\\n        }\\n        \\n        if (!maxheap.isEmpty()) {\\n            // when there is only 1 element left in the maxheap\\n            // check the count, it should not be greater than 1\\n            // otherwise it would be impossible and should return \"\"\\n            if (freq_map.get(maxheap.peek()) > 1) {\\n                return \"\";\\n            }\\n            else {\\n                sb.append(maxheap.poll());\\n            }\\n        }\\n        \\n        return sb.toString();\\n        \\n\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948228,
                "title": "100-fast-priorityqueue-with-explanation-c-java-python-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAlways take max character first so at any time always there will be characters present so we can add easily.\\n\\nFor detailed explanation you can refer to my youtube channel (Hindi Language)\\nhttps://youtube.com/@LetsCodeTogether72\\nor link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Count the frequency of each character in the input string.\\n2. Check if the frequency of any character exceeds half the length of the string. If it does, it\\'s not possible to reorganize the string, so return an empty string.\\n3. Build a priority queue (max heap) of character frequencies and characters themselves.\\n4. While the priority queue has at least two elements:\\n   - Pop the two characters with the highest frequencies from the priority queue.\\n   - Append these characters to the result string.\\n   - Decrease their frequencies by 1 and push them back to the priority queue if their frequency is still greater than 1.\\n5. If there\\'s one character left in the priority queue, append it to the result string.\\n6. Return the result string as the reorganized string.\\n\\n# Explanation\\n\\nThe algorithm ensures that characters with the highest frequencies are placed as far apart as possible in the reorganized string. This prevents adjacent characters from being the same, satisfying the problem\\'s condition.\\n\\nBy using a priority queue, we always have access to the character with the highest frequency. We repeatedly select the two characters with the highest frequencies and alternate between them to construct the reorganized string.\\n\\nThe check for a character\\'s frequency exceeding half the length of the string is crucial. If a character appears more frequently than that, it would be impossible to avoid having adjacent characters, making the reorganization impossible.\\n\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![Screenshot (310).png](https://assets.leetcode.com/users/images/186f11cd-afe5-460a-9040-9df68373b2bb_1692772941.641786.png)\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n       vector<int>f(26,0);\\n       int n=s.size();\\n       for(int i=0;i<s.size();i++){\\n           f[s[i]-\\'a\\']++;\\n        if(f[s[i]-\\'a\\']>(n+1)/2)\\n        return \"\";\\n       }\\n       priority_queue<pair<int,char>>p;\\n       for(int i=0;i<26;i++){\\n        if(f[i]!=0){\\n            p.push({f[i],(char)i+\\'a\\'});\\n        }\\n       }\\n       string ans=\"\";\\n       while(p.size()>=2){\\n           pair<int,char>p1=p.top();\\n           p.pop();\\n           pair<int,char>p2=p.top();\\n           p.pop();\\n           ans+=p1.second;\\n           ans+=p2.second;\\n           if(p1.first>1){\\n           p.push({p1.first-1,p1.second});\\n           }\\n           if(p2.first>1){\\n             p.push({p2.first-1,p2.second});\\n           }\\n       }\\n       if(p.size()==1)\\n        ans+=p.top().second;\\n       return ans;\\n    }\\n};\\n```\\n```java []\\nimport java.util.*;\\n\\nclass Solution {\\n    public String reorganizeString(String s) {\\n        int[] f = new int[26];\\n        int n = s.length();\\n        \\n        for (int i = 0; i < n; i++) {\\n            f[s.charAt(i) - \\'a\\']++;\\n            if (f[s.charAt(i) - \\'a\\'] > (n + 1) / 2) {\\n                return \"\";\\n            }\\n        }\\n        \\n        PriorityQueue<Pair> p = new PriorityQueue<>((a, b) -> b.freq - a.freq);\\n        for (int i = 0; i < 26; i++) {\\n            if (f[i] != 0) {\\n                p.offer(new Pair(f[i], (char) (i + \\'a\\')));\\n            }\\n        }\\n        \\n        StringBuilder ans = new StringBuilder();\\n        while (p.size() >= 2) {\\n            Pair p1 = p.poll();\\n            Pair p2 = p.poll();\\n            ans.append(p1.ch);\\n            ans.append(p2.ch);\\n            if (p1.freq > 1) {\\n                p.offer(new Pair(p1.freq - 1, p1.ch));\\n            }\\n            if (p2.freq > 1) {\\n                p.offer(new Pair(p2.freq - 1, p2.ch));\\n            }\\n        }\\n        \\n        if (!p.isEmpty()) {\\n            ans.append(p.poll().ch);\\n        }\\n        \\n        return ans.toString();\\n    }\\n    \\n    class Pair {\\n        int freq;\\n        char ch;\\n        \\n        Pair(int freq, char ch) {\\n            this.freq = freq;\\n            this.ch = ch;\\n        }\\n    }\\n}\\n```\\n```python []\\nimport heapq\\n\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        f = [0] * 26\\n        n = len(s)\\n        \\n        for i in range(n):\\n            f[ord(s[i]) - ord(\\'a\\')] += 1\\n            if f[ord(s[i]) - ord(\\'a\\')] > (n + 1) // 2:\\n                return \"\"\\n        \\n        p = []\\n        for i in range(26):\\n            if f[i] != 0:\\n                heapq.heappush(p, (-f[i], chr(i + ord(\\'a\\'))))\\n        \\n        ans = []\\n        while len(p) >= 2:\\n            freq1, ch1 = heapq.heappop(p)\\n            freq2, ch2 = heapq.heappop(p)\\n            ans.extend([ch1, ch2])\\n            if freq1 < -1:\\n                heapq.heappush(p, (freq1 + 1, ch1))\\n            if freq2 < -1:\\n                heapq.heappush(p, (freq2 + 1, ch2))\\n        \\n        if p:\\n            ans.append(p[0][1])\\n        \\n        return \\'\\'.join(ans)\\n\\n```\\n```C# []\\nusing System;\\nusing System.Collections.Generic;\\n\\npublic class Solution {\\n    public string ReorganizeString(string s) {\\n        int[] f = new int[26];\\n        int n = s.Length;\\n        \\n        foreach (char ch in s) {\\n            f[ch - \\'a\\']++;\\n            if (f[ch - \\'a\\'] > (n + 1) / 2) {\\n                return \"\";\\n            }\\n        }\\n        \\n        var p = new PriorityQueue<(int freq, char ch)>();\\n        for (int i = 0; i < 26; i++) {\\n            if (f[i] != 0) {\\n                p.Enqueue((-f[i], (char)(\\'a\\' + i)));\\n            }\\n        }\\n        \\n        var ansList = new List<char>();\\n        while (p.Count >= 2) {\\n            var (freq1, ch1) = p.Dequeue();\\n            var (freq2, ch2) = p.Dequeue();\\n            ansList.Add(ch1);\\n            ansList.Add(ch2);\\n            if (freq1 < -1) {\\n                p.Enqueue((freq1 + 1, ch1));\\n            }\\n            if (freq2 < -1) {\\n                p.Enqueue((freq2 + 1, ch2));\\n            }\\n        }\\n        \\n        if (p.Count == 1) {\\n            ansList.Add(p.Dequeue().ch);\\n        }\\n        \\n        return new string(ansList.ToArray());\\n    }\\n    \\n    public class PriorityQueue<T> where T : IComparable<T> {\\n        private readonly List<T> _heap = new List<T>();\\n\\n        public int Count => _heap.Count;\\n\\n        public void Enqueue(T item) {\\n            _heap.Add(item);\\n            int ci = _heap.Count - 1;\\n            while (ci > 0) {\\n                int pi = (ci - 1) / 2;\\n                if (_heap[ci].CompareTo(_heap[pi]) >= 0)\\n                    break;\\n                T tmp = _heap[ci]; _heap[ci] = _heap[pi]; _heap[pi] = tmp;\\n                ci = pi;\\n            }\\n        }\\n\\n        public T Dequeue() {\\n            int li = _heap.Count - 1;\\n            T frontItem = _heap[0];\\n            _heap[0] = _heap[li];\\n            _heap.RemoveAt(li);\\n\\n            --li;\\n            int pi = 0;\\n            while (true) {\\n                int ci = pi * 2 + 1;\\n                if (ci > li) break;\\n                int rc = ci + 1;\\n                if (rc <= li && _heap[rc].CompareTo(_heap[ci]) < 0)\\n                    ci = rc;\\n                if (_heap[pi].CompareTo(_heap[ci]) <= 0) break;\\n                T tmp = _heap[pi]; _heap[pi] = _heap[ci]; _heap[ci] = tmp;\\n                pi = ci;\\n            }\\n            return frontItem;\\n        }\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C#",
                    "Hash Table",
                    "String",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n       vector<int>f(26,0);\\n       int n=s.size();\\n       for(int i=0;i<s.size();i++){\\n           f[s[i]-\\'a\\']++;\\n        if(f[s[i]-\\'a\\']>(n+1)/2)\\n        return \"\";\\n       }\\n       priority_queue<pair<int,char>>p;\\n       for(int i=0;i<26;i++){\\n        if(f[i]!=0){\\n            p.push({f[i],(char)i+\\'a\\'});\\n        }\\n       }\\n       string ans=\"\";\\n       while(p.size()>=2){\\n           pair<int,char>p1=p.top();\\n           p.pop();\\n           pair<int,char>p2=p.top();\\n           p.pop();\\n           ans+=p1.second;\\n           ans+=p2.second;\\n           if(p1.first>1){\\n           p.push({p1.first-1,p1.second});\\n           }\\n           if(p2.first>1){\\n             p.push({p2.first-1,p2.second});\\n           }\\n       }\\n       if(p.size()==1)\\n        ans+=p.top().second;\\n       return ans;\\n    }\\n};\\n```\n```java []\\nimport java.util.*;\\n\\nclass Solution {\\n    public String reorganizeString(String s) {\\n        int[] f = new int[26];\\n        int n = s.length();\\n        \\n        for (int i = 0; i < n; i++) {\\n            f[s.charAt(i) - \\'a\\']++;\\n            if (f[s.charAt(i) - \\'a\\'] > (n + 1) / 2) {\\n                return \"\";\\n            }\\n        }\\n        \\n        PriorityQueue<Pair> p = new PriorityQueue<>((a, b) -> b.freq - a.freq);\\n        for (int i = 0; i < 26; i++) {\\n            if (f[i] != 0) {\\n                p.offer(new Pair(f[i], (char) (i + \\'a\\')));\\n            }\\n        }\\n        \\n        StringBuilder ans = new StringBuilder();\\n        while (p.size() >= 2) {\\n            Pair p1 = p.poll();\\n            Pair p2 = p.poll();\\n            ans.append(p1.ch);\\n            ans.append(p2.ch);\\n            if (p1.freq > 1) {\\n                p.offer(new Pair(p1.freq - 1, p1.ch));\\n            }\\n            if (p2.freq > 1) {\\n                p.offer(new Pair(p2.freq - 1, p2.ch));\\n            }\\n        }\\n        \\n        if (!p.isEmpty()) {\\n            ans.append(p.poll().ch);\\n        }\\n        \\n        return ans.toString();\\n    }\\n    \\n    class Pair {\\n        int freq;\\n        char ch;\\n        \\n        Pair(int freq, char ch) {\\n            this.freq = freq;\\n            this.ch = ch;\\n        }\\n    }\\n}\\n```\n```python []\\nimport heapq\\n\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        f = [0] * 26\\n        n = len(s)\\n        \\n        for i in range(n):\\n            f[ord(s[i]) - ord(\\'a\\')] += 1\\n            if f[ord(s[i]) - ord(\\'a\\')] > (n + 1) // 2:\\n                return \"\"\\n        \\n        p = []\\n        for i in range(26):\\n            if f[i] != 0:\\n                heapq.heappush(p, (-f[i], chr(i + ord(\\'a\\'))))\\n        \\n        ans = []\\n        while len(p) >= 2:\\n            freq1, ch1 = heapq.heappop(p)\\n            freq2, ch2 = heapq.heappop(p)\\n            ans.extend([ch1, ch2])\\n            if freq1 < -1:\\n                heapq.heappush(p, (freq1 + 1, ch1))\\n            if freq2 < -1:\\n                heapq.heappush(p, (freq2 + 1, ch2))\\n        \\n        if p:\\n            ans.append(p[0][1])\\n        \\n        return \\'\\'.join(ans)\\n\\n```\n```C# []\\nusing System;\\nusing System.Collections.Generic;\\n\\npublic class Solution {\\n    public string ReorganizeString(string s) {\\n        int[] f = new int[26];\\n        int n = s.Length;\\n        \\n        foreach (char ch in s) {\\n            f[ch - \\'a\\']++;\\n            if (f[ch - \\'a\\'] > (n + 1) / 2) {\\n                return \"\";\\n            }\\n        }\\n        \\n        var p = new PriorityQueue<(int freq, char ch)>();\\n        for (int i = 0; i < 26; i++) {\\n            if (f[i] != 0) {\\n                p.Enqueue((-f[i], (char)(\\'a\\' + i)));\\n            }\\n        }\\n        \\n        var ansList = new List<char>();\\n        while (p.Count >= 2) {\\n            var (freq1, ch1) = p.Dequeue();\\n            var (freq2, ch2) = p.Dequeue();\\n            ansList.Add(ch1);\\n            ansList.Add(ch2);\\n            if (freq1 < -1) {\\n                p.Enqueue((freq1 + 1, ch1));\\n            }\\n            if (freq2 < -1) {\\n                p.Enqueue((freq2 + 1, ch2));\\n            }\\n        }\\n        \\n        if (p.Count == 1) {\\n            ansList.Add(p.Dequeue().ch);\\n        }\\n        \\n        return new string(ansList.ToArray());\\n    }\\n    \\n    public class PriorityQueue<T> where T : IComparable<T> {\\n        private readonly List<T> _heap = new List<T>();\\n\\n        public int Count => _heap.Count;\\n\\n        public void Enqueue(T item) {\\n            _heap.Add(item);\\n            int ci = _heap.Count - 1;\\n            while (ci > 0) {\\n                int pi = (ci - 1) / 2;\\n                if (_heap[ci].CompareTo(_heap[pi]) >= 0)\\n                    break;\\n                T tmp = _heap[ci]; _heap[ci] = _heap[pi]; _heap[pi] = tmp;\\n                ci = pi;\\n            }\\n        }\\n\\n        public T Dequeue() {\\n            int li = _heap.Count - 1;\\n            T frontItem = _heap[0];\\n            _heap[0] = _heap[li];\\n            _heap.RemoveAt(li);\\n\\n            --li;\\n            int pi = 0;\\n            while (true) {\\n                int ci = pi * 2 + 1;\\n                if (ci > li) break;\\n                int rc = ci + 1;\\n                if (rc <= li && _heap[rc].CompareTo(_heap[ci]) < 0)\\n                    ci = rc;\\n                if (_heap[pi].CompareTo(_heap[ci]) <= 0) break;\\n                T tmp = _heap[pi]; _heap[pi] = _heap[ci]; _heap[ci] = tmp;\\n                pi = ci;\\n            }\\n            return frontItem;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128907,
                "title": "java-solution-99-similar-to-358",
                "content": "In problem 358, we asked to rearrange string such that the same characters are at least distance k from each other.\\nIn this problem, we are asked to rearrange string such that the same characters are at least distance 2 from each other.\\n````\\nclass Solution {\\n    public String reorganizeString(String S) {\\n        if (S == null || S.length() == 0) {\\n            return \"\";\\n        }\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char c : S.toCharArray()) {\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n        PriorityQueue<Map.Entry<Character, Integer>> pq = new PriorityQueue<>((a, b) -> (b.getValue() - a.getValue()));\\n        pq.addAll(map.entrySet());\\n        StringBuilder sb = new StringBuilder();\\n        Queue<Map.Entry<Character, Integer>> queue = new LinkedList<>();\\n        while (!pq.isEmpty()) {\\n            Map.Entry<Character, Integer> entry = pq.poll();\\n            sb.append(entry.getKey());\\n            entry.setValue(entry.getValue() - 1);\\n            queue.offer(entry);\\n            while (queue.size() > 1) {\\n                Map.Entry<Character, Integer> temp = queue.poll();\\n                if (temp.getValue() > 0) {\\n                    pq.offer(temp);\\n                }\\n            }\\n        }\\n        return sb.length() == S.length() ? sb.toString() : \"\";\\n    }\\n}\\n````\\n",
                "solutionTags": [],
                "code": "````\\nclass Solution {\\n    public String reorganizeString(String S) {\\n        if (S == null || S.length() == 0) {\\n            return \"\";\\n        }\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char c : S.toCharArray()) {\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n        PriorityQueue<Map.Entry<Character, Integer>> pq = new PriorityQueue<>((a, b) -> (b.getValue() - a.getValue()));\\n        pq.addAll(map.entrySet());\\n        StringBuilder sb = new StringBuilder();\\n        Queue<Map.Entry<Character, Integer>> queue = new LinkedList<>();\\n        while (!pq.isEmpty()) {\\n            Map.Entry<Character, Integer> entry = pq.poll();\\n            sb.append(entry.getKey());\\n            entry.setValue(entry.getValue() - 1);\\n            queue.offer(entry);\\n            while (queue.size() > 1) {\\n                Map.Entry<Character, Integer> temp = queue.poll();\\n                if (temp.getValue() > 0) {\\n                    pq.offer(temp);\\n                }\\n            }\\n        }\\n        return sb.length() == S.length() ? sb.toString() : \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212155,
                "title": "c-beats-100-elegant-code-complete-detailed-solution",
                "content": "**\"Approach - Using Max Heap\"**\\n\\n**Solution steps:-**  \\n**Step-1:** First of all count the occurences of each character in given string. Return empty string if any character occurs more than the half of string length because in such scenario we cannot create any alteration in the input string. For example, **aaab**, **aaaabc**, in these two strings character **a** occurs more than the half of string length and no valid character rearrangement can be done.\\nTime complexity of this step is **O(n)** because we are traversing the entire **n** length input string once, and space complexity is **O(1)** because we\\'re just creating an array of size 26 for every length of input.\\n\\n* **Key observation:** If any character occurs more than the half of input string length, then there will be no such rearrangement. And we can stop the entire process here. Otherwise, do the required rearrangement.   \\n\\n**Step-2:** Now create a max_heap from the count of characters. Here, for this I\\'m using a pair to remember which characters\\' count is what, **pair<countOfChar,char>**.\\nTime and space complexity of this step will be **O(1)** because to build a max_heap takes O(n) time and \\'n\\' is constant here i.e. 26. And space complexity is therefore also **O(1)**. \\n\\n**Step-3:** This is the major part of entire algorithm.\\n1. `int i = 0;`   \\nWe are storing rearragement from the first index obviously, in the input string itself. \\n2. `pair<int, char> prev = max_heap.top(); max_heap.pop();`\\nCreate a pair to store the first top pair of max_heap\\n3. `s[i++] = prev.second;`\\nStore the character into input string itself from index 0.\\n4. Now pop another pair from max_heap and put the character from pair into input string and reduce the charCount in **prev** pair and push the pair back to max_heap if more occurences of character still remains. Repeat this procedure until max_heap is empty.\\n   ```\\n   while (not max_heap.empty()) {\\n\\t\\tpair<int, char> curr = max_heap.top(); max_heap.pop();\\n\\t\\ts[i++] = curr.second;\\n\\t\\tif (--prev.first) max_heap.push(prev);\\n\\t\\tprev = curr;\\n\\t}\\n   ```\\n   Time complexity of this step is **O(n)** because we\\'re putting \\'n\\' characters to input string to create rearrangement. Though for every character insertion we\\'re doing one push and one pop operation in max_heap but since size of max_heap itself is constant i.e. O(26), therefore, these push and pop operations will not account for total time complexity.\\n\\nOverall time complexity of this solution is **O(n)**.\\n\\n**Code Without Comments**\\n```\\nclass Solution {\\npublic:\\n\\tstring reorganizeString(string s) {\\n\\t\\tvector<int> chrCounts(26);\\n\\t\\tfor (auto& chr: s) { if(++chrCounts[chr-97] > (s.size()+1)/2) return \"\";}\\n\\t\\tpriority_queue<pair<int, char>> max_heap;\\n\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\tif (chrCounts[i]) {max_heap.push({chrCounts[i], 97+i});}\\n\\t\\t}\\n\\t\\tint i = 0;\\n\\t\\tpair<int, char> prev = max_heap.top(); max_heap.pop();\\n\\t\\ts[i++] = prev.second;\\n\\t\\twhile (not max_heap.empty()) {\\n\\t\\t\\tpair<int, char> curr = max_heap.top(); max_heap.pop();\\n\\t\\t\\ts[i++] = curr.second;\\n\\t\\t\\tif (--prev.first) max_heap.push(prev);\\n\\t\\t\\tprev = curr;\\n\\t\\t}\\n\\t\\treturn s;\\n\\t}\\n};\\n```\\n\\n\\n**Commented Solution:-**\\n```\\nclass Solution {\\npublic:\\n\\tstring reorganizeString(string s) {\\n\\t\\t// step 1: count the occurrences of each charcater in given string ==> O(n) Time, O(1) Space\\n\\t\\t\\tvector<int> chrCounts(26);\\n\\t\\t\\tfor (auto& chr: s) { if(++chrCounts[chr-97] > (s.size()+1)/2) return \"\";}\\n\\t\\t\\n\\t\\t// step 2: make a max_heap of pair<charCount, char>  ==> O(1) Time and Space\\n\\t\\t\\tpriority_queue<pair<int, char>> max_heap;\\n\\t\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\t\\tif (chrCounts[i]) {max_heap.push({chrCounts[i], 97+i});}\\n\\t\\t\\t}\\n\\n\\t\\t// step 3: pop top 2 characters and put them into result string to create alteration\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tpair<int, char> prev = max_heap.top(); max_heap.pop();\\n\\t\\t\\ts[i++] = prev.second;\\n\\t\\t\\twhile (not max_heap.empty()) {\\n\\t\\t\\t\\tpair<int, char> curr = max_heap.top(); max_heap.pop();\\n\\t\\t\\t\\ts[i++] = curr.second;\\n\\t\\t\\t\\tif (--prev.first) max_heap.push(prev);\\n\\t\\t\\t\\tprev = curr;\\n\\t\\t\\t}\\n\\t\\treturn s;\\n\\t}\\n};\\n```\\n**Still having trouble to understand or you find something wrong here, lemme know** \\nThanks for your time. ;D\\n\\n**:**\\n![image](https://assets.leetcode.com/users/images/d246cb09-e787-42cd-956a-25f67d1d8d6f_1621173249.9747748.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n   while (not max_heap.empty()) {\\n\\t\\tpair<int, char> curr = max_heap.top(); max_heap.pop();\\n\\t\\ts[i++] = curr.second;\\n\\t\\tif (--prev.first) max_heap.push(prev);\\n\\t\\tprev = curr;\\n\\t}\\n   ```\n```\\nclass Solution {\\npublic:\\n\\tstring reorganizeString(string s) {\\n\\t\\tvector<int> chrCounts(26);\\n\\t\\tfor (auto& chr: s) { if(++chrCounts[chr-97] > (s.size()+1)/2) return \"\";}\\n\\t\\tpriority_queue<pair<int, char>> max_heap;\\n\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\tif (chrCounts[i]) {max_heap.push({chrCounts[i], 97+i});}\\n\\t\\t}\\n\\t\\tint i = 0;\\n\\t\\tpair<int, char> prev = max_heap.top(); max_heap.pop();\\n\\t\\ts[i++] = prev.second;\\n\\t\\twhile (not max_heap.empty()) {\\n\\t\\t\\tpair<int, char> curr = max_heap.top(); max_heap.pop();\\n\\t\\t\\ts[i++] = curr.second;\\n\\t\\t\\tif (--prev.first) max_heap.push(prev);\\n\\t\\t\\tprev = curr;\\n\\t\\t}\\n\\t\\treturn s;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tstring reorganizeString(string s) {\\n\\t\\t// step 1: count the occurrences of each charcater in given string ==> O(n) Time, O(1) Space\\n\\t\\t\\tvector<int> chrCounts(26);\\n\\t\\t\\tfor (auto& chr: s) { if(++chrCounts[chr-97] > (s.size()+1)/2) return \"\";}\\n\\t\\t\\n\\t\\t// step 2: make a max_heap of pair<charCount, char>  ==> O(1) Time and Space\\n\\t\\t\\tpriority_queue<pair<int, char>> max_heap;\\n\\t\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\t\\tif (chrCounts[i]) {max_heap.push({chrCounts[i], 97+i});}\\n\\t\\t\\t}\\n\\n\\t\\t// step 3: pop top 2 characters and put them into result string to create alteration\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tpair<int, char> prev = max_heap.top(); max_heap.pop();\\n\\t\\t\\ts[i++] = prev.second;\\n\\t\\t\\twhile (not max_heap.empty()) {\\n\\t\\t\\t\\tpair<int, char> curr = max_heap.top(); max_heap.pop();\\n\\t\\t\\t\\ts[i++] = curr.second;\\n\\t\\t\\t\\tif (--prev.first) max_heap.push(prev);\\n\\t\\t\\t\\tprev = curr;\\n\\t\\t\\t}\\n\\t\\treturn s;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480696,
                "title": "javascript-solution-sort-pq",
                "content": "### The idea - Sort\\n1. Build a hash based on character count, sort the hash from the largest count to smallest\\n2. A character count  that is larger than half of the string length is considered invalid\\n3. Start filling characters to all the even indexs, i.e. 0, 2, 4,..., when we got to the end, start filling odd indexes i.e. 1,3,5,...\\n4. By filling the characters this way, we can make sure that no same characters will be adjacent to each other\\n```\\n/**\\n * @param {string} S\\n * @return {string}\\n */\\nvar reorganizeString1 = function(S) {\\n    let hash = {};\\n    for (let c of S) hash[c] = hash[c] + 1 || 1;\\n\\n    let sort = Object.keys(hash).sort((a,b)=>hash[b] - hash[a]);\\n    let res = [];\\n    let index = 0;\\n\\n    for (let i = 0;i<sort.length;i++) {\\n        let occur = hash[sort[i]];\\n        if (occur > parseInt((S.length + 1)/2)) return \"\";\\n        for (let j = 0;j < occur;j++) {\\n            if (index >= S.length) index = 1;\\n            res[index] = sort[i];\\n            index += 2;\\n        }\\n    } \\n    return res.join(\\'\\');\\n};\\n```\\n### The idea - PQ\\n``` javascript\\nvar reorganizeString = function(S) {\\n    let hash = {}, pq = [];\\n    for (let s of S) hash[s] = hash[s] + 1 || 1;\\n\\n    for (let key in hash) pq.push([key, hash[key]]);\\n\\n    pq.sort((a,b)=>b[1]-a[1]);\\n    \\n    let res = \"\";    \\n    while (pq.length != 0) {\\n        let lastChar = res[res.length - 1];\\n        let first = pq.shift();\\n\\n        if(lastChar != first[0]) {\\n            res+=first[0];\\n            if (first[1]!=1) pq.push([first[0], first[1]-1]);\\n        } else {\\n            let second = pq.shift();\\n            if (second == null) return \"\";\\n            res+=second[0];\\n            pq.push(first);\\n            if (second[1]!=1) pq.push([second[0], second[1]-1]);\\n        }\\n        pq.sort((a,b)=>b[1]-a[1]);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} S\\n * @return {string}\\n */\\nvar reorganizeString1 = function(S) {\\n    let hash = {};\\n    for (let c of S) hash[c] = hash[c] + 1 || 1;\\n\\n    let sort = Object.keys(hash).sort((a,b)=>hash[b] - hash[a]);\\n    let res = [];\\n    let index = 0;\\n\\n    for (let i = 0;i<sort.length;i++) {\\n        let occur = hash[sort[i]];\\n        if (occur > parseInt((S.length + 1)/2)) return \"\";\\n        for (let j = 0;j < occur;j++) {\\n            if (index >= S.length) index = 1;\\n            res[index] = sort[i];\\n            index += 2;\\n        }\\n    } \\n    return res.join(\\'\\');\\n};\\n```\n``` javascript\\nvar reorganizeString = function(S) {\\n    let hash = {}, pq = [];\\n    for (let s of S) hash[s] = hash[s] + 1 || 1;\\n\\n    for (let key in hash) pq.push([key, hash[key]]);\\n\\n    pq.sort((a,b)=>b[1]-a[1]);\\n    \\n    let res = \"\";    \\n    while (pq.length != 0) {\\n        let lastChar = res[res.length - 1];\\n        let first = pq.shift();\\n\\n        if(lastChar != first[0]) {\\n            res+=first[0];\\n            if (first[1]!=1) pq.push([first[0], first[1]-1]);\\n        } else {\\n            let second = pq.shift();\\n            if (second == null) return \"\";\\n            res+=second[0];\\n            pq.push(first);\\n            if (second[1]!=1) pq.push([second[0], second[1]-1]);\\n        }\\n        pq.sort((a,b)=>b[1]-a[1]);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 134005,
                "title": "python-straightforward-solution",
                "content": "```\\nclass Solution(object):\\n    def reorganizeString(self, S):\\n        if len(S) == 1:\\n            return S\\n        count = collections.Counter(S)\\n        digit0 = max(count.keys(), key = lambda x: count[x])\\n\\n        an = [digit0 for _ in range(count[digit0])]\\n        i = 0\\n        for digit in count:\\n            if digit != digit0:\\n                for _ in range(count[digit]):\\n                    an[i%len(an)] += digit\\n                    i += 1\\n        \\n        return \\'\\'.join(an) if i >= len(an) - 1 else \\'\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def reorganizeString(self, S):\\n        if len(S) == 1:\\n            return S\\n        count = collections.Counter(S)\\n        digit0 = max(count.keys(), key = lambda x: count[x])\\n\\n        an = [digit0 for _ in range(count[digit0])]\\n        i = 0\\n        for digit in count:\\n            if digit != digit0:\\n                for _ in range(count[digit]):\\n                    an[i%len(an)] += digit\\n                    i += 1\\n        \\n        return \\'\\'.join(an) if i >= len(an) - 1 else \\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871713,
                "title": "python-solution-with-heap",
                "content": "```\\nclass Solution:\\n    def reorganizeString(self, S: str) -> str:\\n        cnt = Counter(S)\\n        heap = [(-v,k) for k,v in cnt.items()]\\n        heapq.heapify(heap)\\n        ans = []\\n        while(len(heap)>1):\\n            x = heapq.heappop(heap)\\n            y = heapq.heappop(heap)\\n            ans.extend([x[1],y[1]])\\n            if x[0]<-1:\\n                heapq.heappush(heap,(x[0]+1,x[1]))\\n            if y[0]<-1:\\n                heapq.heappush(heap,(y[0]+1,y[1]))\\n        if heap:\\n            if heap[0][0]<-1:\\n                return \"\" # case where last left element count is more than 2\\n            ans.append(heap[0][1])\\n        return \"\".join(ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def reorganizeString(self, S: str) -> str:\\n        cnt = Counter(S)\\n        heap = [(-v,k) for k,v in cnt.items()]\\n        heapq.heapify(heap)\\n        ans = []\\n        while(len(heap)>1):\\n            x = heapq.heappop(heap)\\n            y = heapq.heappop(heap)\\n            ans.extend([x[1],y[1]])\\n            if x[0]<-1:\\n                heapq.heappush(heap,(x[0]+1,x[1]))\\n            if y[0]<-1:\\n                heapq.heappush(heap,(y[0]+1,y[1]))\\n        if heap:\\n            if heap[0][0]<-1:\\n                return \"\" # case where last left element count is more than 2\\n            ans.append(heap[0][1])\\n        return \"\".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586521,
                "title": "o-n-code-with-comments",
                "content": "**Please Upvote,it helps a lot**\\n```\\nclass Solution {\\n    public String reorganizeString(String s) {\\n        int [] freq = new int[26]; //to Store Frequency of each alphabet\\n        char [] arr = s.toCharArray();\\n        \\n        for(int i = 0;i<arr.length;i++){  //store the frequency\\n            freq[arr[i] - \\'a\\']++;\\n        }\\n        \\n        int max = 0,letter = 0;\\n        \\n        for(int i = 0;i<26;i++){  //find the max frequency\\n            if(freq[i] > max){\\n                max = freq[i];\\n                letter = i;\\n            }\\n        }\\n        \\n        if(max > (s.length() + 1)/2) return \"\"; //if max is more than half then not possible\\n        \\n        int idx = 0;\\n        char [] res = new char[s.length()];\\n        \\n        while(freq[letter] > 0){   //distribute the max freq char into even indices\\n            res[idx] = (char)(letter + \\'a\\');\\n            idx += 2;\\n            freq[letter]--;\\n        }\\n        \\n        for(int i = 0;i<26;i++){  \\n            while(freq[i] > 0){\\n            if(idx >= s.length()) idx = 1; //all even indices filled, so switch to odd indices\\n            res[idx] = (char)(i + \\'a\\');\\n            idx += 2;\\n            freq[i]--;\\n          }\\n            \\n        }\\n        \\n        return String.valueOf(res);  \\n    }\\n}\\n\\nLogic Credit : (https://leetcode.com/fangbiyi/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reorganizeString(String s) {\\n        int [] freq = new int[26]; //to Store Frequency of each alphabet\\n        char [] arr = s.toCharArray();\\n        \\n        for(int i = 0;i<arr.length;i++){  //store the frequency\\n            freq[arr[i] - \\'a\\']++;\\n        }\\n        \\n        int max = 0,letter = 0;\\n        \\n        for(int i = 0;i<26;i++){  //find the max frequency\\n            if(freq[i] > max){\\n                max = freq[i];\\n                letter = i;\\n            }\\n        }\\n        \\n        if(max > (s.length() + 1)/2) return \"\"; //if max is more than half then not possible\\n        \\n        int idx = 0;\\n        char [] res = new char[s.length()];\\n        \\n        while(freq[letter] > 0){   //distribute the max freq char into even indices\\n            res[idx] = (char)(letter + \\'a\\');\\n            idx += 2;\\n            freq[letter]--;\\n        }\\n        \\n        for(int i = 0;i<26;i++){  \\n            while(freq[i] > 0){\\n            if(idx >= s.length()) idx = 1; //all even indices filled, so switch to odd indices\\n            res[idx] = (char)(i + \\'a\\');\\n            idx += 2;\\n            freq[i]--;\\n          }\\n            \\n        }\\n        \\n        return String.valueOf(res);  \\n    }\\n}\\n\\nLogic Credit : (https://leetcode.com/fangbiyi/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949173,
                "title": "c-priority-queue-day-23",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        map<int,int>m;\\n        for(auto i:s)m[i]++;\\n        priority_queue<pair<int,char>>pq;\\n        for(auto i:m)pq.push({i.second,i.first});\\n        string ans = \"\";\\n        while(pq.size()>=2){\\n            auto c1 = pq.top();pq.pop();\\n            auto c2 = pq.top();pq.pop();\\n            ans += c1.second;\\n            ans += c2.second;\\n            if(c1.first-1>0)pq.push({c1.first-1,c1.second});\\n            if(c2.first-1>0)pq.push({c2.first-1,c2.second});\\n        }\\n        if(pq.size()){\\n            if(pq.top().first>1)return \"\";\\n            ans += pq.top().second;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/27fde5ed-0c47-4dc4-901b-020ade08bd6e_1692780291.0377796.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Greedy",
                    "Heap (Priority Queue)",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        map<int,int>m;\\n        for(auto i:s)m[i]++;\\n        priority_queue<pair<int,char>>pq;\\n        for(auto i:m)pq.push({i.second,i.first});\\n        string ans = \"\";\\n        while(pq.size()>=2){\\n            auto c1 = pq.top();pq.pop();\\n            auto c2 = pq.top();pq.pop();\\n            ans += c1.second;\\n            ans += c2.second;\\n            if(c1.first-1>0)pq.push({c1.first-1,c1.second});\\n            if(c2.first-1>0)pq.push({c2.first-1,c2.second});\\n        }\\n        if(pq.size()){\\n            if(pq.top().first>1)return \"\";\\n            ans += pq.top().second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249397,
                "title": "c-o-n-full-explaination-map-heap",
                "content": "*  First we take the count of every character in the string and store it in a unordered map.We use unordered map because it is time effiecient.\\n*  Then we create a max heap of type \" pair<int,char> \" ,.We use a max heap here because we want to get finished with the highest no. of characters available first.\\n*  So we take out the first two elements in the heap and insert one character from each in our ans string and reduce count of 1 from both.\\n*    We then insert the elements back if the count is >0 otherwise inserting won\\'t be of any use to us.\\n*    We only do the above process till the max heap size become one.\\n*    Once it becomes 1 we come out of it.Then check if the last char present has a count >1 if it has so we have no choice but to return \"\" else insert the last character and return ans. \\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        unordered_map<char,int> m;\\n        for(char c:s){\\n            m[c]++;\\n        }\\n        priority_queue<pair<int,char>> maxh;\\n        for(auto itr:m){\\n            maxh.push({itr.second,itr.first});\\n        }\\n        string ans=\"\";\\n        while(maxh.size()>1){\\n            auto [a,b]=maxh.top();\\n            maxh.pop();\\n            auto [c,d]=maxh.top();\\n            maxh.pop();\\n            ans.push_back(b);\\n            ans.push_back(d);\\n            a--;\\n            c--;\\n            if(a>0){\\n                maxh.push({a,b});\\n            }\\n            if(c>0){\\n                maxh.push({c,d});\\n            }\\n        }\\n        if(maxh.size()==1){\\n            auto [a,b]=maxh.top();\\n            maxh.pop();\\n            if(a>1)return \"\";\\n            ans.push_back(b);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        unordered_map<char,int> m;\\n        for(char c:s){\\n            m[c]++;\\n        }\\n        priority_queue<pair<int,char>> maxh;\\n        for(auto itr:m){\\n            maxh.push({itr.second,itr.first});\\n        }\\n        string ans=\"\";\\n        while(maxh.size()>1){\\n            auto [a,b]=maxh.top();\\n            maxh.pop();\\n            auto [c,d]=maxh.top();\\n            maxh.pop();\\n            ans.push_back(b);\\n            ans.push_back(d);\\n            a--;\\n            c--;\\n            if(a>0){\\n                maxh.push({a,b});\\n            }\\n            if(c>0){\\n                maxh.push({c,d});\\n            }\\n        }\\n        if(maxh.size()==1){\\n            auto [a,b]=maxh.top();\\n            maxh.pop();\\n            if(a>1)return \"\";\\n            ans.push_back(b);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947847,
                "title": "c-frequency-array-same-char-with-alternating-indices-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLeetcode says \"Alternate placing the most common letters.\" \\n\\nUse this hint to know:\\nIf there is some character c with freq(c)>(n+1)/2 then it is impossible to find such string with adjacent characters not the same due to Pigeonhole principle, otherwise it is possible!\\n\\n```\\nIf n is odd, use both ends there are at most (n+1)/2 \\nalternating places. If n is even, there are at most n/2 \\nalternating places.\\nDue to Pigeonhole principle, if some character c with \\nfreq(c)>(n+1)/2 , then there must be some place \\nfor the adjacent characters with the same c!\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo use this fact, one needs the frequency tables for each alphabet in string s. There are 26 different alphabets, instead of a hash table using an array is good enough.\\n\\nSort the frequency table which is not neccessary, in fact to find the max freq & to point out which alphabet is most occurring is enough.( It is possible to optimize)\\nIf  max freq()>(n+1)/2 then answer={}\\notherwise proceed the process as follows:\\n1. Fill even indices first from the characters in table.\\n2. Fill odd indices from the characters left in table.\\n\\nConsider the test case\\n```\\n\"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\\n```\\nFind the frequency table. Note freq[0].first=max_freq. In this case there are 2 charaters e & h with max_freq=28. Since max_freq<(n+1)/2, without swap, it works also. But when max_freq=(n+1)/2, this swap can not be saved. E.g. s=\"vvvlo\" max_freq=freq(\\'v\\')=3==(5+1)/2, the swap must be taken. Place like \"vXvXv\" at first.\\n```\\n(28,e)(16,b)(26,c)(15,d)(22,a)(22,f)(17,g)\\n(28,h)(16,i)(11,j)(21,k)(11,l)(26,m)(23,n)\\n(17,o)(18,p)(11,q)(18,r)(19,s)(16,t)(20,u)\\n(24,v)(21,w)(18,x)(22,y)(14,z)\\n```\\nUse the code with sorting obtain:\\n```\\n\"hkhkhkhkhkhkhkhkhkhkhkhkhkhuhuhuhuhuhuhuhuhuhuhuhuhuhuhueueueueueuesesesesesesesesesesesesesesesesesesesexexexexmxmxmxmxmxmxmxmxmxmxmxmxmxmxmrmrmrmrmrmrmrmrmrmrmrmrcrcrcrcrcrcrcpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcocovovovovovovovovovovovovovovovovgvgvgvgvgvgvgvgvgngngngngngngngngntntntntntntntntntntntntntntntytyiyiyiyiyiyiyiyiyiyiyiyiyiyiyiyiybybybybybfbfbfbfbfbfbfbfbfbfbfbfdfdfdfdfdfdfdfdfdfdfdadadadadazazazazazazazazazazazazazazaqaqaqaqwqwqwqwqwqwqwqwlwlwlwlwlwlwlwlwlwlwlwjwjwjkjkjkjkjkjkjkjkj\"\\n```\\nUse the code just finding max_freq & swap once\\n```\\n\"emememememememememenenenenenenenenenenenenenenenenenenenbnbnbnbnbobobobobobobobobobobobococococococpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcqcqcqdqdqdqdqdqdqdqdqdrdrdrdrdrdrdrarararararararararararasasasasasasasasasasasfsfsfsfsfsfsfsfsftftftftftftftftftftftftftftgtgtguguguguguguguguguguguguguguguhuhuhuhuhuhvhvhvhvhvhvhvhvhvhvhvhvhvhvhvhvhvhvhvhvhvhvhviviwiwiwiwiwiwiwiwiwiwiwiwiwiwiwjwjwjwjwjwjwjxjxjxjxjxkxkxkxkxkxkxkxkxkxkxkxkxkxkykykykykykykykylylylylylylylylylylylymymymymzmzmzmzmzmzmzmzmzmzmzmzmzmz\"\\n```\\nOther testcase ```kissossxsis``` with process\\n```\\n(6,s)(2,i)(1,k)(1,o)(1,x)\\n```\\nFill even indices\\n```\\n0->sXXXXXXXXXX\\n2->sXsXXXXXXXX\\n4->sXsXsXXXXXX\\n6->sXsXsXsXXXX\\n8->sXsXsXsXsXX\\n10->sXsXsXsXsXs\\n```\\nFill odd indices\\n```\\n1->sisXsXsXsXs\\n3->sisisXsXsXs\\n5->sisisksXsXs\\n7->sisisksosXs\\n9->sisisksosxs\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n+ 26 \\\\log(26))=O(n)\\\\to O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(26)=O(1)$$\\n# Code using sort beats 100%\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int n=s.size();\\n        vector<pair<int, char>> freq(26, {0, \\'X\\'});\\n        for(char c: s){\\n            freq[c-\\'a\\'].first++;\\n            freq[c-\\'a\\'].second=c;\\n        }\\n        sort(freq.begin(), freq.end(), greater<pair<int, char>>());\\n    //    for (auto& [f, c]: freq) cout<<\"(\" <<f<<\",\"<<c<<\")\"; cout<<endl;\\n\\n        if (freq[0].first>(n+1)/2) return string();\\n        string ans(n, \\'X\\');\\n\\n        // Fill even indices first\\n        int j=0;\\n        for (int i = 0; i < n; i += 2) {\\n            while (j < 26 && freq[j].first == 0) j++;\\n        \\n            ans[i] = freq[j].second;\\n            freq[j].first--;\\n        }\\n        \\n        // Fill odd indices\\n        for (int i = 1; i < n; i += 2) {\\n            while (j < 26 && freq[j].first == 0) j++;\\n        \\n            ans[i] = freq[j].second;\\n            freq[j].first--;\\n        }\\n\\n    //    cout<<ans<<endl;\\n        return ans;    \\n    }\\n};\\n```\\n# code without sort just find max_freq & swap once beats 100%\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int n=s.size();\\n        vector<pair<int, char>> freq(26, {0, \\'X\\'});\\n        for(char c: s){\\n            freq[c-\\'a\\'].first++;\\n            freq[c-\\'a\\'].second=c;\\n        }\\n    //    sort(freq.begin(), freq.end(), greater<pair<int, char>>());\\n        int max_freq=0, max_i=-1;\\n        for(int i=0; i<26; i++){\\n            if (max_freq<freq[i].first){\\n                max_freq=freq[i].first;\\n                max_i=i;\\n            }\\n        }\\n        // If freq[max_i]==(n+1)/2, this must be done. For saving \\n        // an  if-clause, this is always done\\n        swap(freq[0], freq[max_i]);\\n\\n        if (max_freq>(n+1)/2) return string();\\n        string ans(n, \\'X\\');\\n\\n        // Fill even indices first\\n        int j=0;\\n        for (int i = 0; i < n; i += 2) {\\n            while (j < 26 && freq[j].first == 0) j++;\\n            ans[i] = freq[j].second;\\n            freq[j].first--;\\n        }\\n        \\n        // Fill odd indices\\n        for (int i = 1; i < n; i += 2) {\\n            while (j < 26 && freq[j].first == 0) j++;\\n             ans[i] = freq[j].second;\\n            freq[j].first--;\\n        }\\n\\n        //cout<<ans<<endl;\\n        return ans;    \\n    }\\n};\\n```\\nThere are 4 dog holes & 3 dogs, it is possible for each dog a dog hole! But impossible for each dog 2 dog holes!\\n# And impossible for every adjacent pair of dog holes for only 1 dog!! \\n![DALL\\xB7E 2023-08-23 11.18.53 - there are 3 dogs and 2 doghouses in realistic style.png](https://assets.leetcode.com/users/images/be23afd9-9bcf-4af4-bfad-1f4f04c42e50_1692760813.9675193.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nIf n is odd, use both ends there are at most (n+1)/2 \\nalternating places. If n is even, there are at most n/2 \\nalternating places.\\nDue to Pigeonhole principle, if some character c with \\nfreq(c)>(n+1)/2 , then there must be some place \\nfor the adjacent characters with the same c!\\n```\n```\\n\"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\\n```\n```\\n(28,e)(16,b)(26,c)(15,d)(22,a)(22,f)(17,g)\\n(28,h)(16,i)(11,j)(21,k)(11,l)(26,m)(23,n)\\n(17,o)(18,p)(11,q)(18,r)(19,s)(16,t)(20,u)\\n(24,v)(21,w)(18,x)(22,y)(14,z)\\n```\n```\\n\"hkhkhkhkhkhkhkhkhkhkhkhkhkhuhuhuhuhuhuhuhuhuhuhuhuhuhuhueueueueueuesesesesesesesesesesesesesesesesesesesexexexexmxmxmxmxmxmxmxmxmxmxmxmxmxmxmrmrmrmrmrmrmrmrmrmrmrmrcrcrcrcrcrcrcpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcocovovovovovovovovovovovovovovovovgvgvgvgvgvgvgvgvgngngngngngngngngntntntntntntntntntntntntntntntytyiyiyiyiyiyiyiyiyiyiyiyiyiyiyiyiybybybybybfbfbfbfbfbfbfbfbfbfbfbfdfdfdfdfdfdfdfdfdfdfdadadadadazazazazazazazazazazazazazazaqaqaqaqwqwqwqwqwqwqwqwlwlwlwlwlwlwlwlwlwlwlwjwjwjkjkjkjkjkjkjkjkj\"\\n```\n```\\n\"emememememememememenenenenenenenenenenenenenenenenenenenbnbnbnbnbobobobobobobobobobobobococococococpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcqcqcqdqdqdqdqdqdqdqdqdrdrdrdrdrdrdrarararararararararararasasasasasasasasasasasfsfsfsfsfsfsfsfsftftftftftftftftftftftftftftgtgtguguguguguguguguguguguguguguguhuhuhuhuhuhvhvhvhvhvhvhvhvhvhvhvhvhvhvhvhvhvhvhvhvhvhvhviviwiwiwiwiwiwiwiwiwiwiwiwiwiwiwjwjwjwjwjwjwjxjxjxjxjxkxkxkxkxkxkxkxkxkxkxkxkxkxkykykykykykykykylylylylylylylylylylylymymymymzmzmzmzmzmzmzmzmzmzmzmzmzmz\"\\n```\n```kissossxsis```\n```\\n(6,s)(2,i)(1,k)(1,o)(1,x)\\n```\n```\\n0->sXXXXXXXXXX\\n2->sXsXXXXXXXX\\n4->sXsXsXXXXXX\\n6->sXsXsXsXXXX\\n8->sXsXsXsXsXX\\n10->sXsXsXsXsXs\\n```\n```\\n1->sisXsXsXsXs\\n3->sisisXsXsXs\\n5->sisisksXsXs\\n7->sisisksosXs\\n9->sisisksosxs\\n```\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int n=s.size();\\n        vector<pair<int, char>> freq(26, {0, \\'X\\'});\\n        for(char c: s){\\n            freq[c-\\'a\\'].first++;\\n            freq[c-\\'a\\'].second=c;\\n        }\\n        sort(freq.begin(), freq.end(), greater<pair<int, char>>());\\n    //    for (auto& [f, c]: freq) cout<<\"(\" <<f<<\",\"<<c<<\")\"; cout<<endl;\\n\\n        if (freq[0].first>(n+1)/2) return string();\\n        string ans(n, \\'X\\');\\n\\n        // Fill even indices first\\n        int j=0;\\n        for (int i = 0; i < n; i += 2) {\\n            while (j < 26 && freq[j].first == 0) j++;\\n        \\n            ans[i] = freq[j].second;\\n            freq[j].first--;\\n        }\\n        \\n        // Fill odd indices\\n        for (int i = 1; i < n; i += 2) {\\n            while (j < 26 && freq[j].first == 0) j++;\\n        \\n            ans[i] = freq[j].second;\\n            freq[j].first--;\\n        }\\n\\n    //    cout<<ans<<endl;\\n        return ans;    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int n=s.size();\\n        vector<pair<int, char>> freq(26, {0, \\'X\\'});\\n        for(char c: s){\\n            freq[c-\\'a\\'].first++;\\n            freq[c-\\'a\\'].second=c;\\n        }\\n    //    sort(freq.begin(), freq.end(), greater<pair<int, char>>());\\n        int max_freq=0, max_i=-1;\\n        for(int i=0; i<26; i++){\\n            if (max_freq<freq[i].first){\\n                max_freq=freq[i].first;\\n                max_i=i;\\n            }\\n        }\\n        // If freq[max_i]==(n+1)/2, this must be done. For saving \\n        // an  if-clause, this is always done\\n        swap(freq[0], freq[max_i]);\\n\\n        if (max_freq>(n+1)/2) return string();\\n        string ans(n, \\'X\\');\\n\\n        // Fill even indices first\\n        int j=0;\\n        for (int i = 0; i < n; i += 2) {\\n            while (j < 26 && freq[j].first == 0) j++;\\n            ans[i] = freq[j].second;\\n            freq[j].first--;\\n        }\\n        \\n        // Fill odd indices\\n        for (int i = 1; i < n; i += 2) {\\n            while (j < 26 && freq[j].first == 0) j++;\\n             ans[i] = freq[j].second;\\n            freq[j].first--;\\n        }\\n\\n        //cout<<ans<<endl;\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1491490,
                "title": "for-beginners-98-faster-simple-approach-without-heap",
                "content": "## IDEA:\\n* First count the number of characters in word.\\n* If any character is having its presence greater then the half of length of string then it\\'s unpossible to arrange them.\\n* Now, sort the dictionary counter in decreasing order on the basis of its number of times presence in word.\\n* Start putting the most frequent letter into the resultant list one by one leaving the one space in between.\\n* for second most frequent first search for the blank space where it started and similarly for others.\\n\\n**Little-bit concentration needed in last part in arranging the letters, But idea is beautifull.**\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        \\n        n = len(s)\\n        dic = Counter(s)\\n        s_dic = dict(sorted(dic.items(),key=lambda x: x[1],reverse=True)) \\n        \\n        for c in dic:\\n            if dic[c]>((n+1)//2):\\n                return \"\"\\n        \\n        res = [\"\"]*n\\n        p = n\\n        while p>0:\\n            i = 0\\n            while res[i]!=\"\":               # find the start of empty slot.\\n                i+=1\\n                \\n            for k in s_dic:                         # Most frequent key will come first.\\n                while i<n and dic[k]>0:                 \\n                    res[i]=k\\n                    dic[k]-=1\\n                    i+=2\\n                    p-=1\\n                    \\n        return \\'\\'.join(res)\\n\\n### Thanks and Upvote if you got any help !!\\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "## IDEA:\\n* First count the number of characters in word.\\n* If any character is having its presence greater then the half of length of string then it\\'s unpossible to arrange them.\\n* Now, sort the dictionary counter in decreasing order on the basis of its number of times presence in word.\\n* Start putting the most frequent letter into the resultant list one by one leaving the one space in between.\\n* for second most frequent first search for the blank space where it started and similarly for others.\\n\\n**Little-bit concentration needed in last part in arranging the letters, But idea is beautifull.**\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        \\n        n = len(s)\\n        dic = Counter(s)\\n        s_dic = dict(sorted(dic.items(),key=lambda x: x[1],reverse=True)) \\n        \\n        for c in dic:\\n            if dic[c]>((n+1)//2):\\n                return \"\"\\n        \\n        res = [\"\"]*n\\n        p = n\\n        while p>0:\\n            i = 0\\n            while res[i]!=\"\":               # find the start of empty slot.\\n                i+=1\\n                \\n            for k in s_dic:                         # Most frequent key will come first.\\n                while i<n and dic[k]>0:                 \\n                    res[i]=k\\n                    dic[k]-=1\\n                    i+=2\\n                    p-=1\\n                    \\n        return \\'\\'.join(res)\\n\\n### Thanks and Upvote if you got any help !!\\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1296357,
                "title": "python-clean-code-o-nlogn-no-heap-easy-to-understand",
                "content": "Upvote if you like my solution, thank you!\\n```python\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        n = len(s)\\n        freq = Counter(s)\\n        freq = sorted(freq.items(), key=lambda k: -k[1])\\n        if freq[0][1] >= n / 2 + 1:\\n            return \"\"\\n        res = [\"\"] * n\\n        i = 0\\n        for x, fx in freq:  # iterate the sorted dictionary\\n            for _ in range(fx):  # loop fx times\\n                if i >= n:\\n                    i = 1  # go back to index 1\\n                res[i] = x\\n                i += 2\\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        n = len(s)\\n        freq = Counter(s)\\n        freq = sorted(freq.items(), key=lambda k: -k[1])\\n        if freq[0][1] >= n / 2 + 1:\\n            return \"\"\\n        res = [\"\"] * n\\n        i = 0\\n        for x, fx in freq:  # iterate the sorted dictionary\\n            for _ in range(fx):  # loop fx times\\n                if i >= n:\\n                    i = 1  # go back to index 1\\n                res[i] = x\\n                i += 2\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575244,
                "title": "simple-javascript-solution",
                "content": "```\\nlet reorganizeString = (str) => {\\n  // build a frequency map for characters in S - max 26 entries...\\n  let map = {};\\n  for (let idx = 0, len = str.length; idx < len; idx++) {\\n    let char = str[idx];\\n    map[char] = (map[char] || 0) + 1;\\n  }\\n  // sorted array based on frequency count - max 26 entries => O(1) => constant time\\n  let sorted = Object.keys(map).sort((a, b) => map[b] - map[a]);\\n\\n  // fast path early return if a count is (N+1) / 2 for first item\\n  let max = (str.length + 1) / 2;\\n  if (map[sorted[0]] > max) return \\'\\';\\n\\n  // interleave characters\\n  let result = [];\\n  let position = 0;\\n  for (let idx = 0, len = sorted.length; idx < len; idx++) {\\n    let char = sorted[idx];\\n    let frequency = map[char];\\n    for (let j = 0; j < frequency; j++) {\\n      // rewind pointer to 1 when we overflow odd indexes...\\n      // note: we don\\'t have enough characters to overflow again\\n      if (position >= str.length) position = 1;\\n      result[position] = char;\\n      position += 2;\\n    }\\n  }\\n  return result.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet reorganizeString = (str) => {\\n  // build a frequency map for characters in S - max 26 entries...\\n  let map = {};\\n  for (let idx = 0, len = str.length; idx < len; idx++) {\\n    let char = str[idx];\\n    map[char] = (map[char] || 0) + 1;\\n  }\\n  // sorted array based on frequency count - max 26 entries => O(1) => constant time\\n  let sorted = Object.keys(map).sort((a, b) => map[b] - map[a]);\\n\\n  // fast path early return if a count is (N+1) / 2 for first item\\n  let max = (str.length + 1) / 2;\\n  if (map[sorted[0]] > max) return \\'\\';\\n\\n  // interleave characters\\n  let result = [];\\n  let position = 0;\\n  for (let idx = 0, len = sorted.length; idx < len; idx++) {\\n    let char = sorted[idx];\\n    let frequency = map[char];\\n    for (let j = 0; j < frequency; j++) {\\n      // rewind pointer to 1 when we overflow odd indexes...\\n      // note: we don\\'t have enough characters to overflow again\\n      if (position >= str.length) position = 1;\\n      result[position] = char;\\n      position += 2;\\n    }\\n  }\\n  return result.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3949276,
                "title": "video-ex-amazon-explains-a-solution-with-python-javascript-java-and-c",
                "content": "# Intuition\\nUsing max heap to reorganize String.\\n\\n# Solution Video\\n\\n### Please subscribe to my channel from here. I have 247 videos as of August 23rd.\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n\\nhttps://youtu.be/AN6dVKlQG5U\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be differnt a bit.\\n\\n1. Initialize `char_freq` dictionary to track character frequencies.\\n   - Create an empty dictionary `char_freq`.\\n\\n2. Populate `char_freq` dictionary with character frequencies.\\n   - Loop through each character `c` in the input string `s`.\\n   - If `c` is not in `char_freq`, add it with a value of 1. If `c` is already in `char_freq`, increment its value by 1.\\n\\n3. Create a max heap of character frequencies.\\n   - Create an empty list `max_heap`.\\n   - Iterate through the items in the `char_freq` dictionary.\\n   - For each character `char` and frequency `freq` pair, create a tuple `(-freq, char)` and append it to `max_heap`.\\n   - Convert the list `max_heap` into a valid max heap using the `heapify` function from the `heapq` module.\\n\\n4. Initialize `res` list to store the reorganized string.\\n   - Create an empty list `res`.\\n\\n5. Initialize `prev_freq` and `prev_char` to track the previous character\\'s frequency and value.\\n   - Initialize `prev_freq` to 0.\\n   - Initialize `prev_char` to an empty string.\\n\\n6. Reorganize the characters in the max heap.\\n   - Start a loop that continues while the `max_heap` is not empty.\\n   - Pop the character with the highest frequency (lowest negative frequency) from the `max_heap`. This character becomes the next character in the reorganized string, so append it to the `res` list.\\n   - Check if `prev_freq` is negative (indicating that the previous character needs to be re-added to the heap).\\n     - If it is negative, push a tuple `(prev_freq, prev_char)` back into the `max_heap`.\\n   - Increment `freq` by 1 to account for the character added to the result.\\n   - Update `prev_freq` and `prev_char` with the current values.\\n\\n7. Check if the reorganized string length matches the original string length.\\n   - After the loop, compare the length of the `res` list with the length of the input string `s`.\\n   - If they are not equal, return an empty string to indicate that reorganization is not possible.\\n\\n8. Return the reorganized string.\\n   - Join the characters in the `res` list into a single string using the `join` function with an empty string separator.\\n   - Return the reorganized string.\\n\\nThis algorithm constructs a dictionary to track character frequencies, creates a max heap of character frequencies, and then reorganizes characters by choosing the most frequent character while ensuring that no two consecutive characters are the same. The algorithm returns the reorganized string if possible, otherwise an empty string.\\n\\n# Complexity\\n- Time complexity: O(n log k)\\nn is total number of characters and k is unique number of characters\\n\\n- Space complexity: O(n)\\n\\n\\n```python []\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        char_freq = {}\\n        for c in s:\\n            char_freq[c] = char_freq.get(c, 0) + 1\\n        \\n        max_heap = [(-freq, char) for char, freq in char_freq.items()]\\n        heapq.heapify(max_heap)\\n\\n        res = []\\n        prev_freq, prev_char = 0, \"\"\\n\\n        while max_heap:\\n            freq, char = heapq.heappop(max_heap)\\n            res.append(char)\\n\\n            if prev_freq < 0:\\n                heapq.heappush(max_heap, (prev_freq, prev_char))\\n            \\n            freq += 1\\n            prev_freq, prev_char = freq, char\\n        \\n        if len(res) != len(s):\\n            return \"\"\\n        \\n        return \"\".join(res)\\n```\\n```javascript []\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reorganizeString = function(s) {\\n    const charFreq = {};\\n    for (const c of s) {\\n        charFreq[c] = (charFreq[c] || 0) + 1;\\n    }\\n    \\n    const maxHeap = Object.entries(charFreq).map(([char, freq]) => [-freq, char]);\\n    makeHeap(maxHeap);\\n\\n    const res = [];\\n    let prevFreq = 0, prevChar = \\'\\';\\n\\n    while (maxHeap.length) {\\n        const [freq, char] = popHeap(maxHeap);\\n        res.push(char);\\n\\n        if (prevFreq < 0) {\\n            maxHeap.push([prevFreq, prevChar]);\\n            makeHeap(maxHeap);\\n        }\\n        \\n        prevFreq = freq + 1;\\n        prevChar = char;\\n    }\\n    \\n    if (res.length !== s.length) {\\n        return \\'\\';\\n    }\\n    \\n    return res.join(\\'\\');    \\n};\\n\\nfunction makeHeap(arr) {\\n    for (let i = Math.floor(arr.length / 2); i >= 0; i--) {\\n        heapify(arr, i);\\n    }\\n}\\n\\nfunction popHeap(arr) {\\n    const top = arr[0];\\n    arr[0] = arr[arr.length - 1];\\n    arr.pop();\\n    heapify(arr, 0);\\n    return top;\\n}\\n\\nfunction heapify(arr, i) {\\n    const left = 2 * i + 1;\\n    const right = 2 * i + 2;\\n    let largest = i;\\n\\n    if (left < arr.length && arr[left][0] < arr[largest][0]) {\\n        largest = left;\\n    }\\n\\n    if (right < arr.length && arr[right][0] < arr[largest][0]) {\\n        largest = right;\\n    }\\n\\n    if (largest !== i) {\\n        [arr[i], arr[largest]] = [arr[largest], arr[i]];\\n        heapify(arr, largest);\\n    }\\n}\\n```\\n```java []\\nclass Solution {\\n    public String reorganizeString(String s) {\\n        Map<Character, Integer> charFreq = new HashMap<>();\\n        for (char c : s.toCharArray()) {\\n            charFreq.put(c, charFreq.getOrDefault(c, 0) + 1);\\n        }\\n\\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> b[1] - a[1]);\\n        for (Map.Entry<Character, Integer> entry : charFreq.entrySet()) {\\n            maxHeap.offer(new int[]{entry.getKey(), entry.getValue()});\\n        }\\n\\n        StringBuilder res = new StringBuilder();\\n        int[] prev = new int[]{\\'#\\', 0};\\n\\n        while (!maxHeap.isEmpty()) {\\n            int[] current = maxHeap.poll();\\n            res.append((char) current[0]);\\n\\n            if (prev[1] > 0) {\\n                maxHeap.offer(prev);\\n            }\\n\\n            current[1]--;\\n            prev = current;\\n        }\\n\\n        if (res.length() != s.length()) {\\n            return \"\";\\n        }\\n\\n        return res.toString();        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        unordered_map<char, int> charFreq;\\n        for (char c : s) {\\n            charFreq[c]++;\\n        }\\n\\n        auto comp = [](const pair<char, int>& a, const pair<char, int>& b) {\\n            return a.second < b.second;\\n        };\\n\\n        priority_queue<pair<char, int>, vector<pair<char, int>>, decltype(comp)> maxHeap(comp);\\n        for (const auto& entry : charFreq) {\\n            maxHeap.push({entry.first, entry.second});\\n        }\\n\\n        string res = \"\";\\n        pair<char, int> prev = {\\'#\\', 0};\\n\\n        while (!maxHeap.empty()) {\\n            pair<char, int> current = maxHeap.top();\\n            maxHeap.pop();\\n            res += current.first;\\n\\n            if (prev.second > 0) {\\n                maxHeap.push(prev);\\n            }\\n\\n            current.second--;\\n            prev = current;\\n        }\\n\\n        if (res.size() != s.size()) {\\n            return \"\";\\n        }\\n\\n        return res;        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        char_freq = {}\\n        for c in s:\\n            char_freq[c] = char_freq.get(c, 0) + 1\\n        \\n        max_heap = [(-freq, char) for char, freq in char_freq.items()]\\n        heapq.heapify(max_heap)\\n\\n        res = []\\n        prev_freq, prev_char = 0, \"\"\\n\\n        while max_heap:\\n            freq, char = heapq.heappop(max_heap)\\n            res.append(char)\\n\\n            if prev_freq < 0:\\n                heapq.heappush(max_heap, (prev_freq, prev_char))\\n            \\n            freq += 1\\n            prev_freq, prev_char = freq, char\\n        \\n        if len(res) != len(s):\\n            return \"\"\\n        \\n        return \"\".join(res)\\n```\n```javascript []\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reorganizeString = function(s) {\\n    const charFreq = {};\\n    for (const c of s) {\\n        charFreq[c] = (charFreq[c] || 0) + 1;\\n    }\\n    \\n    const maxHeap = Object.entries(charFreq).map(([char, freq]) => [-freq, char]);\\n    makeHeap(maxHeap);\\n\\n    const res = [];\\n    let prevFreq = 0, prevChar = \\'\\';\\n\\n    while (maxHeap.length) {\\n        const [freq, char] = popHeap(maxHeap);\\n        res.push(char);\\n\\n        if (prevFreq < 0) {\\n            maxHeap.push([prevFreq, prevChar]);\\n            makeHeap(maxHeap);\\n        }\\n        \\n        prevFreq = freq + 1;\\n        prevChar = char;\\n    }\\n    \\n    if (res.length !== s.length) {\\n        return \\'\\';\\n    }\\n    \\n    return res.join(\\'\\');    \\n};\\n\\nfunction makeHeap(arr) {\\n    for (let i = Math.floor(arr.length / 2); i >= 0; i--) {\\n        heapify(arr, i);\\n    }\\n}\\n\\nfunction popHeap(arr) {\\n    const top = arr[0];\\n    arr[0] = arr[arr.length - 1];\\n    arr.pop();\\n    heapify(arr, 0);\\n    return top;\\n}\\n\\nfunction heapify(arr, i) {\\n    const left = 2 * i + 1;\\n    const right = 2 * i + 2;\\n    let largest = i;\\n\\n    if (left < arr.length && arr[left][0] < arr[largest][0]) {\\n        largest = left;\\n    }\\n\\n    if (right < arr.length && arr[right][0] < arr[largest][0]) {\\n        largest = right;\\n    }\\n\\n    if (largest !== i) {\\n        [arr[i], arr[largest]] = [arr[largest], arr[i]];\\n        heapify(arr, largest);\\n    }\\n}\\n```\n```java []\\nclass Solution {\\n    public String reorganizeString(String s) {\\n        Map<Character, Integer> charFreq = new HashMap<>();\\n        for (char c : s.toCharArray()) {\\n            charFreq.put(c, charFreq.getOrDefault(c, 0) + 1);\\n        }\\n\\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> b[1] - a[1]);\\n        for (Map.Entry<Character, Integer> entry : charFreq.entrySet()) {\\n            maxHeap.offer(new int[]{entry.getKey(), entry.getValue()});\\n        }\\n\\n        StringBuilder res = new StringBuilder();\\n        int[] prev = new int[]{\\'#\\', 0};\\n\\n        while (!maxHeap.isEmpty()) {\\n            int[] current = maxHeap.poll();\\n            res.append((char) current[0]);\\n\\n            if (prev[1] > 0) {\\n                maxHeap.offer(prev);\\n            }\\n\\n            current[1]--;\\n            prev = current;\\n        }\\n\\n        if (res.length() != s.length()) {\\n            return \"\";\\n        }\\n\\n        return res.toString();        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        unordered_map<char, int> charFreq;\\n        for (char c : s) {\\n            charFreq[c]++;\\n        }\\n\\n        auto comp = [](const pair<char, int>& a, const pair<char, int>& b) {\\n            return a.second < b.second;\\n        };\\n\\n        priority_queue<pair<char, int>, vector<pair<char, int>>, decltype(comp)> maxHeap(comp);\\n        for (const auto& entry : charFreq) {\\n            maxHeap.push({entry.first, entry.second});\\n        }\\n\\n        string res = \"\";\\n        pair<char, int> prev = {\\'#\\', 0};\\n\\n        while (!maxHeap.empty()) {\\n            pair<char, int> current = maxHeap.top();\\n            maxHeap.pop();\\n            res += current.first;\\n\\n            if (prev.second > 0) {\\n                maxHeap.push(prev);\\n            }\\n\\n            current.second--;\\n            prev = current;\\n        }\\n\\n        if (res.size() != s.size()) {\\n            return \"\";\\n        }\\n\\n        return res;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 579511,
                "title": "using-priority-queue-and-hashmap-c-implemenation-youtube-com-watch-v-zam-gllvysw",
                "content": "C++ implementation of the following amazing explanation by Kevin:\\n\\nhttps://www.youtube.com/watch?v=zaM_GLLvysw\\n\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        map<char, int> m;\\n        for (auto &i : s) {\\n            m[i] += 1;\\n        }\\n        priority_queue<pair<int, char>> pq;\\n        for (auto &ele : m) {\\n            pq.push(make_pair(ele.second, ele.first));\\n        }\\n        string ans = \"\";\\n        \\n        while (pq.size() > 1) {\\n            char mostFrequent = pq.top().second;\\n            pq.pop();\\n            char nextFrequent = pq.top().second;\\n            pq.pop();\\n            ans += mostFrequent;\\n            ans += nextFrequent;\\n            if (m[mostFrequent] - 1 > 0) {\\n                m[mostFrequent] -= 1;\\n                pq.push(make_pair(m[mostFrequent], mostFrequent));\\n            }\\n            if (m[nextFrequent] - 1 > 0) {\\n                m[nextFrequent] -= 1;\\n                pq.push(make_pair(m[nextFrequent], nextFrequent));\\n            }\\n        }\\n        \\n        if (pq.size()) {\\n            char lastChar = pq.top().second;\\n            if (m[lastChar] > 1) return \"\";\\n            else ans += lastChar;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        map<char, int> m;\\n        for (auto &i : s) {\\n            m[i] += 1;\\n        }\\n        priority_queue<pair<int, char>> pq;\\n        for (auto &ele : m) {\\n            pq.push(make_pair(ele.second, ele.first));\\n        }\\n        string ans = \"\";\\n        \\n        while (pq.size() > 1) {\\n            char mostFrequent = pq.top().second;\\n            pq.pop();\\n            char nextFrequent = pq.top().second;\\n            pq.pop();\\n            ans += mostFrequent;\\n            ans += nextFrequent;\\n            if (m[mostFrequent] - 1 > 0) {\\n                m[mostFrequent] -= 1;\\n                pq.push(make_pair(m[mostFrequent], mostFrequent));\\n            }\\n            if (m[nextFrequent] - 1 > 0) {\\n                m[nextFrequent] -= 1;\\n                pq.push(make_pair(m[nextFrequent], nextFrequent));\\n            }\\n        }\\n        \\n        if (pq.size()) {\\n            char lastChar = pq.top().second;\\n            if (m[lastChar] > 1) return \"\";\\n            else ans += lastChar;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 456020,
                "title": "python-heap-easy-to-understand-self-explanatory-code",
                "content": "The core idea is to alternatively popping out the most frequent letter.   \\nI use pre to store the most recent popped out item.   \\n\\n```python\\n\\nimport heapq\\nfrom collections import Counter\\nclass Solution:\\n    def reorganizeString(self, S: str) -> str:\\n        if S == \"\":\\n            return \"\" \\n        \\n        # create a counter \\n        d = collections.Counter(S)\\n        \\n        heap = []\\n        for key, value in d.items():\\n            heapq.heappush(heap,[-value,key])\\n        \\n        res = \"\"\\n        pre = heapq.heappop(heap)\\n        res+= pre[1]\\n\\n        while heap: \\n            curr = heapq.heappop(heap)\\n            res+=curr[1]\\n            \\n            pre[0]+=1\\n            if pre[0]<0:\\n                heapq.heappush(heap,pre)\\n            pre = curr \\n            \\n        if len(res)!=len(S):\\n            return \"\"\\n        else:\\n            return res\\n        \\n    \\n            \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\n\\nimport heapq\\nfrom collections import Counter\\nclass Solution:\\n    def reorganizeString(self, S: str) -> str:\\n        if S == \"\":\\n            return \"\" \\n        \\n        # create a counter \\n        d = collections.Counter(S)\\n        \\n        heap = []\\n        for key, value in d.items():\\n            heapq.heappush(heap,[-value,key])\\n        \\n        res = \"\"\\n        pre = heapq.heappop(heap)\\n        res+= pre[1]\\n\\n        while heap: \\n            curr = heapq.heappop(heap)\\n            res+=curr[1]\\n            \\n            pre[0]+=1\\n            if pre[0]<0:\\n                heapq.heappush(heap,pre)\\n            pre = curr \\n            \\n        if len(res)!=len(S):\\n            return \"\"\\n        else:\\n            return res\\n        \\n    \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 167278,
                "title": "c-fast-0ms-and-neat-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string S) {\\n        priority_queue<pair<int, char>> pq;\\n        int map[26] = { 0 };\\n        \\n        for (auto c : S) {\\n            if (++map[c-\\'a\\'] > (S.size() + 1)/2)\\n                return \"\";\\n        }\\n        \\n        for (int i = 0; i < 26; ++i) {\\n            if (map[i])\\n                pq.push({map[i], i + \\'a\\'});\\n        }\\n        \\n        string ans;\\n        while(!pq.empty()) {\\n            pair<int, char> p1, p2;\\n            p1 = pq.top(); pq.pop();\\n            ans.push_back(p1.second);\\n            if (!pq.empty()) {\\n                p2 = pq.top(); pq.pop();\\n                ans.push_back(p2.second);\\n                if (--p2.first)\\n                    pq.push(p2);\\n            }\\n            if (--p1.first)\\n                pq.push(p1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string S) {\\n        priority_queue<pair<int, char>> pq;\\n        int map[26] = { 0 };\\n        \\n        for (auto c : S) {\\n            if (++map[c-\\'a\\'] > (S.size() + 1)/2)\\n                return \"\";\\n        }\\n        \\n        for (int i = 0; i < 26; ++i) {\\n            if (map[i])\\n                pq.push({map[i], i + \\'a\\'});\\n        }\\n        \\n        string ans;\\n        while(!pq.empty()) {\\n            pair<int, char> p1, p2;\\n            p1 = pq.top(); pq.pop();\\n            ans.push_back(p1.second);\\n            if (!pq.empty()) {\\n                p2 = pq.top(); pq.pop();\\n                ans.push_back(p2.second);\\n                if (--p2.first)\\n                    pq.push(p2);\\n            }\\n            if (--p1.first)\\n                pq.push(p1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781167,
                "title": "python-fast-easy-heap-solution-with-explanation",
                "content": "* Using a Counter (hash) to get the occurence count of chars.\\n* Pushing them onto a min heap with negative counters ( done because python heapq module has min queue implementation)\\n* A small check to see if there is any character that occurs more than half the length of the string. Then we return \"\"\\nMore precisely:\\n\\t* \\tfor even strings length > len(S) // 2\\n\\t* \\tfor odd string length > len(S) // 2 + 1\\n\\t* \\tCan be clubbed together and written as >  (len(S) + 1) // 2\\n*  After that, initializing an array of the string length. And popping from the heap and filling in the chars at alternate indexes (even). When the iterator reaches the end we then move it to 1 and fill the rest of the indexes (odd).\\n```\\nclass Solution:\\n\\tdef reorganizeString(self, S: str) -> str:\\n        n, counter = len(S), Counter(S)\\n        pq = [(-count, char) for char, count in counter.items()]\\n        heapq.heapify(pq)\\n        maxOccur = -1 * pq[0][0]\\n        if maxOccur > (n + 1) // 2:\\n            return \"\"\\n        string = [\\'\\'] * n\\n        i = 0\\n        while pq:\\n            count, char = heapq.heappop(pq)\\n            count *= -1\\n            for j in range(count):\\n                string[i] = char\\n                i += 2\\n                if i >= n:\\n                    i = 1\\n        return \"\".join(string)\\n```\\nRuntime: 28 ms, faster than 92.81% of Python3 online submissions for Reorganize String.\\nMemory Usage: 13.8 MB, less than 80.31% of Python3 online submissions for Reorganize String.",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n\\tdef reorganizeString(self, S: str) -> str:\\n        n, counter = len(S), Counter(S)\\n        pq = [(-count, char) for char, count in counter.items()]\\n        heapq.heapify(pq)\\n        maxOccur = -1 * pq[0][0]\\n        if maxOccur > (n + 1) // 2:\\n            return \"\"\\n        string = [\\'\\'] * n\\n        i = 0\\n        while pq:\\n            count, char = heapq.heappop(pq)\\n            count *= -1\\n            for j in range(count):\\n                string[i] = char\\n                i += 2\\n                if i >= n:\\n                    i = 1\\n        return \"\".join(string)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948675,
                "title": "detailed-c-solution-o-n-without-heap-beats-100-in-time",
                "content": "Please **UPVOTE** if you like the solution\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Each element is placed at a minimum of 1 gap (Assume we are first filling the even positions, later you\\'ll understand why)\\n- If the most occuring element cannot be placed at 1 gap (While placing the elements at even position it exceeds the size of the string) then it is not possible to get the desired string\\n- If the task of placing the most occuring element at, at most 1 gap is fulfilled and:\\n-> we have reached the end of the string then : we can place the remaining elements in any order and no consecutive elemets will be the same\\n-> we did not reach the end of the string then: we can place the remaining elements continuing from where we left at 1 gap until we reach the end, then we fill the odd positions one by one.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a map of frequencies of all the characters in the string\\n- Find the maximum frequency and the maximum occuring character\\n- Place the maximum occuring element at even positions until the remaining frequency is exhausted\\n- if after placing at all even positions characters are remaining then it is certainly not possible to get the desired string\\n- iterate through the map to get the remaining characters, and first place them at even positions if left, then start placing them at odd positions by cycling the index back to 1 if it reaches the end\\n- There you have the resultant string\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n-> We are going to each index of the string exactly once so O(N)\\n-> The map would store at max 26 characters(a-z), so traversing it is as good as constant so O(26) \\n Worst case = O(26*N) ~ O(N)\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe are just using a map to store at most 26 characters so \\nWorst case= O(26)~O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int n=s.length();\\n\\n        unordered_map<int,int> mp;\\n        for(auto it: s) mp[it]++;\\n\\n        int maxFreq=0;\\n        char maxChar;\\n        for(auto it: mp){\\n            if(maxFreq<it.second){\\n                maxChar=it.first;\\n                maxFreq=it.second;\\n            }\\n        }\\n\\n        int ind;\\n        for(ind=0; ind<n; ind+=2){\\n            s[ind]=maxChar;\\n            maxFreq--;\\n            if(!maxFreq){\\n                mp.erase(maxChar);\\n                break;\\n            } \\n        }\\n\\n        if(maxFreq) return \"\";\\n\\n        for(auto it: mp){\\n            char currChar=it.first;\\n            int currFreq=it.second;\\n            while(currFreq){\\n                ind=ind+2>=n?1: ind+2;\\n                s[ind]=currChar;\\n                currFreq--;\\n            }\\n        }\\n\\n        return s;\\n    }\\n};\\n```\\n# Another Solution (You may skip):\\nNot Proud of this solution, this was what I instantly thought of\\n- Time Complexity: $$ O(n^2) $$\\n- Space Complexity: $$ O(1) $$\\n- Approach: If two consecutive characters are same, swap the second one with the first character which is not the same, then check for the next index, do the same thing on reverted string as it might fail if same characters are present at the end\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int n=s.length();\\n        if(n==1) return s;\\n        \\n        int i=0;\\n        int j=1;\\n        bool flag=false;\\n        while(j<n){\\n            if(s[i]==s[j]){\\n                i=j;\\n                while(j<n && s[i]==s[j]){\\n                    j++;\\n                }\\n                if(j==n){\\n                flag=true;\\n                continue;\\n                } \\n                swap(s[i],s[j]);\\n            }\\n            i++;\\n            j=i+1;\\n        }\\n        if(flag){\\n            reverse(s.begin(),s.end());\\n            //Same stuff that was done from line 7-24 except now if there are matching characters at the end return an empty string, I know i should and could have created a function\\n            i=0;\\n            j=i+1;\\n            while(j<n){\\n            if(s[i]==s[j]){\\n                i=j;\\n                while(s[i]==s[j]) j++;\\n                if(j==n){\\n            //The only different thing\\n                    return \"\";\\n                } \\n                swap(s[i],s[j]);\\n            }\\n            i++;\\n            j=i+1;\\n        }\\n        }\\n        return s;\\n    }\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/b9c016ac-7a65-4125-8794-b549cc188b26_1692772209.8380158.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int n=s.length();\\n\\n        unordered_map<int,int> mp;\\n        for(auto it: s) mp[it]++;\\n\\n        int maxFreq=0;\\n        char maxChar;\\n        for(auto it: mp){\\n            if(maxFreq<it.second){\\n                maxChar=it.first;\\n                maxFreq=it.second;\\n            }\\n        }\\n\\n        int ind;\\n        for(ind=0; ind<n; ind+=2){\\n            s[ind]=maxChar;\\n            maxFreq--;\\n            if(!maxFreq){\\n                mp.erase(maxChar);\\n                break;\\n            } \\n        }\\n\\n        if(maxFreq) return \"\";\\n\\n        for(auto it: mp){\\n            char currChar=it.first;\\n            int currFreq=it.second;\\n            while(currFreq){\\n                ind=ind+2>=n?1: ind+2;\\n                s[ind]=currChar;\\n                currFreq--;\\n            }\\n        }\\n\\n        return s;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int n=s.length();\\n        if(n==1) return s;\\n        \\n        int i=0;\\n        int j=1;\\n        bool flag=false;\\n        while(j<n){\\n            if(s[i]==s[j]){\\n                i=j;\\n                while(j<n && s[i]==s[j]){\\n                    j++;\\n                }\\n                if(j==n){\\n                flag=true;\\n                continue;\\n                } \\n                swap(s[i],s[j]);\\n            }\\n            i++;\\n            j=i+1;\\n        }\\n        if(flag){\\n            reverse(s.begin(),s.end());\\n            //Same stuff that was done from line 7-24 except now if there are matching characters at the end return an empty string, I know i should and could have created a function\\n            i=0;\\n            j=i+1;\\n            while(j<n){\\n            if(s[i]==s[j]){\\n                i=j;\\n                while(s[i]==s[j]) j++;\\n                if(j==n){\\n            //The only different thing\\n                    return \"\";\\n                } \\n                swap(s[i],s[j]);\\n            }\\n            i++;\\n            j=i+1;\\n        }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 488325,
                "title": "python-8-liner-memory-usage-less-than-100",
                "content": "```\\nclass Solution:\\n    def reorganizeString(self, S: str) -> str:\\n        counter = collections.Counter(S)\\n        i, res, n = 0, [None] * len(S), len(S)\\n        for k in sorted(counter, key = counter.get, reverse = True):\\n            if counter[k] > n // 2 + (n % 2): return \"\"\\n            for j in range(counter[k]):\\n                if i >= n: i = 1\\n                res[i] = k; i += 2\\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reorganizeString(self, S: str) -> str:\\n        counter = collections.Counter(S)\\n        i, res, n = 0, [None] * len(S), len(S)\\n        for k in sorted(counter, key = counter.get, reverse = True):\\n            if counter[k] > n // 2 + (n % 2): return \"\"\\n            for j in range(counter[k]):\\n                if i >= n: i = 1\\n                res[i] = k; i += 2\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414030,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public string ReorganizeString(string s) \\n    {\\n        var charFreq = new Dictionary<char, int>();\\n        foreach(var ch in s)\\n        {\\n            if(!charFreq.ContainsKey(ch)) \\n                charFreq[ch] = 0;\\n            charFreq[ch]++;\\n        }\\n        \\n        var list = charFreq.Select(x => new int[]{(int) x.Key, x.Value}).ToList();\\n        list.Sort((x, y) => -x[1].CompareTo(y[1]));\\n\\n        if (list[0][1] > (s.Length + 1) / 2) \\n            return \"\"; \\n    \\n        var result = new char[s.Length];\\n        int index = 0;\\n        foreach(var elem in list) \\n        {\\n            while (elem[1] > 0) \\n            {\\n                if (index >= result.Length) \\n                    index = 1;\\n                \\n                result[index] = (char) elem[0];\\n                index += 2;\\n                elem[1]--;\\n            }\\n        }\\n        \\n        return new String(result);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public string ReorganizeString(string s) \\n    {\\n        var charFreq = new Dictionary<char, int>();\\n        foreach(var ch in s)\\n        {\\n            if(!charFreq.ContainsKey(ch)) \\n                charFreq[ch] = 0;\\n            charFreq[ch]++;\\n        }\\n        \\n        var list = charFreq.Select(x => new int[]{(int) x.Key, x.Value}).ToList();\\n        list.Sort((x, y) => -x[1].CompareTo(y[1]));\\n\\n        if (list[0][1] > (s.Length + 1) / 2) \\n            return \"\"; \\n    \\n        var result = new char[s.Length];\\n        int index = 0;\\n        foreach(var elem in list) \\n        {\\n            while (elem[1] > 0) \\n            {\\n                if (index >= result.Length) \\n                    index = 1;\\n                \\n                result[index] = (char) elem[0];\\n                index += 2;\\n                elem[1]--;\\n            }\\n        }\\n        \\n        return new String(result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948056,
                "title": "python-java-c-simple-solution",
                "content": "# Announcement:\\n**Join the discord and don\\'t forget to Subscribe the youtube channel to access the premium content materials related to computer science and data science in the discord. (For Only first 10,000 Subscribers)**\\n\\n**Happy Learning,  Cheers Guys \\uD83D\\uDE0A**\\n# Video Solution \\n\\n# Search \\uD83D\\uDC49` Reorganize String By ErraK`\\n\\n# or \\n\\n# Click the Link in my Profile\\n\\n# An UPVOTE will be encouraging \\uD83D\\uDC4D\\n\\n```Python []\\nclass Solution:\\n    def reorganizeString(self, S):\\n        char_count = Counter(S)\\n        max_heap = [(-count, char) for char, count in char_count.items()]\\n        heapq.heapify(max_heap)\\n        result = []\\n        prev_count, prev_char = 0, \"\"\\n        while max_heap:\\n            count, char = heapq.heappop(max_heap)\\n            result.append(char)\\n            if prev_count < 0:\\n                heapq.heappush(max_heap, (prev_count, prev_char))\\n            prev_count, prev_char = count + 1, char\\n        return \"\".join(result) if len(result) == len(S) else \"\"\\n```\\n```Java []\\n\\nclass Solution {\\n    public String reorganizeString(String S) {\\n        Map<Character, Integer> charCount = new HashMap<>();\\n        for (char c : S.toCharArray()) {\\n            charCount.put(c, charCount.getOrDefault(c, 0) + 1);\\n        }\\n\\n        PriorityQueue<Character> maxHeap = new PriorityQueue<>((a, b) -> charCount.get(b) - charCount.get(a));\\n        maxHeap.addAll(charCount.keySet());\\n\\n        StringBuilder result = new StringBuilder();\\n        char prevChar = \\'\\\\0\\';\\n\\n        while (!maxHeap.isEmpty()) {\\n            char currentChar = maxHeap.poll();\\n            result.append(currentChar);\\n            charCount.put(currentChar, charCount.get(currentChar) - 1);\\n\\n            if (prevChar != \\'\\\\0\\' && charCount.get(prevChar) > 0) {\\n                maxHeap.offer(prevChar);\\n            }\\n\\n            prevChar = currentChar;\\n        }\\n\\n        return result.length() == S.length() ? result.toString() : \"\";\\n    }\\n}\\n\\n```\\n```C++ []\\n\\nclass Solution {\\npublic:\\n    string reorganizeString(string S) {\\n        unordered_map<char, int> charCount;\\n        for (char c : S) {\\n            charCount[c]++;\\n        }\\n\\n        auto comp = [](const pair<char, int>& a, const pair<char, int>& b) {\\n            return a.second < b.second;\\n        };\\n\\n        priority_queue<pair<char, int>, vector<pair<char, int>>, decltype(comp)> maxHeap(comp);\\n\\n        for (const auto& entry : charCount) {\\n            maxHeap.push(entry);\\n        }\\n\\n        string result = \"\";\\n        char prevChar = \\'\\\\0\\';\\n\\n        while (!maxHeap.empty()) {\\n            auto current = maxHeap.top();\\n            maxHeap.pop();\\n            result += current.first;\\n            charCount[current.first]--;\\n\\n            if (prevChar != \\'\\\\0\\' && charCount[prevChar] > 0) {\\n                maxHeap.push({prevChar, charCount[prevChar]});\\n            }\\n\\n            prevChar = current.first;\\n        }\\n\\n        return result.length() == S.length() ? result : \"\";\\n    }\\n};\\n\\n```\\n\\n\\n# An UPVOTE will be encouraging \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```Python []\\nclass Solution:\\n    def reorganizeString(self, S):\\n        char_count = Counter(S)\\n        max_heap = [(-count, char) for char, count in char_count.items()]\\n        heapq.heapify(max_heap)\\n        result = []\\n        prev_count, prev_char = 0, \"\"\\n        while max_heap:\\n            count, char = heapq.heappop(max_heap)\\n            result.append(char)\\n            if prev_count < 0:\\n                heapq.heappush(max_heap, (prev_count, prev_char))\\n            prev_count, prev_char = count + 1, char\\n        return \"\".join(result) if len(result) == len(S) else \"\"\\n```\n```Java []\\n\\nclass Solution {\\n    public String reorganizeString(String S) {\\n        Map<Character, Integer> charCount = new HashMap<>();\\n        for (char c : S.toCharArray()) {\\n            charCount.put(c, charCount.getOrDefault(c, 0) + 1);\\n        }\\n\\n        PriorityQueue<Character> maxHeap = new PriorityQueue<>((a, b) -> charCount.get(b) - charCount.get(a));\\n        maxHeap.addAll(charCount.keySet());\\n\\n        StringBuilder result = new StringBuilder();\\n        char prevChar = \\'\\\\0\\';\\n\\n        while (!maxHeap.isEmpty()) {\\n            char currentChar = maxHeap.poll();\\n            result.append(currentChar);\\n            charCount.put(currentChar, charCount.get(currentChar) - 1);\\n\\n            if (prevChar != \\'\\\\0\\' && charCount.get(prevChar) > 0) {\\n                maxHeap.offer(prevChar);\\n            }\\n\\n            prevChar = currentChar;\\n        }\\n\\n        return result.length() == S.length() ? result.toString() : \"\";\\n    }\\n}\\n\\n```\n```C++ []\\n\\nclass Solution {\\npublic:\\n    string reorganizeString(string S) {\\n        unordered_map<char, int> charCount;\\n        for (char c : S) {\\n            charCount[c]++;\\n        }\\n\\n        auto comp = [](const pair<char, int>& a, const pair<char, int>& b) {\\n            return a.second < b.second;\\n        };\\n\\n        priority_queue<pair<char, int>, vector<pair<char, int>>, decltype(comp)> maxHeap(comp);\\n\\n        for (const auto& entry : charCount) {\\n            maxHeap.push(entry);\\n        }\\n\\n        string result = \"\";\\n        char prevChar = \\'\\\\0\\';\\n\\n        while (!maxHeap.empty()) {\\n            auto current = maxHeap.top();\\n            maxHeap.pop();\\n            result += current.first;\\n            charCount[current.first]--;\\n\\n            if (prevChar != \\'\\\\0\\' && charCount[prevChar] > 0) {\\n                maxHeap.push({prevChar, charCount[prevChar]});\\n            }\\n\\n            prevChar = current.first;\\n        }\\n\\n        return result.length() == S.length() ? result : \"\";\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702366,
                "title": "c-0ms-faster-than-100-priority-queue-greedy-approach",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    string reorganizeString(string s) {\\n        \\n\\n        if(s.size() <= 1) return s;\\n\\n        unordered_map<char,int>mpp;\\n\\n        for(auto &it : s) mpp[it]++;\\n        \\n\\n        if(mpp.size()==1) return \"\";\\n\\n\\n        priority_queue<pair<int,char>>vp;\\n        string res;\\n\\n\\n        for(auto &it : mpp)  vp.push({it.second,it.first});\\n        \\n\\n          while(vp.top().first > 0)\\n        {\\n            pair<int,char> p = vp.top();\\n            vp.pop();\\n\\n            res.push_back(p.second);\\n            p.first--;\\n\\n            pair<int,char> p2 = vp.top();\\n            vp.pop();\\n\\n            if(p2.first > 0)\\n            {\\n                res.push_back(p2.second);\\n                p2.first--;\\n            }\\n\\n            vp.push(p);\\n            vp.push(p2);\\n        }\\n\\n        for(int i=0;i<res.size()-1;++i)\\n        {\\n            if(res[i]==res[i+1]) return \"\";\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    string reorganizeString(string s) {\\n        \\n\\n        if(s.size() <= 1) return s;\\n\\n        unordered_map<char,int>mpp;\\n\\n        for(auto &it : s) mpp[it]++;\\n        \\n\\n        if(mpp.size()==1) return \"\";\\n\\n\\n        priority_queue<pair<int,char>>vp;\\n        string res;\\n\\n\\n        for(auto &it : mpp)  vp.push({it.second,it.first});\\n        \\n\\n          while(vp.top().first > 0)\\n        {\\n            pair<int,char> p = vp.top();\\n            vp.pop();\\n\\n            res.push_back(p.second);\\n            p.first--;\\n\\n            pair<int,char> p2 = vp.top();\\n            vp.pop();\\n\\n            if(p2.first > 0)\\n            {\\n                res.push_back(p2.second);\\n                p2.first--;\\n            }\\n\\n            vp.push(p);\\n            vp.push(p2);\\n        }\\n\\n        for(int i=0;i<res.size()-1;++i)\\n        {\\n            if(res[i]==res[i+1]) return \"\";\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906480,
                "title": "clean-and-easy-to-understand-solution-in-java-with-priority-queue-and-map-with-good-explanition",
                "content": "I have used HashMap to create a frequency map and then put all the keys and frequency in priorityQueue with Pair class implement Comparable interface on it and make it a Max-Heap. Then to make a valid answer we need to put characters alternatively  to make it sure i have use one variable hold to hold the first variable which we have pull out from our heap and then using second variable create to add characters in StringBuilder sb then afteer one iteration  we have to add that hold variable in our priority queue and repeat the whole process For better understanding check the code and i have add a picture for better understanding if uh like it please upvote  and if i uh have some suggestions comment down . Thank you..!!! guys\\n![image](https://assets.leetcode.com/users/images/eb970676-4955-47f7-81ea-1af52546df9c_1648902290.1582646.png)\\ncess \\n\\n\\n```\\nclass Solution {\\n    static class Pair implements Comparable<Pair>{\\n        char ch;\\n        int freq;\\n        public Pair(char ch,int freq){\\n            this.ch=ch;\\n            this.freq=freq;\\n        }\\n        public int compareTo(Pair o){  \\n            return o.freq-this.freq;    \\n        }  \\n    }\\n    public String reorganizeString(String s) {\\n        HashMap<Character,Integer> map=new HashMap<>();\\n        //create Frequency map\\n        for(int i=0;i<s.length();i++){ \\n            char ch=s.charAt(i);\\n            int count = map.getOrDefault(ch, 0) + 1;\\n            // Impossible to form a solution if count is greater then half of the string length\\n            if (count > (s.length() + 1) / 2) return \"\";\\n            \\n            map.put(ch,map.getOrDefault(ch,0)+1);\\n        }\\n        PriorityQueue<Pair> pq=new PriorityQueue<>();\\n        //add to heap\\n        for(Character key:map.keySet()){\\n            pq.offer(new Pair(key,map.get(key)));\\n        }\\n        //create answer here\\n        StringBuilder sb=new StringBuilder();\\n        Pair hold=pq.poll();\\n        //need to add characters alternatively so we can make an valid answer\\n        sb.append(hold.ch);\\n        hold.freq--;\\n        while(!pq.isEmpty()){\\n            //create will add an character to sb\\n            Pair create=pq.poll();\\n            sb.append(create.ch);\\n            create.freq--;\\n            if(hold.freq>0){\\n                pq.offer(hold);\\n            }\\n            hold=create;\\n            //then we need to hold create variable for 1 itreation so to make a valid answer \\n        }\\n        return sb.toString();\\n    }\\n}****\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    static class Pair implements Comparable<Pair>{\\n        char ch;\\n        int freq;\\n        public Pair(char ch,int freq){\\n            this.ch=ch;\\n            this.freq=freq;\\n        }\\n        public int compareTo(Pair o){  \\n            return o.freq-this.freq;    \\n        }  \\n    }\\n    public String reorganizeString(String s) {\\n        HashMap<Character,Integer> map=new HashMap<>();\\n        //create Frequency map\\n        for(int i=0;i<s.length();i++){ \\n            char ch=s.charAt(i);\\n            int count = map.getOrDefault(ch, 0) + 1;\\n            // Impossible to form a solution if count is greater then half of the string length\\n            if (count > (s.length() + 1) / 2) return \"\";\\n            \\n            map.put(ch,map.getOrDefault(ch,0)+1);\\n        }\\n        PriorityQueue<Pair> pq=new PriorityQueue<>();\\n        //add to heap\\n        for(Character key:map.keySet()){\\n            pq.offer(new Pair(key,map.get(key)));\\n        }\\n        //create answer here\\n        StringBuilder sb=new StringBuilder();\\n        Pair hold=pq.poll();\\n        //need to add characters alternatively so we can make an valid answer\\n        sb.append(hold.ch);\\n        hold.freq--;\\n        while(!pq.isEmpty()){\\n            //create will add an character to sb\\n            Pair create=pq.poll();\\n            sb.append(create.ch);\\n            create.freq--;\\n            if(hold.freq>0){\\n                pq.offer(hold);\\n            }\\n            hold=create;\\n            //then we need to hold create variable for 1 itreation so to make a valid answer \\n        }\\n        return sb.toString();\\n    }\\n}****\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240598,
                "title": "java-solution-using-hashmap-and-heap",
                "content": "```\\nclass Solution {\\n    public String reorganizeString(String s) {\\n        HashMap<Character,Integer> map=new HashMap(); // to store the frequency of each element\\n        for(char c:s.toCharArray())\\n            map.put(c,map.getOrDefault(c,0)+1);\\n        PriorityQueue<Character> qq=new PriorityQueue((n1,n2) -> map.get(n2)-map.get(n1));\\n        qq.addAll(map.keySet()); // adding all characters to heap\\n        StringBuilder sb=new StringBuilder(); // create a new string\\n      while(qq.size()>1){\\n          char c1=qq.remove(); // remove the most frequent element\\n          char c2=qq.remove(); // remove the 2nd most frequent element\\n          sb.append(c1); // add to string\\n          sb.append(c2);\\n          map.put(c1,map.get(c1)-1); // decrease their values in the map\\n          map.put(c2,map.get(c2)-1);\\n          if(map.get(c1)>0) // if the frequency of the element is >0 then add it back in the heap\\n              qq.add(c1);\\n          if(map.get(c2)>0)\\n              qq.add(c2);\\n      }\\n        if(!qq.isEmpty()){ // if queue is not empty \\n            char w=qq.remove();\\n            if(map.get(w)>1) //if the frequency of character is >1 then the string can\\'t be arranged \\n                return \"\"; // so return empty string\\n                sb.append(w); // otherwise add it to the string\\n        }\\n        return sb.toString();\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public String reorganizeString(String s) {\\n        HashMap<Character,Integer> map=new HashMap(); // to store the frequency of each element\\n        for(char c:s.toCharArray())\\n            map.put(c,map.getOrDefault(c,0)+1);\\n        PriorityQueue<Character> qq=new PriorityQueue((n1,n2) -> map.get(n2)-map.get(n1));\\n        qq.addAll(map.keySet()); // adding all characters to heap\\n        StringBuilder sb=new StringBuilder(); // create a new string\\n      while(qq.size()>1){\\n          char c1=qq.remove(); // remove the most frequent element\\n          char c2=qq.remove(); // remove the 2nd most frequent element\\n          sb.append(c1); // add to string\\n          sb.append(c2);\\n          map.put(c1,map.get(c1)-1); // decrease their values in the map\\n          map.put(c2,map.get(c2)-1);\\n          if(map.get(c1)>0) // if the frequency of the element is >0 then add it back in the heap\\n              qq.add(c1);\\n          if(map.get(c2)>0)\\n              qq.add(c2);\\n      }\\n        if(!qq.isEmpty()){ // if queue is not empty \\n            char w=qq.remove();\\n            if(map.get(w)>1) //if the frequency of character is >1 then the string can\\'t be arranged \\n                return \"\"; // so return empty string\\n                sb.append(w); // otherwise add it to the string\\n        }\\n        return sb.toString();\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523338,
                "title": "95-speed-and-100-memory-python-with-counter-heap-and-explanation",
                "content": "## Motivation for this method\\nWhen I first saw this question, I find it difficult to generalise just by looking at it. So I start from looking at easy examples and the two example given in the question are very inspiring. From \\'aaab\\', we can notice the letter that occur the most number of times makes it impossible to rearrange in this case.\\n\\nFor a case that is build on this one e.g \\'aaaabbc\\'. For 4 \\'a\\'s we use 2 \\'b\\'s to form \\'abab\\'(\\'ab\\'*2) to  reduce this 3 letters problem to a 2 letters problem \\'aac\\'. So we are back in the easy case and this give us an idea to solve the problem by induction.\\n## General method\\nFor a given string, we can always rearrange it in the form \\'aaaabbbccd\\',i.e decending trend in the numebr of occurence. We want to use the letter with most occurence to remove the letter that has the second most occurence.  Do the same for the remaining string and continue this process until we are back to the simple case where we can determine the result easily.\\n\\nKeep in mind the \\'aaaabbbccd\\' structure. When we have removed all other letters, we are left with one letter. If the remaining occurence is one then we can put it at the very end e.g xxxxxxaba. If not(i.e more than one), then it is impossible to rearrange to the desired structure and return \\'\\'.\\n\\n### reason to use heap\\nOccurence suggest we need to count the number of occurence for each letter. Frequent removal of letter with high prioirity suggest priority queue as data structure and hence a heap in this case.\\n\\n### Pseudocode\\n\\'\\'\\'\\n\\n\\t1. Count the number of occurence for each letter\\n\\t2. Use this value to create a maxheap (Python heapq construct heap in O(n) time) \\n\\t3. While heap not empty: \\n\\t\\t\\tpop letter \\'l\\' and its number of  occurence n from the heap\\n\\t\\t\\tif heap empty:\\n\\t\\t\\t\\tif n != 1:\\n\\t\\t\\t\\t\\treturn \\'\\'\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tanswer += \\'l\\' \\n\\t\\t\\t\\t\\treturn  answer\\n\\t\\t\\tpop the next letter \\'h\\' and its number \\'m\\'\\n\\t\\t\\tconcatenate \\'lh\\'*m with the answer\\n\\t\\t\\tif n>m:\\n\\t\\t\\t\\tpush n-m number of letter \\'l\\' back into the heap\\n\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\'\\'\\'          \\n### Note and complexity discussion:\\n1. One might be worried when we push the remaining letter back into the heap it may still has the highest priority. This is why we have \\'lh\\' with the one that is going to be removed as the last making sure no matter what letter comes next we meet the condition.\\n2. One might also suggest wouldn\\'t it be faster if we use a minheap and remove from the smallest which saves the time O(logn) when pushing the remaining back into the heap. Consider \\'aaabbc\\' which using maxheap gives \\'ababac\\' but minheap gives \\'bcbaaa\\'. Probably notice that we always need to start with the letter with most occurence.\\n3. Complexity: The heap can be constructed within O(n) time, count can be done in O(n) time as well (if you dont like Counter, you can always use defaultdict incase you want to explain detail in your interview). The while loop depends on the number of letter and the push requires O(logn) time. Interestingly if n is the number of distinct letters, i.e each letter appear once then we dont need to push back and hence its still O(n) overall. I am not an expert in complexity and if anyone is interested in explaining that would be great.\\n\\n\\nThe python code is below and if you have any questions,clearification want me to make or any suggestion please write a comment. Apologies for the pseudocode if it is confusing, I am really not good at writing it and am still practising.\\n\\n\\'\\'\\'\\n\\n\\tfrom collections import Counter\\n\\tclass Solution:\\n\\t\\tdef reorganizeString(self, S: str) -> str:\\n\\t\\t\\tans = \\'\\'\\n\\t\\t\\t# count the occurence and create a list to heapify, default is minheap but we want maxheap so put a minus sign\\n\\t\\t\\tch = [(-value,key) for key,value in Counter(S).items()]\\n\\t\\t\\theapq.heapify(ch)\\n\\n\\n\\t\\t\\twhile ch:        \\n\\t\\t\\t\\t#pop the letter with the most occurence\\n\\t\\t\\t\\tn,cur = heapq.heappop(ch)\\n\\t\\t\\t\\tn = -n\\n\\n\\t\\t\\t\\t# if this letter is the only one left check \\n\\t\\t\\t\\tif not ch:\\n\\t\\t\\t\\t\\t# we can put it at the very end.\\n\\t\\t\\t\\t\\tif n == 1:\\n\\t\\t\\t\\t\\t\\tans += cur\\n\\t\\t\\t\\t\\t\\treturn ans\\n\\n\\t\\t\\t\\t\\t# we have more than one left impossible to avoid \\'xx\\' \\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\treturn \\'\\'\\n\\n\\t\\t\\t\\t# the letter with second most occurence, m less or equal to n\\n\\t\\t\\t\\tm,fill = heapq.heappop(ch)\\n\\t\\t\\t\\tm = -m\\n\\n\\t\\t\\t\\t# put one adjacent to a different one. Eg for letter \\'a\\', \\'b\\' and m = 2:  \\'ab\\'*m = \\'abab\\'\\n\\t\\t\\t\\tans += (cur+fill)*m\\n\\n\\t\\t\\t\\t# if they happen to have the same occurence, we dont need to do anything else\\n\\t\\t\\t\\t# if not, put the remaining back into the heap with whats left\\n\\t\\t\\t\\tif n>m:\\n\\t\\t\\t\\t\\theapq.heappush(ch,(-(n-m),cur))\\n\\n\\t\\t\\treturn ans\\n\\n\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "## Motivation for this method\\nWhen I first saw this question, I find it difficult to generalise just by looking at it. So I start from looking at easy examples and the two example given in the question are very inspiring. From \\'aaab\\', we can notice the letter that occur the most number of times makes it impossible to rearrange in this case.\\n\\nFor a case that is build on this one e.g \\'aaaabbc\\'. For 4 \\'a\\'s we use 2 \\'b\\'s to form \\'abab\\'(\\'ab\\'*2) to  reduce this 3 letters problem to a 2 letters problem \\'aac\\'. So we are back in the easy case and this give us an idea to solve the problem by induction.\\n## General method\\nFor a given string, we can always rearrange it in the form \\'aaaabbbccd\\',i.e decending trend in the numebr of occurence. We want to use the letter with most occurence to remove the letter that has the second most occurence.  Do the same for the remaining string and continue this process until we are back to the simple case where we can determine the result easily.\\n\\nKeep in mind the \\'aaaabbbccd\\' structure. When we have removed all other letters, we are left with one letter. If the remaining occurence is one then we can put it at the very end e.g xxxxxxaba. If not(i.e more than one), then it is impossible to rearrange to the desired structure and return \\'\\'.\\n\\n### reason to use heap\\nOccurence suggest we need to count the number of occurence for each letter. Frequent removal of letter with high prioirity suggest priority queue as data structure and hence a heap in this case.\\n\\n### Pseudocode\\n\\'\\'\\'\\n\\n\\t1. Count the number of occurence for each letter\\n\\t2. Use this value to create a maxheap (Python heapq construct heap in O(n) time) \\n\\t3. While heap not empty: \\n\\t\\t\\tpop letter \\'l\\' and its number of  occurence n from the heap\\n\\t\\t\\tif heap empty:\\n\\t\\t\\t\\tif n != 1:\\n\\t\\t\\t\\t\\treturn \\'\\'\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tanswer += \\'l\\' \\n\\t\\t\\t\\t\\treturn  answer\\n\\t\\t\\tpop the next letter \\'h\\' and its number \\'m\\'\\n\\t\\t\\tconcatenate \\'lh\\'*m with the answer\\n\\t\\t\\tif n>m:\\n\\t\\t\\t\\tpush n-m number of letter \\'l\\' back into the heap\\n\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\'\\'\\'          \\n### Note and complexity discussion:\\n1. One might be worried when we push the remaining letter back into the heap it may still has the highest priority. This is why we have \\'lh\\' with the one that is going to be removed as the last making sure no matter what letter comes next we meet the condition.\\n2. One might also suggest wouldn\\'t it be faster if we use a minheap and remove from the smallest which saves the time O(logn) when pushing the remaining back into the heap. Consider \\'aaabbc\\' which using maxheap gives \\'ababac\\' but minheap gives \\'bcbaaa\\'. Probably notice that we always need to start with the letter with most occurence.\\n3. Complexity: The heap can be constructed within O(n) time, count can be done in O(n) time as well (if you dont like Counter, you can always use defaultdict incase you want to explain detail in your interview). The while loop depends on the number of letter and the push requires O(logn) time. Interestingly if n is the number of distinct letters, i.e each letter appear once then we dont need to push back and hence its still O(n) overall. I am not an expert in complexity and if anyone is interested in explaining that would be great.\\n\\n\\nThe python code is below and if you have any questions,clearification want me to make or any suggestion please write a comment. Apologies for the pseudocode if it is confusing, I am really not good at writing it and am still practising.\\n\\n\\'\\'\\'\\n\\n\\tfrom collections import Counter\\n\\tclass Solution:\\n\\t\\tdef reorganizeString(self, S: str) -> str:\\n\\t\\t\\tans = \\'\\'\\n\\t\\t\\t# count the occurence and create a list to heapify, default is minheap but we want maxheap so put a minus sign\\n\\t\\t\\tch = [(-value,key) for key,value in Counter(S).items()]\\n\\t\\t\\theapq.heapify(ch)\\n\\n\\n\\t\\t\\twhile ch:        \\n\\t\\t\\t\\t#pop the letter with the most occurence\\n\\t\\t\\t\\tn,cur = heapq.heappop(ch)\\n\\t\\t\\t\\tn = -n\\n\\n\\t\\t\\t\\t# if this letter is the only one left check \\n\\t\\t\\t\\tif not ch:\\n\\t\\t\\t\\t\\t# we can put it at the very end.\\n\\t\\t\\t\\t\\tif n == 1:\\n\\t\\t\\t\\t\\t\\tans += cur\\n\\t\\t\\t\\t\\t\\treturn ans\\n\\n\\t\\t\\t\\t\\t# we have more than one left impossible to avoid \\'xx\\' \\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\treturn \\'\\'\\n\\n\\t\\t\\t\\t# the letter with second most occurence, m less or equal to n\\n\\t\\t\\t\\tm,fill = heapq.heappop(ch)\\n\\t\\t\\t\\tm = -m\\n\\n\\t\\t\\t\\t# put one adjacent to a different one. Eg for letter \\'a\\', \\'b\\' and m = 2:  \\'ab\\'*m = \\'abab\\'\\n\\t\\t\\t\\tans += (cur+fill)*m\\n\\n\\t\\t\\t\\t# if they happen to have the same occurence, we dont need to do anything else\\n\\t\\t\\t\\t# if not, put the remaining back into the heap with whats left\\n\\t\\t\\t\\tif n>m:\\n\\t\\t\\t\\t\\theapq.heappush(ch,(-(n-m),cur))\\n\\n\\t\\t\\treturn ans\\n\\n\\n\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 3576033,
                "title": "easy-java-solution-using-hashmap",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String reorganizeString(String s) {\\n        HashMap<Character, Integer> hm= new HashMap<>();\\n\\n        for(int i=0; i<s.length(); i++){\\n            hm.put(s.charAt(i), hm.getOrDefault(s.charAt(i), 0)+1);\\n        }\\n\\n        char maxFreqChar= \\'-\\';\\n        int maxFreq= 0;\\n        for(char c: hm.keySet()){\\n            if(hm.get(c) > maxFreq){\\n                maxFreq= hm.get(c);\\n                maxFreqChar= c;\\n            }\\n        }\\n\\n        if(maxFreq > (s.length()+1)/2){\\n            return \"\";\\n        }\\n\\n        char[] result= new char[s.length()];\\n        int index= 0;\\n\\n        for(int i=0; i<maxFreq; i++){\\n            result[index]= maxFreqChar;\\n            index+=2;\\n        }\\n\\n        hm.remove(maxFreqChar);\\n\\n        for(char c: hm.keySet()){\\n            if(index >= s.length()){\\n                index= 1;\\n            }\\n\\n\\n            for(int i=0; i<hm.get(c); i++){\\n                if(index >= s.length()){\\n                    index= 1;\\n                }\\n                result[index]= c;\\n                index+= 2;\\n            }\\n        }\\n\\n        return new String(result);\\n    }\\n}\\n```\\n![please-upvote.jpg](https://assets.leetcode.com/users/images/d637c8b9-ed7e-4aaa-aff4-a32305e2403b_1685377902.2776465.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public String reorganizeString(String s) {\\n        HashMap<Character, Integer> hm= new HashMap<>();\\n\\n        for(int i=0; i<s.length(); i++){\\n            hm.put(s.charAt(i), hm.getOrDefault(s.charAt(i), 0)+1);\\n        }\\n\\n        char maxFreqChar= \\'-\\';\\n        int maxFreq= 0;\\n        for(char c: hm.keySet()){\\n            if(hm.get(c) > maxFreq){\\n                maxFreq= hm.get(c);\\n                maxFreqChar= c;\\n            }\\n        }\\n\\n        if(maxFreq > (s.length()+1)/2){\\n            return \"\";\\n        }\\n\\n        char[] result= new char[s.length()];\\n        int index= 0;\\n\\n        for(int i=0; i<maxFreq; i++){\\n            result[index]= maxFreqChar;\\n            index+=2;\\n        }\\n\\n        hm.remove(maxFreqChar);\\n\\n        for(char c: hm.keySet()){\\n            if(index >= s.length()){\\n                index= 1;\\n            }\\n\\n\\n            for(int i=0; i<hm.get(c); i++){\\n                if(index >= s.length()){\\n                    index= 1;\\n                }\\n                result[index]= c;\\n                index+= 2;\\n            }\\n        }\\n\\n        return new String(result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447306,
                "title": "c-easy-solution-using-priority-queue",
                "content": "``Runtime: 0 ms, faster than 100.00% of C++ online submissions for Reorganize String.\\nMemory Usage: 6.3 MB, less than 34.32% of C++ online submissions for Reorganize String.`` \\n\\n````\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        string ans=\"\";\\n        unordered_map<char,int> mp;\\n        for(auto it:s)\\n        mp[it]++;\\n        priority_queue<pair<int,char>> pq;\\n        for(auto it: mp)\\n        pq.push({it.second,it.first});\\n        while(pq.size()>1)\\n        {  \\n            char ch1=pq.top().second;\\n            ans+=ch1;\\n            int val1=pq.top().first;\\n            pq.pop();\\n            int val2=0;\\n            char ch2= pq.top().second;\\n            if(!pq.empty())\\n            {\\n                ans+=ch2;\\n                val2=pq.top().first;\\n                pq.pop();\\n            }\\n            if(val1-1)\\n            {\\n                pq.push({val1-1,ch1});\\n            }\\n            if(val2-1)\\n            {\\n                pq.push({val2-1,ch2});\\n            }\\n        } \\n        if(pq.size()==0)\\n        return ans;\\n        int val=pq.top().first;\\n        if(val>=2)\\n        return \"\";\\n        else\\n        return ans+pq.top().second;\\n    }\\n};  \\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        string ans=\"\";\\n        unordered_map<char,int> mp;\\n        for(auto it:s)\\n        mp[it]++;\\n        priority_queue<pair<int,char>> pq;\\n        for(auto it: mp)\\n        pq.push({it.second,it.first}",
                "codeTag": "Java"
            },
            {
                "id": 1637030,
                "title": "c-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        int max = 0;\\n        char maxele =s[0];\\n        for(auto ele:mp){\\n            if(max< ele.second){\\n                max = ele.second;\\n                maxele =ele.first;\\n            }\\n        }\\n        if((max*2)-1> s.length()){\\n            return \"\";\\n        }\\n        int i = 0;\\n        while(mp[maxele]>0){\\n            s[i] = maxele;\\n            i+=2;\\n            mp[maxele]--;\\n        }\\n        for(auto ele:mp){\\n            while(ele.second > 0){\\n                if(i>=s.size())i=1;\\n                s[i] = ele.first;\\n                ele.second --;\\n                i+=2;\\n            }\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1287364,
                "title": "simple-code-with-full-explanation",
                "content": "# ***Basic Idea-->***\\nThe idea is to first store the frequencies of each character and then sort the characters according to the frequencies . After that we can simply create a character array and store the characters  in alternative positions. Then we can convert the character array into string and then return it.\\n\\n# Impleamentation****\\n**Method 1->** We can use hash map and then sort the hash map according to the values.  \\n**** Method 2->**** We can create frequency array of size 26 and store the frequencies of each character. After that we can add all those character frequency pairs whose frequency is greater than zero.\\n\\n\\n# **Well Commented Code**\\n\\nclass Solution {\\n    public String reorganizeString(String s) {\\n         int n= s.length();\\n        \\n         HashMap<Character,Integer>h= new HashMap<>(); \\n         \\n        //Storing frequencies of every Character using Hah Map\\n            for(int i=0;i<s.length();i++)\\n            {\\n                char a= s.charAt(i);\\n                h.put(a,h.getOrDefault(a,0)+1);\\n            }\\n        \\n        //Sorting characters according to frequencies\\n         List <Map.Entry<Character,Integer>>list= new LinkedList<Map.Entry<Character,Integer>>(h.entrySet());\\n        Collections.sort(list,new Comparator<Map.Entry<Character,Integer>>(){\\n            public int compare(Map.Entry<Character,Integer>o1, Map.Entry<Character,Integer>o2)\\n            {\\n                return (o2.getValue()).compareTo(o1.getValue());\\n            }\\n        });\\n       \\n        //Creating character array to store the same characters on non adjacent place\\n        char[]a= new char[n];\\n        \\n        int j=0,v=1,k;\\n       \\n        //k stores the values such that each character\\'s freequency should be less than the half of the total length of string \\n        if(n%2==0)\\n            k=n/2;\\n        else\\n            k=(n/2)+1;\\n        \\n        for(Map.Entry<Character,Integer>e:list)\\n        {\\n            char x= e.getKey();\\n            int y= e.getValue();\\n            \\n            //Condition that if frequency is more than half of the length of the string than return empty string.\\n            if(y>k)           \\n                return \"\";\\n            \\n            //loop to store the values in alternate positions.\\n            for(int i=0;i<y;i++)\\n            {\\n                a[j]=x;\\n                j+=2;\\n                if(j>=s.length())\\n                    j=v;\\n            }   \\n        }\\n        \\n        //Converting character array into string and returning\\n        return String.valueOf(a); \\n    }\\n}\\n\\n\\nif you like please upvote !!",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public String reorganizeString(String s) {\\n         int n= s.length();\\n        \\n         HashMap<Character,Integer>h= new HashMap<>(); \\n         \\n        //Storing frequencies of every Character using Hah Map\\n            for(int i=0;i<s.length();i++)\\n            {\\n                char a= s.charAt(i);\\n                h.put(a,h.getOrDefault(a,0)+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1205821,
                "title": "easy-to-understand-and-readable-with-without-sorting",
                "content": "**With Sorting:**\\n1.Build a hash based on character count, sort the hash from the largest count to smallest\\n2.A character count that is larger than half of the string length is considered invalid\\n3.Start filling characters to all the even indexs, i.e. 0, 2, 4,..., when we got to the end, start filling odd indexes i.e. 1,3,5,...\\n4.By filling the characters this way, we can make sure that no same characters will be adjacent to each other\\n```\\nvar reorganizeString = function(s) {\\n    const map = new Map();\\n\\t// 1. building map\\n    s.split(\\'\\').forEach((letter)=>{\\n        map.set(letter,map.get(letter)+1||1);\\n    })\\n\\t\\n\\t// 1. sorting the map based on the occurances in descending order.\\n    const sortedMap = new Map([...map.entries()].sort((a,b)=>b[1]-a[1]));\\n    \\n\\t// 2. getting the first value of sorted map and checking if greater than half of string length\\n    if(sortedMap.values().next().value > (s.length+1)/2) return \"\";\\n    \\n    const res=[];\\n    let index=0;\\n    \\n    for(let [key,value] of sortedMap){\\n        while(value--){\\n\\t\\t\\t// 5. if it reaches the end of string, start filling from odd position.\\n            if(index>=s.length) index=1;\\n\\t\\t\\t// 4. adding elements at even position.\\n            res[index]=key\\n            index+=2\\n        }\\n    }\\n\\t// converting array back to string\\n    return res.join(\\'\\');\\n};\\n```\\n**Without sorting:**\\n```\\nvar reorganizeString = function(s) {\\n    const map = new Map()\\n    let max=0;\\n    let maxChar=\\'\\'\\n    for(let c of s){\\n        map.set(c,map.get(c)+1||1)\\n\\t\\t\\n\\t\\t// instead of sorting as we did earlier, we are finding the maximum occuring char\\n        if(map.get(c)>max){\\n            max=map.get(c)\\n            maxChar=c\\n        }\\n    }\\n\\t// checking if max occurance is greater than half of string length(we used Math.ceil instead of s.length+1)\\n    if(max>Math.ceil(s.length/2))return \\'\\'\\n    \\n    let ind=0\\n    const res=[]\\n\\t// first placing the max occured charac in even pos.(0,2,4,...)\\n        while(max--){\\n            res[ind]=maxChar\\n            ind+=2\\n            map.set(maxChar,max)\\n        }\\n\\t\\t\\n\\t// then placing the remaining charac\\'s\\n    for(let [key,val] of map){\\n        while(val--){\\n            if(ind>=s.length)ind=1\\n            res[ind]=key\\n            ind+=2\\n        }\\n    }\\n    return res.join(\\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reorganizeString = function(s) {\\n    const map = new Map();\\n\\t// 1. building map\\n    s.split(\\'\\').forEach((letter)=>{\\n        map.set(letter,map.get(letter)+1||1);\\n    })\\n\\t\\n\\t// 1. sorting the map based on the occurances in descending order.\\n    const sortedMap = new Map([...map.entries()].sort((a,b)=>b[1]-a[1]));\\n    \\n\\t// 2. getting the first value of sorted map and checking if greater than half of string length\\n    if(sortedMap.values().next().value > (s.length+1)/2) return \"\";\\n    \\n    const res=[];\\n    let index=0;\\n    \\n    for(let [key,value] of sortedMap){\\n        while(value--){\\n\\t\\t\\t// 5. if it reaches the end of string, start filling from odd position.\\n            if(index>=s.length) index=1;\\n\\t\\t\\t// 4. adding elements at even position.\\n            res[index]=key\\n            index+=2\\n        }\\n    }\\n\\t// converting array back to string\\n    return res.join(\\'\\');\\n};\\n```\n```\\nvar reorganizeString = function(s) {\\n    const map = new Map()\\n    let max=0;\\n    let maxChar=\\'\\'\\n    for(let c of s){\\n        map.set(c,map.get(c)+1||1)\\n\\t\\t\\n\\t\\t// instead of sorting as we did earlier, we are finding the maximum occuring char\\n        if(map.get(c)>max){\\n            max=map.get(c)\\n            maxChar=c\\n        }\\n    }\\n\\t// checking if max occurance is greater than half of string length(we used Math.ceil instead of s.length+1)\\n    if(max>Math.ceil(s.length/2))return \\'\\'\\n    \\n    let ind=0\\n    const res=[]\\n\\t// first placing the max occured charac in even pos.(0,2,4,...)\\n        while(max--){\\n            res[ind]=maxChar\\n            ind+=2\\n            map.set(maxChar,max)\\n        }\\n\\t\\t\\n\\t// then placing the remaining charac\\'s\\n    for(let [key,val] of map){\\n        while(val--){\\n            if(ind>=s.length)ind=1\\n            res[ind]=key\\n            ind+=2\\n        }\\n    }\\n    return res.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 719106,
                "title": "js-javascript-maxheap-implementation-long-but-should-be-clear",
                "content": "```\\nfunction countChars(S) {\\n    const map = {};\\n    \\n    for(let i = 0; i < S.length; i++) {\\n        const char = S[i];\\n        map[char] = map[char] ? map[char] + 1 : 1;\\n    }\\n    \\n    return map;\\n}\\n// PriorityQueue impl MaxHeap\\nclass MaxHeap {\\n    constructor(data = []) {\\n        this._data = data;\\n        this._heapify();\\n    }\\n    _getLeftChildIndex(parentIndex) {\\n        return 2 * parentIndex + 1;\\n    }\\n    _getRightChildIndex(parentIndex) {\\n        return 2 * parentIndex + 2;\\n    }\\n    _hasLeftChild(parentIndex) {\\n        return this._getLeftChildIndex(parentIndex) < this._data.length;\\n    }\\n    _hasRightChild(parentIndex) {\\n        return this._getRightChildIndex(parentIndex) < this._data.length;\\n    }\\n    _hasParent(index) {\\n        return this._getParentIndex(index) >= 0;\\n    }\\n    _getParentIndex(index) {\\n        return Math.floor((index - 1) / 2);\\n    }\\n    _swap(from, to) {\\n        [this._data[from], this._data[to]] = [this._data[to], this._data[from]];\\n    }\\n    _swim(index) {\\n        let parentIndex = this._getParentIndex(index);\\n\\n        while(this._hasParent(index) && this._data[index][1] > this._data[parentIndex][1]) {\\n            this._swap(index, parentIndex);\\n            \\n            index = parentIndex;\\n            parentIndex = this._getParentIndex(index);\\n        }\\n    }\\n    add(val) {\\n        this._data.push(val);\\n        let lastIndex = this._data.length - 1;\\n        this._swim(lastIndex);\\n    }\\n    poll() {\\n        if (this.isEmpty()) {\\n            return null;\\n        }\\n        this._swap(0, this._data.length - 1);\\n        \\n        const deleted = this._data.pop();\\n        \\n        this._sink(0);\\n        \\n        return deleted;\\n    }\\n    _sink(parentIndex) {\\n        while(this._hasLeftChild(parentIndex)) {\\n            let biggestElementIndex = this._getLeftChildIndex(parentIndex);\\n            \\n            if (this._hasRightChild(parentIndex) && this._data[this._getLeftChildIndex(parentIndex)][1] < this._data[this._getRightChildIndex(parentIndex)][1]) {\\n                biggestElementIndex = this._getRightChildIndex(parentIndex);\\n            }\\n            \\n            if (this._data[parentIndex][1] >= this._data[biggestElementIndex][1]) {\\n                break;\\n            } else {\\n                this._swap(parentIndex, biggestElementIndex);\\n            }\\n            \\n            parentIndex = biggestElementIndex;\\n        }\\n    }\\n    _heapify() {\\n        for (let i = this._data.length - 1; i >= 0; i--) {\\n            this._sink(i);\\n        }\\n    }\\n    isEmpty() {\\n        return this._data.length === 0;\\n    }\\n    size() {\\n        return this._data.length;\\n    }\\n}\\n// R: O(NlogK)\\n// S: O(n)\\nvar reorganizeString = function(S) {\\n    if (S.length === 1) {\\n        return S;\\n    }\\n    \\n    const map = countChars(S);\\n    // create Tuples from map\\n    const tupleCounts = Object.entries(map);\\n    // initialize maxHeap \\n    const maxHeap = new MaxHeap(tupleCounts);\\n    // resulting array, that will become string\\n    const result = [];\\n    // until one char gonna left in MaxHeap\\n    while(maxHeap.size() > 1) {\\n        // take tuple with maxCount in S\\n        let current = maxHeap.poll();\\n        // take tuple with next maxCount in S\\n        let next = maxHeap.poll();\\n        // push it to resulting array\\n        result.push(current[0]);\\n        result.push(next[0]);\\n        // decrement values as far as we\\'ve used them\\n        current[1]--;\\n        next[1]--;\\n        // if there are values left in tuple - push to maxHeap again\\n        if (current[1] > 0) {\\n            maxHeap.add(current);\\n        }\\n        if (next[1] > 0) {\\n            maxHeap.add(next);\\n        }\\n    }\\n    // if maxHeap is not Empty\\n    if (!maxHeap.isEmpty()) {\\n        const last = maxHeap.poll();\\n        // check if last char count is bigger then 1 - it means chars cant be reorganized\\n        if (last[1] > 1) {\\n            return \\'\\'\\n        }\\n        result.push(last[0]);\\n    }\\n    \\n    return result.join(\\'\\');\\n};\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfunction countChars(S) {\\n    const map = {};\\n    \\n    for(let i = 0; i < S.length; i++) {\\n        const char = S[i];\\n        map[char] = map[char] ? map[char] + 1 : 1;\\n    }\\n    \\n    return map;\\n}\\n// PriorityQueue impl MaxHeap\\nclass MaxHeap {\\n    constructor(data = []) {\\n        this._data = data;\\n        this._heapify();\\n    }\\n    _getLeftChildIndex(parentIndex) {\\n        return 2 * parentIndex + 1;\\n    }\\n    _getRightChildIndex(parentIndex) {\\n        return 2 * parentIndex + 2;\\n    }\\n    _hasLeftChild(parentIndex) {\\n        return this._getLeftChildIndex(parentIndex) < this._data.length;\\n    }\\n    _hasRightChild(parentIndex) {\\n        return this._getRightChildIndex(parentIndex) < this._data.length;\\n    }\\n    _hasParent(index) {\\n        return this._getParentIndex(index) >= 0;\\n    }\\n    _getParentIndex(index) {\\n        return Math.floor((index - 1) / 2);\\n    }\\n    _swap(from, to) {\\n        [this._data[from], this._data[to]] = [this._data[to], this._data[from]];\\n    }\\n    _swim(index) {\\n        let parentIndex = this._getParentIndex(index);\\n\\n        while(this._hasParent(index) && this._data[index][1] > this._data[parentIndex][1]) {\\n            this._swap(index, parentIndex);\\n            \\n            index = parentIndex;\\n            parentIndex = this._getParentIndex(index);\\n        }\\n    }\\n    add(val) {\\n        this._data.push(val);\\n        let lastIndex = this._data.length - 1;\\n        this._swim(lastIndex);\\n    }\\n    poll() {\\n        if (this.isEmpty()) {\\n            return null;\\n        }\\n        this._swap(0, this._data.length - 1);\\n        \\n        const deleted = this._data.pop();\\n        \\n        this._sink(0);\\n        \\n        return deleted;\\n    }\\n    _sink(parentIndex) {\\n        while(this._hasLeftChild(parentIndex)) {\\n            let biggestElementIndex = this._getLeftChildIndex(parentIndex);\\n            \\n            if (this._hasRightChild(parentIndex) && this._data[this._getLeftChildIndex(parentIndex)][1] < this._data[this._getRightChildIndex(parentIndex)][1]) {\\n                biggestElementIndex = this._getRightChildIndex(parentIndex);\\n            }\\n            \\n            if (this._data[parentIndex][1] >= this._data[biggestElementIndex][1]) {\\n                break;\\n            } else {\\n                this._swap(parentIndex, biggestElementIndex);\\n            }\\n            \\n            parentIndex = biggestElementIndex;\\n        }\\n    }\\n    _heapify() {\\n        for (let i = this._data.length - 1; i >= 0; i--) {\\n            this._sink(i);\\n        }\\n    }\\n    isEmpty() {\\n        return this._data.length === 0;\\n    }\\n    size() {\\n        return this._data.length;\\n    }\\n}\\n// R: O(NlogK)\\n// S: O(n)\\nvar reorganizeString = function(S) {\\n    if (S.length === 1) {\\n        return S;\\n    }\\n    \\n    const map = countChars(S);\\n    // create Tuples from map\\n    const tupleCounts = Object.entries(map);\\n    // initialize maxHeap \\n    const maxHeap = new MaxHeap(tupleCounts);\\n    // resulting array, that will become string\\n    const result = [];\\n    // until one char gonna left in MaxHeap\\n    while(maxHeap.size() > 1) {\\n        // take tuple with maxCount in S\\n        let current = maxHeap.poll();\\n        // take tuple with next maxCount in S\\n        let next = maxHeap.poll();\\n        // push it to resulting array\\n        result.push(current[0]);\\n        result.push(next[0]);\\n        // decrement values as far as we\\'ve used them\\n        current[1]--;\\n        next[1]--;\\n        // if there are values left in tuple - push to maxHeap again\\n        if (current[1] > 0) {\\n            maxHeap.add(current);\\n        }\\n        if (next[1] > 0) {\\n            maxHeap.add(next);\\n        }\\n    }\\n    // if maxHeap is not Empty\\n    if (!maxHeap.isEmpty()) {\\n        const last = maxHeap.poll();\\n        // check if last char count is bigger then 1 - it means chars cant be reorganized\\n        if (last[1] > 1) {\\n            return \\'\\'\\n        }\\n        result.push(last[0]);\\n    }\\n    \\n    return result.join(\\'\\');\\n};\\n\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 258654,
                "title": "60ms-javascript-solution-using-priority-queue",
                "content": "Fill the even indexes first then the odd indexes.\\n```\\nvar reorganizeString = function(S) {\\n  let dequeue = new PriorityQueue((a,b) => a.count > b.count)\\n  let map = {}\\n  S = S.split(\\'\\')\\n  S.forEach(char => {\\n    map[char] = map[char] ? map[char]+1 : 1\\n  })\\n  Object.keys(map).forEach(char => {\\n    dequeue.offer({\\n      char: char,\\n      count: map[char]\\n    })\\n  })\\n  const max = S.length % 2 ? (S.length+1)/2 : S.length/2\\n  if (dequeue.peek().count > max) return \\'\\'\\n  let item = {}\\n  for (let i = 0; i < S.length; i = i+2) {\\n    if (!item.count) item = dequeue.poll()\\n    S[i] = item.char\\n    item.count--\\n  }\\n  for (let i = 1; i < S.length; i = i+2) {\\n    if (!item.count) item = dequeue.poll()\\n    S[i] = item.char\\n    item.count--\\n  }\\n  return S.join(\\'\\')\\n}\\n```\\n\\nPriority queue:\\n```\\nclass PriorityQueue {\\n  constructor(compare = (a, b) => a < b) {\\n    this.compare = compare\\n    this.queue = []\\n  }\\n  offer(obj) {\\n    let start = 0, end = this.queue.length\\n    while (start < end) {\\n      let mid = Math.floor((start + end) / 2)\\n      if(this.compare(this.queue[mid], obj)) {\\n        start = mid + 1\\n      }\\n      else {\\n        end = mid\\n      }\\n    }\\n    this.queue.splice(start, 0, obj)\\n  }\\n  poll() {\\n    return this.queue.shift()\\n  }\\n  peek() {\\n    return this.queue.length ? this.queue[0] : undefined\\n  }\\n  clear() {\\n    this.queue = []\\n  }\\n  isEmpty() {\\n    return this.queue.length === 0\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar reorganizeString = function(S) {\\n  let dequeue = new PriorityQueue((a,b) => a.count > b.count)\\n  let map = {}\\n  S = S.split(\\'\\')\\n  S.forEach(char => {\\n    map[char] = map[char] ? map[char]+1 : 1\\n  })\\n  Object.keys(map).forEach(char => {\\n    dequeue.offer({\\n      char: char,\\n      count: map[char]\\n    })\\n  })\\n  const max = S.length % 2 ? (S.length+1)/2 : S.length/2\\n  if (dequeue.peek().count > max) return \\'\\'\\n  let item = {}\\n  for (let i = 0; i < S.length; i = i+2) {\\n    if (!item.count) item = dequeue.poll()\\n    S[i] = item.char\\n    item.count--\\n  }\\n  for (let i = 1; i < S.length; i = i+2) {\\n    if (!item.count) item = dequeue.poll()\\n    S[i] = item.char\\n    item.count--\\n  }\\n  return S.join(\\'\\')\\n}\\n```\n```\\nclass PriorityQueue {\\n  constructor(compare = (a, b) => a < b) {\\n    this.compare = compare\\n    this.queue = []\\n  }\\n  offer(obj) {\\n    let start = 0, end = this.queue.length\\n    while (start < end) {\\n      let mid = Math.floor((start + end) / 2)\\n      if(this.compare(this.queue[mid], obj)) {\\n        start = mid + 1\\n      }\\n      else {\\n        end = mid\\n      }\\n    }\\n    this.queue.splice(start, 0, obj)\\n  }\\n  poll() {\\n    return this.queue.shift()\\n  }\\n  peek() {\\n    return this.queue.length ? this.queue[0] : undefined\\n  }\\n  clear() {\\n    this.queue = []\\n  }\\n  isEmpty() {\\n    return this.queue.length === 0\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948797,
                "title": "c-apni-bhasha-mein-seedhi-baat-no-bakwaas-string-heap-interview-prep",
                "content": "# Intuition & Approach\\n- Explained in the code\\n\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n\\n       LOGIC\\n\\n    KARNA KYA HAIN\\u2753\\n    1. Koi string diya hain ab usme yeh note rakhna hain ki\\n    usme same chars side by side na ho.\\n    2. Agar aisa hain to naya string banao jisme side by side na ho.\\n\\n    INTUITION &APPROACH\\n    1. Most basic approach will be ki we will \"count\" each char \"frequency\"\\n    and then put distinct chars side by side.\\n\\n    2. Now there will also be a basic observation ki agar kisi \"char\"\\n    ki frequency pure \"string\" ki frequency ke \"half se jyada\" ho jaye  \\n    then it will be not possible for us to put distict chars side by side.\\n\\n    3. So count(char) > ceil(length / 2) will be directly discarded.\\n\\n    4. Now ab ho kya raha hain: -\\n        - We will create a vector which will store \"frequency\" of chars in\\n         the string.\\n        - We will create a priority_queue \"{max-heap}\" which will store the\\n         chars with max freq at the top and others simultaneously.\\n\\n        - Now we will pop out the top elem from heap and check \\n        the following cases :-\\n\\n        - if the result is \"empty\" or the \"last char of result\" is not\\n        matching with the popped out char.\\n        - If yes then we will append the char in result.And push the \\n        {freq--,char} back in heap.\\n         - else we will check if the \"heap is empty\"\\u2753 Agar aisa hua to \\n         matlab char khatam ho gaye aur ek case aisa fas gaya jahan same\\n        chars side by side aa gaye.\\n         - Nahin to we will pop out the second char and append it in \\n         the result.\\n        - We will push the {freq--,char} of second and first popped\\n    character back in heap.\\n\\n    5. Pure question mein jyada kuch khas nahin kar rahe bas \"heap\"\\n    ki help se we are able to sort the chars according to their frequency.\\n\\n//============================================================================================\\n\\n    string reorganizeString(string s)\\n    {\\n        vector<int> charCounts(26, 0);\\n        //Freq Storage of chars\\n        for (char c: s)\\n        {\\n            charCounts[c - \\'a\\'] = charCounts[c - \\'a\\'] + 1;\\n        }\\n        priority_queue<vector < int>> pq;\\n        for (int i = 0; i < 26; i++)\\n        {\\n            if (charCounts[i] > 0)\\n            {\\n                pq.push(vector < int>\\n                {\\n                    charCounts[i],\\n                    i + \\'a\\' });\\n            //Storing frequency and char in max heap\\n            }\\n        }\\n        string result;\\n        while (!pq.empty())\\n        {\\n            auto first = pq.top();\\n            pq.pop();\\n            if (result.empty() || first[1] != result.back())\\n            //Char not matching with previously appended character\\n            {\\n                result += char(first[1]);\\n                if (--first[0] > 0)\\n                {\\n            //If the freq has not become 0 then again push it in the heap\\n                    pq.push(first);\\n                }\\n            }\\n            else\\n            //If char was matching with previously appended char\\n            {\\n                if (pq.empty())\\n            //Koi char add karne ko hain hi nahin\\n                    return \"\";\\n                auto second = pq.top();\\n                pq.pop();\\n                result += char(second[1]);\\n                if (--second[0] > 0)\\n                    pq.push(second);\\n                pq.push(first);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$ size of max heap.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nIf you *like* \\uD83D\\uDC4D this solution do *upvote* \\u2B06\\uFE0F and if there is any *improvement or suggestion* do mention it in the *comment* section \\uD83D\\uDE0A.\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/1b604300-df68-46aa-a267-71f38463bb89_1684820402.7869222.jpeg\" width=\\'350\\' alt=\"Upvote Image\">\\n</p>",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Counting"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n\\n       LOGIC\\n\\n    KARNA KYA HAIN\\u2753\\n    1. Koi string diya hain ab usme yeh note rakhna hain ki\\n    usme same chars side by side na ho.\\n    2. Agar aisa hain to naya string banao jisme side by side na ho.\\n\\n    INTUITION &APPROACH\\n    1. Most basic approach will be ki we will \"count\" each char \"frequency\"\\n    and then put distinct chars side by side.\\n\\n    2. Now there will also be a basic observation ki agar kisi \"char\"\\n    ki frequency pure \"string\" ki frequency ke \"half se jyada\" ho jaye  \\n    then it will be not possible for us to put distict chars side by side.\\n\\n    3. So count(char) > ceil(length / 2) will be directly discarded.\\n\\n    4. Now ab ho kya raha hain: -\\n        - We will create a vector which will store \"frequency\" of chars in\\n         the string.\\n        - We will create a priority_queue \"{max-heap}\" which will store the\\n         chars with max freq at the top and others simultaneously.\\n\\n        - Now we will pop out the top elem from heap and check \\n        the following cases :-\\n\\n        - if the result is \"empty\" or the \"last char of result\" is not\\n        matching with the popped out char.\\n        - If yes then we will append the char in result.And push the \\n        {freq--,char} back in heap.\\n         - else we will check if the \"heap is empty\"\\u2753 Agar aisa hua to \\n         matlab char khatam ho gaye aur ek case aisa fas gaya jahan same\\n        chars side by side aa gaye.\\n         - Nahin to we will pop out the second char and append it in \\n         the result.\\n        - We will push the {freq--,char} of second and first popped\\n    character back in heap.\\n\\n    5. Pure question mein jyada kuch khas nahin kar rahe bas \"heap\"\\n    ki help se we are able to sort the chars according to their frequency.\\n\\n//============================================================================================\\n\\n    string reorganizeString(string s)\\n    {\\n        vector<int> charCounts(26, 0);\\n        //Freq Storage of chars\\n        for (char c: s)\\n        {\\n            charCounts[c - \\'a\\'] = charCounts[c - \\'a\\'] + 1;\\n        }\\n        priority_queue<vector < int>> pq;\\n        for (int i = 0; i < 26; i++)\\n        {\\n            if (charCounts[i] > 0)\\n            {\\n                pq.push(vector < int>\\n                {\\n                    charCounts[i],\\n                    i + \\'a\\' });\\n            //Storing frequency and char in max heap\\n            }\\n        }\\n        string result;\\n        while (!pq.empty())\\n        {\\n            auto first = pq.top();\\n            pq.pop();\\n            if (result.empty() || first[1] != result.back())\\n            //Char not matching with previously appended character\\n            {\\n                result += char(first[1]);\\n                if (--first[0] > 0)\\n                {\\n            //If the freq has not become 0 then again push it in the heap\\n                    pq.push(first);\\n                }\\n            }\\n            else\\n            //If char was matching with previously appended char\\n            {\\n                if (pq.empty())\\n            //Koi char add karne ko hain hi nahin\\n                    return \"\";\\n                auto second = pq.top();\\n                pq.pop();\\n                result += char(second[1]);\\n                if (--second[0] > 0)\\n                    pq.push(second);\\n                pq.push(first);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948224,
                "title": "beats-100-line-by-line-explanation-smartly-using-priority-queue",
                "content": "# **Intution:**\\nThe ultimate goal is to create a reorganized string where no two adjacent characters are the same, and it tries to achieve this by repeatedly selecting the two most frequent characters at each step. If such a reorganized string is not possible, it returns an empty string.\\n# Here\\'s a breakdown of the logic behind the code\\n\\n**1.Counting Character Frequencies**: The code begins by creating an unordered map mp to store the frequencies of each character in the input string s.\\n```\\nunordered_map<char, int> mp;\\nfor (auto it : s) {\\n    mp[it]++;\\n}\\n```\\n**2.Priority Queue (Max Heap) for Frequencies:** The code then creates a max heap (priority queue) of pairs, where each pair holds the character frequency and the corresponding character. The purpose of using a max heap is to efficiently process the characters in decreasing order of their frequencies.\\n```\\npriority_queue<pair<int, char>> max_heap;\\nfor (auto &[ch, freq] : mp) {\\n    max_heap.push({freq, ch});\\n}\\n\\n```\\n**3.Building the Reorganized String:** The main part of the logic lies in the loop that rearranges the characters to satisfy the given conditions.\\n\\n- The loop continues as long as there are at least two characters with non-zero frequencies in the max heap.\\n- In each iteration of the loop, it extracts the characters with the two highest frequencies from the max heap (top two elements).\\n- It appends these two characters to the answer string ans and decrements their frequencies by 1.\\n- If the frequency of a character after decrementing is still greater than 0, it\\'s pushed back into the max heap.\\n ```\\nwhile (max_heap.size() >= 2) {\\n    auto [freq1, str1] = max_heap.top();\\n    max_heap.pop();\\n    auto [freq2, str2] = max_heap.top();\\n    max_heap.pop();\\n    ans += str1;\\n    ans += str2;\\n    if (--freq1 > 0) max_heap.push({freq1, str1});\\n    if (--freq2 > 0) max_heap.push({freq2, str2});\\n}\\n\\n```\\n**4. Handling the Last Character (If Applicable):** After the loop, if there\\'s only one character left in the max heap, it handles that character by appending it to the answer string if its frequency is 1; otherwise, it returns an empty string.\\n```\\nif (!max_heap.empty()) {\\n    auto [freq, str] = max_heap.top();\\n    if (freq > 1) return ans = \"\";\\n    ans += str;\\n}\\n\\n```\\n**5.Returning the Result:** Finally, the function returns the reorganized string ans if a valid reorganization is possible, or an empty string if not.\\n# PLEASE UPVOTE ME\\uD83D\\uDE0A. I WILL BE HIGHLY OBLIGED\\uD83D\\uDE4F\\uD83C\\uDFFB.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        unordered_map<char,int>mp;\\n        for(auto it:s){\\n            mp[it]++;\\n        }\\n        priority_queue<pair<int,char>>max_heap;\\n        for(auto &[ch,freq]:mp){\\n            max_heap.push({freq,ch});\\n        }\\n        string ans;\\n        while(max_heap.size()>=2){\\n            auto [freq1,str1]=max_heap.top();\\n            max_heap.pop();\\n            auto [freq2,str2]=max_heap.top();\\n            max_heap.pop();\\n            ans+=str1;\\n            ans+=str2;\\n            if(--freq1>0) max_heap.push({freq1,str1});\\n            if(--freq2>0) max_heap.push({freq2,str2});\\n        }\\n        if(!max_heap.empty()){\\n            auto [freq,str]=max_heap.top();\\n            if(freq>1) return ans=\"\";\\n            ans+=str;\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```\\n# PLEASE UPVOTE ME\\uD83D\\uDE0A. I WILL BE HIGHLY OBLIGED.\\n![UPVOTE.png](https://assets.leetcode.com/users/images/234ee14d-39d7-4014-8429-0016260fd562_1692764226.7165859.png)\\n",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nunordered_map<char, int> mp;\\nfor (auto it : s) {\\n    mp[it]++;\\n}\\n```\n```\\npriority_queue<pair<int, char>> max_heap;\\nfor (auto &[ch, freq] : mp) {\\n    max_heap.push({freq, ch});\\n}\\n\\n```\n```\\nwhile (max_heap.size() >= 2) {\\n    auto [freq1, str1] = max_heap.top();\\n    max_heap.pop();\\n    auto [freq2, str2] = max_heap.top();\\n    max_heap.pop();\\n    ans += str1;\\n    ans += str2;\\n    if (--freq1 > 0) max_heap.push({freq1, str1});\\n    if (--freq2 > 0) max_heap.push({freq2, str2});\\n}\\n\\n```\n```\\nif (!max_heap.empty()) {\\n    auto [freq, str] = max_heap.top();\\n    if (freq > 1) return ans = \"\";\\n    ans += str;\\n}\\n\\n```\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        unordered_map<char,int>mp;\\n        for(auto it:s){\\n            mp[it]++;\\n        }\\n        priority_queue<pair<int,char>>max_heap;\\n        for(auto &[ch,freq]:mp){\\n            max_heap.push({freq,ch});\\n        }\\n        string ans;\\n        while(max_heap.size()>=2){\\n            auto [freq1,str1]=max_heap.top();\\n            max_heap.pop();\\n            auto [freq2,str2]=max_heap.top();\\n            max_heap.pop();\\n            ans+=str1;\\n            ans+=str2;\\n            if(--freq1>0) max_heap.push({freq1,str1});\\n            if(--freq2>0) max_heap.push({freq2,str2});\\n        }\\n        if(!max_heap.empty()){\\n            auto [freq,str]=max_heap.top();\\n            if(freq>1) return ans=\"\";\\n            ans+=str;\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154046,
                "title": "easy-commented-explanation-100-faster-priority-queue-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string S) {\\n        string res=\"\";\\n        unordered_map<char,int> mp;\\n        priority_queue<pair<int,char>>pq;\\n        for(auto s: S) mp[s]+=1; // count frequency\\n        for(auto m: mp) pq.push(make_pair(m.second,m.first)); // store in pair, frequencies with chars\\n        while(pq.size() > 1)\\n        {\\n            auto top1 = pq.top(); pq.pop(); // pick the top most frequency element and pop it\\n            auto top2 = pq.top(); pq.pop(); // pick the top most frequency element and pop it\\n            res += top1.second; // add both chars into our resultant string\\n            res += top2.second;\\n            top1.first -= 1; // reduce their frequencies by 1\\n            top2.first -= 1;\\n            if(top1.first > 0) pq.push(top1); // if their frequency is still positive push to the priority queue\\n            if(top2.first > 0) pq.push(top2);\\n        }\\n        if(!pq.empty())\\n        {\\n            if(pq.top().first > 1) return \"\"; // if the top chars frequency is still greater than 1, it\\'s impossible to create\\n            else res += pq.top().second; // else add to the resultant string\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string S) {\\n        string res=\"\";\\n        unordered_map<char,int> mp;\\n        priority_queue<pair<int,char>>pq;\\n        for(auto s: S) mp[s]+=1; // count frequency\\n        for(auto m: mp) pq.push(make_pair(m.second,m.first)); // store in pair, frequencies with chars\\n        while(pq.size() > 1)\\n        {\\n            auto top1 = pq.top(); pq.pop(); // pick the top most frequency element and pop it\\n            auto top2 = pq.top(); pq.pop(); // pick the top most frequency element and pop it\\n            res += top1.second; // add both chars into our resultant string\\n            res += top2.second;\\n            top1.first -= 1; // reduce their frequencies by 1\\n            top2.first -= 1;\\n            if(top1.first > 0) pq.push(top1); // if their frequency is still positive push to the priority queue\\n            if(top2.first > 0) pq.push(top2);\\n        }\\n        if(!pq.empty())\\n        {\\n            if(pq.top().first > 1) return \"\"; // if the top chars frequency is still greater than 1, it\\'s impossible to create\\n            else res += pq.top().second; // else add to the resultant string\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2228987,
                "title": "easy-100-using-maxheap-map-c",
                "content": "**Steps:**\\n1. Store frequencies of each character in unordered map. (unordered_map<char, int> )\\n2. Create a max heap where character with maximum frequency comes out first (pair<char, int>), and insert all the characters with their frequencies in maxHeap.\\n3. Create the string of size \\'s\\', and first fill all the even indices with the top element and then fill remaing indices.\\n\\n```\\nclass cmp{\\n    public:\\n    bool operator()(pair<char, int> &a, pair<char, int> &b){\\n        return a.second < b.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        priority_queue<pair<char, int>, vector<pair<char, int>>, cmp> maxHeap;\\n        \\n        unordered_map<char, int> freq;\\n        \\n        for(auto c : s){\\n            freq[c]++;\\n        }\\n        \\n        for(auto i : freq){\\n            maxHeap.push( {i.first, i.second} );\\n        }\\n        \\n        \\n        if( maxHeap.top().second > (s.size() + 1)/2)\\n            return \"\";\\n        \\n        string ans(s.size(), \\' \\');\\n        \\n        int i = 0, j = 1;\\n        while(maxHeap.size() > 0){\\n            pair<char, int> t = maxHeap.top();\\n            maxHeap.pop();\\n            \\n            int currFreq = t.second;\\n            \\n            for(; i < s.size() && currFreq; i += 2){\\n                ans[i] = t.first;\\n                currFreq--;\\n            }\\n            \\n            for(; j < s.size() && currFreq; j += 2){\\n                ans[j] = t.first;\\n                currFreq--;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass cmp{\\n    public:\\n    bool operator()(pair<char, int> &a, pair<char, int> &b){\\n        return a.second < b.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        priority_queue<pair<char, int>, vector<pair<char, int>>, cmp> maxHeap;\\n        \\n        unordered_map<char, int> freq;\\n        \\n        for(auto c : s){\\n            freq[c]++;\\n        }\\n        \\n        for(auto i : freq){\\n            maxHeap.push( {i.first, i.second} );\\n        }\\n        \\n        \\n        if( maxHeap.top().second > (s.size() + 1)/2)\\n            return \"\";\\n        \\n        string ans(s.size(), \\' \\');\\n        \\n        int i = 0, j = 1;\\n        while(maxHeap.size() > 0){\\n            pair<char, int> t = maxHeap.top();\\n            maxHeap.pop();\\n            \\n            int currFreq = t.second;\\n            \\n            for(; i < s.size() && currFreq; i += 2){\\n                ans[i] = t.first;\\n                currFreq--;\\n            }\\n            \\n            for(; j < s.size() && currFreq; j += 2){\\n                ans[j] = t.first;\\n                currFreq--;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970775,
                "title": "c-solution-priority-queue-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string S) {\\n        string res=\"\";\\n        unordered_map<char,int> map;\\n        priority_queue<pair<int,char>> pq;\\n        \\n        for(auto i : S){\\n            map[i]+=1;\\n        }\\n        \\n        for(auto i : map){\\n            pq.push(make_pair(i.second,i.first));\\n        }\\n        \\n        while(pq.size() > 1){\\n            auto top = pq.top();\\n            pq.pop();\\n            auto next = pq.top();\\n            pq.pop();\\n            \\n            res+=top.second;\\n            res+=next.second;\\n            \\n            top = make_pair(top.first-1,top.second);\\n            next = make_pair(next.first-1,next.second);\\n            \\n    \\n            if(top.first > 0){\\n                 pq.push(top);\\n            }\\n            if(next.first > 0){\\n                pq.push(next);\\n            }\\n            \\n        }\\n       if(!pq.empty()){\\n            char last = pq.top().second;\\n            if(pq.top().first > 1){\\n                return \"\";\\n            }\\n            res+=last;\\n        \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string S) {\\n        string res=\"\";\\n        unordered_map<char,int> map;\\n        priority_queue<pair<int,char>> pq;\\n        \\n        for(auto i : S){\\n            map[i]+=1;\\n        }\\n        \\n        for(auto i : map){\\n            pq.push(make_pair(i.second,i.first));\\n        }\\n        \\n        while(pq.size() > 1){\\n            auto top = pq.top();\\n            pq.pop();\\n            auto next = pq.top();\\n            pq.pop();\\n            \\n            res+=top.second;\\n            res+=next.second;\\n            \\n            top = make_pair(top.first-1,top.second);\\n            next = make_pair(next.first-1,next.second);\\n            \\n    \\n            if(top.first > 0){\\n                 pq.push(top);\\n            }\\n            if(next.first > 0){\\n                pq.push(next);\\n            }\\n            \\n        }\\n       if(!pq.empty()){\\n            char last = pq.top().second;\\n            if(pq.top().first > 1){\\n                return \"\";\\n            }\\n            res+=last;\\n        \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970413,
                "title": "my-java-solution-using-priorityqueue-and-taking-the-count",
                "content": "```\\nclass Solution {\\n    public String reorganizeString(String s) {\\n        // get the count of each count\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char ch: s.toCharArray())\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n        // use priority queue as maxHeap and use lambdas based on the count\\n        PriorityQueue<Character> maxHeap = new PriorityQueue<>((a, b) -> map.get(b) - map.get(a));\\n        maxHeap.addAll(map.keySet());\\n        \\n        // make the most frequent letter, then the next frequent letter and so on\\n        StringBuilder sb = new StringBuilder();\\n        while (maxHeap.size() > 1) {\\n            char current = maxHeap.remove(); // maximum frequent\\n            char next = maxHeap.remove(); // next max\\n            sb.append(current);\\n            sb.append(next); // alternatively adding\\n            map.put(current, map.get(current) - 1);\\n            map.put(next, map.get(next) - 1);\\n            // if still the count > 0, add the charcaters back to heap\\n            if (map.get(current) > 0)\\n                maxHeap.add(current);\\n            if (map.get(next) > 0)\\n                maxHeap.add(next);\\n        }\\n        if (!maxHeap.isEmpty()) {\\n            char last = maxHeap.remove();\\n            if (map.get(last) > 1)\\n                return \"\";\\n            sb.append(last);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public String reorganizeString(String s) {\\n        // get the count of each count\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char ch: s.toCharArray())\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n        // use priority queue as maxHeap and use lambdas based on the count\\n        PriorityQueue<Character> maxHeap = new PriorityQueue<>((a, b) -> map.get(b) - map.get(a));\\n        maxHeap.addAll(map.keySet());\\n        \\n        // make the most frequent letter, then the next frequent letter and so on\\n        StringBuilder sb = new StringBuilder();\\n        while (maxHeap.size() > 1) {\\n            char current = maxHeap.remove(); // maximum frequent\\n            char next = maxHeap.remove(); // next max\\n            sb.append(current);\\n            sb.append(next); // alternatively adding\\n            map.put(current, map.get(current) - 1);\\n            map.put(next, map.get(next) - 1);\\n            // if still the count > 0, add the charcaters back to heap\\n            if (map.get(current) > 0)\\n                maxHeap.add(current);\\n            if (map.get(next) > 0)\\n                maxHeap.add(next);\\n        }\\n        if (!maxHeap.isEmpty()) {\\n            char last = maxHeap.remove();\\n            if (map.get(last) > 1)\\n                return \"\";\\n            sb.append(last);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213359,
                "title": "java-o-n-solution-using-o-1-sort-instead-of-priorityqueue",
                "content": "Just put the most common character first and leave a space so that we can add other character between them later.\\n```\\nclass Solution {\\n    public String reorganizeString(String S) {\\n        int[][] counts = new int[26][2];\\n        for(int i = 0; i < 26; i++) counts[i][1] = i;\\n        for(int i = 0; i < S.length(); i++) counts[S.charAt(i) - \\'a\\'][0]++;\\n        Arrays.sort(counts, new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b){\\n                return b[0] - a[0];\\n            }\\n        });\\n        if(counts[0][0] > (S.length() + 1) / 2) return \"\";\\n        char[] result = new char[S.length()];\\n        int index = 0;\\n        for(int i = 0; i < 26; i++) {\\n            for(int j = 0; j < counts[i][0]; j++) {\\n                result[index] = (char)(counts[i][1] + \\'a\\');\\n                index += 2;\\n                if(index >= result.length) index = 1;\\n            }\\n        }\\n        return String.valueOf(result);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String reorganizeString(String S) {\\n        int[][] counts = new int[26][2];\\n        for(int i = 0; i < 26; i++) counts[i][1] = i;\\n        for(int i = 0; i < S.length(); i++) counts[S.charAt(i) - \\'a\\'][0]++;\\n        Arrays.sort(counts, new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b){\\n                return b[0] - a[0];\\n            }\\n        });\\n        if(counts[0][0] > (S.length() + 1) / 2) return \"\";\\n        char[] result = new char[S.length()];\\n        int index = 0;\\n        for(int i = 0; i < 26; i++) {\\n            for(int j = 0; j < counts[i][0]; j++) {\\n                result[index] = (char)(counts[i][1] + \\'a\\');\\n                index += 2;\\n                if(index >= result.length) index = 1;\\n            }\\n        }\\n        return String.valueOf(result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 118457,
                "title": "no-sort-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string S) {\\n        if(S.size()<2)\\n\\t{\\n\\t\\treturn S;\\n\\t}\\n\\n\\tvector<int> counts(26, 0);\\n\\tint maxC = 1;\\n\\tint maxI = 0;\\n\\tfor(auto ch : S)\\n\\t{\\n\\t\\tcounts[ch-\\'a\\']++;\\n\\t\\tif(counts[ch-\\'a\\'] > maxC)\\n\\t\\t{\\n\\t\\t\\tmaxC = counts[ch-\\'a\\'];\\n\\t\\t\\tmaxI = ch-\\'a\\';\\n\\t\\t}\\n\\t}\\n\\n\\tint n = S.size();\\n\\tif(maxC>(n+1)/2)\\n\\t{\\n\\t\\treturn \"\";\\n\\t}\\n\\n\\tint i = 0;\\n\\twhile(counts[maxI]--)\\n\\t{\\n\\t\\tS[i] = maxI + \\'a\\';\\n\\t\\ti+=2; \\n\\t}\\n\\n\\tfor(int j=0; j<26; j++)\\n\\t{\\n\\t\\twhile(counts[j]-->0)\\n\\t\\t{\\n\\t\\t\\tif(i>=n)\\n\\t\\t\\t{\\n\\t\\t\\t\\ti = 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tS[i] = j+\\'a\\';\\n\\t\\t\\ti+=2;\\n\\t\\t}\\n\\t}\\n\\n\\treturn S;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string S) {\\n        if(S.size()<2)\\n\\t{\\n\\t\\treturn S;\\n\\t}\\n\\n\\tvector<int> counts(26, 0);\\n\\tint maxC = 1;\\n\\tint maxI = 0;\\n\\tfor(auto ch : S)\\n\\t{\\n\\t\\tcounts[ch-\\'a\\']++;\\n\\t\\tif(counts[ch-\\'a\\'] > maxC)\\n\\t\\t{\\n\\t\\t\\tmaxC = counts[ch-\\'a\\'];\\n\\t\\t\\tmaxI = ch-\\'a\\';\\n\\t\\t}\\n\\t}\\n\\n\\tint n = S.size();\\n\\tif(maxC>(n+1)/2)\\n\\t{\\n\\t\\treturn \"\";\\n\\t}\\n\\n\\tint i = 0;\\n\\twhile(counts[maxI]--)\\n\\t{\\n\\t\\tS[i] = maxI + \\'a\\';\\n\\t\\ti+=2; \\n\\t}\\n\\n\\tfor(int j=0; j<26; j++)\\n\\t{\\n\\t\\twhile(counts[j]-->0)\\n\\t\\t{\\n\\t\\t\\tif(i>=n)\\n\\t\\t\\t{\\n\\t\\t\\t\\ti = 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tS[i] = j+\\'a\\';\\n\\t\\t\\ti+=2;\\n\\t\\t}\\n\\t}\\n\\n\\treturn S;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947788,
                "title": "c-simple-solution-2-approach-priority-queue",
                "content": "Method 1\\nTime Complexity -O(n)\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        map<char, int> mp;\\n        int maxi = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            mp[s[i]]++;\\n        }\\n        \\n        char c;\\n        for (auto i : mp) {\\n            if (i.second > maxi) {\\n                maxi = i.second;  // majority frequency\\n                c = i.first;   //  majority charactor \\n            }\\n        }\\n        \\n        if (maxi > (s.size() + 1) / 2) {\\n            return \"\";  // Not possible to reorganize.\\n        }\\n        string ans(s.size(), \\' \\'); // Create a string of size n\\n        int idx = 0;\\n        \\n        while (mp[c] > 0) {\\n            ans[idx] = c;  //majority element in ex- if a is majority and freq 4 then a_a_a_a_ like that\\n            idx += 2;\\n            mp[c]--; // Drecement the freq\\n        }\\n        \\n        for (auto i : mp) {\\n            while (i.second > 0) {\\n                if (idx >= s.size()) {\\n                    idx = 1; // now fill old position\\n                }\\n                ans[idx] = i.first;  //place it in string ans\\n                idx += 2;\\n                i.second--; // Drecement the freq\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n_*METHOD 2 Using Proirty_queue\\nPRIORITY_QUEUE*_\\n![image](https://assets.leetcode.com/users/images/0cfdaa0b-30ee-42a4-a5ee-fcf552a58c72_1692755709.9079585.png)\\n\\n![image](https://assets.leetcode.com/users/images/f7c17412-c679-4f07-a20e-23d1f047399f_1692753180.3832743.jpeg)\\n\\nTime complexity -O(n)\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        map<char, int> mp;\\n        int maxi = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            mp[s[i]]++;\\n            if (mp[s[i]] > maxi) {   \\n                maxi = mp[s[i]];\\n            }\\n        }\\n\\n        if (maxi > (s.size() + 1) / 2) {\\n            return \"\";\\n        }\\n\\n        priority_queue<pair<int, char>> pq; //max heap  \\n        for (auto i : mp) {\\n            pq.push({i.second, i.first}); //sort map using priority_Queue\\n        }\\n\\n        string result = \"\";\\n        while (!pq.empty()) {\\n            pair<int, char> x = pq.top();\\n            pq.pop();\\n            result += x.second;\\n\\n            if (!pq.empty()) {\\n                pair<int, char> sec = pq.top();\\n                pq.pop();\\n                result += sec.second;\\n\\n                if (x.first > 1) {\\n                    pq.push({x.first - 1, x.second});// frequency kaam kar \\n                }\\n                if (sec.first > 1) {\\n                    pq.push({sec.first - 1, sec.second});  // second charac frequency kaam karo \\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/04a12509-18c5-4b55-9dee-23c965c613a2_1692749981.3421.webp)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        map<char, int> mp;\\n        int maxi = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            mp[s[i]]++;\\n        }\\n        \\n        char c;\\n        for (auto i : mp) {\\n            if (i.second > maxi) {\\n                maxi = i.second;  // majority frequency\\n                c = i.first;   //  majority charactor \\n            }\\n        }\\n        \\n        if (maxi > (s.size() + 1) / 2) {\\n            return \"\";  // Not possible to reorganize.\\n        }\\n        string ans(s.size(), \\' \\'); // Create a string of size n\\n        int idx = 0;\\n        \\n        while (mp[c] > 0) {\\n            ans[idx] = c;  //majority element in ex- if a is majority and freq 4 then a_a_a_a_ like that\\n            idx += 2;\\n            mp[c]--; // Drecement the freq\\n        }\\n        \\n        for (auto i : mp) {\\n            while (i.second > 0) {\\n                if (idx >= s.size()) {\\n                    idx = 1; // now fill old position\\n                }\\n                ans[idx] = i.first;  //place it in string ans\\n                idx += 2;\\n                i.second--; // Drecement the freq\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        map<char, int> mp;\\n        int maxi = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            mp[s[i]]++;\\n            if (mp[s[i]] > maxi) {   \\n                maxi = mp[s[i]];\\n            }\\n        }\\n\\n        if (maxi > (s.size() + 1) / 2) {\\n            return \"\";\\n        }\\n\\n        priority_queue<pair<int, char>> pq; //max heap  \\n        for (auto i : mp) {\\n            pq.push({i.second, i.first}); //sort map using priority_Queue\\n        }\\n\\n        string result = \"\";\\n        while (!pq.empty()) {\\n            pair<int, char> x = pq.top();\\n            pq.pop();\\n            result += x.second;\\n\\n            if (!pq.empty()) {\\n                pair<int, char> sec = pq.top();\\n                pq.pop();\\n                result += sec.second;\\n\\n                if (x.first > 1) {\\n                    pq.push({x.first - 1, x.second});// frequency kaam kar \\n                }\\n                if (sec.first > 1) {\\n                    pq.push({sec.first - 1, sec.second});  // second charac frequency kaam karo \\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625848,
                "title": "c-beats-100-2-solutions-optimal-brute-force",
                "content": "# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// OPTIMAL SOLUTION (using map only)\\n/*\\nTC : O(n)\\nSC : O(1)\\n*/\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int n = s.length();\\n\\n        // create map to store characters and their frequencies\\n        int map[26] = {0}; // SC: O(1)\\n        for(int i = 0; i < n; i++) { // TC: O(n)\\n            map[s[i]-\\'a\\']++;\\n        }\\n\\n        int maxFreq = -1, maxFreqChar = \\'#\\';\\n        // finding \\'maxFreqChar\\' and \\'maxFreq\\'\\n        for(int i = 0; i < 26; i++) { // TC: O(1)\\n            if(map[i] > maxFreq) {\\n                maxFreq = map[i];\\n                maxFreqChar = i + \\'a\\';\\n            }\\n        }\\n\\n        // \\n        if(maxFreq > (n+1)/2)\\n            return \"\";\\n\\n        int index = 0;\\n        while(maxFreq > 0 && index < n) { // TC: O(n)\\n            s[index] = maxFreqChar;\\n            index += 2;\\n            maxFreq--;\\n        }\\n\\n        map[maxFreqChar - \\'a\\'] = 0;\\n\\n        for(int i = 0; i < 26; i++) {\\n            while(map[i] > 0) { // TC: O(n)\\n                index = (index >= n) ? 1 : index;\\n                s[index] = i + \\'a\\';\\n                index += 2;\\n                map[i]--;\\n            }\\n        }\\n\\n        return s;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity:$$O(n.logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// BRUTE FORCE (using Heap)\\n/*\\nTC : O(n.logn) // heap -> push(),pop() for n elements\\nSC : O(n) // heap\\n*/\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        string ans = \"\";\\n\\n        // create map to store characters and their frequencies\\n        unordered_map<char,int> map; // SC: O(1)\\n        \\n        int n = s.length();\\n        for(int i = 0; i < n; i++) { // TC: O(n)\\n            map[s[i]]++;\\n        }\\n\\n        priority_queue<pair<int,char>> pq; // max heap of pair type - {freq, char}\\n\\n        // put characters having (freq > 0) in max heap\\n        for(int i = \\'a\\'; i <= \\'z\\'; i++) { // TC: O(1)\\n            if(map[i]) {\\n                pq.push(make_pair(map[i], i));\\n                cout << pq.top().first << \" \" << pq.top().second << endl;\\n            }\\n        }\\n\\n        if(pq.top().first > (n+1)/2) // TC: O(logn)\\n            return ans; // ans is empty\\n        \\n        // add characters in \\'ans\\' string having highest freq which is not selected just before\\n        pair<int,char> prev = {-1,\\'#\\'};\\n        while(!pq.empty()) { // TC: O(n.logn)\\n            pair<int,char> curr = pq.top();\\n            pq.pop();\\n            ans = ans + curr.second;\\n            if(prev.first > 0) {\\n                pq.push(prev);\\n            }\\n            curr.first--;\\n            prev = curr;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// OPTIMAL SOLUTION (using map only)\\n/*\\nTC : O(n)\\nSC : O(1)\\n*/\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int n = s.length();\\n\\n        // create map to store characters and their frequencies\\n        int map[26] = {0}; // SC: O(1)\\n        for(int i = 0; i < n; i++) { // TC: O(n)\\n            map[s[i]-\\'a\\']++;\\n        }\\n\\n        int maxFreq = -1, maxFreqChar = \\'#\\';\\n        // finding \\'maxFreqChar\\' and \\'maxFreq\\'\\n        for(int i = 0; i < 26; i++) { // TC: O(1)\\n            if(map[i] > maxFreq) {\\n                maxFreq = map[i];\\n                maxFreqChar = i + \\'a\\';\\n            }\\n        }\\n\\n        // \\n        if(maxFreq > (n+1)/2)\\n            return \"\";\\n\\n        int index = 0;\\n        while(maxFreq > 0 && index < n) { // TC: O(n)\\n            s[index] = maxFreqChar;\\n            index += 2;\\n            maxFreq--;\\n        }\\n\\n        map[maxFreqChar - \\'a\\'] = 0;\\n\\n        for(int i = 0; i < 26; i++) {\\n            while(map[i] > 0) { // TC: O(n)\\n                index = (index >= n) ? 1 : index;\\n                s[index] = i + \\'a\\';\\n                index += 2;\\n                map[i]--;\\n            }\\n        }\\n\\n        return s;\\n    }\\n};\\n```\n```\\n// BRUTE FORCE (using Heap)\\n/*\\nTC : O(n.logn) // heap -> push(),pop() for n elements\\nSC : O(n) // heap\\n*/\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        string ans = \"\";\\n\\n        // create map to store characters and their frequencies\\n        unordered_map<char,int> map; // SC: O(1)\\n        \\n        int n = s.length();\\n        for(int i = 0; i < n; i++) { // TC: O(n)\\n            map[s[i]]++;\\n        }\\n\\n        priority_queue<pair<int,char>> pq; // max heap of pair type - {freq, char}\\n\\n        // put characters having (freq > 0) in max heap\\n        for(int i = \\'a\\'; i <= \\'z\\'; i++) { // TC: O(1)\\n            if(map[i]) {\\n                pq.push(make_pair(map[i], i));\\n                cout << pq.top().first << \" \" << pq.top().second << endl;\\n            }\\n        }\\n\\n        if(pq.top().first > (n+1)/2) // TC: O(logn)\\n            return ans; // ans is empty\\n        \\n        // add characters in \\'ans\\' string having highest freq which is not selected just before\\n        pair<int,char> prev = {-1,\\'#\\'};\\n        while(!pq.empty()) { // TC: O(n.logn)\\n            pair<int,char> curr = pq.top();\\n            pq.pop();\\n            ans = ans + curr.second;\\n            if(prev.first > 0) {\\n                pq.push(prev);\\n            }\\n            curr.first--;\\n            prev = curr;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1380597,
                "title": "c-greedy-priority-queue-with-comments",
                "content": "**Easy to Understand** \\n*Included Explanation in comments*    \\n    \\n\\t//Intution: We greedily organise the most frequent letter with the next frequent letter\\n    //Ex: aaaabbc\\n    //We organise a first with b in between a-s\\n    //return: ababaca\\n    \\n    string reorganizeString(string s) {\\n        \\n        //Unordered Map for couting the frequencies of the char\\n        unordered_map<char, int> umap;\\n        for(char i: s) umap[i]++;\\n        \\n        //MaxHeap for getting the most frequent letters\\n        priority_queue<pair<int,char>> maxHeap;\\n        \\n        for(auto it = umap.begin(); it != umap.end(); it++){\\n            if(it->second>0) maxHeap.push({it->second, it->first});\\n        }\\n        \\n        string ans;\\n        while(maxHeap.size() > 1){\\n            //Arranging the most frequent letter..\\n            char first = maxHeap.top().second;\\n            umap[first]--;\\n            maxHeap.pop();\\n            //..using the next most frequent letter\\n            char second = maxHeap.top().second;\\n            umap[second]--;\\n            maxHeap.pop();\\n            \\n            //Appending them to the list\\n            ans += first;\\n            ans+=second;\\n            \\n            //If the frequency after removing one element is greater than 0, we add it back to the heap\\n            if(umap[first]>0) maxHeap.push({umap[first], first});\\n            if(umap[second]>0) maxHeap.push({umap[second], second});\\n            \\n        }\\n        \\n        //If there\\'s one left out element\\n        if(!maxHeap.empty()){\\n            char leftOut = maxHeap.top().second;\\n            \\n            //If it is occuring just once, add it to the ans string\\n            if(umap[leftOut]==1) ans += leftOut;\\n            \\n            //if freq>1, that means we cannot reorganise the string, we return empty string\\n            else return \"\";\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "**Easy to Understand** \\n*Included Explanation in comments*    \\n    \\n\\t//Intution: We greedily organise the most frequent letter with the next frequent letter\\n    //Ex: aaaabbc\\n    //We organise a first with b in between a-s\\n    //return: ababaca\\n    \\n    string reorganizeString(string s) {\\n        \\n        //Unordered Map for couting the frequencies of the char\\n        unordered_map<char, int> umap;\\n        for(char i: s) umap[i]++;\\n        \\n        //MaxHeap for getting the most frequent letters\\n        priority_queue<pair<int,char>> maxHeap;\\n        \\n        for(auto it = umap.begin(); it != umap.end(); it++){\\n            if(it->second>0) maxHeap.push({it->second, it->first});\\n        }\\n        \\n        string ans;\\n        while(maxHeap.size() > 1){\\n            //Arranging the most frequent letter..\\n            char first = maxHeap.top().second;\\n            umap[first]--;\\n            maxHeap.pop();\\n            //..using the next most frequent letter\\n            char second = maxHeap.top().second;\\n            umap[second]--;\\n            maxHeap.pop();\\n            \\n            //Appending them to the list\\n            ans += first;\\n            ans+=second;\\n            \\n            //If the frequency after removing one element is greater than 0, we add it back to the heap\\n            if(umap[first]>0) maxHeap.push({umap[first], first});\\n            if(umap[second]>0) maxHeap.push({umap[second], second});\\n            \\n        }\\n        \\n        //If there\\'s one left out element\\n        if(!maxHeap.empty()){\\n            char leftOut = maxHeap.top().second;\\n            \\n            //If it is occuring just once, add it to the ans string\\n            if(umap[leftOut]==1) ans += leftOut;\\n            \\n            //if freq>1, that means we cannot reorganise the string, we return empty string\\n            else return \"\";\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n};",
                "codeTag": "C++"
            },
            {
                "id": 442993,
                "title": "python-greedy-solution-24ms-beat-98-17",
                "content": "Please see and vote for my solution for these similar problems.\\n[767. Reorganize String](https://leetcode.com/problems/reorganize-string/discuss/442993/Python-greedy-solution-(24ms-beat-98.17))\\n[621. Task Scheduler](https://leetcode.com/problems/task-scheduler/discuss/314168/Different-Python-greedy-solutions)\\n[358. Rearrange String k Distance Apart](https://leetcode.com/problems/rearrange-string-k-distance-apart/discuss/444186/Different-Python-Greedy-solutions)\\n\\nImagine that there are two columns needed to be filled: even-indexed and odd-indexed column,\\nfill the most common chars into the even-indexed column if possible,\\nfill the remaining chars into the even-indexed column, then odd-indexed column.\\n\\n```\\n    def reorganizeString(self, S: str) -> str:\\n        count = collections.Counter(S)\\n        c_max, f_max = count.most_common(1)[0]\\n        if 2 * f_max - 1 > len(S):\\n            return \\'\\'\\n        count.pop(c_max)\\n        res = len(S) * [\\'\\']\\n        res[:2*f_max:2] = f_max * [c_max]\\n        i = 2 * f_max\\n        for c in count:\\n            for _ in range(count[c]):\\n                if i >= len(S):\\n                    i = 1\\n                res[i] = c\\n                i += 2\\n        return \\'\\'.join(res)\\n```",
                "solutionTags": [],
                "code": "```\\n    def reorganizeString(self, S: str) -> str:\\n        count = collections.Counter(S)\\n        c_max, f_max = count.most_common(1)[0]\\n        if 2 * f_max - 1 > len(S):\\n            return \\'\\'\\n        count.pop(c_max)\\n        res = len(S) * [\\'\\']\\n        res[:2*f_max:2] = f_max * [c_max]\\n        i = 2 * f_max\\n        for c in count:\\n            for _ in range(count[c]):\\n                if i >= len(S):\\n                    i = 1\\n                res[i] = c\\n                i += 2\\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 274036,
                "title": "swift-solution-100-with-explanation",
                "content": "Create a dictionary (hashmap in Java) ```[Character: Int]``` to save the count of each character and find out the most frequent char at the same time. If any char has the frequency of more than half of the ```length+1```, we know that it\\'s impossible to completely separate that kind of char, thus return ```\"\"```.\\n\\nThen we put the most frequent char in the answer string. Start from index ```0```, then stride in a step of ```2```. \\n\\nRemove the key value pair of the most frequent char after that.\\n\\nLoop through the dictionary and put the rest of the chars into the answer array. We start from the index ```i``` we were left with and go with a step of 2. If index goes to the end, it means that the even indices are already fully occupied; we come back to index ```1``` (```0``` has already been occupied by the most frequent char) and start to fill odd indices of the answer array.\\n\\nFinally return ```String(answer array)```.\\n\\n```\\nclass Solution {\\n\\tfunc reorganizeString(_ S: String) -> String {\\n\\t\\t\\n\\t\\tvar dict: [Character: Int] = [:]\\n\\t\\tlet S = Array(S)\\n\\t\\tlet n = S.count\\n\\t\\t\\n\\t\\tvar maxFreq = 0\\n\\t\\tvar maxChar: Character = \" \"\\n\\t\\tfor c in S {\\n\\t\\t\\tdict[c, default: 0] += 1\\n\\t\\t\\tif dict[c]! > maxFreq {\\n\\t\\t\\t\\tmaxFreq = dict[c]!\\n\\t\\t\\t\\tmaxChar = c\\n\\t\\t\\t}\\n\\t\\t\\tguard dict[c]! <= (n + 1) / 2 else { return \"\" }\\n\\t\\t}\\n\\t\\t\\n\\t\\tvar ans: [Character] = Array(repeating: \" \", count: n)\\n\\t\\t\\n\\t\\t// Put the most frequent char into the ans array\\n\\t\\tvar i = 0\\n\\t\\tfor _ in 1...maxFreq {\\n\\t\\t\\tans[i] = maxChar\\n\\t\\t\\ti += 2\\n\\t\\t}\\n\\t\\tdict.removeValue(forKey: maxChar)\\n\\t\\tdict.forEach { (c, count) in\\n\\t\\t\\tfor _ in 1...count {\\n\\t\\t\\t\\t// if the current index >= n, return to index 1 (after the most frequent char)\\n\\t\\t\\t\\t// This will happen once and only once\\n\\t\\t\\t\\tif i >= n {\\n\\t\\t\\t\\t\\ti = 1\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tans[i] = c\\n\\t\\t\\t\\ti += 2\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn String(ans)\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```[Character: Int]```\n```length+1```\n```\"\"```\n```0```\n```2```\n```i```\n```1```\n```0```\n```String(answer array)```\n```\\nclass Solution {\\n\\tfunc reorganizeString(_ S: String) -> String {\\n\\t\\t\\n\\t\\tvar dict: [Character: Int] = [:]\\n\\t\\tlet S = Array(S)\\n\\t\\tlet n = S.count\\n\\t\\t\\n\\t\\tvar maxFreq = 0\\n\\t\\tvar maxChar: Character = \" \"\\n\\t\\tfor c in S {\\n\\t\\t\\tdict[c, default: 0] += 1\\n\\t\\t\\tif dict[c]! > maxFreq {\\n\\t\\t\\t\\tmaxFreq = dict[c]!\\n\\t\\t\\t\\tmaxChar = c\\n\\t\\t\\t}\\n\\t\\t\\tguard dict[c]! <= (n + 1) / 2 else { return \"\" }\\n\\t\\t}\\n\\t\\t\\n\\t\\tvar ans: [Character] = Array(repeating: \" \", count: n)\\n\\t\\t\\n\\t\\t// Put the most frequent char into the ans array\\n\\t\\tvar i = 0\\n\\t\\tfor _ in 1...maxFreq {\\n\\t\\t\\tans[i] = maxChar\\n\\t\\t\\ti += 2\\n\\t\\t}\\n\\t\\tdict.removeValue(forKey: maxChar)\\n\\t\\tdict.forEach { (c, count) in\\n\\t\\t\\tfor _ in 1...count {\\n\\t\\t\\t\\t// if the current index >= n, return to index 1 (after the most frequent char)\\n\\t\\t\\t\\t// This will happen once and only once\\n\\t\\t\\t\\tif i >= n {\\n\\t\\t\\t\\t\\ti = 1\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tans[i] = c\\n\\t\\t\\t\\ti += 2\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn String(ans)\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 258866,
                "title": "go-golang-0ms",
                "content": "```\\ntype bucket struct {\\n\\tc   byte\\n\\tnum int\\n}\\n\\ntype bucketSlice []bucket\\n\\nfunc (bs bucketSlice) Len() int           { return len(bs) }\\nfunc (bs bucketSlice) Less(i, j int) bool { return bs[i].num < bs[j].num }\\nfunc (bs bucketSlice) Swap(i, j int)      { bs[i], bs[j] = bs[j], bs[i] }\\n\\nfunc reorganizeString(S string) string {\\n\\tn := len(S)\\n\\tbs := make(bucketSlice, 26)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tb := S[i] - \\'a\\'\\n\\t\\tif bs[b].num == 0 {\\n\\t\\t\\tbs[b].c = S[i]\\n\\t\\t}\\n\\t\\tbs[b].num++\\n\\t}\\n\\tsort.Sort(sort.Reverse(bs))\\n\\tif bs[0].num > (n+1)/2 {\\n\\t\\treturn \"\"\\n\\t}\\n\\tres := make([]byte, n)\\n\\tj := 0\\n\\tfor _, bucket := range bs {\\n\\t\\tfor i := 0; i < bucket.num; i, j = i+1, j+2 {\\n\\t\\t\\tif j >= n {\\n\\t\\t\\t\\tj = 1\\n\\t\\t\\t}\\n\\t\\t\\tres[j] = bucket.c\\n\\t\\t}\\n\\t}\\n\\treturn string(res)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype bucket struct {\\n\\tc   byte\\n\\tnum int\\n}\\n\\ntype bucketSlice []bucket\\n\\nfunc (bs bucketSlice) Len() int           { return len(bs) }\\nfunc (bs bucketSlice) Less(i, j int) bool { return bs[i].num < bs[j].num }\\nfunc (bs bucketSlice) Swap(i, j int)      { bs[i], bs[j] = bs[j], bs[i] }\\n\\nfunc reorganizeString(S string) string {\\n\\tn := len(S)\\n\\tbs := make(bucketSlice, 26)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tb := S[i] - \\'a\\'\\n\\t\\tif bs[b].num == 0 {\\n\\t\\t\\tbs[b].c = S[i]\\n\\t\\t}\\n\\t\\tbs[b].num++\\n\\t}\\n\\tsort.Sort(sort.Reverse(bs))\\n\\tif bs[0].num > (n+1)/2 {\\n\\t\\treturn \"\"\\n\\t}\\n\\tres := make([]byte, n)\\n\\tj := 0\\n\\tfor _, bucket := range bs {\\n\\t\\tfor i := 0; i < bucket.num; i, j = i+1, j+2 {\\n\\t\\t\\tif j >= n {\\n\\t\\t\\t\\tj = 1\\n\\t\\t\\t}\\n\\t\\t\\tres[j] = bucket.c\\n\\t\\t}\\n\\t}\\n\\treturn string(res)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 113442,
                "title": "duplicate-question",
                "content": "Looks like this question is repeat of **[358. Rearrange String k Distance Apart](https://leetcode.com/problems/rearrange-string-k-distance-apart/description/)**. Even simpler as k is fixed as 2. \\n\\nSubmitted the same solution with k = 2 and it got accepted.\\n\\n<pre>\\npublic String rearrangeString(String s, int k) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        for(char c : s.toCharArray()){\\n            Integer cnt = map.get(c);\\n            if(cnt == null) cnt = 0;\\n            map.put(c, cnt+1);\\n        }\\n        Queue<Map.Entry<Character, Integer>> mapQueue = new PriorityQueue<>(new Comparator<Map.Entry<Character, Integer>>() {\\n            @Override\\n            public int compare(Map.Entry<Character, Integer> o1, Map.Entry<Character, Integer> o2) {\\n                return o2.getValue()-o1.getValue();\\n            }\\n        });\\n        mapQueue.addAll(map.entrySet());\\n        Queue<Map.Entry<Character, Integer>> queue = new LinkedList<>();\\n        StringBuilder sb = new StringBuilder();\\n        while(!mapQueue.isEmpty()){\\n            Map.Entry<Character, Integer> current = mapQueue.poll();\\n            sb.append(current.getKey());\\n            current.setValue(current.getValue()-1);\\n            queue.offer(current);\\n            if(queue.size() < k) continue;\\n            Map.Entry<Character, Integer> temp = queue.poll();\\n            if(temp.getValue() > 0) mapQueue.offer(temp);\\n        }\\n        return sb.toString().length() == s.length() ? sb.toString() : \"\";\\n    }\\n    public String reorganizeString(String S) {\\n        return rearrangeString(S, 2);\\n    }\\n</pre>",
                "solutionTags": [],
                "code": "Looks like this question is repeat of **[358. Rearrange String k Distance Apart](https://leetcode.com/problems/rearrange-string-k-distance-apart/description/)**. Even simpler as k is fixed as 2. \\n\\nSubmitted the same solution with k = 2 and it got accepted.\\n\\n<pre>\\npublic String rearrangeString(String s, int k) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        for(char c : s.toCharArray()){\\n            Integer cnt = map.get(c);\\n            if(cnt == null) cnt = 0;\\n            map.put(c, cnt+1);\\n        }\\n        Queue<Map.Entry<Character, Integer>> mapQueue = new PriorityQueue<>(new Comparator<Map.Entry<Character, Integer>>() {\\n            @Override\\n            public int compare(Map.Entry<Character, Integer> o1, Map.Entry<Character, Integer> o2) {\\n                return o2.getValue()-o1.getValue();\\n            }\\n        });\\n        mapQueue.addAll(map.entrySet());\\n        Queue<Map.Entry<Character, Integer>> queue = new LinkedList<>();\\n        StringBuilder sb = new StringBuilder();\\n        while(!mapQueue.isEmpty()){\\n            Map.Entry<Character, Integer> current = mapQueue.poll();\\n            sb.append(current.getKey());\\n            current.setValue(current.getValue()-1);\\n            queue.offer(current);\\n            if(queue.size() < k) continue;\\n            Map.Entry<Character, Integer> temp = queue.poll();\\n            if(temp.getValue() > 0) mapQueue.offer(temp);\\n        }\\n        return sb.toString().length() == s.length() ? sb.toString() : \"\";\\n    }\\n    public String reorganizeString(String S) {\\n        return rearrangeString(S, 2);\\n    }\\n</pre>",
                "codeTag": "Unknown"
            },
            {
                "id": 3948308,
                "title": "python-priority-queue-35ms-fastest-optimal-solution",
                "content": "# Python | Priority Queue | <35ms | Fastest | Optimal Solution\\n```\\nclass Solution:\\n    def reorganizeString(self, S):\\n        res, c = [], Counter(S)\\n        pq = [(-value,key) for key,value in c.items()]\\n        heapq.heapify(pq)\\n        p_a, p_b = 0, \\'\\'\\n        while pq:\\n            a, b = heapq.heappop(pq)\\n            res += [b]\\n            if p_a < 0:\\n                heapq.heappush(pq, (p_a, p_b))\\n            a += 1\\n            p_a, p_b = a, b\\n        res = \\'\\'.join(res)\\n        if len(res) != len(S): return \"\"\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def reorganizeString(self, S):\\n        res, c = [], Counter(S)\\n        pq = [(-value,key) for key,value in c.items()]\\n        heapq.heapify(pq)\\n        p_a, p_b = 0, \\'\\'\\n        while pq:\\n            a, b = heapq.heappop(pq)\\n            res += [b]\\n            if p_a < 0:\\n                heapq.heappush(pq, (p_a, p_b))\\n            a += 1\\n            p_a, p_b = a, b\\n        res = \\'\\'.join(res)\\n        if len(res) != len(S): return \"\"\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062154,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        unordered_map<char, int> mp;\\n        int mx=0;\\n        char ch;\\n        for(char c:s)\\n        {\\n            mp[c]++;\\n            if(mx<mp[c])\\n            {\\n                mx=mp[c];\\n                ch=c;\\n            }\\n        }\\n        int n=s.size();\\n        vector<char> v(n);\\n        int i=0;\\n        while(mx--)\\n        {\\n            if(i>=n)\\n            return \"\";\\n            v[i]=ch;\\n            i+=2;\\n        }\\n        for(auto it:mp)\\n        {\\n            if(it.first!=ch)\\n            {\\n                int k=it.second;\\n                while(k--)\\n                {\\n                    if(i>=n)\\n                    i=1;\\n                    v[i]=it.first;\\n                    i+=2;\\n                }\\n            }\\n        }\\n        string ans;\\n        for(char c:v)\\n        ans+=c;\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        unordered_map<char, int> mp;\\n        int mx=0;\\n        char ch;\\n        for(char c:s)\\n        {\\n            mp[c]++;\\n            if(mx<mp[c])\\n            {\\n                mx=mp[c];\\n                ch=c;\\n            }\\n        }\\n        int n=s.size();\\n        vector<char> v(n);\\n        int i=0;\\n        while(mx--)\\n        {\\n            if(i>=n)\\n            return \"\";\\n            v[i]=ch;\\n            i+=2;\\n        }\\n        for(auto it:mp)\\n        {\\n            if(it.first!=ch)\\n            {\\n                int k=it.second;\\n                while(k--)\\n                {\\n                    if(i>=n)\\n                    i=1;\\n                    v[i]=it.first;\\n                    i+=2;\\n                }\\n            }\\n        }\\n        string ans;\\n        for(char c:v)\\n        ans+=c;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779278,
                "title": "python-3-two-solutions-5-3-lines-counter-t-m-99-99",
                "content": "**1. Using a Counter:** Here\\'s the plan:\\n\\n* Rearrange the letters in s (using a ```Counter```) to a list so that common letters are grouped together and the groups are sorted by their lengths, descending. \\n* Check whether the count of the letter with the greatest count of chars is more than half the length of s. If so, there\\'s no solution and we are done.\\n*  Reorder the letters by doing the analogy of a riffle card shuffle. Return the ```join``` of the list.\\n\\n```\\nclass Solution:  #1\\n    def reorganizeString(self, s: str) -> str:\\n                                                              #  Ex: s = \\'bttbtbzzztd\\'\\n                                                              #\\n        n, c = len(s), Counter(s)                             #   c = {\\'t\\': 4, \\'b\\': 3, \\'z\\': 3, \\'d\\': 1}\\n                                                              # \\n        arr = sorted([ch for ch in c], key = lambda x: -c[x]) #   arr = [\\'t\\',\\'b\\',\\'z\\',\\'d\\']\\n \\n        if c[arr[0]] > (len(s)+1)//2: return \\'\\'               #   <-- no solution if and only if more than half (n even) or half+1 (n odd)\\n                                                              #       of the chars in s are the same letter.\\n        \\n        chars = list(chain(*[[ch]*c[ch] for ch in arr]))      #  chars = chain(*[[\\'t\\',\\'t\\',\\'t\\',\\'t\\'], [\\'b\\',\\'b\\',\\'b\\'], [\\'z\\',\\'z\\',\\'z\\'],[\\'d\\']])\\n                                                              #        = [\\'t\\',\\'t\\',\\'t\\',\\'t\\',\\'b\\',\\'b\\',\\'b\\',\\'z\\',\\'z\\',\\'z\\',\\'d\\']      \\n\\n        return \\'\\'.join([chars[(n+i)//2] if i%2 else           # return \\'\\'.join([\\'t\\',\\'b\\',\\'t\\',\\'z\\',\\'t\\',\\'z\\',\\'t\\',\\'z\\',\\'b\\',\\'d\\',\\'b\\']) = \"tbtztztzbdb\"\\n                        chars[    i//2] for i in range(n)])\\n```\\n[https://leetcode.com/submissions/detail/836866370/ ](http://)\\n\\n\\n**2. Not using a Counter:** Same plan as the first solution, but instead of using a ```Counter```, we sort s directly as a list. I was surprised this second solution\\'s best T/M of four runs was roughly as good as the first solution\\'s best T/M of four runs. \\n\\n```\\nclass Solution: #2\\n    def reorganizeString(self, s: str) -> str:\\n\\n        n, s = len(s), sorted(s, key = lambda x: (-s.count(x),x))  # sorting the chars in s directly (no Counter) by lambda key\\n\\n        if s.count(s[0]) > (n+1)//2: return \"\"                     # checking for no solution\\n\\n        return \\'\\'.join([s[(n+i)//2] if i%2 else                    # same as above\\n                        s[    i//2] for i in range(n)])\\n```\\n[https://leetcode.com/submissions/detail/836955435/](http://)\\n\\nI could be wrong, but I think both solutions are *O*(*nlogn*) / *O*(*nlogn*) because of the sorts. Maybe #1 is *O*(*n*) because its sort is on a set of 26.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Counter```\n```join```\n```\\nclass Solution:  #1\\n    def reorganizeString(self, s: str) -> str:\\n                                                              #  Ex: s = \\'bttbtbzzztd\\'\\n                                                              #\\n        n, c = len(s), Counter(s)                             #   c = {\\'t\\': 4, \\'b\\': 3, \\'z\\': 3, \\'d\\': 1}\\n                                                              # \\n        arr = sorted([ch for ch in c], key = lambda x: -c[x]) #   arr = [\\'t\\',\\'b\\',\\'z\\',\\'d\\']\\n \\n        if c[arr[0]] > (len(s)+1)//2: return \\'\\'               #   <-- no solution if and only if more than half (n even) or half+1 (n odd)\\n                                                              #       of the chars in s are the same letter.\\n        \\n        chars = list(chain(*[[ch]*c[ch] for ch in arr]))      #  chars = chain(*[[\\'t\\',\\'t\\',\\'t\\',\\'t\\'], [\\'b\\',\\'b\\',\\'b\\'], [\\'z\\',\\'z\\',\\'z\\'],[\\'d\\']])\\n                                                              #        = [\\'t\\',\\'t\\',\\'t\\',\\'t\\',\\'b\\',\\'b\\',\\'b\\',\\'z\\',\\'z\\',\\'z\\',\\'d\\']      \\n\\n        return \\'\\'.join([chars[(n+i)//2] if i%2 else           # return \\'\\'.join([\\'t\\',\\'b\\',\\'t\\',\\'z\\',\\'t\\',\\'z\\',\\'t\\',\\'z\\',\\'b\\',\\'d\\',\\'b\\']) = \"tbtztztzbdb\"\\n                        chars[    i//2] for i in range(n)])\\n```\n```Counter```\n```\\nclass Solution: #2\\n    def reorganizeString(self, s: str) -> str:\\n\\n        n, s = len(s), sorted(s, key = lambda x: (-s.count(x),x))  # sorting the chars in s directly (no Counter) by lambda key\\n\\n        if s.count(s[0]) > (n+1)//2: return \"\"                     # checking for no solution\\n\\n        return \\'\\'.join([s[(n+i)//2] if i%2 else                    # same as above\\n                        s[    i//2] for i in range(n)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099916,
                "title": "js-solution-o-n",
                "content": "All credit to fangbiyi for this amazing answer!\\n```\\nvar reorganizeString = function(S) {\\n\\tlet map = {};\\n\\n\\tfor (let char of S) map[char] = map[char] + 1 || 1;\\n\\n\\tlet max = 0;\\n\\tlet maxLetter;\\n\\n  for (let key in map) {\\n    if (map[key] > max) {\\n      max = map[key]; //Max occurence of char\\n      maxLetter = key; //Max char\\n    }\\n  }\\n  \\n  if (max > (S.length + 1) / 2) return \"\"; \\n\\n  let res = new Array(S.length);\\n\\n  let index = 0;\\n\\n//Embed maxLetter into res\\n  while (map[maxLetter] > 0) {\\n    res[index] = maxLetter;\\n    index += 2;\\n    map[maxLetter]--;\\n  }\\n   \\n  //Embed rest of characters into res\\n  for (let key in map) {\\n    while (map[key] > 0) {\\n      if (index >= res.length) index = 1;\\n      res[index] = key;\\n      index += 2;\\n      map[key]--\\n    }\\n  }\\n\\nreturn res.join(\\'\\');\\n\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "All credit to fangbiyi for this amazing answer!\\n```\\nvar reorganizeString = function(S) {\\n\\tlet map = {};\\n\\n\\tfor (let char of S) map[char] = map[char] + 1 || 1;\\n\\n\\tlet max = 0;\\n\\tlet maxLetter;\\n\\n  for (let key in map) {\\n    if (map[key] > max) {\\n      max = map[key]; //Max occurence of char\\n      maxLetter = key; //Max char\\n    }\\n  }\\n  \\n  if (max > (S.length + 1) / 2) return \"\"; \\n\\n  let res = new Array(S.length);\\n\\n  let index = 0;\\n\\n//Embed maxLetter into res\\n  while (map[maxLetter] > 0) {\\n    res[index] = maxLetter;\\n    index += 2;\\n    map[maxLetter]--;\\n  }\\n   \\n  //Embed rest of characters into res\\n  for (let key in map) {\\n    while (map[key] > 0) {\\n      if (index >= res.length) index = 1;\\n      res[index] = key;\\n      index += 2;\\n      map[key]--\\n    }\\n  }\\n\\nreturn res.join(\\'\\');\\n\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 872837,
                "title": "python-priority-queue",
                "content": "To solve this problem, we can first count up the frequencies of each character in `S`, storing them in a dictionary.  We then add all of the keys to a priority queue, where the priority is `-frequency` (as python uses a min-heap rather than a max-heap for their priority queue implementation).\\n\\nNow, we want to ensure that two adjacent characters do not match, and we also want to use the highest frequency characters first, so we don\\'t run out of room at the end.  Simply popping from the priority queue would put all same characters next to eachother such as \\n```\\naaabbc\\n```\\nWhat we want is to alternate between the two highest priority characters in the heap.  A clever way to do this is to pop off the highest priority character, and not re-adding it to the priority queue until the second highest priority character has also been popped.  This turns the above example into\\n```\\nababac\\n```\\n\\nThus, we have:\\n```\\nclass Solution(object):\\n    def reorganizeString(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        if not S:\\n            return \"\"\\n    \\n        # Get frequency of each letter\\n        freq = {}\\n        for c in S:\\n            if c in freq:\\n                freq[c] += 1\\n            else:\\n                freq[c] = 1\\n                \\n        # Add to heap (python is min heap)\\n        heap = []\\n        for c in freq:\\n            heapq.heappush(heap, (-freq[c], c))\\n        \\n        # Pop first element off, adding it to res\\n        res = \"\"\\n        prev = heapq.heappop(heap)\\n        res += prev[1]\\n        \\n        # To avoid chars being next to eachother, pop from heap,\\n        # and don\\'t readd that char to the heap until the next iteration\\n        while heap:\\n            curr = heapq.heappop(heap)\\n            res += curr[1]\\n            # Readd prev if it still has frequency left\\n            if prev[0] < -1:\\n                heapq.heappush(heap, (prev[0] + 1, prev[1]))\\n            prev = curr\\n        \\n        if len(res) != len(S):\\n            return \"\"\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\naaabbc\\n```\n```\\nababac\\n```\n```\\nclass Solution(object):\\n    def reorganizeString(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        if not S:\\n            return \"\"\\n    \\n        # Get frequency of each letter\\n        freq = {}\\n        for c in S:\\n            if c in freq:\\n                freq[c] += 1\\n            else:\\n                freq[c] = 1\\n                \\n        # Add to heap (python is min heap)\\n        heap = []\\n        for c in freq:\\n            heapq.heappush(heap, (-freq[c], c))\\n        \\n        # Pop first element off, adding it to res\\n        res = \"\"\\n        prev = heapq.heappop(heap)\\n        res += prev[1]\\n        \\n        # To avoid chars being next to eachother, pop from heap,\\n        # and don\\'t readd that char to the heap until the next iteration\\n        while heap:\\n            curr = heapq.heappop(heap)\\n            res += curr[1]\\n            # Readd prev if it still has frequency left\\n            if prev[0] < -1:\\n                heapq.heappush(heap, (prev[0] + 1, prev[1]))\\n            prev = curr\\n        \\n        if len(res) != len(S):\\n            return \"\"\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757253,
                "title": "java-simple-solution-maxheap-map",
                "content": "```\\nclass Solution {\\n    public String reorganizeString(String S) {\\n       Map<Character, Integer> map = new HashMap<>();\\n        \\n        for (char ch: S.toCharArray()) {\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n        }\\n        \\n        PriorityQueue<Map.Entry<Character, Integer>> maxHeap = new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());\\n        maxHeap.addAll(map.entrySet());\\n        \\n        Map.Entry<Character, Integer> previousEntry = null;\\n        StringBuilder sb = new StringBuilder(S.length());\\n        \\n        while (!maxHeap.isEmpty()) {\\n            Map.Entry<Character, Integer> currentEntry = maxHeap.poll();\\n            \\n            if (previousEntry != null && previousEntry.getValue() > 0) {\\n                maxHeap.offer(previousEntry);\\n            }\\n            \\n            sb.append(currentEntry.getKey());\\n            currentEntry.setValue(currentEntry.getValue() - 1);\\n            previousEntry = currentEntry;\\n        }\\n        \\n        return sb.toString().length() == S.length() ? sb.toString() : \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reorganizeString(String S) {\\n       Map<Character, Integer> map = new HashMap<>();\\n        \\n        for (char ch: S.toCharArray()) {\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n        }\\n        \\n        PriorityQueue<Map.Entry<Character, Integer>> maxHeap = new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());\\n        maxHeap.addAll(map.entrySet());\\n        \\n        Map.Entry<Character, Integer> previousEntry = null;\\n        StringBuilder sb = new StringBuilder(S.length());\\n        \\n        while (!maxHeap.isEmpty()) {\\n            Map.Entry<Character, Integer> currentEntry = maxHeap.poll();\\n            \\n            if (previousEntry != null && previousEntry.getValue() > 0) {\\n                maxHeap.offer(previousEntry);\\n            }\\n            \\n            sb.append(currentEntry.getKey());\\n            currentEntry.setValue(currentEntry.getValue() - 1);\\n            previousEntry = currentEntry;\\n        }\\n        \\n        return sb.toString().length() == S.length() ? sb.toString() : \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113426,
                "title": "a-few-solutions",
                "content": "Greedy algorithm.  Use a priority queue to cherry pick the most frequent characters of the input string `s` to be interleaved first when constructing the transformed string `t`.\\n\\n* **Note:** JS lacks a priority queue, so I implemented one: [heap.js](https://gist.github.com/claytonjwong/2bcf514e89f7d0950be362d2021969ff)\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun reorganizeString(s: String): String {\\n        var m = s.groupingBy{ it }.eachCount()\\n        var q = PriorityQueue<Pair<Int, Char>>(Comparator{ a, b -> a.first.compareTo(b.first) })\\n        for ((c, cnt) in m)\\n            q.add(Pair(-cnt, c))\\n        var t = mutableListOf<Char>()\\n        while (2 <= q.size) {\\n            var (cnt_a, a) = q.poll()\\n            var (cnt_b, b) = q.poll()\\n            t.add(a)\\n            t.add(b)\\n            if (cnt_a + 1 < 0) q.add(Pair(cnt_a + 1, a))\\n            if (cnt_b + 1 < 0) q.add(Pair(cnt_b + 1, b))\\n        }\\n        if (0 < q.size) {\\n            var (_, c) = q.poll()\\n            t.add(c)\\n        }\\n        return if (s.length == t.size) t.joinToString(\"\") else \"\"\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet heapkey = x => Array.isArray(x) ? x[0] : x;\\nlet heappush = (A, x, f = Math.max) => {\\n    let P = i => Math.floor((i - 1) / 2);  // parent\\n    A.push(x);\\n    let N = A.length,\\n        i = N - 1;\\n    while (0 < i && heapkey(A[i]) == f(heapkey(A[i]), heapkey(A[P(i)]))) {\\n        [A[i], A[P(i)]] = [A[P(i)], A[i]];\\n        i = P(i);\\n    }\\n};\\nlet heappop = (A, x, f = Math.max) => {\\n    let L = i => 2 * i + 1,  // children\\n        R = i => 2 * i + 2;\\n    let N = A.length,\\n        i = 0;\\n    let top = A[0];\\n    [A[0], A[N - 1]] = [A[N - 1], A[0]], A.pop(), --N;\\n    let ok = true;\\n    do {\\n        ok = true;\\n        let left = f == Math.min ? Infinity : -Infinity,\\n            right = left;\\n        if (L(i) < N && heapkey(A[i]) != f(heapkey(A[i]), heapkey(A[L(i)]))) ok = false, left  = heapkey(A[L(i)]);\\n        if (R(i) < N && heapkey(A[i]) != f(heapkey(A[i]), heapkey(A[R(i)]))) ok = false, right = heapkey(A[R(i)]);\\n        if (!ok) {\\n            let j = left == f(left, right) ? L(i) : R(i);\\n            [A[i], A[j]] = [A[j], A[i]];\\n            i = j;\\n        }\\n    } while (!ok);\\n    return top;\\n};\\nlet reorganizeString = (s, t = [], m = new Map(), A = []) => {\\n    s.split(\\'\\').forEach(c => m.set(c, 1 + (m.get(c) || 0)));\\n    [...m].forEach(([c, cnt]) => heappush(A, [cnt, c]));\\n    while (1 < A.length) {\\n        let [cnt_a, a] = heappop(A);\\n        let [cnt_b, b] = heappop(A);\\n        if (t.length)\\n            t.push(t[t.length - 1] == a ? b : a),\\n            t.push(t[t.length - 1] == b ? a : b);\\n        else\\n            t.push(a), t.push(b);\\n        if (--cnt_a) heappush(A, [cnt_a, a]);\\n        if (--cnt_b) heappush(A, [cnt_b, b]);\\n    }\\n    if (A.length) {\\n        let [_, a] = heappop(A);\\n        t.push(a);\\n    }\\n    return s.length == t.length ? t.join(\\'\\') : \\'\\';\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        t = []\\n        q = [(-cnt, c) for c, cnt in Counter(s).items()]; heapify(q)\\n        while 1 < len(q):\\n            cnt_a, a = heappop(q)\\n            cnt_b, b = heappop(q)\\n            t.append(a); cnt_a += 1\\n            t.append(b); cnt_b += 1\\n            if cnt_a: heappush(q, (cnt_a, a))\\n            if cnt_b: heappush(q, (cnt_b, b))\\n        if len(q):\\n            _, a = heappop(q)\\n            t.append(a)\\n        return \\'\\'.join(t) if len(s) == len(t) else \\'\\'\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<char, int>;\\n    using Pair = pair<char, int>;\\n    struct Cmp {\\n        bool operator()(const Pair& a, const Pair& b) const {\\n            return a.second < b.second;\\n        }\\n    };\\n    using Queue = priority_queue<Pair, vector<Pair>, Cmp>;\\n    string reorganizeString(string s, string t = {}, Map m = {}) {\\n        for (auto c: s)\\n            ++m[c];\\n        Queue q{ m.begin(), m.end() };\\n        while (1 < q.size()) {\\n            auto [a, cnt_a] = q.top(); q.pop();\\n            auto [b, cnt_b] = q.top(); q.pop();\\n            t.push_back(a); if (--cnt_a) q.push({ a, cnt_a });\\n            t.push_back(b); if (--cnt_b) q.push({ b, cnt_b });\\n        }\\n        if (!q.empty())\\n            t.push_back(q.top().first);\\n        return s.size() == t.size() ? t : \"\";\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun reorganizeString(s: String): String {\\n        var m = s.groupingBy{ it }.eachCount()\\n        var q = PriorityQueue<Pair<Int, Char>>(Comparator{ a, b -> a.first.compareTo(b.first) })\\n        for ((c, cnt) in m)\\n            q.add(Pair(-cnt, c))\\n        var t = mutableListOf<Char>()\\n        while (2 <= q.size) {\\n            var (cnt_a, a) = q.poll()\\n            var (cnt_b, b) = q.poll()\\n            t.add(a)\\n            t.add(b)\\n            if (cnt_a + 1 < 0) q.add(Pair(cnt_a + 1, a))\\n            if (cnt_b + 1 < 0) q.add(Pair(cnt_b + 1, b))\\n        }\\n        if (0 < q.size) {\\n            var (_, c) = q.poll()\\n            t.add(c)\\n        }\\n        return if (s.length == t.size) t.joinToString(\"\") else \"\"\\n    }\\n}\\n```\n```\\nlet heapkey = x => Array.isArray(x) ? x[0] : x;\\nlet heappush = (A, x, f = Math.max) => {\\n    let P = i => Math.floor((i - 1) / 2);  // parent\\n    A.push(x);\\n    let N = A.length,\\n        i = N - 1;\\n    while (0 < i && heapkey(A[i]) == f(heapkey(A[i]), heapkey(A[P(i)]))) {\\n        [A[i], A[P(i)]] = [A[P(i)], A[i]];\\n        i = P(i);\\n    }\\n};\\nlet heappop = (A, x, f = Math.max) => {\\n    let L = i => 2 * i + 1,  // children\\n        R = i => 2 * i + 2;\\n    let N = A.length,\\n        i = 0;\\n    let top = A[0];\\n    [A[0], A[N - 1]] = [A[N - 1], A[0]], A.pop(), --N;\\n    let ok = true;\\n    do {\\n        ok = true;\\n        let left = f == Math.min ? Infinity : -Infinity,\\n            right = left;\\n        if (L(i) < N && heapkey(A[i]) != f(heapkey(A[i]), heapkey(A[L(i)]))) ok = false, left  = heapkey(A[L(i)]);\\n        if (R(i) < N && heapkey(A[i]) != f(heapkey(A[i]), heapkey(A[R(i)]))) ok = false, right = heapkey(A[R(i)]);\\n        if (!ok) {\\n            let j = left == f(left, right) ? L(i) : R(i);\\n            [A[i], A[j]] = [A[j], A[i]];\\n            i = j;\\n        }\\n    } while (!ok);\\n    return top;\\n};\\nlet reorganizeString = (s, t = [], m = new Map(), A = []) => {\\n    s.split(\\'\\').forEach(c => m.set(c, 1 + (m.get(c) || 0)));\\n    [...m].forEach(([c, cnt]) => heappush(A, [cnt, c]));\\n    while (1 < A.length) {\\n        let [cnt_a, a] = heappop(A);\\n        let [cnt_b, b] = heappop(A);\\n        if (t.length)\\n            t.push(t[t.length - 1] == a ? b : a),\\n            t.push(t[t.length - 1] == b ? a : b);\\n        else\\n            t.push(a), t.push(b);\\n        if (--cnt_a) heappush(A, [cnt_a, a]);\\n        if (--cnt_b) heappush(A, [cnt_b, b]);\\n    }\\n    if (A.length) {\\n        let [_, a] = heappop(A);\\n        t.push(a);\\n    }\\n    return s.length == t.length ? t.join(\\'\\') : \\'\\';\\n};\\n```\n```\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        t = []\\n        q = [(-cnt, c) for c, cnt in Counter(s).items()]; heapify(q)\\n        while 1 < len(q):\\n            cnt_a, a = heappop(q)\\n            cnt_b, b = heappop(q)\\n            t.append(a); cnt_a += 1\\n            t.append(b); cnt_b += 1\\n            if cnt_a: heappush(q, (cnt_a, a))\\n            if cnt_b: heappush(q, (cnt_b, b))\\n        if len(q):\\n            _, a = heappop(q)\\n            t.append(a)\\n        return \\'\\'.join(t) if len(s) == len(t) else \\'\\'\\n```\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<char, int>;\\n    using Pair = pair<char, int>;\\n    struct Cmp {\\n        bool operator()(const Pair& a, const Pair& b) const {\\n            return a.second < b.second;\\n        }\\n    };\\n    using Queue = priority_queue<Pair, vector<Pair>, Cmp>;\\n    string reorganizeString(string s, string t = {}, Map m = {}) {\\n        for (auto c: s)\\n            ++m[c];\\n        Queue q{ m.begin(), m.end() };\\n        while (1 < q.size()) {\\n            auto [a, cnt_a] = q.top(); q.pop();\\n            auto [b, cnt_b] = q.top(); q.pop();\\n            t.push_back(a); if (--cnt_a) q.push({ a, cnt_a });\\n            t.push_back(b); if (--cnt_b) q.push({ b, cnt_b });\\n        }\\n        if (!q.empty())\\n            t.push_back(q.top().first);\\n        return s.size() == t.size() ? t : \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950309,
                "title": "beats-100-explanation-c-clean-code",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- At first I thought of the priority queue or Hash table.\\n- But in discussion section I found that it can be done without sorting.\\n- Now, jump to the logic part\\n- First, keep track of the character having **maximum frequency**.\\n- If **frequency of that char is greater than the half the size of the given string**, then it\\'s impossible.\\n- To organize the string so that no adjacent element would be same,\\n-  We need to understand that the char having maximum frequency should arrange in alternative fashion.(**simple arranging k elements in n space so that no adjacent are same**).\\n- After that the char having second largest frequency should be filled **if the resultant string size is still less than the given string**.\\n-------------------------\\n- Create a vector to store frequency of character\\n- Keep track of the char having max freq, and check base case(impossible to reorganize).\\n- Now, put the characters alternatively\\n- At last return answer.\\n---\\n# Complexity\\n- Time complexity: O(s.size())\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) : Because the vector of size 26 is constant.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n---\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        vector<int> cnt(26);\\n        int mostFreq =0, i=0;\\n\\n        for(char c: s){\\n            if(++cnt[c-\\'a\\'] > cnt[mostFreq]) mostFreq = (c-\\'a\\');\\n        }\\n        if(2*cnt[mostFreq]-1 > s.size()) return \"\";\\n\\n        while(cnt[mostFreq]){\\n            s[i] = (\\'a\\' + mostFreq);\\n            cnt[mostFreq]--;\\n            i+=2;\\n        }\\n\\n        for(int j=0; j<26; j++){\\n            while(cnt[j]){\\n                if(i >= s.size()) i=1;\\n                s[i] = (\\'a\\' + j);\\n                cnt[j]--;\\n                i+=2;\\n            }\\n        }\\n\\n        return s;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        vector<int> cnt(26);\\n        int mostFreq =0, i=0;\\n\\n        for(char c: s){\\n            if(++cnt[c-\\'a\\'] > cnt[mostFreq]) mostFreq = (c-\\'a\\');\\n        }\\n        if(2*cnt[mostFreq]-1 > s.size()) return \"\";\\n\\n        while(cnt[mostFreq]){\\n            s[i] = (\\'a\\' + mostFreq);\\n            cnt[mostFreq]--;\\n            i+=2;\\n        }\\n\\n        for(int j=0; j<26; j++){\\n            while(cnt[j]){\\n                if(i >= s.size()) i=1;\\n                s[i] = (\\'a\\' + j);\\n                cnt[j]--;\\n                i+=2;\\n            }\\n        }\\n\\n        return s;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949324,
                "title": "python-3-heap-counter-beats-99-27ms",
                "content": "```python3 []\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        maxHeap = [(-k, c) for c, k in Counter(s).items()]\\n        heapify(maxHeap)\\n\\n        prev, result = None, []\\n        while maxHeap:\\n            k, c = heappop(maxHeap)\\n            k += 1\\n            result.append(c)\\n            if prev and prev[0] < 0:\\n                heappush(maxHeap, prev)\\n            prev = (k, c)\\n            \\n        return \\'\\'.join(result) if len(s) == len(result) else \\'\\'\\n```\\n```python3 []\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        cnt = Counter(s)\\n        maxHeap = []\\n        for c, k in cnt.items():\\n            maxHeap.append((-k, c))\\n        heapify(maxHeap)\\n\\n        prev, result = None, []\\n        while maxHeap:\\n            k, c = heappop(maxHeap)\\n            k +=1\\n            result.append(c)\\n            if prev and prev[0] < 0:\\n                heappush(maxHeap, prev)\\n            prev = (k, c)\\n            \\n        return \\'\\'.join(result) if len(s) == len(result) else \\'\\'\\n```\\n![Screenshot 2023-08-23 at 12.25.58.png](https://assets.leetcode.com/users/images/7f5d7044-d806-4923-942b-e1c0cd977d9e_1692782807.501983.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        maxHeap = [(-k, c) for c, k in Counter(s).items()]\\n        heapify(maxHeap)\\n\\n        prev, result = None, []\\n        while maxHeap:\\n            k, c = heappop(maxHeap)\\n            k += 1\\n            result.append(c)\\n            if prev and prev[0] < 0:\\n                heappush(maxHeap, prev)\\n            prev = (k, c)\\n            \\n        return \\'\\'.join(result) if len(s) == len(result) else \\'\\'\\n```\n```python3 []\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        cnt = Counter(s)\\n        maxHeap = []\\n        for c, k in cnt.items():\\n            maxHeap.append((-k, c))\\n        heapify(maxHeap)\\n\\n        prev, result = None, []\\n        while maxHeap:\\n            k, c = heappop(maxHeap)\\n            k +=1\\n            result.append(c)\\n            if prev and prev[0] < 0:\\n                heappush(maxHeap, prev)\\n            prev = (k, c)\\n            \\n        return \\'\\'.join(result) if len(s) == len(result) else \\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948465,
                "title": "easy-and-understandable-solution-using-max-heap-priority-queue-and-map",
                "content": "# Approach\\nUsing priority queue and max heap\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    string reorganizeString(string s) \\n    {\\n        map<char, int> mp;\\n        string res = \"\";\\n        priority_queue<pair<int, char>> pq;\\n        for(auto it : s)    mp[it]++;\\n        for(auto S : mp)    pq.push({S.second, S.first});\\n        while(pq.size() > 1)\\n        {\\n            auto top1 = pq.top();\\n            pq.pop();\\n            auto top2 = pq.top();\\n            pq.pop();\\n\\n            res = res + top1.second;\\n            res = res + top2.second;\\n\\n            top1.first = top1.first - 1;\\n            top2.first = top2.first - 1;\\n\\n            if(top1.first > 0)  pq.push(top1);\\n            if(top2.first > 0)  pq.push(top2);\\n        }\\n        if(!pq.empty())\\n        {\\n            if(pq.top().first > 1)  res = \"\";\\n            else    res = res + pq.top().second;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string reorganizeString(string s) \\n    {\\n        map<char, int> mp;\\n        string res = \"\";\\n        priority_queue<pair<int, char>> pq;\\n        for(auto it : s)    mp[it]++;\\n        for(auto S : mp)    pq.push({S.second, S.first});\\n        while(pq.size() > 1)\\n        {\\n            auto top1 = pq.top();\\n            pq.pop();\\n            auto top2 = pq.top();\\n            pq.pop();\\n\\n            res = res + top1.second;\\n            res = res + top2.second;\\n\\n            top1.first = top1.first - 1;\\n            top2.first = top2.first - 1;\\n\\n            if(top1.first > 0)  pq.push(top1);\\n            if(top2.first > 0)  pq.push(top2);\\n        }\\n        if(!pq.empty())\\n        {\\n            if(pq.top().first > 1)  res = \"\";\\n            else    res = res + pq.top().second;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948313,
                "title": "c-fastest-3ms-easy-to-understand-optimal-solution",
                "content": "# C++ | Fastest | <3ms | Easy to Understand | Optimal Solution\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string S) {\\n\\tvector<int> cnt(26);\\n\\tint mostFreq = 0, i = 0;\\n\\n\\tfor(char c : S)\\n\\t\\tif(++cnt[c - \\'a\\'] > cnt[mostFreq])\\n\\t\\t\\tmostFreq = (c - \\'a\\');\\n\\n\\tif(2 * cnt[mostFreq] - 1 > S.size()) return \"\";\\n\\n\\twhile(cnt[mostFreq]) {\\n\\t\\tS[i] = (\\'a\\' + mostFreq);\\n\\t\\ti += 2;\\n\\t\\tcnt[mostFreq]--;\\n\\t}\\n\\n\\tfor(int j = 0; j < 26; j++) {\\n\\t\\twhile(cnt[j]) {\\n\\t\\t\\tif(i >= S.size()) i = 1;\\n\\t\\t\\tS[i] = (\\'a\\' + j);\\n\\t\\t\\tcnt[j]--;\\n\\t\\t\\ti += 2;\\n\\t\\t}\\n\\t}\\n\\n\\treturn S;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string S) {\\n\\tvector<int> cnt(26);\\n\\tint mostFreq = 0, i = 0;\\n\\n\\tfor(char c : S)\\n\\t\\tif(++cnt[c - \\'a\\'] > cnt[mostFreq])\\n\\t\\t\\tmostFreq = (c - \\'a\\');\\n\\n\\tif(2 * cnt[mostFreq] - 1 > S.size()) return \"\";\\n\\n\\twhile(cnt[mostFreq]) {\\n\\t\\tS[i] = (\\'a\\' + mostFreq);\\n\\t\\ti += 2;\\n\\t\\tcnt[mostFreq]--;\\n\\t}\\n\\n\\tfor(int j = 0; j < 26; j++) {\\n\\t\\twhile(cnt[j]) {\\n\\t\\t\\tif(i >= S.size()) i = 1;\\n\\t\\t\\tS[i] = (\\'a\\' + j);\\n\\t\\t\\tcnt[j]--;\\n\\t\\t\\ti += 2;\\n\\t\\t}\\n\\t}\\n\\n\\treturn S;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626800,
                "title": "easy-to-understand-100-beats-c",
                "content": "\\n\\n# Approach\\nHash Table \\n- Count character in hash by using for loop.\\n- Try to place most occurant in one go. If not return \"\".\\n- place other character with index gap. i=i+2 \\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n    \\n    int hash[26]={0};\\n    for(int i=0;i<s.size();i++){\\n        hash[s[i]-\\'a\\']++;}\\n\\n    //find most frequent char \\n    char max_freq_char;\\n    int max_freq= INT_MIN;\\n\\n    for(int i=0;i<26;i++){\\n        if(hash[i]>max_freq){\\n            max_freq= hash[i];\\n            max_freq_char = i+ \\'a\\';\\n        }\\n    }\\n\\n    int index=0;\\n    while(max_freq>0 && index<s.size()){\\n        s[index]= max_freq_char;\\n        max_freq--;\\n        index+=2;\\n    }\\n\\n    if(max_freq !=0){\\n        return \"\";\\n    }\\n    hash[max_freq_char -\\'a\\']=0;\\n\\n    for(int i=0;i<26;i++){\\n        while(hash[i]>0){\\n            index= index>=s.size() ? 1: index;\\n            s[index] = i +\\'a\\';\\n            index +=2;\\n            hash[i]--;\\n        }\\n    }\\n    \\n    return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n    \\n    int hash[26]={0};\\n    for(int i=0;i<s.size();i++){\\n        hash[s[i]-\\'a\\']++;}\\n\\n    //find most frequent char \\n    char max_freq_char;\\n    int max_freq= INT_MIN;\\n\\n    for(int i=0;i<26;i++){\\n        if(hash[i]>max_freq){\\n            max_freq= hash[i];\\n            max_freq_char = i+ \\'a\\';\\n        }\\n    }\\n\\n    int index=0;\\n    while(max_freq>0 && index<s.size()){\\n        s[index]= max_freq_char;\\n        max_freq--;\\n        index+=2;\\n    }\\n\\n    if(max_freq !=0){\\n        return \"\";\\n    }\\n    hash[max_freq_char -\\'a\\']=0;\\n\\n    for(int i=0;i<26;i++){\\n        while(hash[i]>0){\\n            index= index>=s.size() ? 1: index;\\n            s[index] = i +\\'a\\';\\n            index +=2;\\n            hash[i]--;\\n        }\\n    }\\n    \\n    return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516039,
                "title": "superb-logic-with-heap-module",
                "content": "# Using Heap Logic\\n```\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        dic=Counter(s)\\n        heap=[[-count,char] for char,count in dic.items()]\\n        heapq.heapify(heap)\\n        prev,output=None,\"\"\\n        while prev or heap:\\n            if prev and not heap:\\n                return \"\"\\n            count,char=heapq.heappop(heap)\\n            count+=1\\n            output+=char\\n            if prev:\\n                heapq.heappush(heap,prev)\\n                prev=None\\n            if count!=0:\\n                prev=[count,char]\\n        return output\\n  ```\\n  # please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        dic=Counter(s)\\n        heap=[[-count,char] for char,count in dic.items()]\\n        heapq.heapify(heap)\\n        prev,output=None,\"\"\\n        while prev or heap:\\n            if prev and not heap:\\n                return \"\"\\n            count,char=heapq.heappop(heap)\\n            count+=1\\n            output+=char\\n            if prev:\\n                heapq.heappush(heap,prev)\\n                prev=None\\n            if count!=0:\\n                prev=[count,char]\\n        return output\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 2287931,
                "title": "short-fast-intuitive-python-heap",
                "content": "1. Use a max Heap to exhaust the most frequent char first\\n2. Use a prev var to avoid adding the same char in the next iteration\\n\\n```\\nimport heapq\\n\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:        \\n        maxHeap = []\\n        res = []\\n        prev = None\\n        \\n        # Use Counter() to build a maxHeap with priority key as the count of the char\\n        count = collections.Counter(s)\\n        for char, count in count.items():\\n            heappush(maxHeap, (count * -1, char))\\n            \\n        while maxHeap:\\n            count, char = heappop(maxHeap)\\n            count +=1 # Since it\\'s a maxHeap we increment count to \\'count down\\'\\n            res.append(char)\\n            \\n            # Push the element from previous iteration to heap \\n            # since we can reuse the char after appending a different char to res\\n            if prev:\\n                heappush(maxHeap, prev)\\n                \\n            # Set prev to current element since we can\\'t reuse it just yet\\n            # or not if count for the char is 0\\n            if count == 0:\\n                prev = None\\n            else:\\n                prev = (count, char)\\n        \\n        # If we have a prev value then there are too many of the same char to return \\n        # a solution that fit the requirement\\n        return \"\" if prev else \"\".join(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:        \\n        maxHeap = []\\n        res = []\\n        prev = None\\n        \\n        # Use Counter() to build a maxHeap with priority key as the count of the char\\n        count = collections.Counter(s)\\n        for char, count in count.items():\\n            heappush(maxHeap, (count * -1, char))\\n            \\n        while maxHeap:\\n            count, char = heappop(maxHeap)\\n            count +=1 # Since it\\'s a maxHeap we increment count to \\'count down\\'\\n            res.append(char)\\n            \\n            # Push the element from previous iteration to heap \\n            # since we can reuse the char after appending a different char to res\\n            if prev:\\n                heappush(maxHeap, prev)\\n                \\n            # Set prev to current element since we can\\'t reuse it just yet\\n            # or not if count for the char is 0\\n            if count == 0:\\n                prev = None\\n            else:\\n                prev = (count, char)\\n        \\n        # If we have a prev value then there are too many of the same char to return \\n        # a solution that fit the requirement\\n        return \"\" if prev else \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918126,
                "title": "python-no-sort-o-n",
                "content": "```\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        count = Counter(s) # O(N)\\n        most_common_c = max(count.items(), key=itemgetter(1))[0] # O(N)\\n        if count[most_common_c] > (len(s)+1)//2:\\n            return \"\"\\n        \\n        output = [\\'\\']*len(s)        \\n        i = 0\\n        for _ in range(count[most_common_c]):\\n            output[i] = most_common_c\\n            i += 2\\n        \\n        count[most_common_c] = 0\\n        \\n        for k, v in count.items():\\n            for _ in range(v):\\n                if i >= len(s):\\n                    i = 1\\n                output[i] = k\\n                i += 2\\n                \\n        return \"\".join(output)\\n```\\nhttps://leetcode.com/problems/reorganize-string/discuss/232469/Java-No-Sort-O(N)-0ms-beat-100",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        count = Counter(s) # O(N)\\n        most_common_c = max(count.items(), key=itemgetter(1))[0] # O(N)\\n        if count[most_common_c] > (len(s)+1)//2:\\n            return \"\"\\n        \\n        output = [\\'\\']*len(s)        \\n        i = 0\\n        for _ in range(count[most_common_c]):\\n            output[i] = most_common_c\\n            i += 2\\n        \\n        count[most_common_c] = 0\\n        \\n        for k, v in count.items():\\n            for _ in range(v):\\n                if i >= len(s):\\n                    i = 1\\n                output[i] = k\\n                i += 2\\n                \\n        return \"\".join(output)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1797776,
                "title": "python3-using-max-heap-and-a-dictionary-counter",
                "content": "The idea and intuition of the solution is as follows:\\n1. Count the occurences of each alphabet in the given string\\n2. Construct a Max heap with (count, alphabet) as elements\\n3. Now, pop two elements each time (two maximum occuring elements) and add them to the answer (include the edge cases when heap is empty after one pop)\\n4. This approach works because the best way to construct the solution string is to greedily select the maximum occuring element so that they get finished alternatively.\\n\\nNote: Code is not that much clean but it is short I guess\\uD83D\\uDE05\\n\\n```\\n# counting the alphabet occurences\\nd = {}\\nl = len(s)\\nfor i in range(l):\\n\\tif s[i] in d:\\n\\t\\td[s[i]]+=1\\n\\telse:\\n\\t\\td[s[i]]=1\\n# construct a max heap\\nhp = []\\nfor k in d:\\n\\theapq.heappush(hp, (-1*d[k], k))\\nans = \"\"\\n\\n# loop through the heap until its size is greater than 1\\nwhile(len(hp)>1):\\n\\tfst = heapq.heappop(hp)\\n\\tif hp:\\n\\t\\tscd = heapq.heappop(hp)\\n\\telse:\\n\\t\\tscd = (0, \"\")\\n\\tans+=fst[1]+scd[1]\\n\\tif (fst[0]+1)<0:\\n\\t\\theapq.heappush(hp, (fst[0]+1, fst[1]))\\n\\tif (scd[0]+1)<0:\\n\\t\\theapq.heappush(hp, (scd[0]+1, scd[1]))\\nif hp and hp[0][0]<-1:\\n\\treturn \"\"\\nelse:\\n\\tif hp and hp[0][0]==-1:\\n\\t\\treturn ans+hp[0][1]\\n\\telse:\\n\\t\\treturn ans\\n```\\n\\nPlease let me know if there is any doubt or the solution needs more clarification. Please upvote the solution if you find it useful :) \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n# counting the alphabet occurences\\nd = {}\\nl = len(s)\\nfor i in range(l):\\n\\tif s[i] in d:\\n\\t\\td[s[i]]+=1\\n\\telse:\\n\\t\\td[s[i]]=1\\n# construct a max heap\\nhp = []\\nfor k in d:\\n\\theapq.heappush(hp, (-1*d[k], k))\\nans = \"\"\\n\\n# loop through the heap until its size is greater than 1\\nwhile(len(hp)>1):\\n\\tfst = heapq.heappop(hp)\\n\\tif hp:\\n\\t\\tscd = heapq.heappop(hp)\\n\\telse:\\n\\t\\tscd = (0, \"\")\\n\\tans+=fst[1]+scd[1]\\n\\tif (fst[0]+1)<0:\\n\\t\\theapq.heappush(hp, (fst[0]+1, fst[1]))\\n\\tif (scd[0]+1)<0:\\n\\t\\theapq.heappush(hp, (scd[0]+1, scd[1]))\\nif hp and hp[0][0]<-1:\\n\\treturn \"\"\\nelse:\\n\\tif hp and hp[0][0]==-1:\\n\\t\\treturn ans+hp[0][1]\\n\\telse:\\n\\t\\treturn ans\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1774190,
                "title": "easy-python-o-nlogn-o-n",
                "content": "```\\n\\nclass Solution(object):\\n    def reorganizeString(self, s):\\n        maxheap =[]\\n        counter = Counter(s)\\n        for char, count in counter.items():\\n            heapq.heappush(maxheap, (-count, char))\\n        res = \"\"\\n        while maxheap:\\n            if len(maxheap) > 1:\\n                count1, char1 = heapq.heappop(maxheap)\\n                count2, char2 = heapq.heappop(maxheap)\\n                count1, count2 = -count1, -count2\\n                res += char1\\n                res += char2\\n                count1 -=1\\n                count2 -=1\\n                if count1 > 0:\\n                    heappush(maxheap, (-count1, char1))\\n                if count2 > 0:\\n                    heappush(maxheap, (-count2, char2))\\n            else: \\n                # if maxheap only has 1 unique element (bc len(maxheap) measures num of unique chars)\\n                count, char = heapq.heappop(maxheap)\\n                if -count == 1:\\n                    res += char\\n                else:\\n                    # same element, multiple occurences\\n                    return \"\" \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nclass Solution(object):\\n    def reorganizeString(self, s):\\n        maxheap =[]\\n        counter = Counter(s)\\n        for char, count in counter.items():\\n            heapq.heappush(maxheap, (-count, char))\\n        res = \"\"\\n        while maxheap:\\n            if len(maxheap) > 1:\\n                count1, char1 = heapq.heappop(maxheap)\\n                count2, char2 = heapq.heappop(maxheap)\\n                count1, count2 = -count1, -count2\\n                res += char1\\n                res += char2\\n                count1 -=1\\n                count2 -=1\\n                if count1 > 0:\\n                    heappush(maxheap, (-count1, char1))\\n                if count2 > 0:\\n                    heappush(maxheap, (-count2, char2))\\n            else: \\n                # if maxheap only has 1 unique element (bc len(maxheap) measures num of unique chars)\\n                count, char = heapq.heappop(maxheap)\\n                if -count == 1:\\n                    res += char\\n                else:\\n                    # same element, multiple occurences\\n                    return \"\" \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1689784,
                "title": "c-easy-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        string ans;\\n        unordered_map<char,int>mp;\\n        for(auto &it:s) mp[it]++;\\n        priority_queue<pair<int,char>>mxHeap;\\n        for(auto it:mp){\\n            mxHeap.push(make_pair(it.second,it.first));\\n        }\\n        \\n        while(mxHeap.size()>1)\\n        {\\n            auto t1=mxHeap.top(); mxHeap.pop();\\n            auto t2=mxHeap.top(); mxHeap.pop();\\n            \\n            ans+=t1.second; ans+=t2.second;\\n            t1.first-=1; t2.first-=1;\\n            \\n            if(t1.first>0){\\n                mxHeap.push(t1);\\n            }\\n            if(t2.first>0){\\n                mxHeap.push(t2);\\n            }\\n            \\n        }\\n        if(!mxHeap.empty()){\\n            if(mxHeap.top().first>1)\\n                return \"\";\\n            else\\n                ans+=mxHeap.top().second;\\n                \\n        }\\n    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        string ans;\\n        unordered_map<char,int>mp;\\n        for(auto &it:s) mp[it]++;\\n        priority_queue<pair<int,char>>mxHeap;\\n        for(auto it:mp){\\n            mxHeap.push(make_pair(it.second,it.first));\\n        }\\n        \\n        while(mxHeap.size()>1)\\n        {\\n            auto t1=mxHeap.top(); mxHeap.pop();\\n            auto t2=mxHeap.top(); mxHeap.pop();\\n            \\n            ans+=t1.second; ans+=t2.second;\\n            t1.first-=1; t2.first-=1;\\n            \\n            if(t1.first>0){\\n                mxHeap.push(t1);\\n            }\\n            if(t2.first>0){\\n                mxHeap.push(t2);\\n            }\\n            \\n        }\\n        if(!mxHeap.empty()){\\n            if(mxHeap.top().first>1)\\n                return \"\";\\n            else\\n                ans+=mxHeap.top().second;\\n                \\n        }\\n    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519439,
                "title": "c-working-solution-with-detailed-explanation",
                "content": "**Detailed explanation ahead**\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        string ans=\"\";\\n        if(s.length()==1)//edge case if s.length is 1 then return s itself\\n        {\\n            ans=ans+s[0];\\n            return ans;\\n        }\\n        unordered_map<char,int> umap;//unordered map to count the frequency of the alphabets\\n        \\n        for(auto ele:s)//pushing into map\\n        {\\n           umap[ele]++;\\n           if(umap[ele]>(s.length()+1)/2)//if frequency of an element is more than half of the length of the string then in no way it can rearrange itself\\n            {\\n                return \"\";\\n            }\\n        }\\n        priority_queue<pair<int,char>> pque;//creting a max heap inorder to sort on the basis of the frequnecy of the elements that\\'s why we have <int,char>\\n        for(auto ele:umap)//pushing into pque\\n        {\\n            pque.push(make_pair(ele.second,ele.first));\\n        }\\n        while(pque.size()>1)//if the size of the pque is 1 then there is no other alphabet than top one so break\\n        {\\n            pair<int,char> top1=pque.top();storing top most element\\n            pque.pop();\\n            pair<int,char> top2=pque.top();//storing second top most element now topmost\\n            pque.pop();\\n            ans=ans+top1.second;//adding it to the result or the ans string\\n            ans=ans+top2.second;//same as above\\n            top1.first=top1.first-1;//decreasing the frequency of the element once added in the ans\\n            top2.first=top2.first-1;\\n            if(top1.first>0)//add again only if if is valid\\n            {\\n                \\n                pque.push(top1);\\n            }\\n            if(top2.first>0)\\n            {\\n                \\n                pque.push(top2);\\n            }\\n            \\n        }\\n        if(!(pque.empty()))\\n        {\\n        if(pque.top().first>1)//if the topmost element still has more than one then it is not going to make a perfect arrangment though we have already checked this earlier\\n        {\\n            return \"\";\\n        }\\n        else {\\n            ans=ans+pque.top().second;//if not then add it to the ans string \\n        }\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n**If you want to understand it better please dry run it once yourself.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        string ans=\"\";\\n        if(s.length()==1)//edge case if s.length is 1 then return s itself\\n        {\\n            ans=ans+s[0];\\n            return ans;\\n        }\\n        unordered_map<char,int> umap;//unordered map to count the frequency of the alphabets\\n        \\n        for(auto ele:s)//pushing into map\\n        {\\n           umap[ele]++;\\n           if(umap[ele]>(s.length()+1)/2)//if frequency of an element is more than half of the length of the string then in no way it can rearrange itself\\n            {\\n                return \"\";\\n            }\\n        }\\n        priority_queue<pair<int,char>> pque;//creting a max heap inorder to sort on the basis of the frequnecy of the elements that\\'s why we have <int,char>\\n        for(auto ele:umap)//pushing into pque\\n        {\\n            pque.push(make_pair(ele.second,ele.first));\\n        }\\n        while(pque.size()>1)//if the size of the pque is 1 then there is no other alphabet than top one so break\\n        {\\n            pair<int,char> top1=pque.top();storing top most element\\n            pque.pop();\\n            pair<int,char> top2=pque.top();//storing second top most element now topmost\\n            pque.pop();\\n            ans=ans+top1.second;//adding it to the result or the ans string\\n            ans=ans+top2.second;//same as above\\n            top1.first=top1.first-1;//decreasing the frequency of the element once added in the ans\\n            top2.first=top2.first-1;\\n            if(top1.first>0)//add again only if if is valid\\n            {\\n                \\n                pque.push(top1);\\n            }\\n            if(top2.first>0)\\n            {\\n                \\n                pque.push(top2);\\n            }\\n            \\n        }\\n        if(!(pque.empty()))\\n        {\\n        if(pque.top().first>1)//if the topmost element still has more than one then it is not going to make a perfect arrangment though we have already checked this earlier\\n        {\\n            return \"\";\\n        }\\n        else {\\n            ans=ans+pque.top().second;//if not then add it to the ans string \\n        }\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261422,
                "title": "c-using-priority-queue",
                "content": "```\\nstring reorganizeString(string s) {\\n       int n=s.length();\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[s[i]]++;\\n        }\\n        priority_queue<pair<int,char>> pq;\\n        for(auto x:mp){\\n            pq.push({x.second,x.first});\\n        }\\n        string ans=\"\";\\n        auto p = pq.top();\\n        pq.pop();\\n        ans.push_back(p.second);\\n        pair<int,char> prev = {p.first-1,p.second};\\n        while(!pq.empty()){\\n            pair<int,char> x = pq.top();\\n            ans.push_back(x.second);\\n            pq.pop();\\n            if(prev.first){\\n                pq.push(prev);\\n            }\\n            prev = {x.first-1,x.second};\\n        }\\n        if(ans.length()<s.length()) return \"\";\\n        return ans;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```\\nstring reorganizeString(string s) {\\n       int n=s.length();\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[s[i]]++;\\n        }\\n        priority_queue<pair<int,char>> pq;\\n        for(auto x:mp){\\n            pq.push({x.second,x.first});\\n        }\\n        string ans=\"\";\\n        auto p = pq.top();\\n        pq.pop();\\n        ans.push_back(p.second);\\n        pair<int,char> prev = {p.first-1,p.second};\\n        while(!pq.empty()){\\n            pair<int,char> x = pq.top();\\n            ans.push_back(x.second);\\n            pq.pop();\\n            if(prev.first){\\n                pq.push(prev);\\n            }\\n            prev = {x.first-1,x.second};\\n        }\\n        if(ans.length()<s.length()) return \"\";\\n        return ans;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1076556,
                "title": "java-python-solution-using-maxheap",
                "content": "**Java**\\n\\n```\\nclass Solution {\\n    public String reorganizeString(String S) {\\n        int[] ascii = new int[127];\\n        for (char c : S.toCharArray()) ascii[c]++;\\n\\n        Queue<int[]> maxHeap = new PriorityQueue<>((o1, o2) -> o2[1] - o1[1]);\\n        for (int i = 0; i < ascii.length; i++) {\\n            if (ascii[i] > 0) {\\n                maxHeap.add(new int[]{i, ascii[i]});\\n            }\\n        }\\n\\n        StringBuilder result = new StringBuilder();\\n        while (maxHeap.size() >= 2) {\\n            int[] curr = maxHeap.remove();\\n            int[] next = maxHeap.remove();\\n\\n            result.append((char) curr[0]);\\n            result.append((char) next[0]);\\n\\n            if (curr[1] > 1) {\\n                maxHeap.add(new int[]{curr[0], curr[1] - 1});\\n            }\\n\\n            if (next[1] > 1) {\\n                maxHeap.add(new int[]{next[0], next[1] - 1});\\n            }\\n        }\\n\\n        if (!maxHeap.isEmpty()) {\\n            int[] curr = maxHeap.remove();\\n            if (curr[1] > 1) {\\n                return \"\";\\n            }\\n\\n            result.append((char) curr[0]);\\n        }\\n\\n        return result.toString();\\n    }\\n}\\n```\\n\\n**Python**\\nIn python I couldn\\'t find native maxHeap class. So I used minHeap(heapq) and negative numbers instead of positive to store the number of characters. In this way minHeap does the same thing as maxHeap.\\n\\n```\\nimport heapq\\n\\nclass Solution:\\n    def reorganizeString(self, S: str) -> str:\\n        ans = str()\\n\\n        ascii = [0] * 127\\n        for i in S:\\n            ascii[ord(i)] -= 1\\n\\n        max_heap = []\\n        for i in range(0, len(ascii)):\\n            if ascii[i] < 0:\\n                heapq.heappush(max_heap, (ascii[i], chr(i)))\\n\\n        while len(max_heap) >= 2:\\n            curr = heapq.heappop(max_heap)\\n            next = heapq.heappop(max_heap)\\n\\n            ans += curr[1]\\n            ans += next[1]\\n\\n            if curr[0] < -1:\\n                heapq.heappush(max_heap, (curr[0] + 1, curr[1]))\\n\\n            if next[0] < -1:\\n                heapq.heappush(max_heap, (next[0] + 1, next[1]))\\n\\n        if len(max_heap) > 0:\\n            curr = heapq.heappop(max_heap)\\n            if curr[0] < -1:\\n                return \"\"\\n\\n            ans += curr[1]\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public String reorganizeString(String S) {\\n        int[] ascii = new int[127];\\n        for (char c : S.toCharArray()) ascii[c]++;\\n\\n        Queue<int[]> maxHeap = new PriorityQueue<>((o1, o2) -> o2[1] - o1[1]);\\n        for (int i = 0; i < ascii.length; i++) {\\n            if (ascii[i] > 0) {\\n                maxHeap.add(new int[]{i, ascii[i]});\\n            }\\n        }\\n\\n        StringBuilder result = new StringBuilder();\\n        while (maxHeap.size() >= 2) {\\n            int[] curr = maxHeap.remove();\\n            int[] next = maxHeap.remove();\\n\\n            result.append((char) curr[0]);\\n            result.append((char) next[0]);\\n\\n            if (curr[1] > 1) {\\n                maxHeap.add(new int[]{curr[0], curr[1] - 1});\\n            }\\n\\n            if (next[1] > 1) {\\n                maxHeap.add(new int[]{next[0], next[1] - 1});\\n            }\\n        }\\n\\n        if (!maxHeap.isEmpty()) {\\n            int[] curr = maxHeap.remove();\\n            if (curr[1] > 1) {\\n                return \"\";\\n            }\\n\\n            result.append((char) curr[0]);\\n        }\\n\\n        return result.toString();\\n    }\\n}\\n```\n```\\nimport heapq\\n\\nclass Solution:\\n    def reorganizeString(self, S: str) -> str:\\n        ans = str()\\n\\n        ascii = [0] * 127\\n        for i in S:\\n            ascii[ord(i)] -= 1\\n\\n        max_heap = []\\n        for i in range(0, len(ascii)):\\n            if ascii[i] < 0:\\n                heapq.heappush(max_heap, (ascii[i], chr(i)))\\n\\n        while len(max_heap) >= 2:\\n            curr = heapq.heappop(max_heap)\\n            next = heapq.heappop(max_heap)\\n\\n            ans += curr[1]\\n            ans += next[1]\\n\\n            if curr[0] < -1:\\n                heapq.heappush(max_heap, (curr[0] + 1, curr[1]))\\n\\n            if next[0] < -1:\\n                heapq.heappush(max_heap, (next[0] + 1, next[1]))\\n\\n        if len(max_heap) > 0:\\n            curr = heapq.heappop(max_heap)\\n            if curr[0] < -1:\\n                return \"\"\\n\\n            ans += curr[1]\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 977150,
                "title": "python-time-o-n-space-o-a-solution-no-sorting-detailed-explanation",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def reorganizeString(self, S: str) -> str:\\n        \"\"\" \\n        Time O(N), Space O(A). (N: number of characters, A: Alphabet size)\\n        First fills the most frequent character by creating enough groups to hold it.\\n        Then adds all other chars (order doesn\\'t matter) to each group to form a valid string.\\n        If the max_char has count more than half the array, there won\\'t be a valid string, return \\'\\'\\n        \"\"\"\\n        # Getting the char counts\\n        counts = Counter(S)\\n        max_count, max_char = 0, 0\\n        \\n        # Getting the character with the maximum count (if there are multiple maximum, it doesn\\'t matter)\\n        # What matters is that we have as many groups as the maximum character count\\n        for char, count in counts.items():\\n            if count > max_count:\\n                max_count = count\\n                max_char = char\\n                \\n        # If the max count is bigger than half threshold (+1) (different for odd and even case)\\n        # There won\\'t be a valid string sequence\\n        if max_count > (len(S) + 1) // 2:\\n            return \\'\\'\\n\\n        # Each group will have one copy of the max element\\n        groups = [max_char for _ in range(max_count)]\\n        counts.pop(max_char)\\n\\n        g_len = len(groups)\\n        g_idx = 0 # The idx of the current group where we are adding\\n        \\n        for char, count in counts.items(): # O(N) loop for N characters total\\n            for j in range(count):\\n                groups[g_idx] += char # Would in theory be better to do these with lists, but practically it\\'s slower for shorter strings\\n                g_idx += 1\\n                if g_idx == g_len: # Circling back to the first group and continuing to make additions\\n                    g_idx = 0\\n    \\n        return \\'\\'.join(groups)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def reorganizeString(self, S: str) -> str:\\n        \"\"\" \\n        Time O(N), Space O(A). (N: number of characters, A: Alphabet size)\\n        First fills the most frequent character by creating enough groups to hold it.\\n        Then adds all other chars (order doesn\\'t matter) to each group to form a valid string.\\n        If the max_char has count more than half the array, there won\\'t be a valid string, return \\'\\'\\n        \"\"\"\\n        # Getting the char counts\\n        counts = Counter(S)\\n        max_count, max_char = 0, 0\\n        \\n        # Getting the character with the maximum count (if there are multiple maximum, it doesn\\'t matter)\\n        # What matters is that we have as many groups as the maximum character count\\n        for char, count in counts.items():\\n            if count > max_count:\\n                max_count = count\\n                max_char = char\\n                \\n        # If the max count is bigger than half threshold (+1) (different for odd and even case)\\n        # There won\\'t be a valid string sequence\\n        if max_count > (len(S) + 1) // 2:\\n            return \\'\\'\\n\\n        # Each group will have one copy of the max element\\n        groups = [max_char for _ in range(max_count)]\\n        counts.pop(max_char)\\n\\n        g_len = len(groups)\\n        g_idx = 0 # The idx of the current group where we are adding\\n        \\n        for char, count in counts.items(): # O(N) loop for N characters total\\n            for j in range(count):\\n                groups[g_idx] += char # Would in theory be better to do these with lists, but practically it\\'s slower for shorter strings\\n                g_idx += 1\\n                if g_idx == g_len: # Circling back to the first group and continuing to make additions\\n                    g_idx = 0\\n    \\n        return \\'\\'.join(groups)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877654,
                "title": "java-greedy-approach-very-clearly-explained",
                "content": "```java\\nclass Solution {\\n    public String reorganizeString(String S) {\\n        \\n        //Use hashmap to store # of occurences\\n        Map<Character,Integer> map = new HashMap();\\n        for(char c: S.toCharArray()) map.put(c,map.getOrDefault(c,0)+1);\\n        \\n        //Use prioirty queue\\'s to add the most occuring characters\\n        //to front of list, and the least to the back\\n        Queue queue = new PriorityQueue<Character>( (a,b) -> map.get(b) - map.get(a));\\n        for(Character c: map.keySet()) queue.add(c);\\n        \\n        //Now loop until queue size is less than or equal to 1\\n        StringBuilder result = new StringBuilder(\"\");\\n        while(queue.size() > 1){\\n            //GREEDY APPROACH\\n            //poll the first and next char\\n            Character curr = (Character) queue.poll();\\n            Character next = (Character) queue.poll();\\n            \\n            //First append to the result to be returned later\\n            result.append(curr);result.append(next);\\n            \\n            //decrement their occurence from map\\n            map.put(curr, map.get(curr)-1);\\n            map.put(next, map.get(next)-1);\\n            \\n            //if they are 0, dont add it back to the heap\\n            //since no more instances of that character\\n            //else add it\\n            if(map.get(curr) > 0) queue.add(curr);\\n            if(map.get(next) > 0) queue.add(next);\\n        }\\n        \\n        //if queue size is 1, it must be\\n        //dangling between a character\\n        if(queue.size() == 1){\\n            //poll the last character\\n            Character last = (Character) queue.poll();\\n            //if that occurence is more than 1, then it must be\\n            //un-proportinate to the other characters so return \\n            //null/empty string in this case\\n            if(map.get(last) > 1) return \"\";\\n            \\n            //otherwise add last char\\n            result.append(last);\\n        }\\n            \\n        return new String(result);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public String reorganizeString(String S) {\\n        \\n        //Use hashmap to store # of occurences\\n        Map<Character,Integer> map = new HashMap();\\n        for(char c: S.toCharArray()) map.put(c,map.getOrDefault(c,0)+1);\\n        \\n        //Use prioirty queue\\'s to add the most occuring characters\\n        //to front of list, and the least to the back\\n        Queue queue = new PriorityQueue<Character>( (a,b) -> map.get(b) - map.get(a));\\n        for(Character c: map.keySet()) queue.add(c);\\n        \\n        //Now loop until queue size is less than or equal to 1\\n        StringBuilder result = new StringBuilder(\"\");\\n        while(queue.size() > 1){\\n            //GREEDY APPROACH\\n            //poll the first and next char\\n            Character curr = (Character) queue.poll();\\n            Character next = (Character) queue.poll();\\n            \\n            //First append to the result to be returned later\\n            result.append(curr);result.append(next);\\n            \\n            //decrement their occurence from map\\n            map.put(curr, map.get(curr)-1);\\n            map.put(next, map.get(next)-1);\\n            \\n            //if they are 0, dont add it back to the heap\\n            //since no more instances of that character\\n            //else add it\\n            if(map.get(curr) > 0) queue.add(curr);\\n            if(map.get(next) > 0) queue.add(next);\\n        }\\n        \\n        //if queue size is 1, it must be\\n        //dangling between a character\\n        if(queue.size() == 1){\\n            //poll the last character\\n            Character last = (Character) queue.poll();\\n            //if that occurence is more than 1, then it must be\\n            //un-proportinate to the other characters so return \\n            //null/empty string in this case\\n            if(map.get(last) > 1) return \"\";\\n            \\n            //otherwise add last char\\n            result.append(last);\\n        }\\n            \\n        return new String(result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741623,
                "title": "python-heap-easy-solution-with-comments",
                "content": "- Counter module to count all the frquencies of the letters and push them to a `maxheap`\\n- Python only supports minheap, hence we `negate` the count.\\n- Store the popped letter into `last` and push it back to the heap AFTER next pop\\n- When the heap is empty, if `last` is empty, then we have a solution\\n- Otherwise it\\'s not possible (since there\\'s unused letters)\\n```\\nclass Solution:\\n    def reorganizeString(self, S: str) -> str:\\n        if not S: return \\'\\'\\n        heap, last, ans = [], None, \\'\\'\\n        counts = collections.Counter(S)\\n        for ch in counts:\\n            heapq.heappush(heap, (-counts[ch], ch))\\n            \\n        while heap:\\n            count, ch = heapq.heappop(heap)\\n            ans += ch\\n            if last:\\n                heapq.heappush(heap, last)\\n            last = (count+1, ch) if count != -1 else None\\n        return ans if not last else \\'\\'\\n",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "- Counter module to count all the frquencies of the letters and push them to a `maxheap`\\n- Python only supports minheap, hence we `negate` the count.\\n- Store the popped letter into `last` and push it back to the heap AFTER next pop\\n- When the heap is empty, if `last` is empty, then we have a solution\\n- Otherwise it\\'s not possible (since there\\'s unused letters)\\n```\\nclass Solution:\\n    def reorganizeString(self, S: str) -> str:\\n        if not S: return \\'\\'\\n        heap, last, ans = [], None, \\'\\'\\n        counts = collections.Counter(S)\\n        for ch in counts:\\n            heapq.heappush(heap, (-counts[ch], ch))\\n            \\n        while heap:\\n            count, ch = heapq.heappop(heap)\\n            ans += ch\\n            if last:\\n                heapq.heappush(heap, last)\\n            last = (count+1, ch) if count != -1 else None\\n        return ans if not last else \\'\\'\\n",
                "codeTag": "Java"
            },
            {
                "id": 249144,
                "title": "a-simple-c-solution-accepted-runtime-4-ms",
                "content": "```\\nint cmp(void* a,void* b){\\n    return ((int**)b)[0][0]-((int**)a)[0][0];\\n}\\nchar* reorganizeString(char* S) {\\n    int len=strlen(S);\\n    int** array=(int**)malloc(26*sizeof(int*));\\n    for(int i=0;i<26;i++){\\n        array[i]=(int*)calloc(2,sizeof(int));\\n        array[i][1]=i;\\n    }\\n    int max=0;\\n    int count=0;\\n    for(int i=0;i<len;i++){\\n        if(array[S[i]-\\'a\\'][0]==0){\\n            count++;\\n        }\\n        array[S[i]-\\'a\\'][0]++;\\n        if(max<array[S[i]-\\'a\\'][0]){\\n            max=array[S[i]-\\'a\\'][0];\\n        }\\n    }\\n    if(max-1>len-max){\\n        return \"\";\\n    }\\n    qsort(array,26,sizeof(array[0]),cmp);\\n    int index=0;\\n    S[index++]=array[0][1]+\\'a\\';\\n    array[0][0]--;\\n    while(index<len){\\n        int max=0;\\n        int temp=0;\\n        for(int i=0;i<count;i++){\\n            if(array[i][1]!=S[index-1]-\\'a\\'&&max<array[i][0]){\\n                max=array[i][0];\\n                temp=i;\\n            }\\n        }\\n        array[temp][0]--;\\n        S[index++]=array[temp][1]+\\'a\\';\\n    }\\n    free(array);\\n    return S;\\n}\\n````",
                "solutionTags": [],
                "code": "```\\nint cmp(void* a,void* b){\\n    return ((int**)b)[0][0]-((int**)a)[0][0];\\n}\\nchar* reorganizeString(char* S) {\\n    int len=strlen(S);\\n    int** array=(int**)malloc(26*sizeof(int*));\\n    for(int i=0;i<26;i++){\\n        array[i]=(int*)calloc(2,sizeof(int));\\n        array[i][1]=i;\\n    }\\n    int max=0;\\n    int count=0;\\n    for(int i=0;i<len;i++){\\n        if(array[S[i]-\\'a\\'][0]==0){\\n            count++;\\n        }\\n        array[S[i]-\\'a\\'][0]++;\\n        if(max<array[S[i]-\\'a\\'][0]){\\n            max=array[S[i]-\\'a\\'][0];\\n        }\\n    }\\n    if(max-1>len-max){\\n        return \"\";\\n    }\\n    qsort(array,26,sizeof(array[0]),cmp);\\n    int index=0;\\n    S[index++]=array[0][1]+\\'a\\';\\n    array[0][0]--;\\n    while(index<len){\\n        int max=0;\\n        int temp=0;\\n        for(int i=0;i<count;i++){\\n            if(array[i][1]!=S[index-1]-\\'a\\'&&max<array[i][0]){\\n                max=array[i][0];\\n                temp=i;\\n            }\\n        }\\n        array[temp][0]--;\\n        S[index++]=array[temp][1]+\\'a\\';\\n    }\\n    free(array);\\n    return S;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 192217,
                "title": "java-hashmap-priorityqueue-o-n",
                "content": "```\\nclass Solution {\\n    public String reorganizeString(String S) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char c : S.toCharArray()){\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n        PriorityQueue<Map.Entry<Character, Integer>> q = new PriorityQueue<>(new Comparator<Map.Entry<Character, Integer>>(){\\n            public int compare(Map.Entry<Character, Integer> a, Map.Entry<Character, Integer> b){\\n                return b.getValue() - a.getValue();\\n            }\\n        });\\n        q.addAll(map.entrySet());\\n        StringBuilder res = new StringBuilder();\\n        Map.Entry<Character, Integer> last = null;\\n        while (!q.isEmpty()){\\n            Map.Entry<Character, Integer> cur = q.poll();\\n            res.append(cur.getKey());\\n            cur.setValue(cur.getValue() - 1);\\n            if(last != null){\\n                q.offer(last);\\n            }\\n            last = cur.getValue() > 0 ? cur : null;\\n\\n        }\\n        return res.length() == S.length() ? res.toString() : \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String reorganizeString(String S) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char c : S.toCharArray()){\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n        PriorityQueue<Map.Entry<Character, Integer>> q = new PriorityQueue<>(new Comparator<Map.Entry<Character, Integer>>(){\\n            public int compare(Map.Entry<Character, Integer> a, Map.Entry<Character, Integer> b){\\n                return b.getValue() - a.getValue();\\n            }\\n        });\\n        q.addAll(map.entrySet());\\n        StringBuilder res = new StringBuilder();\\n        Map.Entry<Character, Integer> last = null;\\n        while (!q.isEmpty()){\\n            Map.Entry<Character, Integer> cur = q.poll();\\n            res.append(cur.getKey());\\n            cur.setValue(cur.getValue() - 1);\\n            if(last != null){\\n                q.offer(last);\\n            }\\n            last = cur.getValue() > 0 ? cur : null;\\n\\n        }\\n        return res.length() == S.length() ? res.toString() : \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 177166,
                "title": "python-just-like-task-schedule",
                "content": "```\\nclass Solution(object):\\n\\tdef reorganizeString(self, S):\\n\\t\\t\"\"\"\\n\\t\\t:type S: str\\n\\t\\t:rtype: str\\n\\t\\t\"\"\"\\n\\t\\tfrom collections import Counter\\n\\n\\t\\t# sorted letter -> freq\\n\\t\\tletter_cnt = Counter(S).most_common(len(S))\\n\\n\\t\\t# As task scheduler, use most common letter as separator\\n\\t\\tmost_freq_letter, freq_most_letter = letter_cnt[0][0], letter_cnt[0][1]\\n\\t\\tres = [most_freq_letter] * freq_most_letter\\n\\n\\t\\tcnt = 0\\n\\t\\tfor letter, freq in letter_cnt[1:]:\\n\\t\\t\\tfor idx in range(freq):\\n\\t\\t\\t\\tres[cnt % freq_most_letter] += letter\\n\\t\\t\\t\\tcnt += 1\\n\\n\\t\\tif freq_most_letter > 1 and res[-2] == most_freq_letter:\\n\\t\\t\\treturn \"\"\\n\\t\\telse:\\n\\t\\t\\treturn \"\".join(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\tdef reorganizeString(self, S):\\n\\t\\t\"\"\"\\n\\t\\t:type S: str\\n\\t\\t:rtype: str\\n\\t\\t\"\"\"\\n\\t\\tfrom collections import Counter\\n\\n\\t\\t# sorted letter -> freq\\n\\t\\tletter_cnt = Counter(S).most_common(len(S))\\n\\n\\t\\t# As task scheduler, use most common letter as separator\\n\\t\\tmost_freq_letter, freq_most_letter = letter_cnt[0][0], letter_cnt[0][1]\\n\\t\\tres = [most_freq_letter] * freq_most_letter\\n\\n\\t\\tcnt = 0\\n\\t\\tfor letter, freq in letter_cnt[1:]:\\n\\t\\t\\tfor idx in range(freq):\\n\\t\\t\\t\\tres[cnt % freq_most_letter] += letter\\n\\t\\t\\t\\tcnt += 1\\n\\n\\t\\tif freq_most_letter > 1 and res[-2] == most_freq_letter:\\n\\t\\t\\treturn \"\"\\n\\t\\telse:\\n\\t\\t\\treturn \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113856,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string S) {\\n        unordered_map<char,int> pool;\\n        int cnt = 0;\\n        for(auto e : S)\\n        {\\n            pool[e]++;\\n            cnt = max(cnt, pool[e]);\\n        }\\n        if(cnt > (S.size()+1) / 2) return \"\";\\n        \\n        priority_queue<pair<int,char>>pq;\\n        for(auto e : pool)\\n            pq.push({e.second, e.first});\\n        \\n        int idx = 0;\\n        while(!pq.empty())\\n        {\\n            auto e = pq.top();\\n            pq.pop();\\n            while(e.first > 0)\\n            {\\n                e.first--;\\n                S[idx] = e.second;\\n                idx += 2;\\n                if(idx >= S.size()) idx = 1;\\n            }\\n        }\\n        \\n        return S;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string reorganizeString(string S) {\\n        unordered_map<char,int> pool;\\n        int cnt = 0;\\n        for(auto e : S)\\n        {\\n            pool[e]++;\\n            cnt = max(cnt, pool[e]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3949519,
                "title": "c-solution-priority-queue-100-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int len= s.length();\\n        vector<int>v(26,0);\\n\\n        for(auto x: s)\\n        {\\n            v[x-\\'a\\']++;\\n            if(v[x-\\'a\\']>(len+1)/2)\\n            return \"\";\\n        }\\n\\n        priority_queue<pair<int,char>>pq;\\n\\n        for(char i=\\'a\\'; i<=\\'z\\'; i++)\\n        {\\n            if(v[i-\\'a\\']>0)\\n            pq.emplace(v[i-\\'a\\'],i);\\n        }\\n        \\n        string ans=\"\";\\n        while(pq.size()>=2)\\n        {\\n            auto p1= pq.top();\\n            pq.pop();\\n            auto p2= pq.top();\\n            pq.pop();\\n\\n            ans+=p1.second;\\n            p1.first--;\\n            ans+=p2.second;\\n            p2.first--;\\n\\n            if(p1.first>0)\\n            {\\n                pq.emplace(p1.first, p1.second);\\n            }\\n            if(p2.first>0)\\n            {\\n                pq.emplace(p2.first, p2.second);\\n            }\\n\\n        }\\n\\n        if(!pq.empty())\\n        {\\n            auto p3= pq.top();\\n            ans+= p3.second;\\n            pq.pop();\\n        }\\n\\n        return ans;\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int len= s.length();\\n        vector<int>v(26,0);\\n\\n        for(auto x: s)\\n        {\\n            v[x-\\'a\\']++;\\n            if(v[x-\\'a\\']>(len+1)/2)\\n            return \"\";\\n        }\\n\\n        priority_queue<pair<int,char>>pq;\\n\\n        for(char i=\\'a\\'; i<=\\'z\\'; i++)\\n        {\\n            if(v[i-\\'a\\']>0)\\n            pq.emplace(v[i-\\'a\\'],i);\\n        }\\n        \\n        string ans=\"\";\\n        while(pq.size()>=2)\\n        {\\n            auto p1= pq.top();\\n            pq.pop();\\n            auto p2= pq.top();\\n            pq.pop();\\n\\n            ans+=p1.second;\\n            p1.first--;\\n            ans+=p2.second;\\n            p2.first--;\\n\\n            if(p1.first>0)\\n            {\\n                pq.emplace(p1.first, p1.second);\\n            }\\n            if(p2.first>0)\\n            {\\n                pq.emplace(p2.first, p2.second);\\n            }\\n\\n        }\\n\\n        if(!pq.empty())\\n        {\\n            auto p3= pq.top();\\n            ans+= p3.second;\\n            pq.pop();\\n        }\\n\\n        return ans;\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949172,
                "title": "c-simple-solution-no-sort-o-n-0ms-beats-100",
                "content": "# Intuition\\nThere is a valid permutation if and only if the count of the character with the largest occurence is `less than or equal` to `(S.size() + 1) / 2`.\\n\\n# Approach\\n1. Count the occurences of all letters and store in count[i].\\n2. Find the letter with largest occurence.\\n3. Put this letter into even index numbers (0, 2, 4 ...) char array.\\n4. Put the rest letters into the array.\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n\\n- Space complexity: `O(n+26)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int count[26] = {0};\\n        int n = s.size();\\n        for (int i=0; i<n; i++) {\\n            count[s[i]-\\'a\\']++;\\n        }\\n        int maxCount = 0, letter;\\n        for (int i=0; i<26; i++) {\\n            if (count[i] > maxCount) {\\n                maxCount = count[i];\\n                letter = i;\\n            }\\n        }\\n        if (maxCount > (n+1)/2) {\\n            return \"\";\\n        }\\n        char arr[n];\\n        int idx = 0;\\n        while (count[letter] > 0) {\\n            arr[idx] = \\'a\\' + letter;\\n            idx += 2;\\n            count[letter]--;\\n        }\\n        for (int i=0; i<26; i++) {\\n            while (count[i] > 0) {\\n                if (idx >= n) {\\n                    idx = 1;\\n                }\\n                arr[idx] = \\'a\\' + i;\\n                idx += 2;\\n                count[i]--;\\n            }\\n        }\\n        string res;\\n        for (int i=0; i<n; i++) {\\n            res += arr[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int count[26] = {0};\\n        int n = s.size();\\n        for (int i=0; i<n; i++) {\\n            count[s[i]-\\'a\\']++;\\n        }\\n        int maxCount = 0, letter;\\n        for (int i=0; i<26; i++) {\\n            if (count[i] > maxCount) {\\n                maxCount = count[i];\\n                letter = i;\\n            }\\n        }\\n        if (maxCount > (n+1)/2) {\\n            return \"\";\\n        }\\n        char arr[n];\\n        int idx = 0;\\n        while (count[letter] > 0) {\\n            arr[idx] = \\'a\\' + letter;\\n            idx += 2;\\n            count[letter]--;\\n        }\\n        for (int i=0; i<26; i++) {\\n            while (count[i] > 0) {\\n                if (idx >= n) {\\n                    idx = 1;\\n                }\\n                arr[idx] = \\'a\\' + i;\\n                idx += 2;\\n                count[i]--;\\n            }\\n        }\\n        string res;\\n        for (int i=0; i<n; i++) {\\n            res += arr[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948153,
                "title": "easy-java-solution-interview-question-priority-queue-and-hash-map-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public class Pair {\\n        char ch;\\n        int freq;\\n\\n        Pair(char ch, int freq){\\n            this.ch = ch;\\n            this.freq = freq;\\n        }\\n\\n    }\\n\\n\\n    public String reorganizeString(String s) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n\\n        for(int i = 0; i < s.length(); i++){\\n            map.put(s.charAt(i) , map.getOrDefault(s.charAt(i), 0) + 1 );\\n        }\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> b.freq - a.freq);\\n\\n        for(Map.Entry<Character, Integer> e : map.entrySet()){\\n            pq.add(new Pair(e.getKey() , e.getValue() ));\\n        }\\n\\n        Pair prev = new Pair(\\'#\\', -1);\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        while(!pq.isEmpty()){\\n            Pair curr = pq.poll();\\n            sb.append(curr.ch);\\n            curr.freq--;\\n\\n            if(prev.freq > 0){\\n                pq.add(prev);\\n            }\\n\\n            prev =curr;\\n        }\\n\\n        if(sb.length() != s.length()) return \"\";\\n        return sb.toString();\\n\\n\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public class Pair {\\n        char ch;\\n        int freq;\\n\\n        Pair(char ch, int freq){\\n            this.ch = ch;\\n            this.freq = freq;\\n        }\\n\\n    }\\n\\n\\n    public String reorganizeString(String s) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n\\n        for(int i = 0; i < s.length(); i++){\\n            map.put(s.charAt(i) , map.getOrDefault(s.charAt(i), 0) + 1 );\\n        }\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> b.freq - a.freq);\\n\\n        for(Map.Entry<Character, Integer> e : map.entrySet()){\\n            pq.add(new Pair(e.getKey() , e.getValue() ));\\n        }\\n\\n        Pair prev = new Pair(\\'#\\', -1);\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        while(!pq.isEmpty()){\\n            Pair curr = pq.poll();\\n            sb.append(curr.ch);\\n            curr.freq--;\\n\\n            if(prev.freq > 0){\\n                pq.add(prev);\\n            }\\n\\n            prev =curr;\\n        }\\n\\n        if(sb.length() != s.length()) return \"\";\\n        return sb.toString();\\n\\n\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948115,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        n=len(s)\\n        freq=dict()\\n        for ch in s:\\n            freq[ch]=1+freq.get(ch,0)\\n\\n        hp=[(-v,k) for k,v in freq.items()]  \\n        heapify(hp)\\n\\n        i=0\\n        ans=[\"\"]*n  \\n        while hp:\\n            v,k=heappop(hp)\\n            v=-v\\n            if 2*v-1>n:\\n                return \"\"\\n\\n            for _ in range(v):\\n                ans[i]=k\\n                i=i+2 if i+2<n else 1  \\n\\n        return \"\".join(ans)          \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        n=len(s)\\n        freq=dict()\\n        for ch in s:\\n            freq[ch]=1+freq.get(ch,0)\\n\\n        hp=[(-v,k) for k,v in freq.items()]  \\n        heapify(hp)\\n\\n        i=0\\n        ans=[\"\"]*n  \\n        while hp:\\n            v,k=heappop(hp)\\n            v=-v\\n            if 2*v-1>n:\\n                return \"\"\\n\\n            for _ in range(v):\\n                ans[i]=k\\n                i=i+2 if i+2<n else 1  \\n\\n        return \"\".join(ans)          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948053,
                "title": "c-solution-for-reorganize-string-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires rearranging the characters in a string so that no two adjacent characters are the same. One way to approach this is to prioritize the characters based on their frequencies and try to place the most frequent characters apart from each other. Using a max-heap (priority queue) allows us to efficiently process and place characters with higher frequencies first.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First, we count the frequency of each character in the input string s.\\n\\n1. We create a max-heap (priority queue) and enqueue each character along with its frequency.\\n\\n1. While the max-heap is not empty:\\na. Dequeue the character with the highest frequency.\\nb. Append the character to the result string.\\nc. If the previously dequeued character\\'s frequency is greater than 0, enqueue it again.\\nd. Decrement the frequency of the currently dequeued character.\\n\\n1. If the length of the result string matches the length of the input string, we have successfully rearranged the characters. Otherwise, it\\'s not possible to rearrange the characters to meet the requirement.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nLet n be the length of the input string s.\\n\\n- Counting character frequencies takes O(n) time.\\n- Enqueuing all characters into the max-heap takes O(26 * log n) time in the worst case (where 26 is the number of lowercase English letters), which simplifies to O(log n) since constants are dropped.\\n- The loop that dequeues characters runs at most n times, and each dequeue operation takes O(log n) time.\\n- Constructing the result string from characters takes O(n) time.\\n- Overall, the time complexity is dominated by the max-heap operations and is approximately O(n * log n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- We use an array charCount to store character frequencies, which takes O(26) = O(1) space.\\n- The max-heap can hold at most 26 characters, which results in O(26) = O(1) space.\\n- The result string takes O(n) space.\\n- The custom PriorityQueue implementation uses a list to store the heap, which also takes O(n) space.\\nOverall, the space complexity is O(n).\\n\\n# Code\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Text;\\n\\npublic class Solution {\\n    public string ReorganizeString(string s) {\\n        int n = s.Length;\\n        int[] charCount = new int[26];\\n        foreach (char c in s) {\\n            charCount[c - \\'a\\']++;\\n        }\\n        \\n        PriorityQueue<(char, int)> maxHeap = new PriorityQueue<(char, int)>((a, b) => b.Item2.CompareTo(a.Item2));\\n        for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            if (charCount[c - \\'a\\'] > 0) {\\n                maxHeap.Enqueue((c, charCount[c - \\'a\\']));\\n            }\\n        }\\n        \\n        StringBuilder result = new StringBuilder();\\n        (char, int) prev = (\\'#\\', -1);\\n        \\n        while (maxHeap.Count > 0) {\\n            var current = maxHeap.Dequeue();\\n            result.Append(current.Item1);\\n            \\n            if (prev.Item2 > 0) {\\n                maxHeap.Enqueue(prev);\\n            }\\n            \\n            current.Item2--;\\n            prev = current;\\n        }\\n        \\n        if (n == result.Length) {\\n            return result.ToString();\\n        }\\n        \\n        return \"\";\\n    }\\n}\\n\\npublic class PriorityQueue<T> {\\n    private List<T> heap;\\n    private Comparison<T> comparison;\\n    \\n    public int Count { get { return heap.Count; } }\\n    \\n    public PriorityQueue(Comparison<T> comparison) {\\n        this.heap = new List<T>();\\n        this.comparison = comparison;\\n    }\\n    \\n    public void Enqueue(T item) {\\n        heap.Add(item);\\n        int currentIndex = heap.Count - 1;\\n        \\n        while (currentIndex > 0) {\\n            int parentIndex = (currentIndex - 1) / 2;\\n            if (comparison(heap[parentIndex], heap[currentIndex]) <= 0) {\\n                break;\\n            }\\n            \\n            T tmp = heap[parentIndex];\\n            heap[parentIndex] = heap[currentIndex];\\n            heap[currentIndex] = tmp;\\n            \\n            currentIndex = parentIndex;\\n        }\\n    }\\n    \\n    public T Dequeue() {\\n        if (heap.Count == 0) {\\n            throw new InvalidOperationException(\"PriorityQueue is empty.\");\\n        }\\n        \\n        T result = heap[0];\\n        heap[0] = heap[heap.Count - 1];\\n        heap.RemoveAt(heap.Count - 1);\\n        \\n        int currentIndex = 0;\\n        while (true) {\\n            int leftChildIndex = 2 * currentIndex + 1;\\n            int rightChildIndex = 2 * currentIndex + 2;\\n            int smallestChildIndex = currentIndex;\\n            \\n            if (leftChildIndex < heap.Count && comparison(heap[leftChildIndex], heap[smallestChildIndex]) < 0) {\\n                smallestChildIndex = leftChildIndex;\\n            }\\n            \\n            if (rightChildIndex < heap.Count && comparison(heap[rightChildIndex], heap[smallestChildIndex]) < 0) {\\n                smallestChildIndex = rightChildIndex;\\n            }\\n            \\n            if (smallestChildIndex == currentIndex) {\\n                break;\\n            }\\n            \\n            T tmp = heap[currentIndex];\\n            heap[currentIndex] = heap[smallestChildIndex];\\n            heap[smallestChildIndex] = tmp;\\n            \\n            currentIndex = smallestChildIndex;\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Text;\\n\\npublic class Solution {\\n    public string ReorganizeString(string s) {\\n        int n = s.Length;\\n        int[] charCount = new int[26];\\n        foreach (char c in s) {\\n            charCount[c - \\'a\\']++;\\n        }\\n        \\n        PriorityQueue<(char, int)> maxHeap = new PriorityQueue<(char, int)>((a, b) => b.Item2.CompareTo(a.Item2));\\n        for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            if (charCount[c - \\'a\\'] > 0) {\\n                maxHeap.Enqueue((c, charCount[c - \\'a\\']));\\n            }\\n        }\\n        \\n        StringBuilder result = new StringBuilder();\\n        (char, int) prev = (\\'#\\', -1);\\n        \\n        while (maxHeap.Count > 0) {\\n            var current = maxHeap.Dequeue();\\n            result.Append(current.Item1);\\n            \\n            if (prev.Item2 > 0) {\\n                maxHeap.Enqueue(prev);\\n            }\\n            \\n            current.Item2--;\\n            prev = current;\\n        }\\n        \\n        if (n == result.Length) {\\n            return result.ToString();\\n        }\\n        \\n        return \"\";\\n    }\\n}\\n\\npublic class PriorityQueue<T> {\\n    private List<T> heap;\\n    private Comparison<T> comparison;\\n    \\n    public int Count { get { return heap.Count; } }\\n    \\n    public PriorityQueue(Comparison<T> comparison) {\\n        this.heap = new List<T>();\\n        this.comparison = comparison;\\n    }\\n    \\n    public void Enqueue(T item) {\\n        heap.Add(item);\\n        int currentIndex = heap.Count - 1;\\n        \\n        while (currentIndex > 0) {\\n            int parentIndex = (currentIndex - 1) / 2;\\n            if (comparison(heap[parentIndex], heap[currentIndex]) <= 0) {\\n                break;\\n            }\\n            \\n            T tmp = heap[parentIndex];\\n            heap[parentIndex] = heap[currentIndex];\\n            heap[currentIndex] = tmp;\\n            \\n            currentIndex = parentIndex;\\n        }\\n    }\\n    \\n    public T Dequeue() {\\n        if (heap.Count == 0) {\\n            throw new InvalidOperationException(\"PriorityQueue is empty.\");\\n        }\\n        \\n        T result = heap[0];\\n        heap[0] = heap[heap.Count - 1];\\n        heap.RemoveAt(heap.Count - 1);\\n        \\n        int currentIndex = 0;\\n        while (true) {\\n            int leftChildIndex = 2 * currentIndex + 1;\\n            int rightChildIndex = 2 * currentIndex + 2;\\n            int smallestChildIndex = currentIndex;\\n            \\n            if (leftChildIndex < heap.Count && comparison(heap[leftChildIndex], heap[smallestChildIndex]) < 0) {\\n                smallestChildIndex = leftChildIndex;\\n            }\\n            \\n            if (rightChildIndex < heap.Count && comparison(heap[rightChildIndex], heap[smallestChildIndex]) < 0) {\\n                smallestChildIndex = rightChildIndex;\\n            }\\n            \\n            if (smallestChildIndex == currentIndex) {\\n                break;\\n            }\\n            \\n            T tmp = heap[currentIndex];\\n            heap[currentIndex] = heap[smallestChildIndex];\\n            heap[smallestChildIndex] = tmp;\\n            \\n            currentIndex = smallestChildIndex;\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947915,
                "title": "beats-100-why-priority-queue-maxheap",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo be able to make striong with non-adjacent elemtns we have to count the frequency of the elements and then place the most frequent elements first, for example in case of \"aab\" frequency of a = 2, b = 1. So we first place a->b->a to make a non-adjacent string. \\n\\nBut the approach of just putting the most frequent element first does not work. For example, for frequency a = 3, b = 1, c = 1, if we put most frequent element first followed by each of other element, we will end up with \"abcaa\" which gives us the wrong answer. \\n\\nInstead of that we just have to put a hold on the previous element that we just used. We can select the next most frequent element excpet prev. Doing that for frequency a = 3, b = 1, c = 1, we will end up with \"abaca\"\\n# Why Priority Queue ?\\nWe\\'re also going to have to keep track of which a previous value we use so that we don\\'t reuse the same value two times in a row. But the time complexity doing that with a hash map scanning through it each time is going to be roughly n^2 in the worst case. So instead, to find the most frequent, we can use heap. In this case, since we want most frequent element, we use a MaxHeap since it stores the maximum count. And thus we can do this in $$O(logn)$$ complexity. \\n\\n# Complexity\\n- Time complexity: $$O(k*logn)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        vector<int> chrCounts(26);\\n        for (auto& chr : s)     chrCounts[chr - \\'a\\']++;\\n    \\n        priority_queue<pair<int, char>> max_heap;\\n        for (int i = 0; i < 26; i++) {\\n            if (chrCounts[i] > 0) {\\n                max_heap.push({chrCounts[i], \\'a\\' + i});\\n            }\\n        }\\n\\n        string result = \"\";\\n        pair<int, char> prev = max_heap.top();\\n        max_heap.pop();\\n        result += prev.second;\\n        while (!max_heap.empty()) {\\n            pair<int, char> curr = max_heap.top();\\n            max_heap.pop();\\n            result += curr.second;\\n            if (--prev.first > 0) max_heap.push(prev);\\n            prev = curr;\\n        }\\n\\n        if (result.size() != s.size())   return \"\";\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        vector<int> chrCounts(26);\\n        for (auto& chr : s)     chrCounts[chr - \\'a\\']++;\\n    \\n        priority_queue<pair<int, char>> max_heap;\\n        for (int i = 0; i < 26; i++) {\\n            if (chrCounts[i] > 0) {\\n                max_heap.push({chrCounts[i], \\'a\\' + i});\\n            }\\n        }\\n\\n        string result = \"\";\\n        pair<int, char> prev = max_heap.top();\\n        max_heap.pop();\\n        result += prev.second;\\n        while (!max_heap.empty()) {\\n            pair<int, char> curr = max_heap.top();\\n            max_heap.pop();\\n            result += curr.second;\\n            if (--prev.first > 0) max_heap.push(prev);\\n            prev = curr;\\n        }\\n\\n        if (result.size() != s.size())   return \"\";\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613006,
                "title": "c-max-heap-priority-queue-detailed-explanation",
                "content": "# Approach\\n- Highest frequency element needs to be placed first. Hence we will make a max heap which will store the characters in order of maximum frequency. \\n- If the last placed character and the top character of heap are same then we try to place the next character in heap, we then reduce the frequency of the placed character and if frequency of the placed character is >0 we again push the character and it\\'s frequency in the heap. \\n- We do this until the heap becomes empty. And if at any point we cannot place the first and second character of the heap in our answer, we return **\"\"** (empty string) .\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        map<char,int> m;\\n        for(auto &i:s)\\n        m[i]++;\\n        priority_queue<pair<int,char>> pq;\\n        for(auto &i:m)\\n        {\\n            pq.push({i.second,i.first});\\n        }\\n        string ans = \"\";\\n        while(!pq.empty())\\n        {\\n            int fre = pq.top().first;\\n            char c = pq.top().second;\\n            pq.pop();\\n            if(ans.size()==0)\\n            {\\n                ans+=c;\\n                fre--;\\n                if(fre>0)\\n                pq.push({fre,c});\\n            }\\n            else if(ans[ans.size()-1]==c)\\n            {\\n                if(pq.size()==0)\\n                return \"\";\\n                char c1 = pq.top().second;\\n                int fre1 = pq.top().first;\\n                pq.pop();\\n                ans+=c1;\\n                fre1--;\\n                pq.push({fre,c});\\n                if(fre1>0)\\n                pq.push({fre1,c1});\\n            }\\n            else\\n            {\\n                ans+=c;\\n                fre--;\\n                if(fre>0)\\n                pq.push({fre,c});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        map<char,int> m;\\n        for(auto &i:s)\\n        m[i]++;\\n        priority_queue<pair<int,char>> pq;\\n        for(auto &i:m)\\n        {\\n            pq.push({i.second,i.first});\\n        }\\n        string ans = \"\";\\n        while(!pq.empty())\\n        {\\n            int fre = pq.top().first;\\n            char c = pq.top().second;\\n            pq.pop();\\n            if(ans.size()==0)\\n            {\\n                ans+=c;\\n                fre--;\\n                if(fre>0)\\n                pq.push({fre,c});\\n            }\\n            else if(ans[ans.size()-1]==c)\\n            {\\n                if(pq.size()==0)\\n                return \"\";\\n                char c1 = pq.top().second;\\n                int fre1 = pq.top().first;\\n                pq.pop();\\n                ans+=c1;\\n                fre1--;\\n                pq.push({fre,c});\\n                if(fre1>0)\\n                pq.push({fre1,c1});\\n            }\\n            else\\n            {\\n                ans+=c;\\n                fre--;\\n                if(fre>0)\\n                pq.push({fre,c});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489084,
                "title": "python-o-n-easy-solution-with-detailed-explanations",
                "content": "\\n```\\n#comments explain thought process if s = \"abbaacaca\"  \\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        S, count = len(s), Counter(s)  # count = { \"a\": 5, \"b\": 2, \"c\", 2 }\\n        max_char, max_count = max(count.items(), key=lambda x: x[1])  # get the character with the most entries\\n\\t\\t\\n\\t\\t# return empty string if arrangement not possible\\n\\t\\t# I derived this equation by thinking whether an arrangement would be possible if len(s) is odd and even respectively\\n        if max_count > (S+1) // 2: return \"\"  \\n        \\n\\t\\t# max_char = \"a\" and max_count = 5, we create the following list: [ \"a\", \"a\", \"a\", \"a\", \"a\" ]\\n        res = [max_char for _ in range(max_count)]\\n        \\n\\t\\t# for every other character, we slot them into each string in the list, starting from index 0 to the end, then cycling back to 0\\n        i = 0\\n        for k,v in count.items():\\n            if k == max_char: continue  # we have already added \"a\" to res so we do not add it again\\n            for _ in range(v):\\n                res[i] += k  # string += is optimised in python to be O(1) when adding a character, using a list works as well\\n                i = i + 1 if i != len(res) - 1 else 0  # move to the next index in res, cycling from the start if the end has been reached\\n\\t\\t\\t\\t\\n\\t\\t# res = [\"ab\", \"ab\", \"ac\", \"ac\", \"a\"]\\n\\t\\t# \"a\" will not be next to another \"a\" because we are slotting characters in between each \"a\"\\n\\t\\t# same goes for any other chracter because there will be an \"a\" seperating them \\n\\t\\t\\n        return \\'\\'.join(res)\\n```\\n\\nTime: O(N)\\nSpace: O(N)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n#comments explain thought process if s = \"abbaacaca\"  \\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        S, count = len(s), Counter(s)  # count = { \"a\": 5, \"b\": 2, \"c\", 2 }\\n        max_char, max_count = max(count.items(), key=lambda x: x[1])  # get the character with the most entries\\n\\t\\t\\n\\t\\t# return empty string if arrangement not possible\\n\\t\\t# I derived this equation by thinking whether an arrangement would be possible if len(s) is odd and even respectively\\n        if max_count > (S+1) // 2: return \"\"  \\n        \\n\\t\\t# max_char = \"a\" and max_count = 5, we create the following list: [ \"a\", \"a\", \"a\", \"a\", \"a\" ]\\n        res = [max_char for _ in range(max_count)]\\n        \\n\\t\\t# for every other character, we slot them into each string in the list, starting from index 0 to the end, then cycling back to 0\\n        i = 0\\n        for k,v in count.items():\\n            if k == max_char: continue  # we have already added \"a\" to res so we do not add it again\\n            for _ in range(v):\\n                res[i] += k  # string += is optimised in python to be O(1) when adding a character, using a list works as well\\n                i = i + 1 if i != len(res) - 1 else 0  # move to the next index in res, cycling from the start if the end has been reached\\n\\t\\t\\t\\t\\n\\t\\t# res = [\"ab\", \"ab\", \"ac\", \"ac\", \"a\"]\\n\\t\\t# \"a\" will not be next to another \"a\" because we are slotting characters in between each \"a\"\\n\\t\\t# same goes for any other chracter because there will be an \"a\" seperating them \\n\\t\\t\\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487921,
                "title": "beats-100-c-code",
                "content": "# Intuition\\nM1 : You can solve using priority queue...\\n\\n**M2 :** Greedy:\\n    A) Find most occurant character...\\n    B)Fit it non-adjacently\\n    C)fill the rest character\\n\\n# Approach\\n//step 1 : Make the hash and store the frequency of hash\\n\\n// step 2: Find the most frequent character...\\n\\n// step 3 : Placing to the correct position...\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) \\n    {\\n    \\n    //step 1 : Make the hash and store the frequency of hash\\n     int hash[26] = {0};      \\n     \\n     for(int i=0;i<s.size();i++)\\n     {\\n         hash[s[i]-\\'a\\']++; //increases the count of the character in hash...\\n     } //O(n)\\n\\n     // step 2: Find the most frequent character...\\n       char most_freq_char;\\n       int max_freq;\\n\\n       for(int i=0;i<26;i++)\\n       {\\n           if(hash[i] > max_freq)\\n           {\\n               max_freq = hash[i];\\n               most_freq_char = i+\\'a\\';// i starts from 0 but we want most occurant character which is starts from ASCII 97 thats why we add \\'a\\'...\\n           }\\n       }   //O(1) -->we can ignore\\n\\n    // step 3 : Placing to the correct position...\\n    int index=0;\\n\\n    while(max_freq>0 && index < s.size()) // tab tak place kro jab tak max_freq 0 nahi ho jati AND index string ke under ho...\\n    {\\n        s[index] = most_freq_char;\\n        max_freq--;\\n        index = index+2;\\n    } \\n\\n    //If all the most_freq_char elements are placed then max_freq is 0 ->no problem but max_freq is !=0 then problem hai bhai...\\n    if(max_freq !=0) \\n    {\\n        return \"\";\\n    }\\n\\n    //Now if the most_freq_char placed correctly ..Now for remaining elemnts\\n    \\n    hash[most_freq_char-\\'a\\'] = 0;//most freq char place ho chuka hai ab ghar jaa\\n\\n    //lets play the rest of the characters...\\n   \\n    for(int i=0;i<26;i++)\\n    {\\n        while(hash[i] > 0) //place elements have index 0...\\n        {\\n            index = index>=s.size()?1:index;\\n            s[index] = i+\\'a\\';\\n            hash[i]--;//after placing the character decrement its frequency...\\n            index = index+2;\\n        }\\n    } //O(26*n)~O(n)\\n      return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) \\n    {\\n    \\n    //step 1 : Make the hash and store the frequency of hash\\n     int hash[26] = {0};      \\n     \\n     for(int i=0;i<s.size();i++)\\n     {\\n         hash[s[i]-\\'a\\']++; //increases the count of the character in hash...\\n     } //O(n)\\n\\n     // step 2: Find the most frequent character...\\n       char most_freq_char;\\n       int max_freq;\\n\\n       for(int i=0;i<26;i++)\\n       {\\n           if(hash[i] > max_freq)\\n           {\\n               max_freq = hash[i];\\n               most_freq_char = i+\\'a\\';// i starts from 0 but we want most occurant character which is starts from ASCII 97 thats why we add \\'a\\'...\\n           }\\n       }   //O(1) -->we can ignore\\n\\n    // step 3 : Placing to the correct position...\\n    int index=0;\\n\\n    while(max_freq>0 && index < s.size()) // tab tak place kro jab tak max_freq 0 nahi ho jati AND index string ke under ho...\\n    {\\n        s[index] = most_freq_char;\\n        max_freq--;\\n        index = index+2;\\n    } \\n\\n    //If all the most_freq_char elements are placed then max_freq is 0 ->no problem but max_freq is !=0 then problem hai bhai...\\n    if(max_freq !=0) \\n    {\\n        return \"\";\\n    }\\n\\n    //Now if the most_freq_char placed correctly ..Now for remaining elemnts\\n    \\n    hash[most_freq_char-\\'a\\'] = 0;//most freq char place ho chuka hai ab ghar jaa\\n\\n    //lets play the rest of the characters...\\n   \\n    for(int i=0;i<26;i++)\\n    {\\n        while(hash[i] > 0) //place elements have index 0...\\n        {\\n            index = index>=s.size()?1:index;\\n            s[index] = i+\\'a\\';\\n            hash[i]--;//after placing the character decrement its frequency...\\n            index = index+2;\\n        }\\n    } //O(26*n)~O(n)\\n      return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460098,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n public:\\n  string reorganizeString(string s) {\\n    unordered_map<char, int> count;\\n    int maxFreq = 0;\\n\\n    for (const char c : s)\\n      maxFreq = max(maxFreq, ++count[c]);\\n\\n    if (maxFreq > (s.length() + 1) / 2)\\n      return \"\";\\n\\n    string ans;\\n    priority_queue<pair<int, char>> maxHeap;  // (freq, c)\\n    int prevFreq = 0;\\n    char prevChar = \\'@\\';\\n\\n    for (const auto& [c, freq] : count)\\n      maxHeap.emplace(freq, c);\\n\\n    while (!maxHeap.empty()) {\\n      const auto [freq, c] = maxHeap.top();\\n      maxHeap.pop();\\n      ans += c;\\n      if (prevFreq > 0)\\n        maxHeap.emplace(prevFreq, prevChar);\\n      prevFreq = freq - 1;\\n      prevChar = c;\\n    }\\n    return ans;\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution(object):\\n    def reorganizeString(self, s):\\n        d = Counter(s)\\n        if max(d.values()) > ceil(len(s)/2):\\n            return \\'\\'\\n        res = [\\' \\']*len(s)\\n        c=d.most_common()\\n        i=0\\n        for e in c:\\n            for j in range(e[1]):\\n                res[i]=e[0]\\n                i+=2\\n                if i>=len(s):\\n                    i=1\\n        return \\'\\'.join(res)\\n```\\n\\n```Java []\\nclass Solution {\\n    public String reorganizeString(String s) {\\n        int [] freq = new int[26];\\n        char [] arr = s.toCharArray();\\n        \\n        for(int i = 0;i<arr.length;i++){\\n            freq[arr[i] - \\'a\\']++;\\n        }\\n        int max = 0,letter = 0;\\n        for(int i = 0;i<26;i++){\\n            if(freq[i] > max){\\n                max = freq[i];\\n                letter = i;\\n            }\\n        }\\n        if(max > (s.length() + 1)/2) return \"\";\\n        int idx = 0;\\n        char [] res = new char[s.length()];\\n        while(freq[letter] > 0){\\n            res[idx] = (char)(letter + \\'a\\');\\n            idx += 2;\\n            freq[letter]--;\\n        }\\n        for(int i = 0;i<26;i++){  \\n            while(freq[i] > 0){\\n            if(idx >= s.length()) idx = 1;\\n            res[idx] = (char)(i + \\'a\\');\\n            idx += 2;\\n            freq[i]--;\\n          }\\n        }\\n        return String.valueOf(res);  \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n public:\\n  string reorganizeString(string s) {\\n    unordered_map<char, int> count;\\n    int maxFreq = 0;\\n\\n    for (const char c : s)\\n      maxFreq = max(maxFreq, ++count[c]);\\n\\n    if (maxFreq > (s.length() + 1) / 2)\\n      return \"\";\\n\\n    string ans;\\n    priority_queue<pair<int, char>> maxHeap;  // (freq, c)\\n    int prevFreq = 0;\\n    char prevChar = \\'@\\';\\n\\n    for (const auto& [c, freq] : count)\\n      maxHeap.emplace(freq, c);\\n\\n    while (!maxHeap.empty()) {\\n      const auto [freq, c] = maxHeap.top();\\n      maxHeap.pop();\\n      ans += c;\\n      if (prevFreq > 0)\\n        maxHeap.emplace(prevFreq, prevChar);\\n      prevFreq = freq - 1;\\n      prevChar = c;\\n    }\\n    return ans;\\n  }\\n};\\n```\n```Python3 []\\nclass Solution(object):\\n    def reorganizeString(self, s):\\n        d = Counter(s)\\n        if max(d.values()) > ceil(len(s)/2):\\n            return \\'\\'\\n        res = [\\' \\']*len(s)\\n        c=d.most_common()\\n        i=0\\n        for e in c:\\n            for j in range(e[1]):\\n                res[i]=e[0]\\n                i+=2\\n                if i>=len(s):\\n                    i=1\\n        return \\'\\'.join(res)\\n```\n```Java []\\nclass Solution {\\n    public String reorganizeString(String s) {\\n        int [] freq = new int[26];\\n        char [] arr = s.toCharArray();\\n        \\n        for(int i = 0;i<arr.length;i++){\\n            freq[arr[i] - \\'a\\']++;\\n        }\\n        int max = 0,letter = 0;\\n        for(int i = 0;i<26;i++){\\n            if(freq[i] > max){\\n                max = freq[i];\\n                letter = i;\\n            }\\n        }\\n        if(max > (s.length() + 1)/2) return \"\";\\n        int idx = 0;\\n        char [] res = new char[s.length()];\\n        while(freq[letter] > 0){\\n            res[idx] = (char)(letter + \\'a\\');\\n            idx += 2;\\n            freq[letter]--;\\n        }\\n        for(int i = 0;i<26;i++){  \\n            while(freq[i] > 0){\\n            if(idx >= s.length()) idx = 1;\\n            res[idx] = (char)(i + \\'a\\');\\n            idx += 2;\\n            freq[i]--;\\n          }\\n        }\\n        return String.valueOf(res);  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742655,
                "title": "easy-best-solution-in-c-priorityqueue",
                "content": "# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int size=s.size();\\n        if(size==1)\\n            return s;\\n        unordered_map<char,int> mp;\\n        string ans=\"\";\\n        for(auto it:s)\\n            mp[it]++;\\n        if(mp.size()==1)\\n            return \"\";\\n        priority_queue<pair<int,char>> pq;   //max priorityQueue\\n        for(auto it:mp)\\n            pq.push({it.second,it.first});\\n        pair<int,char> pr=pq.top();\\n        pq.pop();\\n        ans+=pr.second;\\n        pr.first--;\\n        while(pq.top().first){\\n            pair<int,char> p=pq.top();\\n            pq.pop();\\n            ans+=p.second;\\n            p.first--;\\n            pq.push(pr);\\n            pr=p;\\n        }\\n        if(ans.size()==size)\\n            return ans;\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int size=s.size();\\n        if(size==1)\\n            return s;\\n        unordered_map<char,int> mp;\\n        string ans=\"\";\\n        for(auto it:s)\\n            mp[it]++;\\n        if(mp.size()==1)\\n            return \"\";\\n        priority_queue<pair<int,char>> pq;   //max priorityQueue\\n        for(auto it:mp)\\n            pq.push({it.second,it.first});\\n        pair<int,char> pr=pq.top();\\n        pq.pop();\\n        ans+=pr.second;\\n        pr.first--;\\n        while(pq.top().first){\\n            pair<int,char> p=pq.top();\\n            pq.pop();\\n            ans+=p.second;\\n            p.first--;\\n            pq.push(pr);\\n            pr=p;\\n        }\\n        if(ans.size()==size)\\n            return ans;\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2509667,
                "title": "767-reorganize-string-solution",
                "content": "<iframe src=\"https://leetcode.com/playground/fdqyHDyt/shared\" frameBorder=\"0\" width=\"750\" height=\"750\"></iframe>",
                "solutionTags": [
                    "C"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/fdqyHDyt/shared\" frameBorder=\"0\" width=\"750\" height=\"750\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2410235,
                "title": "python-solution",
                "content": "# class Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        heap = [[-v, k] for k, v in collections.Counter(s).items()]\\n        heapq.heapify(heap)\\n        ans = \"\"\\n        \\n        while len(heap) > 1:\\n            a, ak = heapq.heappop(heap)\\n            b, bk = heapq.heappop(heap)\\n            ans += ak + bk\\n            a, b = -a, -b\\n            if a - 1 > 0:heapq.heappush(heap, [-(a-1),ak])\\n            if b - 1 > 0:heapq.heappush(heap, [-(b-1),bk])\\n                \\n        if not heap: return ans    \\n        if -heap[0][0] > 1: return \"\"\\n        return ans + heap[0][1]\\n        \\n        \\n            \\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "# class Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        heap = [[-v, k] for k, v in collections.Counter(s).items()]\\n        heapq.heapify(heap)\\n        ans = \"\"\\n        \\n        while len(heap) > 1:\\n            a, ak = heapq.heappop(heap)\\n            b, bk = heapq.heappop(heap)\\n            ans += ak + bk\\n            a, b = -a, -b\\n            if a - 1 > 0:heapq.heappush(heap, [-(a-1),ak])\\n            if b - 1 > 0:heapq.heappush(heap, [-(b-1),bk])\\n                \\n        if not heap: return ans    \\n        if -heap[0][0] > 1: return \"\"\\n        return ans + heap[0][1]\\n        \\n        \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 2363065,
                "title": "c-easy-solution-using-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        \\n        int n = s.size();\\n        string ans = \"\";\\n        \\n        unordered_map<char, int> mp;\\n        \\n        for(int i=0; i<n; i++) {\\n            mp[s[i]]++;\\n        }\\n        \\n        priority_queue< pair<int ,char> > q;\\n        \\n        // push all element in Max heap \\n        for(auto it: mp) {\\n              q.push({it.second, it.first});\\n        }\\n        \\n        // Here pop element from heap make answer string\\n        while(q.size() > 1) {\\n           \\n            auto top1 =  q.top();\\n            q.pop();\\n                      \\n            auto top2 =  q.top();\\n            q.pop();\\n            \\n            ans.push_back(top1.second);\\n            ans.push_back(top2.second);\\n            \\n            if(--top1.first > 0) q.push(top1);\\n            if(--top2.first > 0) q.push(top2);\\n            \\n        }\\n        \\n        if(q.size()) {\\n            if(q.top().first == 1) {\\n                  ans.push_back(q.top().second);\\n            }\\n            else {\\n                  return \"\";\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        \\n        int n = s.size();\\n        string ans = \"\";\\n        \\n        unordered_map<char, int> mp;\\n        \\n        for(int i=0; i<n; i++) {\\n            mp[s[i]]++;\\n        }\\n        \\n        priority_queue< pair<int ,char> > q;\\n        \\n        // push all element in Max heap \\n        for(auto it: mp) {\\n              q.push({it.second, it.first});\\n        }\\n        \\n        // Here pop element from heap make answer string\\n        while(q.size() > 1) {\\n           \\n            auto top1 =  q.top();\\n            q.pop();\\n                      \\n            auto top2 =  q.top();\\n            q.pop();\\n            \\n            ans.push_back(top1.second);\\n            ans.push_back(top2.second);\\n            \\n            if(--top1.first > 0) q.push(top1);\\n            if(--top2.first > 0) q.push(top2);\\n            \\n        }\\n        \\n        if(q.size()) {\\n            if(q.top().first == 1) {\\n                  ans.push_back(q.top().second);\\n            }\\n            else {\\n                  return \"\";\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247383,
                "title": "java-solution",
                "content": "```class Solution {\\n    public class pair{\\n        char ch;\\n        int f;\\n         pair(char ch,int f)\\n        {\\n            this.ch=ch;\\n            this.f=f;\\n        }\\n    }\\n    public String reorganizeString(String s) {\\n        int map[]=new int[26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            map[s.charAt(i)-\\'a\\']++;\\n        }\\n        PriorityQueue<pair> pq=new PriorityQueue<>((a,b)->b.f-a.f);\\n        for(int i=0;i<map.length;i++)\\n        {\\n            if(map[i]>0)\\n            {\\n                pq.add(new pair((char)(\\'a\\'+i),map[i]));\\n            }\\n        }\\n        StringBuilder sb=new StringBuilder();\\n        pair block=pq.poll();\\n        sb.append(block.ch);\\n        block.f--;\\n        while(pq.size()>0)\\n        {\\n            pair temp=pq.poll();\\n            sb.append(temp.ch);\\n            temp.f--;\\n            \\n            if(block.f>0)\\n            {\\n                pq.add(block);\\n                \\n            }\\n            block=temp;\\n            \\n        }\\n        if(block.f>0)\\n        {\\n            return \"\";\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public class pair{\\n        char ch;\\n        int f;\\n         pair(char ch,int f)\\n        {\\n            this.ch=ch;\\n            this.f=f;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2210587,
                "title": "beats-100-easy-to-understand-and-crisp-cpp-solution",
                "content": "```\\n// user_name -> divyansh_17\\n// year -> 2022\\n// college -> IIITP\\ntypedef pair<int, char> pic;\\nclass Solution\\n{\\npublic:\\n    string reorganizeString(string s)\\n    {\\n        unordered_map<char, int> hashMap;\\n        priority_queue<pic> maxHeap;\\n        string res;\\n        pic used = {0, \\'A\\'};\\n        for (auto it : s) hashMap[it]++;\\n        for (auto it : hashMap) maxHeap.push({it.second, it.first});\\n        while (maxHeap.size()){\\n            pic top = maxHeap.top();\\n            maxHeap.pop();\\n            res += top.second;\\n            top.first--;\\n            if (used.first > 0) maxHeap.push(used);\\n            used = top;\\n        }\\n        return s.length() == res.length() ? res : \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// user_name -> divyansh_17\\n// year -> 2022\\n// college -> IIITP\\ntypedef pair<int, char> pic;\\nclass Solution\\n{\\npublic:\\n    string reorganizeString(string s)\\n    {\\n        unordered_map<char, int> hashMap;\\n        priority_queue<pic> maxHeap;\\n        string res;\\n        pic used = {0, \\'A\\'};\\n        for (auto it : s) hashMap[it]++;\\n        for (auto it : hashMap) maxHeap.push({it.second, it.first});\\n        while (maxHeap.size()){\\n            pic top = maxHeap.top();\\n            maxHeap.pop();\\n            res += top.second;\\n            top.first--;\\n            if (used.first > 0) maxHeap.push(used);\\n            used = top;\\n        }\\n        return s.length() == res.length() ? res : \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1983913,
                "title": "clean-and-clear-python-solution-using-heap-time-o-n-lg-26-greatly-explained",
                "content": "Very good question!\\nUse **Heap**!\\n\\nThe key is to **balance**! Always balance the frequence of each character when rearranging.\\n\\nFirst, construct a **dict**, key is each character (at most 26), value is frequence.\\nSecond, construct a **heap**, put (-frequence, character) pair into the heap.\\nThen, every time **pop two characters out of the heap**, put two characters into the returning list, change the frequence, push them back to the heap.\\n\\n**Time:** O(n * lg(26)), n is the length of the input string, the length of the heap is at most 26\\n**Space:** O(26)\\n\\n```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        \\n        if not s:\\n            return \"\"\\n\\n        mapping = {}\\n        for c in s:\\n            if c in mapping:\\n                mapping[c] += 1\\n            else:\\n                mapping[c] = 1\\n\\n        heap = []\\n        for key in mapping:\\n            heappush(heap, (-mapping[key], key))\\n\\n        res_list = []\\n        while len(heap) > 1:\\n            freq1, char1 = heappop(heap)\\n            freq2, char2 = heappop(heap)\\n            res_list.append(char1)\\n            res_list.append(char2)\\n            if abs(freq1) > 1:\\n                heappush(heap, (freq1 + 1, char1))\\n            if abs(freq2) > 1: \\n                heappush(heap, (freq2 + 1, char2))\\n\\n        if heap:\\n            freq, char = heap[0]\\n            if abs(freq) > 1: \\n                return \"\"\\n            else:\\n                res_list.append(char)\\n        \\n        return \\'\\'.join(res_list)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        \\n        if not s:\\n            return \"\"\\n\\n        mapping = {}\\n        for c in s:\\n            if c in mapping:\\n                mapping[c] += 1\\n            else:\\n                mapping[c] = 1\\n\\n        heap = []\\n        for key in mapping:\\n            heappush(heap, (-mapping[key], key))\\n\\n        res_list = []\\n        while len(heap) > 1:\\n            freq1, char1 = heappop(heap)\\n            freq2, char2 = heappop(heap)\\n            res_list.append(char1)\\n            res_list.append(char2)\\n            if abs(freq1) > 1:\\n                heappush(heap, (freq1 + 1, char1))\\n            if abs(freq2) > 1: \\n                heappush(heap, (freq2 + 1, char2))\\n\\n        if heap:\\n            freq, char = heap[0]\\n            if abs(freq) > 1: \\n                return \"\"\\n            else:\\n                res_list.append(char)\\n        \\n        return \\'\\'.join(res_list)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930450,
                "title": "python-easy-solution-max-heap-and-counter-hashmap-with-comments",
                "content": "```\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        counter = {}\\n        for ch in s:\\n            if ch in counter:\\n                counter[ch] +=1\\n            else:\\n                counter[ch] = 1\\n        queue = []\\n        \\n        for elem in counter:\\n            heapq.heappush(queue, (-1*counter[elem], elem))\\n            \\n        result = []\\n        prev_char = None\\n        prev_freq = None\\n        while(queue):\\n            freq, elem  = heapq.heappop(queue)\\n            result.append(elem)\\n            if prev_freq:\\n                # it makes sure that character whihc is popped just now is not popped next, i.e. maintains non- adjacent condition\\n                heapq.heappush(queue, (prev_freq, prev_char))\\n            \\n            prev_char, prev_freq = elem, freq + 1 # +1 is equivalent to -1 as we used max_heap\\n        if len(result) == len(s):\\n            return \"\".join(result)\\n        return \"\"\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        counter = {}\\n        for ch in s:\\n            if ch in counter:\\n                counter[ch] +=1\\n            else:\\n                counter[ch] = 1\\n        queue = []\\n        \\n        for elem in counter:\\n            heapq.heappush(queue, (-1*counter[elem], elem))\\n            \\n        result = []\\n        prev_char = None\\n        prev_freq = None\\n        while(queue):\\n            freq, elem  = heapq.heappop(queue)\\n            result.append(elem)\\n            if prev_freq:\\n                # it makes sure that character whihc is popped just now is not popped next, i.e. maintains non- adjacent condition\\n                heapq.heappush(queue, (prev_freq, prev_char))\\n            \\n            prev_char, prev_freq = elem, freq + 1 # +1 is equivalent to -1 as we used max_heap\\n        if len(result) == len(s):\\n            return \"\".join(result)\\n        return \"\"\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900082,
                "title": "python-heap-solution-o-n-log-n",
                "content": "1) Use maxheap to track frequency of characters, and add characters based on frequency.\\n2) Have characters that are popped pushed back into the heap with frequency - 1 (except when freq == 0) after adding the next most frequent character\\n\\n```\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        last, amountLast = None, None\\n        count = Counter(s)\\n        maxHeap = [(-count[char], char) for char in count.keys()]\\n        heapq.heapify(maxHeap)\\n        res = \"\"\\n        while maxHeap:\\n            tmp = heapq.heappop(maxHeap)\\n            res += tmp[1]\\n            \\n            if amountLast:\\n                heapq.heappush(maxHeap, (amountLast, last))\\n            \\n            last, amountLast = tmp[1], tmp[0] + 1\\n        return res if len(res) == len(s) else \"\"\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "1) Use maxheap to track frequency of characters, and add characters based on frequency.\\n2) Have characters that are popped pushed back into the heap with frequency - 1 (except when freq == 0) after adding the next most frequent character\\n\\n```\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        last, amountLast = None, None\\n        count = Counter(s)\\n        maxHeap = [(-count[char], char) for char in count.keys()]\\n        heapq.heapify(maxHeap)\\n        res = \"\"\\n        while maxHeap:\\n            tmp = heapq.heappop(maxHeap)\\n            res += tmp[1]\\n            \\n            if amountLast:\\n                heapq.heappush(maxHeap, (amountLast, last))\\n            \\n            last, amountLast = tmp[1], tmp[0] + 1\\n        return res if len(res) == len(s) else \"\"\\n",
                "codeTag": "Java"
            },
            {
                "id": 1615219,
                "title": "c-solution-using-priority-queue",
                "content": "```\\nstring reorganizeString(string s) {\\n        //create a map to get the count of the characters in the string\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        \\n        //create a max heap having the pair with characters sorted by the count\\n        priority_queue<pair<int,char>> q;\\n        for(auto [k,v] : mp){\\n            q.push({v,k});\\n        }\\n        \\n        string ans=\"\";\\n        //loop until queue is empty\\n        while(!q.empty()){\\n            pair<int,char> x=q.top();\\n            q.pop();\\n            pair<int,char> y;\\n            \\n            //if the queue is empty and the last character in the answer string is not the same \\n            //as the one we have in x, append it and return it.\\n            if(q.empty() && (ans.size()==0 || ans[ans.size()-1]!=x.second)){\\n                ans+=x.second;\\n                x.first-=1;\\n                return (x.first>0?\"\":ans);\\n            }\\n            //if the queue is empty and the last element is same as x, then simply return \"\"\\n            else if(q.empty()){\\n                return \"\";\\n            }\\n            //else set value of y\\n            else{\\n                y=q.top();\\n                q.pop();\\n            }\\n            if(ans.size()==0 || ans[ans.size()-1]!=x.second){\\n                ans+=x.second;\\n                ans+=y.second;\\n            }\\n            else{\\n                ans+=y.second;\\n                ans+=x.second;\\n            }\\n            \\n            //reduce the count in x and y and push it back to the queue if their value is greater than 0\\n            x.first-=1;\\n            y.first-=1;\\n            if(x.first)\\n                q.push(x);\\n            if(y.first)\\n                q.push(y);\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nstring reorganizeString(string s) {\\n        //create a map to get the count of the characters in the string\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        \\n        //create a max heap having the pair with characters sorted by the count\\n        priority_queue<pair<int,char>> q;\\n        for(auto [k,v] : mp){\\n            q.push({v,k});\\n        }\\n        \\n        string ans=\"\";\\n        //loop until queue is empty\\n        while(!q.empty()){\\n            pair<int,char> x=q.top();\\n            q.pop();\\n            pair<int,char> y;\\n            \\n            //if the queue is empty and the last character in the answer string is not the same \\n            //as the one we have in x, append it and return it.\\n            if(q.empty() && (ans.size()==0 || ans[ans.size()-1]!=x.second)){\\n                ans+=x.second;\\n                x.first-=1;\\n                return (x.first>0?\"\":ans);\\n            }\\n            //if the queue is empty and the last element is same as x, then simply return \"\"\\n            else if(q.empty()){\\n                return \"\";\\n            }\\n            //else set value of y\\n            else{\\n                y=q.top();\\n                q.pop();\\n            }\\n            if(ans.size()==0 || ans[ans.size()-1]!=x.second){\\n                ans+=x.second;\\n                ans+=y.second;\\n            }\\n            else{\\n                ans+=y.second;\\n                ans+=x.second;\\n            }\\n            \\n            //reduce the count in x and y and push it back to the queue if their value is greater than 0\\n            x.first-=1;\\n            y.first-=1;\\n            if(x.first)\\n                q.push(x);\\n            if(y.first)\\n                q.push(y);\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1565807,
                "title": "python3-two-greedy-solutions-sort-and-no-sort",
                "content": "**Solution 1: Greedy Sort**\\nThe first greedy idea is that we can start with the lowercase characters that have higher frequencies. Why? Because these are the characters that have a higher chance of collision with neighbors. So we place them in odd indices. Afterwards, we place the rest of the characters in even indices. Then we do the checking. If we pass the checking, we can create and return the string.\\n```\\ndef reorganizeString(self, s: str) -> str:\\n        j = 0\\n        n = len(s)\\n        res = [\\'\\'] * n\\n        cnt = Counter(s)\\n        freq_sorted = list(map(list, cnt.most_common()))\\n        for i in range(0, n, 2):\\n            if freq_sorted[j][1] == 0:\\n                j += 1\\n            res[i] = freq_sorted[j][0]\\n            freq_sorted[j][1] -= 1\\n        for i in range(1, n, 2):\\n            if freq_sorted[j][1] == 0:\\n                j += 1\\n            res[i] = freq_sorted[j][0]\\n            freq_sorted[j][1] -= 1\\n        for i in range(1, n):\\n            if res[i - 1] == res[i]:\\n                return \"\"\\n        return \"\".join(res)\\n```\\n**Solution 2: No Sort (Find the Max)**\\nThe second greedy approach is almost the same as the first one with the realization that we just have to place the most frequent character first and then place rest of characters however we want as long as we obey the rules. In this case, no sorting is required.\\n```\\ndef reorganizeString(self, s: str) -> str:\\n        j = 0\\n        n = len(s)\\n        res = [\\'\\'] * n\\n        cnt = Counter(s)\\n        max_key = \\'\\'\\n        max_val = 0\\n        for key in cnt:\\n            if cnt[key] > max_val:\\n                max_key = key\\n                max_val = cnt[key]\\n        if max_val > (n + 1) // 2:\\n            return \"\"\\n        for i in range(0, n, 2):\\n            if max_val > 0:\\n                res[i] = max_key\\n            else:\\n                if cnt[j][0] == 0:\\n                    j += 1\\n                res[i] = cnt[j][1]\\n                cnt[j][0] -= 1\\n            max_val -= 1\\n            if max_val == 0:\\n                del cnt[max_key]\\n                cnt = list([v, k] for k, v in cnt.items())\\n        for i in range(1, n, 2):\\n            if cnt[j][0] == 0:\\n                j += 1\\n            res[i] = cnt[j][1]\\n            cnt[j][0] -= 1\\n        return \"\".join(res)\\n```",
                "solutionTags": [],
                "code": "```\\ndef reorganizeString(self, s: str) -> str:\\n        j = 0\\n        n = len(s)\\n        res = [\\'\\'] * n\\n        cnt = Counter(s)\\n        freq_sorted = list(map(list, cnt.most_common()))\\n        for i in range(0, n, 2):\\n            if freq_sorted[j][1] == 0:\\n                j += 1\\n            res[i] = freq_sorted[j][0]\\n            freq_sorted[j][1] -= 1\\n        for i in range(1, n, 2):\\n            if freq_sorted[j][1] == 0:\\n                j += 1\\n            res[i] = freq_sorted[j][0]\\n            freq_sorted[j][1] -= 1\\n        for i in range(1, n):\\n            if res[i - 1] == res[i]:\\n                return \"\"\\n        return \"\".join(res)\\n```\n```\\ndef reorganizeString(self, s: str) -> str:\\n        j = 0\\n        n = len(s)\\n        res = [\\'\\'] * n\\n        cnt = Counter(s)\\n        max_key = \\'\\'\\n        max_val = 0\\n        for key in cnt:\\n            if cnt[key] > max_val:\\n                max_key = key\\n                max_val = cnt[key]\\n        if max_val > (n + 1) // 2:\\n            return \"\"\\n        for i in range(0, n, 2):\\n            if max_val > 0:\\n                res[i] = max_key\\n            else:\\n                if cnt[j][0] == 0:\\n                    j += 1\\n                res[i] = cnt[j][1]\\n                cnt[j][0] -= 1\\n            max_val -= 1\\n            if max_val == 0:\\n                del cnt[max_key]\\n                cnt = list([v, k] for k, v in cnt.items())\\n        for i in range(1, n, 2):\\n            if cnt[j][0] == 0:\\n                j += 1\\n            res[i] = cnt[j][1]\\n            cnt[j][0] -= 1\\n        return \"\".join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1552862,
                "title": "simple-java-solution-using-priority-queue",
                "content": "class Solution {\\n    \\n\\tpublic String reorganizeString(String s) {\\n        int n = s.length() , limit = n % 2 == 0 ? n / 2 : (n + 1) / 2;\\n        \\n        int[] freqMap = new int[26];\\n        s.chars().forEach(i -> freqMap[i-97]++);\\n        \\n        PriorityQueue<Character> queue = new PriorityQueue<>((a,b) ->  freqMap[b - 97] - freqMap[a - 97]);\\n        \\n        for(int i = 0 ; i < 26 ; i++){\\n            if(freqMap[i] > 0){\\n                if(freqMap[i] > limit) return \"\";\\n                queue.add((char)(i + 97));\\n            }    \\n        }\\n        \\n        StringBuilder res = new StringBuilder();\\n        \\n        while(queue.size() > 1){\\n            char first = queue.poll();\\n            char second = queue.poll();\\n            res.append(first).append(second);\\n            if(--freqMap[first - 97] > 0) queue.add(first);\\n            if(--freqMap[second - 97] > 0) queue.add(second);\\n        }\\n        \\n        if(!queue.isEmpty()){\\n            char last = queue.poll();\\n            if(freqMap[last - 97] > 1) return \"\";\\n            res.append(last);\\n        }\\n        \\n        return res.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    \\n\\tpublic String reorganizeString(String s) {\\n        int n = s.length() , limit = n % 2 == 0 ? n / 2 : (n + 1) / 2;\\n        \\n        int[] freqMap = new int[26];\\n        s.chars().forEach(i -> freqMap[i-97]++);\\n        \\n        PriorityQueue<Character> queue = new PriorityQueue<>((a,b) ->  freqMap[b - 97] - freqMap[a - 97]);\\n        \\n        for(int i = 0 ; i < 26 ; i++){\\n            if(freqMap[i] > 0){\\n                if(freqMap[i] > limit) return \"\";\\n                queue.add((char)(i + 97));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1312340,
                "title": "java-clean-code-maxheap-priorityqueue",
                "content": "```\\nclass Solution {\\n    static class Pair {\\n      Character c;\\n      int count;\\n\\n      public Pair(Character c, int count) {\\n         this.c = c;\\n         this.count = count;\\n      }\\n   }\\n\\n   public String reorganizeString(String s) {\\n      char[] sChar = s.toCharArray();\\n      Map<Character, Integer> map = new HashMap<>();\\n      for (char c : sChar)\\n         map.put(c, map.getOrDefault(c, 0) + 1);\\n\\n      PriorityQueue<Pair> maxHeap = new PriorityQueue<>(sChar.length, (a, b) -> (b.count - a.count));\\n      for (Map.Entry<Character, Integer> entry : map.entrySet()) {\\n         maxHeap.offer(new Pair(entry.getKey(), entry.getValue()));\\n      }\\n\\n      StringBuilder sb = new StringBuilder();\\n      Pair prev = null;\\n      while (!maxHeap.isEmpty()) {\\n         Pair cur = maxHeap.poll();        \\n         sb.append(cur.c);\\n          \\n         cur.count -= 1;\\n         if (prev != null && prev.count > 0) {\\n            maxHeap.offer(prev);\\n         }\\n         prev = cur;\\n      }\\n      String result = sb.toString(); \\n      return result.length() == s.length() ? result:\"\";\\n   }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    static class Pair {\\n      Character c;\\n      int count;\\n\\n      public Pair(Character c, int count) {\\n         this.c = c;\\n         this.count = count;\\n      }\\n   }\\n\\n   public String reorganizeString(String s) {\\n      char[] sChar = s.toCharArray();\\n      Map<Character, Integer> map = new HashMap<>();\\n      for (char c : sChar)\\n         map.put(c, map.getOrDefault(c, 0) + 1);\\n\\n      PriorityQueue<Pair> maxHeap = new PriorityQueue<>(sChar.length, (a, b) -> (b.count - a.count));\\n      for (Map.Entry<Character, Integer> entry : map.entrySet()) {\\n         maxHeap.offer(new Pair(entry.getKey(), entry.getValue()));\\n      }\\n\\n      StringBuilder sb = new StringBuilder();\\n      Pair prev = null;\\n      while (!maxHeap.isEmpty()) {\\n         Pair cur = maxHeap.poll();        \\n         sb.append(cur.c);\\n          \\n         cur.count -= 1;\\n         if (prev != null && prev.count > 0) {\\n            maxHeap.offer(prev);\\n         }\\n         prev = cur;\\n      }\\n      String result = sb.toString(); \\n      return result.length() == s.length() ? result:\"\";\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 966447,
                "title": "beats-100-cpu-memory-with-explanation-simple-go-solution",
                "content": "Step 1:\\nWe first calculate all chars and it counts, we can use array but we have used Map so that incase some chars are not present, \\nduring calculation we find if string can be valid and find maxChar and its length, \\nStep 2\\nwe will first write the char which occur the most at even position \\nStep 3\\nAnd continue writer others at even position and then start writing at odd positions .\\n \\nTime Complexcity:\\nO(n) \\n(O(n) to read from string and O(n) to write to Byte array) still wiil be O(n)\\n\\nSpace Complexcity:\\nO(n) \\nO(n) to store bytes array + O(1) for map\\n\\n```\\nfunc reorganizeString(S string) string {\\n    //Count chars\\n    charsMap := map[byte]int{}\\n    length := len(S)\\n    maxLen := 0\\n    var maxLenChar byte \\n    //Step 1\\n    //Find all the chars and their count\\n    for i:=0; i < length; i++ {\\n        value, ok := charsMap[S[i]]\\n        if !ok {\\n            charsMap[S[i]] = 1\\n        } else {\\n            newVal := value + 1\\n            charsMap[S[i]] = newVal\\n            // Check if this is not possible\\n            if newVal > (length+ 1) / 2  {\\n                return \"\"\\n            }\\n            //Calculate the max len and chars\\n            if newVal > maxLen {\\n                maxLen = newVal\\n                maxLenChar = S[i]\\n            }\\n        }\\n    }\\n    \\n     //Step 2\\n    //Write the max occurred chars first in even places\\n    var result = make([]byte, length)\\n    index := 0\\n    for maxLen > 0 {\\n        //fmt.Println(index)\\n        result[index] = maxLenChar\\n        maxLen--\\n        val,_ := charsMap[maxLenChar]\\n        if val == 1 {\\n            \\n        } else {\\n            delete(charsMap, maxLenChar)\\n        }\\n        index += 2\\n    }\\n     //Step 3\\n    //Write Remaing chars fill even first and then write odds\\n    for char, value := range charsMap {\\n        \\n        for i := 0; i < value; i++ {\\n            //once we are done writing even index start the odds one\\n            if index >= length {\\n                index = 1\\n            } \\n            result[index] = char\\n            index += 2\\n        }\\n    }\\n    \\n    //convert the byte array to string\\n    return string(result)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc reorganizeString(S string) string {\\n    //Count chars\\n    charsMap := map[byte]int{}\\n    length := len(S)\\n    maxLen := 0\\n    var maxLenChar byte \\n    //Step 1\\n    //Find all the chars and their count\\n    for i:=0; i < length; i++ {\\n        value, ok := charsMap[S[i]]\\n        if !ok {\\n            charsMap[S[i]] = 1\\n        } else {\\n            newVal := value + 1\\n            charsMap[S[i]] = newVal\\n            // Check if this is not possible\\n            if newVal > (length+ 1) / 2  {\\n                return \"\"\\n            }\\n            //Calculate the max len and chars\\n            if newVal > maxLen {\\n                maxLen = newVal\\n                maxLenChar = S[i]\\n            }\\n        }\\n    }\\n    \\n     //Step 2\\n    //Write the max occurred chars first in even places\\n    var result = make([]byte, length)\\n    index := 0\\n    for maxLen > 0 {\\n        //fmt.Println(index)\\n        result[index] = maxLenChar\\n        maxLen--\\n        val,_ := charsMap[maxLenChar]\\n        if val == 1 {\\n            \\n        } else {\\n            delete(charsMap, maxLenChar)\\n        }\\n        index += 2\\n    }\\n     //Step 3\\n    //Write Remaing chars fill even first and then write odds\\n    for char, value := range charsMap {\\n        \\n        for i := 0; i < value; i++ {\\n            //once we are done writing even index start the odds one\\n            if index >= length {\\n                index = 1\\n            } \\n            result[index] = char\\n            index += 2\\n        }\\n    }\\n    \\n    //convert the byte array to string\\n    return string(result)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 786522,
                "title": "bruteforce-dfs-to-pq-solution-thoroughly-commented",
                "content": "Good for you if you\\'re a genius who came up with the pq solution first try.\\n\\nIf you\\'ve never seen this question b4, it might make sense to use DFS + backtracking to find all possibilities, and return a valid string:\\n\\n```\\nclass Solution {\\n    public String reorganizeString(String S) {\\n        \\n        HashSet<String> v = new HashSet<>(); //visited set\\n        \\n        StringBuilder sb = new StringBuilder(S);\\n        \\n        //dfs all possibilities, use backtrack to make candidates\\n        \\n        //if found, just return that possibility\\n        \\n        return dfs(sb, v);\\n        \\n    }\\n    \\n    private String dfs(StringBuilder sb, HashSet<String> v) {\\n        \\n        String curr = sb.toString();\\n        \\n        //base case, no adjacents\\n        if(!adjacent(curr)) return curr;\\n        \\n        if(v.contains(curr)) return \"\";\\n        \\n        v.add(curr);\\n        \\n        //swap all possibilites\\n        for(int i = 0; i < curr.length()-1; i++) {\\n            \\n            //swap\\n            swap(sb, i, i+1);\\n            \\n            //send out dfs\\n            String res = dfs(sb, v);\\n            if (res != \"\") return res;\\n                \\n            //swap back\\n            swap(sb,i,i+1);\\n        }\\n        \\n        return \"\";\\n        \\n    }\\n    \\n    \\n    private boolean adjacent(String curr) {\\n        \\n        for(int i = 0; i < curr.length()-1; i++) {\\n            if(curr.charAt(i)==curr.charAt(i+1)) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    //swaps char at i and j\\n    private void swap(StringBuilder sb, int i, int j) {\\n        \\n        char c1 = sb.charAt(i);\\n        sb.replace(i,i+1, \"\"+sb.charAt(i+1));\\n        sb.replace(i+1, i+2, \"\"+c1);\\n        \\n    }\\n}\\n```\\n\\nUnfortunately this gets TLE (though it passes many smaller test cases). Why is that?\\n\\nWell your branching factor is O(n), and the number of levels in your recursion tree (i.e. the number of swaps necessary to get a valid string) is *at least* O(n), but likely worse. So you\\'re already dealing with an O(n^n) complexity, but it\\'s probably worse. \\n\\nTo improve the time complexity, you have to ask yourself: perhaps there is some way to directly solve this problem without generating a tree of all the possibilities. \\n\\nIndeed there is: consider \"aab\".\\n\\nHow do you know you can sucessfully re-org this string? \\n\\nYou can lay out the \"a_a\" and use \"b\" as a \"resource\" to stop the adjacency.\\n\\nOk, but would this work with more complicated examples? S = \"aaabbcccc\"\\n\\nLet\\'s start by laying out the c\\'s: \"c_c_c_c\"\\n\\nWe need 3 \"resources\" to stop the adjacency. Ok let\\'s just use \"a\" then:\\n\\n\"cacacac\". Uh oh, now we\\'re stuck with the two b\\'s...\\n\\nAt this point, you should realize that the \"resources\" need to be dynamically updated and chosen. That is to say, instead of just choosing to use the 3 a\\'s from the get-go, use two a\\'s, realize now that you have more b resources, so start using the b resources.\\n\\nNaturally, dynamically updating and using the highest resource char should get you thinking of a PQ.\\n\\nLet\\'s see if it works:\\n\\n\"c_c_c_c\" -> \"cacac_c\" -> \"cacacbc\" -> \"cacacbc\" + \"ab\"\\n\\nNice.\\n\\n```\\n public String reorganizeString(String S) {\\n        \\n        //char buckets\\n        int[] cfreq = new int[26];\\n        for(char c: S.toCharArray()) cfreq[c-\\'a\\']++;\\n        \\n        PriorityQueue<Character> pq = new PriorityQueue<>((c1, c2)->{\\n            return cfreq[c2-\\'a\\'] - cfreq[c1-\\'a\\'];\\n        });\\n        \\n        for(int i = 0; i < 26; i++) {\\n            if(cfreq[i]>0) pq.add((char)(i+\\'a\\'));\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();//builds res\\n        \\n        //we choose largest char bucket as a \"base\", poll from pq\\n        while(!pq.isEmpty()) {\\n        \\n            //try to fill in with other chars, use a \"resource\" pq which organizes char bucket by resources remaining\\n            char base = pq.poll();\\n            int needFill = cfreq[base-\\'a\\']-1;\\n            \\n             //start making nonadjacent string\\n            sb.append(base);\\n                        \\n            if(needFill==0) continue; //we\\'re good, nothing to fill in b/c single char\\n            \\n            while(needFill>0) {\\n                \\n                if(pq.isEmpty()) return \"\"; //couldn\\'t fill in everything\\n                \\n                //use a resource, make sure put back in pq to properly update\\n                char resource = pq.poll(); //resource character\\n                cfreq[resource-\\'a\\']--;\\n                \\n                if(cfreq[resource-\\'a\\'] > 0) pq.add(resource); //only add it back if have resource remaining\\n                \\n                //will be non-adjacent\\n                sb.append(resource);\\n                sb.append(base);\\n                \\n                needFill--;\\n            }\\n        \\n            //repeat on next largest char bucket remaining\\n            \\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String reorganizeString(String S) {\\n        \\n        HashSet<String> v = new HashSet<>(); //visited set\\n        \\n        StringBuilder sb = new StringBuilder(S);\\n        \\n        //dfs all possibilities, use backtrack to make candidates\\n        \\n        //if found, just return that possibility\\n        \\n        return dfs(sb, v);\\n        \\n    }\\n    \\n    private String dfs(StringBuilder sb, HashSet<String> v) {\\n        \\n        String curr = sb.toString();\\n        \\n        //base case, no adjacents\\n        if(!adjacent(curr)) return curr;\\n        \\n        if(v.contains(curr)) return \"\";\\n        \\n        v.add(curr);\\n        \\n        //swap all possibilites\\n        for(int i = 0; i < curr.length()-1; i++) {\\n            \\n            //swap\\n            swap(sb, i, i+1);\\n            \\n            //send out dfs\\n            String res = dfs(sb, v);\\n            if (res != \"\") return res;\\n                \\n            //swap back\\n            swap(sb,i,i+1);\\n        }\\n        \\n        return \"\";\\n        \\n    }\\n    \\n    \\n    private boolean adjacent(String curr) {\\n        \\n        for(int i = 0; i < curr.length()-1; i++) {\\n            if(curr.charAt(i)==curr.charAt(i+1)) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    //swaps char at i and j\\n    private void swap(StringBuilder sb, int i, int j) {\\n        \\n        char c1 = sb.charAt(i);\\n        sb.replace(i,i+1, \"\"+sb.charAt(i+1));\\n        sb.replace(i+1, i+2, \"\"+c1);\\n        \\n    }\\n}\\n```\n```\\n public String reorganizeString(String S) {\\n        \\n        //char buckets\\n        int[] cfreq = new int[26];\\n        for(char c: S.toCharArray()) cfreq[c-\\'a\\']++;\\n        \\n        PriorityQueue<Character> pq = new PriorityQueue<>((c1, c2)->{\\n            return cfreq[c2-\\'a\\'] - cfreq[c1-\\'a\\'];\\n        });\\n        \\n        for(int i = 0; i < 26; i++) {\\n            if(cfreq[i]>0) pq.add((char)(i+\\'a\\'));\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();//builds res\\n        \\n        //we choose largest char bucket as a \"base\", poll from pq\\n        while(!pq.isEmpty()) {\\n        \\n            //try to fill in with other chars, use a \"resource\" pq which organizes char bucket by resources remaining\\n            char base = pq.poll();\\n            int needFill = cfreq[base-\\'a\\']-1;\\n            \\n             //start making nonadjacent string\\n            sb.append(base);\\n                        \\n            if(needFill==0) continue; //we\\'re good, nothing to fill in b/c single char\\n            \\n            while(needFill>0) {\\n                \\n                if(pq.isEmpty()) return \"\"; //couldn\\'t fill in everything\\n                \\n                //use a resource, make sure put back in pq to properly update\\n                char resource = pq.poll(); //resource character\\n                cfreq[resource-\\'a\\']--;\\n                \\n                if(cfreq[resource-\\'a\\'] > 0) pq.add(resource); //only add it back if have resource remaining\\n                \\n                //will be non-adjacent\\n                sb.append(resource);\\n                sb.append(base);\\n                \\n                needFill--;\\n            }\\n        \\n            //repeat on next largest char bucket remaining\\n            \\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764929,
                "title": "neat-c-priority-queue-solution-explained",
                "content": "Push all the characters in a priority queue sorted in the order of increasing frequency.\\nPop the two most frequent characters from the pq until the size of pq drops to 1. Add these two characters to final answer string and decrease their counts. If there is no charcter left in priority queue then simply return, else check the frequency of the this last character. If it is greater than 1 we can never get add it to the final ans, so return \"\". Else push it back to final answer string and return.\\n\\n```\\nstring reorganizeString(string S) {\\n        string s;\\n        priority_queue <pair<int,char>> pq;\\n        int count[26];\\n        memset(count, 0, sizeof(count));\\n        for(char c: S){\\n            count[c-\\'a\\']++;\\n        }\\n        for(int i = 0; i < 26; i++){\\n            if(count[i] > 0){\\n                pq.push({count[i], (char)(\\'a\\' + i)});\\n            }\\n        }\\n        while(pq.size() > 1){\\n            pair<int,char> a = pq.top();\\n            pq.pop();\\n            pair<int,char> b = pq.top();\\n            pq.pop();\\n            \\n            s += a.second;\\n            s += b.second;\\n            \\n            a.first--;\\n            b.first--;\\n            \\n            if(a.first > 0) pq.push(a);\\n            if(b.first > 0) pq.push(b);\\n        }\\n        if(pq.empty()){\\n            return s;\\n        }\\n        if(pq.top().first > 1) return \"\";\\n        else{\\n            s.push_back(pq.top().second);\\n        }\\n        return s;\\n    }\\n```\\nHope it helps",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nstring reorganizeString(string S) {\\n        string s;\\n        priority_queue <pair<int,char>> pq;\\n        int count[26];\\n        memset(count, 0, sizeof(count));\\n        for(char c: S){\\n            count[c-\\'a\\']++;\\n        }\\n        for(int i = 0; i < 26; i++){\\n            if(count[i] > 0){\\n                pq.push({count[i], (char)(\\'a\\' + i)});\\n            }\\n        }\\n        while(pq.size() > 1){\\n            pair<int,char> a = pq.top();\\n            pq.pop();\\n            pair<int,char> b = pq.top();\\n            pq.pop();\\n            \\n            s += a.second;\\n            s += b.second;\\n            \\n            a.first--;\\n            b.first--;\\n            \\n            if(a.first > 0) pq.push(a);\\n            if(b.first > 0) pq.push(b);\\n        }\\n        if(pq.empty()){\\n            return s;\\n        }\\n        if(pq.top().first > 1) return \"\";\\n        else{\\n            s.push_back(pq.top().second);\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 711749,
                "title": "fully-explained-simple-c-solution-4ms-using-heap-map",
                "content": "**The idea is to pick up two most frequent elements and add the to the resultant string alternate wise, till the character with lesser count is exhausted. And the latter, is added to the heap again if its count is greater than 0. This is repeated till we have <=1 elements in heap.**\\n\\n```\\nstring reorganizeString(string S) {\\n        map<char,int> mp;\\n        int n=S.length();\\n        for(int i=0;i<n;i++) //taking count of each character\\n            mp[S[i]]++;\\n        priority_queue<pair<int,char>> hp;\\n        \\n        for(auto i=mp.begin();i!=mp.end();i++){ //pushing elements to the heap, with its frequency as 1st element and character as second\\n            hp.push({i->second,i->first});\\n        }\\n        string s; // s stores the resultant string\\n        \\n        while(hp.size()>=2){// implementation of above mentioned idea\\n            pair<int,char> a=hp.top();\\n            hp.pop();\\n            pair<int,char>b=hp.top();\\n            hp.pop();\\n            while((b.first)>0){\\n                s.push_back(a.second);\\n                s.push_back(b.second);\\n                b.first--;\\n                a.first--;\\n                \\n            }\\n            if(a.first>0)\\n                hp.push(a);\\n        }\\n        if(hp.empty()) // if heap is empty, simply return it\\n            return s;\\n        \\n        if(hp.top().first>1) // it means we have one character, which has still count >=2, if now added there\\'s no way to have any character between them\\n            return \"\";// so return empty string\\n        else if(hp.top().first==1) // if one character is left, simply add it to string\\n            s.push_back(hp.top().second);\\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nstring reorganizeString(string S) {\\n        map<char,int> mp;\\n        int n=S.length();\\n        for(int i=0;i<n;i++) //taking count of each character\\n            mp[S[i]]++;\\n        priority_queue<pair<int,char>> hp;\\n        \\n        for(auto i=mp.begin();i!=mp.end();i++){ //pushing elements to the heap, with its frequency as 1st element and character as second\\n            hp.push({i->second,i->first});\\n        }\\n        string s; // s stores the resultant string\\n        \\n        while(hp.size()>=2){// implementation of above mentioned idea\\n            pair<int,char> a=hp.top();\\n            hp.pop();\\n            pair<int,char>b=hp.top();\\n            hp.pop();\\n            while((b.first)>0){\\n                s.push_back(a.second);\\n                s.push_back(b.second);\\n                b.first--;\\n                a.first--;\\n                \\n            }\\n            if(a.first>0)\\n                hp.push(a);\\n        }\\n        if(hp.empty()) // if heap is empty, simply return it\\n            return s;\\n        \\n        if(hp.top().first>1) // it means we have one character, which has still count >=2, if now added there\\'s no way to have any character between them\\n            return \"\";// so return empty string\\n        else if(hp.top().first==1) // if one character is left, simply add it to string\\n            s.push_back(hp.top().second);\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 675541,
                "title": "simple-java-solution-with-explanation-generic-approach-template",
                "content": "Approach 1 :  This is based on simple intuition that can solve only this question . But approach 2 is better and can be applied as a template for this type of question.\\n```\\nclass Solution {\\n    \\n    /**\\n      1. Count the frequency of each number and at any time the freq is greater than N+1/2 its not possible.eg \\n         aaab = a3b1 , so N=4 && 4+1/2 =2 which is less than the a\\'s freq which is 3 hence its not possible.\\n         \\n      2. Use Max heap( sort by count characters) to pop 2 letters at a time and put in new Character Array in interleaving or adjacent to each other.\\n      \\n      3. Then return the new Array as String ;   \\n    \\n    \\n    **/\\n    \\n    \\n    private int index =0;\\n\\n\\tpublic String reorganizeString(String S) {\\n\\n\\t\\tif(S==null || S.isEmpty() ){\\n\\t\\t\\treturn S;\\n\\t\\t}\\n\\t\\tint n = S.length();\\n\\t\\tchar retArray[] = new char[n];\\n       \\n\\t   // Create map for character frequency\\n\\t\\tMap<Character,Integer> chCount = new HashMap<>();\\n\\t\\tfor (char ch : S.toCharArray()){\\n\\t\\t\\tchCount.put(ch, chCount.getOrDefault(ch,0)+1);\\n\\t\\t\\tif(chCount.get(ch) > (n+1)/2){\\n\\t\\t\\t\\treturn \"\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tPriorityQueue<Map.Entry<Character,Integer>> maxHeap = new PriorityQueue<>((ent1,ent2)->{\\n\\t\\t\\tif(ent1.getValue().equals(ent2.getValue())) {\\n\\t\\t\\t\\treturn ent1.getKey().compareTo(ent2.getKey());\\n\\t\\t\\t}\\n\\t\\t\\treturn ent2.getValue().compareTo(ent1.getValue());\\n\\t\\t});\\n\\n        // add all elements into MaxHeap\\n\\t\\tmaxHeap.addAll(chCount.entrySet());\\n        \\n        // clear the map we dont need it now\\n        chCount.clear();\\n\\n\\t\\t// get 2 elements at a time from heap and putting in output array in alternate fashion \\n\\t\\t\\n\\t\\twhile(maxHeap.size()>=2){\\n\\t\\t\\t\\n\\t\\t\\tMap.Entry<Character,Integer> itm1 = maxHeap.poll();\\n\\t\\t\\tMap.Entry<Character,Integer> itm2 = maxHeap.poll();\\n            // Put the first top elemnt from heap and insert into array @retArray \\n            processItem(itm1,retArray,maxHeap);\\n            \\n            // Put the Second top elemnt from heap and insert into array @retArray \\n\\t\\t\\tprocessItem(itm2,retArray,maxHeap);\\n\\t\\t}\\n\\n        // If heap still have some item , put in @retArray \\n\\t\\twhile(maxHeap.size()>0 ){\\n\\t\\t\\tprocessItem(maxHeap.poll(),retArray,maxHeap);\\n\\t\\t}\\n\\n\\t\\treturn new String(retArray);\\n\\n\\t}\\n\\t\\n\\tprivate void processItem(Map.Entry<Character,Integer> itm,\\n\\t\\t\\t                 char retArray[],\\n                             PriorityQueue<Map.Entry<Character,Integer>> maxHeap\\n\\t\\t\\t\\t\\t\\t    ){\\n\\t\\tif(itm.getValue()>0){\\n\\t\\t\\tretArray[index++] = itm.getKey();\\n\\t\\t\\t// key logic get the item and decrease its count until it reaches 0 \\n            itm.setValue( itm.getValue() -1);\\n\\t\\t\\tmaxHeap.add(itm);\\n\\t\\t}else{\\n\\t\\t\\tmaxHeap.remove(itm) ; \\n\\t\\t}\\n\\t}\\n}\\n\\n```\\nApproach 2 : This is more genric and can be applied for this question as well as for https://leetcode.com/problems/rearrange-string-k-distance-apart/  . Just replace 2 with K .\\n\\n```\\n/**\\n      1. Use Map to create the count of Character .\\n      2. Max heap to sort character by FReq\\n      3. coolingQueue wait for 2 ( K) charcaters to come in between the same charcater\\n      4. Lastly if the new string length is equal to current string length then fine else its not possible.\\n    **/\\n\\tpublic String reorganizeString(String S) {\\n\\n\\t\\tif(S==null || S.isEmpty() ){\\n\\t\\t\\treturn S;\\n\\t\\t}\\n\\t\\tint n = S.length();\\n\\t\\tStringBuilder newStr = new StringBuilder();\\n       \\n\\t   // Create map for character frequency\\n\\t\\tMap<Character,Integer> chCount = new HashMap<>();\\n\\t\\tfor (char ch : S.toCharArray()){\\n\\t\\t\\tchCount.put(ch, chCount.getOrDefault(ch,0)+1);\\n\\t\\t}\\n\\n        // log k which 26 \\n\\t\\tPriorityQueue<Map.Entry<Character,Integer>> maxHeap = new PriorityQueue<>((ent1,ent2)->{\\n\\t\\t\\tif(ent1.getValue().equals(ent2.getValue())) {\\n\\t\\t\\t\\treturn ent1.getKey().compareTo(ent2.getKey());\\n\\t\\t\\t}\\n\\t\\t\\treturn ent2.getValue().compareTo(ent1.getValue());\\n\\t\\t});\\n\\n        // add all elements into MaxHeap\\n\\t\\tmaxHeap.addAll(chCount.entrySet());\\n        \\n        // clear the map \\n        chCount.clear();\\n        \\n        Queue<Map.Entry<Character,Integer>> coolingQueue = new LinkedList<>();\\n        \\n        // O(n)  -- n log(k)\\n        while(!maxHeap.isEmpty()){\\n            Map.Entry<Character,Integer> topElement = maxHeap.poll();\\n            topElement.setValue(topElement.getValue()-1);\\n            newStr.append(topElement.getKey());\\n            coolingQueue.add(topElement);\\n            \\n            // Until Queue reaches K( 2) move on . Here replace 2 with K \\n            if(coolingQueue.size() < 2){\\n                continue;\\n            }\\n            \\n            while(!coolingQueue.isEmpty()){\\n                 Map.Entry<Character,Integer> coolingElement = coolingQueue.poll();\\n                 if(coolingElement.getValue() > 0){\\n                    maxHeap.add(coolingElement); \\n                 }\\n                \\n            }\\n        }\\n        return newStr.length() == S.length() ? newStr.toString() : \"\";\\n    }\\n\\t\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /**\\n      1. Count the frequency of each number and at any time the freq is greater than N+1/2 its not possible.eg \\n         aaab = a3b1 , so N=4 && 4+1/2 =2 which is less than the a\\'s freq which is 3 hence its not possible.\\n         \\n      2. Use Max heap( sort by count characters) to pop 2 letters at a time and put in new Character Array in interleaving or adjacent to each other.\\n      \\n      3. Then return the new Array as String ;   \\n    \\n    \\n    **/\\n    \\n    \\n    private int index =0;\\n\\n\\tpublic String reorganizeString(String S) {\\n\\n\\t\\tif(S==null || S.isEmpty() ){\\n\\t\\t\\treturn S;\\n\\t\\t}\\n\\t\\tint n = S.length();\\n\\t\\tchar retArray[] = new char[n];\\n       \\n\\t   // Create map for character frequency\\n\\t\\tMap<Character,Integer> chCount = new HashMap<>();\\n\\t\\tfor (char ch : S.toCharArray()){\\n\\t\\t\\tchCount.put(ch, chCount.getOrDefault(ch,0)+1);\\n\\t\\t\\tif(chCount.get(ch) > (n+1)/2){\\n\\t\\t\\t\\treturn \"\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tPriorityQueue<Map.Entry<Character,Integer>> maxHeap = new PriorityQueue<>((ent1,ent2)->{\\n\\t\\t\\tif(ent1.getValue().equals(ent2.getValue())) {\\n\\t\\t\\t\\treturn ent1.getKey().compareTo(ent2.getKey());\\n\\t\\t\\t}\\n\\t\\t\\treturn ent2.getValue().compareTo(ent1.getValue());\\n\\t\\t});\\n\\n        // add all elements into MaxHeap\\n\\t\\tmaxHeap.addAll(chCount.entrySet());\\n        \\n        // clear the map we dont need it now\\n        chCount.clear();\\n\\n\\t\\t// get 2 elements at a time from heap and putting in output array in alternate fashion \\n\\t\\t\\n\\t\\twhile(maxHeap.size()>=2){\\n\\t\\t\\t\\n\\t\\t\\tMap.Entry<Character,Integer> itm1 = maxHeap.poll();\\n\\t\\t\\tMap.Entry<Character,Integer> itm2 = maxHeap.poll();\\n            // Put the first top elemnt from heap and insert into array @retArray \\n            processItem(itm1,retArray,maxHeap);\\n            \\n            // Put the Second top elemnt from heap and insert into array @retArray \\n\\t\\t\\tprocessItem(itm2,retArray,maxHeap);\\n\\t\\t}\\n\\n        // If heap still have some item , put in @retArray \\n\\t\\twhile(maxHeap.size()>0 ){\\n\\t\\t\\tprocessItem(maxHeap.poll(),retArray,maxHeap);\\n\\t\\t}\\n\\n\\t\\treturn new String(retArray);\\n\\n\\t}\\n\\t\\n\\tprivate void processItem(Map.Entry<Character,Integer> itm,\\n\\t\\t\\t                 char retArray[],\\n                             PriorityQueue<Map.Entry<Character,Integer>> maxHeap\\n\\t\\t\\t\\t\\t\\t    ){\\n\\t\\tif(itm.getValue()>0){\\n\\t\\t\\tretArray[index++] = itm.getKey();\\n\\t\\t\\t// key logic get the item and decrease its count until it reaches 0 \\n            itm.setValue( itm.getValue() -1);\\n\\t\\t\\tmaxHeap.add(itm);\\n\\t\\t}else{\\n\\t\\t\\tmaxHeap.remove(itm) ; \\n\\t\\t}\\n\\t}\\n}\\n\\n```\n```\\n/**\\n      1. Use Map to create the count of Character .\\n      2. Max heap to sort character by FReq\\n      3. coolingQueue wait for 2 ( K) charcaters to come in between the same charcater\\n      4. Lastly if the new string length is equal to current string length then fine else its not possible.\\n    **/\\n\\tpublic String reorganizeString(String S) {\\n\\n\\t\\tif(S==null || S.isEmpty() ){\\n\\t\\t\\treturn S;\\n\\t\\t}\\n\\t\\tint n = S.length();\\n\\t\\tStringBuilder newStr = new StringBuilder();\\n       \\n\\t   // Create map for character frequency\\n\\t\\tMap<Character,Integer> chCount = new HashMap<>();\\n\\t\\tfor (char ch : S.toCharArray()){\\n\\t\\t\\tchCount.put(ch, chCount.getOrDefault(ch,0)+1);\\n\\t\\t}\\n\\n        // log k which 26 \\n\\t\\tPriorityQueue<Map.Entry<Character,Integer>> maxHeap = new PriorityQueue<>((ent1,ent2)->{\\n\\t\\t\\tif(ent1.getValue().equals(ent2.getValue())) {\\n\\t\\t\\t\\treturn ent1.getKey().compareTo(ent2.getKey());\\n\\t\\t\\t}\\n\\t\\t\\treturn ent2.getValue().compareTo(ent1.getValue());\\n\\t\\t});\\n\\n        // add all elements into MaxHeap\\n\\t\\tmaxHeap.addAll(chCount.entrySet());\\n        \\n        // clear the map \\n        chCount.clear();\\n        \\n        Queue<Map.Entry<Character,Integer>> coolingQueue = new LinkedList<>();\\n        \\n        // O(n)  -- n log(k)\\n        while(!maxHeap.isEmpty()){\\n            Map.Entry<Character,Integer> topElement = maxHeap.poll();\\n            topElement.setValue(topElement.getValue()-1);\\n            newStr.append(topElement.getKey());\\n            coolingQueue.add(topElement);\\n            \\n            // Until Queue reaches K( 2) move on . Here replace 2 with K \\n            if(coolingQueue.size() < 2){\\n                continue;\\n            }\\n            \\n            while(!coolingQueue.isEmpty()){\\n                 Map.Entry<Character,Integer> coolingElement = coolingQueue.poll();\\n                 if(coolingElement.getValue() > 0){\\n                    maxHeap.add(coolingElement); \\n                 }\\n                \\n            }\\n        }\\n        return newStr.length() == S.length() ? newStr.toString() : \"\";\\n    }\\n\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 646364,
                "title": "python-heap-simple",
                "content": "```\\nfrom heapq import *\\nfrom collections import Counter\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:        \\n        d = Counter(s)\\n        res = []\\n        h = [(-d[x], x) for x in d]\\n        heapify(h)\\n        while h:\\n            if len(h) > 1:\\n                v1, e1 = heappop(h)\\n                v2, e2 = heappop(h)\\n                res.extend([e1, e2])\\n                if v1 + 1 < 0:\\n                    heappush(h, (v1 + 1, e1))\\n                if v2 + 1 < 0:\\n                    heappush(h, (v2 + 1, e2))\\n            else:\\n                v, e = heappop(h)\\n                if res and res[-1] != e and v == -1:\\n                    res.append(e)\\n                else:\\n                    return \"\"\\n        return \\'\\'.join(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import *\\nfrom collections import Counter\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:        \\n        d = Counter(s)\\n        res = []\\n        h = [(-d[x], x) for x in d]\\n        heapify(h)\\n        while h:\\n            if len(h) > 1:\\n                v1, e1 = heappop(h)\\n                v2, e2 = heappop(h)\\n                res.extend([e1, e2])\\n                if v1 + 1 < 0:\\n                    heappush(h, (v1 + 1, e1))\\n                if v2 + 1 < 0:\\n                    heappush(h, (v2 + 1, e2))\\n            else:\\n                v, e = heappop(h)\\n                if res and res[-1] != e and v == -1:\\n                    res.append(e)\\n                else:\\n                    return \"\"\\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 619532,
                "title": "swift-99-runtime-easy-solution",
                "content": "# Swift: 99% Runtime\\n```\\nclass Solution {\\n    func reorganizeString(_ S: String) -> String {\\n      var sArr = Array(S)\\n      var hashMap: [Character: Int] = [:]\\n      let arrCount = sArr.count\\n        \\n        for c in sArr {\\n            hashMap[c] = (hashMap[c] ?? 0 ) + 1\\n        }\\n        \\n        let sorted = hashMap.sorted(by: {\\n            $0.value > $1.value\\n        })\\n        \\n        var currentIndex: Int = 0\\n        \\n        for (key,_) in sorted {\\n            for i in 0..<hashMap[key]! {\\n                sArr[currentIndex] = key\\n                currentIndex += 2\\n                if currentIndex >= arrCount {\\n                    currentIndex = 1\\n                }\\n            }\\n        }\\n\\t\\t\\n        //Test if no same letters exists together\\n        for i in 0..<arrCount-1 {\\n            if sArr[i] == sArr[i+1] {\\n                return \"\"\\n            }\\n        }\\n        \\n        return String(sArr)\\n       \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    func reorganizeString(_ S: String) -> String {\\n      var sArr = Array(S)\\n      var hashMap: [Character: Int] = [:]\\n      let arrCount = sArr.count\\n        \\n        for c in sArr {\\n            hashMap[c] = (hashMap[c] ?? 0 ) + 1\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 480063,
                "title": "c-o-n-solution-beats-100-in-time-and-memory-without-heap-sort-or-extra-memory",
                "content": "Ported to C# from original C++ solution https://leetcode.com/problems/reorganize-string/discuss/360677/C%2B%2B-O(N)-Solution-beats-100-in-time-and-memory(Without-heap-sort-or-extra-memory))\\n\\nBelow are algorithm description from author\\nAlgorithm:\\n\\n1. Required string is only possible when char with max frequency is less than equal to half of size of given string.\\n2. Check for above condition by creating a char-frequency map.\\n3. In case it is possible, arrange the most occuring character on even positions. Arrange the remaining characters on alternate remaining positions. This makes sure that no 2 same character occurs together.\\n\\n\\n```\\npublic class Solution \\n{\\n    public string ReorganizeString(string s)\\n    {\\n        if (s == null || s.Length < 2)\\n            return s;\\n            \\n        int n = s.Length;\\n        \\n        // Calculate and store frequencies in char-frequency map.\\n        // Find character and frequency with max frequency\\n        int freqChar = -1;\\n        int freqCharCount = -1;\\n        int[] freq = new int[26];\\n        for(int i = 0; i < n; i++)\\n        {\\n            freq[s[i] - \\'a\\']++;\\n            if (freq[s[i] - \\'a\\'] > freqCharCount)\\n            {\\n                freqCharCount = freq[s[i] - \\'a\\'];\\n                freqChar = s[i] - \\'a\\';\\n            }\\n        }\\n        \\n        // Required string is only possible when char with max frequency is less than equal to half of size of given string.\\n        if (freqCharCount > (n + 1) / 2)\\n            return \"\";\\n        \\n        StringBuilder str = new StringBuilder(s);\\n        int position = 0;\\n        // In case it is possible, arrange the most occuring character on even positions. \\n        // Arrange the remaining characters on alternate remaining positions. \\n        // This makes sure that no 2 same character occurs together.\\n        for (int i = -1; i < 26; i++)\\n        {\\n            int current = (i == -1) ? freqChar : i;\\n            while (freq[current]-- > 0)\\n            {\\n                str[position] = (char)(\\'a\\' + current);\\n                position = (position + 2 >= n) ? 1 : position + 2;\\n            }\\n        }\\n        \\n        return str.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public string ReorganizeString(string s)\\n    {\\n        if (s == null || s.Length < 2)\\n            return s;\\n            \\n        int n = s.Length;\\n        \\n        // Calculate and store frequencies in char-frequency map.\\n        // Find character and frequency with max frequency\\n        int freqChar = -1;\\n        int freqCharCount = -1;\\n        int[] freq = new int[26];\\n        for(int i = 0; i < n; i++)\\n        {\\n            freq[s[i] - \\'a\\']++;\\n            if (freq[s[i] - \\'a\\'] > freqCharCount)\\n            {\\n                freqCharCount = freq[s[i] - \\'a\\'];\\n                freqChar = s[i] - \\'a\\';\\n            }\\n        }\\n        \\n        // Required string is only possible when char with max frequency is less than equal to half of size of given string.\\n        if (freqCharCount > (n + 1) / 2)\\n            return \"\";\\n        \\n        StringBuilder str = new StringBuilder(s);\\n        int position = 0;\\n        // In case it is possible, arrange the most occuring character on even positions. \\n        // Arrange the remaining characters on alternate remaining positions. \\n        // This makes sure that no 2 same character occurs together.\\n        for (int i = -1; i < 26; i++)\\n        {\\n            int current = (i == -1) ? freqChar : i;\\n            while (freq[current]-- > 0)\\n            {\\n                str[position] = (char)(\\'a\\' + current);\\n                position = (position + 2 >= n) ? 1 : position + 2;\\n            }\\n        }\\n        \\n        return str.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427771,
                "title": "python-count-and-rearrange-o-n-beats-100-time-and-space",
                "content": "```\\nclass Solution:\\n    def reorganizeString(self, S: str) -> str:\\n        counts = collections.Counter(S)\\n        maxc = 0\\n        \\n        for k,v in counts.items():\\n            if v>maxc:\\n                maxc = v\\n                maxs = k\\n        \\n        if maxc>(len(S)+1)//2:\\n            return \\'\\'\\n        \\n        out = [maxs]*maxc\\n        count = 0\\n        for kk in counts:\\n            if maxs!= kk:\\n                for i in range(counts[kk]):\\n                    out[count%maxc] += kk\\n                    count += 1\\n        return \\'\\'.join(out)\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reorganizeString(self, S: str) -> str:\\n        counts = collections.Counter(S)\\n        maxc = 0\\n        \\n        for k,v in counts.items():\\n            if v>maxc:\\n                maxc = v\\n                maxs = k\\n        \\n        if maxc>(len(S)+1)//2:\\n            return \\'\\'\\n        \\n        out = [maxs]*maxc\\n        count = 0\\n        for kk in counts:\\n            if maxs!= kk:\\n                for i in range(counts[kk]):\\n                    out[count%maxc] += kk\\n                    count += 1\\n        return \\'\\'.join(out)\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 343412,
                "title": "java-pq-explained",
                "content": "1. Use Binary Max Heap and put all characters and ordered by their frequencies.\\n2. One by one take highest frequency character from the heap and add it to result. \\n3. Once added, decrease frequency of the character and temporarily move this character out of Max Heap so that it is not picked next time.\\n4. If length of the result if same as input String return the result, else empty string.\\n\\n```\\nimport java.util.*;\\n\\nclass Pair implements Comparable<Pair> {\\n    public int key;\\n    public int freq;\\n    \\n    public Pair(int key, int freq) {\\n        this.key = key;\\n        this.freq = freq;\\n    }\\n    \\n    public int compareTo(Pair o1) {\\n        return o1.freq - freq;\\n    }\\n}\\n\\n\\nclass Solution {\\n    \\n    public String reorganizeString(String S) {\\n        int[] dict = new int[26];\\n        for (int index = 0; index < S.length(); ++index)\\n            dict[S.charAt(index) - \\'a\\']++;\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        for (int index = 0; index < 26; ++index) {\\n            if (dict[index] > 0)\\n                pq.offer(new Pair(index + \\'a\\', dict[index]));\\n        }\\n        String res = \"\";\\n        Pair temp = new Pair(\\'#\\', -1);\\n        while (!pq.isEmpty()) {\\n            Pair curr = pq.poll();\\n            res = res + (char) curr.key;\\n            curr.freq--;\\n            if (temp.freq > 0)\\n                pq.offer(temp);\\n            temp = curr;\\n        }\\n        if (res.length() == S.length())\\n            return res;\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\n\\nclass Pair implements Comparable<Pair> {\\n    public int key;\\n    public int freq;\\n    \\n    public Pair(int key, int freq) {\\n        this.key = key;\\n        this.freq = freq;\\n    }\\n    \\n    public int compareTo(Pair o1) {\\n        return o1.freq - freq;\\n    }\\n}\\n\\n\\nclass Solution {\\n    \\n    public String reorganizeString(String S) {\\n        int[] dict = new int[26];\\n        for (int index = 0; index < S.length(); ++index)\\n            dict[S.charAt(index) - \\'a\\']++;\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        for (int index = 0; index < 26; ++index) {\\n            if (dict[index] > 0)\\n                pq.offer(new Pair(index + \\'a\\', dict[index]));\\n        }\\n        String res = \"\";\\n        Pair temp = new Pair(\\'#\\', -1);\\n        while (!pq.isEmpty()) {\\n            Pair curr = pq.poll();\\n            res = res + (char) curr.key;\\n            curr.freq--;\\n            if (temp.freq > 0)\\n                pq.offer(temp);\\n            temp = curr;\\n        }\\n        if (res.length() == S.length())\\n            return res;\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329985,
                "title": "intuitive-generic-java-solution",
                "content": "**Idea** \\nSame as `Task Scheduler` problem with cooling period = 1.\\nhttps://leetcode.com/problems/task-scheduler/description/\\n\\n\\n```\\npublic String reorganizeString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        Map<Character, Integer> freq = new HashMap<>();\\n        for(char ch : s.toCharArray())\\n            freq.put(ch, freq.getOrDefault(ch, 0)+1);\\n        \\n        PriorityQueue<Map.Entry<Character, Integer>> pq = new PriorityQueue<>(new Comparator<Map.Entry<Character, Integer>>(){\\n            public int compare(Map.Entry<Character, Integer> e1, Map.Entry<Character, Integer> e2){\\n                return e2.getValue()-e1.getValue();\\n            }\\n        });\\n        pq.addAll(freq.entrySet());\\n        Queue<Map.Entry<Character, Integer>> blacklist = new LinkedList<>();\\n        while(!pq.isEmpty()){\\n            int k=2; //cooling_period+1\\n            while(k > 0 && !pq.isEmpty()){\\n                Map.Entry<Character, Integer> e = pq.remove();\\n                e.setValue(e.getValue()-1);\\n                sb.append(e.getKey());\\n                blacklist.add(e);\\n                --k; //first item in the blacklist will wait for cooling_period units and then gets released\\n            }\\n            while(!blacklist.isEmpty()){\\n                Map.Entry<Character, Integer> e = blacklist.remove();\\n                if(e.getValue() > 0)\\n                    pq.add(e);\\n            }\\n            if(pq.isEmpty()) break;\\n            if(k > 0) return \"\"; //if idle slots allowed, we need k slots here\\n        }\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String reorganizeString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        Map<Character, Integer> freq = new HashMap<>();\\n        for(char ch : s.toCharArray())\\n            freq.put(ch, freq.getOrDefault(ch, 0)+1);\\n        \\n        PriorityQueue<Map.Entry<Character, Integer>> pq = new PriorityQueue<>(new Comparator<Map.Entry<Character, Integer>>(){\\n            public int compare(Map.Entry<Character, Integer> e1, Map.Entry<Character, Integer> e2){\\n                return e2.getValue()-e1.getValue();\\n            }\\n        });\\n        pq.addAll(freq.entrySet());\\n        Queue<Map.Entry<Character, Integer>> blacklist = new LinkedList<>();\\n        while(!pq.isEmpty()){\\n            int k=2; //cooling_period+1\\n            while(k > 0 && !pq.isEmpty()){\\n                Map.Entry<Character, Integer> e = pq.remove();\\n                e.setValue(e.getValue()-1);\\n                sb.append(e.getKey());\\n                blacklist.add(e);\\n                --k; //first item in the blacklist will wait for cooling_period units and then gets released\\n            }\\n            while(!blacklist.isEmpty()){\\n                Map.Entry<Character, Integer> e = blacklist.remove();\\n                if(e.getValue() > 0)\\n                    pq.add(e);\\n            }\\n            if(pq.isEmpty()) break;\\n            if(k > 0) return \"\"; //if idle slots allowed, we need k slots here\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 243968,
                "title": "javascript",
                "content": "```\\nvar reorganizeString = function(S) {\\n    let map = {}\\n    for(let s of S){\\n        map[s] = map[s] ? [s, map[s][1] + 1] : [s, 1]\\n    }\\n    let array = Object.values(map)\\n    array.sort((a,b) => (b[1] - a[1]))\\n    \\n    let result = \"\", previous = \"\"\\n    for(let i = 0; i < S.length; i++){\\n        let j = 0, find = false\\n        while(j < array.length){\\n            if(array[j][0] !== previous && array[j][1] > 0){\\n                find = true\\n                break\\n            }\\n            j += 1\\n        }\\n        if(!find) {\\n            return \"\"\\n        }\\n        result += array[j][0]\\n        array[j][1] -= 1\\n        previous = array[j][0]\\n        if(j < array.length - 1 && array[j][1] < array[j+1][1]){\\n            [array[j], array[j+1]] = [array[j+1], array[j]]\\n        }\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar reorganizeString = function(S) {\\n    let map = {}\\n    for(let s of S){\\n        map[s] = map[s] ? [s, map[s][1] + 1] : [s, 1]\\n    }\\n    let array = Object.values(map)\\n    array.sort((a,b) => (b[1] - a[1]))\\n    \\n    let result = \"\", previous = \"\"\\n    for(let i = 0; i < S.length; i++){\\n        let j = 0, find = false\\n        while(j < array.length){\\n            if(array[j][0] !== previous && array[j][1] > 0){\\n                find = true\\n                break\\n            }\\n            j += 1\\n        }\\n        if(!find) {\\n            return \"\"\\n        }\\n        result += array[j][0]\\n        array[j][1] -= 1\\n        previous = array[j][0]\\n        if(j < array.length - 1 && array[j][1] < array[j+1][1]){\\n            [array[j], array[j+1]] = [array[j+1], array[j]]\\n        }\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 113430,
                "title": "10-liner-round-robin-in-frequency-order",
                "content": "The idea is straightforward:\\n1. Get frequencies `f[26]` of chars in `s`. Note if `max > (n+1)/2`, cannot build answer (*early termination check*).\\n1. Rearrange `s` in sorted frequencies.\\n1. Build answer string by taking chars from rearranged `s` in round robin way (each small string has no duplicated chars).\\n1. Join small strings to get answer.\\n\\n```cpp\\n    string reorganizeString(string s) \\n    {\\n        // build frequency of chars\\n        vector<int> f(26);\\n        for (char c : s) ++f[c-\\'a\\'];\\n        int maxFre = *max_element(f.begin(), f.end()), n = s.size(); \\n        if (maxFre > (n+1)/2) return \"\"; // early termination\\n        \\n        // sort frequencies\\n        set<pair<int,int>> sf;\\n        for (int i = 0; i < f.size(); ++i) sf.emplace(f[i], i); // (count, char)\\n        \\n        // sort chars by sorted frequencies\\n        for (auto& x : sf) s.replace(n-=x.first, x.first, x.first, \\'a\\'+x.second);\\n        \\n        // build answer by round robin\\n        vector<string> strs(maxFre);\\n        while (n < s.size()) strs[n++%maxFre] += s[n]; // round robin\\n        return accumulate(strs.begin(), strs.end(), s=\"\");\\n    }\\n```\\n\\n**Updated solution without sorting frequencies**.\\n**NOTE:** Actually, as long as we find a char with max frequency, it doesn\\'t matter the order of remaining frequencies since the count of any other chars cannot make more than one round.\\n```cpp\\n    string reorganizeString(string s) \\n    {\\n      // build char frequency\\n      unordered_map<char, int> fre; \\n      for (char c : s) fre[c]++;\\n      \\n      // find max frequency\\n      int max_fre = 0;\\n      char max_char;\\n      for (auto& p : fre)\\n        if (p.second > max_fre) {\\n          max_fre = p.second;\\n          max_char = p.first;\\n        }\\n      \\n      if (max_fre > (s.size()+1)/2) return \"\"; // can\\'t arrange    \\n      \\n      fre.erase(max_char);\\n      \\n      // append remaining chars to strs by \"round robin\"\\n      vector<string> strs(max_fre, string(1, max_char));\\n      int i = 0; // strs[] index\\n      for (auto& p : fre) {\\n        while (p.second--) \\n          strs[i++%max_fre] += p.first;\\n      }\\n      \\n      // concatenate strs\\n      return accumulate(strs.begin(), strs.end(), s = \"\");\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```cpp\\n    string reorganizeString(string s) \\n    {\\n        // build frequency of chars\\n        vector<int> f(26);\\n        for (char c : s) ++f[c-\\'a\\'];\\n        int maxFre = *max_element(f.begin(), f.end()), n = s.size(); \\n        if (maxFre > (n+1)/2) return \"\"; // early termination\\n        \\n        // sort frequencies\\n        set<pair<int,int>> sf;\\n        for (int i = 0; i < f.size(); ++i) sf.emplace(f[i], i); // (count, char)\\n        \\n        // sort chars by sorted frequencies\\n        for (auto& x : sf) s.replace(n-=x.first, x.first, x.first, \\'a\\'+x.second);\\n        \\n        // build answer by round robin\\n        vector<string> strs(maxFre);\\n        while (n < s.size()) strs[n++%maxFre] += s[n]; // round robin\\n        return accumulate(strs.begin(), strs.end(), s=\"\");\\n    }\\n```\n```cpp\\n    string reorganizeString(string s) \\n    {\\n      // build char frequency\\n      unordered_map<char, int> fre; \\n      for (char c : s) fre[c]++;\\n      \\n      // find max frequency\\n      int max_fre = 0;\\n      char max_char;\\n      for (auto& p : fre)\\n        if (p.second > max_fre) {\\n          max_fre = p.second;\\n          max_char = p.first;\\n        }\\n      \\n      if (max_fre > (s.size()+1)/2) return \"\"; // can\\'t arrange    \\n      \\n      fre.erase(max_char);\\n      \\n      // append remaining chars to strs by \"round robin\"\\n      vector<string> strs(max_fre, string(1, max_char));\\n      int i = 0; // strs[] index\\n      for (auto& p : fre) {\\n        while (p.second--) \\n          strs[i++%max_fre] += p.first;\\n      }\\n      \\n      // concatenate strs\\n      return accumulate(strs.begin(), strs.end(), s = \"\");\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 113451,
                "title": "7-ms-java-o-n-solution-no-sorting",
                "content": "```\\nclass Solution {\\n    public String reorganizeString(String S) {\\n        int n = S.length();\\n        int[] cnt = new int[128];\\n        char mc = 'a';\\n        for (char c : S.toCharArray()) {\\n            cnt[c]++;\\n            mc = (cnt[c] > cnt[mc]) ? c : mc;\\n        }\\n        if (cnt[mc] == 1) {\\n            return S;\\n        }\\n        if (n - cnt[mc] <= cnt[mc] - 2) {\\n            return \"\";\\n        }\\n        StringBuilder[] sb = new StringBuilder[cnt[mc]];\\n        for (int i = 0; i < sb.length; i ++) {\\n            sb[i] = new StringBuilder();\\n            sb[i].append(mc);\\n        }\\n        int k = 0;\\n        for (char c = 'a'; c <= 'z'; c++) {\\n            while (c != mc && cnt[c] > 0) {\\n                sb[k++].append(c);\\n                cnt[c]--;\\n                k %= sb.length;\\n            }\\n        }\\n        for (int i = 1; i < sb.length; i++) {\\n            sb[0].append(sb[i]);\\n        }\\n        return sb[0].toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String reorganizeString(String S) {\\n        int n = S.length();\\n        int[] cnt = new int[128];\\n        char mc = 'a';\\n        for (char c : S.toCharArray()) {\\n            cnt[c]++;\\n            mc = (cnt[c] > cnt[mc]) ? c : mc;\\n        }\\n        if (cnt[mc] == 1) {\\n            return S;\\n        }\\n        if (n - cnt[mc] <= cnt[mc] - 2) {\\n            return \"\";\\n        }\\n        StringBuilder[] sb = new StringBuilder[cnt[mc]];\\n        for (int i = 0; i < sb.length; i ++) {\\n            sb[i] = new StringBuilder();\\n            sb[i].append(mc);\\n        }\\n        int k = 0;\\n        for (char c = 'a'; c <= 'z'; c++) {\\n            while (c != mc && cnt[c] > 0) {\\n                sb[k++].append(c);\\n                cnt[c]--;\\n                k %= sb.length;\\n            }\\n        }\\n        for (int i = 1; i < sb.length; i++) {\\n            sb[0].append(sb[i]);\\n        }\\n        return sb[0].toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999222,
                "title": "reorganize-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        vector<int> H (26,0);\\n        for(int i = 0 ; s[i]!=\\'\\\\0\\';i++)\\n        H[s[i]-97]++;\\n\\n        int max = 0 , letter = 0 ;\\n        for(int i = 0 ; i<H.size();i++)\\n        {\\n            if(H[i]> max )\\n            {\\n                max = H[i];\\n                letter = i ;\\n            }\\n        }\\n        if(max > (s.length()+1)/2) return \"\";\\n        vector<char> res(s.length());\\n        int index = 0;\\n        while(H[letter]-- > 0 )\\n        {\\n            \\n            res[index]= static_cast<char>(letter + \\'a\\');\\n            index+=2;\\n        }\\n\\n        for(int i = 0 ; i < H.size();i++)\\n        {\\n            while(H[i]-->0)\\n            {\\n                \\n                if(index>=res.size()) index=1;\\n                res[index]=static_cast<char>(i + \\'a\\');\\n                index+=2;\\n            }\\n        }\\n        return string(res.begin(),res.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        vector<int> H (26,0);\\n        for(int i = 0 ; s[i]!=\\'\\\\0\\';i++)\\n        H[s[i]-97]++;\\n\\n        int max = 0 , letter = 0 ;\\n        for(int i = 0 ; i<H.size();i++)\\n        {\\n            if(H[i]> max )\\n            {\\n                max = H[i];\\n                letter = i ;\\n            }\\n        }\\n        if(max > (s.length()+1)/2) return \"\";\\n        vector<char> res(s.length());\\n        int index = 0;\\n        while(H[letter]-- > 0 )\\n        {\\n            \\n            res[index]= static_cast<char>(letter + \\'a\\');\\n            index+=2;\\n        }\\n\\n        for(int i = 0 ; i < H.size();i++)\\n        {\\n            while(H[i]-->0)\\n            {\\n                \\n                if(index>=res.size()) index=1;\\n                res[index]=static_cast<char>(i + \\'a\\');\\n                index+=2;\\n            }\\n        }\\n        return string(res.begin(),res.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951482,
                "title": "c-beginner-friendly-solution-beats-100",
                "content": "# Intuition\\n\\n# Approach\\n-Create a simple Hash table with size 26 to count the frequency of letters\\n-Find the letter with maximum frequency \\n\\nstep 1: when maximum frequency  > half of the length of given string, it dont have any possible combination,\\n\\nstep 2: from 0th index , fill the maximum occuring element in even index\\n res : a _ a \\n\\nstep 3 : fill the remaining elements , by keeping count of their occurances, \\n   res: aba  ( since the index value is greater than the size of \\'res\\', index is assigned to 1 )\\n\\n\\n# Complexity\\n-  Time complexity:O(n) \\n    this code contains a while loop inside the for loop , still it achieves overall time complexity as o(n), coz the total number of iterations is directly proportional to the length of string i.e \\'n\\'.\\n\\n- **Space complexity:O(1)**\\n     The space complexity for the H array is O(1) because it has a fixed size of 26, which doesn\\'t depend on the input size.\\n\\n![upvote.jpeg](https://assets.leetcode.com/users/images/ff87479b-f4c2-4d18-96d4-b80fbdd3febc_1692816544.2889514.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        vector<int> H (26,0);\\n        for(int i = 0 ; s[i]!=\\'\\\\0\\';i++)\\n        H[s[i]-97]++;\\n\\n        int max = 0 , letter = 0 ;\\n        for(int i = 0 ; i<H.size();i++)\\n        {\\n            if(H[i]> max )\\n            {\\n                max = H[i];\\n                letter = i ;\\n            }\\n        }\\n        if(max > (s.length()+1)/2) return \"\";\\n        vector<char> res(s.length());\\n        int index = 0;\\n        while(H[letter]-- > 0 )\\n        {\\n            \\n            res[index]= static_cast<char>(letter + \\'a\\');\\n            index+=2;\\n        }\\n\\n        for(int i = 0 ; i < H.size();i++)\\n        {\\n            while(H[i]-->0)\\n            {\\n                \\n                if(index>=res.size()) index=1;\\n                res[index]=static_cast<char>(i + \\'a\\');\\n                index+=2;\\n            }\\n        }\\n        return string(res.begin(),res.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        vector<int> H (26,0);\\n        for(int i = 0 ; s[i]!=\\'\\\\0\\';i++)\\n        H[s[i]-97]++;\\n\\n        int max = 0 , letter = 0 ;\\n        for(int i = 0 ; i<H.size();i++)\\n        {\\n            if(H[i]> max )\\n            {\\n                max = H[i];\\n                letter = i ;\\n            }\\n        }\\n        if(max > (s.length()+1)/2) return \"\";\\n        vector<char> res(s.length());\\n        int index = 0;\\n        while(H[letter]-- > 0 )\\n        {\\n            \\n            res[index]= static_cast<char>(letter + \\'a\\');\\n            index+=2;\\n        }\\n\\n        for(int i = 0 ; i < H.size();i++)\\n        {\\n            while(H[i]-->0)\\n            {\\n                \\n                if(index>=res.size()) index=1;\\n                res[index]=static_cast<char>(i + \\'a\\');\\n                index+=2;\\n            }\\n        }\\n        return string(res.begin(),res.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950999,
                "title": "python-3-runtime-26ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n\\n        # Create a hashmap to store frequency of words\\n        hashm={}\\n        res=\"\"\\n        for i in s:\\n            if i in hashm:\\n                hashm[i]+=1\\n            else:\\n                hashm[i]=1\\n\\n        # Maxheap\\n        h=[]\\n        for i in hashm:\\n            heapq.heappush(h,[-hashm[i],i])\\n\\n        # Basically following a greedy approach where we keep on adding higher frequcny chars to result string.\\n        \\n        # Intilaaly add most repeated charecter to result\\n        temp=heapq.heappop(h)\\n        res+=temp[1]\\n        if temp[0]+1:\\n            heapq.heappush(h,[temp[0]+1,temp[1]])\\n\\n        while h:\\n\\n            # Check if last charecter of result matches firstchar in heap i.e; highest count one\\n\\n            # If it doesnt match add to result\\n            if res[-1]!=h[0][1]:\\n                temp=heapq.heappop(h)\\n                res+=temp[1]\\n                if temp[0]+1:\\n                    heapq.heappush(h,[temp[0]+1,temp[1]])\\n            else:\\n\\n                # This means there is only one char in heap and this matches with last char in result i.e; we get two same chars even after appending to result. So return empty string\\n                if len(h)==1:\\n                    return \"\"\\n\\n                # Else, add second elemnt in heap to result \\n                else:\\n                    temp1=heapq.heappop(h)\\n                    temp2=heapq.heappop(h)\\n                    res+=temp2[1]\\n                    if temp2[0]+1:\\n                        heapq.heappush(h,[temp2[0]+1,temp2[1]])\\n                    heapq.heappush(h,[temp1[0],temp1[1]])\\n        \\n        return res\\n\\n\\n        \\n\\n\\n            \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n\\n        # Create a hashmap to store frequency of words\\n        hashm={}\\n        res=\"\"\\n        for i in s:\\n            if i in hashm:\\n                hashm[i]+=1\\n            else:\\n                hashm[i]=1\\n\\n        # Maxheap\\n        h=[]\\n        for i in hashm:\\n            heapq.heappush(h,[-hashm[i],i])\\n\\n        # Basically following a greedy approach where we keep on adding higher frequcny chars to result string.\\n        \\n        # Intilaaly add most repeated charecter to result\\n        temp=heapq.heappop(h)\\n        res+=temp[1]\\n        if temp[0]+1:\\n            heapq.heappush(h,[temp[0]+1,temp[1]])\\n\\n        while h:\\n\\n            # Check if last charecter of result matches firstchar in heap i.e; highest count one\\n\\n            # If it doesnt match add to result\\n            if res[-1]!=h[0][1]:\\n                temp=heapq.heappop(h)\\n                res+=temp[1]\\n                if temp[0]+1:\\n                    heapq.heappush(h,[temp[0]+1,temp[1]])\\n            else:\\n\\n                # This means there is only one char in heap and this matches with last char in result i.e; we get two same chars even after appending to result. So return empty string\\n                if len(h)==1:\\n                    return \"\"\\n\\n                # Else, add second elemnt in heap to result \\n                else:\\n                    temp1=heapq.heappop(h)\\n                    temp2=heapq.heappop(h)\\n                    res+=temp2[1]\\n                    if temp2[0]+1:\\n                        heapq.heappush(h,[temp2[0]+1,temp2[1]])\\n                    heapq.heappush(h,[temp1[0],temp1[1]])\\n        \\n        return res\\n\\n\\n        \\n\\n\\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950451,
                "title": "linear-java-solution",
                "content": "# Intuition\\nThe intuition behind this algorithm was that we can split a string into similar segments that later need to fill with different characters.\\n\\n# Approach\\nThe approach is to count the occurences of each character in the string s. Then, we select the one with the most occurences, and if it is occuring too much (max > sum + 1), that means that there will be at least one segment that will be empty (eg. aab resolves to ab|a, but\\naaab resolves to ab|a|a). Then, we add next elements to the result,\\nand every time we do that we add the character thathas the most remaining occurences, wasn\\'t the last added character and isn\\'t the most occuring char itself. And that\\'s it.\\n\\n# Complexity\\n- Time complexity:\\nO(26n) ~ O(n): for each character in s we loop through the array of length 26 (length of the alphabet).\\n\\n- Space complexity:\\nO(n): we need a variable result that will store our result of length s.\\n\\n# Code\\n```\\nclass Solution {\\n    public String reorganizeString(String s) {\\n        //edge cases\\n        if(s.equals(\"\")){return \"\";}\\n        else if(s.length() == 1){return s;}\\n\\n        //Table used to count the number \\n        //of occurences for each character\\n        int[] chars = new int[26];\\n        //Filling up the table\\n        for(int i = 0; i < s.length(); ++i)\\n        {++chars[s.charAt(i) - 97];}\\n\\n        //Finding the cahacter with most occurences\\n        int max = 0;\\n        int sum = 0;\\n        int maxIter = 0;\\n        for(int i = 0; i < chars.length; ++i){\\n            if(chars[i] > max){\\n                sum += max;\\n                maxIter = i;\\n                max = chars[i];\\n            }\\n            else{sum += chars[i];}\\n        }\\n        //If the number of occurences of the \"max\" character\\n        //is greater than sum+1, it means that at least two\\n        //occurences of this character would be adjacent,\\n        //so we return \"\".\\n        if(max > sum && max - sum >= 2){return \"\";}\\n        int iter = 0;\\n        //StringBuilder is mutable, so it is more\\n        //memory-efficient than the String class itself.\\n        StringBuilder result = new StringBuilder();\\n        int amount = s.length()/max;\\n        //Edge case, eg if we have \"aaaabbbb\", amount is 2,\\n        //but we want to add only one character (\\'b\\') after \\'a\\'.\\n        if(amount * max == s.length()){--amount;}\\n        int subMax = max;\\n        //We iterate as long as our result is shorter\\n        //than the given String s\\n        while(result.length() < s.length()){\\n            //Appending the character that occurs the most in s\\n            result.append((char)(97+maxIter));\\n            iter = maxIter;\\n            for(int i = 0; i < amount; ++i){\\n                if(result.length() >= s.length()){break;}\\n                //Looking for the most frequently appearing\\n                //character that wasn\\'t appended to the result\\n                //and is not our \"max\" character.\\n                int maxLocal = 0;\\n                int maxIterLocal = 0;\\n                for(int j = 0; j < chars.length; ++j){\\n                    if(chars[j] > maxLocal && \\n                    j != iter && j != maxIter){\\n                        maxLocal = chars[j];\\n                        maxIterLocal = j;\\n                    }\\n                }\\n                iter = maxIterLocal;\\n                //If we didn\\'t find any character other than\\n                //our \"max\" char and the char that was added last,\\n                //we continue our loop.\\n                if(iter == 0 && chars[iter] == 0){continue;}\\n                result.append((char)(97+(iter%26)));\\n                --chars[iter%26];\\n            }\\n        }\\n\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reorganizeString(String s) {\\n        //edge cases\\n        if(s.equals(\"\")){return \"\";}\\n        else if(s.length() == 1){return s;}\\n\\n        //Table used to count the number \\n        //of occurences for each character\\n        int[] chars = new int[26];\\n        //Filling up the table\\n        for(int i = 0; i < s.length(); ++i)\\n        {++chars[s.charAt(i) - 97];}\\n\\n        //Finding the cahacter with most occurences\\n        int max = 0;\\n        int sum = 0;\\n        int maxIter = 0;\\n        for(int i = 0; i < chars.length; ++i){\\n            if(chars[i] > max){\\n                sum += max;\\n                maxIter = i;\\n                max = chars[i];\\n            }\\n            else{sum += chars[i];}\\n        }\\n        //If the number of occurences of the \"max\" character\\n        //is greater than sum+1, it means that at least two\\n        //occurences of this character would be adjacent,\\n        //so we return \"\".\\n        if(max > sum && max - sum >= 2){return \"\";}\\n        int iter = 0;\\n        //StringBuilder is mutable, so it is more\\n        //memory-efficient than the String class itself.\\n        StringBuilder result = new StringBuilder();\\n        int amount = s.length()/max;\\n        //Edge case, eg if we have \"aaaabbbb\", amount is 2,\\n        //but we want to add only one character (\\'b\\') after \\'a\\'.\\n        if(amount * max == s.length()){--amount;}\\n        int subMax = max;\\n        //We iterate as long as our result is shorter\\n        //than the given String s\\n        while(result.length() < s.length()){\\n            //Appending the character that occurs the most in s\\n            result.append((char)(97+maxIter));\\n            iter = maxIter;\\n            for(int i = 0; i < amount; ++i){\\n                if(result.length() >= s.length()){break;}\\n                //Looking for the most frequently appearing\\n                //character that wasn\\'t appended to the result\\n                //and is not our \"max\" character.\\n                int maxLocal = 0;\\n                int maxIterLocal = 0;\\n                for(int j = 0; j < chars.length; ++j){\\n                    if(chars[j] > maxLocal && \\n                    j != iter && j != maxIter){\\n                        maxLocal = chars[j];\\n                        maxIterLocal = j;\\n                    }\\n                }\\n                iter = maxIterLocal;\\n                //If we didn\\'t find any character other than\\n                //our \"max\" char and the char that was added last,\\n                //we continue our loop.\\n                if(iter == 0 && chars[iter] == 0){continue;}\\n                result.append((char)(97+(iter%26)));\\n                --chars[iter%26];\\n            }\\n        }\\n\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949578,
                "title": "easiest-c-code-beats-100-without-priority-queue",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Count the frequency of each character and store it in a map.\\n- To sort the characters according to the frequency, store them in a vector pair and sort.\\n- Now we put the characters with the highest frquency in alternate positions starting with index 0 and do this until all the alternate positions are filled.\\n- Now we put the rest of the characters alternatively in the index starting with the index 1.\\n- Lastly, we check if the final string has any characters repeating simultaneously.\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(2n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool static compareByValue(const pair<char, int>& a, const pair<char, int>& b){\\n        return a.second > b.second;\\n    }\\n    string reorganizeString(string s) {\\n        map<char,int> mp;\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        vector<pair<char, int>> sortedPairs(mp.begin(), mp.end());\\n        sort(sortedPairs.begin(), sortedPairs.end(), compareByValue);\\n        int j=0;\\n        auto x=sortedPairs[j];\\n        for(int i=0;i<s.length();i+=2){\\n            if(x.second==0 && j<sortedPairs.size()-1){\\n                j++;\\n                x=sortedPairs[j];\\n            }\\n            s[i]=x.first;\\n            x.second--;\\n        }\\n        for(int i=1;i<s.length();i+=2){\\n            if(x.second==0 && j<sortedPairs.size()-1){\\n                j++;\\n                x=sortedPairs[j];\\n            }\\n            s[i]=x.first;\\n            x.second--;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==s[i+1]){\\n                return \"\";\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Ordered Map",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static compareByValue(const pair<char, int>& a, const pair<char, int>& b){\\n        return a.second > b.second;\\n    }\\n    string reorganizeString(string s) {\\n        map<char,int> mp;\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        vector<pair<char, int>> sortedPairs(mp.begin(), mp.end());\\n        sort(sortedPairs.begin(), sortedPairs.end(), compareByValue);\\n        int j=0;\\n        auto x=sortedPairs[j];\\n        for(int i=0;i<s.length();i+=2){\\n            if(x.second==0 && j<sortedPairs.size()-1){\\n                j++;\\n                x=sortedPairs[j];\\n            }\\n            s[i]=x.first;\\n            x.second--;\\n        }\\n        for(int i=1;i<s.length();i+=2){\\n            if(x.second==0 && j<sortedPairs.size()-1){\\n                j++;\\n                x=sortedPairs[j];\\n            }\\n            s[i]=x.first;\\n            x.second--;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==s[i+1]){\\n                return \"\";\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949425,
                "title": "greedy-approach-easiest-and-simplified-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe Just need to use the logic of keeping a Gap between any 2 same characters!! \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow the same characters can be easily separated keeping a gap of 1 between them or always keeping them at Alternate positions.\\nSo we will simply always pick the characters with the highest frequency and will keep them on alternate position.\\nThe String will be returned empty only when :\\n1) Length of String is Odd :    \\n\"aaabb\" => \"ababa\"(pssbl)\\n\"aaaab\" => not pssbl\\nThat is if any character occurs more than (len+1)/2, then return the empty string\\n2) Length of String is Even :    \\n\"aaabbb\" => \"ababab\"\\n\"aaaabb\" => not pssbl\\nIf any character occurs more than half the length of the string \\n\\nConclusion : Ans is empty string only if any character occurs more than (len+1)/2\\n{len denotes length of the string}\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(26)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll int\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int sz = s.size();\\n        vector<int> v(26,0);\\n        for(int i = 0;i<sz;++i){\\n            v[s[i]-\\'a\\']++;\\n            if(v[s[i]-\\'a\\'] > (sz+1)/2){return \"\";}\\n        }\\n        map<char,ll> mp;\\n        for(int i = 0;i<26;++i){\\n            if(v[i]){\\n                mp[i+\\'a\\'] = v[i];\\n            }\\n        }\\n\\n        multiset<pair<ll,char>> ms;\\n        for(auto it:mp){\\n            ms.insert({it.second,it.first});\\n        }\\n        \\n        string tmp;\\n        while(!ms.empty()){\\n            auto p = *ms.rbegin();ms.erase(p);\\n            while(p.first--){\\n                tmp += p.second;\\n            }\\n        }\\n        s.clear();s = tmp;\\n\\n        vector<char> ok(sz);\\n        int i = 0,j = 0,n = sz;\\n        while(n--){   \\n            ok[i] = s[j];\\n            i += 2;++j;\\n            if(i >= sz){\\n                i = 1;\\n            }\\n        }\\n        string ans;\\n        for(auto it:ok){ans += it;}\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Greedy",
                    "Ordered Map"
                ],
                "code": "```\\n#define ll int\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int sz = s.size();\\n        vector<int> v(26,0);\\n        for(int i = 0;i<sz;++i){\\n            v[s[i]-\\'a\\']++;\\n            if(v[s[i]-\\'a\\'] > (sz+1)/2){return \"\";}\\n        }\\n        map<char,ll> mp;\\n        for(int i = 0;i<26;++i){\\n            if(v[i]){\\n                mp[i+\\'a\\'] = v[i];\\n            }\\n        }\\n\\n        multiset<pair<ll,char>> ms;\\n        for(auto it:mp){\\n            ms.insert({it.second,it.first});\\n        }\\n        \\n        string tmp;\\n        while(!ms.empty()){\\n            auto p = *ms.rbegin();ms.erase(p);\\n            while(p.first--){\\n                tmp += p.second;\\n            }\\n        }\\n        s.clear();s = tmp;\\n\\n        vector<char> ok(sz);\\n        int i = 0,j = 0,n = sz;\\n        while(n--){   \\n            ok[i] = s[j];\\n            i += 2;++j;\\n            if(i >= sz){\\n                i = 1;\\n            }\\n        }\\n        string ans;\\n        for(auto it:ok){ans += it;}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948952,
                "title": "c-human-friendly-solution-map-and-heap-detailed-w-comments-day-24",
                "content": "\\n# Approach\\nThis is def. a little tricky one!\\n What we planning to do here is, everytime we add that character to the ```ans``` string, which PRESENTLY is the **most abundant one**!\\nso for that we use *hash table* to store the freq. of occurence of each character and then use a *max-heap* to arrange those frequencies along with its respective character such that the character with highest freq. of occurence appears on top! (property of max-heap)\\n\\nNow, one by one we get the **1st most abundant** char from max-heap and append it to the ```ans``` string, then we get the **2nd most abundant** char and append it to the ```ans``` string. We do this so that there is no chances of repeating of same characters.\\n\\nPlease look at the code for line by line explanation!\\nPLEASE UPVOTE IF THIS HELPS!\\nHappy leetcoding! CHEERS!\\n\\n\\n# Code\\n```\\n//space comp : O(N) + O(N) - i.e. map and heap\\n//time comp : O(N*logN)\\n\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        \\n        int n = s.size();\\n        if(n==1) return s; //understood!\\n\\n        string ans = \"\";\\n        unordered_map<int,int> mp;\\n        for(int i=0; i<n; i++) mp[s[i]]++; //storing the frequency of each character type of s\\n\\n        priority_queue< pair<int,char> > pq; //max heap with pair => {freq, character}\\n        for(auto it: mp){\\n            pq.push({it.second, it.first});\\n        }\\n\\n        while(pq.size()>1){  //do until size of priority queue is larger than 1\\n\\n            char c = pq.top().second;\\n            int cnt = pq.top().first;\\n            pq.pop();\\n\\n            ans = ans + c; //concatenate to ans string the char with 1st largest occurence\\n\\n            char ch = pq.top().second;\\n            int count = pq.top().first;\\n            pq.pop();\\n\\n            ans = ans + ch;  //concatenate to ans string the char with 2nd largest occurence\\n\\n            // if that char still has occurences left,\\n            // we push it back into pq with the ONE size reduced (new size = old size - 1)\\n            if(cnt!=1) pq.push({--cnt,c});  \\n            if(count!=1) pq.push({--count,ch});\\n        }\\n        \\n        if(pq.size()>1 || pq.top().first>1){ //in this case we cannot have desired ans string\\n            return \"\"; //so return empty string\\n        }\\n\\n        else if(pq.size()==1){\\n            ans = ans + pq.top().second; //add the last remaining character to ans and return the final ans!\\n            pq.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```ans```\n```ans```\n```ans```\n```\\n//space comp : O(N) + O(N) - i.e. map and heap\\n//time comp : O(N*logN)\\n\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        \\n        int n = s.size();\\n        if(n==1) return s; //understood!\\n\\n        string ans = \"\";\\n        unordered_map<int,int> mp;\\n        for(int i=0; i<n; i++) mp[s[i]]++; //storing the frequency of each character type of s\\n\\n        priority_queue< pair<int,char> > pq; //max heap with pair => {freq, character}\\n        for(auto it: mp){\\n            pq.push({it.second, it.first});\\n        }\\n\\n        while(pq.size()>1){  //do until size of priority queue is larger than 1\\n\\n            char c = pq.top().second;\\n            int cnt = pq.top().first;\\n            pq.pop();\\n\\n            ans = ans + c; //concatenate to ans string the char with 1st largest occurence\\n\\n            char ch = pq.top().second;\\n            int count = pq.top().first;\\n            pq.pop();\\n\\n            ans = ans + ch;  //concatenate to ans string the char with 2nd largest occurence\\n\\n            // if that char still has occurences left,\\n            // we push it back into pq with the ONE size reduced (new size = old size - 1)\\n            if(cnt!=1) pq.push({--cnt,c});  \\n            if(count!=1) pq.push({--count,ch});\\n        }\\n        \\n        if(pq.size()>1 || pq.top().first>1){ //in this case we cannot have desired ans string\\n            return \"\"; //so return empty string\\n        }\\n\\n        else if(pq.size()==1){\\n            ans = ans + pq.top().second; //add the last remaining character to ans and return the final ans!\\n            pq.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948826,
                "title": "python-solution-without-dictionary-and-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPLEASE UPVOTE GUYS\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        x=[]\\n        res=s[0]\\n        for i in range(1,len(s)):\\n            if x and x[-1]!=res[-1]:\\n                #Add to result which are non similar adjacent elements\\n                res=res+x.pop()\\n            if res[-1]!=s[i]:\\n                res=res+s[i]\\n            else:\\n                #Append the non similar adjacent elements to the x\\n                x.append(s[i])\\n        if len(x)>=1:\\n            if x[-1]!=res[0]:\\n                res=x.pop()+res\\n            if x and x[-1]!=res[-1]:\\n                res=res+x.pop()\\n            i=0\\n            while i<len(res)-1:\\n                #Simply add the elements to the result which are present in the x\\n                if x and x[-1]!=res[i] and x[-1]!=res[i+1]:\\n                    res=res[:i+1]+x.pop()+res[i+1:]\\n                i=i+1\\n        if len(res)!=len(s):\\n            return \"\"\\n        #Return the result\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        x=[]\\n        res=s[0]\\n        for i in range(1,len(s)):\\n            if x and x[-1]!=res[-1]:\\n                #Add to result which are non similar adjacent elements\\n                res=res+x.pop()\\n            if res[-1]!=s[i]:\\n                res=res+s[i]\\n            else:\\n                #Append the non similar adjacent elements to the x\\n                x.append(s[i])\\n        if len(x)>=1:\\n            if x[-1]!=res[0]:\\n                res=x.pop()+res\\n            if x and x[-1]!=res[-1]:\\n                res=res+x.pop()\\n            i=0\\n            while i<len(res)-1:\\n                #Simply add the elements to the result which are present in the x\\n                if x and x[-1]!=res[i] and x[-1]!=res[i+1]:\\n                    res=res[:i+1]+x.pop()+res[i+1:]\\n                i=i+1\\n        if len(res)!=len(s):\\n            return \"\"\\n        #Return the result\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948770,
                "title": "simple-beginner-friendly-c-solution-with-intuition-and-explanation",
                "content": "# Intuition\\nWe start by identifying the character with the maximum frequency and store its index. If this maximum frequency is greater than half the length of the input string, a valid reorganization isn\\'t possible, and an empty string is returned. Otherwise, we construct the reorganized string by alternating between inserting the character with the maximum frequency (ensuring no adjacent duplicates) and distributing the remaining characters. By following this alternating insertion pattern, we create a reorganized string that meets the specified criteria of non-adjacent identical characters.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSTEPS:\\n- We iterate through the input string s and populate the count vector based on the frequency of each character.\\n\\n- We then find the character with the maximum count (frequency) and stores its index in the variable letter.\\n\\n- If the maximum count is greater than half the length of the input string (meaning it\\'s not possible to reorganize the string without adjacent identical characters), we return an empty string.\\n\\n- Otherwise, we initialize a string ans with the same content as the input string s.\\n\\n- We then start reorganizing the characters in the string ans. First we fill the characters with the character having the maximum count, ensuring that no two adjacent characters are the same. We do this by inserting the character at every second index, starting from index 0.\\n\\n- After using up the characters with the maximum count, we proceed to fill the remaining characters with the remaining characters based on their counts, again ensuring that no two adjacent characters are the same. We do this by continuing to insert characters at every second index.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k) where k is the total unique characters in the string\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUPVOTE. Glad to help.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        vector<int> count(26,0);\\n        for(char c:s)count[c-\\'a\\']++;\\n        int maxCount=0,letter=0;\\n        for(int i=0;i<count.size();i++){\\n            if(count[i]>maxCount){\\n                maxCount=count[i];\\n                letter=i;\\n            }\\n        }\\n        if(maxCount>(s.length()+1)/2)return \"\";\\n        string ans=s;\\n        int index=0;\\n        while(count[letter]!=0){\\n            ans[index]=char(letter+\\'a\\');\\n            index+=2;\\n            count[letter]--;\\n        }\\n        for(int i=0;i<count.size();i++){\\n            while(count[i]>0){\\n                if(index>=s.size())index=1;\\n                ans[index]=char(i+\\'a\\');\\n                index+=2;\\n                count[i]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        vector<int> count(26,0);\\n        for(char c:s)count[c-\\'a\\']++;\\n        int maxCount=0,letter=0;\\n        for(int i=0;i<count.size();i++){\\n            if(count[i]>maxCount){\\n                maxCount=count[i];\\n                letter=i;\\n            }\\n        }\\n        if(maxCount>(s.length()+1)/2)return \"\";\\n        string ans=s;\\n        int index=0;\\n        while(count[letter]!=0){\\n            ans[index]=char(letter+\\'a\\');\\n            index+=2;\\n            count[letter]--;\\n        }\\n        for(int i=0;i<count.size();i++){\\n            while(count[i]>0){\\n                if(index>=s.size())index=1;\\n                ans[index]=char(i+\\'a\\');\\n                index+=2;\\n                count[i]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948557,
                "title": "beats-100-two-pointer-solution-o-n-approach-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we have to check if adjacent characters are same or not, we can use two pointers to solve this problem. Using two pointers, we can check if adjacent characters are same. One pointer will check if **adjacent characters** are **same** and the other will **fetch new characters** incase adjacent characters are same.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nIntialise two pointers `i = 1, j = 1` for comparsion from the first index of the string.\\n\\n**i pointer** will be used for checking if adjacent characters are equal.\\n**j pointer** will be used for fetching new characters if adjacent characters are equal.\\n\\nThere can be two cases. \\n\\n1. **The adjacent characters are not equal**, i.e `s[i] != s[i - 1]`. In this case, we can simply move both of our pointers forward, i.e `i++, j++`.\\n2. **The adjacent characters are equal**, i.e `s[i] == s[i - 1]`. In this case, we utilize our `j pointer` to search for an index such that `s[j] != s[i]`. Once we find such an index, we swap the characters i.e, `swap(s[i], s[j])`. Now increase i pointer by 2, i.e `i += 2.`\\n\\n*Do a dry run on the given testcases using this logic. ^_^*\\n\\n## Edge Cases \\nIn step 2, there is a possibility that we don\\'t find an *index to swap with using our j pointer*. However, it does not necessarily mean that a correct string does not exist.\\n\\nConsider this testcase:\\n\\n![image.png](https://assets.leetcode.com/users/images/aca096e2-adaa-45c4-8e94-a414c10a64d9_1692769219.832241.png)\\n\\n#### 1st iteration \\n    i = 1, j = 1. s[i] != s[i - 1]. Therefore i and j increase by 1.\\n\\n#### 2nd iteration\\n    i = 2, j = 2. s[i] == s[i - 1]. j now increases to 3. swap(s[i], s[j]). i += 2 => i = 4.\\n\\n![image.png](https://assets.leetcode.com/users/images/07a5567e-f513-4e69-bce8-ba2a14e2729b_1692769563.5914683.png)\\n\\n*current state*\\n\\n#### 3rd iteration\\n    i = 4, j = 3. s[i] == s[i - 1]. j now exceeds the size of string s.\\n\\nIf we now conclude that there a correct string does not exist, then our conclusion would be wrong. Therefore, we need to traverse the string once again from the **opposite direction** using the same logic as discussed above. Introducing this correction would solve the above edge case.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int n = s.length(), i = 1, j = 1;\\n        if(n == 1) //We have to deal with this edge case separately\\n        {\\n            return s;\\n        }\\n        //Traversing the string from the front.\\n        while(i < n && j < n)\\n        {\\n            if(s[i] == s[i - 1])// if adjacent characters are equal\\n            {\\n                while(j < n && s[i] == s[j])\\n                {\\n                    j++;//Increase j until we come across a character that is different from the character at index i\\n                }\\n                if(j >= n)\\n                {\\n                    break;\\n                }\\n                swap(s[i], s[j]);\\n                i += 2;\\n            }\\n            else\\n            {\\n                i++, j++;\\n            }\\n        }\\n        i = n - 2, j = n - 2;\\n        //Traversing from the end to deal with edge cases\\n        //Notice that the exact same logic has been used in both traversals.\\n        while(i >= 0 && j >= 0)\\n        {\\n            if(s[i] == s[i + 1])\\n            {\\n                while(j >= 0 && s[i] == s[j])\\n                {\\n                    j--;\\n                }\\n                if(j < 0)\\n                {\\n                    return \"\";// We are now certain that a correct string does not exist.\\n                }\\n                swap(s[i], s[j]);\\n                i -= 2;\\n            }\\n            else\\n            {\\n                i--, j--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/c16b9875-5816-4050-abf6-c90105e30e0c_1692770404.037495.png)\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int n = s.length(), i = 1, j = 1;\\n        if(n == 1) //We have to deal with this edge case separately\\n        {\\n            return s;\\n        }\\n        //Traversing the string from the front.\\n        while(i < n && j < n)\\n        {\\n            if(s[i] == s[i - 1])// if adjacent characters are equal\\n            {\\n                while(j < n && s[i] == s[j])\\n                {\\n                    j++;//Increase j until we come across a character that is different from the character at index i\\n                }\\n                if(j >= n)\\n                {\\n                    break;\\n                }\\n                swap(s[i], s[j]);\\n                i += 2;\\n            }\\n            else\\n            {\\n                i++, j++;\\n            }\\n        }\\n        i = n - 2, j = n - 2;\\n        //Traversing from the end to deal with edge cases\\n        //Notice that the exact same logic has been used in both traversals.\\n        while(i >= 0 && j >= 0)\\n        {\\n            if(s[i] == s[i + 1])\\n            {\\n                while(j >= 0 && s[i] == s[j])\\n                {\\n                    j--;\\n                }\\n                if(j < 0)\\n                {\\n                    return \"\";// We are now certain that a correct string does not exist.\\n                }\\n                swap(s[i], s[j]);\\n                i -= 2;\\n            }\\n            else\\n            {\\n                i--, j--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948389,
                "title": "using-max-heap-100-faster-cpp-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef pair<int, char> P;\\n    string reorganizeString(string s) {\\n        int n = s.length();\\n        vector<int> count(26, 0);\\n        for(char &ch : s) {\\n            count[ch-\\'a\\']++;\\n            if(count[ch-\\'a\\'] > (n+1)/2)\\n                return \"\";\\n        } \\n        priority_queue<P, vector<P>> pq;\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch++) {\\n            if(count[ch-\\'a\\'] > 0) {\\n                pq.push({count[ch-\\'a\\'], ch});\\n            }\\n         }\\n        string result = \"\";\\n        while(pq.size() >= 2) {\\n            auto P1 = pq.top(); \\n            pq.pop();\\n            auto P2 = pq.top();\\n            pq.pop();\\n            result.push_back(P1.second);\\n            result.push_back(P2.second); \\n            P1.first--;\\n            P2.first--;\\n            if(P1.first > 0)\\n                pq.push(P1);\\n            if(P2.first > 0)\\n                pq.push(P2);\\n        }\\n        \\n        if(!pq.empty())\\n            result.push_back(pq.top().second);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int, char> P;\\n    string reorganizeString(string s) {\\n        int n = s.length();\\n        vector<int> count(26, 0);\\n        for(char &ch : s) {\\n            count[ch-\\'a\\']++;\\n            if(count[ch-\\'a\\'] > (n+1)/2)\\n                return \"\";\\n        } \\n        priority_queue<P, vector<P>> pq;\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch++) {\\n            if(count[ch-\\'a\\'] > 0) {\\n                pq.push({count[ch-\\'a\\'], ch});\\n            }\\n         }\\n        string result = \"\";\\n        while(pq.size() >= 2) {\\n            auto P1 = pq.top(); \\n            pq.pop();\\n            auto P2 = pq.top();\\n            pq.pop();\\n            result.push_back(P1.second);\\n            result.push_back(P2.second); \\n            P1.first--;\\n            P2.first--;\\n            if(P1.first > 0)\\n                pq.push(P1);\\n            if(P2.first > 0)\\n                pq.push(P2);\\n        }\\n        \\n        if(!pq.empty())\\n            result.push_back(pq.top().second);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948329,
                "title": "2-easy-solution-100-accuracy-priority-queue-without-priority-queue-explanation",
                "content": "\\n# Code\\n# Solution 1(Without Priority Queue)\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int arr[26] = {0};\\n        int maxi = 0, i = 0;\\n        int n = s.size();\\n\\n        for(auto it : s){\\n            if(++arr[it - \\'a\\'] > arr[maxi])\\n                maxi = it - \\'a\\';  // finding the index of most occuring character\\n        }\\n\\n        if(2*arr[maxi] - n > 1)\\n            return \"\";\\n        \\n        while(arr[maxi]){  // putting the maximum occuring character at alternate position\\n            s[i] = \\'a\\' + maxi;\\n            i += 2;\\n            arr[maxi]--;\\n        }\\n\\n        for(int j = 0; j < 26; j++){  // putting all the remaining character at alternate position\\n            while(arr[j]){\\n                if(i >= n)\\n                    i = 1;\\n                s[i] = \\'a\\' + j;\\n                arr[j]--;\\n                i += 2;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\\n\\n# Solution 2\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        unordered_map<char, int> mp;\\n        int n = s.size();\\n        for(auto it : s)\\n            mp[it]++;\\n        \\n        int maxi = 0;\\n        for(auto it : mp)\\n            maxi = max(maxi, it.second);\\n        \\n        if(maxi - (n - maxi) > 1)\\n            return \"\";\\n\\n        priority_queue<pair<int, char>> pq;\\n        for(auto it : mp)\\n            pq.push({it.second, it.first});\\n        \\n        string ans = \"\";\\n        while(pq.size() > 1){\\n            auto a = pq.top();\\n            pq.pop();\\n            auto b = pq.top();\\n            pq.pop();\\n            \\n            ans += a.second;\\n            ans += b.second; \\n            a.first--;\\n            b.first--;\\n            if(a.first)\\n                pq.push(a);\\n            if(b.first)\\n                pq.push(b);\\n        }\\n\\n        if(!pq.empty() && pq.top().first > 1)\\n            return \"\";\\n        else if(!pq.empty() && pq.top().first == 1)\\n            ans += pq.top().second;\\n        return ans;\\n            \\n    }\\n};\\n```\\n\\n![upvote_leetcode.jpeg](https://assets.leetcode.com/users/images/60c00d71-8e4b-4ae3-af4c-3836808463f7_1692766472.7045834.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int arr[26] = {0};\\n        int maxi = 0, i = 0;\\n        int n = s.size();\\n\\n        for(auto it : s){\\n            if(++arr[it - \\'a\\'] > arr[maxi])\\n                maxi = it - \\'a\\';  // finding the index of most occuring character\\n        }\\n\\n        if(2*arr[maxi] - n > 1)\\n            return \"\";\\n        \\n        while(arr[maxi]){  // putting the maximum occuring character at alternate position\\n            s[i] = \\'a\\' + maxi;\\n            i += 2;\\n            arr[maxi]--;\\n        }\\n\\n        for(int j = 0; j < 26; j++){  // putting all the remaining character at alternate position\\n            while(arr[j]){\\n                if(i >= n)\\n                    i = 1;\\n                s[i] = \\'a\\' + j;\\n                arr[j]--;\\n                i += 2;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        unordered_map<char, int> mp;\\n        int n = s.size();\\n        for(auto it : s)\\n            mp[it]++;\\n        \\n        int maxi = 0;\\n        for(auto it : mp)\\n            maxi = max(maxi, it.second);\\n        \\n        if(maxi - (n - maxi) > 1)\\n            return \"\";\\n\\n        priority_queue<pair<int, char>> pq;\\n        for(auto it : mp)\\n            pq.push({it.second, it.first});\\n        \\n        string ans = \"\";\\n        while(pq.size() > 1){\\n            auto a = pq.top();\\n            pq.pop();\\n            auto b = pq.top();\\n            pq.pop();\\n            \\n            ans += a.second;\\n            ans += b.second; \\n            a.first--;\\n            b.first--;\\n            if(a.first)\\n                pq.push(a);\\n            if(b.first)\\n                pq.push(b);\\n        }\\n\\n        if(!pq.empty() && pq.top().first > 1)\\n            return \"\";\\n        else if(!pq.empty() && pq.top().first == 1)\\n            ans += pq.top().second;\\n        return ans;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948269,
                "title": "runtime-0ms-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Storing frequencies\\n- check if max freq is greater than half of length+1 , if it is we cannot form alternating different characters\\n- adding freqs and respective chars in maxheap such that we can get the alternating chars easily. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int l = s.length();\\n        unordered_map<char,int> um;\\n        for(auto it : s)\\n            um[it]+=1;\\n        int maxi = 0;\\n\\n        priority_queue<pair<int,char>> pq;\\n        for(auto it : um){\\n            maxi = max(maxi,it.second);\\n            pq.push({it.second,it.first});\\n        }\\n\\n        if(maxi > (l+1)/2)\\n            return \"\";\\n\\n        string res;\\n\\n        while(pq.size()){\\n            auto ptr = pq.top();\\n            pq.pop();\\n            res+=ptr.second;\\n\\n            if(pq.size()){\\n                auto ptr2 = pq.top();\\n                pq.pop();\\n                res+=ptr2.second;\\n\\n\\n                if(ptr2.first>1)\\n                    pq.push({ptr2.first-1,ptr2.second});\\n            }\\n\\n            if(ptr.first>1)\\n                pq.push({ptr.first-1,ptr.second});\\n\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int l = s.length();\\n        unordered_map<char,int> um;\\n        for(auto it : s)\\n            um[it]+=1;\\n        int maxi = 0;\\n\\n        priority_queue<pair<int,char>> pq;\\n        for(auto it : um){\\n            maxi = max(maxi,it.second);\\n            pq.push({it.second,it.first});\\n        }\\n\\n        if(maxi > (l+1)/2)\\n            return \"\";\\n\\n        string res;\\n\\n        while(pq.size()){\\n            auto ptr = pq.top();\\n            pq.pop();\\n            res+=ptr.second;\\n\\n            if(pq.size()){\\n                auto ptr2 = pq.top();\\n                pq.pop();\\n                res+=ptr2.second;\\n\\n\\n                if(ptr2.first>1)\\n                    pq.push({ptr2.first-1,ptr2.second});\\n            }\\n\\n            if(ptr.first>1)\\n                pq.push({ptr.first-1,ptr.second});\\n\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948218,
                "title": "c-greedy-faster-than-100-0ms",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        // Intution\\n        // We will follow greedy approach. We will maitain a frequency table and then align the elements correspondingly.\\n\\n        unordered_map<char, int> mp;\\n        \\n        for(auto &ch : s) mp[ch] += 1;\\n\\n        priority_queue<pair<int, char>, vector<pair<int, char>>> pq;\\n\\n        for(auto itr = mp.begin() ; itr != mp.end() ; itr++){\\n            pq.push({itr->second, itr->first});\\n        }\\n\\n        int size = s.size();\\n        int ind = 0;\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int freq        = top.first;\\n            char character  = top.second;\\n            if( 2 * freq - 1 > size ) return \"\";\\n            while(freq --> 0){\\n                if(ind >= size) ind = 1;\\n                s[ind] = character;\\n                ind += 2;\\n            }\\n        }\\n\\n        return s;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        // Intution\\n        // We will follow greedy approach. We will maitain a frequency table and then align the elements correspondingly.\\n\\n        unordered_map<char, int> mp;\\n        \\n        for(auto &ch : s) mp[ch] += 1;\\n\\n        priority_queue<pair<int, char>, vector<pair<int, char>>> pq;\\n\\n        for(auto itr = mp.begin() ; itr != mp.end() ; itr++){\\n            pq.push({itr->second, itr->first});\\n        }\\n\\n        int size = s.size();\\n        int ind = 0;\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int freq        = top.first;\\n            char character  = top.second;\\n            if( 2 * freq - 1 > size ) return \"\";\\n            while(freq --> 0){\\n                if(ind >= size) ind = 1;\\n                s[ind] = character;\\n                ind += 2;\\n            }\\n        }\\n\\n        return s;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948210,
                "title": "c-easy-solution-counting-the-frequency",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int n = (int)s.size();\\n        vector<int> Cnt(26);\\n        int f = 0;\\n        for (auto x : s) {\\n            Cnt[x - \\'a\\'] += 1;\\n            if (Cnt[x - \\'a\\'] > Cnt[f]) {\\n                f = (x - \\'a\\');\\n            }\\n        }\\n        if (Cnt[f] > (n + 1) / 2) {\\n            return \"\";\\n        }\\n        int i = 0;\\n        while (Cnt[f]) {\\n            s[i] = (f + \\'a\\');\\n            i += 2;\\n            Cnt[f] -= 1;\\n        }\\n\\n        for (int k = 0; k < 26; k++) {\\n            while (Cnt[k]) {\\n                i = (i >= n ? 1 : i);\\n                s[i] = (k + \\'a\\');\\n                Cnt[k] -= 1;\\n                i += 2;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        int n = (int)s.size();\\n        vector<int> Cnt(26);\\n        int f = 0;\\n        for (auto x : s) {\\n            Cnt[x - \\'a\\'] += 1;\\n            if (Cnt[x - \\'a\\'] > Cnt[f]) {\\n                f = (x - \\'a\\');\\n            }\\n        }\\n        if (Cnt[f] > (n + 1) / 2) {\\n            return \"\";\\n        }\\n        int i = 0;\\n        while (Cnt[f]) {\\n            s[i] = (f + \\'a\\');\\n            i += 2;\\n            Cnt[f] -= 1;\\n        }\\n\\n        for (int k = 0; k < 26; k++) {\\n            while (Cnt[k]) {\\n                i = (i >= n ? 1 : i);\\n                s[i] = (k + \\'a\\');\\n                Cnt[k] -= 1;\\n                i += 2;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948182,
                "title": "video-solution-explanation-with-drawings-in-depth-c-java",
                "content": "# Intuition, approach, and complexity dicussed in detail in video solution\\nhttps://youtu.be/RpXbt-zerM4\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        vector<int> chrs(26, 0);\\n\\n        for(auto chr : s){\\n            chrs[chr- \\'a\\']++;\\n    \\n        }\\n        priority_queue<pair<int, char>> maxFreq;\\n        for(int indx = 0; indx < 26; indx++){\\n            if(chrs[indx] != 0){\\n                \\n               maxFreq.push(make_pair(chrs[indx], (char)(indx + \\'a\\')));\\n            }\\n        }\\n        \\n        string res  = \"\";\\n        while(maxFreq.size() >= 2){\\n            auto freqPr1 = maxFreq.top();\\n            // cout<<freqPr1.first<<endl;\\n            maxFreq.pop();\\n            auto freqPr2 = maxFreq.top();\\n            // cout<<freqPr2.first<<endl;\\n            maxFreq.pop();\\n            int freq1 = freqPr1.first, \\n            freq2 = freqPr2.first;\\n            res += (freqPr1.second);\\n            res += (freqPr2.second);\\n            if(freq1-1 > 0){\\n               maxFreq.push(make_pair(freq1-1, freqPr1.second));\\n            }\\n            if(freq2 - 1 > 0){\\n                maxFreq.push(make_pair(freq2 - 1, freqPr2.second));\\n            }\\n\\n        }\\n        if(maxFreq.size() > 0){\\n            auto freqPr = maxFreq.top();\\n            if(freqPr.first > 1){\\n                return \"\";\\n            }\\n            res += (freqPr.second);\\n        }\\n        return res;\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public String reorganizeString(String s) {\\n        int chrs[] = new int[26];\\n        for(var chr : s.toCharArray()){\\n            chrs[chr- \\'a\\']++;\\n        }\\n        PriorityQueue<Pair<Integer, Character>> maxFreq = new PriorityQueue<>((a, b)->(b.getKey() - a.getKey()));\\n        for(int indx = 0; indx < 26; indx++){\\n            if(chrs[indx] != 0){\\n               maxFreq.offer(new Pair<Integer, Character>(chrs[indx], (char)(indx + \\'a\\')));\\n            }\\n        }\\n        StringBuilder res  = new StringBuilder();\\n        while(maxFreq.size() >= 2){\\n            var freqPr1 = maxFreq.poll();\\n            var freqPr2 = maxFreq.poll();\\n            int freq1 = freqPr1.getKey(), \\n            freq2 = freqPr2.getKey();\\n            res.append(freqPr1.getValue());\\n            res.append(freqPr2.getValue());\\n            if(freq1-1 > 0){\\n               maxFreq.offer(new Pair<Integer, Character>(freq1-1, freqPr1.getValue()));\\n            }\\n            if(freq2 - 1 > 0){\\n                maxFreq.offer(new Pair<Integer, Character>(freq2 - 1, freqPr2.getValue()));\\n            }\\n\\n        }\\n        if(maxFreq.size() > 0){\\n            var freqPr = maxFreq.poll();\\n            if(freqPr.getKey() > 1){\\n                return \"\";\\n            }\\n            res.append(freqPr.getValue());\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        vector<int> chrs(26, 0);\\n\\n        for(auto chr : s){\\n            chrs[chr- \\'a\\']++;\\n    \\n        }\\n        priority_queue<pair<int, char>> maxFreq;\\n        for(int indx = 0; indx < 26; indx++){\\n            if(chrs[indx] != 0){\\n                \\n               maxFreq.push(make_pair(chrs[indx], (char)(indx + \\'a\\')));\\n            }\\n        }\\n        \\n        string res  = \"\";\\n        while(maxFreq.size() >= 2){\\n            auto freqPr1 = maxFreq.top();\\n            // cout<<freqPr1.first<<endl;\\n            maxFreq.pop();\\n            auto freqPr2 = maxFreq.top();\\n            // cout<<freqPr2.first<<endl;\\n            maxFreq.pop();\\n            int freq1 = freqPr1.first, \\n            freq2 = freqPr2.first;\\n            res += (freqPr1.second);\\n            res += (freqPr2.second);\\n            if(freq1-1 > 0){\\n               maxFreq.push(make_pair(freq1-1, freqPr1.second));\\n            }\\n            if(freq2 - 1 > 0){\\n                maxFreq.push(make_pair(freq2 - 1, freqPr2.second));\\n            }\\n\\n        }\\n        if(maxFreq.size() > 0){\\n            auto freqPr = maxFreq.top();\\n            if(freqPr.first > 1){\\n                return \"\";\\n            }\\n            res += (freqPr.second);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String reorganizeString(String s) {\\n        int chrs[] = new int[26];\\n        for(var chr : s.toCharArray()){\\n            chrs[chr- \\'a\\']++;\\n        }\\n        PriorityQueue<Pair<Integer, Character>> maxFreq = new PriorityQueue<>((a, b)->(b.getKey() - a.getKey()));\\n        for(int indx = 0; indx < 26; indx++){\\n            if(chrs[indx] != 0){\\n               maxFreq.offer(new Pair<Integer, Character>(chrs[indx], (char)(indx + \\'a\\')));\\n            }\\n        }\\n        StringBuilder res  = new StringBuilder();\\n        while(maxFreq.size() >= 2){\\n            var freqPr1 = maxFreq.poll();\\n            var freqPr2 = maxFreq.poll();\\n            int freq1 = freqPr1.getKey(), \\n            freq2 = freqPr2.getKey();\\n            res.append(freqPr1.getValue());\\n            res.append(freqPr2.getValue());\\n            if(freq1-1 > 0){\\n               maxFreq.offer(new Pair<Integer, Character>(freq1-1, freqPr1.getValue()));\\n            }\\n            if(freq2 - 1 > 0){\\n                maxFreq.offer(new Pair<Integer, Character>(freq2 - 1, freqPr2.getValue()));\\n            }\\n\\n        }\\n        if(maxFreq.size() > 0){\\n            var freqPr = maxFreq.poll();\\n            if(freqPr.getKey() > 1){\\n                return \"\";\\n            }\\n            res.append(freqPr.getValue());\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3947897,
                "title": "beginner-freindly-without-sort",
                "content": "# Intuition\\nJust think about hint ,how can your place alternate maximum cnt\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1->Just place maxiCnt char first at alternte places \\n2-> Place other ele alternatively now .\\nUpvote if you like soltuion\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- o(26)~o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        vector<int> freq(26,0);\\n        int n = s.length();\\n        int maxiCnt=0,maxiIdx=0;\\n        char ele;\\n        for(int i=0;i<n;i++){\\n            freq[s[i] - \\'a\\']++;\\n            if(freq[s[i]-\\'a\\'] > maxiCnt){\\n                maxiCnt= freq[s[i]-\\'a\\'];\\n                maxiIdx = s[i]-\\'a\\';\\n                ele= s[i];\\n            }\\n        }\\n        \\n        int idx=0;\\n        if(freq[maxiIdx]*2 -1 > s.length()) return \"\";\\n        while(freq[maxiIdx]>0){\\n           \\n            s[idx] =maxiIdx + \\'a\\';\\n            idx+=2;\\n            freq[maxiIdx]--;\\n        }\\n        for(int i=0;i<26;i++){\\n            while(freq[i]> 0){\\n                if(idx >= s.length()){\\n                    idx =1;\\n                }\\n                s[idx] = i + \\'a\\';\\n                idx+=2;\\n                freq[i]--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        vector<int> freq(26,0);\\n        int n = s.length();\\n        int maxiCnt=0,maxiIdx=0;\\n        char ele;\\n        for(int i=0;i<n;i++){\\n            freq[s[i] - \\'a\\']++;\\n            if(freq[s[i]-\\'a\\'] > maxiCnt){\\n                maxiCnt= freq[s[i]-\\'a\\'];\\n                maxiIdx = s[i]-\\'a\\';\\n                ele= s[i];\\n            }\\n        }\\n        \\n        int idx=0;\\n        if(freq[maxiIdx]*2 -1 > s.length()) return \"\";\\n        while(freq[maxiIdx]>0){\\n           \\n            s[idx] =maxiIdx + \\'a\\';\\n            idx+=2;\\n            freq[maxiIdx]--;\\n        }\\n        for(int i=0;i<26;i++){\\n            while(freq[i]> 0){\\n                if(idx >= s.length()){\\n                    idx =1;\\n                }\\n                s[idx] = i + \\'a\\';\\n                idx+=2;\\n                freq[i]--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947864,
                "title": "c-hashmap-maxheap-solution-with-explanation-and-diagrams",
                "content": "# Intuition: Greedy Algorithim\\n\\n# Approach : Frequencys and heap.\\n```\\nlets walk through the example: \\n\\ns = \"vvvlo\"\\n```\\n**1. count the freqnecys of the letters in hashmap**\\n```\\n    v : 3\\n    l : 1\\n    o : 1\\n```\\n**2. insert the frequencys of indivdual letters into a max heap as [frequency, letter] pairs**\\n```\\nmax freq ->             [3 , v]\\n                        /     \\\\\\n                    [1, l]   [1, o]\\n```\\n\\n**3. Greedily add the letter with the highest frequency to the output.**\\n- This steps requires checking if the highest frequency letter is the same as the back of the string\\n- If it is take the second highest frequency letter.\\n- Reduce the frequency of the letter added to the output. If it is still > 0, add it back to the heap.\\n```\\niteration 1:        s = \"\"             \\n\\n    Heap Before             [3 , v]\\n                            /     \\\\\\n                        [1, l]   [1, o]\\n\\n\\n    Heap After             [2 , v]\\n                            /     \\\\\\n                        [1, l]   [1, o]\\n\\n                    s = \"v\"\\n```\\nIn iteration 1, we could add the max frequency character v to the output string since it would not cause an adjacent match\\n```\\niteration 2:        s = \"v\"             \\n\\n    Heap Before             [2 , v]\\n                            /     \\\\\\n                        [1, l]   [1, o]\\n\\n\\n    Heap After             [2 , v]\\n                                 \\\\\\n                                [1, o]\\n\\n                    s = \"vl\"\\n```\\nIn iteration 2, we could  NOT add the max frequency character v to the output string since it would cause an adjacent match.\\n\\nTherefore we took the second largest character and added it the output, l.\\n\\nAfter decrementing the count of l from 1 to 0. We did not insert back into the heap since there are not more l\\'s.\\n```\\niteration 3:        s = \"vl\"             \\n\\n    Heap Before             [2 , v]\\n                                  \\\\\\n                                [1, o]\\n\\n\\n    Heap After             [1 , v]\\n                                 \\\\\\n                                [1, o]\\n\\n                    s = \"vlv\"\\n```\\nIn iteration 3, we could add the max frequency character v to the output string since it would not cause an adjacent match\\n```\\niteration 4:        s = \"vlv\"             \\n\\n    Heap Before             [1 , v]\\n                                  \\\\\\n                                [1, o]\\n\\n\\n    Heap After             [1 , v]\\n\\n\\n\\n                    s = \"vlvo\"\\n```\\nIn iteration 4, we could  NOT add the max frequency character v to the output string since it would cause an adjacent match.\\n\\nTherefore we took the second largest character and added it the output, o.\\n\\nAfter decrementing the count of o from 1 to 0. We did not insert back into the heap since there are not more o\\'s.\\n```\\niteration 5:        s = \"vlvo\"             \\n\\n    Heap Before             [1 , v]\\n\\n\\n\\n    Heap After             \\n\\n\\n\\n                    s = \"vlvov\"\\n```\\nIn iteration 5, we could add the max frequency character v to the output string since it would not cause an adjacent match\\n\\nHowever the count of it became 0 (there are no more v\\'s left to add). Thus our heap is empty and we finish building our string.\\n\\n**4. Return if the output was a valid reorganized string**\\nif our string is the same size as input string after the insertion process, we return the string since it worked. If not, we could not build an appropriate string and return \"\"\\n# Complexity\\n**Time complexity: O(nlogk)**\\n- we loop to add characters to output string n times (where n is legnth of s)\\n- every loop we apply heap operations which is logk (where k is size of the heap)\\n\\n**Space complexity: O(1)**\\n- hashmap size will never exceed 26 -> O(26)\\n- max heap size will never exceed 26 -> O(26)\\n- therefore total is O(26 + 26) = O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        unordered_map<char,int> freq (26); // hashmap to count frequencys\\n\\n        for(char c : s) freq[c]++;\\n\\n        priority_queue<pair<int,char>> pq;  // max heap\\n\\n        for(auto& [c, freq] : freq) pq.push({freq, c}); // inset [frequency ,character] pairs\\n        \\n\\n        string out = \"\";\\n        \\n        // loop while there is still more characters left to add\\n        while(!pq.empty()) {\\n            // if the back character and the highest freqncy characte rare not the same\\n            if(out == \"\" || pq.top().second != out.back()) {     \\n                pair<int,char> largest = pq.top();\\n                pq.pop();\\n\\n                out += largest.second;\\n                largest.first--;\\n\\n                if(largest.first) pq.push(largest);\\n\\n            } else {\\n                // store the largest so can access the second largest\\n                pair<int,char> largest = pq.top();\\n                pq.pop();\\n\\n                if(pq.empty()) return \"\"; // if there is not a second largest character\\n\\n                // add second largest character to string\\n                pair<int,char> second_largest = pq.top();\\n                pq.pop();\\n\\n                out += second_largest.second;\\n                second_largest.first--;\\n\\n                if(second_largest.first > 0) pq.push(second_largest);\\n                \\n                // can always add largest back since no update to its frequency\\n                pq.push(largest); \\n            }\\n        }\\n        return out.size() == s.size() ? out : \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nlets walk through the example: \\n\\ns = \"vvvlo\"\\n```\n```\\n    v : 3\\n    l : 1\\n    o : 1\\n```\n```\\nmax freq ->             [3 , v]\\n                        /     \\\\\\n                    [1, l]   [1, o]\\n```\n```\\niteration 1:        s = \"\"             \\n\\n    Heap Before             [3 , v]\\n                            /     \\\\\\n                        [1, l]   [1, o]\\n\\n\\n    Heap After             [2 , v]\\n                            /     \\\\\\n                        [1, l]   [1, o]\\n\\n                    s = \"v\"\\n```\n```\\niteration 2:        s = \"v\"             \\n\\n    Heap Before             [2 , v]\\n                            /     \\\\\\n                        [1, l]   [1, o]\\n\\n\\n    Heap After             [2 , v]\\n                                 \\\\\\n                                [1, o]\\n\\n                    s = \"vl\"\\n```\n```\\niteration 3:        s = \"vl\"             \\n\\n    Heap Before             [2 , v]\\n                                  \\\\\\n                                [1, o]\\n\\n\\n    Heap After             [1 , v]\\n                                 \\\\\\n                                [1, o]\\n\\n                    s = \"vlv\"\\n```\n```\\niteration 4:        s = \"vlv\"             \\n\\n    Heap Before             [1 , v]\\n                                  \\\\\\n                                [1, o]\\n\\n\\n    Heap After             [1 , v]\\n\\n\\n\\n                    s = \"vlvo\"\\n```\n```\\niteration 5:        s = \"vlvo\"             \\n\\n    Heap Before             [1 , v]\\n\\n\\n\\n    Heap After             \\n\\n\\n\\n                    s = \"vlvov\"\\n```\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        unordered_map<char,int> freq (26); // hashmap to count frequencys\\n\\n        for(char c : s) freq[c]++;\\n\\n        priority_queue<pair<int,char>> pq;  // max heap\\n\\n        for(auto& [c, freq] : freq) pq.push({freq, c}); // inset [frequency ,character] pairs\\n        \\n\\n        string out = \"\";\\n        \\n        // loop while there is still more characters left to add\\n        while(!pq.empty()) {\\n            // if the back character and the highest freqncy characte rare not the same\\n            if(out == \"\" || pq.top().second != out.back()) {     \\n                pair<int,char> largest = pq.top();\\n                pq.pop();\\n\\n                out += largest.second;\\n                largest.first--;\\n\\n                if(largest.first) pq.push(largest);\\n\\n            } else {\\n                // store the largest so can access the second largest\\n                pair<int,char> largest = pq.top();\\n                pq.pop();\\n\\n                if(pq.empty()) return \"\"; // if there is not a second largest character\\n\\n                // add second largest character to string\\n                pair<int,char> second_largest = pq.top();\\n                pq.pop();\\n\\n                out += second_largest.second;\\n                second_largest.first--;\\n\\n                if(second_largest.first > 0) pq.push(second_largest);\\n                \\n                // can always add largest back since no update to its frequency\\n                pq.push(largest); \\n            }\\n        }\\n        return out.size() == s.size() ? out : \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947768,
                "title": "daily-leetcoding-challenge-august-day-23",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reorganize-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Counting and Priority Queue\n\n  \n**Approach 2:** Counting and Odd/Even\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reorganize-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3553346,
                "title": "ez-java-solution-explained-2ms",
                "content": "**Time Complexity : O (N * 26)\\nSpace Complexity : O (26)**\\n\\n```\\nclass Solution {\\n    public String reorganizeString(String s) {\\n        int m[]=new int[26];//Hashmap to store the frequency of each character\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n            m[s.charAt(i)-\\'a\\']++;\\n        \\n        StringBuilder ans=new StringBuilder();\\n        int i=0;\\n        char prev=\\'*\\';//Keep track of previous character\\n        while(i<n){\\n            int maxi=0,ind=0;\\n            //We traverse the entire hashmap to find the character with maximum count and not equal to previous character\\n            for(int j=0;j<26;j++){                \\n                if(m[j]>maxi&&prev!=(j+\\'a\\')&&m[j]>0){\\n                    maxi=m[j];\\n                    ind=j;\\n                }\\n            }\\n            if(maxi==0) return \"\";//If maxi is 0 then no solution can be made as suitable element not found\\n            prev=(char)(ind+\\'a\\');//Updating previous\\n            ans.append(prev);\\n            m[ind]--;  //Decreasing count from map since the character is done\\n            i++;\\n        }        \\n        return ans.toString();\\n    }\\n}\\n/*\\n    \"aaabcc\"\\n    acacab\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reorganizeString(String s) {\\n        int m[]=new int[26];//Hashmap to store the frequency of each character\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n            m[s.charAt(i)-\\'a\\']++;\\n        \\n        StringBuilder ans=new StringBuilder();\\n        int i=0;\\n        char prev=\\'*\\';//Keep track of previous character\\n        while(i<n){\\n            int maxi=0,ind=0;\\n            //We traverse the entire hashmap to find the character with maximum count and not equal to previous character\\n            for(int j=0;j<26;j++){                \\n                if(m[j]>maxi&&prev!=(j+\\'a\\')&&m[j]>0){\\n                    maxi=m[j];\\n                    ind=j;\\n                }\\n            }\\n            if(maxi==0) return \"\";//If maxi is 0 then no solution can be made as suitable element not found\\n            prev=(char)(ind+\\'a\\');//Updating previous\\n            ans.append(prev);\\n            m[ind]--;  //Decreasing count from map since the character is done\\n            i++;\\n        }        \\n        return ans.toString();\\n    }\\n}\\n/*\\n    \"aaabcc\"\\n    acacab\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933451,
                "title": "using-maxheap-codedominar-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        heap = [[-val,char] for char,val in Counter(s).items()]\\n        heapq.heapify(heap)\\n        ans = \"\"\\n        prev = None\\n        while heap or prev:\\n            if not heap and prev:\\n                return \\'\\'\\n            freq,char = heapq.heappop(heap)\\n            ans += char\\n            freq += 1\\n            if prev:\\n                heapq.heappush(heap,prev)\\n                prev = None\\n            if freq != 0:\\n                prev = [freq,char]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        heap = [[-val,char] for char,val in Counter(s).items()]\\n        heapq.heapify(heap)\\n        ans = \"\"\\n        prev = None\\n        while heap or prev:\\n            if not heap and prev:\\n                return \\'\\'\\n            freq,char = heapq.heappop(heap)\\n            ans += char\\n            freq += 1\\n            if prev:\\n                heapq.heappush(heap,prev)\\n                prev = None\\n            if freq != 0:\\n                prev = [freq,char]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832304,
                "title": "cpp-very-easy-to-understand-heap-and-map",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) \\n{\\n\\t//according to the example 1 min heap would not work according to this approach\\n\\t\\n\\tbool flag=true;  //assuming every char to have one freq only\\n\\t//unordered map of <char int>\\n    unordered_map<char,int>mp;\\n    \\n    \\n    //getting the freq of each character in the string\\n\\tfor(int i=0;i<s.length();i++)\\n\\t{\\n\\t   mp[s[i]]++;\\n\\t   \\t\\n\\t   if(mp[s[i]] > 1)\\n\\t   flag=false;\\n    }  \\n\\tif(flag==true)\\n\\t{\\n       return s;\\t\\t\\n    }         \\n    \\n    //declaring the max heap\\n    priority_queue<pair<int,char>>pq;\\n    \\n    //iterating over the map so that we can put the <freq,char>pair\\n    for(auto it = mp.begin() ; it!=mp.end() ; it++)\\n    {\\n   \\t   pq.push(make_pair(it->second,it->first));  //pair of <freq,int>\\n\\t}\\n\\t\\n\\tstring ans = \"\";\\n\\t\\n\\twhile(!pq.empty())\\n\\t{\\n        //if it is the starting character\\n\\t\\tif(ans.length() == 0)\\n\\t\\t{\\n\\t\\t    pair<int,char>p = pq.top();\\n\\t\\t\\tpq.pop();\\n\\t\\t\\t\\n\\t\\t    ans.push_back(p.second);\\n\\t \\t\\tp.first--;\\n\\t\\t\\t\\n\\t\\t\\tif(p.first > 0 and pq.size() ==0)\\n\\t\\t\\t{\\n\\t\\t\\t   return \"\";\\t\\n\\t\\t\\t}\\t\\n\\t\\t\\t\\n\\t\\t\\tpq.push(p);\\n\\t\\t}\\n\\t\\telse if(ans.length() > 0)\\n\\t\\t{\\n\\t\\t\\tchar lastchar = ans[ans.length()-1];\\n\\t\\t\\t\\n\\t\\t\\tpair<int,char>p1 = pq.top();\\n\\t\\t\\tpq.pop();\\n\\t\\t\\t\\n\\t\\t\\tif(p1.second == lastchar)\\n\\t\\t\\t{\\n                 if(pq.size()==0) return \"\";\\n                 \\n                 pair<int,char>p2 = pq.top();\\n                 pq.pop();\\n                 \\n                 ans.push_back(p2.second);\\n                 p2.first--;\\n                 \\n                 if(p2.first > 0)\\n                 {\\n                 \\tpq.push(p2);\\n\\t\\t\\t\\t }\\n\\t\\t\\t\\t pq.push(p1);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tans.push_back(p1.second);\\n\\t\\t\\t\\tp1.first--;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(p1.first > 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tpq.push(p1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\t\\t    \\n\\t}\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reorganizeString(string s) \\n{\\n\\t//according to the example 1 min heap would not work according to this approach\\n\\t\\n\\tbool flag=true;  //assuming every char to have one freq only\\n\\t//unordered map of <char int>\\n    unordered_map<char,int>mp;\\n    \\n    \\n    //getting the freq of each character in the string\\n\\tfor(int i=0;i<s.length();i++)\\n\\t{\\n\\t   mp[s[i]]++;\\n\\t   \\t\\n\\t   if(mp[s[i]] > 1)\\n\\t   flag=false;\\n    }  \\n\\tif(flag==true)\\n\\t{\\n       return s;\\t\\t\\n    }         \\n    \\n    //declaring the max heap\\n    priority_queue<pair<int,char>>pq;\\n    \\n    //iterating over the map so that we can put the <freq,char>pair\\n    for(auto it = mp.begin() ; it!=mp.end() ; it++)\\n    {\\n   \\t   pq.push(make_pair(it->second,it->first));  //pair of <freq,int>\\n\\t}\\n\\t\\n\\tstring ans = \"\";\\n\\t\\n\\twhile(!pq.empty())\\n\\t{\\n        //if it is the starting character\\n\\t\\tif(ans.length() == 0)\\n\\t\\t{\\n\\t\\t    pair<int,char>p = pq.top();\\n\\t\\t\\tpq.pop();\\n\\t\\t\\t\\n\\t\\t    ans.push_back(p.second);\\n\\t \\t\\tp.first--;\\n\\t\\t\\t\\n\\t\\t\\tif(p.first > 0 and pq.size() ==0)\\n\\t\\t\\t{\\n\\t\\t\\t   return \"\";\\t\\n\\t\\t\\t}\\t\\n\\t\\t\\t\\n\\t\\t\\tpq.push(p);\\n\\t\\t}\\n\\t\\telse if(ans.length() > 0)\\n\\t\\t{\\n\\t\\t\\tchar lastchar = ans[ans.length()-1];\\n\\t\\t\\t\\n\\t\\t\\tpair<int,char>p1 = pq.top();\\n\\t\\t\\tpq.pop();\\n\\t\\t\\t\\n\\t\\t\\tif(p1.second == lastchar)\\n\\t\\t\\t{\\n                 if(pq.size()==0) return \"\";\\n                 \\n                 pair<int,char>p2 = pq.top();\\n                 pq.pop();\\n                 \\n                 ans.push_back(p2.second);\\n                 p2.first--;\\n                 \\n                 if(p2.first > 0)\\n                 {\\n                 \\tpq.push(p2);\\n\\t\\t\\t\\t }\\n\\t\\t\\t\\t pq.push(p1);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tans.push_back(p1.second);\\n\\t\\t\\t\\tp1.first--;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(p1.first > 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tpq.push(p1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\t\\t    \\n\\t}\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809007,
                "title": "using-dictionary-for-count-of-each-character",
                "content": "# Intuition\\nGoing to start from the character which has most frequency and put it in even indexes and put the rest charcaters on remaining even indexes and odd indexes.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. First created a freq dictionary and count each character frequency\\n2. Find which character has max count\\n3. If the max count is greatar than string length +1 /2 it is not possible to convert it.\\n4. Put the max character in even indexes. (we need this only if length of string is odd and we should start putting maxchar from index 0 but for even it does not matter)\\n5. Put the rest characters in the rest even indexes and then odd indexes.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![Screenshot 2022-11-13 at 3.08.48 PM.png](https://assets.leetcode.com/users/images/f9590c71-3303-4805-a675-39da68cb9779_1668380976.0596952.png)\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public string ReorganizeString(string s) {\\n        var result = new char[s.Length];\\n        var freq = new Dictionary<char,int>();\\n        foreach(var ch in s){\\n            if(freq.ContainsKey(ch)) freq[ch]++;\\n            else freq.Add(ch,1);\\n        }\\n        var max=freq.Max(p=>p.Value);\\n        if(max>(s.Length+1)/2) return \"\";\\n        var maxChar=freq.First(p=>p.Value==max).Key;\\n        int i=0;\\n        bool secondRound=false;\\n        for(int j=0;j<max;j++)\\n        {\\n            result[i]=maxChar;\\n            i+=2;\\n        }\\n        foreach(var item in freq){\\n            if(item.Key!=maxChar){\\n                for(int j=0;j<item.Value;j++){\\n                    if(i>=s.Length && !secondRound){\\n                        i=1;\\n                        secondRound=true;\\n                    }\\n                    result[i]=item.Key;\\n                    i+=2;\\n                }\\n            }\\n        }\\n        return new string(result);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string ReorganizeString(string s) {\\n        var result = new char[s.Length];\\n        var freq = new Dictionary<char,int>();\\n        foreach(var ch in s){\\n            if(freq.ContainsKey(ch)) freq[ch]++;\\n            else freq.Add(ch,1);\\n        }\\n        var max=freq.Max(p=>p.Value);\\n        if(max>(s.Length+1)/2) return \"\";\\n        var maxChar=freq.First(p=>p.Value==max).Key;\\n        int i=0;\\n        bool secondRound=false;\\n        for(int j=0;j<max;j++)\\n        {\\n            result[i]=maxChar;\\n            i+=2;\\n        }\\n        foreach(var item in freq){\\n            if(item.Key!=maxChar){\\n                for(int j=0;j<item.Value;j++){\\n                    if(i>=s.Length && !secondRound){\\n                        i=1;\\n                        secondRound=true;\\n                    }\\n                    result[i]=item.Key;\\n                    i+=2;\\n                }\\n            }\\n        }\\n        return new string(result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2026577,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/GaUxskL\">\\n  <img src=\"https://i.imgur.com/GaUxskL.jpg\" title=\"source: imgur.com\" style=\"height: 300px;\" width=\"300px\" />\\n</a>\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@DoraBabukondala](/DoraBabukondala) Lacrimosa \\uD83D\\uDE15"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "knock knock"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I will learn priority queue, but not today."
                    },
                    {
                        "username": "arsalAbbas",
                        "content": "https://leetcode.com/problems/reorganize-string/solutions/3948675/detailed-c-solution-o-n-without-heap-beats-100-in-time/\\n\\nWho said anything about priority queue? ; )"
                    },
                    {
                        "username": "Barney786",
                        "content": "without using priority queue u can solve it too just place the max freq of  char alternatively/gap of 1 in resultant string"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@z3eg](/z3eg) me now.\\n"
                    },
                    {
                        "username": "21bce043",
                        "content": "us moment\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me basically every day lmao"
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"Alternate placing the most common letters. \" Use this hint to know\n If there is some character c with freq(c)>(n+1)/2 then it is impossible"
                    },
                    {
                        "username": "wafsinc",
                        "content": "WHY ARE YOU YELLING."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Sukhwindersingh0007](/Sukhwindersingh0007) If n is odd, use both ends there are  at most (n+1)/2 alternating places. If n is even, there are at most n/2 alternating places.\\nDue to Pigeonhole principle, if some character c with freq(c)>(n+1)/2 , then there must be some place for the adjacent characters with c!"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Whats the intitution?\\n"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "helful \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s easy to realise what we need to do here, alternatively put characters with maximum frequency. The problem lies in implementing this.\\n\\nEven if you get the intuition of using `Heaps`, it\\'s still a tricky one to implement.\\n\\nSo, the trick is to store pair of `{frequency,char}` in a Heap. Then while `Heap.size()>1` , at every iteration, take out the top two elements, append them to the ans string, decrease their frequency by `1` and push them again in the Heap.\\n\\nWhen the loop will break, either the Heap became `empty` or of `1 size.`\\n\\nIf it\\'s empty, return the ans string.\\n\\nif it has `size == 1`, check the remaining frequency of the top/last element, if its `1`, append it and return ans.\\n\\nOtherwise, return `\"\"`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sikora92](/sikora92) so heap will do that automatically, no? that\\'s why we will use that"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@ktnaneri](/ktnaneri) haha, mistakes happen"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Wish I read your comment before reading the solutions..."
                    },
                    {
                        "username": "sikora92",
                        "content": "Very good top. It does not have to be heap, any sorted collection will work. And remember to sort by frequency (current, not initial)."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "seemed easy at first... until it wasn\\'t"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "tricky one\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The approach to solve this problem is to use a priority queue to store the characters based on their frequency. We first count the frequency of each character in the string and store it in a hash map. Then, we create a priority queue and add all the characters from the hash map to it. We use a comparator to order the characters in the priority queue based on their frequency in decreasing order.\n\nThen, we take out two characters from the priority queue and append them to the output string. We keep track of the last character appended to the output string. If the next character in the priority queue is the same as the last character appended to the output string, we take out the next character from the priority queue and append it to the output string. We continue this process until the priority queue is empty or we cannot append any more characters to the output string.\n\nIf we cannot append any more characters to the output string, we return an empty string."
                    },
                    {
                        "username": "dec0de",
                        "content": "Input: \\n\"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\\\\\\\\\\\\\\\\\\n\\nMy output: \\n\"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\\n\\nExpected:\\n\"eweweweweweweweweweweweweweueueueueueueueueueueueueueueuhuhuhuhuhuhshshshshshshshshshshshshshshshshshshshphphphpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcrcrcrcrcrcrcrcrcrcrcrcrmrmrmrmrmrmrmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmgmgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvovovovovovovovovonononononononononbnbnbnbnbnbnbnbnbnbnbnbnbnbnbabaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiatatatatatftftftftftftftftftftftfdfdfdfdfdfdfdfdfdfdfdydydydydyzyzyzyzyzyzyzyzyzyzyzyzyzyzyjyjyjyjkjkjkjkjkjkjkjklklklklklklklklklklklkqkqkqwqwqwqwqwqwqwqwq\"\\n\\nMy output seems correct to me as there are no chars that are same and adajacent.\\nCan anybody point me where did i miss something?\\nThis the last test case"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@its_iterator](/its_iterator) nice , you earned my upvote "
                    },
                    {
                        "username": "jPank1983",
                        "content": "Copy that test case and then run it ( !submit ) then leetcode automatically highlight error "
                    },
                    {
                        "username": "its_iterator",
                        "content": "```\ns = \"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\n\np = \"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\n\na = [0]*26\nb = [0]*26\n\nfor i in range(len(s)):\n  a[ord(s[i])-ord('a')]+=1\n\nfor i in range(len(p)):\n  b[ord(p[i])-ord('a')]+=1\n\nprint(a)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 11, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\nprint(b)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 9, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\n\n```\n[@dec0de](/dec0de) your output have 2 \"j\" character sort than expected output.\n\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This problem is very similar to Task Scheduler, https://leetcode.com/problems/task-scheduler/. If you have done Task Scheduler you should recognize the pattern quickly"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "what if the question is with minimum numbers of swap done .. the !?? can someone give idea ?"
                    }
                ]
            },
            {
                "id": 2026265,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/GaUxskL\">\\n  <img src=\"https://i.imgur.com/GaUxskL.jpg\" title=\"source: imgur.com\" style=\"height: 300px;\" width=\"300px\" />\\n</a>\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@DoraBabukondala](/DoraBabukondala) Lacrimosa \\uD83D\\uDE15"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "knock knock"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I will learn priority queue, but not today."
                    },
                    {
                        "username": "arsalAbbas",
                        "content": "https://leetcode.com/problems/reorganize-string/solutions/3948675/detailed-c-solution-o-n-without-heap-beats-100-in-time/\\n\\nWho said anything about priority queue? ; )"
                    },
                    {
                        "username": "Barney786",
                        "content": "without using priority queue u can solve it too just place the max freq of  char alternatively/gap of 1 in resultant string"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@z3eg](/z3eg) me now.\\n"
                    },
                    {
                        "username": "21bce043",
                        "content": "us moment\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me basically every day lmao"
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"Alternate placing the most common letters. \" Use this hint to know\n If there is some character c with freq(c)>(n+1)/2 then it is impossible"
                    },
                    {
                        "username": "wafsinc",
                        "content": "WHY ARE YOU YELLING."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Sukhwindersingh0007](/Sukhwindersingh0007) If n is odd, use both ends there are  at most (n+1)/2 alternating places. If n is even, there are at most n/2 alternating places.\\nDue to Pigeonhole principle, if some character c with freq(c)>(n+1)/2 , then there must be some place for the adjacent characters with c!"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Whats the intitution?\\n"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "helful \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s easy to realise what we need to do here, alternatively put characters with maximum frequency. The problem lies in implementing this.\\n\\nEven if you get the intuition of using `Heaps`, it\\'s still a tricky one to implement.\\n\\nSo, the trick is to store pair of `{frequency,char}` in a Heap. Then while `Heap.size()>1` , at every iteration, take out the top two elements, append them to the ans string, decrease their frequency by `1` and push them again in the Heap.\\n\\nWhen the loop will break, either the Heap became `empty` or of `1 size.`\\n\\nIf it\\'s empty, return the ans string.\\n\\nif it has `size == 1`, check the remaining frequency of the top/last element, if its `1`, append it and return ans.\\n\\nOtherwise, return `\"\"`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sikora92](/sikora92) so heap will do that automatically, no? that\\'s why we will use that"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@ktnaneri](/ktnaneri) haha, mistakes happen"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Wish I read your comment before reading the solutions..."
                    },
                    {
                        "username": "sikora92",
                        "content": "Very good top. It does not have to be heap, any sorted collection will work. And remember to sort by frequency (current, not initial)."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "seemed easy at first... until it wasn\\'t"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "tricky one\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The approach to solve this problem is to use a priority queue to store the characters based on their frequency. We first count the frequency of each character in the string and store it in a hash map. Then, we create a priority queue and add all the characters from the hash map to it. We use a comparator to order the characters in the priority queue based on their frequency in decreasing order.\n\nThen, we take out two characters from the priority queue and append them to the output string. We keep track of the last character appended to the output string. If the next character in the priority queue is the same as the last character appended to the output string, we take out the next character from the priority queue and append it to the output string. We continue this process until the priority queue is empty or we cannot append any more characters to the output string.\n\nIf we cannot append any more characters to the output string, we return an empty string."
                    },
                    {
                        "username": "dec0de",
                        "content": "Input: \\n\"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\\\\\\\\\\\\\\\\\\n\\nMy output: \\n\"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\\n\\nExpected:\\n\"eweweweweweweweweweweweweweueueueueueueueueueueueueueueuhuhuhuhuhuhshshshshshshshshshshshshshshshshshshshphphphpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcrcrcrcrcrcrcrcrcrcrcrcrmrmrmrmrmrmrmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmgmgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvovovovovovovovovonononononononononbnbnbnbnbnbnbnbnbnbnbnbnbnbnbabaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiatatatatatftftftftftftftftftftftfdfdfdfdfdfdfdfdfdfdfdydydydydyzyzyzyzyzyzyzyzyzyzyzyzyzyzyjyjyjyjkjkjkjkjkjkjkjklklklklklklklklklklklkqkqkqwqwqwqwqwqwqwqwq\"\\n\\nMy output seems correct to me as there are no chars that are same and adajacent.\\nCan anybody point me where did i miss something?\\nThis the last test case"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@its_iterator](/its_iterator) nice , you earned my upvote "
                    },
                    {
                        "username": "jPank1983",
                        "content": "Copy that test case and then run it ( !submit ) then leetcode automatically highlight error "
                    },
                    {
                        "username": "its_iterator",
                        "content": "```\ns = \"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\n\np = \"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\n\na = [0]*26\nb = [0]*26\n\nfor i in range(len(s)):\n  a[ord(s[i])-ord('a')]+=1\n\nfor i in range(len(p)):\n  b[ord(p[i])-ord('a')]+=1\n\nprint(a)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 11, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\nprint(b)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 9, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\n\n```\n[@dec0de](/dec0de) your output have 2 \"j\" character sort than expected output.\n\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This problem is very similar to Task Scheduler, https://leetcode.com/problems/task-scheduler/. If you have done Task Scheduler you should recognize the pattern quickly"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "what if the question is with minimum numbers of swap done .. the !?? can someone give idea ?"
                    }
                ]
            },
            {
                "id": 2026236,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/GaUxskL\">\\n  <img src=\"https://i.imgur.com/GaUxskL.jpg\" title=\"source: imgur.com\" style=\"height: 300px;\" width=\"300px\" />\\n</a>\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@DoraBabukondala](/DoraBabukondala) Lacrimosa \\uD83D\\uDE15"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "knock knock"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I will learn priority queue, but not today."
                    },
                    {
                        "username": "arsalAbbas",
                        "content": "https://leetcode.com/problems/reorganize-string/solutions/3948675/detailed-c-solution-o-n-without-heap-beats-100-in-time/\\n\\nWho said anything about priority queue? ; )"
                    },
                    {
                        "username": "Barney786",
                        "content": "without using priority queue u can solve it too just place the max freq of  char alternatively/gap of 1 in resultant string"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@z3eg](/z3eg) me now.\\n"
                    },
                    {
                        "username": "21bce043",
                        "content": "us moment\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me basically every day lmao"
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"Alternate placing the most common letters. \" Use this hint to know\n If there is some character c with freq(c)>(n+1)/2 then it is impossible"
                    },
                    {
                        "username": "wafsinc",
                        "content": "WHY ARE YOU YELLING."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Sukhwindersingh0007](/Sukhwindersingh0007) If n is odd, use both ends there are  at most (n+1)/2 alternating places. If n is even, there are at most n/2 alternating places.\\nDue to Pigeonhole principle, if some character c with freq(c)>(n+1)/2 , then there must be some place for the adjacent characters with c!"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Whats the intitution?\\n"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "helful \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s easy to realise what we need to do here, alternatively put characters with maximum frequency. The problem lies in implementing this.\\n\\nEven if you get the intuition of using `Heaps`, it\\'s still a tricky one to implement.\\n\\nSo, the trick is to store pair of `{frequency,char}` in a Heap. Then while `Heap.size()>1` , at every iteration, take out the top two elements, append them to the ans string, decrease their frequency by `1` and push them again in the Heap.\\n\\nWhen the loop will break, either the Heap became `empty` or of `1 size.`\\n\\nIf it\\'s empty, return the ans string.\\n\\nif it has `size == 1`, check the remaining frequency of the top/last element, if its `1`, append it and return ans.\\n\\nOtherwise, return `\"\"`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sikora92](/sikora92) so heap will do that automatically, no? that\\'s why we will use that"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@ktnaneri](/ktnaneri) haha, mistakes happen"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Wish I read your comment before reading the solutions..."
                    },
                    {
                        "username": "sikora92",
                        "content": "Very good top. It does not have to be heap, any sorted collection will work. And remember to sort by frequency (current, not initial)."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "seemed easy at first... until it wasn\\'t"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "tricky one\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The approach to solve this problem is to use a priority queue to store the characters based on their frequency. We first count the frequency of each character in the string and store it in a hash map. Then, we create a priority queue and add all the characters from the hash map to it. We use a comparator to order the characters in the priority queue based on their frequency in decreasing order.\n\nThen, we take out two characters from the priority queue and append them to the output string. We keep track of the last character appended to the output string. If the next character in the priority queue is the same as the last character appended to the output string, we take out the next character from the priority queue and append it to the output string. We continue this process until the priority queue is empty or we cannot append any more characters to the output string.\n\nIf we cannot append any more characters to the output string, we return an empty string."
                    },
                    {
                        "username": "dec0de",
                        "content": "Input: \\n\"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\\\\\\\\\\\\\\\\\\n\\nMy output: \\n\"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\\n\\nExpected:\\n\"eweweweweweweweweweweweweweueueueueueueueueueueueueueueuhuhuhuhuhuhshshshshshshshshshshshshshshshshshshshphphphpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcrcrcrcrcrcrcrcrcrcrcrcrmrmrmrmrmrmrmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmgmgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvovovovovovovovovonononononononononbnbnbnbnbnbnbnbnbnbnbnbnbnbnbabaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiatatatatatftftftftftftftftftftftfdfdfdfdfdfdfdfdfdfdfdydydydydyzyzyzyzyzyzyzyzyzyzyzyzyzyzyjyjyjyjkjkjkjkjkjkjkjklklklklklklklklklklklkqkqkqwqwqwqwqwqwqwqwq\"\\n\\nMy output seems correct to me as there are no chars that are same and adajacent.\\nCan anybody point me where did i miss something?\\nThis the last test case"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@its_iterator](/its_iterator) nice , you earned my upvote "
                    },
                    {
                        "username": "jPank1983",
                        "content": "Copy that test case and then run it ( !submit ) then leetcode automatically highlight error "
                    },
                    {
                        "username": "its_iterator",
                        "content": "```\ns = \"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\n\np = \"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\n\na = [0]*26\nb = [0]*26\n\nfor i in range(len(s)):\n  a[ord(s[i])-ord('a')]+=1\n\nfor i in range(len(p)):\n  b[ord(p[i])-ord('a')]+=1\n\nprint(a)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 11, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\nprint(b)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 9, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\n\n```\n[@dec0de](/dec0de) your output have 2 \"j\" character sort than expected output.\n\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This problem is very similar to Task Scheduler, https://leetcode.com/problems/task-scheduler/. If you have done Task Scheduler you should recognize the pattern quickly"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "what if the question is with minimum numbers of swap done .. the !?? can someone give idea ?"
                    }
                ]
            },
            {
                "id": 2026331,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/GaUxskL\">\\n  <img src=\"https://i.imgur.com/GaUxskL.jpg\" title=\"source: imgur.com\" style=\"height: 300px;\" width=\"300px\" />\\n</a>\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@DoraBabukondala](/DoraBabukondala) Lacrimosa \\uD83D\\uDE15"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "knock knock"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I will learn priority queue, but not today."
                    },
                    {
                        "username": "arsalAbbas",
                        "content": "https://leetcode.com/problems/reorganize-string/solutions/3948675/detailed-c-solution-o-n-without-heap-beats-100-in-time/\\n\\nWho said anything about priority queue? ; )"
                    },
                    {
                        "username": "Barney786",
                        "content": "without using priority queue u can solve it too just place the max freq of  char alternatively/gap of 1 in resultant string"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@z3eg](/z3eg) me now.\\n"
                    },
                    {
                        "username": "21bce043",
                        "content": "us moment\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me basically every day lmao"
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"Alternate placing the most common letters. \" Use this hint to know\n If there is some character c with freq(c)>(n+1)/2 then it is impossible"
                    },
                    {
                        "username": "wafsinc",
                        "content": "WHY ARE YOU YELLING."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Sukhwindersingh0007](/Sukhwindersingh0007) If n is odd, use both ends there are  at most (n+1)/2 alternating places. If n is even, there are at most n/2 alternating places.\\nDue to Pigeonhole principle, if some character c with freq(c)>(n+1)/2 , then there must be some place for the adjacent characters with c!"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Whats the intitution?\\n"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "helful \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s easy to realise what we need to do here, alternatively put characters with maximum frequency. The problem lies in implementing this.\\n\\nEven if you get the intuition of using `Heaps`, it\\'s still a tricky one to implement.\\n\\nSo, the trick is to store pair of `{frequency,char}` in a Heap. Then while `Heap.size()>1` , at every iteration, take out the top two elements, append them to the ans string, decrease their frequency by `1` and push them again in the Heap.\\n\\nWhen the loop will break, either the Heap became `empty` or of `1 size.`\\n\\nIf it\\'s empty, return the ans string.\\n\\nif it has `size == 1`, check the remaining frequency of the top/last element, if its `1`, append it and return ans.\\n\\nOtherwise, return `\"\"`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sikora92](/sikora92) so heap will do that automatically, no? that\\'s why we will use that"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@ktnaneri](/ktnaneri) haha, mistakes happen"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Wish I read your comment before reading the solutions..."
                    },
                    {
                        "username": "sikora92",
                        "content": "Very good top. It does not have to be heap, any sorted collection will work. And remember to sort by frequency (current, not initial)."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "seemed easy at first... until it wasn\\'t"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "tricky one\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The approach to solve this problem is to use a priority queue to store the characters based on their frequency. We first count the frequency of each character in the string and store it in a hash map. Then, we create a priority queue and add all the characters from the hash map to it. We use a comparator to order the characters in the priority queue based on their frequency in decreasing order.\n\nThen, we take out two characters from the priority queue and append them to the output string. We keep track of the last character appended to the output string. If the next character in the priority queue is the same as the last character appended to the output string, we take out the next character from the priority queue and append it to the output string. We continue this process until the priority queue is empty or we cannot append any more characters to the output string.\n\nIf we cannot append any more characters to the output string, we return an empty string."
                    },
                    {
                        "username": "dec0de",
                        "content": "Input: \\n\"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\\\\\\\\\\\\\\\\\\n\\nMy output: \\n\"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\\n\\nExpected:\\n\"eweweweweweweweweweweweweweueueueueueueueueueueueueueueuhuhuhuhuhuhshshshshshshshshshshshshshshshshshshshphphphpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcrcrcrcrcrcrcrcrcrcrcrcrmrmrmrmrmrmrmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmgmgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvovovovovovovovovonononononononononbnbnbnbnbnbnbnbnbnbnbnbnbnbnbabaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiatatatatatftftftftftftftftftftftfdfdfdfdfdfdfdfdfdfdfdydydydydyzyzyzyzyzyzyzyzyzyzyzyzyzyzyjyjyjyjkjkjkjkjkjkjkjklklklklklklklklklklklkqkqkqwqwqwqwqwqwqwqwq\"\\n\\nMy output seems correct to me as there are no chars that are same and adajacent.\\nCan anybody point me where did i miss something?\\nThis the last test case"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@its_iterator](/its_iterator) nice , you earned my upvote "
                    },
                    {
                        "username": "jPank1983",
                        "content": "Copy that test case and then run it ( !submit ) then leetcode automatically highlight error "
                    },
                    {
                        "username": "its_iterator",
                        "content": "```\ns = \"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\n\np = \"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\n\na = [0]*26\nb = [0]*26\n\nfor i in range(len(s)):\n  a[ord(s[i])-ord('a')]+=1\n\nfor i in range(len(p)):\n  b[ord(p[i])-ord('a')]+=1\n\nprint(a)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 11, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\nprint(b)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 9, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\n\n```\n[@dec0de](/dec0de) your output have 2 \"j\" character sort than expected output.\n\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This problem is very similar to Task Scheduler, https://leetcode.com/problems/task-scheduler/. If you have done Task Scheduler you should recognize the pattern quickly"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "what if the question is with minimum numbers of swap done .. the !?? can someone give idea ?"
                    }
                ]
            },
            {
                "id": 2026244,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/GaUxskL\">\\n  <img src=\"https://i.imgur.com/GaUxskL.jpg\" title=\"source: imgur.com\" style=\"height: 300px;\" width=\"300px\" />\\n</a>\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@DoraBabukondala](/DoraBabukondala) Lacrimosa \\uD83D\\uDE15"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "knock knock"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I will learn priority queue, but not today."
                    },
                    {
                        "username": "arsalAbbas",
                        "content": "https://leetcode.com/problems/reorganize-string/solutions/3948675/detailed-c-solution-o-n-without-heap-beats-100-in-time/\\n\\nWho said anything about priority queue? ; )"
                    },
                    {
                        "username": "Barney786",
                        "content": "without using priority queue u can solve it too just place the max freq of  char alternatively/gap of 1 in resultant string"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@z3eg](/z3eg) me now.\\n"
                    },
                    {
                        "username": "21bce043",
                        "content": "us moment\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me basically every day lmao"
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"Alternate placing the most common letters. \" Use this hint to know\n If there is some character c with freq(c)>(n+1)/2 then it is impossible"
                    },
                    {
                        "username": "wafsinc",
                        "content": "WHY ARE YOU YELLING."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Sukhwindersingh0007](/Sukhwindersingh0007) If n is odd, use both ends there are  at most (n+1)/2 alternating places. If n is even, there are at most n/2 alternating places.\\nDue to Pigeonhole principle, if some character c with freq(c)>(n+1)/2 , then there must be some place for the adjacent characters with c!"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Whats the intitution?\\n"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "helful \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s easy to realise what we need to do here, alternatively put characters with maximum frequency. The problem lies in implementing this.\\n\\nEven if you get the intuition of using `Heaps`, it\\'s still a tricky one to implement.\\n\\nSo, the trick is to store pair of `{frequency,char}` in a Heap. Then while `Heap.size()>1` , at every iteration, take out the top two elements, append them to the ans string, decrease their frequency by `1` and push them again in the Heap.\\n\\nWhen the loop will break, either the Heap became `empty` or of `1 size.`\\n\\nIf it\\'s empty, return the ans string.\\n\\nif it has `size == 1`, check the remaining frequency of the top/last element, if its `1`, append it and return ans.\\n\\nOtherwise, return `\"\"`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sikora92](/sikora92) so heap will do that automatically, no? that\\'s why we will use that"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@ktnaneri](/ktnaneri) haha, mistakes happen"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Wish I read your comment before reading the solutions..."
                    },
                    {
                        "username": "sikora92",
                        "content": "Very good top. It does not have to be heap, any sorted collection will work. And remember to sort by frequency (current, not initial)."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "seemed easy at first... until it wasn\\'t"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "tricky one\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The approach to solve this problem is to use a priority queue to store the characters based on their frequency. We first count the frequency of each character in the string and store it in a hash map. Then, we create a priority queue and add all the characters from the hash map to it. We use a comparator to order the characters in the priority queue based on their frequency in decreasing order.\n\nThen, we take out two characters from the priority queue and append them to the output string. We keep track of the last character appended to the output string. If the next character in the priority queue is the same as the last character appended to the output string, we take out the next character from the priority queue and append it to the output string. We continue this process until the priority queue is empty or we cannot append any more characters to the output string.\n\nIf we cannot append any more characters to the output string, we return an empty string."
                    },
                    {
                        "username": "dec0de",
                        "content": "Input: \\n\"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\\\\\\\\\\\\\\\\\\n\\nMy output: \\n\"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\\n\\nExpected:\\n\"eweweweweweweweweweweweweweueueueueueueueueueueueueueueuhuhuhuhuhuhshshshshshshshshshshshshshshshshshshshphphphpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcrcrcrcrcrcrcrcrcrcrcrcrmrmrmrmrmrmrmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmgmgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvovovovovovovovovonononononononononbnbnbnbnbnbnbnbnbnbnbnbnbnbnbabaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiatatatatatftftftftftftftftftftftfdfdfdfdfdfdfdfdfdfdfdydydydydyzyzyzyzyzyzyzyzyzyzyzyzyzyzyjyjyjyjkjkjkjkjkjkjkjklklklklklklklklklklklkqkqkqwqwqwqwqwqwqwqwq\"\\n\\nMy output seems correct to me as there are no chars that are same and adajacent.\\nCan anybody point me where did i miss something?\\nThis the last test case"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@its_iterator](/its_iterator) nice , you earned my upvote "
                    },
                    {
                        "username": "jPank1983",
                        "content": "Copy that test case and then run it ( !submit ) then leetcode automatically highlight error "
                    },
                    {
                        "username": "its_iterator",
                        "content": "```\ns = \"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\n\np = \"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\n\na = [0]*26\nb = [0]*26\n\nfor i in range(len(s)):\n  a[ord(s[i])-ord('a')]+=1\n\nfor i in range(len(p)):\n  b[ord(p[i])-ord('a')]+=1\n\nprint(a)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 11, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\nprint(b)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 9, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\n\n```\n[@dec0de](/dec0de) your output have 2 \"j\" character sort than expected output.\n\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This problem is very similar to Task Scheduler, https://leetcode.com/problems/task-scheduler/. If you have done Task Scheduler you should recognize the pattern quickly"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "what if the question is with minimum numbers of swap done .. the !?? can someone give idea ?"
                    }
                ]
            },
            {
                "id": 1739742,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/GaUxskL\">\\n  <img src=\"https://i.imgur.com/GaUxskL.jpg\" title=\"source: imgur.com\" style=\"height: 300px;\" width=\"300px\" />\\n</a>\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@DoraBabukondala](/DoraBabukondala) Lacrimosa \\uD83D\\uDE15"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "knock knock"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I will learn priority queue, but not today."
                    },
                    {
                        "username": "arsalAbbas",
                        "content": "https://leetcode.com/problems/reorganize-string/solutions/3948675/detailed-c-solution-o-n-without-heap-beats-100-in-time/\\n\\nWho said anything about priority queue? ; )"
                    },
                    {
                        "username": "Barney786",
                        "content": "without using priority queue u can solve it too just place the max freq of  char alternatively/gap of 1 in resultant string"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@z3eg](/z3eg) me now.\\n"
                    },
                    {
                        "username": "21bce043",
                        "content": "us moment\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me basically every day lmao"
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"Alternate placing the most common letters. \" Use this hint to know\n If there is some character c with freq(c)>(n+1)/2 then it is impossible"
                    },
                    {
                        "username": "wafsinc",
                        "content": "WHY ARE YOU YELLING."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Sukhwindersingh0007](/Sukhwindersingh0007) If n is odd, use both ends there are  at most (n+1)/2 alternating places. If n is even, there are at most n/2 alternating places.\\nDue to Pigeonhole principle, if some character c with freq(c)>(n+1)/2 , then there must be some place for the adjacent characters with c!"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Whats the intitution?\\n"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "helful \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s easy to realise what we need to do here, alternatively put characters with maximum frequency. The problem lies in implementing this.\\n\\nEven if you get the intuition of using `Heaps`, it\\'s still a tricky one to implement.\\n\\nSo, the trick is to store pair of `{frequency,char}` in a Heap. Then while `Heap.size()>1` , at every iteration, take out the top two elements, append them to the ans string, decrease their frequency by `1` and push them again in the Heap.\\n\\nWhen the loop will break, either the Heap became `empty` or of `1 size.`\\n\\nIf it\\'s empty, return the ans string.\\n\\nif it has `size == 1`, check the remaining frequency of the top/last element, if its `1`, append it and return ans.\\n\\nOtherwise, return `\"\"`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sikora92](/sikora92) so heap will do that automatically, no? that\\'s why we will use that"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@ktnaneri](/ktnaneri) haha, mistakes happen"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Wish I read your comment before reading the solutions..."
                    },
                    {
                        "username": "sikora92",
                        "content": "Very good top. It does not have to be heap, any sorted collection will work. And remember to sort by frequency (current, not initial)."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "seemed easy at first... until it wasn\\'t"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "tricky one\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The approach to solve this problem is to use a priority queue to store the characters based on their frequency. We first count the frequency of each character in the string and store it in a hash map. Then, we create a priority queue and add all the characters from the hash map to it. We use a comparator to order the characters in the priority queue based on their frequency in decreasing order.\n\nThen, we take out two characters from the priority queue and append them to the output string. We keep track of the last character appended to the output string. If the next character in the priority queue is the same as the last character appended to the output string, we take out the next character from the priority queue and append it to the output string. We continue this process until the priority queue is empty or we cannot append any more characters to the output string.\n\nIf we cannot append any more characters to the output string, we return an empty string."
                    },
                    {
                        "username": "dec0de",
                        "content": "Input: \\n\"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\\\\\\\\\\\\\\\\\\n\\nMy output: \\n\"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\\n\\nExpected:\\n\"eweweweweweweweweweweweweweueueueueueueueueueueueueueueuhuhuhuhuhuhshshshshshshshshshshshshshshshshshshshphphphpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcrcrcrcrcrcrcrcrcrcrcrcrmrmrmrmrmrmrmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmgmgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvovovovovovovovovonononononononononbnbnbnbnbnbnbnbnbnbnbnbnbnbnbabaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiatatatatatftftftftftftftftftftftfdfdfdfdfdfdfdfdfdfdfdydydydydyzyzyzyzyzyzyzyzyzyzyzyzyzyzyjyjyjyjkjkjkjkjkjkjkjklklklklklklklklklklklkqkqkqwqwqwqwqwqwqwqwq\"\\n\\nMy output seems correct to me as there are no chars that are same and adajacent.\\nCan anybody point me where did i miss something?\\nThis the last test case"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@its_iterator](/its_iterator) nice , you earned my upvote "
                    },
                    {
                        "username": "jPank1983",
                        "content": "Copy that test case and then run it ( !submit ) then leetcode automatically highlight error "
                    },
                    {
                        "username": "its_iterator",
                        "content": "```\ns = \"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\n\np = \"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\n\na = [0]*26\nb = [0]*26\n\nfor i in range(len(s)):\n  a[ord(s[i])-ord('a')]+=1\n\nfor i in range(len(p)):\n  b[ord(p[i])-ord('a')]+=1\n\nprint(a)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 11, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\nprint(b)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 9, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\n\n```\n[@dec0de](/dec0de) your output have 2 \"j\" character sort than expected output.\n\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This problem is very similar to Task Scheduler, https://leetcode.com/problems/task-scheduler/. If you have done Task Scheduler you should recognize the pattern quickly"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "what if the question is with minimum numbers of swap done .. the !?? can someone give idea ?"
                    }
                ]
            },
            {
                "id": 1812318,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/GaUxskL\">\\n  <img src=\"https://i.imgur.com/GaUxskL.jpg\" title=\"source: imgur.com\" style=\"height: 300px;\" width=\"300px\" />\\n</a>\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@DoraBabukondala](/DoraBabukondala) Lacrimosa \\uD83D\\uDE15"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "knock knock"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I will learn priority queue, but not today."
                    },
                    {
                        "username": "arsalAbbas",
                        "content": "https://leetcode.com/problems/reorganize-string/solutions/3948675/detailed-c-solution-o-n-without-heap-beats-100-in-time/\\n\\nWho said anything about priority queue? ; )"
                    },
                    {
                        "username": "Barney786",
                        "content": "without using priority queue u can solve it too just place the max freq of  char alternatively/gap of 1 in resultant string"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@z3eg](/z3eg) me now.\\n"
                    },
                    {
                        "username": "21bce043",
                        "content": "us moment\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me basically every day lmao"
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"Alternate placing the most common letters. \" Use this hint to know\n If there is some character c with freq(c)>(n+1)/2 then it is impossible"
                    },
                    {
                        "username": "wafsinc",
                        "content": "WHY ARE YOU YELLING."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Sukhwindersingh0007](/Sukhwindersingh0007) If n is odd, use both ends there are  at most (n+1)/2 alternating places. If n is even, there are at most n/2 alternating places.\\nDue to Pigeonhole principle, if some character c with freq(c)>(n+1)/2 , then there must be some place for the adjacent characters with c!"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Whats the intitution?\\n"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "helful \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s easy to realise what we need to do here, alternatively put characters with maximum frequency. The problem lies in implementing this.\\n\\nEven if you get the intuition of using `Heaps`, it\\'s still a tricky one to implement.\\n\\nSo, the trick is to store pair of `{frequency,char}` in a Heap. Then while `Heap.size()>1` , at every iteration, take out the top two elements, append them to the ans string, decrease their frequency by `1` and push them again in the Heap.\\n\\nWhen the loop will break, either the Heap became `empty` or of `1 size.`\\n\\nIf it\\'s empty, return the ans string.\\n\\nif it has `size == 1`, check the remaining frequency of the top/last element, if its `1`, append it and return ans.\\n\\nOtherwise, return `\"\"`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sikora92](/sikora92) so heap will do that automatically, no? that\\'s why we will use that"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@ktnaneri](/ktnaneri) haha, mistakes happen"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Wish I read your comment before reading the solutions..."
                    },
                    {
                        "username": "sikora92",
                        "content": "Very good top. It does not have to be heap, any sorted collection will work. And remember to sort by frequency (current, not initial)."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "seemed easy at first... until it wasn\\'t"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "tricky one\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The approach to solve this problem is to use a priority queue to store the characters based on their frequency. We first count the frequency of each character in the string and store it in a hash map. Then, we create a priority queue and add all the characters from the hash map to it. We use a comparator to order the characters in the priority queue based on their frequency in decreasing order.\n\nThen, we take out two characters from the priority queue and append them to the output string. We keep track of the last character appended to the output string. If the next character in the priority queue is the same as the last character appended to the output string, we take out the next character from the priority queue and append it to the output string. We continue this process until the priority queue is empty or we cannot append any more characters to the output string.\n\nIf we cannot append any more characters to the output string, we return an empty string."
                    },
                    {
                        "username": "dec0de",
                        "content": "Input: \\n\"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\\\\\\\\\\\\\\\\\\n\\nMy output: \\n\"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\\n\\nExpected:\\n\"eweweweweweweweweweweweweweueueueueueueueueueueueueueueuhuhuhuhuhuhshshshshshshshshshshshshshshshshshshshphphphpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcrcrcrcrcrcrcrcrcrcrcrcrmrmrmrmrmrmrmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmgmgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvovovovovovovovovonononononononononbnbnbnbnbnbnbnbnbnbnbnbnbnbnbabaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiatatatatatftftftftftftftftftftftfdfdfdfdfdfdfdfdfdfdfdydydydydyzyzyzyzyzyzyzyzyzyzyzyzyzyzyjyjyjyjkjkjkjkjkjkjkjklklklklklklklklklklklkqkqkqwqwqwqwqwqwqwqwq\"\\n\\nMy output seems correct to me as there are no chars that are same and adajacent.\\nCan anybody point me where did i miss something?\\nThis the last test case"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@its_iterator](/its_iterator) nice , you earned my upvote "
                    },
                    {
                        "username": "jPank1983",
                        "content": "Copy that test case and then run it ( !submit ) then leetcode automatically highlight error "
                    },
                    {
                        "username": "its_iterator",
                        "content": "```\ns = \"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\n\np = \"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\n\na = [0]*26\nb = [0]*26\n\nfor i in range(len(s)):\n  a[ord(s[i])-ord('a')]+=1\n\nfor i in range(len(p)):\n  b[ord(p[i])-ord('a')]+=1\n\nprint(a)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 11, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\nprint(b)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 9, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\n\n```\n[@dec0de](/dec0de) your output have 2 \"j\" character sort than expected output.\n\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This problem is very similar to Task Scheduler, https://leetcode.com/problems/task-scheduler/. If you have done Task Scheduler you should recognize the pattern quickly"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "what if the question is with minimum numbers of swap done .. the !?? can someone give idea ?"
                    }
                ]
            },
            {
                "id": 1572502,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/GaUxskL\">\\n  <img src=\"https://i.imgur.com/GaUxskL.jpg\" title=\"source: imgur.com\" style=\"height: 300px;\" width=\"300px\" />\\n</a>\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@DoraBabukondala](/DoraBabukondala) Lacrimosa \\uD83D\\uDE15"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "knock knock"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I will learn priority queue, but not today."
                    },
                    {
                        "username": "arsalAbbas",
                        "content": "https://leetcode.com/problems/reorganize-string/solutions/3948675/detailed-c-solution-o-n-without-heap-beats-100-in-time/\\n\\nWho said anything about priority queue? ; )"
                    },
                    {
                        "username": "Barney786",
                        "content": "without using priority queue u can solve it too just place the max freq of  char alternatively/gap of 1 in resultant string"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@z3eg](/z3eg) me now.\\n"
                    },
                    {
                        "username": "21bce043",
                        "content": "us moment\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me basically every day lmao"
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"Alternate placing the most common letters. \" Use this hint to know\n If there is some character c with freq(c)>(n+1)/2 then it is impossible"
                    },
                    {
                        "username": "wafsinc",
                        "content": "WHY ARE YOU YELLING."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Sukhwindersingh0007](/Sukhwindersingh0007) If n is odd, use both ends there are  at most (n+1)/2 alternating places. If n is even, there are at most n/2 alternating places.\\nDue to Pigeonhole principle, if some character c with freq(c)>(n+1)/2 , then there must be some place for the adjacent characters with c!"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Whats the intitution?\\n"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "helful \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s easy to realise what we need to do here, alternatively put characters with maximum frequency. The problem lies in implementing this.\\n\\nEven if you get the intuition of using `Heaps`, it\\'s still a tricky one to implement.\\n\\nSo, the trick is to store pair of `{frequency,char}` in a Heap. Then while `Heap.size()>1` , at every iteration, take out the top two elements, append them to the ans string, decrease their frequency by `1` and push them again in the Heap.\\n\\nWhen the loop will break, either the Heap became `empty` or of `1 size.`\\n\\nIf it\\'s empty, return the ans string.\\n\\nif it has `size == 1`, check the remaining frequency of the top/last element, if its `1`, append it and return ans.\\n\\nOtherwise, return `\"\"`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sikora92](/sikora92) so heap will do that automatically, no? that\\'s why we will use that"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@ktnaneri](/ktnaneri) haha, mistakes happen"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Wish I read your comment before reading the solutions..."
                    },
                    {
                        "username": "sikora92",
                        "content": "Very good top. It does not have to be heap, any sorted collection will work. And remember to sort by frequency (current, not initial)."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "seemed easy at first... until it wasn\\'t"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "tricky one\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The approach to solve this problem is to use a priority queue to store the characters based on their frequency. We first count the frequency of each character in the string and store it in a hash map. Then, we create a priority queue and add all the characters from the hash map to it. We use a comparator to order the characters in the priority queue based on their frequency in decreasing order.\n\nThen, we take out two characters from the priority queue and append them to the output string. We keep track of the last character appended to the output string. If the next character in the priority queue is the same as the last character appended to the output string, we take out the next character from the priority queue and append it to the output string. We continue this process until the priority queue is empty or we cannot append any more characters to the output string.\n\nIf we cannot append any more characters to the output string, we return an empty string."
                    },
                    {
                        "username": "dec0de",
                        "content": "Input: \\n\"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\\\\\\\\\\\\\\\\\\n\\nMy output: \\n\"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\\n\\nExpected:\\n\"eweweweweweweweweweweweweweueueueueueueueueueueueueueueuhuhuhuhuhuhshshshshshshshshshshshshshshshshshshshphphphpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcrcrcrcrcrcrcrcrcrcrcrcrmrmrmrmrmrmrmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmgmgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvovovovovovovovovonononononononononbnbnbnbnbnbnbnbnbnbnbnbnbnbnbabaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiatatatatatftftftftftftftftftftftfdfdfdfdfdfdfdfdfdfdfdydydydydyzyzyzyzyzyzyzyzyzyzyzyzyzyzyjyjyjyjkjkjkjkjkjkjkjklklklklklklklklklklklkqkqkqwqwqwqwqwqwqwqwq\"\\n\\nMy output seems correct to me as there are no chars that are same and adajacent.\\nCan anybody point me where did i miss something?\\nThis the last test case"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@its_iterator](/its_iterator) nice , you earned my upvote "
                    },
                    {
                        "username": "jPank1983",
                        "content": "Copy that test case and then run it ( !submit ) then leetcode automatically highlight error "
                    },
                    {
                        "username": "its_iterator",
                        "content": "```\ns = \"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\n\np = \"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\n\na = [0]*26\nb = [0]*26\n\nfor i in range(len(s)):\n  a[ord(s[i])-ord('a')]+=1\n\nfor i in range(len(p)):\n  b[ord(p[i])-ord('a')]+=1\n\nprint(a)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 11, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\nprint(b)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 9, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\n\n```\n[@dec0de](/dec0de) your output have 2 \"j\" character sort than expected output.\n\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This problem is very similar to Task Scheduler, https://leetcode.com/problems/task-scheduler/. If you have done Task Scheduler you should recognize the pattern quickly"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "what if the question is with minimum numbers of swap done .. the !?? can someone give idea ?"
                    }
                ]
            },
            {
                "id": 2026317,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/GaUxskL\">\\n  <img src=\"https://i.imgur.com/GaUxskL.jpg\" title=\"source: imgur.com\" style=\"height: 300px;\" width=\"300px\" />\\n</a>\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@DoraBabukondala](/DoraBabukondala) Lacrimosa \\uD83D\\uDE15"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "knock knock"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I will learn priority queue, but not today."
                    },
                    {
                        "username": "arsalAbbas",
                        "content": "https://leetcode.com/problems/reorganize-string/solutions/3948675/detailed-c-solution-o-n-without-heap-beats-100-in-time/\\n\\nWho said anything about priority queue? ; )"
                    },
                    {
                        "username": "Barney786",
                        "content": "without using priority queue u can solve it too just place the max freq of  char alternatively/gap of 1 in resultant string"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@z3eg](/z3eg) me now.\\n"
                    },
                    {
                        "username": "21bce043",
                        "content": "us moment\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me basically every day lmao"
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"Alternate placing the most common letters. \" Use this hint to know\n If there is some character c with freq(c)>(n+1)/2 then it is impossible"
                    },
                    {
                        "username": "wafsinc",
                        "content": "WHY ARE YOU YELLING."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Sukhwindersingh0007](/Sukhwindersingh0007) If n is odd, use both ends there are  at most (n+1)/2 alternating places. If n is even, there are at most n/2 alternating places.\\nDue to Pigeonhole principle, if some character c with freq(c)>(n+1)/2 , then there must be some place for the adjacent characters with c!"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Whats the intitution?\\n"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "helful \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s easy to realise what we need to do here, alternatively put characters with maximum frequency. The problem lies in implementing this.\\n\\nEven if you get the intuition of using `Heaps`, it\\'s still a tricky one to implement.\\n\\nSo, the trick is to store pair of `{frequency,char}` in a Heap. Then while `Heap.size()>1` , at every iteration, take out the top two elements, append them to the ans string, decrease their frequency by `1` and push them again in the Heap.\\n\\nWhen the loop will break, either the Heap became `empty` or of `1 size.`\\n\\nIf it\\'s empty, return the ans string.\\n\\nif it has `size == 1`, check the remaining frequency of the top/last element, if its `1`, append it and return ans.\\n\\nOtherwise, return `\"\"`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sikora92](/sikora92) so heap will do that automatically, no? that\\'s why we will use that"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@ktnaneri](/ktnaneri) haha, mistakes happen"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Wish I read your comment before reading the solutions..."
                    },
                    {
                        "username": "sikora92",
                        "content": "Very good top. It does not have to be heap, any sorted collection will work. And remember to sort by frequency (current, not initial)."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "seemed easy at first... until it wasn\\'t"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "tricky one\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The approach to solve this problem is to use a priority queue to store the characters based on their frequency. We first count the frequency of each character in the string and store it in a hash map. Then, we create a priority queue and add all the characters from the hash map to it. We use a comparator to order the characters in the priority queue based on their frequency in decreasing order.\n\nThen, we take out two characters from the priority queue and append them to the output string. We keep track of the last character appended to the output string. If the next character in the priority queue is the same as the last character appended to the output string, we take out the next character from the priority queue and append it to the output string. We continue this process until the priority queue is empty or we cannot append any more characters to the output string.\n\nIf we cannot append any more characters to the output string, we return an empty string."
                    },
                    {
                        "username": "dec0de",
                        "content": "Input: \\n\"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\\\\\\\\\\\\\\\\\\n\\nMy output: \\n\"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\\n\\nExpected:\\n\"eweweweweweweweweweweweweweueueueueueueueueueueueueueueuhuhuhuhuhuhshshshshshshshshshshshshshshshshshshshphphphpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcrcrcrcrcrcrcrcrcrcrcrcrmrmrmrmrmrmrmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmgmgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvovovovovovovovovonononononononononbnbnbnbnbnbnbnbnbnbnbnbnbnbnbabaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiatatatatatftftftftftftftftftftftfdfdfdfdfdfdfdfdfdfdfdydydydydyzyzyzyzyzyzyzyzyzyzyzyzyzyzyjyjyjyjkjkjkjkjkjkjkjklklklklklklklklklklklkqkqkqwqwqwqwqwqwqwqwq\"\\n\\nMy output seems correct to me as there are no chars that are same and adajacent.\\nCan anybody point me where did i miss something?\\nThis the last test case"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@its_iterator](/its_iterator) nice , you earned my upvote "
                    },
                    {
                        "username": "jPank1983",
                        "content": "Copy that test case and then run it ( !submit ) then leetcode automatically highlight error "
                    },
                    {
                        "username": "its_iterator",
                        "content": "```\ns = \"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\n\np = \"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\n\na = [0]*26\nb = [0]*26\n\nfor i in range(len(s)):\n  a[ord(s[i])-ord('a')]+=1\n\nfor i in range(len(p)):\n  b[ord(p[i])-ord('a')]+=1\n\nprint(a)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 11, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\nprint(b)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 9, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\n\n```\n[@dec0de](/dec0de) your output have 2 \"j\" character sort than expected output.\n\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This problem is very similar to Task Scheduler, https://leetcode.com/problems/task-scheduler/. If you have done Task Scheduler you should recognize the pattern quickly"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "what if the question is with minimum numbers of swap done .. the !?? can someone give idea ?"
                    }
                ]
            },
            {
                "id": 1969515,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/GaUxskL\">\\n  <img src=\"https://i.imgur.com/GaUxskL.jpg\" title=\"source: imgur.com\" style=\"height: 300px;\" width=\"300px\" />\\n</a>\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@DoraBabukondala](/DoraBabukondala) Lacrimosa \\uD83D\\uDE15"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "knock knock"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I will learn priority queue, but not today."
                    },
                    {
                        "username": "arsalAbbas",
                        "content": "https://leetcode.com/problems/reorganize-string/solutions/3948675/detailed-c-solution-o-n-without-heap-beats-100-in-time/\\n\\nWho said anything about priority queue? ; )"
                    },
                    {
                        "username": "Barney786",
                        "content": "without using priority queue u can solve it too just place the max freq of  char alternatively/gap of 1 in resultant string"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@z3eg](/z3eg) me now.\\n"
                    },
                    {
                        "username": "21bce043",
                        "content": "us moment\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me basically every day lmao"
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"Alternate placing the most common letters. \" Use this hint to know\n If there is some character c with freq(c)>(n+1)/2 then it is impossible"
                    },
                    {
                        "username": "wafsinc",
                        "content": "WHY ARE YOU YELLING."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Sukhwindersingh0007](/Sukhwindersingh0007) If n is odd, use both ends there are  at most (n+1)/2 alternating places. If n is even, there are at most n/2 alternating places.\\nDue to Pigeonhole principle, if some character c with freq(c)>(n+1)/2 , then there must be some place for the adjacent characters with c!"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Whats the intitution?\\n"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "helful \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s easy to realise what we need to do here, alternatively put characters with maximum frequency. The problem lies in implementing this.\\n\\nEven if you get the intuition of using `Heaps`, it\\'s still a tricky one to implement.\\n\\nSo, the trick is to store pair of `{frequency,char}` in a Heap. Then while `Heap.size()>1` , at every iteration, take out the top two elements, append them to the ans string, decrease their frequency by `1` and push them again in the Heap.\\n\\nWhen the loop will break, either the Heap became `empty` or of `1 size.`\\n\\nIf it\\'s empty, return the ans string.\\n\\nif it has `size == 1`, check the remaining frequency of the top/last element, if its `1`, append it and return ans.\\n\\nOtherwise, return `\"\"`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sikora92](/sikora92) so heap will do that automatically, no? that\\'s why we will use that"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@ktnaneri](/ktnaneri) haha, mistakes happen"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Wish I read your comment before reading the solutions..."
                    },
                    {
                        "username": "sikora92",
                        "content": "Very good top. It does not have to be heap, any sorted collection will work. And remember to sort by frequency (current, not initial)."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "seemed easy at first... until it wasn\\'t"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "tricky one\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The approach to solve this problem is to use a priority queue to store the characters based on their frequency. We first count the frequency of each character in the string and store it in a hash map. Then, we create a priority queue and add all the characters from the hash map to it. We use a comparator to order the characters in the priority queue based on their frequency in decreasing order.\n\nThen, we take out two characters from the priority queue and append them to the output string. We keep track of the last character appended to the output string. If the next character in the priority queue is the same as the last character appended to the output string, we take out the next character from the priority queue and append it to the output string. We continue this process until the priority queue is empty or we cannot append any more characters to the output string.\n\nIf we cannot append any more characters to the output string, we return an empty string."
                    },
                    {
                        "username": "dec0de",
                        "content": "Input: \\n\"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\\\\\\\\\\\\\\\\\\n\\nMy output: \\n\"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\\n\\nExpected:\\n\"eweweweweweweweweweweweweweueueueueueueueueueueueueueueuhuhuhuhuhuhshshshshshshshshshshshshshshshshshshshphphphpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcrcrcrcrcrcrcrcrcrcrcrcrmrmrmrmrmrmrmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmgmgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvovovovovovovovovonononononononononbnbnbnbnbnbnbnbnbnbnbnbnbnbnbabaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiatatatatatftftftftftftftftftftftfdfdfdfdfdfdfdfdfdfdfdydydydydyzyzyzyzyzyzyzyzyzyzyzyzyzyzyjyjyjyjkjkjkjkjkjkjkjklklklklklklklklklklklkqkqkqwqwqwqwqwqwqwqwq\"\\n\\nMy output seems correct to me as there are no chars that are same and adajacent.\\nCan anybody point me where did i miss something?\\nThis the last test case"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@its_iterator](/its_iterator) nice , you earned my upvote "
                    },
                    {
                        "username": "jPank1983",
                        "content": "Copy that test case and then run it ( !submit ) then leetcode automatically highlight error "
                    },
                    {
                        "username": "its_iterator",
                        "content": "```\ns = \"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\n\np = \"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\n\na = [0]*26\nb = [0]*26\n\nfor i in range(len(s)):\n  a[ord(s[i])-ord('a')]+=1\n\nfor i in range(len(p)):\n  b[ord(p[i])-ord('a')]+=1\n\nprint(a)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 11, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\nprint(b)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 9, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\n\n```\n[@dec0de](/dec0de) your output have 2 \"j\" character sort than expected output.\n\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This problem is very similar to Task Scheduler, https://leetcode.com/problems/task-scheduler/. If you have done Task Scheduler you should recognize the pattern quickly"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "what if the question is with minimum numbers of swap done .. the !?? can someone give idea ?"
                    }
                ]
            },
            {
                "id": 2026577,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/GaUxskL\">\\n  <img src=\"https://i.imgur.com/GaUxskL.jpg\" title=\"source: imgur.com\" style=\"height: 300px;\" width=\"300px\" />\\n</a>\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@DoraBabukondala](/DoraBabukondala) Lacrimosa \\uD83D\\uDE15"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "knock knock"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I will learn priority queue, but not today."
                    },
                    {
                        "username": "arsalAbbas",
                        "content": "https://leetcode.com/problems/reorganize-string/solutions/3948675/detailed-c-solution-o-n-without-heap-beats-100-in-time/\\n\\nWho said anything about priority queue? ; )"
                    },
                    {
                        "username": "Barney786",
                        "content": "without using priority queue u can solve it too just place the max freq of  char alternatively/gap of 1 in resultant string"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@z3eg](/z3eg) me now.\\n"
                    },
                    {
                        "username": "21bce043",
                        "content": "us moment\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me basically every day lmao"
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"Alternate placing the most common letters. \" Use this hint to know\n If there is some character c with freq(c)>(n+1)/2 then it is impossible"
                    },
                    {
                        "username": "wafsinc",
                        "content": "WHY ARE YOU YELLING."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Sukhwindersingh0007](/Sukhwindersingh0007) If n is odd, use both ends there are  at most (n+1)/2 alternating places. If n is even, there are at most n/2 alternating places.\\nDue to Pigeonhole principle, if some character c with freq(c)>(n+1)/2 , then there must be some place for the adjacent characters with c!"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Whats the intitution?\\n"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "helful \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s easy to realise what we need to do here, alternatively put characters with maximum frequency. The problem lies in implementing this.\\n\\nEven if you get the intuition of using `Heaps`, it\\'s still a tricky one to implement.\\n\\nSo, the trick is to store pair of `{frequency,char}` in a Heap. Then while `Heap.size()>1` , at every iteration, take out the top two elements, append them to the ans string, decrease their frequency by `1` and push them again in the Heap.\\n\\nWhen the loop will break, either the Heap became `empty` or of `1 size.`\\n\\nIf it\\'s empty, return the ans string.\\n\\nif it has `size == 1`, check the remaining frequency of the top/last element, if its `1`, append it and return ans.\\n\\nOtherwise, return `\"\"`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sikora92](/sikora92) so heap will do that automatically, no? that\\'s why we will use that"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@ktnaneri](/ktnaneri) haha, mistakes happen"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Wish I read your comment before reading the solutions..."
                    },
                    {
                        "username": "sikora92",
                        "content": "Very good top. It does not have to be heap, any sorted collection will work. And remember to sort by frequency (current, not initial)."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "seemed easy at first... until it wasn\\'t"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "tricky one\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The approach to solve this problem is to use a priority queue to store the characters based on their frequency. We first count the frequency of each character in the string and store it in a hash map. Then, we create a priority queue and add all the characters from the hash map to it. We use a comparator to order the characters in the priority queue based on their frequency in decreasing order.\n\nThen, we take out two characters from the priority queue and append them to the output string. We keep track of the last character appended to the output string. If the next character in the priority queue is the same as the last character appended to the output string, we take out the next character from the priority queue and append it to the output string. We continue this process until the priority queue is empty or we cannot append any more characters to the output string.\n\nIf we cannot append any more characters to the output string, we return an empty string."
                    },
                    {
                        "username": "dec0de",
                        "content": "Input: \\n\"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\\\\\\\\\\\\\\\\\\n\\nMy output: \\n\"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\\n\\nExpected:\\n\"eweweweweweweweweweweweweweueueueueueueueueueueueueueueuhuhuhuhuhuhshshshshshshshshshshshshshshshshshshshphphphpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcrcrcrcrcrcrcrcrcrcrcrcrmrmrmrmrmrmrmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmgmgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvovovovovovovovovonononononononononbnbnbnbnbnbnbnbnbnbnbnbnbnbnbabaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiatatatatatftftftftftftftftftftftfdfdfdfdfdfdfdfdfdfdfdydydydydyzyzyzyzyzyzyzyzyzyzyzyzyzyzyjyjyjyjkjkjkjkjkjkjkjklklklklklklklklklklklkqkqkqwqwqwqwqwqwqwqwq\"\\n\\nMy output seems correct to me as there are no chars that are same and adajacent.\\nCan anybody point me where did i miss something?\\nThis the last test case"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@its_iterator](/its_iterator) nice , you earned my upvote "
                    },
                    {
                        "username": "jPank1983",
                        "content": "Copy that test case and then run it ( !submit ) then leetcode automatically highlight error "
                    },
                    {
                        "username": "its_iterator",
                        "content": "```\ns = \"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\n\np = \"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\n\na = [0]*26\nb = [0]*26\n\nfor i in range(len(s)):\n  a[ord(s[i])-ord('a')]+=1\n\nfor i in range(len(p)):\n  b[ord(p[i])-ord('a')]+=1\n\nprint(a)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 11, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\nprint(b)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 9, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\n\n```\n[@dec0de](/dec0de) your output have 2 \"j\" character sort than expected output.\n\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This problem is very similar to Task Scheduler, https://leetcode.com/problems/task-scheduler/. If you have done Task Scheduler you should recognize the pattern quickly"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "what if the question is with minimum numbers of swap done .. the !?? can someone give idea ?"
                    }
                ]
            },
            {
                "id": 2026265,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/GaUxskL\">\\n  <img src=\"https://i.imgur.com/GaUxskL.jpg\" title=\"source: imgur.com\" style=\"height: 300px;\" width=\"300px\" />\\n</a>\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@DoraBabukondala](/DoraBabukondala) Lacrimosa \\uD83D\\uDE15"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "knock knock"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I will learn priority queue, but not today."
                    },
                    {
                        "username": "arsalAbbas",
                        "content": "https://leetcode.com/problems/reorganize-string/solutions/3948675/detailed-c-solution-o-n-without-heap-beats-100-in-time/\\n\\nWho said anything about priority queue? ; )"
                    },
                    {
                        "username": "Barney786",
                        "content": "without using priority queue u can solve it too just place the max freq of  char alternatively/gap of 1 in resultant string"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@z3eg](/z3eg) me now.\\n"
                    },
                    {
                        "username": "21bce043",
                        "content": "us moment\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me basically every day lmao"
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"Alternate placing the most common letters. \" Use this hint to know\n If there is some character c with freq(c)>(n+1)/2 then it is impossible"
                    },
                    {
                        "username": "wafsinc",
                        "content": "WHY ARE YOU YELLING."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Sukhwindersingh0007](/Sukhwindersingh0007) If n is odd, use both ends there are  at most (n+1)/2 alternating places. If n is even, there are at most n/2 alternating places.\\nDue to Pigeonhole principle, if some character c with freq(c)>(n+1)/2 , then there must be some place for the adjacent characters with c!"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Whats the intitution?\\n"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "helful \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s easy to realise what we need to do here, alternatively put characters with maximum frequency. The problem lies in implementing this.\\n\\nEven if you get the intuition of using `Heaps`, it\\'s still a tricky one to implement.\\n\\nSo, the trick is to store pair of `{frequency,char}` in a Heap. Then while `Heap.size()>1` , at every iteration, take out the top two elements, append them to the ans string, decrease their frequency by `1` and push them again in the Heap.\\n\\nWhen the loop will break, either the Heap became `empty` or of `1 size.`\\n\\nIf it\\'s empty, return the ans string.\\n\\nif it has `size == 1`, check the remaining frequency of the top/last element, if its `1`, append it and return ans.\\n\\nOtherwise, return `\"\"`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sikora92](/sikora92) so heap will do that automatically, no? that\\'s why we will use that"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@ktnaneri](/ktnaneri) haha, mistakes happen"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Wish I read your comment before reading the solutions..."
                    },
                    {
                        "username": "sikora92",
                        "content": "Very good top. It does not have to be heap, any sorted collection will work. And remember to sort by frequency (current, not initial)."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "seemed easy at first... until it wasn\\'t"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "tricky one\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The approach to solve this problem is to use a priority queue to store the characters based on their frequency. We first count the frequency of each character in the string and store it in a hash map. Then, we create a priority queue and add all the characters from the hash map to it. We use a comparator to order the characters in the priority queue based on their frequency in decreasing order.\n\nThen, we take out two characters from the priority queue and append them to the output string. We keep track of the last character appended to the output string. If the next character in the priority queue is the same as the last character appended to the output string, we take out the next character from the priority queue and append it to the output string. We continue this process until the priority queue is empty or we cannot append any more characters to the output string.\n\nIf we cannot append any more characters to the output string, we return an empty string."
                    },
                    {
                        "username": "dec0de",
                        "content": "Input: \\n\"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\\\\\\\\\\\\\\\\\\n\\nMy output: \\n\"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\\n\\nExpected:\\n\"eweweweweweweweweweweweweweueueueueueueueueueueueueueueuhuhuhuhuhuhshshshshshshshshshshshshshshshshshshshphphphpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcrcrcrcrcrcrcrcrcrcrcrcrmrmrmrmrmrmrmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmgmgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvovovovovovovovovonononononononononbnbnbnbnbnbnbnbnbnbnbnbnbnbnbabaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiatatatatatftftftftftftftftftftftfdfdfdfdfdfdfdfdfdfdfdydydydydyzyzyzyzyzyzyzyzyzyzyzyzyzyzyjyjyjyjkjkjkjkjkjkjkjklklklklklklklklklklklkqkqkqwqwqwqwqwqwqwqwq\"\\n\\nMy output seems correct to me as there are no chars that are same and adajacent.\\nCan anybody point me where did i miss something?\\nThis the last test case"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@its_iterator](/its_iterator) nice , you earned my upvote "
                    },
                    {
                        "username": "jPank1983",
                        "content": "Copy that test case and then run it ( !submit ) then leetcode automatically highlight error "
                    },
                    {
                        "username": "its_iterator",
                        "content": "```\ns = \"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\n\np = \"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\n\na = [0]*26\nb = [0]*26\n\nfor i in range(len(s)):\n  a[ord(s[i])-ord('a')]+=1\n\nfor i in range(len(p)):\n  b[ord(p[i])-ord('a')]+=1\n\nprint(a)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 11, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\nprint(b)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 9, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\n\n```\n[@dec0de](/dec0de) your output have 2 \"j\" character sort than expected output.\n\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This problem is very similar to Task Scheduler, https://leetcode.com/problems/task-scheduler/. If you have done Task Scheduler you should recognize the pattern quickly"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "what if the question is with minimum numbers of swap done .. the !?? can someone give idea ?"
                    }
                ]
            },
            {
                "id": 2026236,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/GaUxskL\">\\n  <img src=\"https://i.imgur.com/GaUxskL.jpg\" title=\"source: imgur.com\" style=\"height: 300px;\" width=\"300px\" />\\n</a>\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@DoraBabukondala](/DoraBabukondala) Lacrimosa \\uD83D\\uDE15"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "knock knock"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I will learn priority queue, but not today."
                    },
                    {
                        "username": "arsalAbbas",
                        "content": "https://leetcode.com/problems/reorganize-string/solutions/3948675/detailed-c-solution-o-n-without-heap-beats-100-in-time/\\n\\nWho said anything about priority queue? ; )"
                    },
                    {
                        "username": "Barney786",
                        "content": "without using priority queue u can solve it too just place the max freq of  char alternatively/gap of 1 in resultant string"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@z3eg](/z3eg) me now.\\n"
                    },
                    {
                        "username": "21bce043",
                        "content": "us moment\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me basically every day lmao"
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"Alternate placing the most common letters. \" Use this hint to know\n If there is some character c with freq(c)>(n+1)/2 then it is impossible"
                    },
                    {
                        "username": "wafsinc",
                        "content": "WHY ARE YOU YELLING."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Sukhwindersingh0007](/Sukhwindersingh0007) If n is odd, use both ends there are  at most (n+1)/2 alternating places. If n is even, there are at most n/2 alternating places.\\nDue to Pigeonhole principle, if some character c with freq(c)>(n+1)/2 , then there must be some place for the adjacent characters with c!"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Whats the intitution?\\n"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "helful \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s easy to realise what we need to do here, alternatively put characters with maximum frequency. The problem lies in implementing this.\\n\\nEven if you get the intuition of using `Heaps`, it\\'s still a tricky one to implement.\\n\\nSo, the trick is to store pair of `{frequency,char}` in a Heap. Then while `Heap.size()>1` , at every iteration, take out the top two elements, append them to the ans string, decrease their frequency by `1` and push them again in the Heap.\\n\\nWhen the loop will break, either the Heap became `empty` or of `1 size.`\\n\\nIf it\\'s empty, return the ans string.\\n\\nif it has `size == 1`, check the remaining frequency of the top/last element, if its `1`, append it and return ans.\\n\\nOtherwise, return `\"\"`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sikora92](/sikora92) so heap will do that automatically, no? that\\'s why we will use that"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@ktnaneri](/ktnaneri) haha, mistakes happen"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Wish I read your comment before reading the solutions..."
                    },
                    {
                        "username": "sikora92",
                        "content": "Very good top. It does not have to be heap, any sorted collection will work. And remember to sort by frequency (current, not initial)."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "seemed easy at first... until it wasn\\'t"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "tricky one\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The approach to solve this problem is to use a priority queue to store the characters based on their frequency. We first count the frequency of each character in the string and store it in a hash map. Then, we create a priority queue and add all the characters from the hash map to it. We use a comparator to order the characters in the priority queue based on their frequency in decreasing order.\n\nThen, we take out two characters from the priority queue and append them to the output string. We keep track of the last character appended to the output string. If the next character in the priority queue is the same as the last character appended to the output string, we take out the next character from the priority queue and append it to the output string. We continue this process until the priority queue is empty or we cannot append any more characters to the output string.\n\nIf we cannot append any more characters to the output string, we return an empty string."
                    },
                    {
                        "username": "dec0de",
                        "content": "Input: \\n\"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\\\\\\\\\\\\\\\\\\n\\nMy output: \\n\"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\\n\\nExpected:\\n\"eweweweweweweweweweweweweweueueueueueueueueueueueueueueuhuhuhuhuhuhshshshshshshshshshshshshshshshshshshshphphphpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcrcrcrcrcrcrcrcrcrcrcrcrmrmrmrmrmrmrmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmgmgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvovovovovovovovovonononononononononbnbnbnbnbnbnbnbnbnbnbnbnbnbnbabaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiatatatatatftftftftftftftftftftftfdfdfdfdfdfdfdfdfdfdfdydydydydyzyzyzyzyzyzyzyzyzyzyzyzyzyzyjyjyjyjkjkjkjkjkjkjkjklklklklklklklklklklklkqkqkqwqwqwqwqwqwqwqwq\"\\n\\nMy output seems correct to me as there are no chars that are same and adajacent.\\nCan anybody point me where did i miss something?\\nThis the last test case"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@its_iterator](/its_iterator) nice , you earned my upvote "
                    },
                    {
                        "username": "jPank1983",
                        "content": "Copy that test case and then run it ( !submit ) then leetcode automatically highlight error "
                    },
                    {
                        "username": "its_iterator",
                        "content": "```\ns = \"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\n\np = \"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\n\na = [0]*26\nb = [0]*26\n\nfor i in range(len(s)):\n  a[ord(s[i])-ord('a')]+=1\n\nfor i in range(len(p)):\n  b[ord(p[i])-ord('a')]+=1\n\nprint(a)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 11, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\nprint(b)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 9, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\n\n```\n[@dec0de](/dec0de) your output have 2 \"j\" character sort than expected output.\n\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This problem is very similar to Task Scheduler, https://leetcode.com/problems/task-scheduler/. If you have done Task Scheduler you should recognize the pattern quickly"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "what if the question is with minimum numbers of swap done .. the !?? can someone give idea ?"
                    }
                ]
            },
            {
                "id": 2026331,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/GaUxskL\">\\n  <img src=\"https://i.imgur.com/GaUxskL.jpg\" title=\"source: imgur.com\" style=\"height: 300px;\" width=\"300px\" />\\n</a>\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@DoraBabukondala](/DoraBabukondala) Lacrimosa \\uD83D\\uDE15"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "knock knock"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I will learn priority queue, but not today."
                    },
                    {
                        "username": "arsalAbbas",
                        "content": "https://leetcode.com/problems/reorganize-string/solutions/3948675/detailed-c-solution-o-n-without-heap-beats-100-in-time/\\n\\nWho said anything about priority queue? ; )"
                    },
                    {
                        "username": "Barney786",
                        "content": "without using priority queue u can solve it too just place the max freq of  char alternatively/gap of 1 in resultant string"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@z3eg](/z3eg) me now.\\n"
                    },
                    {
                        "username": "21bce043",
                        "content": "us moment\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me basically every day lmao"
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"Alternate placing the most common letters. \" Use this hint to know\n If there is some character c with freq(c)>(n+1)/2 then it is impossible"
                    },
                    {
                        "username": "wafsinc",
                        "content": "WHY ARE YOU YELLING."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Sukhwindersingh0007](/Sukhwindersingh0007) If n is odd, use both ends there are  at most (n+1)/2 alternating places. If n is even, there are at most n/2 alternating places.\\nDue to Pigeonhole principle, if some character c with freq(c)>(n+1)/2 , then there must be some place for the adjacent characters with c!"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Whats the intitution?\\n"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "helful \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s easy to realise what we need to do here, alternatively put characters with maximum frequency. The problem lies in implementing this.\\n\\nEven if you get the intuition of using `Heaps`, it\\'s still a tricky one to implement.\\n\\nSo, the trick is to store pair of `{frequency,char}` in a Heap. Then while `Heap.size()>1` , at every iteration, take out the top two elements, append them to the ans string, decrease their frequency by `1` and push them again in the Heap.\\n\\nWhen the loop will break, either the Heap became `empty` or of `1 size.`\\n\\nIf it\\'s empty, return the ans string.\\n\\nif it has `size == 1`, check the remaining frequency of the top/last element, if its `1`, append it and return ans.\\n\\nOtherwise, return `\"\"`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sikora92](/sikora92) so heap will do that automatically, no? that\\'s why we will use that"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@ktnaneri](/ktnaneri) haha, mistakes happen"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Wish I read your comment before reading the solutions..."
                    },
                    {
                        "username": "sikora92",
                        "content": "Very good top. It does not have to be heap, any sorted collection will work. And remember to sort by frequency (current, not initial)."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "seemed easy at first... until it wasn\\'t"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "tricky one\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The approach to solve this problem is to use a priority queue to store the characters based on their frequency. We first count the frequency of each character in the string and store it in a hash map. Then, we create a priority queue and add all the characters from the hash map to it. We use a comparator to order the characters in the priority queue based on their frequency in decreasing order.\n\nThen, we take out two characters from the priority queue and append them to the output string. We keep track of the last character appended to the output string. If the next character in the priority queue is the same as the last character appended to the output string, we take out the next character from the priority queue and append it to the output string. We continue this process until the priority queue is empty or we cannot append any more characters to the output string.\n\nIf we cannot append any more characters to the output string, we return an empty string."
                    },
                    {
                        "username": "dec0de",
                        "content": "Input: \\n\"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\\\\\\\\\\\\\\\\\\n\\nMy output: \\n\"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\\n\\nExpected:\\n\"eweweweweweweweweweweweweweueueueueueueueueueueueueueueuhuhuhuhuhuhshshshshshshshshshshshshshshshshshshshphphphpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcrcrcrcrcrcrcrcrcrcrcrcrmrmrmrmrmrmrmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmgmgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvovovovovovovovovonononononononononbnbnbnbnbnbnbnbnbnbnbnbnbnbnbabaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiatatatatatftftftftftftftftftftftfdfdfdfdfdfdfdfdfdfdfdydydydydyzyzyzyzyzyzyzyzyzyzyzyzyzyzyjyjyjyjkjkjkjkjkjkjkjklklklklklklklklklklklkqkqkqwqwqwqwqwqwqwqwq\"\\n\\nMy output seems correct to me as there are no chars that are same and adajacent.\\nCan anybody point me where did i miss something?\\nThis the last test case"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@its_iterator](/its_iterator) nice , you earned my upvote "
                    },
                    {
                        "username": "jPank1983",
                        "content": "Copy that test case and then run it ( !submit ) then leetcode automatically highlight error "
                    },
                    {
                        "username": "its_iterator",
                        "content": "```\ns = \"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\n\np = \"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\n\na = [0]*26\nb = [0]*26\n\nfor i in range(len(s)):\n  a[ord(s[i])-ord('a')]+=1\n\nfor i in range(len(p)):\n  b[ord(p[i])-ord('a')]+=1\n\nprint(a)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 11, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\nprint(b)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 9, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\n\n```\n[@dec0de](/dec0de) your output have 2 \"j\" character sort than expected output.\n\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This problem is very similar to Task Scheduler, https://leetcode.com/problems/task-scheduler/. If you have done Task Scheduler you should recognize the pattern quickly"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "what if the question is with minimum numbers of swap done .. the !?? can someone give idea ?"
                    }
                ]
            },
            {
                "id": 2026244,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/GaUxskL\">\\n  <img src=\"https://i.imgur.com/GaUxskL.jpg\" title=\"source: imgur.com\" style=\"height: 300px;\" width=\"300px\" />\\n</a>\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@DoraBabukondala](/DoraBabukondala) Lacrimosa \\uD83D\\uDE15"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "knock knock"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I will learn priority queue, but not today."
                    },
                    {
                        "username": "arsalAbbas",
                        "content": "https://leetcode.com/problems/reorganize-string/solutions/3948675/detailed-c-solution-o-n-without-heap-beats-100-in-time/\\n\\nWho said anything about priority queue? ; )"
                    },
                    {
                        "username": "Barney786",
                        "content": "without using priority queue u can solve it too just place the max freq of  char alternatively/gap of 1 in resultant string"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@z3eg](/z3eg) me now.\\n"
                    },
                    {
                        "username": "21bce043",
                        "content": "us moment\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me basically every day lmao"
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"Alternate placing the most common letters. \" Use this hint to know\n If there is some character c with freq(c)>(n+1)/2 then it is impossible"
                    },
                    {
                        "username": "wafsinc",
                        "content": "WHY ARE YOU YELLING."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Sukhwindersingh0007](/Sukhwindersingh0007) If n is odd, use both ends there are  at most (n+1)/2 alternating places. If n is even, there are at most n/2 alternating places.\\nDue to Pigeonhole principle, if some character c with freq(c)>(n+1)/2 , then there must be some place for the adjacent characters with c!"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Whats the intitution?\\n"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "helful \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s easy to realise what we need to do here, alternatively put characters with maximum frequency. The problem lies in implementing this.\\n\\nEven if you get the intuition of using `Heaps`, it\\'s still a tricky one to implement.\\n\\nSo, the trick is to store pair of `{frequency,char}` in a Heap. Then while `Heap.size()>1` , at every iteration, take out the top two elements, append them to the ans string, decrease their frequency by `1` and push them again in the Heap.\\n\\nWhen the loop will break, either the Heap became `empty` or of `1 size.`\\n\\nIf it\\'s empty, return the ans string.\\n\\nif it has `size == 1`, check the remaining frequency of the top/last element, if its `1`, append it and return ans.\\n\\nOtherwise, return `\"\"`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sikora92](/sikora92) so heap will do that automatically, no? that\\'s why we will use that"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@ktnaneri](/ktnaneri) haha, mistakes happen"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Wish I read your comment before reading the solutions..."
                    },
                    {
                        "username": "sikora92",
                        "content": "Very good top. It does not have to be heap, any sorted collection will work. And remember to sort by frequency (current, not initial)."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "seemed easy at first... until it wasn\\'t"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "tricky one\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The approach to solve this problem is to use a priority queue to store the characters based on their frequency. We first count the frequency of each character in the string and store it in a hash map. Then, we create a priority queue and add all the characters from the hash map to it. We use a comparator to order the characters in the priority queue based on their frequency in decreasing order.\n\nThen, we take out two characters from the priority queue and append them to the output string. We keep track of the last character appended to the output string. If the next character in the priority queue is the same as the last character appended to the output string, we take out the next character from the priority queue and append it to the output string. We continue this process until the priority queue is empty or we cannot append any more characters to the output string.\n\nIf we cannot append any more characters to the output string, we return an empty string."
                    },
                    {
                        "username": "dec0de",
                        "content": "Input: \\n\"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\\\\\\\\\\\\\\\\\\n\\nMy output: \\n\"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\\n\\nExpected:\\n\"eweweweweweweweweweweweweweueueueueueueueueueueueueueueuhuhuhuhuhuhshshshshshshshshshshshshshshshshshshshphphphpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcrcrcrcrcrcrcrcrcrcrcrcrmrmrmrmrmrmrmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmgmgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvovovovovovovovovonononononononononbnbnbnbnbnbnbnbnbnbnbnbnbnbnbabaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiatatatatatftftftftftftftftftftftfdfdfdfdfdfdfdfdfdfdfdydydydydyzyzyzyzyzyzyzyzyzyzyzyzyzyzyjyjyjyjkjkjkjkjkjkjkjklklklklklklklklklklklkqkqkqwqwqwqwqwqwqwqwq\"\\n\\nMy output seems correct to me as there are no chars that are same and adajacent.\\nCan anybody point me where did i miss something?\\nThis the last test case"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@its_iterator](/its_iterator) nice , you earned my upvote "
                    },
                    {
                        "username": "jPank1983",
                        "content": "Copy that test case and then run it ( !submit ) then leetcode automatically highlight error "
                    },
                    {
                        "username": "its_iterator",
                        "content": "```\ns = \"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\n\np = \"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\n\na = [0]*26\nb = [0]*26\n\nfor i in range(len(s)):\n  a[ord(s[i])-ord('a')]+=1\n\nfor i in range(len(p)):\n  b[ord(p[i])-ord('a')]+=1\n\nprint(a)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 11, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\nprint(b)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 9, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\n\n```\n[@dec0de](/dec0de) your output have 2 \"j\" character sort than expected output.\n\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This problem is very similar to Task Scheduler, https://leetcode.com/problems/task-scheduler/. If you have done Task Scheduler you should recognize the pattern quickly"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "what if the question is with minimum numbers of swap done .. the !?? can someone give idea ?"
                    }
                ]
            },
            {
                "id": 1739742,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/GaUxskL\">\\n  <img src=\"https://i.imgur.com/GaUxskL.jpg\" title=\"source: imgur.com\" style=\"height: 300px;\" width=\"300px\" />\\n</a>\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@DoraBabukondala](/DoraBabukondala) Lacrimosa \\uD83D\\uDE15"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "knock knock"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I will learn priority queue, but not today."
                    },
                    {
                        "username": "arsalAbbas",
                        "content": "https://leetcode.com/problems/reorganize-string/solutions/3948675/detailed-c-solution-o-n-without-heap-beats-100-in-time/\\n\\nWho said anything about priority queue? ; )"
                    },
                    {
                        "username": "Barney786",
                        "content": "without using priority queue u can solve it too just place the max freq of  char alternatively/gap of 1 in resultant string"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@z3eg](/z3eg) me now.\\n"
                    },
                    {
                        "username": "21bce043",
                        "content": "us moment\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me basically every day lmao"
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"Alternate placing the most common letters. \" Use this hint to know\n If there is some character c with freq(c)>(n+1)/2 then it is impossible"
                    },
                    {
                        "username": "wafsinc",
                        "content": "WHY ARE YOU YELLING."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Sukhwindersingh0007](/Sukhwindersingh0007) If n is odd, use both ends there are  at most (n+1)/2 alternating places. If n is even, there are at most n/2 alternating places.\\nDue to Pigeonhole principle, if some character c with freq(c)>(n+1)/2 , then there must be some place for the adjacent characters with c!"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Whats the intitution?\\n"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "helful \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s easy to realise what we need to do here, alternatively put characters with maximum frequency. The problem lies in implementing this.\\n\\nEven if you get the intuition of using `Heaps`, it\\'s still a tricky one to implement.\\n\\nSo, the trick is to store pair of `{frequency,char}` in a Heap. Then while `Heap.size()>1` , at every iteration, take out the top two elements, append them to the ans string, decrease their frequency by `1` and push them again in the Heap.\\n\\nWhen the loop will break, either the Heap became `empty` or of `1 size.`\\n\\nIf it\\'s empty, return the ans string.\\n\\nif it has `size == 1`, check the remaining frequency of the top/last element, if its `1`, append it and return ans.\\n\\nOtherwise, return `\"\"`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sikora92](/sikora92) so heap will do that automatically, no? that\\'s why we will use that"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@ktnaneri](/ktnaneri) haha, mistakes happen"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Wish I read your comment before reading the solutions..."
                    },
                    {
                        "username": "sikora92",
                        "content": "Very good top. It does not have to be heap, any sorted collection will work. And remember to sort by frequency (current, not initial)."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "seemed easy at first... until it wasn\\'t"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "tricky one\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The approach to solve this problem is to use a priority queue to store the characters based on their frequency. We first count the frequency of each character in the string and store it in a hash map. Then, we create a priority queue and add all the characters from the hash map to it. We use a comparator to order the characters in the priority queue based on their frequency in decreasing order.\n\nThen, we take out two characters from the priority queue and append them to the output string. We keep track of the last character appended to the output string. If the next character in the priority queue is the same as the last character appended to the output string, we take out the next character from the priority queue and append it to the output string. We continue this process until the priority queue is empty or we cannot append any more characters to the output string.\n\nIf we cannot append any more characters to the output string, we return an empty string."
                    },
                    {
                        "username": "dec0de",
                        "content": "Input: \\n\"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\\\\\\\\\\\\\\\\\\n\\nMy output: \\n\"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\\n\\nExpected:\\n\"eweweweweweweweweweweweweweueueueueueueueueueueueueueueuhuhuhuhuhuhshshshshshshshshshshshshshshshshshshshphphphpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcrcrcrcrcrcrcrcrcrcrcrcrmrmrmrmrmrmrmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmgmgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvovovovovovovovovonononononononononbnbnbnbnbnbnbnbnbnbnbnbnbnbnbabaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiatatatatatftftftftftftftftftftftfdfdfdfdfdfdfdfdfdfdfdydydydydyzyzyzyzyzyzyzyzyzyzyzyzyzyzyjyjyjyjkjkjkjkjkjkjkjklklklklklklklklklklklkqkqkqwqwqwqwqwqwqwqwq\"\\n\\nMy output seems correct to me as there are no chars that are same and adajacent.\\nCan anybody point me where did i miss something?\\nThis the last test case"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@its_iterator](/its_iterator) nice , you earned my upvote "
                    },
                    {
                        "username": "jPank1983",
                        "content": "Copy that test case and then run it ( !submit ) then leetcode automatically highlight error "
                    },
                    {
                        "username": "its_iterator",
                        "content": "```\ns = \"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\n\np = \"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\n\na = [0]*26\nb = [0]*26\n\nfor i in range(len(s)):\n  a[ord(s[i])-ord('a')]+=1\n\nfor i in range(len(p)):\n  b[ord(p[i])-ord('a')]+=1\n\nprint(a)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 11, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\nprint(b)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 9, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\n\n```\n[@dec0de](/dec0de) your output have 2 \"j\" character sort than expected output.\n\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This problem is very similar to Task Scheduler, https://leetcode.com/problems/task-scheduler/. If you have done Task Scheduler you should recognize the pattern quickly"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "what if the question is with minimum numbers of swap done .. the !?? can someone give idea ?"
                    }
                ]
            },
            {
                "id": 1812318,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/GaUxskL\">\\n  <img src=\"https://i.imgur.com/GaUxskL.jpg\" title=\"source: imgur.com\" style=\"height: 300px;\" width=\"300px\" />\\n</a>\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@DoraBabukondala](/DoraBabukondala) Lacrimosa \\uD83D\\uDE15"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "knock knock"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I will learn priority queue, but not today."
                    },
                    {
                        "username": "arsalAbbas",
                        "content": "https://leetcode.com/problems/reorganize-string/solutions/3948675/detailed-c-solution-o-n-without-heap-beats-100-in-time/\\n\\nWho said anything about priority queue? ; )"
                    },
                    {
                        "username": "Barney786",
                        "content": "without using priority queue u can solve it too just place the max freq of  char alternatively/gap of 1 in resultant string"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@z3eg](/z3eg) me now.\\n"
                    },
                    {
                        "username": "21bce043",
                        "content": "us moment\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me basically every day lmao"
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"Alternate placing the most common letters. \" Use this hint to know\n If there is some character c with freq(c)>(n+1)/2 then it is impossible"
                    },
                    {
                        "username": "wafsinc",
                        "content": "WHY ARE YOU YELLING."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Sukhwindersingh0007](/Sukhwindersingh0007) If n is odd, use both ends there are  at most (n+1)/2 alternating places. If n is even, there are at most n/2 alternating places.\\nDue to Pigeonhole principle, if some character c with freq(c)>(n+1)/2 , then there must be some place for the adjacent characters with c!"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Whats the intitution?\\n"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "helful \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s easy to realise what we need to do here, alternatively put characters with maximum frequency. The problem lies in implementing this.\\n\\nEven if you get the intuition of using `Heaps`, it\\'s still a tricky one to implement.\\n\\nSo, the trick is to store pair of `{frequency,char}` in a Heap. Then while `Heap.size()>1` , at every iteration, take out the top two elements, append them to the ans string, decrease their frequency by `1` and push them again in the Heap.\\n\\nWhen the loop will break, either the Heap became `empty` or of `1 size.`\\n\\nIf it\\'s empty, return the ans string.\\n\\nif it has `size == 1`, check the remaining frequency of the top/last element, if its `1`, append it and return ans.\\n\\nOtherwise, return `\"\"`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sikora92](/sikora92) so heap will do that automatically, no? that\\'s why we will use that"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@ktnaneri](/ktnaneri) haha, mistakes happen"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Wish I read your comment before reading the solutions..."
                    },
                    {
                        "username": "sikora92",
                        "content": "Very good top. It does not have to be heap, any sorted collection will work. And remember to sort by frequency (current, not initial)."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "seemed easy at first... until it wasn\\'t"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "tricky one\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The approach to solve this problem is to use a priority queue to store the characters based on their frequency. We first count the frequency of each character in the string and store it in a hash map. Then, we create a priority queue and add all the characters from the hash map to it. We use a comparator to order the characters in the priority queue based on their frequency in decreasing order.\n\nThen, we take out two characters from the priority queue and append them to the output string. We keep track of the last character appended to the output string. If the next character in the priority queue is the same as the last character appended to the output string, we take out the next character from the priority queue and append it to the output string. We continue this process until the priority queue is empty or we cannot append any more characters to the output string.\n\nIf we cannot append any more characters to the output string, we return an empty string."
                    },
                    {
                        "username": "dec0de",
                        "content": "Input: \\n\"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\\\\\\\\\\\\\\\\\\n\\nMy output: \\n\"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\\n\\nExpected:\\n\"eweweweweweweweweweweweweweueueueueueueueueueueueueueueuhuhuhuhuhuhshshshshshshshshshshshshshshshshshshshphphphpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcrcrcrcrcrcrcrcrcrcrcrcrmrmrmrmrmrmrmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmgmgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvovovovovovovovovonononononononononbnbnbnbnbnbnbnbnbnbnbnbnbnbnbabaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiatatatatatftftftftftftftftftftftfdfdfdfdfdfdfdfdfdfdfdydydydydyzyzyzyzyzyzyzyzyzyzyzyzyzyzyjyjyjyjkjkjkjkjkjkjkjklklklklklklklklklklklkqkqkqwqwqwqwqwqwqwqwq\"\\n\\nMy output seems correct to me as there are no chars that are same and adajacent.\\nCan anybody point me where did i miss something?\\nThis the last test case"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@its_iterator](/its_iterator) nice , you earned my upvote "
                    },
                    {
                        "username": "jPank1983",
                        "content": "Copy that test case and then run it ( !submit ) then leetcode automatically highlight error "
                    },
                    {
                        "username": "its_iterator",
                        "content": "```\ns = \"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\n\np = \"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\n\na = [0]*26\nb = [0]*26\n\nfor i in range(len(s)):\n  a[ord(s[i])-ord('a')]+=1\n\nfor i in range(len(p)):\n  b[ord(p[i])-ord('a')]+=1\n\nprint(a)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 11, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\nprint(b)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 9, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\n\n```\n[@dec0de](/dec0de) your output have 2 \"j\" character sort than expected output.\n\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This problem is very similar to Task Scheduler, https://leetcode.com/problems/task-scheduler/. If you have done Task Scheduler you should recognize the pattern quickly"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "what if the question is with minimum numbers of swap done .. the !?? can someone give idea ?"
                    }
                ]
            },
            {
                "id": 1572502,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/GaUxskL\">\\n  <img src=\"https://i.imgur.com/GaUxskL.jpg\" title=\"source: imgur.com\" style=\"height: 300px;\" width=\"300px\" />\\n</a>\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@DoraBabukondala](/DoraBabukondala) Lacrimosa \\uD83D\\uDE15"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "knock knock"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I will learn priority queue, but not today."
                    },
                    {
                        "username": "arsalAbbas",
                        "content": "https://leetcode.com/problems/reorganize-string/solutions/3948675/detailed-c-solution-o-n-without-heap-beats-100-in-time/\\n\\nWho said anything about priority queue? ; )"
                    },
                    {
                        "username": "Barney786",
                        "content": "without using priority queue u can solve it too just place the max freq of  char alternatively/gap of 1 in resultant string"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@z3eg](/z3eg) me now.\\n"
                    },
                    {
                        "username": "21bce043",
                        "content": "us moment\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me basically every day lmao"
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"Alternate placing the most common letters. \" Use this hint to know\n If there is some character c with freq(c)>(n+1)/2 then it is impossible"
                    },
                    {
                        "username": "wafsinc",
                        "content": "WHY ARE YOU YELLING."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Sukhwindersingh0007](/Sukhwindersingh0007) If n is odd, use both ends there are  at most (n+1)/2 alternating places. If n is even, there are at most n/2 alternating places.\\nDue to Pigeonhole principle, if some character c with freq(c)>(n+1)/2 , then there must be some place for the adjacent characters with c!"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Whats the intitution?\\n"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "helful \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s easy to realise what we need to do here, alternatively put characters with maximum frequency. The problem lies in implementing this.\\n\\nEven if you get the intuition of using `Heaps`, it\\'s still a tricky one to implement.\\n\\nSo, the trick is to store pair of `{frequency,char}` in a Heap. Then while `Heap.size()>1` , at every iteration, take out the top two elements, append them to the ans string, decrease their frequency by `1` and push them again in the Heap.\\n\\nWhen the loop will break, either the Heap became `empty` or of `1 size.`\\n\\nIf it\\'s empty, return the ans string.\\n\\nif it has `size == 1`, check the remaining frequency of the top/last element, if its `1`, append it and return ans.\\n\\nOtherwise, return `\"\"`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sikora92](/sikora92) so heap will do that automatically, no? that\\'s why we will use that"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@ktnaneri](/ktnaneri) haha, mistakes happen"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Wish I read your comment before reading the solutions..."
                    },
                    {
                        "username": "sikora92",
                        "content": "Very good top. It does not have to be heap, any sorted collection will work. And remember to sort by frequency (current, not initial)."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "seemed easy at first... until it wasn\\'t"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "tricky one\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The approach to solve this problem is to use a priority queue to store the characters based on their frequency. We first count the frequency of each character in the string and store it in a hash map. Then, we create a priority queue and add all the characters from the hash map to it. We use a comparator to order the characters in the priority queue based on their frequency in decreasing order.\n\nThen, we take out two characters from the priority queue and append them to the output string. We keep track of the last character appended to the output string. If the next character in the priority queue is the same as the last character appended to the output string, we take out the next character from the priority queue and append it to the output string. We continue this process until the priority queue is empty or we cannot append any more characters to the output string.\n\nIf we cannot append any more characters to the output string, we return an empty string."
                    },
                    {
                        "username": "dec0de",
                        "content": "Input: \\n\"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\\\\\\\\\\\\\\\\\\n\\nMy output: \\n\"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\\n\\nExpected:\\n\"eweweweweweweweweweweweweweueueueueueueueueueueueueueueuhuhuhuhuhuhshshshshshshshshshshshshshshshshshshshphphphpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcrcrcrcrcrcrcrcrcrcrcrcrmrmrmrmrmrmrmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmgmgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvovovovovovovovovonononononononononbnbnbnbnbnbnbnbnbnbnbnbnbnbnbabaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiatatatatatftftftftftftftftftftftfdfdfdfdfdfdfdfdfdfdfdydydydydyzyzyzyzyzyzyzyzyzyzyzyzyzyzyjyjyjyjkjkjkjkjkjkjkjklklklklklklklklklklklkqkqkqwqwqwqwqwqwqwqwq\"\\n\\nMy output seems correct to me as there are no chars that are same and adajacent.\\nCan anybody point me where did i miss something?\\nThis the last test case"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@its_iterator](/its_iterator) nice , you earned my upvote "
                    },
                    {
                        "username": "jPank1983",
                        "content": "Copy that test case and then run it ( !submit ) then leetcode automatically highlight error "
                    },
                    {
                        "username": "its_iterator",
                        "content": "```\ns = \"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\n\np = \"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\n\na = [0]*26\nb = [0]*26\n\nfor i in range(len(s)):\n  a[ord(s[i])-ord('a')]+=1\n\nfor i in range(len(p)):\n  b[ord(p[i])-ord('a')]+=1\n\nprint(a)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 11, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\nprint(b)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 9, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\n\n```\n[@dec0de](/dec0de) your output have 2 \"j\" character sort than expected output.\n\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This problem is very similar to Task Scheduler, https://leetcode.com/problems/task-scheduler/. If you have done Task Scheduler you should recognize the pattern quickly"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "what if the question is with minimum numbers of swap done .. the !?? can someone give idea ?"
                    }
                ]
            },
            {
                "id": 2026317,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/GaUxskL\">\\n  <img src=\"https://i.imgur.com/GaUxskL.jpg\" title=\"source: imgur.com\" style=\"height: 300px;\" width=\"300px\" />\\n</a>\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@DoraBabukondala](/DoraBabukondala) Lacrimosa \\uD83D\\uDE15"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "knock knock"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I will learn priority queue, but not today."
                    },
                    {
                        "username": "arsalAbbas",
                        "content": "https://leetcode.com/problems/reorganize-string/solutions/3948675/detailed-c-solution-o-n-without-heap-beats-100-in-time/\\n\\nWho said anything about priority queue? ; )"
                    },
                    {
                        "username": "Barney786",
                        "content": "without using priority queue u can solve it too just place the max freq of  char alternatively/gap of 1 in resultant string"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@z3eg](/z3eg) me now.\\n"
                    },
                    {
                        "username": "21bce043",
                        "content": "us moment\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me basically every day lmao"
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"Alternate placing the most common letters. \" Use this hint to know\n If there is some character c with freq(c)>(n+1)/2 then it is impossible"
                    },
                    {
                        "username": "wafsinc",
                        "content": "WHY ARE YOU YELLING."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Sukhwindersingh0007](/Sukhwindersingh0007) If n is odd, use both ends there are  at most (n+1)/2 alternating places. If n is even, there are at most n/2 alternating places.\\nDue to Pigeonhole principle, if some character c with freq(c)>(n+1)/2 , then there must be some place for the adjacent characters with c!"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Whats the intitution?\\n"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "helful \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s easy to realise what we need to do here, alternatively put characters with maximum frequency. The problem lies in implementing this.\\n\\nEven if you get the intuition of using `Heaps`, it\\'s still a tricky one to implement.\\n\\nSo, the trick is to store pair of `{frequency,char}` in a Heap. Then while `Heap.size()>1` , at every iteration, take out the top two elements, append them to the ans string, decrease their frequency by `1` and push them again in the Heap.\\n\\nWhen the loop will break, either the Heap became `empty` or of `1 size.`\\n\\nIf it\\'s empty, return the ans string.\\n\\nif it has `size == 1`, check the remaining frequency of the top/last element, if its `1`, append it and return ans.\\n\\nOtherwise, return `\"\"`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sikora92](/sikora92) so heap will do that automatically, no? that\\'s why we will use that"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@ktnaneri](/ktnaneri) haha, mistakes happen"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Wish I read your comment before reading the solutions..."
                    },
                    {
                        "username": "sikora92",
                        "content": "Very good top. It does not have to be heap, any sorted collection will work. And remember to sort by frequency (current, not initial)."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "seemed easy at first... until it wasn\\'t"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "tricky one\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The approach to solve this problem is to use a priority queue to store the characters based on their frequency. We first count the frequency of each character in the string and store it in a hash map. Then, we create a priority queue and add all the characters from the hash map to it. We use a comparator to order the characters in the priority queue based on their frequency in decreasing order.\n\nThen, we take out two characters from the priority queue and append them to the output string. We keep track of the last character appended to the output string. If the next character in the priority queue is the same as the last character appended to the output string, we take out the next character from the priority queue and append it to the output string. We continue this process until the priority queue is empty or we cannot append any more characters to the output string.\n\nIf we cannot append any more characters to the output string, we return an empty string."
                    },
                    {
                        "username": "dec0de",
                        "content": "Input: \\n\"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\\\\\\\\\\\\\\\\\\n\\nMy output: \\n\"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\\n\\nExpected:\\n\"eweweweweweweweweweweweweweueueueueueueueueueueueueueueuhuhuhuhuhuhshshshshshshshshshshshshshshshshshshshphphphpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcrcrcrcrcrcrcrcrcrcrcrcrmrmrmrmrmrmrmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmgmgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvovovovovovovovovonononononononononbnbnbnbnbnbnbnbnbnbnbnbnbnbnbabaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiatatatatatftftftftftftftftftftftfdfdfdfdfdfdfdfdfdfdfdydydydydyzyzyzyzyzyzyzyzyzyzyzyzyzyzyjyjyjyjkjkjkjkjkjkjkjklklklklklklklklklklklkqkqkqwqwqwqwqwqwqwqwq\"\\n\\nMy output seems correct to me as there are no chars that are same and adajacent.\\nCan anybody point me where did i miss something?\\nThis the last test case"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@its_iterator](/its_iterator) nice , you earned my upvote "
                    },
                    {
                        "username": "jPank1983",
                        "content": "Copy that test case and then run it ( !submit ) then leetcode automatically highlight error "
                    },
                    {
                        "username": "its_iterator",
                        "content": "```\ns = \"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\n\np = \"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\n\na = [0]*26\nb = [0]*26\n\nfor i in range(len(s)):\n  a[ord(s[i])-ord('a')]+=1\n\nfor i in range(len(p)):\n  b[ord(p[i])-ord('a')]+=1\n\nprint(a)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 11, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\nprint(b)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 9, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\n\n```\n[@dec0de](/dec0de) your output have 2 \"j\" character sort than expected output.\n\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This problem is very similar to Task Scheduler, https://leetcode.com/problems/task-scheduler/. If you have done Task Scheduler you should recognize the pattern quickly"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "what if the question is with minimum numbers of swap done .. the !?? can someone give idea ?"
                    }
                ]
            },
            {
                "id": 1969515,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/GaUxskL\">\\n  <img src=\"https://i.imgur.com/GaUxskL.jpg\" title=\"source: imgur.com\" style=\"height: 300px;\" width=\"300px\" />\\n</a>\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@DoraBabukondala](/DoraBabukondala) Lacrimosa \\uD83D\\uDE15"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "knock knock"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I will learn priority queue, but not today."
                    },
                    {
                        "username": "arsalAbbas",
                        "content": "https://leetcode.com/problems/reorganize-string/solutions/3948675/detailed-c-solution-o-n-without-heap-beats-100-in-time/\\n\\nWho said anything about priority queue? ; )"
                    },
                    {
                        "username": "Barney786",
                        "content": "without using priority queue u can solve it too just place the max freq of  char alternatively/gap of 1 in resultant string"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@z3eg](/z3eg) me now.\\n"
                    },
                    {
                        "username": "21bce043",
                        "content": "us moment\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me basically every day lmao"
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"Alternate placing the most common letters. \" Use this hint to know\n If there is some character c with freq(c)>(n+1)/2 then it is impossible"
                    },
                    {
                        "username": "wafsinc",
                        "content": "WHY ARE YOU YELLING."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Sukhwindersingh0007](/Sukhwindersingh0007) If n is odd, use both ends there are  at most (n+1)/2 alternating places. If n is even, there are at most n/2 alternating places.\\nDue to Pigeonhole principle, if some character c with freq(c)>(n+1)/2 , then there must be some place for the adjacent characters with c!"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Whats the intitution?\\n"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "helful \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s easy to realise what we need to do here, alternatively put characters with maximum frequency. The problem lies in implementing this.\\n\\nEven if you get the intuition of using `Heaps`, it\\'s still a tricky one to implement.\\n\\nSo, the trick is to store pair of `{frequency,char}` in a Heap. Then while `Heap.size()>1` , at every iteration, take out the top two elements, append them to the ans string, decrease their frequency by `1` and push them again in the Heap.\\n\\nWhen the loop will break, either the Heap became `empty` or of `1 size.`\\n\\nIf it\\'s empty, return the ans string.\\n\\nif it has `size == 1`, check the remaining frequency of the top/last element, if its `1`, append it and return ans.\\n\\nOtherwise, return `\"\"`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sikora92](/sikora92) so heap will do that automatically, no? that\\'s why we will use that"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@ktnaneri](/ktnaneri) haha, mistakes happen"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Wish I read your comment before reading the solutions..."
                    },
                    {
                        "username": "sikora92",
                        "content": "Very good top. It does not have to be heap, any sorted collection will work. And remember to sort by frequency (current, not initial)."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "seemed easy at first... until it wasn\\'t"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "tricky one\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The approach to solve this problem is to use a priority queue to store the characters based on their frequency. We first count the frequency of each character in the string and store it in a hash map. Then, we create a priority queue and add all the characters from the hash map to it. We use a comparator to order the characters in the priority queue based on their frequency in decreasing order.\n\nThen, we take out two characters from the priority queue and append them to the output string. We keep track of the last character appended to the output string. If the next character in the priority queue is the same as the last character appended to the output string, we take out the next character from the priority queue and append it to the output string. We continue this process until the priority queue is empty or we cannot append any more characters to the output string.\n\nIf we cannot append any more characters to the output string, we return an empty string."
                    },
                    {
                        "username": "dec0de",
                        "content": "Input: \\n\"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\\\\\\\\\\\\\\\\\\n\\nMy output: \\n\"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\\n\\nExpected:\\n\"eweweweweweweweweweweweweweueueueueueueueueueueueueueueuhuhuhuhuhuhshshshshshshshshshshshshshshshshshshshphphphpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcrcrcrcrcrcrcrcrcrcrcrcrmrmrmrmrmrmrmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmxmgmgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvgvovovovovovovovovonononononononononbnbnbnbnbnbnbnbnbnbnbnbnbnbnbabaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiaiatatatatatftftftftftftftftftftftfdfdfdfdfdfdfdfdfdfdfdydydydydyzyzyzyzyzyzyzyzyzyzyzyzyzyzyjyjyjyjkjkjkjkjkjkjkjklklklklklklklklklklklkqkqkqwqwqwqwqwqwqwqwq\"\\n\\nMy output seems correct to me as there are no chars that are same and adajacent.\\nCan anybody point me where did i miss something?\\nThis the last test case"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@its_iterator](/its_iterator) nice , you earned my upvote "
                    },
                    {
                        "username": "jPank1983",
                        "content": "Copy that test case and then run it ( !submit ) then leetcode automatically highlight error "
                    },
                    {
                        "username": "its_iterator",
                        "content": "```\ns = \"tndsewnllhrtwsvxenkscbivijfqnysamckzoyfnapuotmdexzkkrpmppttficzerdndssuveompqkemtbwbodrhwsfpbmkafpwyedpcowruntvymxtyyejqtajkcjakghtdwmuygecjncxzcxezgecrxonnszmqmecgvqqkdagvaaucewelchsmebikscciegzoiamovdojrmmwgbxeygibxxltemfgpogjkhobmhwquizuwvhfaiavsxhiknysdghcawcrphaykyashchyomklvghkyabxatmrkmrfsppfhgrwywtlxebgzmevefcqquvhvgounldxkdzndwybxhtycmlybhaaqvodntsvfhwcuhvuccwcsxelafyzushjhfyklvghpfvknprfouevsxmcuhiiiewcluehpmzrjzffnrptwbuhnyahrbzqvirvmffbxvrmynfcnupnukayjghpusewdwrbkhvjnveuiionefmnfxao\"\n\np = \"ehehehehehehehehehehehehehehehehehehehehehehehehehehehehcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmcmvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvnvayayayayayayayayayayayayayayayayayayayayayayfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfwfkukukukukukukukukukukukukukukukukukukukuksxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsxsprprprprprprprprprprprprprprprprprprgogogogogogogogogogogogogogogogogobtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtidididididididididididididididizqzqzqzqzqzqzqzqzqzqzqzlzlzljljljljljljljljlj\"\n\na = [0]*26\nb = [0]*26\n\nfor i in range(len(s)):\n  a[ord(s[i])-ord('a')]+=1\n\nfor i in range(len(p)):\n  b[ord(p[i])-ord('a')]+=1\n\nprint(a)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 11, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\nprint(b)  #[22, 16, 26, 15, 28, 22, 17, 28, 16, 9, 21, 11, 26, 23, 17, 18, 11, 18, 19, 16, 20, 24, 21, 18, 22, 14]\n\n```\n[@dec0de](/dec0de) your output have 2 \"j\" character sort than expected output.\n\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This problem is very similar to Task Scheduler, https://leetcode.com/problems/task-scheduler/. If you have done Task Scheduler you should recognize the pattern quickly"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "what if the question is with minimum numbers of swap done .. the !?? can someone give idea ?"
                    }
                ]
            },
            {
                "id": 2027316,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "another unlucky day "
                    },
                    {
                        "username": "coder_sd",
                        "content": "Its a very good problem for logical thinking!"
                    },
                    {
                        "username": "Usman_M_Kafi",
                        "content": "I never thought this problem could be a problem until it became one by giving me a headache."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question to think about and implement.\\nSome tips:\\n\\n1. Look for the condition where its not possible to make the string at all, that is, if the frequency of any character is greater than (n+1)/2 then its not possible because the number of gaps between these characters would be more than the number of characters left in the string.\\n\\n2. Once you have taken care of the \\'not possible\\' condition, now you can try to find a way to make the string. There could be multiple ways to do this but the easiest one to implement would be to use a priority queue and append the characters of the two most frequent characters alternatively. "
                    },
                    {
                        "username": "Usman_M_Kafi",
                        "content": "[@sarbajit acharjee](/Noobcoooooder)"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "I thought we should use the back tracking since the beginning for this type of question. Who can realize this solution in the interview? "
                    },
                    {
                        "username": "schatterjee380",
                        "content": "the thing about backtracking is the max length of the string is 500. Since we know that the number of characters in the alphabet is 26 and we would have to try a lot of subproblems. I initially thought it was going to be a Dp problem but I realized if I used recursion there are no overlapping subproblems. So I just started writing more examples out."
                    },
                    {
                        "username": "rawatvishal",
                        "content": "TLE\nthis solution  is based on brute force and backtracking\nany optimization ?\n\nclass Solution {\npublic:\n    map<char, int> mp;\n\n    void check(string s, int start, vector<string>& ans, string temp) {\n        if (start == s.size()) {\n            ans.push_back(temp);\n            return;\n        }\n        for (int i = 0; i < s.size(); i++) {\n            if(ans.size()>0){\n                break;\n            }\n            if (mp[s[i]] > 0 && (temp.empty() || temp.back() != s[i])) {\n                temp += s[i];\n                mp[s[i]]--;\n                check(s, start + 1, ans, temp);\n                temp.pop_back(); \n                mp[s[i]]++; \n            }\n        }\n    }\n\n    string reorganizeString(string s) {\n        vector<string> ans;\n        int n = s.size();\n        for (int i = 0; i < n; i++) {\n            mp[s[i]]++;\n        }\n        string temp = \"\";\n        check(s, 0, ans, temp);\n        return ans.empty() ? \"\" : ans[0];\n    }\n};\n"
                    },
                    {
                        "username": "bhati25",
                        "content": "s = \"ogccckcwmbmxtsbmozli\"\\n\\nOutput : \"czcxcwctmsmlmkoiogbg\"\\n\\nExpected : \"cocgcickmlmsmtbwbxoz\"\\n\\nin the description it is written that *Return any possible rearrangement of s or return \"\" if not possible*\\nBut it is showing wrong ans.\\n"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thank you bro got the correct answer!!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`s` and `Output` contain differenct characters. In sorted order:\n```py\ns:      bbccccgiklmmmoostwxz\noutput: bccccggiklmmmoostwxz\n```"
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Surely not a medium one \\uD83D\\uDC80</h1> "
                    },
                    {
                        "username": "RivnaT",
                        "content": "Next Day Question when will available?"
                    },
                    {
                        "username": "user6009Ab",
                        "content": "please find error in my code\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        hello = len(str) \\n        i = 0\\n        if (i > hello):\\n            str[i] == str[i+1]\\n            if (str[i+2] != null):\\n                a = str[i+1]\\n                str[i+1]=  str[i+2]\\n                str[i+2] = a\\n                return str\\n            else: return null"
                    }
                ]
            },
            {
                "id": 1973413,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "another unlucky day "
                    },
                    {
                        "username": "coder_sd",
                        "content": "Its a very good problem for logical thinking!"
                    },
                    {
                        "username": "Usman_M_Kafi",
                        "content": "I never thought this problem could be a problem until it became one by giving me a headache."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question to think about and implement.\\nSome tips:\\n\\n1. Look for the condition where its not possible to make the string at all, that is, if the frequency of any character is greater than (n+1)/2 then its not possible because the number of gaps between these characters would be more than the number of characters left in the string.\\n\\n2. Once you have taken care of the \\'not possible\\' condition, now you can try to find a way to make the string. There could be multiple ways to do this but the easiest one to implement would be to use a priority queue and append the characters of the two most frequent characters alternatively. "
                    },
                    {
                        "username": "Usman_M_Kafi",
                        "content": "[@sarbajit acharjee](/Noobcoooooder)"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "I thought we should use the back tracking since the beginning for this type of question. Who can realize this solution in the interview? "
                    },
                    {
                        "username": "schatterjee380",
                        "content": "the thing about backtracking is the max length of the string is 500. Since we know that the number of characters in the alphabet is 26 and we would have to try a lot of subproblems. I initially thought it was going to be a Dp problem but I realized if I used recursion there are no overlapping subproblems. So I just started writing more examples out."
                    },
                    {
                        "username": "rawatvishal",
                        "content": "TLE\nthis solution  is based on brute force and backtracking\nany optimization ?\n\nclass Solution {\npublic:\n    map<char, int> mp;\n\n    void check(string s, int start, vector<string>& ans, string temp) {\n        if (start == s.size()) {\n            ans.push_back(temp);\n            return;\n        }\n        for (int i = 0; i < s.size(); i++) {\n            if(ans.size()>0){\n                break;\n            }\n            if (mp[s[i]] > 0 && (temp.empty() || temp.back() != s[i])) {\n                temp += s[i];\n                mp[s[i]]--;\n                check(s, start + 1, ans, temp);\n                temp.pop_back(); \n                mp[s[i]]++; \n            }\n        }\n    }\n\n    string reorganizeString(string s) {\n        vector<string> ans;\n        int n = s.size();\n        for (int i = 0; i < n; i++) {\n            mp[s[i]]++;\n        }\n        string temp = \"\";\n        check(s, 0, ans, temp);\n        return ans.empty() ? \"\" : ans[0];\n    }\n};\n"
                    },
                    {
                        "username": "bhati25",
                        "content": "s = \"ogccckcwmbmxtsbmozli\"\\n\\nOutput : \"czcxcwctmsmlmkoiogbg\"\\n\\nExpected : \"cocgcickmlmsmtbwbxoz\"\\n\\nin the description it is written that *Return any possible rearrangement of s or return \"\" if not possible*\\nBut it is showing wrong ans.\\n"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thank you bro got the correct answer!!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`s` and `Output` contain differenct characters. In sorted order:\n```py\ns:      bbccccgiklmmmoostwxz\noutput: bccccggiklmmmoostwxz\n```"
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Surely not a medium one \\uD83D\\uDC80</h1> "
                    },
                    {
                        "username": "RivnaT",
                        "content": "Next Day Question when will available?"
                    },
                    {
                        "username": "user6009Ab",
                        "content": "please find error in my code\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        hello = len(str) \\n        i = 0\\n        if (i > hello):\\n            str[i] == str[i+1]\\n            if (str[i+2] != null):\\n                a = str[i+1]\\n                str[i+1]=  str[i+2]\\n                str[i+2] = a\\n                return str\\n            else: return null"
                    }
                ]
            },
            {
                "id": 2027074,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "another unlucky day "
                    },
                    {
                        "username": "coder_sd",
                        "content": "Its a very good problem for logical thinking!"
                    },
                    {
                        "username": "Usman_M_Kafi",
                        "content": "I never thought this problem could be a problem until it became one by giving me a headache."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question to think about and implement.\\nSome tips:\\n\\n1. Look for the condition where its not possible to make the string at all, that is, if the frequency of any character is greater than (n+1)/2 then its not possible because the number of gaps between these characters would be more than the number of characters left in the string.\\n\\n2. Once you have taken care of the \\'not possible\\' condition, now you can try to find a way to make the string. There could be multiple ways to do this but the easiest one to implement would be to use a priority queue and append the characters of the two most frequent characters alternatively. "
                    },
                    {
                        "username": "Usman_M_Kafi",
                        "content": "[@sarbajit acharjee](/Noobcoooooder)"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "I thought we should use the back tracking since the beginning for this type of question. Who can realize this solution in the interview? "
                    },
                    {
                        "username": "schatterjee380",
                        "content": "the thing about backtracking is the max length of the string is 500. Since we know that the number of characters in the alphabet is 26 and we would have to try a lot of subproblems. I initially thought it was going to be a Dp problem but I realized if I used recursion there are no overlapping subproblems. So I just started writing more examples out."
                    },
                    {
                        "username": "rawatvishal",
                        "content": "TLE\nthis solution  is based on brute force and backtracking\nany optimization ?\n\nclass Solution {\npublic:\n    map<char, int> mp;\n\n    void check(string s, int start, vector<string>& ans, string temp) {\n        if (start == s.size()) {\n            ans.push_back(temp);\n            return;\n        }\n        for (int i = 0; i < s.size(); i++) {\n            if(ans.size()>0){\n                break;\n            }\n            if (mp[s[i]] > 0 && (temp.empty() || temp.back() != s[i])) {\n                temp += s[i];\n                mp[s[i]]--;\n                check(s, start + 1, ans, temp);\n                temp.pop_back(); \n                mp[s[i]]++; \n            }\n        }\n    }\n\n    string reorganizeString(string s) {\n        vector<string> ans;\n        int n = s.size();\n        for (int i = 0; i < n; i++) {\n            mp[s[i]]++;\n        }\n        string temp = \"\";\n        check(s, 0, ans, temp);\n        return ans.empty() ? \"\" : ans[0];\n    }\n};\n"
                    },
                    {
                        "username": "bhati25",
                        "content": "s = \"ogccckcwmbmxtsbmozli\"\\n\\nOutput : \"czcxcwctmsmlmkoiogbg\"\\n\\nExpected : \"cocgcickmlmsmtbwbxoz\"\\n\\nin the description it is written that *Return any possible rearrangement of s or return \"\" if not possible*\\nBut it is showing wrong ans.\\n"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thank you bro got the correct answer!!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`s` and `Output` contain differenct characters. In sorted order:\n```py\ns:      bbccccgiklmmmoostwxz\noutput: bccccggiklmmmoostwxz\n```"
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Surely not a medium one \\uD83D\\uDC80</h1> "
                    },
                    {
                        "username": "RivnaT",
                        "content": "Next Day Question when will available?"
                    },
                    {
                        "username": "user6009Ab",
                        "content": "please find error in my code\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        hello = len(str) \\n        i = 0\\n        if (i > hello):\\n            str[i] == str[i+1]\\n            if (str[i+2] != null):\\n                a = str[i+1]\\n                str[i+1]=  str[i+2]\\n                str[i+2] = a\\n                return str\\n            else: return null"
                    }
                ]
            },
            {
                "id": 2026435,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "another unlucky day "
                    },
                    {
                        "username": "coder_sd",
                        "content": "Its a very good problem for logical thinking!"
                    },
                    {
                        "username": "Usman_M_Kafi",
                        "content": "I never thought this problem could be a problem until it became one by giving me a headache."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question to think about and implement.\\nSome tips:\\n\\n1. Look for the condition where its not possible to make the string at all, that is, if the frequency of any character is greater than (n+1)/2 then its not possible because the number of gaps between these characters would be more than the number of characters left in the string.\\n\\n2. Once you have taken care of the \\'not possible\\' condition, now you can try to find a way to make the string. There could be multiple ways to do this but the easiest one to implement would be to use a priority queue and append the characters of the two most frequent characters alternatively. "
                    },
                    {
                        "username": "Usman_M_Kafi",
                        "content": "[@sarbajit acharjee](/Noobcoooooder)"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "I thought we should use the back tracking since the beginning for this type of question. Who can realize this solution in the interview? "
                    },
                    {
                        "username": "schatterjee380",
                        "content": "the thing about backtracking is the max length of the string is 500. Since we know that the number of characters in the alphabet is 26 and we would have to try a lot of subproblems. I initially thought it was going to be a Dp problem but I realized if I used recursion there are no overlapping subproblems. So I just started writing more examples out."
                    },
                    {
                        "username": "rawatvishal",
                        "content": "TLE\nthis solution  is based on brute force and backtracking\nany optimization ?\n\nclass Solution {\npublic:\n    map<char, int> mp;\n\n    void check(string s, int start, vector<string>& ans, string temp) {\n        if (start == s.size()) {\n            ans.push_back(temp);\n            return;\n        }\n        for (int i = 0; i < s.size(); i++) {\n            if(ans.size()>0){\n                break;\n            }\n            if (mp[s[i]] > 0 && (temp.empty() || temp.back() != s[i])) {\n                temp += s[i];\n                mp[s[i]]--;\n                check(s, start + 1, ans, temp);\n                temp.pop_back(); \n                mp[s[i]]++; \n            }\n        }\n    }\n\n    string reorganizeString(string s) {\n        vector<string> ans;\n        int n = s.size();\n        for (int i = 0; i < n; i++) {\n            mp[s[i]]++;\n        }\n        string temp = \"\";\n        check(s, 0, ans, temp);\n        return ans.empty() ? \"\" : ans[0];\n    }\n};\n"
                    },
                    {
                        "username": "bhati25",
                        "content": "s = \"ogccckcwmbmxtsbmozli\"\\n\\nOutput : \"czcxcwctmsmlmkoiogbg\"\\n\\nExpected : \"cocgcickmlmsmtbwbxoz\"\\n\\nin the description it is written that *Return any possible rearrangement of s or return \"\" if not possible*\\nBut it is showing wrong ans.\\n"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thank you bro got the correct answer!!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`s` and `Output` contain differenct characters. In sorted order:\n```py\ns:      bbccccgiklmmmoostwxz\noutput: bccccggiklmmmoostwxz\n```"
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Surely not a medium one \\uD83D\\uDC80</h1> "
                    },
                    {
                        "username": "RivnaT",
                        "content": "Next Day Question when will available?"
                    },
                    {
                        "username": "user6009Ab",
                        "content": "please find error in my code\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        hello = len(str) \\n        i = 0\\n        if (i > hello):\\n            str[i] == str[i+1]\\n            if (str[i+2] != null):\\n                a = str[i+1]\\n                str[i+1]=  str[i+2]\\n                str[i+2] = a\\n                return str\\n            else: return null"
                    }
                ]
            },
            {
                "id": 2026267,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "another unlucky day "
                    },
                    {
                        "username": "coder_sd",
                        "content": "Its a very good problem for logical thinking!"
                    },
                    {
                        "username": "Usman_M_Kafi",
                        "content": "I never thought this problem could be a problem until it became one by giving me a headache."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question to think about and implement.\\nSome tips:\\n\\n1. Look for the condition where its not possible to make the string at all, that is, if the frequency of any character is greater than (n+1)/2 then its not possible because the number of gaps between these characters would be more than the number of characters left in the string.\\n\\n2. Once you have taken care of the \\'not possible\\' condition, now you can try to find a way to make the string. There could be multiple ways to do this but the easiest one to implement would be to use a priority queue and append the characters of the two most frequent characters alternatively. "
                    },
                    {
                        "username": "Usman_M_Kafi",
                        "content": "[@sarbajit acharjee](/Noobcoooooder)"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "I thought we should use the back tracking since the beginning for this type of question. Who can realize this solution in the interview? "
                    },
                    {
                        "username": "schatterjee380",
                        "content": "the thing about backtracking is the max length of the string is 500. Since we know that the number of characters in the alphabet is 26 and we would have to try a lot of subproblems. I initially thought it was going to be a Dp problem but I realized if I used recursion there are no overlapping subproblems. So I just started writing more examples out."
                    },
                    {
                        "username": "rawatvishal",
                        "content": "TLE\nthis solution  is based on brute force and backtracking\nany optimization ?\n\nclass Solution {\npublic:\n    map<char, int> mp;\n\n    void check(string s, int start, vector<string>& ans, string temp) {\n        if (start == s.size()) {\n            ans.push_back(temp);\n            return;\n        }\n        for (int i = 0; i < s.size(); i++) {\n            if(ans.size()>0){\n                break;\n            }\n            if (mp[s[i]] > 0 && (temp.empty() || temp.back() != s[i])) {\n                temp += s[i];\n                mp[s[i]]--;\n                check(s, start + 1, ans, temp);\n                temp.pop_back(); \n                mp[s[i]]++; \n            }\n        }\n    }\n\n    string reorganizeString(string s) {\n        vector<string> ans;\n        int n = s.size();\n        for (int i = 0; i < n; i++) {\n            mp[s[i]]++;\n        }\n        string temp = \"\";\n        check(s, 0, ans, temp);\n        return ans.empty() ? \"\" : ans[0];\n    }\n};\n"
                    },
                    {
                        "username": "bhati25",
                        "content": "s = \"ogccckcwmbmxtsbmozli\"\\n\\nOutput : \"czcxcwctmsmlmkoiogbg\"\\n\\nExpected : \"cocgcickmlmsmtbwbxoz\"\\n\\nin the description it is written that *Return any possible rearrangement of s or return \"\" if not possible*\\nBut it is showing wrong ans.\\n"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thank you bro got the correct answer!!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`s` and `Output` contain differenct characters. In sorted order:\n```py\ns:      bbccccgiklmmmoostwxz\noutput: bccccggiklmmmoostwxz\n```"
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Surely not a medium one \\uD83D\\uDC80</h1> "
                    },
                    {
                        "username": "RivnaT",
                        "content": "Next Day Question when will available?"
                    },
                    {
                        "username": "user6009Ab",
                        "content": "please find error in my code\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        hello = len(str) \\n        i = 0\\n        if (i > hello):\\n            str[i] == str[i+1]\\n            if (str[i+2] != null):\\n                a = str[i+1]\\n                str[i+1]=  str[i+2]\\n                str[i+2] = a\\n                return str\\n            else: return null"
                    }
                ]
            },
            {
                "id": 2043484,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "another unlucky day "
                    },
                    {
                        "username": "coder_sd",
                        "content": "Its a very good problem for logical thinking!"
                    },
                    {
                        "username": "Usman_M_Kafi",
                        "content": "I never thought this problem could be a problem until it became one by giving me a headache."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question to think about and implement.\\nSome tips:\\n\\n1. Look for the condition where its not possible to make the string at all, that is, if the frequency of any character is greater than (n+1)/2 then its not possible because the number of gaps between these characters would be more than the number of characters left in the string.\\n\\n2. Once you have taken care of the \\'not possible\\' condition, now you can try to find a way to make the string. There could be multiple ways to do this but the easiest one to implement would be to use a priority queue and append the characters of the two most frequent characters alternatively. "
                    },
                    {
                        "username": "Usman_M_Kafi",
                        "content": "[@sarbajit acharjee](/Noobcoooooder)"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "I thought we should use the back tracking since the beginning for this type of question. Who can realize this solution in the interview? "
                    },
                    {
                        "username": "schatterjee380",
                        "content": "the thing about backtracking is the max length of the string is 500. Since we know that the number of characters in the alphabet is 26 and we would have to try a lot of subproblems. I initially thought it was going to be a Dp problem but I realized if I used recursion there are no overlapping subproblems. So I just started writing more examples out."
                    },
                    {
                        "username": "rawatvishal",
                        "content": "TLE\nthis solution  is based on brute force and backtracking\nany optimization ?\n\nclass Solution {\npublic:\n    map<char, int> mp;\n\n    void check(string s, int start, vector<string>& ans, string temp) {\n        if (start == s.size()) {\n            ans.push_back(temp);\n            return;\n        }\n        for (int i = 0; i < s.size(); i++) {\n            if(ans.size()>0){\n                break;\n            }\n            if (mp[s[i]] > 0 && (temp.empty() || temp.back() != s[i])) {\n                temp += s[i];\n                mp[s[i]]--;\n                check(s, start + 1, ans, temp);\n                temp.pop_back(); \n                mp[s[i]]++; \n            }\n        }\n    }\n\n    string reorganizeString(string s) {\n        vector<string> ans;\n        int n = s.size();\n        for (int i = 0; i < n; i++) {\n            mp[s[i]]++;\n        }\n        string temp = \"\";\n        check(s, 0, ans, temp);\n        return ans.empty() ? \"\" : ans[0];\n    }\n};\n"
                    },
                    {
                        "username": "bhati25",
                        "content": "s = \"ogccckcwmbmxtsbmozli\"\\n\\nOutput : \"czcxcwctmsmlmkoiogbg\"\\n\\nExpected : \"cocgcickmlmsmtbwbxoz\"\\n\\nin the description it is written that *Return any possible rearrangement of s or return \"\" if not possible*\\nBut it is showing wrong ans.\\n"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thank you bro got the correct answer!!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`s` and `Output` contain differenct characters. In sorted order:\n```py\ns:      bbccccgiklmmmoostwxz\noutput: bccccggiklmmmoostwxz\n```"
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Surely not a medium one \\uD83D\\uDC80</h1> "
                    },
                    {
                        "username": "RivnaT",
                        "content": "Next Day Question when will available?"
                    },
                    {
                        "username": "user6009Ab",
                        "content": "please find error in my code\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        hello = len(str) \\n        i = 0\\n        if (i > hello):\\n            str[i] == str[i+1]\\n            if (str[i+2] != null):\\n                a = str[i+1]\\n                str[i+1]=  str[i+2]\\n                str[i+2] = a\\n                return str\\n            else: return null"
                    }
                ]
            },
            {
                "id": 2027621,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "another unlucky day "
                    },
                    {
                        "username": "coder_sd",
                        "content": "Its a very good problem for logical thinking!"
                    },
                    {
                        "username": "Usman_M_Kafi",
                        "content": "I never thought this problem could be a problem until it became one by giving me a headache."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question to think about and implement.\\nSome tips:\\n\\n1. Look for the condition where its not possible to make the string at all, that is, if the frequency of any character is greater than (n+1)/2 then its not possible because the number of gaps between these characters would be more than the number of characters left in the string.\\n\\n2. Once you have taken care of the \\'not possible\\' condition, now you can try to find a way to make the string. There could be multiple ways to do this but the easiest one to implement would be to use a priority queue and append the characters of the two most frequent characters alternatively. "
                    },
                    {
                        "username": "Usman_M_Kafi",
                        "content": "[@sarbajit acharjee](/Noobcoooooder)"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "I thought we should use the back tracking since the beginning for this type of question. Who can realize this solution in the interview? "
                    },
                    {
                        "username": "schatterjee380",
                        "content": "the thing about backtracking is the max length of the string is 500. Since we know that the number of characters in the alphabet is 26 and we would have to try a lot of subproblems. I initially thought it was going to be a Dp problem but I realized if I used recursion there are no overlapping subproblems. So I just started writing more examples out."
                    },
                    {
                        "username": "rawatvishal",
                        "content": "TLE\nthis solution  is based on brute force and backtracking\nany optimization ?\n\nclass Solution {\npublic:\n    map<char, int> mp;\n\n    void check(string s, int start, vector<string>& ans, string temp) {\n        if (start == s.size()) {\n            ans.push_back(temp);\n            return;\n        }\n        for (int i = 0; i < s.size(); i++) {\n            if(ans.size()>0){\n                break;\n            }\n            if (mp[s[i]] > 0 && (temp.empty() || temp.back() != s[i])) {\n                temp += s[i];\n                mp[s[i]]--;\n                check(s, start + 1, ans, temp);\n                temp.pop_back(); \n                mp[s[i]]++; \n            }\n        }\n    }\n\n    string reorganizeString(string s) {\n        vector<string> ans;\n        int n = s.size();\n        for (int i = 0; i < n; i++) {\n            mp[s[i]]++;\n        }\n        string temp = \"\";\n        check(s, 0, ans, temp);\n        return ans.empty() ? \"\" : ans[0];\n    }\n};\n"
                    },
                    {
                        "username": "bhati25",
                        "content": "s = \"ogccckcwmbmxtsbmozli\"\\n\\nOutput : \"czcxcwctmsmlmkoiogbg\"\\n\\nExpected : \"cocgcickmlmsmtbwbxoz\"\\n\\nin the description it is written that *Return any possible rearrangement of s or return \"\" if not possible*\\nBut it is showing wrong ans.\\n"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thank you bro got the correct answer!!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`s` and `Output` contain differenct characters. In sorted order:\n```py\ns:      bbccccgiklmmmoostwxz\noutput: bccccggiklmmmoostwxz\n```"
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Surely not a medium one \\uD83D\\uDC80</h1> "
                    },
                    {
                        "username": "RivnaT",
                        "content": "Next Day Question when will available?"
                    },
                    {
                        "username": "user6009Ab",
                        "content": "please find error in my code\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        hello = len(str) \\n        i = 0\\n        if (i > hello):\\n            str[i] == str[i+1]\\n            if (str[i+2] != null):\\n                a = str[i+1]\\n                str[i+1]=  str[i+2]\\n                str[i+2] = a\\n                return str\\n            else: return null"
                    }
                ]
            },
            {
                "id": 2027586,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "another unlucky day "
                    },
                    {
                        "username": "coder_sd",
                        "content": "Its a very good problem for logical thinking!"
                    },
                    {
                        "username": "Usman_M_Kafi",
                        "content": "I never thought this problem could be a problem until it became one by giving me a headache."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question to think about and implement.\\nSome tips:\\n\\n1. Look for the condition where its not possible to make the string at all, that is, if the frequency of any character is greater than (n+1)/2 then its not possible because the number of gaps between these characters would be more than the number of characters left in the string.\\n\\n2. Once you have taken care of the \\'not possible\\' condition, now you can try to find a way to make the string. There could be multiple ways to do this but the easiest one to implement would be to use a priority queue and append the characters of the two most frequent characters alternatively. "
                    },
                    {
                        "username": "Usman_M_Kafi",
                        "content": "[@sarbajit acharjee](/Noobcoooooder)"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "I thought we should use the back tracking since the beginning for this type of question. Who can realize this solution in the interview? "
                    },
                    {
                        "username": "schatterjee380",
                        "content": "the thing about backtracking is the max length of the string is 500. Since we know that the number of characters in the alphabet is 26 and we would have to try a lot of subproblems. I initially thought it was going to be a Dp problem but I realized if I used recursion there are no overlapping subproblems. So I just started writing more examples out."
                    },
                    {
                        "username": "rawatvishal",
                        "content": "TLE\nthis solution  is based on brute force and backtracking\nany optimization ?\n\nclass Solution {\npublic:\n    map<char, int> mp;\n\n    void check(string s, int start, vector<string>& ans, string temp) {\n        if (start == s.size()) {\n            ans.push_back(temp);\n            return;\n        }\n        for (int i = 0; i < s.size(); i++) {\n            if(ans.size()>0){\n                break;\n            }\n            if (mp[s[i]] > 0 && (temp.empty() || temp.back() != s[i])) {\n                temp += s[i];\n                mp[s[i]]--;\n                check(s, start + 1, ans, temp);\n                temp.pop_back(); \n                mp[s[i]]++; \n            }\n        }\n    }\n\n    string reorganizeString(string s) {\n        vector<string> ans;\n        int n = s.size();\n        for (int i = 0; i < n; i++) {\n            mp[s[i]]++;\n        }\n        string temp = \"\";\n        check(s, 0, ans, temp);\n        return ans.empty() ? \"\" : ans[0];\n    }\n};\n"
                    },
                    {
                        "username": "bhati25",
                        "content": "s = \"ogccckcwmbmxtsbmozli\"\\n\\nOutput : \"czcxcwctmsmlmkoiogbg\"\\n\\nExpected : \"cocgcickmlmsmtbwbxoz\"\\n\\nin the description it is written that *Return any possible rearrangement of s or return \"\" if not possible*\\nBut it is showing wrong ans.\\n"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thank you bro got the correct answer!!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`s` and `Output` contain differenct characters. In sorted order:\n```py\ns:      bbccccgiklmmmoostwxz\noutput: bccccggiklmmmoostwxz\n```"
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Surely not a medium one \\uD83D\\uDC80</h1> "
                    },
                    {
                        "username": "RivnaT",
                        "content": "Next Day Question when will available?"
                    },
                    {
                        "username": "user6009Ab",
                        "content": "please find error in my code\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        hello = len(str) \\n        i = 0\\n        if (i > hello):\\n            str[i] == str[i+1]\\n            if (str[i+2] != null):\\n                a = str[i+1]\\n                str[i+1]=  str[i+2]\\n                str[i+2] = a\\n                return str\\n            else: return null"
                    }
                ]
            },
            {
                "id": 2027552,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "another unlucky day "
                    },
                    {
                        "username": "coder_sd",
                        "content": "Its a very good problem for logical thinking!"
                    },
                    {
                        "username": "Usman_M_Kafi",
                        "content": "I never thought this problem could be a problem until it became one by giving me a headache."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question to think about and implement.\\nSome tips:\\n\\n1. Look for the condition where its not possible to make the string at all, that is, if the frequency of any character is greater than (n+1)/2 then its not possible because the number of gaps between these characters would be more than the number of characters left in the string.\\n\\n2. Once you have taken care of the \\'not possible\\' condition, now you can try to find a way to make the string. There could be multiple ways to do this but the easiest one to implement would be to use a priority queue and append the characters of the two most frequent characters alternatively. "
                    },
                    {
                        "username": "Usman_M_Kafi",
                        "content": "[@sarbajit acharjee](/Noobcoooooder)"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "I thought we should use the back tracking since the beginning for this type of question. Who can realize this solution in the interview? "
                    },
                    {
                        "username": "schatterjee380",
                        "content": "the thing about backtracking is the max length of the string is 500. Since we know that the number of characters in the alphabet is 26 and we would have to try a lot of subproblems. I initially thought it was going to be a Dp problem but I realized if I used recursion there are no overlapping subproblems. So I just started writing more examples out."
                    },
                    {
                        "username": "rawatvishal",
                        "content": "TLE\nthis solution  is based on brute force and backtracking\nany optimization ?\n\nclass Solution {\npublic:\n    map<char, int> mp;\n\n    void check(string s, int start, vector<string>& ans, string temp) {\n        if (start == s.size()) {\n            ans.push_back(temp);\n            return;\n        }\n        for (int i = 0; i < s.size(); i++) {\n            if(ans.size()>0){\n                break;\n            }\n            if (mp[s[i]] > 0 && (temp.empty() || temp.back() != s[i])) {\n                temp += s[i];\n                mp[s[i]]--;\n                check(s, start + 1, ans, temp);\n                temp.pop_back(); \n                mp[s[i]]++; \n            }\n        }\n    }\n\n    string reorganizeString(string s) {\n        vector<string> ans;\n        int n = s.size();\n        for (int i = 0; i < n; i++) {\n            mp[s[i]]++;\n        }\n        string temp = \"\";\n        check(s, 0, ans, temp);\n        return ans.empty() ? \"\" : ans[0];\n    }\n};\n"
                    },
                    {
                        "username": "bhati25",
                        "content": "s = \"ogccckcwmbmxtsbmozli\"\\n\\nOutput : \"czcxcwctmsmlmkoiogbg\"\\n\\nExpected : \"cocgcickmlmsmtbwbxoz\"\\n\\nin the description it is written that *Return any possible rearrangement of s or return \"\" if not possible*\\nBut it is showing wrong ans.\\n"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thank you bro got the correct answer!!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`s` and `Output` contain differenct characters. In sorted order:\n```py\ns:      bbccccgiklmmmoostwxz\noutput: bccccggiklmmmoostwxz\n```"
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Surely not a medium one \\uD83D\\uDC80</h1> "
                    },
                    {
                        "username": "RivnaT",
                        "content": "Next Day Question when will available?"
                    },
                    {
                        "username": "user6009Ab",
                        "content": "please find error in my code\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        hello = len(str) \\n        i = 0\\n        if (i > hello):\\n            str[i] == str[i+1]\\n            if (str[i+2] != null):\\n                a = str[i+1]\\n                str[i+1]=  str[i+2]\\n                str[i+2] = a\\n                return str\\n            else: return null"
                    }
                ]
            },
            {
                "id": 2027472,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "another unlucky day "
                    },
                    {
                        "username": "coder_sd",
                        "content": "Its a very good problem for logical thinking!"
                    },
                    {
                        "username": "Usman_M_Kafi",
                        "content": "I never thought this problem could be a problem until it became one by giving me a headache."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question to think about and implement.\\nSome tips:\\n\\n1. Look for the condition where its not possible to make the string at all, that is, if the frequency of any character is greater than (n+1)/2 then its not possible because the number of gaps between these characters would be more than the number of characters left in the string.\\n\\n2. Once you have taken care of the \\'not possible\\' condition, now you can try to find a way to make the string. There could be multiple ways to do this but the easiest one to implement would be to use a priority queue and append the characters of the two most frequent characters alternatively. "
                    },
                    {
                        "username": "Usman_M_Kafi",
                        "content": "[@sarbajit acharjee](/Noobcoooooder)"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "I thought we should use the back tracking since the beginning for this type of question. Who can realize this solution in the interview? "
                    },
                    {
                        "username": "schatterjee380",
                        "content": "the thing about backtracking is the max length of the string is 500. Since we know that the number of characters in the alphabet is 26 and we would have to try a lot of subproblems. I initially thought it was going to be a Dp problem but I realized if I used recursion there are no overlapping subproblems. So I just started writing more examples out."
                    },
                    {
                        "username": "rawatvishal",
                        "content": "TLE\nthis solution  is based on brute force and backtracking\nany optimization ?\n\nclass Solution {\npublic:\n    map<char, int> mp;\n\n    void check(string s, int start, vector<string>& ans, string temp) {\n        if (start == s.size()) {\n            ans.push_back(temp);\n            return;\n        }\n        for (int i = 0; i < s.size(); i++) {\n            if(ans.size()>0){\n                break;\n            }\n            if (mp[s[i]] > 0 && (temp.empty() || temp.back() != s[i])) {\n                temp += s[i];\n                mp[s[i]]--;\n                check(s, start + 1, ans, temp);\n                temp.pop_back(); \n                mp[s[i]]++; \n            }\n        }\n    }\n\n    string reorganizeString(string s) {\n        vector<string> ans;\n        int n = s.size();\n        for (int i = 0; i < n; i++) {\n            mp[s[i]]++;\n        }\n        string temp = \"\";\n        check(s, 0, ans, temp);\n        return ans.empty() ? \"\" : ans[0];\n    }\n};\n"
                    },
                    {
                        "username": "bhati25",
                        "content": "s = \"ogccckcwmbmxtsbmozli\"\\n\\nOutput : \"czcxcwctmsmlmkoiogbg\"\\n\\nExpected : \"cocgcickmlmsmtbwbxoz\"\\n\\nin the description it is written that *Return any possible rearrangement of s or return \"\" if not possible*\\nBut it is showing wrong ans.\\n"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thank you bro got the correct answer!!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`s` and `Output` contain differenct characters. In sorted order:\n```py\ns:      bbccccgiklmmmoostwxz\noutput: bccccggiklmmmoostwxz\n```"
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Surely not a medium one \\uD83D\\uDC80</h1> "
                    },
                    {
                        "username": "RivnaT",
                        "content": "Next Day Question when will available?"
                    },
                    {
                        "username": "user6009Ab",
                        "content": "please find error in my code\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        hello = len(str) \\n        i = 0\\n        if (i > hello):\\n            str[i] == str[i+1]\\n            if (str[i+2] != null):\\n                a = str[i+1]\\n                str[i+1]=  str[i+2]\\n                str[i+2] = a\\n                return str\\n            else: return null"
                    }
                ]
            },
            {
                "id": 2027428,
                "content": [
                    {
                        "username": "SahilNikam",
                        "content": "somehow managed to pass 50 testcases TLE after that.\nedit : tried alternate characters and something different than previous got rid of TLE but wrong ans after 65 testcases.\nedit2 : finally I did it  \nThis problem was really fun it took me 2 house to figure out solution but it gave me satisfaction after my solution got accepted. :)"
                    },
                    {
                        "username": "VincentFF",
                        "content": "Good problem for learning heap usage. "
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Unlike some other problems here on Leetcode, this one is easy to understand and hard to implement. \\n\\nThe way I solved this is by using the dictionary to keep track of each character\\'s occurrence. After that, it was about figuring out how to implement it. Fun problem, but it definitely deserves the medium tag.\\n\\nAlso, my first attempted and solved medium. Yay!"
                    },
                    {
                        "username": "yutaaa",
                        "content": "s =\\n\"ogccckcwmbmxtsbmozli\"\\n\\nOutput\\n\"czcxcwctmsmlmkoiogbi\"\\nExpected\\n\"cocgcickmlmsmtbwbxoz\"\\n\\nwhere am I wrong in this?"
                    },
                    {
                        "username": "yutaaa",
                        "content": "ah, my bad.. I got it. Not deleting this because someone else can know the mistake in this.\\nActually I was going alternate positions in the string and using a while loop I was adding the same char whilst reducing it\\'s frequency starting from i=0 and incrementing by 2 in each iteration of loop. If i exceeds s.size() then update i to 1.\\nBut the problem was that I was doing that outside the while loop. There could be a possibility that i exceeds s.size() in the loop itself so check that also\\n\\n\\nhere is the code of the loop\\n```cpp\\n\\t\\t while(occ>0){\\n                s[i] = al+\\'a\\';\\n                i+=2;\\n                if(i>=s.size()) // check here too\\n                i=1;\\n                occ--;\\n            }\\n            if(i>=s.size()) // i can exceed s.size() outside the loop as well\\n                i=1;\\n\\t\\t```"
                    },
                    {
                        "username": "jems1123",
                        "content": "why the hell I am not getting this question\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Can anyone Explain "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Another useless problem that makes me slacking for it"
                    },
                    {
                        "username": "layyy",
                        "content": "if some letter occurs more than ceil(n/2) times return empty string\\nelse start placing letters at alternate positions starting with the most frequent letter"
                    },
                    {
                        "username": "aadityarajsingh0903",
                        "content": "it seems like same as  previous question but there is something new \\n"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Pop First two elements from a priority queue of {freq,char} and add them to sol string. do this while pq.size()>1 ... finally we obtain an empty pq return string , if pq.size()==1 if(frq>1) return -1l else add it to solution string and return it"
                    }
                ]
            },
            {
                "id": 2027376,
                "content": [
                    {
                        "username": "SahilNikam",
                        "content": "somehow managed to pass 50 testcases TLE after that.\nedit : tried alternate characters and something different than previous got rid of TLE but wrong ans after 65 testcases.\nedit2 : finally I did it  \nThis problem was really fun it took me 2 house to figure out solution but it gave me satisfaction after my solution got accepted. :)"
                    },
                    {
                        "username": "VincentFF",
                        "content": "Good problem for learning heap usage. "
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Unlike some other problems here on Leetcode, this one is easy to understand and hard to implement. \\n\\nThe way I solved this is by using the dictionary to keep track of each character\\'s occurrence. After that, it was about figuring out how to implement it. Fun problem, but it definitely deserves the medium tag.\\n\\nAlso, my first attempted and solved medium. Yay!"
                    },
                    {
                        "username": "yutaaa",
                        "content": "s =\\n\"ogccckcwmbmxtsbmozli\"\\n\\nOutput\\n\"czcxcwctmsmlmkoiogbi\"\\nExpected\\n\"cocgcickmlmsmtbwbxoz\"\\n\\nwhere am I wrong in this?"
                    },
                    {
                        "username": "yutaaa",
                        "content": "ah, my bad.. I got it. Not deleting this because someone else can know the mistake in this.\\nActually I was going alternate positions in the string and using a while loop I was adding the same char whilst reducing it\\'s frequency starting from i=0 and incrementing by 2 in each iteration of loop. If i exceeds s.size() then update i to 1.\\nBut the problem was that I was doing that outside the while loop. There could be a possibility that i exceeds s.size() in the loop itself so check that also\\n\\n\\nhere is the code of the loop\\n```cpp\\n\\t\\t while(occ>0){\\n                s[i] = al+\\'a\\';\\n                i+=2;\\n                if(i>=s.size()) // check here too\\n                i=1;\\n                occ--;\\n            }\\n            if(i>=s.size()) // i can exceed s.size() outside the loop as well\\n                i=1;\\n\\t\\t```"
                    },
                    {
                        "username": "jems1123",
                        "content": "why the hell I am not getting this question\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Can anyone Explain "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Another useless problem that makes me slacking for it"
                    },
                    {
                        "username": "layyy",
                        "content": "if some letter occurs more than ceil(n/2) times return empty string\\nelse start placing letters at alternate positions starting with the most frequent letter"
                    },
                    {
                        "username": "aadityarajsingh0903",
                        "content": "it seems like same as  previous question but there is something new \\n"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Pop First two elements from a priority queue of {freq,char} and add them to sol string. do this while pq.size()>1 ... finally we obtain an empty pq return string , if pq.size()==1 if(frq>1) return -1l else add it to solution string and return it"
                    }
                ]
            },
            {
                "id": 2027334,
                "content": [
                    {
                        "username": "SahilNikam",
                        "content": "somehow managed to pass 50 testcases TLE after that.\nedit : tried alternate characters and something different than previous got rid of TLE but wrong ans after 65 testcases.\nedit2 : finally I did it  \nThis problem was really fun it took me 2 house to figure out solution but it gave me satisfaction after my solution got accepted. :)"
                    },
                    {
                        "username": "VincentFF",
                        "content": "Good problem for learning heap usage. "
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Unlike some other problems here on Leetcode, this one is easy to understand and hard to implement. \\n\\nThe way I solved this is by using the dictionary to keep track of each character\\'s occurrence. After that, it was about figuring out how to implement it. Fun problem, but it definitely deserves the medium tag.\\n\\nAlso, my first attempted and solved medium. Yay!"
                    },
                    {
                        "username": "yutaaa",
                        "content": "s =\\n\"ogccckcwmbmxtsbmozli\"\\n\\nOutput\\n\"czcxcwctmsmlmkoiogbi\"\\nExpected\\n\"cocgcickmlmsmtbwbxoz\"\\n\\nwhere am I wrong in this?"
                    },
                    {
                        "username": "yutaaa",
                        "content": "ah, my bad.. I got it. Not deleting this because someone else can know the mistake in this.\\nActually I was going alternate positions in the string and using a while loop I was adding the same char whilst reducing it\\'s frequency starting from i=0 and incrementing by 2 in each iteration of loop. If i exceeds s.size() then update i to 1.\\nBut the problem was that I was doing that outside the while loop. There could be a possibility that i exceeds s.size() in the loop itself so check that also\\n\\n\\nhere is the code of the loop\\n```cpp\\n\\t\\t while(occ>0){\\n                s[i] = al+\\'a\\';\\n                i+=2;\\n                if(i>=s.size()) // check here too\\n                i=1;\\n                occ--;\\n            }\\n            if(i>=s.size()) // i can exceed s.size() outside the loop as well\\n                i=1;\\n\\t\\t```"
                    },
                    {
                        "username": "jems1123",
                        "content": "why the hell I am not getting this question\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Can anyone Explain "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Another useless problem that makes me slacking for it"
                    },
                    {
                        "username": "layyy",
                        "content": "if some letter occurs more than ceil(n/2) times return empty string\\nelse start placing letters at alternate positions starting with the most frequent letter"
                    },
                    {
                        "username": "aadityarajsingh0903",
                        "content": "it seems like same as  previous question but there is something new \\n"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Pop First two elements from a priority queue of {freq,char} and add them to sol string. do this while pq.size()>1 ... finally we obtain an empty pq return string , if pq.size()==1 if(frq>1) return -1l else add it to solution string and return it"
                    }
                ]
            },
            {
                "id": 2027243,
                "content": [
                    {
                        "username": "SahilNikam",
                        "content": "somehow managed to pass 50 testcases TLE after that.\nedit : tried alternate characters and something different than previous got rid of TLE but wrong ans after 65 testcases.\nedit2 : finally I did it  \nThis problem was really fun it took me 2 house to figure out solution but it gave me satisfaction after my solution got accepted. :)"
                    },
                    {
                        "username": "VincentFF",
                        "content": "Good problem for learning heap usage. "
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Unlike some other problems here on Leetcode, this one is easy to understand and hard to implement. \\n\\nThe way I solved this is by using the dictionary to keep track of each character\\'s occurrence. After that, it was about figuring out how to implement it. Fun problem, but it definitely deserves the medium tag.\\n\\nAlso, my first attempted and solved medium. Yay!"
                    },
                    {
                        "username": "yutaaa",
                        "content": "s =\\n\"ogccckcwmbmxtsbmozli\"\\n\\nOutput\\n\"czcxcwctmsmlmkoiogbi\"\\nExpected\\n\"cocgcickmlmsmtbwbxoz\"\\n\\nwhere am I wrong in this?"
                    },
                    {
                        "username": "yutaaa",
                        "content": "ah, my bad.. I got it. Not deleting this because someone else can know the mistake in this.\\nActually I was going alternate positions in the string and using a while loop I was adding the same char whilst reducing it\\'s frequency starting from i=0 and incrementing by 2 in each iteration of loop. If i exceeds s.size() then update i to 1.\\nBut the problem was that I was doing that outside the while loop. There could be a possibility that i exceeds s.size() in the loop itself so check that also\\n\\n\\nhere is the code of the loop\\n```cpp\\n\\t\\t while(occ>0){\\n                s[i] = al+\\'a\\';\\n                i+=2;\\n                if(i>=s.size()) // check here too\\n                i=1;\\n                occ--;\\n            }\\n            if(i>=s.size()) // i can exceed s.size() outside the loop as well\\n                i=1;\\n\\t\\t```"
                    },
                    {
                        "username": "jems1123",
                        "content": "why the hell I am not getting this question\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Can anyone Explain "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Another useless problem that makes me slacking for it"
                    },
                    {
                        "username": "layyy",
                        "content": "if some letter occurs more than ceil(n/2) times return empty string\\nelse start placing letters at alternate positions starting with the most frequent letter"
                    },
                    {
                        "username": "aadityarajsingh0903",
                        "content": "it seems like same as  previous question but there is something new \\n"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Pop First two elements from a priority queue of {freq,char} and add them to sol string. do this while pq.size()>1 ... finally we obtain an empty pq return string , if pq.size()==1 if(frq>1) return -1l else add it to solution string and return it"
                    }
                ]
            },
            {
                "id": 2027163,
                "content": [
                    {
                        "username": "SahilNikam",
                        "content": "somehow managed to pass 50 testcases TLE after that.\nedit : tried alternate characters and something different than previous got rid of TLE but wrong ans after 65 testcases.\nedit2 : finally I did it  \nThis problem was really fun it took me 2 house to figure out solution but it gave me satisfaction after my solution got accepted. :)"
                    },
                    {
                        "username": "VincentFF",
                        "content": "Good problem for learning heap usage. "
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Unlike some other problems here on Leetcode, this one is easy to understand and hard to implement. \\n\\nThe way I solved this is by using the dictionary to keep track of each character\\'s occurrence. After that, it was about figuring out how to implement it. Fun problem, but it definitely deserves the medium tag.\\n\\nAlso, my first attempted and solved medium. Yay!"
                    },
                    {
                        "username": "yutaaa",
                        "content": "s =\\n\"ogccckcwmbmxtsbmozli\"\\n\\nOutput\\n\"czcxcwctmsmlmkoiogbi\"\\nExpected\\n\"cocgcickmlmsmtbwbxoz\"\\n\\nwhere am I wrong in this?"
                    },
                    {
                        "username": "yutaaa",
                        "content": "ah, my bad.. I got it. Not deleting this because someone else can know the mistake in this.\\nActually I was going alternate positions in the string and using a while loop I was adding the same char whilst reducing it\\'s frequency starting from i=0 and incrementing by 2 in each iteration of loop. If i exceeds s.size() then update i to 1.\\nBut the problem was that I was doing that outside the while loop. There could be a possibility that i exceeds s.size() in the loop itself so check that also\\n\\n\\nhere is the code of the loop\\n```cpp\\n\\t\\t while(occ>0){\\n                s[i] = al+\\'a\\';\\n                i+=2;\\n                if(i>=s.size()) // check here too\\n                i=1;\\n                occ--;\\n            }\\n            if(i>=s.size()) // i can exceed s.size() outside the loop as well\\n                i=1;\\n\\t\\t```"
                    },
                    {
                        "username": "jems1123",
                        "content": "why the hell I am not getting this question\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Can anyone Explain "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Another useless problem that makes me slacking for it"
                    },
                    {
                        "username": "layyy",
                        "content": "if some letter occurs more than ceil(n/2) times return empty string\\nelse start placing letters at alternate positions starting with the most frequent letter"
                    },
                    {
                        "username": "aadityarajsingh0903",
                        "content": "it seems like same as  previous question but there is something new \\n"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Pop First two elements from a priority queue of {freq,char} and add them to sol string. do this while pq.size()>1 ... finally we obtain an empty pq return string , if pq.size()==1 if(frq>1) return -1l else add it to solution string and return it"
                    }
                ]
            },
            {
                "id": 2027064,
                "content": [
                    {
                        "username": "SahilNikam",
                        "content": "somehow managed to pass 50 testcases TLE after that.\nedit : tried alternate characters and something different than previous got rid of TLE but wrong ans after 65 testcases.\nedit2 : finally I did it  \nThis problem was really fun it took me 2 house to figure out solution but it gave me satisfaction after my solution got accepted. :)"
                    },
                    {
                        "username": "VincentFF",
                        "content": "Good problem for learning heap usage. "
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Unlike some other problems here on Leetcode, this one is easy to understand and hard to implement. \\n\\nThe way I solved this is by using the dictionary to keep track of each character\\'s occurrence. After that, it was about figuring out how to implement it. Fun problem, but it definitely deserves the medium tag.\\n\\nAlso, my first attempted and solved medium. Yay!"
                    },
                    {
                        "username": "yutaaa",
                        "content": "s =\\n\"ogccckcwmbmxtsbmozli\"\\n\\nOutput\\n\"czcxcwctmsmlmkoiogbi\"\\nExpected\\n\"cocgcickmlmsmtbwbxoz\"\\n\\nwhere am I wrong in this?"
                    },
                    {
                        "username": "yutaaa",
                        "content": "ah, my bad.. I got it. Not deleting this because someone else can know the mistake in this.\\nActually I was going alternate positions in the string and using a while loop I was adding the same char whilst reducing it\\'s frequency starting from i=0 and incrementing by 2 in each iteration of loop. If i exceeds s.size() then update i to 1.\\nBut the problem was that I was doing that outside the while loop. There could be a possibility that i exceeds s.size() in the loop itself so check that also\\n\\n\\nhere is the code of the loop\\n```cpp\\n\\t\\t while(occ>0){\\n                s[i] = al+\\'a\\';\\n                i+=2;\\n                if(i>=s.size()) // check here too\\n                i=1;\\n                occ--;\\n            }\\n            if(i>=s.size()) // i can exceed s.size() outside the loop as well\\n                i=1;\\n\\t\\t```"
                    },
                    {
                        "username": "jems1123",
                        "content": "why the hell I am not getting this question\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Can anyone Explain "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Another useless problem that makes me slacking for it"
                    },
                    {
                        "username": "layyy",
                        "content": "if some letter occurs more than ceil(n/2) times return empty string\\nelse start placing letters at alternate positions starting with the most frequent letter"
                    },
                    {
                        "username": "aadityarajsingh0903",
                        "content": "it seems like same as  previous question but there is something new \\n"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Pop First two elements from a priority queue of {freq,char} and add them to sol string. do this while pq.size()>1 ... finally we obtain an empty pq return string , if pq.size()==1 if(frq>1) return -1l else add it to solution string and return it"
                    }
                ]
            },
            {
                "id": 2026882,
                "content": [
                    {
                        "username": "SahilNikam",
                        "content": "somehow managed to pass 50 testcases TLE after that.\nedit : tried alternate characters and something different than previous got rid of TLE but wrong ans after 65 testcases.\nedit2 : finally I did it  \nThis problem was really fun it took me 2 house to figure out solution but it gave me satisfaction after my solution got accepted. :)"
                    },
                    {
                        "username": "VincentFF",
                        "content": "Good problem for learning heap usage. "
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Unlike some other problems here on Leetcode, this one is easy to understand and hard to implement. \\n\\nThe way I solved this is by using the dictionary to keep track of each character\\'s occurrence. After that, it was about figuring out how to implement it. Fun problem, but it definitely deserves the medium tag.\\n\\nAlso, my first attempted and solved medium. Yay!"
                    },
                    {
                        "username": "yutaaa",
                        "content": "s =\\n\"ogccckcwmbmxtsbmozli\"\\n\\nOutput\\n\"czcxcwctmsmlmkoiogbi\"\\nExpected\\n\"cocgcickmlmsmtbwbxoz\"\\n\\nwhere am I wrong in this?"
                    },
                    {
                        "username": "yutaaa",
                        "content": "ah, my bad.. I got it. Not deleting this because someone else can know the mistake in this.\\nActually I was going alternate positions in the string and using a while loop I was adding the same char whilst reducing it\\'s frequency starting from i=0 and incrementing by 2 in each iteration of loop. If i exceeds s.size() then update i to 1.\\nBut the problem was that I was doing that outside the while loop. There could be a possibility that i exceeds s.size() in the loop itself so check that also\\n\\n\\nhere is the code of the loop\\n```cpp\\n\\t\\t while(occ>0){\\n                s[i] = al+\\'a\\';\\n                i+=2;\\n                if(i>=s.size()) // check here too\\n                i=1;\\n                occ--;\\n            }\\n            if(i>=s.size()) // i can exceed s.size() outside the loop as well\\n                i=1;\\n\\t\\t```"
                    },
                    {
                        "username": "jems1123",
                        "content": "why the hell I am not getting this question\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Can anyone Explain "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Another useless problem that makes me slacking for it"
                    },
                    {
                        "username": "layyy",
                        "content": "if some letter occurs more than ceil(n/2) times return empty string\\nelse start placing letters at alternate positions starting with the most frequent letter"
                    },
                    {
                        "username": "aadityarajsingh0903",
                        "content": "it seems like same as  previous question but there is something new \\n"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Pop First two elements from a priority queue of {freq,char} and add them to sol string. do this while pq.size()>1 ... finally we obtain an empty pq return string , if pq.size()==1 if(frq>1) return -1l else add it to solution string and return it"
                    }
                ]
            },
            {
                "id": 2026803,
                "content": [
                    {
                        "username": "SahilNikam",
                        "content": "somehow managed to pass 50 testcases TLE after that.\nedit : tried alternate characters and something different than previous got rid of TLE but wrong ans after 65 testcases.\nedit2 : finally I did it  \nThis problem was really fun it took me 2 house to figure out solution but it gave me satisfaction after my solution got accepted. :)"
                    },
                    {
                        "username": "VincentFF",
                        "content": "Good problem for learning heap usage. "
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Unlike some other problems here on Leetcode, this one is easy to understand and hard to implement. \\n\\nThe way I solved this is by using the dictionary to keep track of each character\\'s occurrence. After that, it was about figuring out how to implement it. Fun problem, but it definitely deserves the medium tag.\\n\\nAlso, my first attempted and solved medium. Yay!"
                    },
                    {
                        "username": "yutaaa",
                        "content": "s =\\n\"ogccckcwmbmxtsbmozli\"\\n\\nOutput\\n\"czcxcwctmsmlmkoiogbi\"\\nExpected\\n\"cocgcickmlmsmtbwbxoz\"\\n\\nwhere am I wrong in this?"
                    },
                    {
                        "username": "yutaaa",
                        "content": "ah, my bad.. I got it. Not deleting this because someone else can know the mistake in this.\\nActually I was going alternate positions in the string and using a while loop I was adding the same char whilst reducing it\\'s frequency starting from i=0 and incrementing by 2 in each iteration of loop. If i exceeds s.size() then update i to 1.\\nBut the problem was that I was doing that outside the while loop. There could be a possibility that i exceeds s.size() in the loop itself so check that also\\n\\n\\nhere is the code of the loop\\n```cpp\\n\\t\\t while(occ>0){\\n                s[i] = al+\\'a\\';\\n                i+=2;\\n                if(i>=s.size()) // check here too\\n                i=1;\\n                occ--;\\n            }\\n            if(i>=s.size()) // i can exceed s.size() outside the loop as well\\n                i=1;\\n\\t\\t```"
                    },
                    {
                        "username": "jems1123",
                        "content": "why the hell I am not getting this question\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Can anyone Explain "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Another useless problem that makes me slacking for it"
                    },
                    {
                        "username": "layyy",
                        "content": "if some letter occurs more than ceil(n/2) times return empty string\\nelse start placing letters at alternate positions starting with the most frequent letter"
                    },
                    {
                        "username": "aadityarajsingh0903",
                        "content": "it seems like same as  previous question but there is something new \\n"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Pop First two elements from a priority queue of {freq,char} and add them to sol string. do this while pq.size()>1 ... finally we obtain an empty pq return string , if pq.size()==1 if(frq>1) return -1l else add it to solution string and return it"
                    }
                ]
            },
            {
                "id": 2026779,
                "content": [
                    {
                        "username": "SahilNikam",
                        "content": "somehow managed to pass 50 testcases TLE after that.\nedit : tried alternate characters and something different than previous got rid of TLE but wrong ans after 65 testcases.\nedit2 : finally I did it  \nThis problem was really fun it took me 2 house to figure out solution but it gave me satisfaction after my solution got accepted. :)"
                    },
                    {
                        "username": "VincentFF",
                        "content": "Good problem for learning heap usage. "
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Unlike some other problems here on Leetcode, this one is easy to understand and hard to implement. \\n\\nThe way I solved this is by using the dictionary to keep track of each character\\'s occurrence. After that, it was about figuring out how to implement it. Fun problem, but it definitely deserves the medium tag.\\n\\nAlso, my first attempted and solved medium. Yay!"
                    },
                    {
                        "username": "yutaaa",
                        "content": "s =\\n\"ogccckcwmbmxtsbmozli\"\\n\\nOutput\\n\"czcxcwctmsmlmkoiogbi\"\\nExpected\\n\"cocgcickmlmsmtbwbxoz\"\\n\\nwhere am I wrong in this?"
                    },
                    {
                        "username": "yutaaa",
                        "content": "ah, my bad.. I got it. Not deleting this because someone else can know the mistake in this.\\nActually I was going alternate positions in the string and using a while loop I was adding the same char whilst reducing it\\'s frequency starting from i=0 and incrementing by 2 in each iteration of loop. If i exceeds s.size() then update i to 1.\\nBut the problem was that I was doing that outside the while loop. There could be a possibility that i exceeds s.size() in the loop itself so check that also\\n\\n\\nhere is the code of the loop\\n```cpp\\n\\t\\t while(occ>0){\\n                s[i] = al+\\'a\\';\\n                i+=2;\\n                if(i>=s.size()) // check here too\\n                i=1;\\n                occ--;\\n            }\\n            if(i>=s.size()) // i can exceed s.size() outside the loop as well\\n                i=1;\\n\\t\\t```"
                    },
                    {
                        "username": "jems1123",
                        "content": "why the hell I am not getting this question\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Can anyone Explain "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Another useless problem that makes me slacking for it"
                    },
                    {
                        "username": "layyy",
                        "content": "if some letter occurs more than ceil(n/2) times return empty string\\nelse start placing letters at alternate positions starting with the most frequent letter"
                    },
                    {
                        "username": "aadityarajsingh0903",
                        "content": "it seems like same as  previous question but there is something new \\n"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Pop First two elements from a priority queue of {freq,char} and add them to sol string. do this while pq.size()>1 ... finally we obtain an empty pq return string , if pq.size()==1 if(frq>1) return -1l else add it to solution string and return it"
                    }
                ]
            },
            {
                "id": 2026742,
                "content": [
                    {
                        "username": "SahilNikam",
                        "content": "somehow managed to pass 50 testcases TLE after that.\nedit : tried alternate characters and something different than previous got rid of TLE but wrong ans after 65 testcases.\nedit2 : finally I did it  \nThis problem was really fun it took me 2 house to figure out solution but it gave me satisfaction after my solution got accepted. :)"
                    },
                    {
                        "username": "VincentFF",
                        "content": "Good problem for learning heap usage. "
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Unlike some other problems here on Leetcode, this one is easy to understand and hard to implement. \\n\\nThe way I solved this is by using the dictionary to keep track of each character\\'s occurrence. After that, it was about figuring out how to implement it. Fun problem, but it definitely deserves the medium tag.\\n\\nAlso, my first attempted and solved medium. Yay!"
                    },
                    {
                        "username": "yutaaa",
                        "content": "s =\\n\"ogccckcwmbmxtsbmozli\"\\n\\nOutput\\n\"czcxcwctmsmlmkoiogbi\"\\nExpected\\n\"cocgcickmlmsmtbwbxoz\"\\n\\nwhere am I wrong in this?"
                    },
                    {
                        "username": "yutaaa",
                        "content": "ah, my bad.. I got it. Not deleting this because someone else can know the mistake in this.\\nActually I was going alternate positions in the string and using a while loop I was adding the same char whilst reducing it\\'s frequency starting from i=0 and incrementing by 2 in each iteration of loop. If i exceeds s.size() then update i to 1.\\nBut the problem was that I was doing that outside the while loop. There could be a possibility that i exceeds s.size() in the loop itself so check that also\\n\\n\\nhere is the code of the loop\\n```cpp\\n\\t\\t while(occ>0){\\n                s[i] = al+\\'a\\';\\n                i+=2;\\n                if(i>=s.size()) // check here too\\n                i=1;\\n                occ--;\\n            }\\n            if(i>=s.size()) // i can exceed s.size() outside the loop as well\\n                i=1;\\n\\t\\t```"
                    },
                    {
                        "username": "jems1123",
                        "content": "why the hell I am not getting this question\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Can anyone Explain "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Another useless problem that makes me slacking for it"
                    },
                    {
                        "username": "layyy",
                        "content": "if some letter occurs more than ceil(n/2) times return empty string\\nelse start placing letters at alternate positions starting with the most frequent letter"
                    },
                    {
                        "username": "aadityarajsingh0903",
                        "content": "it seems like same as  previous question but there is something new \\n"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Pop First two elements from a priority queue of {freq,char} and add them to sol string. do this while pq.size()>1 ... finally we obtain an empty pq return string , if pq.size()==1 if(frq>1) return -1l else add it to solution string and return it"
                    }
                ]
            },
            {
                "id": 2026727,
                "content": [
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "I thought of going with a two pointer approach, and swapping the element with the non repeating one, Like, Eg- xxxab, Then I\\'d swap the second occurance of the repeating element with a char which is different than the repeating one. But I cannot what would be a problem in this approach, Can anyone tell?"
                    },
                    {
                        "username": "trip1312",
                        "content": "That is actually exactly how I solved it. You just need to loop through it once going from left to right then once going from right to left."
                    },
                    {
                        "username": "harshal1911",
                        "content": "little tricky one , but solved!!! \\n\\u2705"
                    },
                    {
                        "username": "psionl0",
                        "content": "Append the most frequent letter to the return string. If the last letter of the return string is the same as the most frequent letter then append the second most frequent letter to the string instead. If there is no second frequent letter then alternation can't be done so return an empty string.\nAs you append letters, the frequency of the remaining letters decreases and other letters may become more frequent. You will need a priority queue to keep track of the most frequent letters."
                    },
                    {
                        "username": "nihalshahria",
                        "content": "I encountered Runtime Error for a specific test case. When I test my [code](https://ideone.com/3cqX5U) using this test case in my local machine or any other online compiler, it produced the correct output. Can anyone help? \\nTest input:\\n`\"snnnnbpngobwznvnnnlnwhvnnnnfjnnlnnnnnnbnknnqkndzefncknnnnnaiqrntnndnnnjninnnunnunqhndnnqnnsjqnnpiqshntnnncnvnnnncnnqenlnninyndnnnljongnnjwnnnngllnnngkbnllnnnnontlbpngjnnenqnsnnnnnjeqqghnfpngepnodnnnnnnvnsrnughbnipvnhqmnzonoonnnjotnnonoennnpnfnnkdnnbmnmnpnqninnxronnnnvnlanlnnnebnnnlnvnfknsnbincnttnmnguqenhnnxunnnntnnnnhnqnzehvunfnvnndvnjnnnbnnpxnqipwnmnonnndlnsnonnninnxnnnjnnnnnesennmyiednnnnnnnnnhimtnnnonjlicnwnwvnntaxmnrntnnnnsnbnanninnecbcfjxncnnkvnnqgnunensanpnngjnzxjnopnnyvnnxskniyytnsnnnnx\"`\\n"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def reorganizeString(self, S: str) -> str:\\n        hash = [0] * 26\\n        for char in S:\\n            hash[ord(char) - ord(\\'a\\')] += 1\\n\\n        max_count, letter = 0, 0\\n        for i in range(len(hash)):\\n            if hash[i] > max_count:\\n                max_count = hash[i]\\n                letter = i\\n\\n        if max_count > (len(S) + 1) // 2:\\n            return \"\"\\n\\n        res = [None] * len(S)\\n        idx = 0\\n        while hash[letter] > 0:\\n            res[idx] = chr(letter + ord(\\'a\\'))\\n            idx += 2\\n            hash[letter] -= 1\\n\\n        for i in range(len(hash)):\\n            while hash[i] > 0:\\n                if idx >= len(res):\\n                    idx = 1\\n                res[idx] = chr(i + ord(\\'a\\'))\\n                idx += 2\\n                hash[i] -= 1\\n\\n        return \\'\\'.join(res)"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "nice one but don\\'t post solutions in discussion"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I couldn\\'t solve it without the hint. The solutions provided in the editorial are brilliant, particularly the second one."
                    },
                    {
                        "username": "_SID_",
                        "content": "Keep track of previous character while appending the current most frequent character"
                    },
                    {
                        "username": "singh__12",
                        "content": "Really It is very logical but when you come up with solution, it looks easy."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I find a heap helpful in solving this."
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "class Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        priority_queue<pair<int,char>> pq;\\nmap<char,int> mp;\\nstring ans=\"\";\\npair<int ,char> block{0,\\'0\\'},temp{0,\\'0\\'};\\n\\nfor(char ch:s) mp[ch]++;\\n\\n    for(auto p:mp) pq.push({p.second,p.first});\\n     block=pq.top();\\n     ans+=block.second;\\n     block.first--;\\n     pq.pop();\\n     while(pq.size()>0|| block!=NULL){\\n       if(!pq.size() && block!=NULL) return \"\";\\n       temp=pq.top();\\n       pq.pop();\\n       ans+=temp.second;\\n       temp.first--;\\n       if(block.first>0){\\n       pq.push(block);\\n       }\\n       block=temp;\\n     }\\n     \\n\\n    \\n    return ans; \\n    }\\n};\\n\\nwhy erroor????????????????????"
                    }
                ]
            },
            {
                "id": 2026704,
                "content": [
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "I thought of going with a two pointer approach, and swapping the element with the non repeating one, Like, Eg- xxxab, Then I\\'d swap the second occurance of the repeating element with a char which is different than the repeating one. But I cannot what would be a problem in this approach, Can anyone tell?"
                    },
                    {
                        "username": "trip1312",
                        "content": "That is actually exactly how I solved it. You just need to loop through it once going from left to right then once going from right to left."
                    },
                    {
                        "username": "harshal1911",
                        "content": "little tricky one , but solved!!! \\n\\u2705"
                    },
                    {
                        "username": "psionl0",
                        "content": "Append the most frequent letter to the return string. If the last letter of the return string is the same as the most frequent letter then append the second most frequent letter to the string instead. If there is no second frequent letter then alternation can't be done so return an empty string.\nAs you append letters, the frequency of the remaining letters decreases and other letters may become more frequent. You will need a priority queue to keep track of the most frequent letters."
                    },
                    {
                        "username": "nihalshahria",
                        "content": "I encountered Runtime Error for a specific test case. When I test my [code](https://ideone.com/3cqX5U) using this test case in my local machine or any other online compiler, it produced the correct output. Can anyone help? \\nTest input:\\n`\"snnnnbpngobwznvnnnlnwhvnnnnfjnnlnnnnnnbnknnqkndzefncknnnnnaiqrntnndnnnjninnnunnunqhndnnqnnsjqnnpiqshntnnncnvnnnncnnqenlnninyndnnnljongnnjwnnnngllnnngkbnllnnnnontlbpngjnnenqnsnnnnnjeqqghnfpngepnodnnnnnnvnsrnughbnipvnhqmnzonoonnnjotnnonoennnpnfnnkdnnbmnmnpnqninnxronnnnvnlanlnnnebnnnlnvnfknsnbincnttnmnguqenhnnxunnnntnnnnhnqnzehvunfnvnndvnjnnnbnnpxnqipwnmnonnndlnsnonnninnxnnnjnnnnnesennmyiednnnnnnnnnhimtnnnonjlicnwnwvnntaxmnrntnnnnsnbnanninnecbcfjxncnnkvnnqgnunensanpnngjnzxjnopnnyvnnxskniyytnsnnnnx\"`\\n"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def reorganizeString(self, S: str) -> str:\\n        hash = [0] * 26\\n        for char in S:\\n            hash[ord(char) - ord(\\'a\\')] += 1\\n\\n        max_count, letter = 0, 0\\n        for i in range(len(hash)):\\n            if hash[i] > max_count:\\n                max_count = hash[i]\\n                letter = i\\n\\n        if max_count > (len(S) + 1) // 2:\\n            return \"\"\\n\\n        res = [None] * len(S)\\n        idx = 0\\n        while hash[letter] > 0:\\n            res[idx] = chr(letter + ord(\\'a\\'))\\n            idx += 2\\n            hash[letter] -= 1\\n\\n        for i in range(len(hash)):\\n            while hash[i] > 0:\\n                if idx >= len(res):\\n                    idx = 1\\n                res[idx] = chr(i + ord(\\'a\\'))\\n                idx += 2\\n                hash[i] -= 1\\n\\n        return \\'\\'.join(res)"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "nice one but don\\'t post solutions in discussion"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I couldn\\'t solve it without the hint. The solutions provided in the editorial are brilliant, particularly the second one."
                    },
                    {
                        "username": "_SID_",
                        "content": "Keep track of previous character while appending the current most frequent character"
                    },
                    {
                        "username": "singh__12",
                        "content": "Really It is very logical but when you come up with solution, it looks easy."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I find a heap helpful in solving this."
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "class Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        priority_queue<pair<int,char>> pq;\\nmap<char,int> mp;\\nstring ans=\"\";\\npair<int ,char> block{0,\\'0\\'},temp{0,\\'0\\'};\\n\\nfor(char ch:s) mp[ch]++;\\n\\n    for(auto p:mp) pq.push({p.second,p.first});\\n     block=pq.top();\\n     ans+=block.second;\\n     block.first--;\\n     pq.pop();\\n     while(pq.size()>0|| block!=NULL){\\n       if(!pq.size() && block!=NULL) return \"\";\\n       temp=pq.top();\\n       pq.pop();\\n       ans+=temp.second;\\n       temp.first--;\\n       if(block.first>0){\\n       pq.push(block);\\n       }\\n       block=temp;\\n     }\\n     \\n\\n    \\n    return ans; \\n    }\\n};\\n\\nwhy erroor????????????????????"
                    }
                ]
            },
            {
                "id": 2026660,
                "content": [
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "I thought of going with a two pointer approach, and swapping the element with the non repeating one, Like, Eg- xxxab, Then I\\'d swap the second occurance of the repeating element with a char which is different than the repeating one. But I cannot what would be a problem in this approach, Can anyone tell?"
                    },
                    {
                        "username": "trip1312",
                        "content": "That is actually exactly how I solved it. You just need to loop through it once going from left to right then once going from right to left."
                    },
                    {
                        "username": "harshal1911",
                        "content": "little tricky one , but solved!!! \\n\\u2705"
                    },
                    {
                        "username": "psionl0",
                        "content": "Append the most frequent letter to the return string. If the last letter of the return string is the same as the most frequent letter then append the second most frequent letter to the string instead. If there is no second frequent letter then alternation can't be done so return an empty string.\nAs you append letters, the frequency of the remaining letters decreases and other letters may become more frequent. You will need a priority queue to keep track of the most frequent letters."
                    },
                    {
                        "username": "nihalshahria",
                        "content": "I encountered Runtime Error for a specific test case. When I test my [code](https://ideone.com/3cqX5U) using this test case in my local machine or any other online compiler, it produced the correct output. Can anyone help? \\nTest input:\\n`\"snnnnbpngobwznvnnnlnwhvnnnnfjnnlnnnnnnbnknnqkndzefncknnnnnaiqrntnndnnnjninnnunnunqhndnnqnnsjqnnpiqshntnnncnvnnnncnnqenlnninyndnnnljongnnjwnnnngllnnngkbnllnnnnontlbpngjnnenqnsnnnnnjeqqghnfpngepnodnnnnnnvnsrnughbnipvnhqmnzonoonnnjotnnonoennnpnfnnkdnnbmnmnpnqninnxronnnnvnlanlnnnebnnnlnvnfknsnbincnttnmnguqenhnnxunnnntnnnnhnqnzehvunfnvnndvnjnnnbnnpxnqipwnmnonnndlnsnonnninnxnnnjnnnnnesennmyiednnnnnnnnnhimtnnnonjlicnwnwvnntaxmnrntnnnnsnbnanninnecbcfjxncnnkvnnqgnunensanpnngjnzxjnopnnyvnnxskniyytnsnnnnx\"`\\n"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def reorganizeString(self, S: str) -> str:\\n        hash = [0] * 26\\n        for char in S:\\n            hash[ord(char) - ord(\\'a\\')] += 1\\n\\n        max_count, letter = 0, 0\\n        for i in range(len(hash)):\\n            if hash[i] > max_count:\\n                max_count = hash[i]\\n                letter = i\\n\\n        if max_count > (len(S) + 1) // 2:\\n            return \"\"\\n\\n        res = [None] * len(S)\\n        idx = 0\\n        while hash[letter] > 0:\\n            res[idx] = chr(letter + ord(\\'a\\'))\\n            idx += 2\\n            hash[letter] -= 1\\n\\n        for i in range(len(hash)):\\n            while hash[i] > 0:\\n                if idx >= len(res):\\n                    idx = 1\\n                res[idx] = chr(i + ord(\\'a\\'))\\n                idx += 2\\n                hash[i] -= 1\\n\\n        return \\'\\'.join(res)"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "nice one but don\\'t post solutions in discussion"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I couldn\\'t solve it without the hint. The solutions provided in the editorial are brilliant, particularly the second one."
                    },
                    {
                        "username": "_SID_",
                        "content": "Keep track of previous character while appending the current most frequent character"
                    },
                    {
                        "username": "singh__12",
                        "content": "Really It is very logical but when you come up with solution, it looks easy."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I find a heap helpful in solving this."
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "class Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        priority_queue<pair<int,char>> pq;\\nmap<char,int> mp;\\nstring ans=\"\";\\npair<int ,char> block{0,\\'0\\'},temp{0,\\'0\\'};\\n\\nfor(char ch:s) mp[ch]++;\\n\\n    for(auto p:mp) pq.push({p.second,p.first});\\n     block=pq.top();\\n     ans+=block.second;\\n     block.first--;\\n     pq.pop();\\n     while(pq.size()>0|| block!=NULL){\\n       if(!pq.size() && block!=NULL) return \"\";\\n       temp=pq.top();\\n       pq.pop();\\n       ans+=temp.second;\\n       temp.first--;\\n       if(block.first>0){\\n       pq.push(block);\\n       }\\n       block=temp;\\n     }\\n     \\n\\n    \\n    return ans; \\n    }\\n};\\n\\nwhy erroor????????????????????"
                    }
                ]
            },
            {
                "id": 2026531,
                "content": [
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "I thought of going with a two pointer approach, and swapping the element with the non repeating one, Like, Eg- xxxab, Then I\\'d swap the second occurance of the repeating element with a char which is different than the repeating one. But I cannot what would be a problem in this approach, Can anyone tell?"
                    },
                    {
                        "username": "trip1312",
                        "content": "That is actually exactly how I solved it. You just need to loop through it once going from left to right then once going from right to left."
                    },
                    {
                        "username": "harshal1911",
                        "content": "little tricky one , but solved!!! \\n\\u2705"
                    },
                    {
                        "username": "psionl0",
                        "content": "Append the most frequent letter to the return string. If the last letter of the return string is the same as the most frequent letter then append the second most frequent letter to the string instead. If there is no second frequent letter then alternation can't be done so return an empty string.\nAs you append letters, the frequency of the remaining letters decreases and other letters may become more frequent. You will need a priority queue to keep track of the most frequent letters."
                    },
                    {
                        "username": "nihalshahria",
                        "content": "I encountered Runtime Error for a specific test case. When I test my [code](https://ideone.com/3cqX5U) using this test case in my local machine or any other online compiler, it produced the correct output. Can anyone help? \\nTest input:\\n`\"snnnnbpngobwznvnnnlnwhvnnnnfjnnlnnnnnnbnknnqkndzefncknnnnnaiqrntnndnnnjninnnunnunqhndnnqnnsjqnnpiqshntnnncnvnnnncnnqenlnninyndnnnljongnnjwnnnngllnnngkbnllnnnnontlbpngjnnenqnsnnnnnjeqqghnfpngepnodnnnnnnvnsrnughbnipvnhqmnzonoonnnjotnnonoennnpnfnnkdnnbmnmnpnqninnxronnnnvnlanlnnnebnnnlnvnfknsnbincnttnmnguqenhnnxunnnntnnnnhnqnzehvunfnvnndvnjnnnbnnpxnqipwnmnonnndlnsnonnninnxnnnjnnnnnesennmyiednnnnnnnnnhimtnnnonjlicnwnwvnntaxmnrntnnnnsnbnanninnecbcfjxncnnkvnnqgnunensanpnngjnzxjnopnnyvnnxskniyytnsnnnnx\"`\\n"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def reorganizeString(self, S: str) -> str:\\n        hash = [0] * 26\\n        for char in S:\\n            hash[ord(char) - ord(\\'a\\')] += 1\\n\\n        max_count, letter = 0, 0\\n        for i in range(len(hash)):\\n            if hash[i] > max_count:\\n                max_count = hash[i]\\n                letter = i\\n\\n        if max_count > (len(S) + 1) // 2:\\n            return \"\"\\n\\n        res = [None] * len(S)\\n        idx = 0\\n        while hash[letter] > 0:\\n            res[idx] = chr(letter + ord(\\'a\\'))\\n            idx += 2\\n            hash[letter] -= 1\\n\\n        for i in range(len(hash)):\\n            while hash[i] > 0:\\n                if idx >= len(res):\\n                    idx = 1\\n                res[idx] = chr(i + ord(\\'a\\'))\\n                idx += 2\\n                hash[i] -= 1\\n\\n        return \\'\\'.join(res)"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "nice one but don\\'t post solutions in discussion"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I couldn\\'t solve it without the hint. The solutions provided in the editorial are brilliant, particularly the second one."
                    },
                    {
                        "username": "_SID_",
                        "content": "Keep track of previous character while appending the current most frequent character"
                    },
                    {
                        "username": "singh__12",
                        "content": "Really It is very logical but when you come up with solution, it looks easy."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I find a heap helpful in solving this."
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "class Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        priority_queue<pair<int,char>> pq;\\nmap<char,int> mp;\\nstring ans=\"\";\\npair<int ,char> block{0,\\'0\\'},temp{0,\\'0\\'};\\n\\nfor(char ch:s) mp[ch]++;\\n\\n    for(auto p:mp) pq.push({p.second,p.first});\\n     block=pq.top();\\n     ans+=block.second;\\n     block.first--;\\n     pq.pop();\\n     while(pq.size()>0|| block!=NULL){\\n       if(!pq.size() && block!=NULL) return \"\";\\n       temp=pq.top();\\n       pq.pop();\\n       ans+=temp.second;\\n       temp.first--;\\n       if(block.first>0){\\n       pq.push(block);\\n       }\\n       block=temp;\\n     }\\n     \\n\\n    \\n    return ans; \\n    }\\n};\\n\\nwhy erroor????????????????????"
                    }
                ]
            },
            {
                "id": 2026525,
                "content": [
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "I thought of going with a two pointer approach, and swapping the element with the non repeating one, Like, Eg- xxxab, Then I\\'d swap the second occurance of the repeating element with a char which is different than the repeating one. But I cannot what would be a problem in this approach, Can anyone tell?"
                    },
                    {
                        "username": "trip1312",
                        "content": "That is actually exactly how I solved it. You just need to loop through it once going from left to right then once going from right to left."
                    },
                    {
                        "username": "harshal1911",
                        "content": "little tricky one , but solved!!! \\n\\u2705"
                    },
                    {
                        "username": "psionl0",
                        "content": "Append the most frequent letter to the return string. If the last letter of the return string is the same as the most frequent letter then append the second most frequent letter to the string instead. If there is no second frequent letter then alternation can't be done so return an empty string.\nAs you append letters, the frequency of the remaining letters decreases and other letters may become more frequent. You will need a priority queue to keep track of the most frequent letters."
                    },
                    {
                        "username": "nihalshahria",
                        "content": "I encountered Runtime Error for a specific test case. When I test my [code](https://ideone.com/3cqX5U) using this test case in my local machine or any other online compiler, it produced the correct output. Can anyone help? \\nTest input:\\n`\"snnnnbpngobwznvnnnlnwhvnnnnfjnnlnnnnnnbnknnqkndzefncknnnnnaiqrntnndnnnjninnnunnunqhndnnqnnsjqnnpiqshntnnncnvnnnncnnqenlnninyndnnnljongnnjwnnnngllnnngkbnllnnnnontlbpngjnnenqnsnnnnnjeqqghnfpngepnodnnnnnnvnsrnughbnipvnhqmnzonoonnnjotnnonoennnpnfnnkdnnbmnmnpnqninnxronnnnvnlanlnnnebnnnlnvnfknsnbincnttnmnguqenhnnxunnnntnnnnhnqnzehvunfnvnndvnjnnnbnnpxnqipwnmnonnndlnsnonnninnxnnnjnnnnnesennmyiednnnnnnnnnhimtnnnonjlicnwnwvnntaxmnrntnnnnsnbnanninnecbcfjxncnnkvnnqgnunensanpnngjnzxjnopnnyvnnxskniyytnsnnnnx\"`\\n"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def reorganizeString(self, S: str) -> str:\\n        hash = [0] * 26\\n        for char in S:\\n            hash[ord(char) - ord(\\'a\\')] += 1\\n\\n        max_count, letter = 0, 0\\n        for i in range(len(hash)):\\n            if hash[i] > max_count:\\n                max_count = hash[i]\\n                letter = i\\n\\n        if max_count > (len(S) + 1) // 2:\\n            return \"\"\\n\\n        res = [None] * len(S)\\n        idx = 0\\n        while hash[letter] > 0:\\n            res[idx] = chr(letter + ord(\\'a\\'))\\n            idx += 2\\n            hash[letter] -= 1\\n\\n        for i in range(len(hash)):\\n            while hash[i] > 0:\\n                if idx >= len(res):\\n                    idx = 1\\n                res[idx] = chr(i + ord(\\'a\\'))\\n                idx += 2\\n                hash[i] -= 1\\n\\n        return \\'\\'.join(res)"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "nice one but don\\'t post solutions in discussion"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I couldn\\'t solve it without the hint. The solutions provided in the editorial are brilliant, particularly the second one."
                    },
                    {
                        "username": "_SID_",
                        "content": "Keep track of previous character while appending the current most frequent character"
                    },
                    {
                        "username": "singh__12",
                        "content": "Really It is very logical but when you come up with solution, it looks easy."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I find a heap helpful in solving this."
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "class Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        priority_queue<pair<int,char>> pq;\\nmap<char,int> mp;\\nstring ans=\"\";\\npair<int ,char> block{0,\\'0\\'},temp{0,\\'0\\'};\\n\\nfor(char ch:s) mp[ch]++;\\n\\n    for(auto p:mp) pq.push({p.second,p.first});\\n     block=pq.top();\\n     ans+=block.second;\\n     block.first--;\\n     pq.pop();\\n     while(pq.size()>0|| block!=NULL){\\n       if(!pq.size() && block!=NULL) return \"\";\\n       temp=pq.top();\\n       pq.pop();\\n       ans+=temp.second;\\n       temp.first--;\\n       if(block.first>0){\\n       pq.push(block);\\n       }\\n       block=temp;\\n     }\\n     \\n\\n    \\n    return ans; \\n    }\\n};\\n\\nwhy erroor????????????????????"
                    }
                ]
            },
            {
                "id": 2026498,
                "content": [
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "I thought of going with a two pointer approach, and swapping the element with the non repeating one, Like, Eg- xxxab, Then I\\'d swap the second occurance of the repeating element with a char which is different than the repeating one. But I cannot what would be a problem in this approach, Can anyone tell?"
                    },
                    {
                        "username": "trip1312",
                        "content": "That is actually exactly how I solved it. You just need to loop through it once going from left to right then once going from right to left."
                    },
                    {
                        "username": "harshal1911",
                        "content": "little tricky one , but solved!!! \\n\\u2705"
                    },
                    {
                        "username": "psionl0",
                        "content": "Append the most frequent letter to the return string. If the last letter of the return string is the same as the most frequent letter then append the second most frequent letter to the string instead. If there is no second frequent letter then alternation can't be done so return an empty string.\nAs you append letters, the frequency of the remaining letters decreases and other letters may become more frequent. You will need a priority queue to keep track of the most frequent letters."
                    },
                    {
                        "username": "nihalshahria",
                        "content": "I encountered Runtime Error for a specific test case. When I test my [code](https://ideone.com/3cqX5U) using this test case in my local machine or any other online compiler, it produced the correct output. Can anyone help? \\nTest input:\\n`\"snnnnbpngobwznvnnnlnwhvnnnnfjnnlnnnnnnbnknnqkndzefncknnnnnaiqrntnndnnnjninnnunnunqhndnnqnnsjqnnpiqshntnnncnvnnnncnnqenlnninyndnnnljongnnjwnnnngllnnngkbnllnnnnontlbpngjnnenqnsnnnnnjeqqghnfpngepnodnnnnnnvnsrnughbnipvnhqmnzonoonnnjotnnonoennnpnfnnkdnnbmnmnpnqninnxronnnnvnlanlnnnebnnnlnvnfknsnbincnttnmnguqenhnnxunnnntnnnnhnqnzehvunfnvnndvnjnnnbnnpxnqipwnmnonnndlnsnonnninnxnnnjnnnnnesennmyiednnnnnnnnnhimtnnnonjlicnwnwvnntaxmnrntnnnnsnbnanninnecbcfjxncnnkvnnqgnunensanpnngjnzxjnopnnyvnnxskniyytnsnnnnx\"`\\n"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def reorganizeString(self, S: str) -> str:\\n        hash = [0] * 26\\n        for char in S:\\n            hash[ord(char) - ord(\\'a\\')] += 1\\n\\n        max_count, letter = 0, 0\\n        for i in range(len(hash)):\\n            if hash[i] > max_count:\\n                max_count = hash[i]\\n                letter = i\\n\\n        if max_count > (len(S) + 1) // 2:\\n            return \"\"\\n\\n        res = [None] * len(S)\\n        idx = 0\\n        while hash[letter] > 0:\\n            res[idx] = chr(letter + ord(\\'a\\'))\\n            idx += 2\\n            hash[letter] -= 1\\n\\n        for i in range(len(hash)):\\n            while hash[i] > 0:\\n                if idx >= len(res):\\n                    idx = 1\\n                res[idx] = chr(i + ord(\\'a\\'))\\n                idx += 2\\n                hash[i] -= 1\\n\\n        return \\'\\'.join(res)"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "nice one but don\\'t post solutions in discussion"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I couldn\\'t solve it without the hint. The solutions provided in the editorial are brilliant, particularly the second one."
                    },
                    {
                        "username": "_SID_",
                        "content": "Keep track of previous character while appending the current most frequent character"
                    },
                    {
                        "username": "singh__12",
                        "content": "Really It is very logical but when you come up with solution, it looks easy."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I find a heap helpful in solving this."
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "class Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        priority_queue<pair<int,char>> pq;\\nmap<char,int> mp;\\nstring ans=\"\";\\npair<int ,char> block{0,\\'0\\'},temp{0,\\'0\\'};\\n\\nfor(char ch:s) mp[ch]++;\\n\\n    for(auto p:mp) pq.push({p.second,p.first});\\n     block=pq.top();\\n     ans+=block.second;\\n     block.first--;\\n     pq.pop();\\n     while(pq.size()>0|| block!=NULL){\\n       if(!pq.size() && block!=NULL) return \"\";\\n       temp=pq.top();\\n       pq.pop();\\n       ans+=temp.second;\\n       temp.first--;\\n       if(block.first>0){\\n       pq.push(block);\\n       }\\n       block=temp;\\n     }\\n     \\n\\n    \\n    return ans; \\n    }\\n};\\n\\nwhy erroor????????????????????"
                    }
                ]
            },
            {
                "id": 2026475,
                "content": [
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "I thought of going with a two pointer approach, and swapping the element with the non repeating one, Like, Eg- xxxab, Then I\\'d swap the second occurance of the repeating element with a char which is different than the repeating one. But I cannot what would be a problem in this approach, Can anyone tell?"
                    },
                    {
                        "username": "trip1312",
                        "content": "That is actually exactly how I solved it. You just need to loop through it once going from left to right then once going from right to left."
                    },
                    {
                        "username": "harshal1911",
                        "content": "little tricky one , but solved!!! \\n\\u2705"
                    },
                    {
                        "username": "psionl0",
                        "content": "Append the most frequent letter to the return string. If the last letter of the return string is the same as the most frequent letter then append the second most frequent letter to the string instead. If there is no second frequent letter then alternation can't be done so return an empty string.\nAs you append letters, the frequency of the remaining letters decreases and other letters may become more frequent. You will need a priority queue to keep track of the most frequent letters."
                    },
                    {
                        "username": "nihalshahria",
                        "content": "I encountered Runtime Error for a specific test case. When I test my [code](https://ideone.com/3cqX5U) using this test case in my local machine or any other online compiler, it produced the correct output. Can anyone help? \\nTest input:\\n`\"snnnnbpngobwznvnnnlnwhvnnnnfjnnlnnnnnnbnknnqkndzefncknnnnnaiqrntnndnnnjninnnunnunqhndnnqnnsjqnnpiqshntnnncnvnnnncnnqenlnninyndnnnljongnnjwnnnngllnnngkbnllnnnnontlbpngjnnenqnsnnnnnjeqqghnfpngepnodnnnnnnvnsrnughbnipvnhqmnzonoonnnjotnnonoennnpnfnnkdnnbmnmnpnqninnxronnnnvnlanlnnnebnnnlnvnfknsnbincnttnmnguqenhnnxunnnntnnnnhnqnzehvunfnvnndvnjnnnbnnpxnqipwnmnonnndlnsnonnninnxnnnjnnnnnesennmyiednnnnnnnnnhimtnnnonjlicnwnwvnntaxmnrntnnnnsnbnanninnecbcfjxncnnkvnnqgnunensanpnngjnzxjnopnnyvnnxskniyytnsnnnnx\"`\\n"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def reorganizeString(self, S: str) -> str:\\n        hash = [0] * 26\\n        for char in S:\\n            hash[ord(char) - ord(\\'a\\')] += 1\\n\\n        max_count, letter = 0, 0\\n        for i in range(len(hash)):\\n            if hash[i] > max_count:\\n                max_count = hash[i]\\n                letter = i\\n\\n        if max_count > (len(S) + 1) // 2:\\n            return \"\"\\n\\n        res = [None] * len(S)\\n        idx = 0\\n        while hash[letter] > 0:\\n            res[idx] = chr(letter + ord(\\'a\\'))\\n            idx += 2\\n            hash[letter] -= 1\\n\\n        for i in range(len(hash)):\\n            while hash[i] > 0:\\n                if idx >= len(res):\\n                    idx = 1\\n                res[idx] = chr(i + ord(\\'a\\'))\\n                idx += 2\\n                hash[i] -= 1\\n\\n        return \\'\\'.join(res)"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "nice one but don\\'t post solutions in discussion"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I couldn\\'t solve it without the hint. The solutions provided in the editorial are brilliant, particularly the second one."
                    },
                    {
                        "username": "_SID_",
                        "content": "Keep track of previous character while appending the current most frequent character"
                    },
                    {
                        "username": "singh__12",
                        "content": "Really It is very logical but when you come up with solution, it looks easy."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I find a heap helpful in solving this."
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "class Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        priority_queue<pair<int,char>> pq;\\nmap<char,int> mp;\\nstring ans=\"\";\\npair<int ,char> block{0,\\'0\\'},temp{0,\\'0\\'};\\n\\nfor(char ch:s) mp[ch]++;\\n\\n    for(auto p:mp) pq.push({p.second,p.first});\\n     block=pq.top();\\n     ans+=block.second;\\n     block.first--;\\n     pq.pop();\\n     while(pq.size()>0|| block!=NULL){\\n       if(!pq.size() && block!=NULL) return \"\";\\n       temp=pq.top();\\n       pq.pop();\\n       ans+=temp.second;\\n       temp.first--;\\n       if(block.first>0){\\n       pq.push(block);\\n       }\\n       block=temp;\\n     }\\n     \\n\\n    \\n    return ans; \\n    }\\n};\\n\\nwhy erroor????????????????????"
                    }
                ]
            },
            {
                "id": 2026312,
                "content": [
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "I thought of going with a two pointer approach, and swapping the element with the non repeating one, Like, Eg- xxxab, Then I\\'d swap the second occurance of the repeating element with a char which is different than the repeating one. But I cannot what would be a problem in this approach, Can anyone tell?"
                    },
                    {
                        "username": "trip1312",
                        "content": "That is actually exactly how I solved it. You just need to loop through it once going from left to right then once going from right to left."
                    },
                    {
                        "username": "harshal1911",
                        "content": "little tricky one , but solved!!! \\n\\u2705"
                    },
                    {
                        "username": "psionl0",
                        "content": "Append the most frequent letter to the return string. If the last letter of the return string is the same as the most frequent letter then append the second most frequent letter to the string instead. If there is no second frequent letter then alternation can't be done so return an empty string.\nAs you append letters, the frequency of the remaining letters decreases and other letters may become more frequent. You will need a priority queue to keep track of the most frequent letters."
                    },
                    {
                        "username": "nihalshahria",
                        "content": "I encountered Runtime Error for a specific test case. When I test my [code](https://ideone.com/3cqX5U) using this test case in my local machine or any other online compiler, it produced the correct output. Can anyone help? \\nTest input:\\n`\"snnnnbpngobwznvnnnlnwhvnnnnfjnnlnnnnnnbnknnqkndzefncknnnnnaiqrntnndnnnjninnnunnunqhndnnqnnsjqnnpiqshntnnncnvnnnncnnqenlnninyndnnnljongnnjwnnnngllnnngkbnllnnnnontlbpngjnnenqnsnnnnnjeqqghnfpngepnodnnnnnnvnsrnughbnipvnhqmnzonoonnnjotnnonoennnpnfnnkdnnbmnmnpnqninnxronnnnvnlanlnnnebnnnlnvnfknsnbincnttnmnguqenhnnxunnnntnnnnhnqnzehvunfnvnndvnjnnnbnnpxnqipwnmnonnndlnsnonnninnxnnnjnnnnnesennmyiednnnnnnnnnhimtnnnonjlicnwnwvnntaxmnrntnnnnsnbnanninnecbcfjxncnnkvnnqgnunensanpnngjnzxjnopnnyvnnxskniyytnsnnnnx\"`\\n"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def reorganizeString(self, S: str) -> str:\\n        hash = [0] * 26\\n        for char in S:\\n            hash[ord(char) - ord(\\'a\\')] += 1\\n\\n        max_count, letter = 0, 0\\n        for i in range(len(hash)):\\n            if hash[i] > max_count:\\n                max_count = hash[i]\\n                letter = i\\n\\n        if max_count > (len(S) + 1) // 2:\\n            return \"\"\\n\\n        res = [None] * len(S)\\n        idx = 0\\n        while hash[letter] > 0:\\n            res[idx] = chr(letter + ord(\\'a\\'))\\n            idx += 2\\n            hash[letter] -= 1\\n\\n        for i in range(len(hash)):\\n            while hash[i] > 0:\\n                if idx >= len(res):\\n                    idx = 1\\n                res[idx] = chr(i + ord(\\'a\\'))\\n                idx += 2\\n                hash[i] -= 1\\n\\n        return \\'\\'.join(res)"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "nice one but don\\'t post solutions in discussion"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I couldn\\'t solve it without the hint. The solutions provided in the editorial are brilliant, particularly the second one."
                    },
                    {
                        "username": "_SID_",
                        "content": "Keep track of previous character while appending the current most frequent character"
                    },
                    {
                        "username": "singh__12",
                        "content": "Really It is very logical but when you come up with solution, it looks easy."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I find a heap helpful in solving this."
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "class Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        priority_queue<pair<int,char>> pq;\\nmap<char,int> mp;\\nstring ans=\"\";\\npair<int ,char> block{0,\\'0\\'},temp{0,\\'0\\'};\\n\\nfor(char ch:s) mp[ch]++;\\n\\n    for(auto p:mp) pq.push({p.second,p.first});\\n     block=pq.top();\\n     ans+=block.second;\\n     block.first--;\\n     pq.pop();\\n     while(pq.size()>0|| block!=NULL){\\n       if(!pq.size() && block!=NULL) return \"\";\\n       temp=pq.top();\\n       pq.pop();\\n       ans+=temp.second;\\n       temp.first--;\\n       if(block.first>0){\\n       pq.push(block);\\n       }\\n       block=temp;\\n     }\\n     \\n\\n    \\n    return ans; \\n    }\\n};\\n\\nwhy erroor????????????????????"
                    }
                ]
            },
            {
                "id": 2026298,
                "content": [
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "I thought of going with a two pointer approach, and swapping the element with the non repeating one, Like, Eg- xxxab, Then I\\'d swap the second occurance of the repeating element with a char which is different than the repeating one. But I cannot what would be a problem in this approach, Can anyone tell?"
                    },
                    {
                        "username": "trip1312",
                        "content": "That is actually exactly how I solved it. You just need to loop through it once going from left to right then once going from right to left."
                    },
                    {
                        "username": "harshal1911",
                        "content": "little tricky one , but solved!!! \\n\\u2705"
                    },
                    {
                        "username": "psionl0",
                        "content": "Append the most frequent letter to the return string. If the last letter of the return string is the same as the most frequent letter then append the second most frequent letter to the string instead. If there is no second frequent letter then alternation can't be done so return an empty string.\nAs you append letters, the frequency of the remaining letters decreases and other letters may become more frequent. You will need a priority queue to keep track of the most frequent letters."
                    },
                    {
                        "username": "nihalshahria",
                        "content": "I encountered Runtime Error for a specific test case. When I test my [code](https://ideone.com/3cqX5U) using this test case in my local machine or any other online compiler, it produced the correct output. Can anyone help? \\nTest input:\\n`\"snnnnbpngobwznvnnnlnwhvnnnnfjnnlnnnnnnbnknnqkndzefncknnnnnaiqrntnndnnnjninnnunnunqhndnnqnnsjqnnpiqshntnnncnvnnnncnnqenlnninyndnnnljongnnjwnnnngllnnngkbnllnnnnontlbpngjnnenqnsnnnnnjeqqghnfpngepnodnnnnnnvnsrnughbnipvnhqmnzonoonnnjotnnonoennnpnfnnkdnnbmnmnpnqninnxronnnnvnlanlnnnebnnnlnvnfknsnbincnttnmnguqenhnnxunnnntnnnnhnqnzehvunfnvnndvnjnnnbnnpxnqipwnmnonnndlnsnonnninnxnnnjnnnnnesennmyiednnnnnnnnnhimtnnnonjlicnwnwvnntaxmnrntnnnnsnbnanninnecbcfjxncnnkvnnqgnunensanpnngjnzxjnopnnyvnnxskniyytnsnnnnx\"`\\n"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def reorganizeString(self, S: str) -> str:\\n        hash = [0] * 26\\n        for char in S:\\n            hash[ord(char) - ord(\\'a\\')] += 1\\n\\n        max_count, letter = 0, 0\\n        for i in range(len(hash)):\\n            if hash[i] > max_count:\\n                max_count = hash[i]\\n                letter = i\\n\\n        if max_count > (len(S) + 1) // 2:\\n            return \"\"\\n\\n        res = [None] * len(S)\\n        idx = 0\\n        while hash[letter] > 0:\\n            res[idx] = chr(letter + ord(\\'a\\'))\\n            idx += 2\\n            hash[letter] -= 1\\n\\n        for i in range(len(hash)):\\n            while hash[i] > 0:\\n                if idx >= len(res):\\n                    idx = 1\\n                res[idx] = chr(i + ord(\\'a\\'))\\n                idx += 2\\n                hash[i] -= 1\\n\\n        return \\'\\'.join(res)"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "nice one but don\\'t post solutions in discussion"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I couldn\\'t solve it without the hint. The solutions provided in the editorial are brilliant, particularly the second one."
                    },
                    {
                        "username": "_SID_",
                        "content": "Keep track of previous character while appending the current most frequent character"
                    },
                    {
                        "username": "singh__12",
                        "content": "Really It is very logical but when you come up with solution, it looks easy."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I find a heap helpful in solving this."
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "class Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        priority_queue<pair<int,char>> pq;\\nmap<char,int> mp;\\nstring ans=\"\";\\npair<int ,char> block{0,\\'0\\'},temp{0,\\'0\\'};\\n\\nfor(char ch:s) mp[ch]++;\\n\\n    for(auto p:mp) pq.push({p.second,p.first});\\n     block=pq.top();\\n     ans+=block.second;\\n     block.first--;\\n     pq.pop();\\n     while(pq.size()>0|| block!=NULL){\\n       if(!pq.size() && block!=NULL) return \"\";\\n       temp=pq.top();\\n       pq.pop();\\n       ans+=temp.second;\\n       temp.first--;\\n       if(block.first>0){\\n       pq.push(block);\\n       }\\n       block=temp;\\n     }\\n     \\n\\n    \\n    return ans; \\n    }\\n};\\n\\nwhy erroor????????????????????"
                    }
                ]
            },
            {
                "id": 1935924,
                "content": [
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "I thought of going with a two pointer approach, and swapping the element with the non repeating one, Like, Eg- xxxab, Then I\\'d swap the second occurance of the repeating element with a char which is different than the repeating one. But I cannot what would be a problem in this approach, Can anyone tell?"
                    },
                    {
                        "username": "trip1312",
                        "content": "That is actually exactly how I solved it. You just need to loop through it once going from left to right then once going from right to left."
                    },
                    {
                        "username": "harshal1911",
                        "content": "little tricky one , but solved!!! \\n\\u2705"
                    },
                    {
                        "username": "psionl0",
                        "content": "Append the most frequent letter to the return string. If the last letter of the return string is the same as the most frequent letter then append the second most frequent letter to the string instead. If there is no second frequent letter then alternation can't be done so return an empty string.\nAs you append letters, the frequency of the remaining letters decreases and other letters may become more frequent. You will need a priority queue to keep track of the most frequent letters."
                    },
                    {
                        "username": "nihalshahria",
                        "content": "I encountered Runtime Error for a specific test case. When I test my [code](https://ideone.com/3cqX5U) using this test case in my local machine or any other online compiler, it produced the correct output. Can anyone help? \\nTest input:\\n`\"snnnnbpngobwznvnnnlnwhvnnnnfjnnlnnnnnnbnknnqkndzefncknnnnnaiqrntnndnnnjninnnunnunqhndnnqnnsjqnnpiqshntnnncnvnnnncnnqenlnninyndnnnljongnnjwnnnngllnnngkbnllnnnnontlbpngjnnenqnsnnnnnjeqqghnfpngepnodnnnnnnvnsrnughbnipvnhqmnzonoonnnjotnnonoennnpnfnnkdnnbmnmnpnqninnxronnnnvnlanlnnnebnnnlnvnfknsnbincnttnmnguqenhnnxunnnntnnnnhnqnzehvunfnvnndvnjnnnbnnpxnqipwnmnonnndlnsnonnninnxnnnjnnnnnesennmyiednnnnnnnnnhimtnnnonjlicnwnwvnntaxmnrntnnnnsnbnanninnecbcfjxncnnkvnnqgnunensanpnngjnzxjnopnnyvnnxskniyytnsnnnnx\"`\\n"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def reorganizeString(self, S: str) -> str:\\n        hash = [0] * 26\\n        for char in S:\\n            hash[ord(char) - ord(\\'a\\')] += 1\\n\\n        max_count, letter = 0, 0\\n        for i in range(len(hash)):\\n            if hash[i] > max_count:\\n                max_count = hash[i]\\n                letter = i\\n\\n        if max_count > (len(S) + 1) // 2:\\n            return \"\"\\n\\n        res = [None] * len(S)\\n        idx = 0\\n        while hash[letter] > 0:\\n            res[idx] = chr(letter + ord(\\'a\\'))\\n            idx += 2\\n            hash[letter] -= 1\\n\\n        for i in range(len(hash)):\\n            while hash[i] > 0:\\n                if idx >= len(res):\\n                    idx = 1\\n                res[idx] = chr(i + ord(\\'a\\'))\\n                idx += 2\\n                hash[i] -= 1\\n\\n        return \\'\\'.join(res)"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "nice one but don\\'t post solutions in discussion"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I couldn\\'t solve it without the hint. The solutions provided in the editorial are brilliant, particularly the second one."
                    },
                    {
                        "username": "_SID_",
                        "content": "Keep track of previous character while appending the current most frequent character"
                    },
                    {
                        "username": "singh__12",
                        "content": "Really It is very logical but when you come up with solution, it looks easy."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I find a heap helpful in solving this."
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "class Solution {\\npublic:\\n    string reorganizeString(string s) {\\n        priority_queue<pair<int,char>> pq;\\nmap<char,int> mp;\\nstring ans=\"\";\\npair<int ,char> block{0,\\'0\\'},temp{0,\\'0\\'};\\n\\nfor(char ch:s) mp[ch]++;\\n\\n    for(auto p:mp) pq.push({p.second,p.first});\\n     block=pq.top();\\n     ans+=block.second;\\n     block.first--;\\n     pq.pop();\\n     while(pq.size()>0|| block!=NULL){\\n       if(!pq.size() && block!=NULL) return \"\";\\n       temp=pq.top();\\n       pq.pop();\\n       ans+=temp.second;\\n       temp.first--;\\n       if(block.first>0){\\n       pq.push(block);\\n       }\\n       block=temp;\\n     }\\n     \\n\\n    \\n    return ans; \\n    }\\n};\\n\\nwhy erroor????????????????????"
                    }
                ]
            }
        ]
    }
]